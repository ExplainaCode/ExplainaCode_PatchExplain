record_number,buggy_code,fixed_code,code_similarity
56001,"/** 
 * Creates a new management graph iterator. This constructor can be used to traverse only specific parts of the graph starting at <code>startVertex</code>. The iterator will not switch to the next input/output vertex of an output/input vertex has been reached.
 * @param managementGraph the management graph that should be traversed
 * @param startVertex the vertex to start the traversal from
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 */
public ManagementGraphIterator(final ManagementGraph managementGraph,final ManagementVertex startVertex,final boolean forward){
  this.managementGraph=managementGraph;
  this.forward=forward;
  this.numVisitedEntryVertices=-1;
  this.startStage=0;
  this.confinedToStage=false;
  final TraversalEntry te=new TraversalEntry(startVertex,0,0);
  traversalStack.push(te);
}","/** 
 * Creates a new management graph iterator. This constructor can be used to traverse only specific parts of the graph starting at <code>startVertex</code>. The iterator will not switch to the next input/output vertex of an output/input vertex has been reached.
 * @param managementGraph the management graph that should be traversed
 * @param startVertex the vertex to start the traversal from
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 */
public ManagementGraphIterator(final ManagementGraph managementGraph,final ManagementVertex startVertex,final boolean forward){
  this.managementGraph=managementGraph;
  this.forward=forward;
  this.numVisitedEntryVertices=-1;
  this.startStage=0;
  this.confinedToStage=false;
  final TraversalEntry te=new TraversalEntry(startVertex,0,0);
  this.traversalStack.push(te);
  this.alreadyVisited.add(te.getManagementVertex());
}",0.96908315565032
56002,"/** 
 * {@inheritDoc}
 */
@Override public ManagementGroupVertex next(){
  if (this.traversalStack.isEmpty()) {
    final TraversalEntry newentry=new TraversalEntry(this.entryVertices.get(this.numVisitedEntryVertices),0);
    this.traversalStack.push(newentry);
  }
  final ManagementGroupVertex returnVertex=this.traversalStack.peek().getGroupVertex();
  do {
    final TraversalEntry te=this.traversalStack.peek();
    final ManagementGroupVertex candidateVertex=getCandidateVertex(te,forward);
    if (candidateVertex == null) {
      this.traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0);
      this.traversalStack.add(newte);
      break;
    }
  }
 while (!this.traversalStack.isEmpty());
  this.alreadyVisited.add(returnVertex);
  return returnVertex;
}","/** 
 * {@inheritDoc}
 */
@Override public ManagementGroupVertex next(){
  if (this.traversalStack.isEmpty()) {
    final TraversalEntry newentry=new TraversalEntry(this.entryVertices.get(this.numVisitedEntryVertices),0);
    this.traversalStack.push(newentry);
    this.alreadyVisited.add(newentry.getGroupVertex());
  }
  final ManagementGroupVertex returnVertex=this.traversalStack.peek().getGroupVertex();
  do {
    final TraversalEntry te=this.traversalStack.peek();
    final ManagementGroupVertex candidateVertex=getCandidateVertex(te,forward);
    if (candidateVertex == null) {
      this.traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0);
      this.traversalStack.push(newte);
      this.alreadyVisited.add(newte.getGroupVertex());
      break;
    }
  }
 while (!this.traversalStack.isEmpty());
  return returnVertex;
}",0.8998242530755711
56003,"/** 
 * Collects all input group vertices (i.e. vertices with no incoming edge or incoming edges from other stages) in the given stage and adds them to an internal list.
 * @param stage the number of the stage whose input vertices should be collected
 */
private void collectStartVertices(final ManagementStage stage){
  for (int i=0; i < stage.getNumberOfGroupVertices(); i++) {
    final ManagementGroupVertex groupVertex=stage.getGroupVertex(i);
    if (forward) {
      if ((groupVertex.getNumberOfBackwardEdges() == 0) || ((this.stage >= 0) && allConnectionsFromOtherStage(groupVertex,true))) {
        this.entryVertices.add(groupVertex);
      }
    }
 else {
      if ((groupVertex.getNumberOfForwardEdges() == 0) || ((this.stage >= 0) && allConnectionsFromOtherStage(groupVertex,false))) {
        this.entryVertices.add(groupVertex);
      }
    }
  }
}","/** 
 * Collects all input group vertices (i.e. vertices with no incoming edge or incoming edges from other stages) in the given stage and adds them to an internal list.
 * @param stage the number of the stage whose input vertices should be collected
 */
private void collectStartVertices(final ManagementStage stage){
  for (int i=0; i < stage.getNumberOfGroupVertices(); i++) {
    final ManagementGroupVertex groupVertex=stage.getGroupVertex(i);
    if (this.forward) {
      if ((groupVertex.getNumberOfBackwardEdges() == 0) || ((this.stage >= 0) && allConnectionsFromOtherStage(groupVertex,true))) {
        this.entryVertices.add(groupVertex);
      }
    }
 else {
      if ((groupVertex.getNumberOfForwardEdges() == 0) || ((this.stage >= 0) && allConnectionsFromOtherStage(groupVertex,false))) {
        this.entryVertices.add(groupVertex);
      }
    }
  }
}",0.9971114962449452
56004,"/** 
 * Creates a new management group vertex iterator.
 * @param managementGraph the management graph that should be traversed
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 * @param stage the number of the stage whose vertices should be traversed or -1 if all stages should be included in the traversal
 */
public ManagementGroupVertexIterator(final ManagementGraph managementGraph,final boolean forward,final int stage){
  this.forward=forward;
  this.stage=stage;
  if (stage < 0) {
    for (int i=0; i < managementGraph.getNumberOfStages(); i++) {
      collectStartVertices(managementGraph.getStage(i));
    }
  }
 else {
    if (stage < managementGraph.getNumberOfStages()) {
      collectStartVertices(managementGraph.getStage(stage));
    }
  }
  if (this.entryVertices.size() > 0) {
    final TraversalEntry te=new TraversalEntry(this.entryVertices.get(0),0);
    this.traversalStack.push(te);
  }
}","/** 
 * Creates a new management group vertex iterator.
 * @param managementGraph the management graph that should be traversed
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 * @param stage the number of the stage whose vertices should be traversed or -1 if all stages should be included in the traversal
 */
public ManagementGroupVertexIterator(final ManagementGraph managementGraph,final boolean forward,final int stage){
  this.forward=forward;
  this.stage=stage;
  if (stage < 0) {
    for (int i=0; i < managementGraph.getNumberOfStages(); i++) {
      collectStartVertices(managementGraph.getStage(i));
    }
  }
 else {
    if (stage < managementGraph.getNumberOfStages()) {
      collectStartVertices(managementGraph.getStage(stage));
    }
  }
  if (this.entryVertices.size() > 0) {
    final TraversalEntry te=new TraversalEntry(this.entryVertices.get(0),0);
    this.traversalStack.push(te);
    this.alreadyVisited.add(te.getGroupVertex());
  }
}",0.975609756097561
56005,"/** 
 * {@inheritDoc}
 */
@Override public ExecutionVertex next(){
  if (traversalStack.isEmpty()) {
    if (numVisitedEntryVertices < 0) {
      return null;
    }
    TraversalEntry newentry;
    if (forward) {
      newentry=new TraversalEntry(executionGraph.getInputVertex(this.startStage,numVisitedEntryVertices),0,0);
    }
 else {
      newentry=new TraversalEntry(executionGraph.getOutputVertex(this.startStage,numVisitedEntryVertices),0,0);
    }
    traversalStack.push(newentry);
  }
  final ExecutionVertex returnVertex=traversalStack.peek().getExecutionVertex();
  do {
    final TraversalEntry te=traversalStack.peek();
    final ExecutionVertex candidateVertex=getCandidateVertex(te,forward);
    if (candidateVertex == null) {
      traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0,0);
      traversalStack.add(newte);
      break;
    }
  }
 while (!traversalStack.isEmpty());
  alreadyVisited.add(returnVertex);
  return returnVertex;
}","/** 
 * {@inheritDoc}
 */
@Override public ExecutionVertex next(){
  if (this.traversalStack.isEmpty()) {
    if (this.numVisitedEntryVertices < 0) {
      return null;
    }
    TraversalEntry newentry;
    if (this.forward) {
      newentry=new TraversalEntry(this.executionGraph.getInputVertex(this.startStage,this.numVisitedEntryVertices),0,0);
    }
 else {
      newentry=new TraversalEntry(this.executionGraph.getOutputVertex(this.startStage,this.numVisitedEntryVertices),0,0);
    }
    this.traversalStack.push(newentry);
    this.alreadyVisited.add(newentry.getExecutionVertex());
  }
  final ExecutionVertex returnVertex=this.traversalStack.peek().getExecutionVertex();
  do {
    final TraversalEntry te=this.traversalStack.peek();
    final ExecutionVertex candidateVertex=getCandidateVertex(te,forward);
    if (candidateVertex == null) {
      this.traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0,0);
      this.traversalStack.push(newte);
      this.alreadyVisited.add(candidateVertex);
      break;
    }
  }
 while (!this.traversalStack.isEmpty());
  return returnVertex;
}",0.8944444444444445
56006,"/** 
 * Creates a new execution graph iterator. This constructor can be used to traverse only specific parts of the graph starting at <code>startVertex</code>. The iterator will not switch to the next input/output vertex of an output/input vertex has been reached.
 * @param executionGraph the execution graph that should be traversed
 * @param startVertex the vertex to start the traversal from
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 */
public ExecutionGraphIterator(ExecutionGraph executionGraph,ExecutionVertex startVertex,boolean forward){
  this.executionGraph=executionGraph;
  this.forward=forward;
  this.numVisitedEntryVertices=-1;
  this.startStage=0;
  this.confinedToStage=false;
  final TraversalEntry te=new TraversalEntry(startVertex,0,0);
  traversalStack.push(te);
}","/** 
 * Creates a new execution graph iterator. This constructor can be used to traverse only specific parts of the graph starting at <code>startVertex</code>. The iterator will not switch to the next input/output vertex of an output/input vertex has been reached.
 * @param executionGraph the execution graph that should be traversed
 * @param startVertex the vertex to start the traversal from
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 */
public ExecutionGraphIterator(ExecutionGraph executionGraph,ExecutionVertex startVertex,boolean forward){
  this.executionGraph=executionGraph;
  this.forward=forward;
  this.numVisitedEntryVertices=-1;
  this.startStage=0;
  this.confinedToStage=false;
  final TraversalEntry te=new TraversalEntry(startVertex,0,0);
  this.traversalStack.push(te);
  this.alreadyVisited.add(startVertex);
}",0.9751243781094528
56007,"/** 
 * {@inheritDoc}
 */
@Override public boolean hasNext(){
  if (traversalStack.isEmpty()) {
    if (numVisitedEntryVertices < 0) {
      return false;
    }
    numVisitedEntryVertices++;
    if (forward) {
      if (executionGraph.getNumberOfInputVertices(this.startStage) <= numVisitedEntryVertices) {
        return false;
      }
    }
 else {
      if (executionGraph.getNumberOfOutputVertices(this.startStage) <= numVisitedEntryVertices) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean hasNext(){
  if (this.traversalStack.isEmpty()) {
    if (this.numVisitedEntryVertices < 0) {
      return false;
    }
    ++this.numVisitedEntryVertices;
    if (this.forward) {
      if (this.executionGraph.getNumberOfInputVertices(this.startStage) <= this.numVisitedEntryVertices) {
        return false;
      }
    }
 else {
      if (this.executionGraph.getNumberOfOutputVertices(this.startStage) <= this.numVisitedEntryVertices) {
        return false;
      }
    }
  }
  return true;
}",0.9581749049429658
56008,"/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ExecutionVertex getCandidateVertex(TraversalEntry te,boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getExecutionVertex().getEnvironment().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getExecutionVertex().getEnvironment().getOutputGate(te.getCurrentGate()).getNumberOfOutputChannels()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final AbstractOutputChannel<? extends Record> outputChannel=te.getExecutionVertex().getEnvironment().getOutputGate(te.getCurrentGate()).getOutputChannel(te.getCurrentChannel());
        final ExecutionVertex tmp=executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
        if (tmp == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(tmp)) {
          return tmp;
        }
      }
    }
  }
 else {
    while (true) {
      if (te.getCurrentGate() >= te.getExecutionVertex().getEnvironment().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getExecutionVertex().getEnvironment().getInputGate(te.getCurrentGate()).getNumberOfInputChannels()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final AbstractInputChannel<? extends Record> inputChannel=te.getExecutionVertex().getEnvironment().getInputGate(te.getCurrentGate()).getInputChannel(te.getCurrentChannel());
        final ExecutionVertex tmp=executionGraph.getVertexByChannelID(inputChannel.getConnectedChannelID());
        if (tmp == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(tmp)) {
          return tmp;
        }
      }
    }
  }
  return null;
}","/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ExecutionVertex getCandidateVertex(TraversalEntry te,boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getExecutionVertex().getEnvironment().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getExecutionVertex().getEnvironment().getOutputGate(te.getCurrentGate()).getNumberOfOutputChannels()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final AbstractOutputChannel<? extends Record> outputChannel=te.getExecutionVertex().getEnvironment().getOutputGate(te.getCurrentGate()).getOutputChannel(te.getCurrentChannel());
        final ExecutionVertex tmp=this.executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
        if (tmp == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!this.alreadyVisited.contains(tmp)) {
          return tmp;
        }
      }
    }
  }
 else {
    while (true) {
      if (te.getCurrentGate() >= te.getExecutionVertex().getEnvironment().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getExecutionVertex().getEnvironment().getInputGate(te.getCurrentGate()).getNumberOfInputChannels()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final AbstractInputChannel<? extends Record> inputChannel=te.getExecutionVertex().getEnvironment().getInputGate(te.getCurrentGate()).getInputChannel(te.getCurrentChannel());
        final ExecutionVertex tmp=this.executionGraph.getVertexByChannelID(inputChannel.getConnectedChannelID());
        if (tmp == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!this.alreadyVisited.contains(tmp)) {
          return tmp;
        }
      }
    }
  }
  return null;
}",0.995949777237748
56009,"/** 
 * Initializes the input reader of the MapTask.
 * @throws RuntimeException Thrown if no input ship strategy was provided.
 */
private void initInputReader() throws RuntimeException {
  RecordDeserializer<KeyValuePair<Key,Value>> deserializerPartition=new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),(Class<Value>)((Class<? extends Value>)PactNull.class));
  RecordDeserializer<KeyValuePair<Key,Value>> deserializerReader=new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),stub.getOutValueType());
  DistributionPattern dpPartition=null;
switch (config.getInputShipStrategy(0)) {
case FORWARD:
    dpPartition=new PointwiseDistributionPattern();
  break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
dpPartition=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
DistributionPattern dpReader=null;
switch (config.getInputShipStrategy(0)) {
case FORWARD:
dpReader=new PointwiseDistributionPattern();
break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
dpReader=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
readerPartition=new RecordReader<KeyValuePair<Key,Value>>(this,deserializerPartition,dpPartition);
readerStub=new RecordReader<KeyValuePair<Key,Value>>(this,deserializerReader,dpReader);
}","/** 
 * Initializes the input reader of the MapTask.
 * @throws RuntimeException Thrown if no input ship strategy was provided.
 */
private void initInputReader() throws RuntimeException {
  RecordDeserializer<KeyValuePair<Key,Value>> deserializerPartition=new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),(Class<Value>)((Class<? extends Value>)PactNull.class));
  RecordDeserializer<KeyValuePair<Key,Value>> deserializerReader=new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),stub.getOutValueType());
  DistributionPattern dpPartition=null;
switch (config.getInputShipStrategy(0)) {
case FORWARD:
    dpPartition=new PointwiseDistributionPattern();
  break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
dpPartition=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
DistributionPattern dpReader=null;
switch (config.getInputShipStrategy(1)) {
case FORWARD:
dpReader=new PointwiseDistributionPattern();
break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
dpReader=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
readerPartition=new RecordReader<KeyValuePair<Key,Value>>(this,deserializerPartition,dpPartition);
readerStub=new RecordReader<KeyValuePair<Key,Value>>(this,deserializerReader,dpReader);
}",0.9992630803242448
56010,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
    final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
    try {
      requestInstances(executionStage);
    }
 catch (    InstanceException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}",0.9264049955396968
56011,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new LocalExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new LocalExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
    final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
    try {
      requestInstances(executionStage);
    }
 catch (    InstanceException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}",0.9262075134168156
56012,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    throw new SchedulingException(StringUtils.stringifyException(e));
  }
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
}",0.8984409799554566
56013,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new LocalExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    throw new SchedulingException(StringUtils.stringifyException(e));
  }
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new LocalExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
}",0.8981688253684681
56014,"@Override public JsonNode evaluate(final JsonNode node,EvaluationContext context){
  if (node.isArray()) {
    if (node instanceof StreamArrayNode)     return new StreamArrayNode(new TransformingIterator<JsonNode,JsonNode>(node.iterator()){
      @Override protected JsonNode transform(      JsonNode inputObject){
        return inputObject.get(FieldAccess.this.field);
      }
    }
);
    ArrayNode arrayNode=new ArrayNode(NODE_FACTORY);
    for (int index=0, size=node.size(); index < size; index++)     arrayNode.add(node.get(index).get(this.field));
    return arrayNode;
  }
  return node.get(this.field);
}","@Override public JsonNode evaluate(final JsonNode node,EvaluationContext context){
  if (node.isArray()) {
    if (node instanceof StreamArrayNode)     return new StreamArrayNode(new ConversionIterator<JsonNode,JsonNode>(node.iterator()){
      @Override protected JsonNode convert(      JsonNode inputObject){
        return inputObject.get(FieldAccess.this.field);
      }
    }
);
    ArrayNode arrayNode=new ArrayNode(NODE_FACTORY);
    for (int index=0, size=node.size(); index < size; index++)     arrayNode.add(node.get(index).get(this.field));
    return arrayNode;
  }
  return node.get(this.field);
}",0.9689542483660132
56015,"@Override public Iterator<Evaluable> iterator(){
  return new TransformingIterator<Mapping,Evaluable>(mappings.iterator()){
    @Override protected Evaluable transform(    Mapping inputObject){
      return inputObject.getExpression();
    }
  }
;
}","@Override public Iterator<Evaluable> iterator(){
  return new ConversionIterator<Mapping,Evaluable>(mappings.iterator()){
    @Override protected Evaluable convert(    Mapping inputObject){
      return inputObject.getExpression();
    }
  }
;
}",0.9230769230769232
56016,"public static JsonNode union(JsonNode[] params){
  boolean hasStream=false;
  for (  JsonNode param : params) {
    if (!param.isArray())     throw new EvaluationException(""String_Node_Str"");
    hasStream|=param instanceof StreamArrayNode;
  }
  if (hasStream) {
    @SuppressWarnings(""String_Node_Str"") Iterator<JsonNode>[] iterators=new Iterator[params.length];
    for (int index=0; index < iterators.length; index++)     iterators[index]=params[index].iterator();
    return new StreamArrayNode(new ConcatenatingIterator<JsonNode>(iterators));
  }
  ArrayNode union=NODE_FACTORY.arrayNode();
  for (  JsonNode param : params)   union.addAll((ArrayNode)param);
  return union;
}","public static JsonNode union(JsonNode[] params){
  boolean hasStream=false;
  for (  JsonNode param : params) {
    if (!param.isArray())     throw new EvaluationException(""String_Node_Str"");
    hasStream|=param instanceof StreamArrayNode;
  }
  if (hasStream) {
    Iterator<?>[] iterators=new Iterator[params.length];
    for (int index=0; index < iterators.length; index++)     iterators[index]=params[index].iterator();
    return new StreamArrayNode(new ConcatenatingIterator<JsonNode>(iterators));
  }
  ArrayNode union=NODE_FACTORY.arrayNode();
  for (  JsonNode param : params)   union.addAll((ArrayNode)param);
  return union;
}",0.9651515151515152
56017,"public int getDistance(Signature actualSignature,Method method){
  Class<?>[] actualParamTypes=actualSignature.parameterTypes;
  int nonVarArgs=this.parameterTypes.length - 1;
  if (nonVarArgs > actualParamTypes.length)   return NO_MATCH;
  int distance=0;
  for (int index=0; index < nonVarArgs; index++) {
    if (!this.parameterTypes[index].isAssignableFrom(actualParamTypes[index]))     return NO_MATCH;
    distance+=ReflectUtil.getDistance(this.parameterTypes[index],actualParamTypes[index]);
  }
  if (nonVarArgs < actualParamTypes.length) {
    Class<?> varargType=this.parameterTypes[nonVarArgs].getComponentType();
    for (int index=nonVarArgs; index < actualParamTypes.length; index++) {
      if (!varargType.isAssignableFrom(actualParamTypes[index]))       return NO_MATCH;
      distance+=ReflectUtil.getDistance(varargType,actualParamTypes[index]) + 1;
    }
  }
  return distance;
}","@Override public int getDistance(Signature actualSignature){
  Class<?>[] actualParamTypes=actualSignature.parameterTypes;
  int nonVarArgs=this.parameterTypes.length - 1;
  if (nonVarArgs > actualParamTypes.length)   return NO_MATCH;
  int distance=0;
  for (int index=0; index < nonVarArgs; index++) {
    if (!this.parameterTypes[index].isAssignableFrom(actualParamTypes[index]))     return NO_MATCH;
    distance+=ReflectUtil.getDistance(this.parameterTypes[index],actualParamTypes[index]);
  }
  if (nonVarArgs < actualParamTypes.length) {
    Class<?> varargType=this.parameterTypes[nonVarArgs].getComponentType();
    for (int index=nonVarArgs; index < actualParamTypes.length; index++) {
      if (!varargType.isAssignableFrom(actualParamTypes[index]))       return NO_MATCH;
      distance+=ReflectUtil.getDistance(varargType,actualParamTypes[index]) + 1;
    }
  }
  return distance;
}",0.9866220735785952
56018,protected abstract T loadNext();,"/** 
 * Returns the next element or the result of   {@link #noMoreElements()}.
 * @return the next element
 */
protected abstract T loadNext();",0.3657142857142857
56019,"protected boolean isInitialized(){
  return this.initialized;
}","/** 
 * Return true if at least one element has been loaded.
 * @return true if at least one element has been loaded
 */
protected boolean isInitialized(){
  return this.initialized;
}",0.5101214574898786
56020,"protected T noMoreElements(){
  this.hasNext=false;
  return null;
}","/** 
 * Signal methods that should be invoked when no more elements are in the iterator.
 * @return a signal that no more elements are in this iterator
 */
protected T noMoreElements(){
  this.hasNext=false;
  return null;
}",0.4657534246575342
56021,"public ConcatenatingIterator(Iterator<T>... inputs){
  this.inputs=new LinkedList<Iterator<T>>(Arrays.asList(inputs));
}","/** 
 * Initializes a ConcatenatingIterator with an array of iterators. This constructor is not type-safe.
 * @param iterators the iterators to concatenate
 */
@SuppressWarnings(""String_Node_Str"") public ConcatenatingIterator(Iterator<?>... iterators){
  this.inputs=new LinkedList<Iterator<? extends T>>((Collection<? extends Iterator<? extends T>>)Arrays.asList(iterators));
}",0.1927710843373494
56022,"@Override protected T loadNext(){
  while (!this.inputs.isEmpty()) {
    Iterator<T> iterator=this.inputs.getFirst();
    if (!iterator.hasNext())     this.inputs.pop();
 else     return iterator.next();
  }
  return this.noMoreElements();
}","@Override protected T loadNext(){
  while (!this.inputs.isEmpty()) {
    Iterator<? extends T> iterator=this.inputs.getFirst();
    if (!iterator.hasNext())     this.inputs.pop();
 else     return iterator.next();
  }
  return this.noMoreElements();
}",0.9796747967479674
56023,"public OneElementList(E element){
  this.element=element;
}","/** 
 * Initializes OneElementList with the given element.
 * @param element the element to wrap
 */
public OneElementList(E element){
  this.element=element;
}",0.5388127853881278
56024,"@Override public void write(final DataOutput out) throws IOException {
  final int maxBit=0x1 << 7;
  int len=this.value.length();
  while (len >= maxBit) {
    out.write(len | maxBit);
    len>>=7;
  }
  out.write(len);
  for (int i=0; i < this.value.length(); i++) {
    int c=this.value.charAt(i);
    if (c < maxBit)     out.write(c);
 else     while (c >= maxBit) {
      out.write(c | maxBit);
      c>>=7;
    }
  }
}","@Override public void write(final DataOutput out) throws IOException {
  final int maxBit=0x1 << 7;
  int len=this.value.length();
  while (len >= maxBit) {
    out.write(len | maxBit);
    len>>=7;
  }
  out.write(len);
  for (int i=0; i < this.value.length(); i++) {
    int c=this.value.charAt(i);
    while (c >= maxBit) {
      out.write(c | maxBit);
      c>>=7;
    }
    out.write(c);
  }
}",0.924574209245742
56025,"@Test public void testPactString(){
  PactString string0=new PactString(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",string0.toString());
  PactString string1=new PactString(""String_Node_Str"");
  PactString string2=new PactString(""String_Node_Str"");
  PactString string3=new PactString(""String_Node_Str"");
  Assert.assertTrue(string0.compareTo(string0) == 0);
  Assert.assertTrue(string0.compareTo(string1) == 0);
  Assert.assertTrue(string0.compareTo(string2) > 0);
  Assert.assertTrue(string0.compareTo(string3) < 0);
  try {
    string0.write(mOut);
    string2.write(mOut);
    string3.write(mOut);
    PactString string1n=new PactString();
    PactString string2n=new PactString();
    PactString string3n=new PactString();
    string1n.read(mIn);
    string2n.read(mIn);
    string3n.read(mIn);
    Assert.assertEquals(string0.compareTo(string1n),0);
    Assert.assertEquals(string0.toString(),string1n.toString());
    Assert.assertEquals(string2.compareTo(string2n),0);
    Assert.assertEquals(string2.toString(),string2n.toString());
    Assert.assertEquals(string3.compareTo(string3n),0);
    Assert.assertEquals(string3.toString(),string3n.toString());
  }
 catch (  Exception e) {
    Assert.assertTrue(false);
  }
}","@Test public void testPactString(){
  PactString string0=new PactString(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",string0.toString());
  PactString string1=new PactString(""String_Node_Str"");
  PactString string2=new PactString(""String_Node_Str"");
  PactString string3=new PactString(""String_Node_Str"");
  PactString string4=new PactString(""String_Node_Str"");
  Assert.assertTrue(string0.compareTo(string0) == 0);
  Assert.assertTrue(string0.compareTo(string1) == 0);
  Assert.assertTrue(string0.compareTo(string2) > 0);
  Assert.assertTrue(string0.compareTo(string3) < 0);
  try {
    string0.write(mOut);
    string4.write(mOut);
    string2.write(mOut);
    string3.write(mOut);
    PactString string1n=new PactString();
    PactString string2n=new PactString();
    PactString string3n=new PactString();
    PactString string4n=new PactString();
    string1n.read(mIn);
    string4n.read(mIn);
    string2n.read(mIn);
    string3n.read(mIn);
    Assert.assertEquals(string0.compareTo(string1n),0);
    Assert.assertEquals(string0.toString(),string1n.toString());
    Assert.assertEquals(string4.compareTo(string4n),0);
    Assert.assertEquals(string4.toString(),string4n.toString());
    Assert.assertEquals(string2.compareTo(string2n),0);
    Assert.assertEquals(string2.toString(),string2n.toString());
    Assert.assertEquals(string3.compareTo(string3n),0);
    Assert.assertEquals(string3.toString(),string3n.toString());
  }
 catch (  Exception e) {
    Assert.assertTrue(false);
  }
}",0.8954248366013072
56026,"@Override public InstanceType getDefaultInstanceType(){
  return DEFAULT;
}","@Override public InstanceType getDefaultInstanceType(){
  return DEFAULT_INSTANCE_TYPE;
}",0.9146341463414634
56027,"@Override public InstanceType getInstanceTypeByName(final String instanceTypeName){
  return DEFAULT;
}","@Override public InstanceType getInstanceTypeByName(final String instanceTypeName){
  return DEFAULT_INSTANCE_TYPE;
}",0.9363636363636364
56028,"@Override public InstanceType getSuitableInstanceType(final int minNumComputeUnits,final int minNumCPUCores,final int minMemorySize,final int minDiskCapacity,final int maxPricePerHour){
  return DEFAULT;
}","@Override public InstanceType getSuitableInstanceType(final int minNumComputeUnits,final int minNumCPUCores,final int minMemorySize,final int minDiskCapacity,final int maxPricePerHour){
  return DEFAULT_INSTANCE_TYPE;
}",0.9669811320754716
56029,"private void assignMemory(final TaskConfig config,final int memSize){
  config.setMemorySize(((long)memSize) * 1024L * 1024L);
  config.setNumFilehandles(DEFAUTL_MERGE_FACTOR);
}","private void assignMemory(final TaskConfig config,final int memSize){
  config.setMemorySize(memSize * 1024L * 1024L);
  config.setNumFilehandles(DEFAUTL_MERGE_FACTOR);
}",0.9770114942528736
56030,"/** 
 * {@inheritDoc}
 */
@Override public void requestClose() throws IOException, InterruptedException {
  if (!this.closeRequested) {
    this.closeRequested=true;
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void requestClose() throws IOException, InterruptedException {
  if (!this.closeRequested) {
    this.closeRequested=true;
    if (!isBroadcastChannel() || getChannelIndex() == 0) {
      transferEvent(new ByteBufferedChannelCloseEvent());
    }
  }
}",0.8598848368522073
56031,"/** 
 * Decreases the number of references to the physical buffer by one. If the number of references becomes zero the physical buffer is recycled.
 */
synchronized void decreaseReferenceCounter(){
  if (this.bufferAlreadyRecycled) {
    LOG.error(""String_Node_Str"");
  }
  --this.referenceCounter;
  if (this.referenceCounter <= 0) {
    this.originalBuffer.clear();
synchronized (this.queueForRecycledBuffers) {
      this.queueForRecycledBuffers.add(this.originalBuffer);
      this.queueForRecycledBuffers.notify();
    }
  }
  this.bufferAlreadyRecycled=true;
}","/** 
 * Decreases the number of references to the physical buffer by one. If the number of references becomes zero the physical buffer is recycled.
 */
synchronized void decreaseReferenceCounter(){
  if (this.bufferAlreadyRecycled) {
    LOG.error(""String_Node_Str"");
  }
  --this.referenceCounter;
  if (this.referenceCounter <= 0) {
    this.originalBuffer.clear();
synchronized (this.queueForRecycledBuffers) {
      this.queueForRecycledBuffers.add(this.originalBuffer);
      this.queueForRecycledBuffers.notify();
    }
    this.bufferAlreadyRecycled=true;
  }
}",0.9365079365079364
56032,"private boolean processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList) throws IOException, InterruptedException {
  final Buffer buffer=transferEnvelope.getBuffer();
  if (buffer.isReadBuffer()) {
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      final Buffer writeBuffer=this.bufferProvider.requestEmptyWriteBuffer(buffer.size());
      if (writeBuffer == null) {
        return false;
      }
      transferEnvelope.getBuffer().copyToBuffer(writeBuffer);
      final TransferEnvelope remoteEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      remoteEnvelope.setBuffer(writeBuffer);
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),remoteEnvelope.duplicate());
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),remoteEnvelope);
    }
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        for (int i=1; i < localReceivers.size(); ++i) {
          channelWrapper=this.registeredChannels.get(localReceivers.get(i));
          if (channelWrapper == null) {
            LOG.error(""String_Node_Str"" + localReceivers.get(i) + ""String_Node_Str""+ transferEnvelope.getJobID());
            continue;
          }
          channelWrapper.queueTransferEnvelope(transferEnvelope.duplicate());
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error(""String_Node_Str"" + localReceivers.get(0) + ""String_Node_Str""+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(transferEnvelope);
        }
      }
    }
 else {
      buffer.recycleBuffer();
    }
  }
 else {
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
      final Buffer readBuffer=this.bufferProvider.requestEmptyReadBufferAndWait(buffer.size(),localReceivers.get(0));
      transferEnvelope.getBuffer().copyToBuffer(readBuffer);
      final TransferEnvelope localEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      localEnvelope.setBuffer(readBuffer);
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        for (int i=1; i < localReceivers.size(); ++i) {
          channelWrapper=this.registeredChannels.get(localReceivers.get(i));
          if (channelWrapper == null) {
            LOG.error(""String_Node_Str"" + localReceivers.get(i) + ""String_Node_Str""+ transferEnvelope.getJobID());
            continue;
          }
          channelWrapper.queueTransferEnvelope(localEnvelope.duplicate());
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error(""String_Node_Str"" + localReceivers.get(0) + ""String_Node_Str""+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(localEnvelope);
        }
      }
    }
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),transferEnvelope.duplicate());
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),transferEnvelope);
    }
 else {
      buffer.recycleBuffer();
    }
  }
  return true;
}","private boolean processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList) throws IOException, InterruptedException {
  final Buffer buffer=transferEnvelope.getBuffer();
  if (buffer.isReadBuffer()) {
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      final Buffer writeBuffer=this.bufferProvider.requestEmptyWriteBuffer(buffer.size());
      if (writeBuffer == null) {
        return false;
      }
      transferEnvelope.getBuffer().copyToBuffer(writeBuffer);
      final TransferEnvelope remoteEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      remoteEnvelope.setBuffer(writeBuffer);
      TransferEnvelope[] duplicatedEnvelopes=new TransferEnvelope[remoteReceivers.size() - 1];
      for (int i=0; i < duplicatedEnvelopes.length; ++i) {
        duplicatedEnvelopes[i]=remoteEnvelope.duplicate();
      }
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),duplicatedEnvelopes[i - 1]);
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),remoteEnvelope);
    }
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        if (localReceivers.size() > 1) {
          TransferEnvelope[] duplicatedEnvelopes=new TransferEnvelope[localReceivers.size() - 1];
          for (int i=0; i < duplicatedEnvelopes.length; ++i) {
            duplicatedEnvelopes[i]=transferEnvelope.duplicate();
          }
          for (int i=1; i < localReceivers.size(); ++i) {
            channelWrapper=this.registeredChannels.get(localReceivers.get(i));
            if (channelWrapper == null) {
              LOG.error(""String_Node_Str"" + localReceivers.get(i) + ""String_Node_Str""+ transferEnvelope.getJobID());
              continue;
            }
            channelWrapper.queueTransferEnvelope(duplicatedEnvelopes[i - 1]);
          }
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error(""String_Node_Str"" + localReceivers.get(0) + ""String_Node_Str""+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(transferEnvelope);
        }
      }
    }
 else {
      buffer.recycleBuffer();
    }
  }
 else {
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
      final Buffer readBuffer=this.bufferProvider.requestEmptyReadBufferAndWait(buffer.size(),localReceivers.get(0));
      transferEnvelope.getBuffer().copyToBuffer(readBuffer);
      final TransferEnvelope localEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      localEnvelope.setBuffer(readBuffer);
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        for (int i=1; i < localReceivers.size(); ++i) {
          channelWrapper=this.registeredChannels.get(localReceivers.get(i));
          if (channelWrapper == null) {
            LOG.error(""String_Node_Str"" + localReceivers.get(i) + ""String_Node_Str""+ transferEnvelope.getJobID());
            continue;
          }
          channelWrapper.queueTransferEnvelope(localEnvelope.duplicate());
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error(""String_Node_Str"" + localReceivers.get(0) + ""String_Node_Str""+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(localEnvelope);
        }
      }
    }
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),transferEnvelope.duplicate());
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),transferEnvelope);
    }
 else {
      buffer.recycleBuffer();
    }
  }
  return true;
}",0.9230588787239034
56033,"/** 
 * {@inheritDoc}
 */
@Override public boolean processEnvelopeFromNetworkOrCheckpoint(final TransferEnvelope transferEnvelope) throws IOException {
  try {
    if (!processEnvelope(transferEnvelope)) {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(e));
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean processEnvelopeFromNetworkOrCheckpoint(final TransferEnvelope transferEnvelope) throws IOException {
  try {
    if (!processEnvelope(transferEnvelope)) {
      return false;
    }
  }
 catch (  InterruptedException e) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(e));
  }
  return true;
}",0.9253333333333332
56034,"private boolean readSequenceNumber(ReadableByteChannel readableByteChannel) throws IOException {
  if (!this.sequenceNumberDeserializationStarted) {
    this.lengthBuffer.clear();
    this.sequenceNumberDeserializationStarted=true;
  }
  if (readableByteChannel.read(this.lengthBuffer) == -1) {
    if (this.lengthBuffer.position() == 0) {
      throw new EOFException();
    }
 else {
      throw new IOException(""String_Node_Str"");
    }
  }
  if (!this.lengthBuffer.hasRemaining()) {
    final int sequenceNumber=byteBufferToInteger(this.lengthBuffer,0);
    if (sequenceNumber < 0) {
      throw new IOException(""String_Node_Str"" + sequenceNumber);
    }
    this.deserializationState=DeserializationState.SEQUENCENUMBERDESERIALIZED;
    this.sequenceNumberDeserializationStarted=false;
    this.transferEnvelope=null;
    this.sizeOfBuffer=-1;
    this.bufferExistanceDeserialized=false;
    this.existanceBuffer.clear();
    this.lengthBuffer.clear();
    this.jobIDDeserializationBuffer.clear();
    this.channelIDDeserializationBuffer.clear();
    this.buffer=null;
    return false;
  }
  return true;
}","private boolean readSequenceNumber(ReadableByteChannel readableByteChannel) throws IOException {
  if (!this.sequenceNumberDeserializationStarted) {
    this.lengthBuffer.clear();
    this.sequenceNumberDeserializationStarted=true;
  }
  if (readableByteChannel.read(this.lengthBuffer) == -1) {
    if (this.lengthBuffer.position() == 0) {
      throw new EOFException();
    }
 else {
      throw new IOException(""String_Node_Str"");
    }
  }
  if (!this.lengthBuffer.hasRemaining()) {
    this.deserializedSequenceNumber=byteBufferToInteger(this.lengthBuffer,0);
    if (this.deserializedSequenceNumber < 0) {
      throw new IOException(""String_Node_Str"" + this.deserializedSequenceNumber);
    }
    this.deserializationState=DeserializationState.SEQUENCENUMBERDESERIALIZED;
    this.sequenceNumberDeserializationStarted=false;
    this.transferEnvelope=null;
    this.sizeOfBuffer=-1;
    this.bufferExistanceDeserialized=false;
    this.existanceBuffer.clear();
    this.lengthBuffer.clear();
    this.jobIDDeserializationBuffer.clear();
    this.channelIDDeserializationBuffer.clear();
    this.buffer=null;
    return false;
  }
  return true;
}",0.9704194260485652
56035,"public abstract void getStreamedNestedLoopsCosts(OptimizerNode node,PactConnection outerSide,PactConnection innerSide,Costs costs);","public abstract void getStreamedNestedLoopsCosts(OptimizerNode node,PactConnection outerSide,PactConnection innerSide,int bufferSize,Costs costs);",0.9458483754512635
56036,"/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  PactConnection primConn=null;
  PactConnection secConn=null;
{
    List<PactConnection> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primConn=conns.get(0);
    }
    if (conns.size() > 1) {
      secConn=conns.get(1);
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primConn != null) {
switch (primConn.getShipStrategy()) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(primConn,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(primConn,globCost);
break;
case BROADCAST:
getBroadcastCost(primConn,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primConn.getShipStrategy().name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secConn != null) {
Costs secCost=new Costs();
switch (secConn.getShipStrategy()) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(secConn,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(secConn,secCost);
break;
case BROADCAST:
getBroadcastCost(secConn,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secConn.getShipStrategy().name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primConn,locCost);
break;
case SORT_BOTH_MERGE:
getLocalDoubleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_FIRST_MERGE:
getLocalSingleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SECOND_MERGE:
getLocalSingleSortMergeCost(n,secConn,primConn,locCost);
break;
case MERGE:
getLocalMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SELF_NESTEDLOOP:
getLocalSortSelfNestedLoopCost(n,primConn,10,locCost);
break;
case SELF_NESTEDLOOP:
getLocalSelfNestedLoopCost(n,primConn,10,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primConn,secConn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secConn,primConn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primConn,secConn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secConn,primConn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primConn,secConn,2,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secConn,primConn,2,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primConn,secConn,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secConn,primConn,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}","/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  PactConnection primConn=null;
  PactConnection secConn=null;
{
    List<PactConnection> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primConn=conns.get(0);
    }
    if (conns.size() > 1) {
      secConn=conns.get(1);
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primConn != null) {
switch (primConn.getShipStrategy()) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(primConn,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(primConn,globCost);
break;
case BROADCAST:
getBroadcastCost(primConn,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primConn.getShipStrategy().name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secConn != null) {
Costs secCost=new Costs();
switch (secConn.getShipStrategy()) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(secConn,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(secConn,secCost);
break;
case BROADCAST:
getBroadcastCost(secConn,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secConn.getShipStrategy().name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primConn,locCost);
break;
case SORT_BOTH_MERGE:
getLocalDoubleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_FIRST_MERGE:
getLocalSingleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SECOND_MERGE:
getLocalSingleSortMergeCost(n,secConn,primConn,locCost);
break;
case MERGE:
getLocalMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SELF_NESTEDLOOP:
getLocalSortSelfNestedLoopCost(n,primConn,10,locCost);
break;
case SELF_NESTEDLOOP:
getLocalSelfNestedLoopCost(n,primConn,10,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primConn,secConn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secConn,primConn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primConn,secConn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secConn,primConn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primConn,secConn,BlockResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secConn,primConn,BlockResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primConn,secConn,SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS * SpillingResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secConn,primConn,SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS * SpillingResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}",0.9627228525121556
56037,"/** 
 * Executes the list action.
 * @param args Command line arguments for the list action.
 */
private void list(String[] args){
  boolean running;
  boolean scheduled;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_LIST),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  running=line.hasOption(RUNNING_OPTION.getOpt());
  scheduled=line.hasOption(SCHEDULED_OPTION.getOpt());
  if (!running && !scheduled) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  ExtendedManagementProtocol jmConn=null;
  try {
    jmConn=getJMConnection();
    List<RecentJobEvent> recentJobs=jmConn.getRecentJobs();
    ArrayList<RecentJobEvent> runningJobs=null;
    ArrayList<RecentJobEvent> scheduledJobs=null;
    if (running) {
      runningJobs=new ArrayList<RecentJobEvent>();
    }
    if (scheduled) {
      scheduledJobs=new ArrayList<RecentJobEvent>();
    }
    for (    RecentJobEvent rje : recentJobs) {
      if (running && rje.getJobStatus().equals(JobStatus.RUNNING)) {
        runningJobs.add(rje);
      }
      if (scheduled && rje.getJobStatus().equals(JobStatus.SCHEDULED)) {
        scheduledJobs.add(rje);
      }
    }
    SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
    Comparator<RecentJobEvent> njec=new Comparator<RecentJobEvent>(){
      @Override public int compare(      RecentJobEvent o1,      RecentJobEvent o2){
        return (int)(o1.getTimestamp() - o2.getTimestamp());
      }
    }
;
    if (running) {
      if (runningJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        RecentJobEvent je : runningJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
    if (scheduled) {
      if (scheduledJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        RecentJobEvent je : scheduledJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  Throwable t) {
    handleError(t);
  }
 finally {
    if (jmConn != null) {
      try {
        RPC.stopProxy(jmConn);
      }
 catch (      Throwable t) {
        System.err.println(""String_Node_Str"");
      }
    }
    jmConn=null;
  }
}","/** 
 * Executes the list action.
 * @param args Command line arguments for the list action.
 */
private void list(String[] args){
  boolean running;
  boolean scheduled;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_LIST),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  running=line.hasOption(RUNNING_OPTION.getOpt());
  scheduled=line.hasOption(SCHEDULED_OPTION.getOpt());
  if (!running && !scheduled) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  ExtendedManagementProtocol jmConn=null;
  try {
    jmConn=getJMConnection();
    List<RecentJobEvent> recentJobs=jmConn.getRecentJobs();
    ArrayList<RecentJobEvent> runningJobs=null;
    ArrayList<RecentJobEvent> scheduledJobs=null;
    if (running) {
      runningJobs=new ArrayList<RecentJobEvent>();
    }
    if (scheduled) {
      scheduledJobs=new ArrayList<RecentJobEvent>();
    }
    for (    RecentJobEvent rje : recentJobs) {
      if (running && rje.getJobStatus().equals(JobStatus.RUNNING)) {
        runningJobs.add(rje);
      }
      if (scheduled && rje.getJobStatus().equals(JobStatus.SCHEDULED)) {
        scheduledJobs.add(rje);
      }
    }
    SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
    Comparator<RecentJobEvent> njec=new Comparator<RecentJobEvent>(){
      @Override public int compare(      RecentJobEvent o1,      RecentJobEvent o2){
        return (int)(o1.getTimestamp() - o2.getTimestamp());
      }
    }
;
    if (running) {
      if (runningJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        RecentJobEvent je : runningJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
    if (scheduled) {
      if (scheduledJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(scheduledJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        RecentJobEvent je : scheduledJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  Throwable t) {
    handleError(t);
  }
 finally {
    if (jmConn != null) {
      try {
        RPC.stopProxy(jmConn);
      }
 catch (      Throwable t) {
        System.err.println(""String_Node_Str"");
      }
    }
    jmConn=null;
  }
}",0.9970898508548564
56038,"/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(Environment ee,ExecutionState newExecutionState,String optionalMessage){
  final long timestamp=System.currentTimeMillis();
  final VertexEvent vertexEvent=new VertexEvent(timestamp,this.jobVertexID,ee.getTaskName(),ee.getCurrentNumberOfSubtasks(),ee.getIndexInSubtaskGroup(),newExecutionState,optionalMessage);
  this.eventCollector.addEvent(ee.getJobID(),vertexEvent);
  final ExecutionStateChangeEvent executionStateChangeEvent=new ExecutionStateChangeEvent(timestamp,this.managementVertexID,newExecutionState);
  this.eventCollector.addEvent(ee.getJobID(),executionStateChangeEvent);
}","/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(Environment ee,ExecutionState newExecutionState,String optionalMessage){
  final long timestamp=System.currentTimeMillis();
  final VertexEvent vertexEvent=new VertexEvent(timestamp,this.jobVertexID,ee.getTaskName(),ee.getCurrentNumberOfSubtasks(),ee.getIndexInSubtaskGroup(),newExecutionState,optionalMessage);
  this.eventCollector.addEvent(ee.getJobID(),vertexEvent);
  final ExecutionStateChangeEvent executionStateChangeEvent=new ExecutionStateChangeEvent(timestamp,this.managementVertexID,newExecutionState);
  this.eventCollector.updateManagementGraph(ee.getJobID(),executionStateChangeEvent);
  this.eventCollector.addEvent(ee.getJobID(),executionStateChangeEvent);
}",0.9273504273504274
56039,"/** 
 * {@inheritDoc}
 */
@Override public void vertexAssignmentChanged(ExecutionVertexID id,AllocatedResource newAllocatedResource){
  final ManagementVertexID managementVertexID=id.toManagementVertexID();
  final long timestamp=System.currentTimeMillis();
  final AbstractInstance instance=newAllocatedResource.getInstance();
  VertexAssignmentEvent event;
  if (instance == null) {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,instance.getName(),instance.getType().getIdentifier());
  }
  this.eventCollector.addEvent(this.jobID,event);
}","/** 
 * {@inheritDoc}
 */
@Override public void vertexAssignmentChanged(ExecutionVertexID id,AllocatedResource newAllocatedResource){
  final ManagementVertexID managementVertexID=id.toManagementVertexID();
  final long timestamp=System.currentTimeMillis();
  final AbstractInstance instance=newAllocatedResource.getInstance();
  VertexAssignmentEvent event;
  if (instance == null) {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,instance.getName(),instance.getType().getIdentifier());
  }
  this.eventCollector.updateManagementGraph(jobID,event);
  this.eventCollector.addEvent(this.jobID,event);
}",0.9588652482269504
56040,"private int writeContentForCanceledChannel(final ReadableByteChannel readableByteChannel) throws IOException {
  final ByteBuffer tmpBuffer=ByteBuffer.allocate(128);
  long bytesWritten=0;
  long diff=this.bufferSize - this.totalBytesWritten;
  if (diff <= 0) {
    return 0;
  }
  while (diff > 0) {
    if (diff < tmpBuffer.remaining()) {
      tmpBuffer.limit(tmpBuffer.position() + (int)diff);
    }
    final long b=readableByteChannel.read(tmpBuffer);
    if (b == 0) {
      break;
    }
    if (b == -1) {
      throw new IOException(""String_Node_Str"");
    }
    if (!tmpBuffer.hasRemaining()) {
      tmpBuffer.clear();
    }
    bytesWritten+=b;
    this.totalBytesWritten+=bytesWritten;
    diff=this.bufferSize - this.totalBytesWritten;
  }
  return (int)bytesWritten;
}","private int writeContentForCanceledChannel(final ReadableByteChannel readableByteChannel) throws IOException {
  final ByteBuffer tmpBuffer=ByteBuffer.allocate(128);
  long bytesWritten=0;
  long diff=this.bufferSize - this.totalBytesWritten;
  if (diff <= 0) {
    return 0;
  }
  while (diff > 0) {
    if (diff < tmpBuffer.remaining()) {
      tmpBuffer.limit(tmpBuffer.position() + (int)diff);
    }
    final long b=readableByteChannel.read(tmpBuffer);
    if (b == 0) {
      break;
    }
    if (b == -1) {
      throw new IOException(""String_Node_Str"");
    }
    if (!tmpBuffer.hasRemaining()) {
      tmpBuffer.clear();
    }
    bytesWritten+=b;
    this.totalBytesWritten+=b;
    diff=this.bufferSize - this.totalBytesWritten;
  }
  return (int)bytesWritten;
}",0.919614147909968
56041,"/** 
 * Executes the list action.
 * @param args Command line arguments for the list action.
 */
private void list(String[] args){
  boolean running;
  boolean scheduled;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_LIST),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  running=line.hasOption(RUNNING_OPTION.getOpt());
  scheduled=line.hasOption(SCHEDULED_OPTION.getOpt());
  if (!running && !scheduled) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  ExtendedManagementProtocol jmConn=null;
  try {
    jmConn=getJMConnection();
    List<NewJobEvent> recentJobs=jmConn.getRecentJobs();
    ArrayList<NewJobEvent> runningJobs=null;
    ArrayList<NewJobEvent> scheduledJobs=null;
    if (running) {
      runningJobs=new ArrayList<NewJobEvent>();
    }
    if (scheduled) {
      scheduledJobs=new ArrayList<NewJobEvent>();
    }
    for (    NewJobEvent je : recentJobs) {
      if (running) {
      }
      if (scheduled) {
        scheduledJobs.add(je);
      }
    }
    SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
    if (running) {
      if (runningJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,new Comparator<NewJobEvent>(){
          @Override public int compare(          NewJobEvent o1,          NewJobEvent o2){
            return (int)(o1.getTimestamp() - o2.getTimestamp());
          }
        }
);
        System.out.println(""String_Node_Str"");
        for (        NewJobEvent je : runningJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
    if (scheduled) {
      if (scheduledJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(scheduledJobs,new Comparator<NewJobEvent>(){
          @Override public int compare(          NewJobEvent o1,          NewJobEvent o2){
            return (int)(o1.getTimestamp() - o2.getTimestamp());
          }
        }
);
        System.out.println(""String_Node_Str"");
        for (        NewJobEvent je : scheduledJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  Throwable t) {
    handleError(t);
  }
 finally {
    if (jmConn != null) {
      try {
        RPC.stopProxy(jmConn);
      }
 catch (      Throwable t) {
        System.err.println(""String_Node_Str"");
      }
    }
    jmConn=null;
  }
}","/** 
 * Executes the list action.
 * @param args Command line arguments for the list action.
 */
private void list(String[] args){
  boolean running;
  boolean scheduled;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_LIST),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  running=line.hasOption(RUNNING_OPTION.getOpt());
  scheduled=line.hasOption(SCHEDULED_OPTION.getOpt());
  if (!running && !scheduled) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  ExtendedManagementProtocol jmConn=null;
  try {
    jmConn=getJMConnection();
    List<NewJobEvent> recentJobs=jmConn.getRecentJobs();
    ArrayList<NewJobEvent> runningJobs=null;
    ArrayList<NewJobEvent> scheduledJobs=null;
    if (running) {
      runningJobs=new ArrayList<NewJobEvent>();
    }
    if (scheduled) {
      scheduledJobs=new ArrayList<NewJobEvent>();
    }
    for (    NewJobEvent je : recentJobs) {
      if (running) {
      }
      if (scheduled) {
        scheduledJobs.add(je);
      }
    }
    SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
    Comparator<NewJobEvent> njec=new Comparator<NewJobEvent>(){
      @Override public int compare(      NewJobEvent o1,      NewJobEvent o2){
        return (int)(o1.getTimestamp() - o2.getTimestamp());
      }
    }
;
    if (running) {
      if (runningJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        NewJobEvent je : runningJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
    if (scheduled) {
      if (scheduledJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        NewJobEvent je : scheduledJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  Throwable t) {
    handleError(t);
  }
 finally {
    if (jmConn != null) {
      try {
        RPC.stopProxy(jmConn);
      }
 catch (      Throwable t) {
        System.err.println(""String_Node_Str"");
      }
    }
    jmConn=null;
  }
}",0.8876026885735624
56042,"/** 
 * Executes the info action.
 * @param args Command line arguments for the info action. 
 */
private void info(String[] args){
  File jarFile=null;
  String assemblerClass=null;
  String[] programArgs=null;
  boolean description;
  boolean plan;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_INFO),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  if (line.hasOption(JAR_OPTION.getOpt())) {
    jarFile=new File(line.getOptionValue(JAR_OPTION.getOpt()));
    if (!jarFile.exists()) {
      System.err.println(""String_Node_Str"");
      printHelp();
      System.exit(1);
    }
 else     if (!jarFile.isFile()) {
      System.err.println(""String_Node_Str"");
      printHelp();
      System.exit(1);
    }
  }
 else {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  if (line.hasOption(CLASS_OPTION.getOpt())) {
    assemblerClass=line.getOptionValue(CLASS_OPTION.getOpt());
  }
  if (line.hasOption(ARGS_OPTION.getOpt())) {
    programArgs=line.getOptionValues(ARGS_OPTION.getOpt());
  }
  description=line.hasOption(DESCR_OPTION.getOpt());
  plan=line.hasOption(PLAN_OPTION.getOpt());
  if (!description && !plan) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  PactProgram program=null;
  try {
    if (assemblerClass == null) {
      program=new PactProgram(jarFile,programArgs);
    }
 else {
      program=new PactProgram(jarFile,assemblerClass,programArgs);
    }
  }
 catch (  ProgramInvocationException e) {
    handleError(e);
  }
  if (description) {
    String descr=null;
    try {
      descr=program.getTextDescription();
    }
 catch (    Exception e) {
      handleError(e);
    }
    if (descr != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(descr);
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    System.exit(0);
  }
  if (plan) {
    String jsonPlan=null;
    try {
      jsonPlan=program.getJSONPlan();
    }
 catch (    Exception e) {
      handleError(e);
    }
    if (jsonPlan != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(jsonPlan);
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
}","/** 
 * Executes the info action.
 * @param args Command line arguments for the info action. 
 */
private void info(String[] args){
  File jarFile=null;
  String assemblerClass=null;
  String[] programArgs=null;
  boolean description;
  boolean plan;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_INFO),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  if (line.hasOption(JAR_OPTION.getOpt())) {
    jarFile=new File(line.getOptionValue(JAR_OPTION.getOpt()));
    if (!jarFile.exists()) {
      System.err.println(""String_Node_Str"");
      printHelp();
      System.exit(1);
    }
 else     if (!jarFile.isFile()) {
      System.err.println(""String_Node_Str"");
      printHelp();
      System.exit(1);
    }
  }
 else {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  if (line.hasOption(CLASS_OPTION.getOpt())) {
    assemblerClass=line.getOptionValue(CLASS_OPTION.getOpt());
  }
  if (line.hasOption(ARGS_OPTION.getOpt())) {
    programArgs=line.getOptionValues(ARGS_OPTION.getOpt());
  }
  description=line.hasOption(DESCR_OPTION.getOpt());
  plan=line.hasOption(PLAN_OPTION.getOpt());
  if (!description && !plan) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  PactProgram program=null;
  try {
    if (assemblerClass == null) {
      program=new PactProgram(jarFile,programArgs);
    }
 else {
      program=new PactProgram(jarFile,assemblerClass,programArgs);
    }
  }
 catch (  ProgramInvocationException e) {
    handleError(e);
  }
  if (description) {
    String descr=null;
    try {
      descr=program.getTextDescription();
    }
 catch (    Exception e) {
      handleError(e);
    }
    if (descr != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(descr);
      System.out.println(""String_Node_Str"");
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  if (plan) {
    String jsonPlan=null;
    Configuration configuration=getConfiguration();
    Client client=new Client(configuration);
    try {
      jsonPlan=client.getJSONPlan(program);
    }
 catch (    ProgramInvocationException e) {
      handleError(e);
    }
catch (    ErrorInPlanAssemblerException e) {
      handleError(e);
    }
    if (jsonPlan != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(jsonPlan);
      System.out.println(""String_Node_Str"");
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
}",0.9154639175257732
56043,"/** 
 * Submits the job-graph to the nephele job-manager for execution.
 * @param prog The program to be submitted.
 * @throws ProgramInvocationException Thrown, if the submission failed. That might be either due to an I/O problem,i.e. the job-manager is unreachable, or due to the fact that the execution on the nephele system failed.
 */
public void run(JobGraph jobGraph,boolean wait) throws ProgramInvocationException {
  nepheleConfig.setBoolean(""String_Node_Str"",false);
  JobClient client;
  try {
    client=new JobClient(jobGraph,nepheleConfig);
  }
 catch (  IOException e) {
    throw new ProgramInvocationException(""String_Node_Str"" + e.getMessage());
  }
  try {
    if (wait) {
      client.submitJobAndWait();
    }
 else {
      JobSubmissionResult result=client.submitJob();
      if (result.getReturnCode() != ReturnCode.SUCCESS) {
        throw new ProgramInvocationException(""String_Node_Str"" + (result.getDescription() == null ? ""String_Node_Str"" : ""String_Node_Str"" + result.getDescription()));
      }
    }
  }
 catch (  IOException e) {
    throw new ProgramInvocationException(""String_Node_Str"" + e.getMessage());
  }
catch (  JobExecutionException jex) {
    throw new ProgramInvocationException(""String_Node_Str"" + jex.getMessage());
  }
}","/** 
 * Submits the job-graph to the nephele job-manager for execution.
 * @param prog The program to be submitted.
 * @param wait Method will block until the job execution is finished if set to true. If set to false, the method will directly return after the job is submitted. 
 * @throws ProgramInvocationException Thrown, if the submission failed. That might be either due to an I/O problem,i.e. the job-manager is unreachable, or due to the fact that the execution on the nephele system failed.
 */
public void run(JobGraph jobGraph,boolean wait) throws ProgramInvocationException {
  nepheleConfig.setBoolean(""String_Node_Str"",false);
  JobClient client;
  try {
    client=new JobClient(jobGraph,nepheleConfig);
  }
 catch (  IOException e) {
    throw new ProgramInvocationException(""String_Node_Str"" + e.getMessage());
  }
  try {
    if (wait) {
      client.submitJobAndWait();
    }
 else {
      JobSubmissionResult result=client.submitJob();
      if (result.getReturnCode() != ReturnCode.SUCCESS) {
        throw new ProgramInvocationException(""String_Node_Str"" + (result.getDescription() == null ? ""String_Node_Str"" : ""String_Node_Str"" + result.getDescription()));
      }
    }
  }
 catch (  IOException e) {
    throw new ProgramInvocationException(""String_Node_Str"" + e.getMessage());
  }
catch (  JobExecutionException jex) {
    throw new ProgramInvocationException(""String_Node_Str"" + jex.getMessage());
  }
}",0.939562476826103
56044,"/** 
 * Crosses a single value with N values all sharing a common key.
 * @param key The key shared by all values
 * @param val1 The single value
 * @param valsN Iterator over N values
 * @param firstInputNValues Set to true if the first input in N-value side, false otherwise.
 * @throws RuntimeException Forwards all exceptions thrown by the stub.
 */
private void cross1withNValues(Key key,Value val1,Iterator<Value> valsN,final boolean firstInputNValues) throws RuntimeException {
  Value v1;
  Value vN;
  keyCopier.setCopy(key);
  this.v1Copier.setCopy(val1);
  while (!this.taskCanceled && valsN.hasNext()) {
    key=this.keySerialization.newInstance();
    this.keyCopier.getCopy(key);
    v1=this.v1Serialization.newInstance();
    this.v1Copier.getCopy(v1);
    vN=valsN.next();
    if (firstInputNValues) {
      matchStub.match(key,vN,v1,output);
    }
 else {
      matchStub.match(key,v1,vN,output);
    }
  }
}","/** 
 * Crosses a single value with N values all sharing a common key.
 * @param key The key shared by all values
 * @param val1 The single value
 * @param valsN Iterator over N values
 * @param firstInputNValues Set to true if the first input in N-value side, false otherwise.
 * @throws RuntimeException Forwards all exceptions thrown by the stub.
 */
private void cross1withNValues(Key key,Value val1,Iterator<Value> valsN,final boolean firstInputNValues) throws RuntimeException {
  Value v1;
  Value vN;
  keyCopier.setCopy(key);
  this.v1Copier.setCopy(val1);
  while (!this.taskCanceled && valsN.hasNext()) {
    key=this.keySerialization.newInstance();
    this.keyCopier.getCopy(key);
    vN=valsN.next();
    if (firstInputNValues) {
      v1=this.v2Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      matchStub.match(key,vN,v1,output);
    }
 else {
      v1=this.v1Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      matchStub.match(key,v1,vN,output);
    }
  }
}",0.8467908902691511
56045,"@Override public V next(){
  nextCalled=true;
  return next.getValue();
}","@Override public V next(){
  if (first)   first=false;
  nextCalled=true;
  return next.getValue();
}",0.8390804597701149
56046,"public Iterator<V> getValues(){
  return new Iterator<V>(){
    boolean first=true;
    boolean last=false;
    boolean nextCalled=true;
    @Override public boolean hasNext(){
      if (first) {
        first=false;
        return true;
      }
 else       if (last) {
        return false;
      }
 else {
        if (nextCalled) {
          if (!iterator.hasNext()) {
            return false;
          }
          nextCalled=false;
          KeyValuePair<K,V> prev=next;
          next=iterator.next();
          if (next.getKey().compareTo(prev.getKey()) == 0) {
            return true;
          }
 else {
            last=true;
            nextKey=true;
            return false;
          }
        }
 else {
          return true;
        }
      }
    }
    @Override public V next(){
      nextCalled=true;
      return next.getValue();
    }
    @Override public void remove(){
    }
  }
;
}","public Iterator<V> getValues(){
  return new Iterator<V>(){
    boolean first=true;
    boolean last=false;
    boolean nextCalled=true;
    @Override public boolean hasNext(){
      if (first) {
        first=false;
        return true;
      }
 else       if (last) {
        return false;
      }
 else {
        if (nextCalled) {
          if (!iterator.hasNext()) {
            return false;
          }
          nextCalled=false;
          KeyValuePair<K,V> prev=next;
          next=iterator.next();
          if (next.getKey().compareTo(prev.getKey()) == 0) {
            return true;
          }
 else {
            last=true;
            nextKey=true;
            return false;
          }
        }
 else {
          return true;
        }
      }
    }
    @Override public V next(){
      if (first)       first=false;
      nextCalled=true;
      return next.getValue();
    }
    @Override public void remove(){
    }
  }
;
}",0.980498374864572
56047,"@Override public KeyValuePair<Key,Value> next(){
  try {
    KeyValuePair<Key,Value> pair=outerReader.next();
    copier.setCopy(pair);
    return pair;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}","@Override public KeyValuePair<Key,Value> next(){
  try {
    KeyValuePair<Key,Value> pair=reader.next();
    copier.setCopy(pair);
    return pair;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}",0.988155668358714
56048,"/** 
 * Runs a streamed nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read directly from the input reader. The inner side is read and reseted using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runStreamed(MemoryManager memoryManager,IOManager ioManager,RecordReader<KeyValuePair<Key,Value>> innerReader,final RecordReader<KeyValuePair<Key,Value>> outerReader) throws Exception {
  LastRepeatableIterator<KeyValuePair<Key,Value>> outerInput=new LastRepeatableIterator<KeyValuePair<Key,Value>>(){
    SerializationCopier<KeyValuePair<Key,Value>> copier=new SerializationCopier<KeyValuePair<Key,Value>>();
    KeyValuePairDeserializer<Key,Value> deserializer=new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType());
    @Override public boolean hasNext(){
      return outerReader.hasNext();
    }
    @Override public KeyValuePair<Key,Value> next(){
      try {
        KeyValuePair<Key,Value> pair=outerReader.next();
        copier.setCopy(pair);
        return pair;
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public KeyValuePair<Key,Value> repeatLast(){
      KeyValuePair<Key,Value> pair=deserializer.getInstance();
      copier.getCopy(pair);
      return pair;
    }
  }
;
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  try {
    try {
      innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
      spillingResetIt=innerInput;
    }
 catch (    MemoryAllocationException mae) {
      throw new RuntimeException(""String_Node_Str"",mae);
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    stub.open();
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      while (!this.taskCanceled && outerInput.hasNext()) {
        Pair outerPair=outerInput.next();
        while (!this.taskCanceled && innerInput.hasNext()) {
          Pair innerPair=innerInput.next();
          stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
          outerPair=outerInput.repeatLast();
        }
        if (!this.taskCanceled && outerInput.hasNext()) {
          innerInput.reset();
        }
      }
    }
 else {
      while (!this.taskCanceled && outerInput.hasNext()) {
        Pair outerPair=outerInput.next();
        while (!this.taskCanceled && innerInput.hasNext()) {
          Pair innerPair=innerInput.next();
          stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
          outerPair=outerInput.repeatLast();
        }
        if (!this.taskCanceled && outerInput.hasNext()) {
          innerInput.reset();
        }
      }
    }
    stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ex;
    }
  }
 finally {
    if (innerInput != null) {
      innerInput.close();
    }
  }
}","/** 
 * Runs a streamed nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read directly from the input reader. The inner side is read and reseted using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runStreamed(MemoryManager memoryManager,IOManager ioManager,RecordReader<KeyValuePair<Key,Value>> innerReader,final RecordReader<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  RepeatableReaderIterator outerInput=null;
  try {
    final boolean firstInputIsOuter;
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      outerInput=new RepeatableReaderIterator(outerReader,stub.getFirstInKeyType(),stub.getFirstInValueType());
      firstInputIsOuter=true;
    }
 else     if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      outerInput=new RepeatableReaderIterator(outerReader,stub.getSecondInKeyType(),stub.getSecondInValueType());
      firstInputIsOuter=false;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    stub.open();
    while (!this.taskCanceled && outerInput.hasNext()) {
      Pair outerPair=outerInput.next();
      while (!this.taskCanceled && innerInput.hasNext()) {
        Pair innerPair=innerInput.next();
        if (firstInputIsOuter) {
          stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
        }
 else {
          stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
        }
        outerPair=outerInput.repeatLast();
      }
      if (!this.taskCanceled && outerInput.hasNext()) {
        innerInput.reset();
      }
    }
    stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ex;
    }
  }
 finally {
    if (innerInput != null) {
      innerInput.close();
    }
  }
}",0.3239223887533403
56049,"@Override public boolean hasNext(){
  return outerReader.hasNext();
}","@Override public boolean hasNext(){
  return reader.hasNext();
}",0.962406015037594
56050,"/** 
 * Runs a blocked nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read using a BlockResettableIterator. The inner side is read using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @see eu.stratosphere.pact.runtime.resettable.BlockResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runBlocked(MemoryManager memoryManager,IOManager ioManager,RecordReader<KeyValuePair<Key,Value>> innerReader,RecordReader<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
    }
 else     if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    stub.open();
    boolean moreOuterBlocks=false;
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      do {
        while (!this.taskCanceled && innerInput.hasNext()) {
          Pair<Key,Value> innerPair=innerInput.next();
          while (!this.taskCanceled && outerInput.hasNext()) {
            Pair<Key,Value> outerPair=outerInput.next();
            stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (!this.taskCanceled && moreOuterBlocks);
    }
 else {
      do {
        while (!this.taskCanceled && innerInput.hasNext()) {
          Pair<Key,Value> innerPair=innerInput.next();
          while (!this.taskCanceled && outerInput.hasNext()) {
            Pair<Key,Value> outerPair=outerInput.next();
            stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (!this.taskCanceled && moreOuterBlocks);
    }
    stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ex;
    }
  }
 finally {
    Throwable t1=null, t2=null;
    try {
      if (innerInput != null) {
        innerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t1=t;
    }
    try {
      if (outerInput != null) {
        outerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t2=t;
    }
    if (t1 != null)     throw new RuntimeException(""String_Node_Str"",t1);
    if (t2 != null)     throw new RuntimeException(""String_Node_Str"",t2);
  }
}","/** 
 * Runs a blocked nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read using a BlockResettableIterator. The inner side is read using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @see eu.stratosphere.pact.runtime.resettable.BlockResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runBlocked(MemoryManager memoryManager,IOManager ioManager,RecordReader<KeyValuePair<Key,Value>> innerReader,RecordReader<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    final boolean firstInputIsOuter;
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=false;
    }
 else     if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=true;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    stub.open();
    boolean moreOuterBlocks=false;
    do {
      while (!this.taskCanceled && innerInput.hasNext()) {
        Pair<Key,Value> innerPair=innerInput.next();
        while (!this.taskCanceled && outerInput.hasNext()) {
          Pair<Key,Value> outerPair=outerInput.next();
          if (firstInputIsOuter) {
            stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
          }
 else {
            stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
          }
          innerPair=innerInput.repeatLast();
        }
        outerInput.reset();
      }
      moreOuterBlocks=outerInput.nextBlock();
      if (moreOuterBlocks) {
        innerInput.reset();
      }
    }
 while (!this.taskCanceled && moreOuterBlocks);
    stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ex;
    }
  }
 finally {
    Throwable t1=null, t2=null;
    try {
      if (innerInput != null) {
        innerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t1=t;
    }
    try {
      if (outerInput != null) {
        outerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t2=t;
    }
    if (t1 != null)     throw new RuntimeException(""String_Node_Str"",t1);
    if (t2 != null)     throw new RuntimeException(""String_Node_Str"",t2);
  }
}",0.90815627141878
56051,"/** 
 * Constructs a new <tt>ResettableIterator</tt>
 * @param memoryManager
 * @param ioManager
 * @param reader
 * @param availableMemory
 * @throws MemoryAllocationException
 */
public SpillingResettableIterator(MemoryManager memoryManager,IOManager ioManager,Reader<T> reader,long availableMemory,RecordDeserializer<T> deserializer,AbstractInvokable parentTask) throws MemoryAllocationException {
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.recordReader=reader;
  this.deserializer=deserializer;
  this.memorySegments=this.memoryManager.allocate(parentTask,availableMemory,MINIMUM_NUMBER_OF_BUFFERS,MIN_BUFFER_SIZE);
  this.numBuffers=this.memorySegments.size();
  this.currentBuffer=0;
  LOG.debug(""String_Node_Str"" + availableMemory + ""String_Node_Str"");
}","/** 
 * Constructs a new <tt>ResettableIterator</tt>
 * @param memoryManager
 * @param ioManager
 * @param reader
 * @param availableMemory
 * @throws MemoryAllocationException
 */
public SpillingResettableIterator(MemoryManager memoryManager,IOManager ioManager,final Iterator<T> it,long availableMemory,RecordDeserializer<T> deserializer,AbstractInvokable parentTask) throws MemoryAllocationException {
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.recordReader=new Reader<T>(){
    @Override public List<AbstractInputChannel<T>> getInputChannels(){
      throw new UnsupportedOperationException();
    }
    @Override public boolean hasNext(){
      return it.hasNext();
    }
    @Override public T next() throws IOException, InterruptedException {
      T next=it.next();
      return next;
    }
  }
;
  this.deserializer=deserializer;
  this.memorySegments=this.memoryManager.allocate(parentTask,availableMemory,MINIMUM_NUMBER_OF_BUFFERS,MIN_BUFFER_SIZE);
  this.numBuffers=this.memorySegments.size();
  this.currentBuffer=0;
  LOG.debug(""String_Node_Str"" + availableMemory + ""String_Node_Str"");
}",0.8050052137643379
56052,"@Override public boolean hasNext(){
  if (this.next == null) {
    this.next=deserializer.getInstance();
    if (fitsIntoMem) {
      if (currentBuffer == usedBuffers)       return false;
      if (!inputBuffers.get(currentBuffer).read(this.next)) {
        inputBuffers.get(currentBuffer).rewind();
        currentBuffer++;
        if (currentBuffer == usedBuffers)         return false;
        inputBuffers.get(currentBuffer).read(this.next);
      }
      return true;
    }
 else {
      try {
        return ioReader.read(this.next);
      }
 catch (      IOException ioex) {
        throw new RuntimeException(ioex);
      }
    }
  }
 else {
    return true;
  }
}","@Override public boolean hasNext(){
  if (this.next == null) {
    this.next=deserializer.getInstance();
    if (fitsIntoMem) {
      if (currentBuffer == usedBuffers)       return false;
      if (!inputBuffers.get(currentBuffer).read(this.next)) {
        inputBuffers.get(currentBuffer).rewind();
        currentBuffer++;
        if (currentBuffer == usedBuffers) {
          this.next=null;
          return false;
        }
        inputBuffers.get(currentBuffer).read(this.next);
      }
      return true;
    }
 else {
      try {
        if (ioReader.read(this.next)) {
          return true;
        }
 else {
          this.next=null;
          return false;
        }
      }
 catch (      IOException ioex) {
        throw new RuntimeException(ioex);
      }
    }
  }
 else {
    return true;
  }
}",0.866576819407008
56053,"@Override public V next(){
  return next.getValue();
}","@Override public V next(){
  nextCalled=true;
  return next.getValue();
}",0.8503937007874016
56054,"public Iterator<V> getValues(){
  return new Iterator<V>(){
    boolean first=true;
    boolean last=false;
    @Override public boolean hasNext(){
      if (first) {
        first=false;
        return true;
      }
 else       if (last) {
        return false;
      }
 else {
        if (!iterator.hasNext()) {
          return false;
        }
        KeyValuePair<K,V> prev=next;
        next=iterator.next();
        if (next.getKey().compareTo(prev.getKey()) == 0) {
          return true;
        }
 else {
          last=true;
          nextKey=true;
          return false;
        }
      }
    }
    @Override public V next(){
      return next.getValue();
    }
    @Override public void remove(){
    }
  }
;
}","public Iterator<V> getValues(){
  return new Iterator<V>(){
    boolean first=true;
    boolean last=false;
    boolean nextCalled=true;
    @Override public boolean hasNext(){
      if (first) {
        first=false;
        return true;
      }
 else       if (last) {
        return false;
      }
 else {
        if (nextCalled) {
          if (!iterator.hasNext()) {
            return false;
          }
          nextCalled=false;
          KeyValuePair<K,V> prev=next;
          next=iterator.next();
          if (next.getKey().compareTo(prev.getKey()) == 0) {
            return true;
          }
 else {
            last=true;
            nextKey=true;
            return false;
          }
        }
 else {
          return true;
        }
      }
    }
    @Override public V next(){
      nextCalled=true;
      return next.getValue();
    }
    @Override public void remove(){
    }
  }
;
}",0.7820748925721301
56055,"@Override public boolean hasNext(){
  if (first) {
    first=false;
    return true;
  }
 else   if (last) {
    return false;
  }
 else {
    if (!iterator.hasNext()) {
      return false;
    }
    KeyValuePair<K,V> prev=next;
    next=iterator.next();
    if (next.getKey().compareTo(prev.getKey()) == 0) {
      return true;
    }
 else {
      last=true;
      nextKey=true;
      return false;
    }
  }
}","@Override public boolean hasNext(){
  if (first) {
    first=false;
    return true;
  }
 else   if (last) {
    return false;
  }
 else {
    if (nextCalled) {
      if (!iterator.hasNext()) {
        return false;
      }
      nextCalled=false;
      KeyValuePair<K,V> prev=next;
      next=iterator.next();
      if (next.getKey().compareTo(prev.getKey()) == 0) {
        return true;
      }
 else {
        last=true;
        nextKey=true;
        return false;
      }
    }
 else {
      return true;
    }
  }
}",0.6917293233082706
56056,"private void resolveDeadlock(PactConnection conn){
  OptimizerNode sourcePact=conn.getSourcePact();
  OptimizerNode targetPact=conn.getTargetPact();
  if (sourcePact instanceof DataSourceNode) {
    DataSourceNode duplicateDataSource=new DataSourceNode((DataSourceContract)sourcePact.getPactContract());
    PactConnection newConn=new PactConnection(conn,duplicateDataSource,targetPact);
    sourcePact.getOutgoingConnections().remove(conn);
    duplicateDataSource.addOutgoingConnection(newConn);
    if (targetPact instanceof SingleInputNode) {
      ((SingleInputNode)targetPact).setInputConnection(newConn);
    }
 else     if (targetPact instanceof TwoInputNode) {
      if (((TwoInputNode)targetPact).getFirstInputConnection() == conn) {
        ((TwoInputNode)targetPact).setFirstInputConnection(newConn);
      }
 else {
        ((TwoInputNode)targetPact).setSecondInputConnection(newConn);
      }
    }
  }
 else   if (sourcePact.getIncomingConnections().size() > 1) {
    conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
  }
 else   if (sourcePact.getOutgoingConnections().size() > 1) {
    conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
  }
 else {
    PactConnection predConn=sourcePact.getIncomingConnections().get(0);
    long curSize=sourcePact.getEstimatedOutputSize();
    long predSize=predConn.getSourcePact().getEstimatedOutputSize();
    if (curSize < predSize) {
      conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
    }
 else {
      resolveDeadlock(predConn);
    }
  }
}","private void resolveDeadlock(PactConnection conn){
  OptimizerNode sourcePact=conn.getSourcePact();
  OptimizerNode targetPact=conn.getTargetPact();
  if (sourcePact instanceof DataSourceNode) {
    DataSourceNode duplicateDataSource=new DataSourceNode((DataSourceContract<?,?>)sourcePact.getPactContract());
    PactConnection newConn=new PactConnection(conn,duplicateDataSource,targetPact);
    sourcePact.getOutgoingConnections().remove(conn);
    duplicateDataSource.addOutgoingConnection(newConn);
    if (targetPact instanceof SingleInputNode) {
      ((SingleInputNode)targetPact).setInputConnection(newConn);
    }
 else     if (targetPact instanceof TwoInputNode) {
      if (((TwoInputNode)targetPact).getFirstInputConnection() == conn) {
        ((TwoInputNode)targetPact).setFirstInputConnection(newConn);
      }
 else {
        ((TwoInputNode)targetPact).setSecondInputConnection(newConn);
      }
    }
  }
 else   if (sourcePact.getIncomingConnections().size() > 1) {
    conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
  }
 else   if (sourcePact.getOutgoingConnections().size() > 1) {
    conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
  }
 else {
    PactConnection predConn=sourcePact.getIncomingConnections().get(0);
    long curSize=sourcePact.getEstimatedOutputSize();
    long predSize=predConn.getSourcePact().getEstimatedOutputSize();
    if (curSize < predSize) {
      conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
    }
 else {
      resolveDeadlock(predConn);
    }
  }
}",0.998330550918197
56057,"public CombinerNode(ReduceContract<?,?,?,?> reducer,OptimizerNode predecessor,float reducingFactor){
  super(reducer);
  this.input=new PactConnection(predecessor,this,ShipStrategy.FORWARD);
  this.setLocalStrategy(LocalStrategy.COMBININGSORT);
  this.globalProps=predecessor.globalProps;
  this.localProps=predecessor.localProps;
  this.setDegreeOfParallelism(predecessor.getDegreeOfParallelism());
  this.setInstancesPerMachine(predecessor.getInstancesPerMachine());
  this.estimatedKeyCardinality=predecessor.estimatedKeyCardinality;
  if (predecessor.estimatedNumRecords >= 1 && predecessor.estimatedKeyCardinality >= 1 && predecessor.estimatedOutputSize >= -1) {
    this.estimatedNumRecords=(long)(predecessor.estimatedNumRecords * reducingFactor);
    this.estimatedOutputSize=(long)(predecessor.estimatedOutputSize * reducingFactor);
  }
 else {
    this.estimatedNumRecords=predecessor.estimatedNumRecords;
    this.estimatedOutputSize=predecessor.estimatedOutputSize;
  }
}","public CombinerNode(ReduceContract<?,?,?,?> reducer,OptimizerNode predecessor,float reducingFactor){
  super(reducer);
  this.input=new PactConnection(predecessor,this,ShipStrategy.FORWARD);
  this.setLocalStrategy(LocalStrategy.COMBININGSORT);
  this.globalProps=predecessor.globalProps;
  this.localProps=predecessor.localProps;
  this.setDegreeOfParallelism(predecessor.getDegreeOfParallelism());
  this.setInstancesPerMachine(predecessor.getInstancesPerMachine());
  this.estimatedKeyCardinality=predecessor.estimatedKeyCardinality;
  if (predecessor.estimatedNumRecords >= 1 && predecessor.estimatedKeyCardinality >= 1 && predecessor.estimatedOutputSize >= -1) {
    this.estimatedNumRecords=(long)(predecessor.estimatedNumRecords * reducingFactor);
    this.estimatedOutputSize=(long)(predecessor.estimatedOutputSize * reducingFactor);
  }
 else {
    this.estimatedNumRecords=predecessor.estimatedNumRecords;
    this.estimatedOutputSize=predecessor.estimatedOutputSize;
  }
  if (this.branchPlan == null) {
    this.branchPlan=predecessor.branchPlan;
  }
 else   if (predecessor.branchPlan != null) {
    this.branchPlan.putAll(predecessor.branchPlan);
  }
}",0.914844113541182
56058,"@Override public Value next() throws IOException, InterruptedException {
  if (firstValue) {
    firstValue=false;
    return origVal;
  }
 else {
    Value nextVal=values.next();
    copyKey=keySerialization.newInstance();
    keyCopier.getCopy(copyKey);
    copyVal=valSerialization.newInstance();
    valCopier.getCopy(copyVal);
    nextValCopier.setCopy(nextVal);
    copyNextVal=valSerialization.newInstance();
    nextValCopier.getCopy(copyNextVal);
    stub.match(copyKey,copyVal,copyNextVal,out);
    return nextVal;
  }
}","@Override public Value next() throws IOException, InterruptedException {
  if (bufferIdx < VALUE_BUFFER_SIZE) {
    return valBuffer[bufferIdx++];
  }
 else {
    Value nextVal=values.next();
    Key copyKey;
    Value outerVal;
    Value innerVal;
    outerValCopier.setCopy(nextVal);
    for (int i=0; i < VALUE_BUFFER_SIZE; i++) {
      innerValCopier.setCopy(valBuffer[i]);
      copyKey=keySerialization.newInstance();
      keyCopier.getCopy(copyKey);
      outerVal=valSerialization.newInstance();
      outerValCopier.getCopy(outerVal);
      innerVal=valSerialization.newInstance();
      innerValCopier.getCopy(innerVal);
      stub.match(copyKey,outerVal,innerVal,out);
    }
    return nextVal;
  }
}",0.6006441223832528
56059,"@Override public boolean hasNext(){
  if (taskCanceled)   return false;
  if (firstValue)   return true;
  return values.hasNext();
}","@Override public boolean hasNext(){
  if (taskCanceled)   return false;
  if (bufferIdx < VALUE_BUFFER_SIZE)   return true;
  return values.hasNext();
}",0.8842105263157894
56060,"/** 
 * Crosses the values of all pairs that have the same key. The   {@link MatchStub#match(Key,Iterator,Collector)} method is called for each element of the Cartesian product. 
 * @param key The key of all values in the iterator.
 * @param vals An iterator over values that share the same key.
 * @param out The collector to write the results to.
 */
private final void crossValues(Key key,final Iterator<Value> values,final Collector<Key,Value> out){
  Key copyKey;
  final Value origVal=values.next();
  Value copyVal=valSerialization.newInstance();
  valCopier.setCopy(origVal);
  valCopier.getCopy(copyVal);
  stub.match(key,origVal,copyVal,out);
  if (values.hasNext()) {
    Reader<Value> valReader=new Reader<Value>(){
      boolean firstValue=true;
      Key copyKey;
      Value copyVal;
      Value copyNextVal;
      SerializationCopier<Value> nextValCopier=new SerializationCopier<Value>();
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (taskCanceled)         return false;
        if (firstValue)         return true;
        return values.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return origVal;
        }
 else {
          Value nextVal=values.next();
          copyKey=keySerialization.newInstance();
          keyCopier.getCopy(copyKey);
          copyVal=valSerialization.newInstance();
          valCopier.getCopy(copyVal);
          nextValCopier.setCopy(nextVal);
          copyNextVal=valSerialization.newInstance();
          nextValCopier.getCopy(copyNextVal);
          stub.match(copyKey,copyVal,copyNextVal,out);
          return nextVal;
        }
      }
    }
;
    SpillingResettableIterator<Value> valResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(stub.getFirstInValueType());
      valResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),valReader,(long)(this.availableMemory * MEMORY_SHARE_RATIO),v1Deserializer,this);
      valResettableIterator.open();
      long readCnt=1;
      long cnt=0;
      while (!this.taskCanceled && cnt < readCnt && valResettableIterator.hasNext()) {
        valResettableIterator.next();
        cnt++;
      }
      while (!this.taskCanceled && valResettableIterator.hasNext()) {
        Value crossVal=valResettableIterator.next();
        readCnt++;
        valCopier.setCopy(crossVal);
        valResettableIterator.reset();
        while (!this.taskCanceled && valResettableIterator.hasNext()) {
          copyKey=keySerialization.newInstance();
          keyCopier.getCopy(copyKey);
          copyVal=valSerialization.newInstance();
          valCopier.getCopy(copyVal);
          stub.match(copyKey,copyVal,valResettableIterator.next(),out);
        }
        valResettableIterator.reset();
        cnt=0;
        while (!this.taskCanceled && cnt < readCnt && valResettableIterator.hasNext()) {
          valResettableIterator.next();
          cnt++;
        }
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (valResettableIterator != null) {
        valResettableIterator.close();
      }
    }
  }
}","/** 
 * Crosses the values of all pairs that have the same key. The   {@link MatchStub#match(Key,Iterator,Collector)} method is called for each element of the Cartesian product. 
 * @param key The key of all values in the iterator.
 * @param vals An iterator over values that share the same key.
 * @param out The collector to write the results to.
 */
private final void crossValues(Key key,final Iterator<Value> values,final Collector<Key,Value> out){
  final Value[] valBuffer=new Value[VALUE_BUFFER_SIZE];
  this.keyCopier.setCopy(key);
  Key copyKey;
  Value outerVal;
  Value innerVal;
  int bufferValCnt;
  for (bufferValCnt=0; bufferValCnt < VALUE_BUFFER_SIZE; bufferValCnt++) {
    if (values.hasNext()) {
      valBuffer[bufferValCnt]=values.next();
    }
 else {
      break;
    }
  }
  for (int i=0; i < bufferValCnt; i++) {
    this.outerValCopier.setCopy(valBuffer[i]);
    for (int j=0; j < bufferValCnt; j++) {
      this.innerValCopier.setCopy(valBuffer[j]);
      copyKey=keySerialization.newInstance();
      this.keyCopier.getCopy(copyKey);
      outerVal=valSerialization.newInstance();
      this.outerValCopier.getCopy(outerVal);
      innerVal=valSerialization.newInstance();
      this.innerValCopier.getCopy(innerVal);
      stub.match(copyKey,outerVal,innerVal,out);
    }
  }
  if (values.hasNext()) {
    Reader<Value> valReader=new Reader<Value>(){
      int bufferIdx=0;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (taskCanceled)         return false;
        if (bufferIdx < VALUE_BUFFER_SIZE)         return true;
        return values.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (bufferIdx < VALUE_BUFFER_SIZE) {
          return valBuffer[bufferIdx++];
        }
 else {
          Value nextVal=values.next();
          Key copyKey;
          Value outerVal;
          Value innerVal;
          outerValCopier.setCopy(nextVal);
          for (int i=0; i < VALUE_BUFFER_SIZE; i++) {
            innerValCopier.setCopy(valBuffer[i]);
            copyKey=keySerialization.newInstance();
            keyCopier.getCopy(copyKey);
            outerVal=valSerialization.newInstance();
            outerValCopier.getCopy(outerVal);
            innerVal=valSerialization.newInstance();
            innerValCopier.getCopy(innerVal);
            stub.match(copyKey,outerVal,innerVal,out);
          }
          return nextVal;
        }
      }
    }
;
    SpillingResettableIterator<Value> innerValResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(stub.getFirstInValueType());
      innerValResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),valReader,(long)(this.availableMemory * (MEMORY_SHARE_RATIO / 2)),v1Deserializer,this);
      innerValResettableIterator.open();
      long readCnt=VALUE_BUFFER_SIZE;
      long cnt=0;
      while (!this.taskCanceled && cnt < readCnt && innerValResettableIterator.hasNext()) {
        innerValResettableIterator.next();
        cnt++;
      }
      while (!this.taskCanceled && innerValResettableIterator.hasNext()) {
        for (bufferValCnt=0; bufferValCnt < VALUE_BUFFER_SIZE; bufferValCnt++) {
          if (!innerValResettableIterator.hasNext()) {
            break;
          }
          valBuffer[bufferValCnt]=innerValResettableIterator.next();
        }
        readCnt+=bufferValCnt;
        innerValResettableIterator.reset();
        while (!this.taskCanceled && innerValResettableIterator.hasNext()) {
          outerValCopier.setCopy(innerValResettableIterator.next());
          for (int i=0; i < bufferValCnt; i++) {
            innerValCopier.setCopy(valBuffer[i]);
            copyKey=keySerialization.newInstance();
            keyCopier.getCopy(copyKey);
            outerVal=valSerialization.newInstance();
            outerValCopier.getCopy(outerVal);
            innerVal=valSerialization.newInstance();
            innerValCopier.getCopy(innerVal);
            stub.match(copyKey,outerVal,innerVal,out);
          }
        }
        innerValResettableIterator.reset();
        cnt=0;
        while (!this.taskCanceled && cnt < readCnt && innerValResettableIterator.hasNext()) {
          innerValResettableIterator.next();
          cnt++;
        }
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (innerValResettableIterator != null) {
        innerValResettableIterator.close();
      }
    }
  }
}",0.5563076923076923
56061,"@Test public void testSortSelfMatchTask(){
  int keyCnt=100;
  int valCnt=5;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,false));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SORT_SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  for (  KeyValuePair<PactInteger,PactInteger> pair : outList) {
    Integer key=pair.getKey().getValue();
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    Assert.assertTrue(""String_Node_Str"" + keyValCntMap.get(key) + ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key) != (valCnt * valCnt));
  }
  outList.clear();
}","@Test public void testSortSelfMatchTask(){
  int keyCnt=100;
  int valCnt=14;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,false));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SORT_SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  for (  KeyValuePair<PactInteger,PactInteger> pair : outList) {
    Integer key=pair.getKey().getValue();
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    Assert.assertTrue(""String_Node_Str"" + key + ""String_Node_Str""+ keyValCntMap.get(key)+ ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key).intValue() == (valCnt * valCnt));
  }
  outList.clear();
}",0.9702290076335878
56062,"@Test public void testNoneSelfMatchTask(){
  int keyCnt=100;
  int valCnt=5;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,true));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  for (  KeyValuePair<PactInteger,PactInteger> pair : outList) {
    Integer key=pair.getKey().getValue();
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    Assert.assertTrue(""String_Node_Str"" + keyValCntMap.get(key) + ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key) != (valCnt * valCnt));
  }
  outList.clear();
}","@Test public void testNoneSelfMatchTask(){
  int keyCnt=100;
  int valCnt=5;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,true));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  for (  KeyValuePair<PactInteger,PactInteger> pair : outList) {
    Integer key=pair.getKey().getValue();
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    Assert.assertTrue(""String_Node_Str"" + keyValCntMap.get(key) + ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key) == (valCnt * valCnt));
  }
  outList.clear();
}",0.999222395023328
56063,"/** 
 * Closes the input stream of the input format.
 */
public void closeInput(){
  if (this.stream != null) {
    this.stream.close();
  }
}","/** 
 * Closes the input stream of the input format.
 */
public void closeInput() throws IOException {
  if (this.stream != null) {
    this.stream.close();
  }
}",0.9342105263157896
56064,"/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  KeyValuePair<Key,Value> pair=null;
  LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  final Iterator<FileInputSplit> splitIterator=getFileInputSplits();
  boolean immutable=config.getMutability() == Config.Mutability.IMMUTABLE;
  while (!this.taskCanceled && splitIterator.hasNext()) {
    final FileInputSplit split=splitIterator.next();
    final long start=split.getStart();
    final long length=split.getLength();
    LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    FSDataInputStream fdis=null;
    InputSplitOpenThread isot=new InputSplitOpenThread(split);
    isot.start();
    try {
      isot.join();
    }
 catch (    InterruptedException ie) {
      if (isot.getFSDataInputStream() != null) {
        isot.getFSDataInputStream().close();
      }
    }
    if (!this.taskCanceled) {
      try {
        if (!isot.fsDataInputStreamSuccessfullyObtained()) {
          throw isot.getException();
        }
        fdis=isot.getFSDataInputStream();
        format.setInput(new DistributedDataInputStream(fdis),start,length,(1024 * 1024));
        format.open();
        LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
        if (!immutable) {
          pair=format.createPair();
        }
        while (!this.taskCanceled && !format.reachedEnd()) {
          if (immutable) {
            pair=format.createPair();
          }
          boolean valid=format.nextPair(pair);
          if (valid) {
            output.collect(pair.getKey(),pair.getValue());
          }
        }
        LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      }
 catch (      Exception ex) {
        if (!this.taskCanceled) {
          LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
          throw ex;
        }
      }
 finally {
        if (format != null) {
          format.closeInput();
          format.close();
        }
        if (fdis != null) {
          fdis.close();
        }
      }
    }
  }
  if (!this.taskCanceled) {
    LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
 else {
    LOG.warn(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  KeyValuePair<Key,Value> pair=null;
  LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  final Iterator<FileInputSplit> splitIterator=getFileInputSplits();
  boolean immutable=config.getMutability() == Config.Mutability.IMMUTABLE;
  while (!this.taskCanceled && splitIterator.hasNext()) {
    final FileInputSplit split=splitIterator.next();
    final long start=split.getStart();
    final long length=split.getLength();
    LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    FSDataInputStream fdis=null;
    InputSplitOpenThread isot=new InputSplitOpenThread(split);
    isot.start();
    try {
      isot.join();
    }
 catch (    InterruptedException ie) {
      if (isot.getFSDataInputStream() != null) {
        isot.getFSDataInputStream().close();
      }
    }
    if (!this.taskCanceled) {
      try {
        if (!isot.fsDataInputStreamSuccessfullyObtained()) {
          throw isot.getException();
        }
        fdis=isot.getFSDataInputStream();
        format.setInput(new DistributedDataInputStream(fdis),start,length,(1024 * 1024));
        format.open();
        LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
        if (!immutable) {
          pair=format.createPair();
        }
        while (!this.taskCanceled && !format.reachedEnd()) {
          if (immutable) {
            pair=format.createPair();
          }
          boolean valid=format.nextPair(pair);
          if (valid) {
            output.collect(pair.getKey(),pair.getValue());
          }
        }
        LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      }
 catch (      Exception ex) {
        if (!this.taskCanceled) {
          LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
          throw ex;
        }
      }
 finally {
        if (format != null) {
          try {
            format.closeInput();
          }
 catch (          IOException ioe) {
            LOG.error(""String_Node_Str"");
            throw ioe;
          }
          try {
            format.close();
          }
 catch (          IOException ioe) {
            LOG.error(""String_Node_Str"");
            throw ioe;
          }
        }
      }
    }
  }
  if (!this.taskCanceled) {
    LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
 else {
    LOG.warn(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
}",0.8704264099037139
56065,"@Override public void run(){
  while (this.alive) {
    IORequest<Buffer.Input> request=null;
    while (request == null) {
      try {
        request=this.requestQueue.take();
      }
 catch (      InterruptedException iex) {
        if (!this.alive) {
          return;
        }
      }
    }
    IOException ioex=null;
    try {
      request.buffer.readFromChannel(request.channel.fileChannel);
    }
 catch (    IOException e) {
      ioex=e;
    }
    request.channel.handleProcessedBuffer(request.buffer,ioex);
  }
}","@Override public void run(){
  while (this.alive) {
    IORequest<Buffer.Input> request=null;
    while (request == null) {
      try {
        request=this.requestQueue.take();
      }
 catch (      InterruptedException iex) {
        if (!this.alive) {
          return;
        }
      }
    }
    IOException ioex=null;
    try {
      if (!request.buffer.memory.isFree()) {
        request.buffer.readFromChannel(request.channel.fileChannel);
      }
    }
 catch (    IOException e) {
      ioex=e;
    }
catch (    Throwable t) {
      ioex=new IOException(""String_Node_Str"" + t.getMessage(),t);
    }
    request.channel.handleProcessedBuffer(request.buffer,ioex);
  }
}",0.8728179551122195
56066,"@Override public void run(){
  while (this.alive) {
    IORequest<Buffer.Output> request=null;
    while (request == null) {
      try {
        request=requestQueue.take();
      }
 catch (      InterruptedException iex) {
        if (!this.alive) {
          return;
        }
      }
    }
    IOException ioex=null;
    try {
      request.buffer.writeToChannel(request.channel.fileChannel);
    }
 catch (    IOException e) {
      ioex=e;
    }
    request.channel.handleProcessedBuffer(request.buffer,ioex);
  }
}","@Override public void run(){
  while (this.alive) {
    IORequest<Buffer.Output> request=null;
    while (request == null) {
      try {
        request=requestQueue.take();
      }
 catch (      InterruptedException iex) {
        if (!this.alive) {
          return;
        }
      }
    }
    IOException ioex=null;
    try {
      if (!request.buffer.memory.isFree()) {
        request.buffer.writeToChannel(request.channel.fileChannel);
      }
    }
 catch (    IOException e) {
      ioex=e;
    }
catch (    Throwable t) {
      ioex=new IOException(""String_Node_Str"" + t.getMessage(),t);
    }
    request.channel.handleProcessedBuffer(request.buffer,ioex);
  }
}",0.8717518860016764
56067,"/** 
 * Skips   {@code size} memory.
 */
public DataInputView skip(int size);","/** 
 * Skips   {@code size} memory.
 */
public DataInputView skip(int size) throws EOFException ;",0.88
56068,"@Override public DataInputView skip(int size){
  position+=size;
  return this;
}","@Override public DataInputView skip(int size) throws EOFException {
  final int newPos=this.position + size;
  if (newPos < 0 || newPos > this.end) {
    throw new EOFException();
  }
  this.position=newPos;
  return this;
}",0.4524590163934426
56069,"@Override public String readLine() throws IOException {
  if (position < this.end) {
    char curr=readChar();
    while (position < this.end && curr != '\n') {
      bld.append(curr);
      curr=readChar();
    }
    int len=bld.length();
    if (len > 0 && bld.charAt(len - 1) == '\r') {
      bld.setLength(len - 1);
    }
    String s=bld.toString();
    bld.setLength(0);
    return s;
  }
 else {
    return null;
  }
}","@Override public String readLine() throws IOException {
  if (this.position < this.end) {
    char curr=readChar();
    while (position < this.end && curr != '\n') {
      bld.append(curr);
      curr=readChar();
    }
    int len=bld.length();
    if (len > 0 && bld.charAt(len - 1) == '\r') {
      bld.setLength(len - 1);
    }
    String s=bld.toString();
    bld.setLength(0);
    return s;
  }
 else {
    return null;
  }
}",0.9941520467836256
56070,"@Override public DataInputView setPosition(int position){
  this.position=position + this.offset;
  return this;
}","@Override public DataInputView setPosition(int position){
  if (position < 0 | position > this.size) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + this.size + ""String_Node_Str"");
  }
  this.position=position + this.offset;
  return this;
}",0.6178861788617886
56071,"@Override public char readChar() throws IOException {
  if (position + 1 < this.end) {
    return (char)(((this.memory[position++] & 0xff) << 8) | ((this.memory[position++] & 0xff) << 0));
  }
 else {
    throw new EOFException();
  }
}","@Override public char readChar() throws IOException {
  if (this.position < this.end - 1) {
    return (char)(((this.memory[this.position++] & 0xff) << 8) | ((this.memory[this.position++] & 0xff) << 0));
  }
 else {
    throw new EOFException();
  }
}",0.8829568788501027
56072,"@Override public int skipBytes(int n) throws IOException {
  if (position + n <= this.end) {
    position+=n;
    return n;
  }
 else {
    n=this.end - position;
    position=this.end;
    return n;
  }
}","@Override public int skipBytes(int n) throws IOException {
  if (this.position <= this.end - n) {
    this.position+=n;
    return n;
  }
 else {
    n=this.end - this.position;
    this.position=this.end;
    return n;
  }
}",0.4372093023255814
56073,"@Override public int getPosition(){
  return position - this.offset;
}","@Override public int getPosition(){
  return this.position - this.offset;
}",0.9655172413793104
56074,"@Override public long readLong() throws IOException {
  if (position >= 0 && position + 7 < this.end) {
    return (((long)this.memory[position++] & 0xff) << 56) | (((long)this.memory[position++] & 0xff) << 48) | (((long)this.memory[position++] & 0xff) << 40)| (((long)this.memory[position++] & 0xff) << 32)| (((long)this.memory[position++] & 0xff) << 24)| (((long)this.memory[position++] & 0xff) << 16)| (((long)this.memory[position++] & 0xff) << 8)| (((long)this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}","@Override public long readLong() throws IOException {
  if (position >= 0 && position < this.end - 7) {
    return (((long)this.memory[position++] & 0xff) << 56) | (((long)this.memory[position++] & 0xff) << 48) | (((long)this.memory[position++] & 0xff) << 40)| (((long)this.memory[position++] & 0xff) << 32)| (((long)this.memory[position++] & 0xff) << 24)| (((long)this.memory[position++] & 0xff) << 16)| (((long)this.memory[position++] & 0xff) << 8)| (((long)this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}",0.978021978021978
56075,"@Override public short readShort() throws IOException {
  if (position >= 0 && position + 1 < this.end) {
    return (short)((((this.memory[position++]) & 0xff) << 8) | (((this.memory[position++]) & 0xff) << 0));
  }
 else {
    throw new EOFException();
  }
}","@Override public short readShort() throws IOException {
  if (position >= 0 && position < this.end - 1) {
    return (short)((((this.memory[position++]) & 0xff) << 8) | (((this.memory[position++]) & 0xff) << 0));
  }
 else {
    throw new EOFException();
  }
}",0.953846153846154
56076,"@Override public void readFully(byte[] b,int off,int len) throws IOException {
  if (position < this.end && position + len <= this.end && off + len <= b.length) {
    System.arraycopy(this.memory,position,b,off,len);
    position+=len;
  }
 else {
    throw new EOFException();
  }
}","@Override public void readFully(byte[] b,int off,int len) throws IOException {
  if (this.position < this.end && this.position <= this.end - len && off <= b.length - len) {
    System.arraycopy(this.memory,position,b,off,len);
    position+=len;
  }
 else {
    throw new EOFException();
  }
}",0.8958333333333334
56077,"@Override public DataInputView reset(){
  position=this.offset;
  return this;
}","@Override public DataInputView reset(){
  this.position=this.offset;
  return this;
}",0.9696969696969696
56078,"@Override public boolean readBoolean() throws IOException {
  if (position < this.end) {
    return this.memory[position++] != 0;
  }
 else {
    throw new EOFException();
  }
}","@Override public boolean readBoolean() throws IOException {
  if (this.position < this.end) {
    return this.memory[this.position++] != 0;
  }
 else {
    throw new EOFException();
  }
}",0.9725274725274724
56079,"@Override public byte readByte() throws IOException {
  if (position < this.end) {
    return this.memory[position++];
  }
 else {
    throw new EOFException();
  }
}","@Override public byte readByte() throws IOException {
  if (this.position < this.end) {
    return this.memory[this.position++];
  }
 else {
    throw new EOFException();
  }
}",0.9707602339181286
56080,"@Override public int readInt() throws IOException {
  if (position >= 0 && position + 3 < this.end) {
    return ((this.memory[position++] & 0xff) << 24) | ((this.memory[position++] & 0xff) << 16) | ((this.memory[position++] & 0xff) << 8)| ((this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}","@Override public int readInt() throws IOException {
  if (this.position >= 0 && this.position < this.end - 3) {
    return ((this.memory[position++] & 0xff) << 24) | ((this.memory[position++] & 0xff) << 16) | ((this.memory[position++] & 0xff) << 8)| ((this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}",0.921921921921922
56081,"@Override public int readUnsignedByte() throws IOException {
  if (position < this.end) {
    return (this.memory[position++] & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public int readUnsignedByte() throws IOException {
  if (this.position < this.end) {
    return (this.memory[this.position++] & 0xff);
  }
 else {
    throw new EOFException();
  }
}",0.9732620320855616
56082,"@Override public int readUnsignedShort() throws IOException {
  if (position + 1 < this.end) {
    return ((this.memory[position++] & 0xff) << 8) | ((this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}","@Override public int readUnsignedShort() throws IOException {
  if (this.position < this.end - 1) {
    return ((this.memory[this.position++] & 0xff) << 8) | ((this.memory[this.position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}",0.8829568788501027
56083,"@Override public void writeInt(int v) throws IOException {
  if (position + 3 < this.end) {
    this.memory[position++]=(byte)((v >> 24) & 0xff);
    this.memory[position++]=(byte)((v >> 16) & 0xff);
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeInt(int v) throws IOException {
  if (position < this.end - 3) {
    this.memory[position++]=(byte)((v >> 24) & 0xff);
    this.memory[position++]=(byte)((v >> 16) & 0xff);
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}",0.9660056657223796
56084,"@Override public void writeChar(int v) throws IOException {
  if (position + 1 < this.end) {
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeChar(int v) throws IOException {
  if (position < this.end - 1) {
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}",0.951219512195122
56085,"@Override public void writeLong(long v) throws IOException {
  if (position + 7 < this.end) {
    this.memory[position++]=(byte)((v >> 56) & 0xff);
    this.memory[position++]=(byte)((v >> 48) & 0xff);
    this.memory[position++]=(byte)((v >> 40) & 0xff);
    this.memory[position++]=(byte)((v >> 32) & 0xff);
    this.memory[position++]=(byte)((v >> 24) & 0xff);
    this.memory[position++]=(byte)((v >> 16) & 0xff);
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeLong(long v) throws IOException {
  if (position < this.end - 7) {
    this.memory[position++]=(byte)((v >> 56) & 0xff);
    this.memory[position++]=(byte)((v >> 48) & 0xff);
    this.memory[position++]=(byte)((v >> 40) & 0xff);
    this.memory[position++]=(byte)((v >> 32) & 0xff);
    this.memory[position++]=(byte)((v >> 24) & 0xff);
    this.memory[position++]=(byte)((v >> 16) & 0xff);
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}",0.978984238178634
56086,"@Override public int getPosition(){
  return position - this.offset;
}","@Override public int getPosition(){
  return this.position - this.offset;
}",0.9655172413793104
56087,"@Override public void writeBytes(String s) throws IOException {
  final int sLen=s.length();
  if (this.position + sLen < this.end) {
    for (int i=0; i < sLen; i++) {
      writeByte(s.charAt(i));
    }
    this.position+=sLen;
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeBytes(String s) throws IOException {
  final int sLen=s.length();
  if (this.position < this.end - sLen) {
    for (int i=0; i < sLen; i++) {
      writeByte(s.charAt(i));
    }
    this.position+=sLen;
  }
 else {
    throw new EOFException();
  }
}",0.9747292418772564
56088,"@Override public DataOutputView reset(){
  position=this.offset;
  return this;
}","@Override public DataOutputView reset(){
  this.position=this.offset;
  return this;
}",0.9700598802395208
56089,"@Override public void writeShort(int v) throws IOException {
  if (position + 1 < this.end) {
    this.memory[position++]=(byte)((v >>> 8) & 0xff);
    this.memory[position++]=(byte)((v >>> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeShort(int v) throws IOException {
  if (position < this.end - 1) {
    this.memory[position++]=(byte)((v >>> 8) & 0xff);
    this.memory[position++]=(byte)((v >>> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}",0.9518072289156626
56090,"@Override public void writeChars(String s) throws IOException {
  if (position + 2 * s.length() < this.end) {
    int length=s.length();
    for (int i=0; i < length; i++) {
      writeChar(s.charAt(i));
    }
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeChars(String s) throws IOException {
  if (position < this.end - (2 * s.length())) {
    int length=s.length();
    for (int i=0; i < length; i++) {
      writeChar(s.charAt(i));
    }
  }
 else {
    throw new EOFException();
  }
}",0.9457364341085271
56091,"@Override public void write(byte[] b,int off,int len) throws IOException {
  if (position < this.end && position + len <= this.end && off + len <= b.length) {
    System.arraycopy(b,off,this.memory,position,len);
    position+=len;
  }
 else {
    throw new EOFException();
  }
}","@Override public void write(byte[] b,int off,int len) throws IOException {
  if (this.position < this.end && this.position <= this.end - len && off <= b.length - len) {
    System.arraycopy(b,off,this.memory,position,len);
    this.position+=len;
  }
 else {
    throw new EOFException();
  }
}",0.8865619546247818
56092,"@Override public void writeBoolean(boolean v) throws IOException {
  if (position < this.end) {
    this.memory[position++]=(byte)(v ? 1 : 0);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeBoolean(boolean v) throws IOException {
  if (this.position < this.end) {
    this.memory[this.position++]=(byte)(v ? 1 : 0);
  }
 else {
    throw new EOFException();
  }
}",0.9743589743589745
56093,"@Override public RandomAccessView get(DataOutput out,int offset,int length) throws IOException {
  if (offset >= 0 && offset < this.size && length >= 0 && length < this.size) {
    out.write(this.memory,this.offset + offset,length);
    return this;
  }
 else {
    throw new IndexOutOfBoundsException();
  }
}","@Override public RandomAccessView get(DataOutput out,int offset,int length) throws IOException {
  if (offset >= 0 && offset < this.size && length >= 0 && offset + length < this.size) {
    out.write(this.memory,this.offset + offset,length);
    return this;
  }
 else {
    throw new IndexOutOfBoundsException();
  }
}",0.985691573926868
56094,"/** 
 * @param matchNode
 * @return
 * @throws CompilerException
 */
private JobTaskVertex generateMatchVertex(OptimizerNode matchNode) throws CompilerException {
  JobTaskVertex matchVertex=new JobTaskVertex(matchNode.getPactContract().getName(),this.jobGraph);
  TaskConfig matchConfig=new TaskConfig(matchVertex.getConfiguration());
  matchConfig.setStubClass(matchNode.getPactContract().getStubClass());
switch (matchNode.getLocalStrategy()) {
case SORT_BOTH_MERGE:
    matchVertex.setTaskClass(MatchTask.class);
  matchConfig.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
break;
case SORT_FIRST_MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
break;
case SORT_SECOND_MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
break;
case MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MERGE);
break;
case HYBRIDHASH_FIRST:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.HYBRIDHASH_FIRST);
break;
case HYBRIDHASH_SECOND:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.HYBRIDHASH_SECOND);
break;
case MMHASH_FIRST:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MMHASH_FIRST);
break;
case MMHASH_SECOND:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MMHASH_SECOND);
break;
case SORT_SELF_NESTEDLOOP:
matchVertex.setTaskClass(SelfMatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_SELF_NESTEDLOOP);
case SELF_NESTEDLOOP:
matchVertex.setTaskClass(SelfMatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
default :
throw new CompilerException(""String_Node_Str"" + matchNode.getName() + ""String_Node_Str""+ matchNode.getLocalStrategy());
}
assignMemory(matchConfig,matchNode.getMemoryPerTask());
matchConfig.setStubParameters(matchNode.getPactContract().getStubParameters());
return matchVertex;
}","/** 
 * @param matchNode
 * @return
 * @throws CompilerException
 */
private JobTaskVertex generateMatchVertex(OptimizerNode matchNode) throws CompilerException {
  JobTaskVertex matchVertex=new JobTaskVertex(matchNode.getPactContract().getName(),this.jobGraph);
  TaskConfig matchConfig=new TaskConfig(matchVertex.getConfiguration());
  matchConfig.setStubClass(matchNode.getPactContract().getStubClass());
switch (matchNode.getLocalStrategy()) {
case SORT_BOTH_MERGE:
    matchVertex.setTaskClass(MatchTask.class);
  matchConfig.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
break;
case SORT_FIRST_MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
break;
case SORT_SECOND_MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
break;
case MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MERGE);
break;
case HYBRIDHASH_FIRST:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.HYBRIDHASH_FIRST);
break;
case HYBRIDHASH_SECOND:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.HYBRIDHASH_SECOND);
break;
case MMHASH_FIRST:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MMHASH_FIRST);
break;
case MMHASH_SECOND:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MMHASH_SECOND);
break;
case SORT_SELF_NESTEDLOOP:
matchVertex.setTaskClass(SelfMatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_SELF_NESTEDLOOP);
break;
case SELF_NESTEDLOOP:
matchVertex.setTaskClass(SelfMatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
break;
default :
throw new CompilerException(""String_Node_Str"" + matchNode.getName() + ""String_Node_Str""+ matchNode.getLocalStrategy());
}
assignMemory(matchConfig,matchNode.getMemoryPerTask());
matchConfig.setStubParameters(matchNode.getPactContract().getStubParameters());
return matchVertex;
}",0.9966118102613748
56095,"/** 
 * Sets the shipping strategy for this connection.
 * @param strategy The shipping strategy to be applied to this connection.
 */
public void setShipStrategy(ShipStrategy strategy){
  if (strategy == ShipStrategy.FORWARD && sourcePact.getDegreeOfParallelism() < targetPact.getDegreeOfParallelism()) {
    for (    InterestingProperties props : this.interestingProps) {
      PartitionProperty pp=props.getGlobalProperties().getPartitioning();
      if (pp == PartitionProperty.HASH_PARTITIONED || pp == PartitionProperty.ANY) {
        strategy=ShipStrategy.PARTITION_LOCAL_HASH;
        break;
      }
 else       if (pp == PartitionProperty.RANGE_PARTITIONED) {
        throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  this.shipStrategy=strategy;
}","/** 
 * Sets the shipping strategy for this connection.
 * @param strategy The shipping strategy to be applied to this connection.
 */
public void setShipStrategy(ShipStrategy strategy){
  if (strategy == ShipStrategy.FORWARD && sourcePact.getDegreeOfParallelism() < targetPact.getDegreeOfParallelism()) {
    if (this.interestingProps != null) {
      for (      InterestingProperties props : this.interestingProps) {
        PartitionProperty pp=props.getGlobalProperties().getPartitioning();
        if (pp == PartitionProperty.HASH_PARTITIONED || pp == PartitionProperty.ANY) {
          strategy=ShipStrategy.PARTITION_LOCAL_HASH;
          break;
        }
 else         if (pp == PartitionProperty.RANGE_PARTITIONED) {
          throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
  this.shipStrategy=strategy;
}",0.9535304767652384
56096,"/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    channelType=ChannelType.INMEMORY;
  break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}","/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceInnerDOP=connection.getSourcePact().getInstancesPerMachine();
int sourceNumInstances=(int)Math.ceil((double)sourceDOP / (double)sourceInnerDOP);
int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
int targetInnerDOP=connection.getTargetPact().getInstancesPerMachine();
int targetNumInstances=(int)Math.ceil((double)targetDOP / (double)targetInnerDOP);
channelType=sourceNumInstances == targetNumInstances ? ChannelType.INMEMORY : ChannelType.NETWORK;
break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}",0.9047198161569736
56097,"/** 
 * This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and sets local strategy.
 * @param node The node that is currently processed.
 * @return True, if the visitor should descend to the node's children, false if not.
 * @see eu.stratosphere.pact.common.plan.Visitor#preVisit(eu.stratosphere.pact.common.plan.Visitable)
 */
@Override public boolean preVisit(OptimizerNode node){
  if (vertices.containsKey(node)) {
    return false;
  }
  AbstractJobVertex vertex=null;
  try {
switch (node.getPactType()) {
case Map:
      vertex=generateMapVertex(node);
    break;
case Reduce:
  if (node instanceof ReduceNode) {
    vertex=generateReduceVertex((ReduceNode)node);
  }
 else   if (node instanceof CombinerNode) {
    vertex=generateCombineVertex((CombinerNode)node);
  }
 else {
    throw new CompilerException(""String_Node_Str"" + node.getClass().getName());
  }
break;
case Match:
vertex=generateMatchVertex(node);
break;
case Cross:
vertex=generateCrossVertex(node);
break;
case Cogroup:
vertex=generateCoGroupVertex(node);
break;
case DataSource:
vertex=generateDataSourceVertex(node);
break;
case DataSink:
vertex=generateDataSinkVertex(node);
break;
default :
throw new Exception(""String_Node_Str"" + node.getPactType());
}
}
 catch (NotEnoughMemoryException nemex) {
throw new CompilerException(""String_Node_Str"" + node.getMemoryPerTask() + ""String_Node_Str""+ node.toString()+ ""String_Node_Str"");
}
catch (Exception e) {
throw new CompilerException(""String_Node_Str"" + e.getMessage(),e);
}
int pd=node.getDegreeOfParallelism();
vertex.setNumberOfSubtasks(pd);
if (maxDegreeVertex == null || maxDegreeVertex.getNumberOfSubtasks() < pd) {
maxDegreeVertex=vertex;
}
if (node.getInstancesPerMachine() >= 1) {
vertex.setNumberOfSubtasksPerInstance(node.getInstancesPerMachine());
}
this.vertices.put(node,vertex);
return true;
}","/** 
 * This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and sets local strategy.
 * @param node The node that is currently processed.
 * @return True, if the visitor should descend to the node's children, false if not.
 * @see eu.stratosphere.pact.common.plan.Visitor#preVisit(eu.stratosphere.pact.common.plan.Visitable)
 */
@Override public boolean preVisit(OptimizerNode node){
  if (vertices.containsKey(node)) {
    return false;
  }
  AbstractJobVertex vertex=null;
  try {
switch (node.getPactType()) {
case Map:
      vertex=generateMapVertex(node);
    break;
case Reduce:
  if (node instanceof ReduceNode) {
    vertex=generateReduceVertex((ReduceNode)node);
  }
 else   if (node instanceof CombinerNode) {
    vertex=generateCombineVertex((CombinerNode)node);
  }
 else {
    throw new CompilerException(""String_Node_Str"" + node.getClass().getName());
  }
break;
case Match:
vertex=generateMatchVertex(node);
break;
case Cross:
vertex=generateCrossVertex(node);
break;
case Cogroup:
vertex=generateCoGroupVertex(node);
break;
case DataSource:
vertex=generateDataSourceVertex(node);
break;
case DataSink:
vertex=generateDataSinkVertex(node);
break;
default :
throw new Exception(""String_Node_Str"" + node.getPactType());
}
}
 catch (Exception e) {
throw new CompilerException(""String_Node_Str"" + e.getMessage(),e);
}
int pd=node.getDegreeOfParallelism();
vertex.setNumberOfSubtasks(pd);
if (maxDegreeVertex == null || maxDegreeVertex.getNumberOfSubtasks() < pd) {
maxDegreeVertex=vertex;
}
if (node.getInstancesPerMachine() >= 1) {
vertex.setNumberOfSubtasksPerInstance(node.getInstancesPerMachine());
}
this.vertices.put(node,vertex);
return true;
}",0.951797157982725
56098,"/** 
 * Private utility method that generates the alternative Cross nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<CrossNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  LocalProperties lpDefaults=new LocalProperties();
  GlobalProperties gp=null;
  LocalProperties lp=null;
  OutputContract oc=getOutputContract();
  boolean isFirst=false;
  if (oc.appliesToFirstInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
    isFirst=true;
  }
 else   if (oc.appliesToSecondInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  }
 else {
    gp=new GlobalProperties();
    lp=new LocalProperties();
  }
  gp.setKeyUnique(false);
  lp.setKeyUnique(false);
  GlobalProperties gpNoOrder=gp.createCopy();
  gpNoOrder.setKeyOrder(Order.NONE);
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      gp=isFirst ? gp : gpNoOrder;
      lp=isFirst ? lp : lpDefaults;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      gp=isFirst ? gpNoOrder : gp;
      lp=isFirst ? lpDefaults : lp;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST || ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      gp=gpNoOrder;
      lp=lpDefaults;
    }
 else {
      return;
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,ls,gp,lp,estimator);
  }
 else {
    if (isFirst) {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
 else {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND,gpNoOrder,lpDefaults,estimator);
  }
}","/** 
 * Private utility method that generates the alternative Cross nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<CrossNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  LocalProperties lpDefaults=new LocalProperties();
  GlobalProperties gp=null;
  LocalProperties lp=null;
  OutputContract oc=getOutputContract();
  boolean isFirst=false;
  if (oc.appliesToFirstInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
    isFirst=true;
  }
 else   if (oc.appliesToSecondInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  }
 else {
    gp=new GlobalProperties();
    lp=new LocalProperties();
  }
  gp.setKeyUnique(false);
  lp.setKeyUnique(false);
  GlobalProperties gpNoOrder=gp.createCopy();
  gpNoOrder.setKeyOrder(Order.NONE);
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      gp=isFirst ? gp : gpNoOrder;
      lp=isFirst ? lp : lpDefaults;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      gp=isFirst ? gpNoOrder : gp;
      lp=isFirst ? lpDefaults : lp;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST || ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      gp=gpNoOrder;
      lp=lpDefaults;
    }
 else {
      return;
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,ls,gp,lp,estimator);
  }
 else {
    if (pred1.getEstimatedOutputSize() > 0 && pred2.getEstimatedOutputSize() > 0) {
      if (isFirst) {
        createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gp,lp,estimator);
        createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
      }
 else {
        createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gp,lp,estimator);
        createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
      }
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND,gpNoOrder,lpDefaults,estimator);
  }
}",0.9825795644891122
56099,"/** 
 * Wires this group vertex to the specified group vertex and creates a back link.
 * @param groupVertex the group vertex that should be the target of the wiring
 * @param indexOfInputGate the index of the consuming task's input gate
 * @param indexOfOutputGate the index of the producing tasks's output gate
 * @param channelType the channel type to be used for this edge
 * @param userDefinedChannelType <code>true</code> if the channel type is user defined, <code>false</code> otherwise
 * @param compressionLevel the compression level to be used for this edge
 * @param userDefinedCompressionLevel <code>true</code> if the compression level is user defined, <code>false</code> otherwise
 */
public void wireTo(ExecutionGroupVertex groupVertex,int indexOfInputGate,int indexOfOutputGate,ChannelType channelType,boolean userDefinedChannelType,CompressionLevel compressionLevel,boolean userDefinedCompressionLevel) throws GraphConversionException {
  List<ExecutionGroupEdge> edges=this.getForwardEdges(groupVertex);
  if (edges.size() > 0) {
    if (channelType != edges.get(0).getChannelType()) {
      if (userDefinedChannelType) {
        throw new GraphConversionException(""String_Node_Str"" + getName() + ""String_Node_Str""+ groupVertex+ ""String_Node_Str"");
      }
 else {
        channelType=edges.get(0).getChannelType();
      }
    }
  }
  final ExecutionGroupEdge edge=new ExecutionGroupEdge(this.executionGraph,this,indexOfOutputGate,groupVertex,indexOfInputGate,channelType,userDefinedChannelType,compressionLevel,userDefinedCompressionLevel);
synchronized (this.forwardLinks) {
    this.forwardLinks.add(edge);
  }
  groupVertex.wireBackLink(edge);
}","/** 
 * Wires this group vertex to the specified group vertex and creates a back link.
 * @param groupVertex the group vertex that should be the target of the wiring
 * @param indexOfInputGate the index of the consuming task's input gate
 * @param indexOfOutputGate the index of the producing tasks's output gate
 * @param channelType the channel type to be used for this edge
 * @param userDefinedChannelType <code>true</code> if the channel type is user defined, <code>false</code> otherwise
 * @param compressionLevel the compression level to be used for this edge
 * @param userDefinedCompressionLevel <code>true</code> if the compression level is user defined, <code>false</code> otherwise
 */
public void wireTo(ExecutionGroupVertex groupVertex,int indexOfInputGate,int indexOfOutputGate,ChannelType channelType,boolean userDefinedChannelType,CompressionLevel compressionLevel,boolean userDefinedCompressionLevel) throws GraphConversionException {
synchronized (this.forwardLinks) {
    if (indexOfOutputGate < this.forwardLinks.size()) {
      final ExecutionGroupEdge previousEdge=this.forwardLinks.get(indexOfOutputGate);
      if (previousEdge != null) {
        throw new GraphConversionException(""String_Node_Str"" + indexOfOutputGate + ""String_Node_Str""+ getName()+ ""String_Node_Str"");
      }
    }
  }
  final ExecutionGroupEdge edge=new ExecutionGroupEdge(this.executionGraph,this,indexOfOutputGate,groupVertex,indexOfInputGate,channelType,userDefinedChannelType,compressionLevel,userDefinedCompressionLevel);
synchronized (this.forwardLinks) {
    this.forwardLinks.add(edge);
  }
  groupVertex.wireBackLink(edge);
}",0.6903030303030303
56100,"/** 
 * Tests the Nephele execution with a job that has two vertices, that are connected twice with each other with different channel types.
 */
@Test public void testExecutionDoubleConnection(){
  File inputFile=null;
  File outputFile=null;
  File jarFile=new File(ServerTestUtils.getTempDir() + File.separator + ""String_Node_Str"");
  try {
    inputFile=ServerTestUtils.createInputFile(0);
    outputFile=new File(ServerTestUtils.getTempDir() + File.separator + ServerTestUtils.getRandomFilename());
    JarFileCreator jfc=new JarFileCreator(jarFile);
    jfc.addClass(DoubleSourceTask.class);
    jfc.addClass(DoubleTargetTask.class);
    jfc.createJarFile();
    final JobGraph jg=new JobGraph(""String_Node_Str"");
    final JobFileInputVertex i1=new JobFileInputVertex(""String_Node_Str"",jg);
    i1.setFileInputClass(DoubleSourceTask.class);
    i1.setFilePath(new Path(""String_Node_Str"" + inputFile.getAbsolutePath().toString()));
    final JobTaskVertex t1=new JobTaskVertex(""String_Node_Str"",jg);
    t1.setTaskClass(DoubleTargetTask.class);
    JobFileOutputVertex o1=new JobFileOutputVertex(""String_Node_Str"",jg);
    o1.setFileOutputClass(FileLineWriter.class);
    o1.setFilePath(new Path(""String_Node_Str"" + outputFile.getAbsolutePath().toString()));
    t1.setVertexToShareInstancesWith(i1);
    o1.setVertexToShareInstancesWith(i1);
    i1.connectTo(t1,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    i1.connectTo(t1,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t1.connectTo(o1,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    jg.addJar(new Path(""String_Node_Str"" + jarFile.getAbsolutePath()));
    final JobClient jobClient=new JobClient(jg,configuration);
    try {
      jobClient.submitJobAndWait();
    }
 catch (    JobExecutionException e) {
      if (e.getMessage() == null) {
        fail(""String_Node_Str"");
      }
      if (!e.getMessage().contains(RuntimeExceptionTask.RUNTIME_EXCEPTION_MESSAGE)) {
        fail(""String_Node_Str"");
      }
      return;
    }
    fail(""String_Node_Str"");
  }
 catch (  JobGraphDefinitionException jgde) {
    fail(jgde.getMessage());
  }
catch (  IOException ioe) {
    fail(ioe.getMessage());
  }
 finally {
    if (inputFile != null) {
      inputFile.delete();
    }
    if (outputFile != null) {
      outputFile.delete();
    }
    if (jarFile != null) {
      jarFile.delete();
    }
  }
}","/** 
 * Tests the Nephele execution with a job that has two vertices, that are connected twice with each other with different channel types.
 */
@Test public void testExecutionDoubleConnection(){
  File inputFile=null;
  File outputFile=null;
  File jarFile=new File(ServerTestUtils.getTempDir() + File.separator + ""String_Node_Str"");
  try {
    inputFile=ServerTestUtils.createInputFile(0);
    outputFile=new File(ServerTestUtils.getTempDir() + File.separator + ServerTestUtils.getRandomFilename());
    JarFileCreator jfc=new JarFileCreator(jarFile);
    jfc.addClass(DoubleSourceTask.class);
    jfc.addClass(DoubleTargetTask.class);
    jfc.createJarFile();
    final JobGraph jg=new JobGraph(""String_Node_Str"");
    final JobFileInputVertex i1=new JobFileInputVertex(""String_Node_Str"",jg);
    i1.setFileInputClass(DoubleSourceTask.class);
    i1.setFilePath(new Path(""String_Node_Str"" + inputFile.getAbsolutePath().toString()));
    final JobTaskVertex t1=new JobTaskVertex(""String_Node_Str"",jg);
    t1.setTaskClass(DoubleTargetTask.class);
    JobFileOutputVertex o1=new JobFileOutputVertex(""String_Node_Str"",jg);
    o1.setFileOutputClass(FileLineWriter.class);
    o1.setFilePath(new Path(""String_Node_Str"" + outputFile.getAbsolutePath().toString()));
    t1.setVertexToShareInstancesWith(i1);
    o1.setVertexToShareInstancesWith(i1);
    i1.connectTo(t1,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    i1.connectTo(t1,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t1.connectTo(o1,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    jg.addJar(new Path(""String_Node_Str"" + jarFile.getAbsolutePath()));
    final JobClient jobClient=new JobClient(jg,configuration);
    jobClient.submitJobAndWait();
  }
 catch (  JobExecutionException e) {
    fail(e.getMessage());
  }
catch (  JobGraphDefinitionException jgde) {
    fail(jgde.getMessage());
  }
catch (  IOException ioe) {
    fail(ioe.getMessage());
  }
 finally {
    if (inputFile != null) {
      inputFile.delete();
    }
    if (outputFile != null) {
      outputFile.delete();
    }
    if (jarFile != null) {
      jarFile.delete();
    }
  }
}",0.9435874834728956
56101,"/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  tempIterator=null;
  try {
    tempIterator=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,reader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),stub.getOutValueType()),this);
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    tempIterator.open();
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    while (tempIterator.hasNext() && !this.taskCanceled) {
      KeyValuePair<Key,Value> pair=tempIterator.next();
      writer.emit(pair);
    }
    if (!this.taskCanceled) {
      LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    }
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException(""String_Node_Str"",mae);
  }
catch (  ServiceException se) {
    throw new RuntimeException(se);
  }
catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
catch (  Exception ie) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ie;
    }
  }
 finally {
    tempIterator.close();
  }
  if (!this.taskCanceled) {
    LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
 else {
    LOG.warn(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  tempIterator=null;
  try {
    tempIterator=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,reader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),stub.getOutValueType()),this);
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    tempIterator.open();
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    while (tempIterator.hasNext() && !this.taskCanceled) {
      KeyValuePair<Key,Value> pair=tempIterator.next();
      writer.emit(pair);
    }
    if (!this.taskCanceled) {
      LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    }
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException(""String_Node_Str"",mae);
  }
catch (  ServiceException se) {
    throw new RuntimeException(se);
  }
catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
catch (  Exception ie) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ie;
    }
  }
 finally {
    if (tempIterator != null) {
      tempIterator.close();
    }
  }
  if (!this.taskCanceled) {
    LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
 else {
    LOG.warn(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
}",0.9932975871313672
56102,"/** 
 * <p> Calls the <code>MatchStub#match()</code> method for all two key-value pairs that share the same key and come from different inputs. The output of the <code>match()</code> method is forwarded. <p> This method is called with a key and two iterator (one for each input) over all values that share this key. <p>
 * @param key A key.
 * @param values1 An iterator on values of the first input that were paired with the key.
 * @param values2 An iterator on values of the second input that were paired with the key.
 * @param out A collector that collects all output pairs.
 */
private void crossValues(Key key,final Iterator<Value> values1,final Iterator<Value> values2) throws RuntimeException {
  final Value firstV1=values1.next();
  final Value firstV2=values2.next();
  if (firstV1 == null || firstV2 == null) {
    return;
  }
  boolean v1HasNext=values1.hasNext();
  boolean v2HasNext=values2.hasNext();
  if (!v1HasNext && !v2HasNext) {
    matchStub.match(key,firstV1,firstV2,output);
    return;
  }
  Value v1;
  Value v2;
  keyCopier.setCopy(key);
  if (!v1HasNext) {
    this.v1Copier.setCopy(firstV1);
    matchStub.match(key,firstV1,firstV2,output);
    while (v2HasNext && !this.taskCanceled) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v1=this.v1Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      v2=values2.next();
      v2HasNext=values2.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else   if (!v2HasNext && !this.taskCanceled) {
    this.v2Copier.setCopy(firstV2);
    matchStub.match(key,firstV1,firstV2,output);
    while (v1HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v2=this.v2Serialization.newInstance();
      this.v2Copier.getCopy(v2);
      v1=values1.next();
      v1HasNext=values1.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else {
    Reader<Value> v1Reader=new Reader<Value>(){
      boolean firstValue=true;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (firstValue)         return true;
        return values1.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return firstV1;
        }
        return values1.next();
      }
    }
;
    SpillingResettableIterator<Value> v1ResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(matchStub.getFirstInValueType());
      v1ResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),v1Reader,((int)(MEMORY_IO * MEMORY_SHARE_RATIO)),v1Deserializer,this);
      v1ResettableIterator.open();
      this.v2Copier.setCopy(firstV2);
      while (v1ResettableIterator.hasNext() && !this.taskCanceled) {
        key=this.keySerialization.newInstance();
        this.keyCopier.getCopy(key);
        v2=this.v2Serialization.newInstance();
        this.v2Copier.getCopy(v2);
        v1=v1ResettableIterator.next();
        matchStub.match(key,v1,v2,output);
      }
      v1ResettableIterator.reset();
      while (values2.hasNext() && !this.taskCanceled) {
        v2=values2.next();
        this.v2Copier.setCopy(v2);
        while (v1ResettableIterator.hasNext() && !this.taskCanceled) {
          key=this.keySerialization.newInstance();
          this.keyCopier.getCopy(key);
          v2=this.v2Serialization.newInstance();
          this.v2Copier.getCopy(v2);
          v1=v1ResettableIterator.next();
          matchStub.match(key,v1,v2,output);
        }
        v1ResettableIterator.reset();
      }
      v1ResettableIterator.close();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (v1ResettableIterator != null) {
        try {
          v1ResettableIterator.close();
        }
 catch (        ServiceException e) {
          LOG.warn(e);
        }
      }
    }
  }
}","/** 
 * <p> Calls the <code>MatchStub#match()</code> method for all two key-value pairs that share the same key and come from different inputs. The output of the <code>match()</code> method is forwarded. <p> This method is called with a key and two iterator (one for each input) over all values that share this key. <p>
 * @param key A key.
 * @param values1 An iterator on values of the first input that were paired with the key.
 * @param values2 An iterator on values of the second input that were paired with the key.
 * @param out A collector that collects all output pairs.
 */
private void crossValues(Key key,final Iterator<Value> values1,final Iterator<Value> values2) throws RuntimeException {
  final Value firstV1=values1.next();
  final Value firstV2=values2.next();
  if (firstV1 == null || firstV2 == null) {
    return;
  }
  boolean v1HasNext=values1.hasNext();
  boolean v2HasNext=values2.hasNext();
  if (!v1HasNext && !v2HasNext) {
    matchStub.match(key,firstV1,firstV2,output);
    return;
  }
  Value v1;
  Value v2;
  keyCopier.setCopy(key);
  if (!v1HasNext) {
    this.v1Copier.setCopy(firstV1);
    matchStub.match(key,firstV1,firstV2,output);
    while (v2HasNext && !this.taskCanceled) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v1=this.v1Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      v2=values2.next();
      v2HasNext=values2.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else   if (!v2HasNext && !this.taskCanceled) {
    this.v2Copier.setCopy(firstV2);
    matchStub.match(key,firstV1,firstV2,output);
    while (v1HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v2=this.v2Serialization.newInstance();
      this.v2Copier.getCopy(v2);
      v1=values1.next();
      v1HasNext=values1.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else {
    Reader<Value> v1Reader=new Reader<Value>(){
      boolean firstValue=true;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (firstValue)         return true;
        return values1.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return firstV1;
        }
        return values1.next();
      }
    }
;
    SpillingResettableIterator<Value> v1ResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(matchStub.getFirstInValueType());
      v1ResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),v1Reader,((int)(MEMORY_IO * MEMORY_SHARE_RATIO)),v1Deserializer,this);
      v1ResettableIterator.open();
      this.v2Copier.setCopy(firstV2);
      while (v1ResettableIterator.hasNext() && !this.taskCanceled) {
        key=this.keySerialization.newInstance();
        this.keyCopier.getCopy(key);
        v2=this.v2Serialization.newInstance();
        this.v2Copier.getCopy(v2);
        v1=v1ResettableIterator.next();
        matchStub.match(key,v1,v2,output);
      }
      v1ResettableIterator.reset();
      while (values2.hasNext() && !this.taskCanceled) {
        v2=values2.next();
        this.v2Copier.setCopy(v2);
        while (v1ResettableIterator.hasNext() && !this.taskCanceled) {
          key=this.keySerialization.newInstance();
          this.keyCopier.getCopy(key);
          v2=this.v2Serialization.newInstance();
          this.v2Copier.getCopy(v2);
          v1=v1ResettableIterator.next();
          matchStub.match(key,v1,v2,output);
        }
        v1ResettableIterator.reset();
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (v1ResettableIterator != null) {
        try {
          v1ResettableIterator.close();
        }
 catch (        ServiceException e) {
          LOG.warn(e);
        }
      }
    }
  }
}",0.9956300072833212
56103,"/** 
 * Sets the shipping strategy for this connection.
 * @param strategy The shipping strategy to be applied to this connection.
 */
public void setShipStrategy(ShipStrategy strategy){
  if (strategy == ShipStrategy.FORWARD && sourcePact.getDegreeOfParallelism() < targetPact.getDegreeOfParallelism()) {
    for (    InterestingProperties props : this.interestingProps) {
      PartitionProperty pp=props.getGlobalProperties().getPartitioning();
      if (pp == PartitionProperty.HASH_PARTITIONED || pp == PartitionProperty.ANY) {
        strategy=ShipStrategy.PARTITION_LOCAL_HASH;
        break;
      }
 else       if (pp == PartitionProperty.RANGE_PARTITIONED) {
        throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  this.shipStrategy=strategy;
}","/** 
 * Sets the shipping strategy for this connection.
 * @param strategy The shipping strategy to be applied to this connection.
 */
public void setShipStrategy(ShipStrategy strategy){
  if (strategy == ShipStrategy.FORWARD && sourcePact.getDegreeOfParallelism() < targetPact.getDegreeOfParallelism()) {
    if (this.interestingProps != null) {
      for (      InterestingProperties props : this.interestingProps) {
        PartitionProperty pp=props.getGlobalProperties().getPartitioning();
        if (pp == PartitionProperty.HASH_PARTITIONED || pp == PartitionProperty.ANY) {
          strategy=ShipStrategy.PARTITION_LOCAL_HASH;
          break;
        }
 else         if (pp == PartitionProperty.RANGE_PARTITIONED) {
          throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
  this.shipStrategy=strategy;
}",0.9535304767652384
56104,"@Test public void testJob() throws Exception {
  preSubmit();
  JobGraph jobGraph=getJobGraph();
  cluster.submitJobAndWait(jobGraph,getJarFilePath());
  postSubmit();
}","@Test public void testJob() throws Exception {
  preSubmit();
  JobGraph jobGraph=null;
  try {
    jobGraph=getJobGraph();
  }
 catch (  Exception e) {
    LOG.error(e);
    Assert.fail(""String_Node_Str"");
  }
  try {
    cluster.submitJobAndWait(jobGraph,getJarFilePath());
  }
 catch (  Exception e) {
    LOG.error(e);
    Assert.fail(""String_Node_Str"");
  }
  postSubmit();
}",0.6156648451730419
56105,"/** 
 * Entry point of the thread.
 */
public void go() throws IOException {
  final Channel.Enumerator enumerator=this.ioManager.createChannelEnumerator();
  final List<MemorySegment> writeBuffers;
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  try {
    writeBuffers=this.memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,writeMemSize,NUM_WRITE_BUFFERS,MIN_IO_BUFFER_SIZE);
    registerSegmentsToBeFreedAtShutdown(writeBuffers);
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  while (isRunning()) {
    CircularElement element=null;
    try {
      element=queues.spill.take();
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
 else {
        return;
      }
    }
    if (!isRunning()) {
      return;
    }
    if (element == SENTINEL) {
      break;
    }
    final Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    final ChannelWriter writer=ioManager.createChannelWriter(channel,writeBuffers);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortableGuaranteed<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    writer.close();
    element.buffer.reset();
    queues.empty.add(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    try {
      this.memoryManager.release(queues.empty.take().buffer.unbind());
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        return;
      }
    }
  }
  if (CombiningUnilateralSortMerger.this.sortSegments != null) {
    unregisterSegmentsToBeFreedAtShutdown(CombiningUnilateralSortMerger.this.sortSegments);
    CombiningUnilateralSortMerger.this.sortSegments.clear();
  }
  try {
    while (channelIDs.size() > CombiningUnilateralSortMerger.this.maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,writeBuffers,this.readMemSize);
    }
    this.memoryManager.release(writeBuffers);
    unregisterSegmentsToBeFreedAtShutdown(writeBuffers);
    final List<List<MemorySegment>> readBuffers=new ArrayList<List<MemorySegment>>(channelIDs.size());
    final List<MemorySegment> allBuffers=getSegmentsForReaders(readBuffers,this.readMemSize,channelIDs.size());
    registerSegmentsToBeFreedAtShutdown(allBuffers);
    final List<ChannelAccess<?>> readers=new ArrayList<ChannelAccess<?>>(channelIDs.size());
    registerChannelsToBeRemovedAtShudown(readers);
    final Iterator<KeyValuePair<K,V>> mergeIterator=getMergingIterator(channelIDs,readBuffers,readers);
    if (CombiningUnilateralSortMerger.this.combineLastMerge) {
      KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(mergeIterator);
      setResultIterator(new CombiningIterator<K,V>(combineStub,iter));
    }
 else {
      setResultIterator(mergeIterator);
    }
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws IOException {
  final Channel.Enumerator enumerator=this.ioManager.createChannelEnumerator();
  final List<MemorySegment> writeBuffers;
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  try {
    writeBuffers=this.memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,writeMemSize,NUM_WRITE_BUFFERS,MIN_IO_BUFFER_SIZE);
    registerSegmentsToBeFreedAtShutdown(writeBuffers);
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  while (isRunning()) {
    CircularElement element=null;
    try {
      element=queues.spill.take();
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
 else {
        return;
      }
    }
    if (!isRunning()) {
      return;
    }
    if (element == SENTINEL) {
      break;
    }
    final Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    final ChannelWriter writer=ioManager.createChannelWriter(channel,writeBuffers);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortableGuaranteed<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    writer.close();
    element.buffer.reset();
    queues.empty.add(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    try {
      this.memoryManager.release(queues.empty.take().buffer.unbind());
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        return;
      }
    }
  }
  if (CombiningUnilateralSortMerger.this.sortSegments != null) {
    unregisterSegmentsToBeFreedAtShutdown(CombiningUnilateralSortMerger.this.sortSegments);
    CombiningUnilateralSortMerger.this.sortSegments.clear();
  }
  try {
    while (channelIDs.size() > CombiningUnilateralSortMerger.this.maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,writeBuffers,this.readMemSize);
    }
    this.memoryManager.release(writeBuffers);
    unregisterSegmentsToBeFreedAtShutdown(writeBuffers);
    if (channelIDs.isEmpty()) {
      setResultIterator(EmptyIterator.<KeyValuePair<K,V>>get());
    }
 else {
      final List<List<MemorySegment>> readBuffers=new ArrayList<List<MemorySegment>>(channelIDs.size());
      final List<MemorySegment> allBuffers=getSegmentsForReaders(readBuffers,this.readMemSize,channelIDs.size());
      registerSegmentsToBeFreedAtShutdown(allBuffers);
      final List<ChannelAccess<?>> readers=new ArrayList<ChannelAccess<?>>(channelIDs.size());
      registerChannelsToBeRemovedAtShudown(readers);
      final Iterator<KeyValuePair<K,V>> mergeIterator=getMergingIterator(channelIDs,readBuffers,readers);
      if (CombiningUnilateralSortMerger.this.combineLastMerge) {
        KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(mergeIterator);
        setResultIterator(new CombiningIterator<K,V>(combineStub,iter));
      }
 else {
        setResultIterator(mergeIterator);
      }
    }
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  LOG.debug(""String_Node_Str"");
}",0.8296976655185611
56106,"/** 
 * Fills the given list with collections of buffers for channels. The list will contain as many collections as the parameter <code>numReaders</code> specifies.
 * @param target The list into which the lists with buffers for the channels are put.
 * @param totalReadMemory The total amount of memory to be divided among the channels.
 * @param numChannels The number of channels for which to allocate buffers.
 * @return A list with all memory segments that were allocated.
 * @throws MemoryAllocationException Thrown, if the specified memory is insufficient to merge the channelsor if the memory manager could not provide the requested memory.
 */
protected final List<MemorySegment> getSegmentsForReaders(List<List<MemorySegment>> target,long totalReadMemory,int numChannels) throws MemoryAllocationException {
  final long ioMemoryPerChannel=totalReadMemory / numChannels;
  final int numBuffers=ioMemoryPerChannel < 2 * MIN_IO_BUFFER_SIZE ? 1 : ioMemoryPerChannel < 2 * MAX_IO_BUFFER_SIZE ? 2 : (int)(ioMemoryPerChannel / MAX_IO_BUFFER_SIZE);
  final long bufferSize=(ioMemoryPerChannel / numBuffers) & BUFFER_ALIGNMENT_MASK;
  final List<MemorySegment> memorySegments=this.memoryManager.allocate(this.parent,bufferSize * numBuffers * numChannels,numBuffers * numChannels,MIN_IO_BUFFER_SIZE);
  for (int i=0, buffer=0; i < numChannels - 1; i++) {
    List<MemorySegment> segs=new ArrayList<MemorySegment>(numBuffers);
    target.add(segs);
    for (int k=0; k < numBuffers; k++, buffer++) {
      segs.add(memorySegments.get(buffer));
    }
  }
  List<MemorySegment> segsForLast=new ArrayList<MemorySegment>(numBuffers);
  target.add(segsForLast);
  for (int i=(numChannels - 1) * numBuffers; i < memorySegments.size(); i++) {
    segsForLast.add(memorySegments.get(i));
  }
  return memorySegments;
}","/** 
 * Fills the given list with collections of buffers for channels. The list will contain as many collections as the parameter <code>numReaders</code> specifies.
 * @param target The list into which the lists with buffers for the channels are put.
 * @param totalReadMemory The total amount of memory to be divided among the channels.
 * @param numChannels The number of channels for which to allocate buffers. Must not be zero.
 * @return A list with all memory segments that were allocated.
 * @throws MemoryAllocationException Thrown, if the specified memory is insufficient to merge the channelsor if the memory manager could not provide the requested memory.
 */
protected final List<MemorySegment> getSegmentsForReaders(List<List<MemorySegment>> target,long totalReadMemory,int numChannels) throws MemoryAllocationException {
  final long ioMemoryPerChannel=totalReadMemory / numChannels;
  final int numBuffers=ioMemoryPerChannel < 2 * MIN_IO_BUFFER_SIZE ? 1 : ioMemoryPerChannel < 2 * MAX_IO_BUFFER_SIZE ? 2 : (int)(ioMemoryPerChannel / MAX_IO_BUFFER_SIZE);
  final long bufferSize=(ioMemoryPerChannel / numBuffers) & BUFFER_ALIGNMENT_MASK;
  final List<MemorySegment> memorySegments=this.memoryManager.allocate(this.parent,bufferSize * numBuffers * numChannels,numBuffers * numChannels,MIN_IO_BUFFER_SIZE);
  for (int i=0, buffer=0; i < numChannels - 1; i++) {
    List<MemorySegment> segs=new ArrayList<MemorySegment>(numBuffers);
    target.add(segs);
    for (int k=0; k < numBuffers; k++, buffer++) {
      segs.add(memorySegments.get(buffer));
    }
  }
  List<MemorySegment> segsForLast=new ArrayList<MemorySegment>(numBuffers);
  target.add(segsForLast);
  for (int i=(numChannels - 1) * numBuffers; i < memorySegments.size(); i++) {
    segsForLast.add(memorySegments.get(i));
  }
  return memorySegments;
}",0.995049504950495
56107,"/** 
 * Entry point of the thread.
 */
public void go() throws IOException {
  final Channel.Enumerator enumerator=this.ioManager.createChannelEnumerator();
  final List<MemorySegment> writeBuffers;
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  try {
    writeBuffers=this.memoryManager.allocate(UnilateralSortMerger.this.parent,writeMemSize,NUM_WRITE_BUFFERS,MIN_IO_BUFFER_SIZE);
    registerSegmentsToBeFreedAtShutdown(writeBuffers);
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  while (isRunning()) {
    CircularElement element=null;
    try {
      element=this.queues.spill.take();
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
 else {
        return;
      }
    }
    if (!isRunning()) {
      return;
    }
    if (element == SENTINEL) {
      break;
    }
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    ChannelWriter writer=this.ioManager.createChannelWriter(channel,writeBuffers);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    element.buffer.writeToChannel(writer);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    writer.close();
    element.buffer.reset();
    queues.empty.add(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    try {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        return;
      }
    }
  }
  if (UnilateralSortMerger.this.sortSegments != null) {
    unregisterSegmentsToBeFreedAtShutdown(UnilateralSortMerger.this.sortSegments);
    UnilateralSortMerger.this.sortSegments.clear();
  }
  try {
    while (channelIDs.size() > UnilateralSortMerger.this.maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,writeBuffers,this.readMemSize);
    }
    this.memoryManager.release(writeBuffers);
    unregisterSegmentsToBeFreedAtShutdown(writeBuffers);
    writeBuffers.clear();
    List<List<MemorySegment>> readBuffers=new ArrayList<List<MemorySegment>>(channelIDs.size());
    List<MemorySegment> allBuffers=getSegmentsForReaders(readBuffers,this.readMemSize,channelIDs.size());
    registerSegmentsToBeFreedAtShutdown(allBuffers);
    List<ChannelAccess<?>> readers=new ArrayList<ChannelAccess<?>>(channelIDs.size());
    registerChannelsToBeRemovedAtShudown(readers);
    setResultIterator(getMergingIterator(channelIDs,readBuffers,readers));
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws IOException {
  final Channel.Enumerator enumerator=this.ioManager.createChannelEnumerator();
  final List<MemorySegment> writeBuffers;
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  try {
    writeBuffers=this.memoryManager.allocate(UnilateralSortMerger.this.parent,writeMemSize,NUM_WRITE_BUFFERS,MIN_IO_BUFFER_SIZE);
    registerSegmentsToBeFreedAtShutdown(writeBuffers);
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  while (isRunning()) {
    CircularElement element=null;
    try {
      element=this.queues.spill.take();
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
 else {
        return;
      }
    }
    if (!isRunning()) {
      return;
    }
    if (element == SENTINEL) {
      break;
    }
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    ChannelWriter writer=this.ioManager.createChannelWriter(channel,writeBuffers);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    element.buffer.writeToChannel(writer);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    writer.close();
    element.buffer.reset();
    queues.empty.add(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    try {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        return;
      }
    }
  }
  if (UnilateralSortMerger.this.sortSegments != null) {
    unregisterSegmentsToBeFreedAtShutdown(UnilateralSortMerger.this.sortSegments);
    UnilateralSortMerger.this.sortSegments.clear();
  }
  try {
    while (channelIDs.size() > UnilateralSortMerger.this.maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,writeBuffers,this.readMemSize);
    }
    this.memoryManager.release(writeBuffers);
    unregisterSegmentsToBeFreedAtShutdown(writeBuffers);
    writeBuffers.clear();
    if (channelIDs.isEmpty()) {
      setResultIterator(EmptyIterator.<KeyValuePair<K,V>>get());
    }
 else {
      LOG.debug(""String_Node_Str"");
      List<List<MemorySegment>> readBuffers=new ArrayList<List<MemorySegment>>(channelIDs.size());
      List<MemorySegment> allBuffers=getSegmentsForReaders(readBuffers,this.readMemSize,channelIDs.size());
      registerSegmentsToBeFreedAtShutdown(allBuffers);
      List<ChannelAccess<?>> readers=new ArrayList<ChannelAccess<?>>(channelIDs.size());
      registerChannelsToBeRemovedAtShudown(readers);
      setResultIterator(getMergingIterator(channelIDs,readBuffers,readers));
    }
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  LOG.debug(""String_Node_Str"");
}",0.9715370018975332
56108,"@Override public boolean equals(Object o){
  return (o.getClass() == PactNull.class);
}","@Override public boolean equals(Object o){
  return (o != null && o.getClass() == PactNull.class);
}",0.93048128342246
56109,"/** 
 * Translates the given pact plan in to an OptimizedPlan, where all nodes have their local strategy assigned and all channels have a shipping strategy assigned. The process goes through several phases: <ol> <li>Create <tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li> <li>Compute interesting properties and auxiliary structures.</li> <li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as opposed to the Database approaches), because we support plans that are not trees.</li> </ol>
 * @param pactPlan The PACT plan to be translated.
 * @return The optimized plan.
 * @throws CompilerException Thrown, if the plan is invalid or the optimizer encountered an inconsistent situation during the compilation process.
 */
public OptimizedPlan compile(Plan pactPlan) throws CompilerException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + pactPlan.getJobName() + '\'');
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"");
  }
  Map<InstanceType,InstanceTypeDescription> instances=null;
  JobManagerConnector jmc=new JobManagerConnector(this.jobManagerAddress);
  Thread connectorThread=new Thread(jmc,""String_Node_Str"");
  connectorThread.setDaemon(true);
  connectorThread.start();
  try {
    jmc.waitForCompletion();
    instances=jmc.instances;
    if (instances == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
  }
 catch (  Throwable t) {
    throw new CompilerException(""String_Node_Str"" + t.getMessage(),t);
  }
  int maxMachinesJob=pactPlan.getMaxNumberMachines();
  if (maxMachinesJob < 1) {
    maxMachinesJob=this.maxMachines;
  }
 else   if (this.maxMachines >= 1) {
    if (maxMachinesJob > this.maxMachines && LOG.isWarnEnabled()) {
      LOG.warn(""String_Node_Str"" + maxMachinesJob + ""String_Node_Str""+ this.maxMachines+ ""String_Node_Str"");
    }
    maxMachinesJob=Math.min(maxMachinesJob,this.maxMachines);
  }
  InstanceTypeDescription type=getType(instances);
  String instanceName=type.getInstanceType().getIdentifier();
  long memoryPerInstance=type.getHardwareDescription().getSizeOfFreeMemory();
  int memoryMegabytes=(int)(memoryPerInstance >>> 20);
  int numInstances=type.getMaximumNumberOfAvailableInstances();
  if (maxMachinesJob < 1) {
    maxMachinesJob=numInstances;
  }
 else   if (maxMachinesJob > numInstances) {
    maxMachinesJob=numInstances;
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + maxMachinesJob + ""String_Node_Str"");
    }
  }
  int defaultParallelism=this.defaultDegreeOfParallelism;
  if (defaultParallelism < 1) {
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
  }
 else   if (defaultParallelism > maxMachinesJob * defaultIntraNodeParallelism) {
    int oldParallelism=defaultParallelism;
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + oldParallelism + ""String_Node_Str""+ defaultParallelism+ ""String_Node_Str""+ maxMachinesJob+ ""String_Node_Str""+ defaultIntraNodeParallelism);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + defaultParallelism + ""String_Node_Str""+ this.defaultIntraNodeParallelism+ '.');
    if (maxMachines > 0) {
      LOG.debug(""String_Node_Str"" + maxMachines + ""String_Node_Str"");
    }
  }
  GraphCreatingVisitor graphCreator=new GraphCreatingVisitor(this.statistics,maxMachinesJob,defaultParallelism,this.defaultIntraNodeParallelism,true);
  pactPlan.accept(graphCreator);
  OptimizerNode rootNode=null;
  if (graphCreator.sinks.size() == 1) {
    rootNode=graphCreator.sinks.get(0);
  }
 else   if (graphCreator.sinks.size() > 1) {
    Iterator<DataSinkNode> iter=graphCreator.sinks.iterator();
    rootNode=iter.next();
    int id=graphCreator.getId();
    while (iter.hasNext()) {
      rootNode=new SinkJoiner(rootNode,iter.next());
      rootNode.SetId(id++);
    }
  }
 else {
    throw new CompilerException(""String_Node_Str"");
  }
  InterestingPropertyAndBranchesVisitor propsVisitor=new InterestingPropertyAndBranchesVisitor(this.costEstimator);
  rootNode.accept(propsVisitor);
  List<? extends OptimizerNode> bestPlan=rootNode.getAlternativePlans(this.costEstimator);
  if (bestPlan.size() != 1) {
    throw new CompilerException(""String_Node_Str"");
  }
  OptimizerNode bestPlanRoot=bestPlan.get(0);
  List<DataSinkNode> bestPlanSinks=new ArrayList<DataSinkNode>(4);
  if (bestPlanRoot instanceof DataSinkNode) {
    bestPlanSinks.add((DataSinkNode)bestPlanRoot);
  }
 else   if (bestPlanRoot instanceof SinkJoiner) {
    ((SinkJoiner)bestPlanRoot).getDataSinks(bestPlanSinks);
  }
  OptimizedPlan plan=new PlanFinalizer().createFinalPlan(bestPlanSinks,pactPlan.getJobName(),memoryMegabytes);
  plan.setInstanceTypeName(instanceName);
  insertTempConnection(plan);
  return plan;
}","/** 
 * Translates the given pact plan in to an OptimizedPlan, where all nodes have their local strategy assigned and all channels have a shipping strategy assigned. The process goes through several phases: <ol> <li>Create <tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li> <li>Compute interesting properties and auxiliary structures.</li> <li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as opposed to the Database approaches), because we support plans that are not trees.</li> </ol>
 * @param pactPlan The PACT plan to be translated.
 * @param type The instance type to schedule the execution on. Used also to determine the amount of memoryavailable to the tasks.
 * @return The optimized plan.
 * @throws CompilerException Thrown, if the plan is invalid or the optimizer encountered an inconsistent situation during the compilation process.
 */
public OptimizedPlan compile(Plan pactPlan,InstanceTypeDescription type) throws CompilerException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + pactPlan.getJobName() + '\'');
  }
  String instanceName=type.getInstanceType().getIdentifier();
  long memoryPerInstance=type.getHardwareDescription().getSizeOfFreeMemory();
  int memoryMegabytes=(int)(memoryPerInstance >>> 20);
  int numInstances=type.getMaximumNumberOfAvailableInstances();
  int maxMachinesJob=pactPlan.getMaxNumberMachines();
  if (maxMachinesJob < 1) {
    maxMachinesJob=this.maxMachines;
  }
 else   if (this.maxMachines >= 1) {
    if (maxMachinesJob > this.maxMachines && LOG.isWarnEnabled()) {
      LOG.warn(""String_Node_Str"" + maxMachinesJob + ""String_Node_Str""+ this.maxMachines+ ""String_Node_Str"");
    }
    maxMachinesJob=Math.min(maxMachinesJob,this.maxMachines);
  }
  if (maxMachinesJob < 1) {
    maxMachinesJob=numInstances;
  }
 else   if (maxMachinesJob > numInstances) {
    maxMachinesJob=numInstances;
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + maxMachinesJob + ""String_Node_Str"");
    }
  }
  int defaultParallelism=this.defaultDegreeOfParallelism;
  if (defaultParallelism < 1) {
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
  }
 else   if (defaultParallelism > maxMachinesJob * defaultIntraNodeParallelism) {
    int oldParallelism=defaultParallelism;
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + oldParallelism + ""String_Node_Str""+ defaultParallelism+ ""String_Node_Str""+ maxMachinesJob+ ""String_Node_Str""+ defaultIntraNodeParallelism);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + defaultParallelism + ""String_Node_Str""+ this.defaultIntraNodeParallelism+ '.');
    if (maxMachines > 0) {
      LOG.debug(""String_Node_Str"" + maxMachines + ""String_Node_Str"");
    }
  }
  GraphCreatingVisitor graphCreator=new GraphCreatingVisitor(this.statistics,maxMachinesJob,defaultParallelism,this.defaultIntraNodeParallelism,true);
  pactPlan.accept(graphCreator);
  OptimizerNode rootNode=null;
  if (graphCreator.sinks.size() == 1) {
    rootNode=graphCreator.sinks.get(0);
  }
 else   if (graphCreator.sinks.size() > 1) {
    Iterator<DataSinkNode> iter=graphCreator.sinks.iterator();
    rootNode=iter.next();
    int id=graphCreator.getId();
    while (iter.hasNext()) {
      rootNode=new SinkJoiner(rootNode,iter.next());
      rootNode.SetId(id++);
    }
  }
 else {
    throw new CompilerException(""String_Node_Str"");
  }
  InterestingPropertyAndBranchesVisitor propsVisitor=new InterestingPropertyAndBranchesVisitor(this.costEstimator);
  rootNode.accept(propsVisitor);
  List<? extends OptimizerNode> bestPlan=rootNode.getAlternativePlans(this.costEstimator);
  if (bestPlan.size() != 1) {
    throw new CompilerException(""String_Node_Str"");
  }
  OptimizerNode bestPlanRoot=bestPlan.get(0);
  List<DataSinkNode> bestPlanSinks=new ArrayList<DataSinkNode>(4);
  if (bestPlanRoot instanceof DataSinkNode) {
    bestPlanSinks.add((DataSinkNode)bestPlanRoot);
  }
 else   if (bestPlanRoot instanceof SinkJoiner) {
    ((SinkJoiner)bestPlanRoot).getDataSinks(bestPlanSinks);
  }
  OptimizedPlan plan=new PlanFinalizer().createFinalPlan(bestPlanSinks,pactPlan.getJobName(),memoryMegabytes);
  plan.setInstanceTypeName(instanceName);
  insertTempConnection(plan);
  return plan;
}",0.6418054809242343
56110,"/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  ShipStrategy primStrat=null;
  ShipStrategy secStrat=null;
  OptimizerNode primIn=null;
  OptimizerNode secIn=null;
{
    List<PactConnection> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primStrat=conns.get(0).getShipStrategy();
      primIn=conns.get(0).getSourcePact();
    }
    if (conns.size() > 1) {
      secStrat=conns.get(1).getShipStrategy();
      secIn=conns.get(1).getSourcePact();
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primStrat != null) {
switch (primStrat) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(n,primIn,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(n,primIn,globCost);
break;
case BROADCAST:
getBroadcastCost(n,primIn,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primStrat.name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secStrat != null) {
Costs secCost=new Costs();
switch (secStrat) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(n,secIn,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(n,secIn,secCost);
break;
case BROADCAST:
getBroadcastCost(n,secIn,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secStrat.name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primIn,locCost);
break;
case SORTMERGE:
getLocalSortMergeCost(n,primIn,secIn,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primIn,secIn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secIn,primIn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primIn,secIn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secIn,primIn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primIn,secIn,locCost,2);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secIn,primIn,locCost,2);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primIn,secIn,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secIn,primIn,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}","/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  ShipStrategy primStrat=null;
  ShipStrategy secStrat=null;
  OptimizerNode primIn=null;
  OptimizerNode secIn=null;
{
    List<PactConnection> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primStrat=conns.get(0).getShipStrategy();
      primIn=conns.get(0).getSourcePact();
    }
    if (conns.size() > 1) {
      secStrat=conns.get(1).getShipStrategy();
      secIn=conns.get(1).getSourcePact();
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primStrat != null) {
switch (primStrat) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(n,primIn,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(n,primIn,globCost);
break;
case BROADCAST:
getBroadcastCost(n,primIn,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primStrat.name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secStrat != null) {
Costs secCost=new Costs();
switch (secStrat) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(n,secIn,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(n,secIn,secCost);
break;
case BROADCAST:
getBroadcastCost(n,secIn,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secStrat.name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primIn,locCost);
break;
case SORTMERGE:
getLocalSortMergeCost(n,primIn,secIn,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primIn,secIn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secIn,primIn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primIn,secIn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secIn,primIn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primIn,secIn,locCost,2);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secIn,primIn,locCost,2);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primIn,secIn,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secIn,primIn,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}",0.9670949545596992
56111,"@Override public void postVisit(OptimizerNode visitable){
  jsonString.append(""String_Node_Str"");
  jsonString.append(""String_Node_Str"" + nodeIds.get(visitable));
  String type;
switch (visitable.getPactType()) {
case DataSink:
    type=""String_Node_Str"";
  break;
case DataSource:
type=""String_Node_Str"";
break;
default :
type=""String_Node_Str"";
break;
}
jsonString.append(""String_Node_Str"" + type + ""String_Node_Str"");
if (type.equals(""String_Node_Str"")) {
jsonString.append(""String_Node_Str"" + visitable.getName() + ""String_Node_Str"");
}
String contents;
switch (visitable.getPactType()) {
case DataSink:
contents=((DataSinkContract<?,?>)visitable.getPactContract()).getFilePath();
break;
case DataSource:
contents=((DataSourceContract<?,?>)visitable.getPactContract()).getFilePath();
break;
default :
contents=visitable.getPactContract().getName();
break;
}
jsonString.append(""String_Node_Str"" + contents + ""String_Node_Str"");
OutputContract outContr=visitable.getOutputContract();
if (outContr != null && outContr != OutputContract.None) {
jsonString.append(""String_Node_Str"" + outContr.name() + ""String_Node_Str"");
}
jsonString.append(""String_Node_Str"" + (visitable.getDegreeOfParallelism() >= 1 ? visitable.getDegreeOfParallelism() : ""String_Node_Str"") + ""String_Node_Str"");
List<PactConnection> connList=visitable.getIncomingConnections();
String child1name=null, child2name=null;
if (connList != null && connList.size() > 0) {
jsonString.append(""String_Node_Str"");
int connCnt=0;
for (PactConnection conn : connList) {
jsonString.append(connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
if (connCnt == 0) {
child1name=conn.getSourcePact().getPactContract().getName();
}
 else if (connCnt == 1) {
child2name=conn.getSourcePact().getPactContract().getName();
}
jsonString.append(""String_Node_Str"" + nodeIds.get(conn.getSourcePact()));
if (connList.size() == 2) {
jsonString.append(""String_Node_Str"" + (connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}
String shipStrategy=null;
String channelType=null;
switch (conn.getShipStrategy()) {
case NONE:
break;
case FORWARD:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case BROADCAST:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_RANGE:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case SFR:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + conn.getShipStrategy().name() + ""String_Node_Str"");
}
if (shipStrategy != null) {
jsonString.append(""String_Node_Str"" + shipStrategy + ""String_Node_Str"");
}
if (channelType != null) {
jsonString.append(""String_Node_Str"" + channelType + ""String_Node_Str"");
}
if (conn.getTempMode() != TempMode.NONE) {
String tempMode=conn.getTempMode().toString();
jsonString.append(""String_Node_Str"" + tempMode + ""String_Node_Str"");
}
jsonString.append('}');
connCnt++;
}
jsonString.append(""String_Node_Str"");
}
String locString=null;
if (visitable.getLocalStrategy() != null) {
switch (visitable.getLocalStrategy()) {
case NONE:
break;
case HYBRIDHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case HYBRIDHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case MMHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case MMHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case SORTMERGE:
locString=""String_Node_Str"";
break;
case SORT:
locString=""String_Node_Str"";
break;
case COMBININGSORT:
locString=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + visitable.getLocalStrategy().name() + ""String_Node_Str"");
}
if (locString != null) {
jsonString.append(""String_Node_Str"");
jsonString.append(locString);
jsonString.append(""String_Node_Str"");
}
}
{
GlobalProperties gp=visitable.getGlobalProperties();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",gp.getPartitioning().name(),true);
addProperty(jsonString,""String_Node_Str"",gp.getKeyOrder().name(),false);
addProperty(jsonString,""String_Node_Str"",gp.isKeyUnique() ? ""String_Node_Str"" : ""String_Node_Str"",false);
jsonString.append(""String_Node_Str"");
}
{
LocalProperties lp=visitable.getLocalProperties();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",lp.getKeyOrder().name(),true);
addProperty(jsonString,""String_Node_Str"",lp.isKeyUnique() ? ""String_Node_Str"" : ""String_Node_Str"",false);
addProperty(jsonString,""String_Node_Str"",lp.areKeysGrouped() ? ""String_Node_Str"" : ""String_Node_Str"",false);
jsonString.append(""String_Node_Str"");
}
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedNumRecords() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedNumRecords()),true);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedKeyCardinality() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedKeyCardinality()),false);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedOutputSize() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedOutputSize(),""String_Node_Str""),false);
jsonString.append(""String_Node_Str"");
if (visitable.getNodeCosts() != null) {
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",visitable.getNodeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getNetworkCost(),""String_Node_Str""),true);
addProperty(jsonString,""String_Node_Str"",visitable.getNodeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
addProperty(jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getNetworkCost(),""String_Node_Str""),false);
addProperty(jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
jsonString.append(""String_Node_Str"");
}
if (visitable.getPactContract().getCompilerHints() != null) {
CompilerHints hints=visitable.getPactContract().getCompilerHints();
CompilerHints defaults=new CompilerHints();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",hints.getKeyCardinality() == defaults.getKeyCardinality() ? ""String_Node_Str"" : formatNumber(hints.getKeyCardinality()),true);
addProperty(jsonString,""String_Node_Str"",hints.getSelectivity() == defaults.getSelectivity() ? ""String_Node_Str"" : String.valueOf(hints.getSelectivity()),false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgNumValuesPerKey() == defaults.getAvgNumValuesPerKey() ? ""String_Node_Str"" : String.valueOf(hints.getAvgNumValuesPerKey()),false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgBytesPerRecord() == defaults.getAvgBytesPerRecord() ? ""String_Node_Str"" : String.valueOf(hints.getAvgBytesPerRecord()),false);
jsonString.append(""String_Node_Str"");
}
jsonString.append(""String_Node_Str"");
}","@Override public void postVisit(OptimizerNode visitable){
  jsonString.append(""String_Node_Str"");
  jsonString.append(""String_Node_Str"" + nodeIds.get(visitable));
  String type;
switch (visitable.getPactType()) {
case DataSink:
    type=""String_Node_Str"";
  break;
case DataSource:
type=""String_Node_Str"";
break;
default :
type=""String_Node_Str"";
break;
}
jsonString.append(""String_Node_Str"" + type + ""String_Node_Str"");
if (type.equals(""String_Node_Str"")) {
jsonString.append(""String_Node_Str"" + visitable.getName() + ""String_Node_Str"");
}
String contents;
switch (visitable.getPactType()) {
case DataSink:
contents=((DataSinkContract<?,?>)visitable.getPactContract()).getFilePath();
break;
case DataSource:
contents=((DataSourceContract<?,?>)visitable.getPactContract()).getFilePath();
break;
default :
contents=visitable.getPactContract().getName();
break;
}
jsonString.append(""String_Node_Str"" + contents + ""String_Node_Str"");
OutputContract outContr=visitable.getOutputContract();
if (outContr != null && outContr != OutputContract.None) {
jsonString.append(""String_Node_Str"" + outContr.name() + ""String_Node_Str"");
}
jsonString.append(""String_Node_Str"" + (visitable.getDegreeOfParallelism() >= 1 ? visitable.getDegreeOfParallelism() : ""String_Node_Str"") + ""String_Node_Str"");
List<PactConnection> connList=visitable.getIncomingConnections();
String child1name=null, child2name=null;
if (connList != null && connList.size() > 0) {
jsonString.append(""String_Node_Str"");
int connCnt=0;
for (PactConnection conn : connList) {
jsonString.append(connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
if (connCnt == 0) {
child1name=conn.getSourcePact().getPactContract().getName();
}
 else if (connCnt == 1) {
child2name=conn.getSourcePact().getPactContract().getName();
}
jsonString.append(""String_Node_Str"" + nodeIds.get(conn.getSourcePact()));
if (connList.size() == 2) {
jsonString.append(""String_Node_Str"" + (connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}
String shipStrategy=null;
String channelType=null;
switch (conn.getShipStrategy()) {
case NONE:
break;
case FORWARD:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case BROADCAST:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_RANGE:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_LOCAL_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
case SFR:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + conn.getShipStrategy().name() + ""String_Node_Str"");
}
if (shipStrategy != null) {
jsonString.append(""String_Node_Str"" + shipStrategy + ""String_Node_Str"");
}
if (channelType != null) {
jsonString.append(""String_Node_Str"" + channelType + ""String_Node_Str"");
}
if (conn.getTempMode() != TempMode.NONE) {
String tempMode=conn.getTempMode().toString();
jsonString.append(""String_Node_Str"" + tempMode + ""String_Node_Str"");
}
jsonString.append('}');
connCnt++;
}
jsonString.append(""String_Node_Str"");
}
String locString=null;
if (visitable.getLocalStrategy() != null) {
switch (visitable.getLocalStrategy()) {
case NONE:
break;
case HYBRIDHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case HYBRIDHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case MMHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case MMHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case SORTMERGE:
locString=""String_Node_Str"";
break;
case SORT:
locString=""String_Node_Str"";
break;
case COMBININGSORT:
locString=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + visitable.getLocalStrategy().name() + ""String_Node_Str"");
}
if (locString != null) {
jsonString.append(""String_Node_Str"");
jsonString.append(locString);
jsonString.append(""String_Node_Str"");
}
}
{
GlobalProperties gp=visitable.getGlobalProperties();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",gp.getPartitioning().name(),true);
addProperty(jsonString,""String_Node_Str"",gp.getKeyOrder().name(),false);
addProperty(jsonString,""String_Node_Str"",gp.isKeyUnique() ? ""String_Node_Str"" : ""String_Node_Str"",false);
jsonString.append(""String_Node_Str"");
}
{
LocalProperties lp=visitable.getLocalProperties();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",lp.getKeyOrder().name(),true);
addProperty(jsonString,""String_Node_Str"",lp.isKeyUnique() ? ""String_Node_Str"" : ""String_Node_Str"",false);
addProperty(jsonString,""String_Node_Str"",lp.areKeysGrouped() ? ""String_Node_Str"" : ""String_Node_Str"",false);
jsonString.append(""String_Node_Str"");
}
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedNumRecords() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedNumRecords()),true);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedKeyCardinality() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedKeyCardinality()),false);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedOutputSize() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedOutputSize(),""String_Node_Str""),false);
jsonString.append(""String_Node_Str"");
if (visitable.getNodeCosts() != null) {
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",visitable.getNodeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getNetworkCost(),""String_Node_Str""),true);
addProperty(jsonString,""String_Node_Str"",visitable.getNodeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
addProperty(jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getNetworkCost(),""String_Node_Str""),false);
addProperty(jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
jsonString.append(""String_Node_Str"");
}
if (visitable.getPactContract().getCompilerHints() != null) {
CompilerHints hints=visitable.getPactContract().getCompilerHints();
CompilerHints defaults=new CompilerHints();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",hints.getKeyCardinality() == defaults.getKeyCardinality() ? ""String_Node_Str"" : formatNumber(hints.getKeyCardinality()),true);
addProperty(jsonString,""String_Node_Str"",hints.getSelectivity() == defaults.getSelectivity() ? ""String_Node_Str"" : String.valueOf(hints.getSelectivity()),false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgNumValuesPerKey() == defaults.getAvgNumValuesPerKey() ? ""String_Node_Str"" : String.valueOf(hints.getAvgNumValuesPerKey()),false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgBytesPerRecord() == defaults.getAvgBytesPerRecord() ? ""String_Node_Str"" : String.valueOf(hints.getAvgBytesPerRecord()),false);
jsonString.append(""String_Node_Str"");
}
jsonString.append(""String_Node_Str"");
}",0.9942107294480896
56112,"/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
    channelType=ChannelType.INMEMORY;
  break;
case PARTITION_HASH:
channelType=ChannelType.NETWORK;
break;
case BROADCAST:
channelType=ChannelType.NETWORK;
break;
case SFR:
channelType=ChannelType.NETWORK;
break;
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}","/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    channelType=ChannelType.INMEMORY;
  break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}",0.9588073754413496
56113,"@Override public List<CoGroupNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans1=input1.getSourcePact().getAlternativePlans(estimator);
  List<? extends OptimizerNode> inPlans2=input2.getSourcePact().getAlternativePlans(estimator);
  List<CoGroupNode> outputPlans=new ArrayList<CoGroupNode>();
  for (  OptimizerNode pred1 : inPlans1) {
    for (    OptimizerNode pred2 : inPlans2) {
      if (!areBranchCompatible(pred1,pred2)) {
        continue;
      }
      ShipStrategy ss1=input1.getShipStrategy();
      ShipStrategy ss2=input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=pred1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=pred2.getGlobalProperties();
          if (gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (gp2.getPartitioning().isComputablyPartitioned()) {
            if ((!gp1.getPartitioning().isPartitioned()) || gp1.getPartitioning() == gp2.getPartitioning()) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
              }
              continue;
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
              }
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
switch (ss2) {
case FORWARD:
            if (gp2.getPartitioning().isPartitioned()) {
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_HASH;
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_RANGE;
              }
 else {
                throw new CompilerException();
              }
            }
 else {
              continue;
            }
          break;
case PARTITION_HASH:
        ss1=(gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
      break;
case PARTITION_RANGE:
    ss1=(gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
  break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
gp2=pred2.getGlobalProperties();
switch (ss1) {
case FORWARD:
if (gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
continue;
}
break;
case PARTITION_HASH:
ss2=(gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
if (gp1.getPartitioning().isPartitioned() && gp1.getPartitioning() == gp2.getPartitioning()) {
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
if (outputPlans.isEmpty()) {
throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
}
prunePlanAlternatives(outputPlans);
if (isBranching()) {
this.cachedPlans=outputPlans;
}
return outputPlans;
}","@Override public List<CoGroupNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans1=input1.getSourcePact().getAlternativePlans(estimator);
  List<? extends OptimizerNode> inPlans2=input2.getSourcePact().getAlternativePlans(estimator);
  List<CoGroupNode> outputPlans=new ArrayList<CoGroupNode>();
  for (  OptimizerNode pred1 : inPlans1) {
    for (    OptimizerNode pred2 : inPlans2) {
      if (!areBranchCompatible(pred1,pred2)) {
        continue;
      }
      ShipStrategy ss1=input1.getShipStrategy();
      ShipStrategy ss2=input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=pred1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=pred2.getGlobalProperties();
          if (gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (gp2.getPartitioning().isComputablyPartitioned()) {
            if ((!gp1.getPartitioning().isComputablyPartitioned()) || gp1.getPartitioning() == gp2.getPartitioning()) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
              }
              continue;
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
              }
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
switch (ss2) {
case FORWARD:
            if (gp2.getPartitioning().isPartitioned()) {
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_HASH;
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_RANGE;
              }
 else {
                throw new CompilerException();
              }
            }
 else {
              continue;
            }
          break;
case PARTITION_HASH:
        ss1=(gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
      break;
case PARTITION_RANGE:
    ss1=(gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
  break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=pred2.getGlobalProperties();
switch (ss1) {
case FORWARD:
if (gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
continue;
}
break;
case PARTITION_HASH:
ss2=(gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning()) {
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
if (outputPlans.isEmpty()) {
throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
}
prunePlanAlternatives(outputPlans);
if (isBranching()) {
this.cachedPlans=outputPlans;
}
return outputPlans;
}",0.9970414201183432
56114,"/** 
 * Private utility method that generates the alternative CoGroup nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createCoGroupAlternative(List<CoGroupNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
  LocalProperties lp1=PactConnection.getLocalPropertiesAfterConnection(pred1,ss1);
  LocalProperties lp2=PactConnection.getLocalPropertiesAfterConnection(pred2,ss2);
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning());
  LocalProperties outLp=new LocalProperties();
  outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() && lp1.getKeyOrder() == lp2.getKeyOrder() ? lp1.getKeyOrder() : Order.NONE);
  outLp.setKeysGrouped(outLp.getKeyOrder().isOrdered());
  CoGroupNode n=new CoGroupNode(this,pred1,pred2,input1,input2,outGp,outLp);
  n.input1.setShipStrategy(ss1);
  n.input2.setShipStrategy(ss2);
  if (outLp.getKeyOrder().isOrdered()) {
    n.setLocalStrategy(LocalStrategy.NONE);
  }
 else {
    n.setLocalStrategy(LocalStrategy.SORTMERGE);
    n.getLocalProperties().setKeyOrder(Order.ASCENDING);
    n.getLocalProperties().setKeysGrouped(true);
  }
  n.getGlobalProperties().getPreservedAfterContract(getOutputContract());
  n.getLocalProperties().getPreservedAfterContract(getOutputContract());
  estimator.costOperator(n);
  target.add(n);
}","/** 
 * Private utility method that generates the alternative CoGroup nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createCoGroupAlternative(List<CoGroupNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
  LocalProperties lp1=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
  LocalProperties lp2=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning());
  LocalProperties outLp=new LocalProperties();
  outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() && lp1.getKeyOrder() == lp2.getKeyOrder() ? lp1.getKeyOrder() : Order.NONE);
  outLp.setKeysGrouped(outLp.getKeyOrder().isOrdered());
  CoGroupNode n=new CoGroupNode(this,pred1,pred2,input1,input2,outGp,outLp);
  n.input1.setShipStrategy(ss1);
  n.input2.setShipStrategy(ss2);
  if (outLp.getKeyOrder().isOrdered()) {
    n.setLocalStrategy(LocalStrategy.NONE);
  }
 else {
    n.setLocalStrategy(LocalStrategy.SORTMERGE);
    n.getLocalProperties().setKeyOrder(Order.ASCENDING);
    n.getLocalProperties().setKeysGrouped(true);
  }
  n.getGlobalProperties().getPreservedAfterContract(getOutputContract());
  n.getLocalProperties().getPreservedAfterContract(getOutputContract());
  estimator.costOperator(n);
  target.add(n);
}",0.995827538247566
56115,"/** 
 * Private utility method that generates the alternative Cross nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<CrossNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  LocalProperties lpDefaults=new LocalProperties();
  GlobalProperties gp=null;
  LocalProperties lp=null;
  OutputContract oc=getOutputContract();
  boolean isFirst=false;
  if (oc.appliesToFirstInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred1,ss1);
    isFirst=true;
  }
 else   if (oc.appliesToSecondInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred2,ss2);
  }
 else {
    gp=new GlobalProperties();
    lp=new LocalProperties();
  }
  gp.setKeyUnique(false);
  lp.setKeyUnique(false);
  GlobalProperties gpNoOrder=gp.createCopy();
  gpNoOrder.setKeyOrder(Order.NONE);
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      gp=isFirst ? gp : gpNoOrder;
      lp=isFirst ? lp : lpDefaults;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      gp=isFirst ? gpNoOrder : gp;
      lp=isFirst ? lpDefaults : lp;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST || ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      gp=gpNoOrder;
      lp=lpDefaults;
    }
 else {
      return;
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,ls,gp,lp,estimator);
  }
 else {
    if (isFirst) {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
 else {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND,gpNoOrder,lpDefaults,estimator);
  }
}","/** 
 * Private utility method that generates the alternative Cross nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<CrossNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  LocalProperties lpDefaults=new LocalProperties();
  GlobalProperties gp=null;
  LocalProperties lp=null;
  OutputContract oc=getOutputContract();
  boolean isFirst=false;
  if (oc.appliesToFirstInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
    isFirst=true;
  }
 else   if (oc.appliesToSecondInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  }
 else {
    gp=new GlobalProperties();
    lp=new LocalProperties();
  }
  gp.setKeyUnique(false);
  lp.setKeyUnique(false);
  GlobalProperties gpNoOrder=gp.createCopy();
  gpNoOrder.setKeyOrder(Order.NONE);
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      gp=isFirst ? gp : gpNoOrder;
      lp=isFirst ? lp : lpDefaults;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      gp=isFirst ? gpNoOrder : gp;
      lp=isFirst ? lpDefaults : lp;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST || ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      gp=gpNoOrder;
      lp=lpDefaults;
    }
 else {
      return;
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,ls,gp,lp,estimator);
  }
 else {
    if (isFirst) {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
 else {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND,gpNoOrder,lpDefaults,estimator);
  }
}",0.996578857338351
56116,"/** 
 * Copy constructor to create a copy of the data-source object for the process of plan enumeration.
 * @param template The node to create a copy of.
 * @param gp The global properties of this copy.
 * @param lp The local properties of this copy.
 */
protected DataSourceNode(DataSourceNode template,GlobalProperties gp,LocalProperties lp){
  super(template,gp,lp);
}","/** 
 * Copy constructor to create a copy of the data-source object for the process of plan enumeration.
 * @param template The node to create a copy of.
 * @param gp The global properties of this copy.
 * @param lp The local properties of this copy.
 */
protected DataSourceNode(DataSourceNode template,GlobalProperties gp,LocalProperties lp){
  super(template,gp,lp);
  this.fileSize=template.fileSize;
}",0.954954954954955
56117,"@Override public List<MapNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans=input.getSourcePact().getAlternativePlans(estimator);
  List<MapNode> outputPlans=new ArrayList<MapNode>();
  for (  OptimizerNode pred : inPlans) {
    ShipStrategy ss=input.getShipStrategy() == ShipStrategy.NONE ? ShipStrategy.FORWARD : input.getShipStrategy();
    GlobalProperties gp=PactConnection.getGlobalPropertiesAfterConnection(pred,ss);
    LocalProperties lp=PactConnection.getLocalPropertiesAfterConnection(pred,ss);
    MapNode nMap=new MapNode(this,pred,input,gp,lp);
    nMap.input.setShipStrategy(ss);
    nMap.getGlobalProperties().getPreservedAfterContract(getOutputContract());
    nMap.getLocalProperties().getPreservedAfterContract(getOutputContract());
    estimator.costOperator(nMap);
    outputPlans.add(nMap);
  }
  prunePlanAlternatives(outputPlans);
  if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}","@Override public List<MapNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans=input.getSourcePact().getAlternativePlans(estimator);
  List<MapNode> outputPlans=new ArrayList<MapNode>();
  for (  OptimizerNode pred : inPlans) {
    ShipStrategy ss=input.getShipStrategy() == ShipStrategy.NONE ? ShipStrategy.FORWARD : input.getShipStrategy();
    GlobalProperties gp=PactConnection.getGlobalPropertiesAfterConnection(pred,this,ss);
    LocalProperties lp=PactConnection.getLocalPropertiesAfterConnection(pred,this,ss);
    MapNode nMap=new MapNode(this,pred,input,gp,lp);
    nMap.input.setShipStrategy(ss);
    nMap.getGlobalProperties().getPreservedAfterContract(getOutputContract());
    nMap.getLocalProperties().getPreservedAfterContract(getOutputContract());
    estimator.costOperator(nMap);
    outputPlans.add(nMap);
  }
  prunePlanAlternatives(outputPlans);
  if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}",0.9954954954954957
56118,"@Override public List<MatchNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans1=input1.getSourcePact().getAlternativePlans(estimator);
  List<? extends OptimizerNode> inPlans2=input2.getSourcePact().getAlternativePlans(estimator);
  List<MatchNode> outputPlans=new ArrayList<MatchNode>();
  for (  OptimizerNode pred1 : inPlans1) {
    for (    OptimizerNode pred2 : inPlans2) {
      if (!areBranchCompatible(pred1,pred2)) {
        continue;
      }
      ShipStrategy ss1=input1.getShipStrategy();
      ShipStrategy ss2=input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=pred1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=pred2.getGlobalProperties();
          if (gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (gp2.getPartitioning().isComputablyPartitioned()) {
            if ((!gp1.getPartitioning().isPartitioned()) || gp1.getPartitioning().isCompatibleWith(gp2.getPartitioning())) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
              }
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
              }
              continue;
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.PARTITION_RANGE,estimator);
              }
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            if (pred1.getEstimatedOutputSize() != -1 && pred2.getEstimatedOutputSize() != -1) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.BROADCAST,ShipStrategy.FORWARD,estimator);
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.BROADCAST,estimator);
            }
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
switch (ss2) {
case BROADCAST:
            ss1=ShipStrategy.FORWARD;
          break;
case FORWARD:
        if (gp2.getPartitioning().isPartitioned()) {
          if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_HASH;
          }
 else           if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_RANGE;
          }
 else {
            throw new CompilerException();
          }
        }
 else {
          ss1=ShipStrategy.BROADCAST;
        }
      break;
case PARTITION_HASH:
    ss1=(gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
  break;
case PARTITION_RANGE:
ss1=(gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
gp2=pred2.getGlobalProperties();
switch (ss1) {
case BROADCAST:
ss2=ShipStrategy.FORWARD;
break;
case FORWARD:
if (gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
ss2=ShipStrategy.BROADCAST;
}
break;
case PARTITION_HASH:
ss2=(gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
if ((ss1 == ShipStrategy.BROADCAST && ss2 != ShipStrategy.BROADCAST) || (ss1 != ShipStrategy.BROADCAST && ss2 == ShipStrategy.BROADCAST)) {
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
if (gp1.getPartitioning().isPartitioned() && gp1.getPartitioning() == gp2.getPartitioning()) {
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}
if (outputPlans.isEmpty()) {
throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
}
prunePlanAlternatives(outputPlans);
if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
this.cachedPlans=outputPlans;
}
return outputPlans;
}","@Override public List<MatchNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans1=input1.getSourcePact().getAlternativePlans(estimator);
  List<? extends OptimizerNode> inPlans2=input2.getSourcePact().getAlternativePlans(estimator);
  List<MatchNode> outputPlans=new ArrayList<MatchNode>();
  for (  OptimizerNode pred1 : inPlans1) {
    for (    OptimizerNode pred2 : inPlans2) {
      if (!areBranchCompatible(pred1,pred2)) {
        continue;
      }
      ShipStrategy ss1=input1.getShipStrategy();
      ShipStrategy ss2=input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=pred1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=pred2.getGlobalProperties();
          if (gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (gp2.getPartitioning().isComputablyPartitioned()) {
            if ((!gp1.getPartitioning().isPartitioned()) || gp1.getPartitioning().isCompatibleWith(gp2.getPartitioning())) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
              }
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
              }
              continue;
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.PARTITION_RANGE,estimator);
              }
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            if (pred1.getEstimatedOutputSize() != -1 && pred2.getEstimatedOutputSize() != -1) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.BROADCAST,ShipStrategy.FORWARD,estimator);
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.BROADCAST,estimator);
            }
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
switch (ss2) {
case BROADCAST:
            ss1=ShipStrategy.FORWARD;
          break;
case FORWARD:
        if (gp2.getPartitioning().isPartitioned()) {
          if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_HASH;
          }
 else           if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_RANGE;
          }
 else {
            throw new CompilerException();
          }
        }
 else {
          ss1=ShipStrategy.BROADCAST;
        }
      break;
case PARTITION_HASH:
    ss1=(gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
  break;
case PARTITION_RANGE:
ss1=(gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=pred2.getGlobalProperties();
switch (ss1) {
case BROADCAST:
ss2=ShipStrategy.FORWARD;
break;
case FORWARD:
if (gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
ss2=ShipStrategy.BROADCAST;
}
break;
case PARTITION_HASH:
ss2=(gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
if ((ss1 == ShipStrategy.BROADCAST && ss2 != ShipStrategy.BROADCAST) || (ss1 != ShipStrategy.BROADCAST && ss2 == ShipStrategy.BROADCAST)) {
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning()) {
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}
if (outputPlans.isEmpty()) {
throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
}
prunePlanAlternatives(outputPlans);
if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
this.cachedPlans=outputPlans;
}
return outputPlans;
}",0.9980471292800416
56119,"/** 
 * Private utility method that generates the alternative Match nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<MatchNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
  GlobalProperties gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
  LocalProperties lp1=PactConnection.getLocalPropertiesAfterConnection(pred1,ss1);
  LocalProperties lp2=PactConnection.getLocalPropertiesAfterConnection(pred2,ss2);
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning().isPartitioned() ? gp1.getPartitioning() : gp2.getPartitioning());
  outGp.setKeyOrder(gp1.getKeyOrder().isOrdered() ? gp1.getKeyOrder() : gp2.getKeyOrder());
  LocalProperties outLp=new LocalProperties();
  outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() && lp1.getKeyOrder() == lp2.getKeyOrder() ? lp1.getKeyOrder() : Order.NONE);
  outLp.setKeysGrouped(outLp.getKeyOrder().isOrdered());
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.SORTMERGE) {
      outLp.setKeyOrder(Order.ASCENDING);
      outLp.setKeysGrouped(true);
    }
 else     if (ls == LocalStrategy.HYBRIDHASH_FIRST || ls == LocalStrategy.HYBRIDHASH_SECOND || ls == LocalStrategy.MMHASH_FIRST || ls == LocalStrategy.MMHASH_SECOND) {
      outLp.setKeyOrder(Order.NONE);
      outLp.setKeysGrouped(false);
    }
    createMatchAlternative(target,pred1,pred2,ss1,ss2,ls,outGp,outLp,estimator);
  }
 else   if (outLp.getKeyOrder().isOrdered()) {
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NONE,outGp,outLp,estimator);
  }
 else   if (lp1.getKeyOrder().isOrdered() || lp2.getKeyOrder().isOrdered()) {
    outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() ? lp1.getKeyOrder() : lp2.getKeyOrder());
    outLp.setKeysGrouped(true);
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.SORTMERGE,outGp,outLp,estimator);
  }
 else {
    if (pred1.estimatedOutputSize > 0 && pred2.estimatedOutputSize > 0) {
      createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.HYBRIDHASH_FIRST,outGp.createCopy(),outLp.createCopy(),estimator);
      createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.HYBRIDHASH_SECOND,outGp.createCopy(),outLp.createCopy(),estimator);
    }
    outLp.setKeyOrder(Order.ASCENDING);
    outLp.setKeysGrouped(true);
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.SORTMERGE,outGp,outLp,estimator);
  }
}","/** 
 * Private utility method that generates the alternative Match nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<MatchNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
  GlobalProperties gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
  LocalProperties lp1=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
  LocalProperties lp2=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning().isComputablyPartitioned() ? gp1.getPartitioning() : gp2.getPartitioning());
  outGp.setKeyOrder(gp1.getKeyOrder().isOrdered() ? gp1.getKeyOrder() : gp2.getKeyOrder());
  LocalProperties outLp=new LocalProperties();
  outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() && lp1.getKeyOrder() == lp2.getKeyOrder() ? lp1.getKeyOrder() : Order.NONE);
  outLp.setKeysGrouped(outLp.getKeyOrder().isOrdered());
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.SORTMERGE) {
      outLp.setKeyOrder(Order.ASCENDING);
      outLp.setKeysGrouped(true);
    }
 else     if (ls == LocalStrategy.HYBRIDHASH_FIRST || ls == LocalStrategy.HYBRIDHASH_SECOND || ls == LocalStrategy.MMHASH_FIRST || ls == LocalStrategy.MMHASH_SECOND) {
      outLp.setKeyOrder(Order.NONE);
      outLp.setKeysGrouped(false);
    }
    createMatchAlternative(target,pred1,pred2,ss1,ss2,ls,outGp,outLp,estimator);
  }
 else   if (outLp.getKeyOrder().isOrdered()) {
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NONE,outGp,outLp,estimator);
  }
 else   if (lp1.getKeyOrder().isOrdered() || lp2.getKeyOrder().isOrdered()) {
    outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() ? lp1.getKeyOrder() : lp2.getKeyOrder());
    outLp.setKeysGrouped(true);
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.SORTMERGE,outGp,outLp,estimator);
  }
 else {
    if (pred1.estimatedOutputSize > 0 && pred2.estimatedOutputSize > 0) {
      createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.HYBRIDHASH_FIRST,outGp.createCopy(),outLp.createCopy(),estimator);
      createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.HYBRIDHASH_SECOND,outGp.createCopy(),outLp.createCopy(),estimator);
    }
    outLp.setKeyOrder(Order.ASCENDING);
    outLp.setKeysGrouped(true);
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.SORTMERGE,outGp,outLp,estimator);
  }
}",0.9949579831932772
56120,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  this.jobID=new JobID();
  this.jobID.read(in);
  this.taskName=StringRecord.readString(in);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException(""String_Node_Str"" + invokableClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
  }
  final int numOuputGates=in.readInt();
  for (int i=0; i < numOuputGates; i++) {
    final String typeClassName=StringRecord.readString(in);
    Class<? extends Record> type=null;
    try {
      type=(Class<? extends Record>)Class.forName(typeClassName,true,cl);
    }
 catch (    ClassNotFoundException cnfe) {
      throw new IOException(""String_Node_Str"" + typeClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
    }
    final boolean isBroadcast=in.readBoolean();
    ChannelSelector<? extends Record> channelSelector=null;
    if (!isBroadcast) {
      final String channelSelectorClassName=StringRecord.readString(in);
      try {
        channelSelector=(ChannelSelector<? extends Record>)Class.forName(channelSelectorClassName,true,cl).newInstance();
      }
 catch (      InstantiationException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      IllegalAccessException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      ClassNotFoundException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
    }
    channelSelector.read(in);
    @SuppressWarnings(""String_Node_Str"") final OutputGate<? extends Record> eog=new OutputGate(this.jobID,type,i,channelSelector,isBroadcast);
    eog.read(in);
    this.outputGates.add(eog);
    this.unboundOutputGates.add(eog);
  }
  final int numInputGates=in.readInt();
  for (int i=0; i < numInputGates; i++) {
    final String deserializerClassName=StringRecord.readString(in);
    RecordDeserializer<? extends Record> recordDeserializer=null;
    Class<? extends RecordDeserializer<? extends Record>> deserializerClass=null;
    try {
      deserializerClass=(Class<? extends RecordDeserializer<? extends Record>>)cl.loadClass(deserializerClassName);
      recordDeserializer=deserializerClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    recordDeserializer.setClassLoader(cl);
    recordDeserializer.read(in);
    final String distributionPatternClassName=StringRecord.readString(in);
    DistributionPattern distributionPattern=null;
    Class<? extends DistributionPattern> distributionPatternClass=null;
    try {
      distributionPatternClass=(Class<? extends DistributionPattern>)cl.loadClass(distributionPatternClassName);
      distributionPattern=distributionPatternClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    @SuppressWarnings(""String_Node_Str"") final InputGate<? extends Record> eig=new InputGate(this.jobID,recordDeserializer,i,distributionPattern);
    eig.read(in);
    this.inputGates.add(eig);
    this.unboundInputGates.add(eig);
  }
  final int numInputSplits=in.readInt();
  for (int i=0; i < numInputSplits; i++) {
    final boolean isNotNull=in.readBoolean();
    if (isNotNull) {
      final String className=StringRecord.readString(in);
      Class<? extends IOReadableWritable> c=null;
      try {
        c=(Class<? extends IOReadableWritable>)Class.forName(className,true,cl);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new IOException(""String_Node_Str"" + className + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
      }
      try {
        final InputSplit inputSplit=(InputSplit)c.newInstance();
        inputSplit.read(in);
        this.inputSplits.add(inputSplit);
      }
 catch (      InstantiationException e) {
        throw new IOException(e);
      }
catch (      IllegalAccessException e) {
        throw new IOException(e);
      }
    }
  }
  this.runtimeConfiguration=new Configuration();
  this.runtimeConfiguration.read(in);
  this.currentNumberOfSubtasks=in.readInt();
  this.indexInSubtaskGroup=in.readInt();
  this.executionState=EnumUtils.readEnum(in,ExecutionState.class);
  try {
    instantiateInvokable();
  }
 catch (  Exception e) {
    throw new IOException(StringUtils.stringifyException(e));
  }
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  this.jobID=new JobID();
  this.jobID.read(in);
  this.taskName=StringRecord.readString(in);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException(""String_Node_Str"" + invokableClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
  }
  final int numOuputGates=in.readInt();
  for (int i=0; i < numOuputGates; i++) {
    final String typeClassName=StringRecord.readString(in);
    Class<? extends Record> type=null;
    try {
      type=(Class<? extends Record>)Class.forName(typeClassName,true,cl);
    }
 catch (    ClassNotFoundException cnfe) {
      throw new IOException(""String_Node_Str"" + typeClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
    }
    final boolean isBroadcast=in.readBoolean();
    ChannelSelector<? extends Record> channelSelector=null;
    if (!isBroadcast) {
      final String channelSelectorClassName=StringRecord.readString(in);
      try {
        channelSelector=(ChannelSelector<? extends Record>)Class.forName(channelSelectorClassName,true,cl).newInstance();
      }
 catch (      InstantiationException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      IllegalAccessException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      ClassNotFoundException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
      channelSelector.read(in);
    }
    @SuppressWarnings(""String_Node_Str"") final OutputGate<? extends Record> eog=new OutputGate(this.jobID,type,i,channelSelector,isBroadcast);
    eog.read(in);
    this.outputGates.add(eog);
    this.unboundOutputGates.add(eog);
  }
  final int numInputGates=in.readInt();
  for (int i=0; i < numInputGates; i++) {
    final String deserializerClassName=StringRecord.readString(in);
    RecordDeserializer<? extends Record> recordDeserializer=null;
    Class<? extends RecordDeserializer<? extends Record>> deserializerClass=null;
    try {
      deserializerClass=(Class<? extends RecordDeserializer<? extends Record>>)cl.loadClass(deserializerClassName);
      recordDeserializer=deserializerClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    recordDeserializer.setClassLoader(cl);
    recordDeserializer.read(in);
    final String distributionPatternClassName=StringRecord.readString(in);
    DistributionPattern distributionPattern=null;
    Class<? extends DistributionPattern> distributionPatternClass=null;
    try {
      distributionPatternClass=(Class<? extends DistributionPattern>)cl.loadClass(distributionPatternClassName);
      distributionPattern=distributionPatternClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    @SuppressWarnings(""String_Node_Str"") final InputGate<? extends Record> eig=new InputGate(this.jobID,recordDeserializer,i,distributionPattern);
    eig.read(in);
    this.inputGates.add(eig);
    this.unboundInputGates.add(eig);
  }
  final int numInputSplits=in.readInt();
  for (int i=0; i < numInputSplits; i++) {
    final boolean isNotNull=in.readBoolean();
    if (isNotNull) {
      final String className=StringRecord.readString(in);
      Class<? extends IOReadableWritable> c=null;
      try {
        c=(Class<? extends IOReadableWritable>)Class.forName(className,true,cl);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new IOException(""String_Node_Str"" + className + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
      }
      try {
        final InputSplit inputSplit=(InputSplit)c.newInstance();
        inputSplit.read(in);
        this.inputSplits.add(inputSplit);
      }
 catch (      InstantiationException e) {
        throw new IOException(e);
      }
catch (      IllegalAccessException e) {
        throw new IOException(e);
      }
    }
  }
  this.runtimeConfiguration=new Configuration();
  this.runtimeConfiguration.read(in);
  this.currentNumberOfSubtasks=in.readInt();
  this.indexInSubtaskGroup=in.readInt();
  this.executionState=EnumUtils.readEnum(in,ExecutionState.class);
  try {
    instantiateInvokable();
  }
 catch (  Exception e) {
    throw new IOException(StringUtils.stringifyException(e));
  }
}",0.9943077488064634
56121,"/** 
 * Blocks until all output channels are closed.
 * @throws IOException thrown if an error occurred while closing the output channels
 */
private void waitForOutputChannelsToBeClosed() throws IOException {
  while (true) {
    boolean allClosed=true;
    for (int i=0; i < getNumberOfOutputGates(); i++) {
      final OutputGate<? extends Record> eog=getOutputGate(i);
      if (!eog.isClosed()) {
        allClosed=false;
      }
    }
    if (allClosed) {
      break;
    }
 else {
      try {
        Thread.sleep(SLEEPINTERVAL);
      }
 catch (      InterruptedException e) {
        LOG.debug(e);
      }
    }
  }
}","/** 
 * Blocks until all output channels are closed.
 * @throws IOException thrown if an error occurred while closing the output channels
 * @throws InterruptedException thrown if the thread waiting for the channels to be closed is interrupted
 */
private void waitForOutputChannelsToBeClosed() throws IOException, InterruptedException {
  while (true) {
    if (this.isCanceled) {
      throw new InterruptedException();
    }
    boolean allClosed=true;
    for (int i=0; i < getNumberOfOutputGates(); i++) {
      final OutputGate<? extends Record> eog=getOutputGate(i);
      if (!eog.isClosed()) {
        allClosed=false;
      }
    }
    if (allClosed) {
      break;
    }
 else {
      Thread.sleep(SLEEPINTERVAL);
    }
  }
}",0.7850330154071901
56122,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  if (invokable == null) {
    LOG.fatal(""String_Node_Str"");
  }
  changeExecutionState(ExecutionState.RUNNING,null);
  try {
    this.invokable.invoke();
    if (this.isCanceled) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    if (!this.isCanceled) {
      try {
        this.invokable.cancel();
      }
 catch (      Exception e2) {
        LOG.error(StringUtils.stringifyException(e2));
      }
    }
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    closeInputGates();
    requestAllOutputGatesToClose();
    waitForInputChannelsToBeClosed();
    waitForOutputChannelsToBeClosed();
  }
 catch (  Exception e) {
    changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  if (invokable == null) {
    LOG.fatal(""String_Node_Str"");
  }
  changeExecutionState(ExecutionState.RUNNING,null);
  try {
    this.invokable.invoke();
    if (this.isCanceled) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    if (!this.isCanceled) {
      try {
        this.invokable.cancel();
      }
 catch (      Exception e2) {
        LOG.error(StringUtils.stringifyException(e2));
      }
    }
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    closeInputGates();
    requestAllOutputGatesToClose();
    waitForInputChannelsToBeClosed();
    waitForOutputChannelsToBeClosed();
  }
 catch (  Exception e) {
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}",0.9528010586678428
56123,"/** 
 * Blocks until all input channels are closed.
 * @throws IOException thrown if an error occurred while closing the input channels
 */
private void waitForInputChannelsToBeClosed() throws IOException {
  while (true) {
    boolean allClosed=true;
    for (int i=0; i < getNumberOfInputGates(); i++) {
      final InputGate<? extends Record> eig=getInputGate(i);
      if (!eig.isClosed()) {
        allClosed=false;
      }
    }
    if (allClosed) {
      break;
    }
 else {
      try {
        Thread.sleep(SLEEPINTERVAL);
      }
 catch (      InterruptedException e) {
        LOG.debug(e);
      }
    }
  }
}","/** 
 * Blocks until all input channels are closed.
 * @throws IOException thrown if an error occurred while closing the input channels
 * @throws InterruptedException thrown if the thread waiting for the channels to be closed is interrupted
 */
private void waitForInputChannelsToBeClosed() throws IOException, InterruptedException {
  while (true) {
    if (this.isCanceled) {
      throw new InterruptedException();
    }
    boolean allClosed=true;
    for (int i=0; i < getNumberOfInputGates(); i++) {
      final InputGate<? extends Record> eig=getInputGate(i);
      if (!eig.isClosed()) {
        allClosed=false;
      }
    }
    if (allClosed) {
      break;
    }
 else {
      Thread.sleep(SLEEPINTERVAL);
    }
  }
}",0.7831236121391562
56124,"public void read() throws IOException, EOFException {
  if (!isActiveConnection()) {
    System.out.println(""String_Node_Str"");
    return;
  }
  this.deserializer.read(this.readableByteChannel);
  final TransferEnvelope transferEnvelope=this.deserializer.getFullyDeserializedTransferEnvelope();
  if (transferEnvelope != null) {
    this.byteBufferedChannelManager.queueIncomingTransferEnvelope(transferEnvelope);
  }
}","public void read() throws IOException, EOFException {
  if (this.inactiveConnection) {
    final ByteBuffer buf=ByteBuffer.allocate(8);
    final int bytesRead=this.readableByteChannel.read(buf);
    if (bytesRead == 0) {
      return;
    }
 else     if (bytesRead == -1) {
      throw new EOFException();
    }
 else {
      throw new IOException(""String_Node_Str"" + bytesRead + ""String_Node_Str"");
    }
  }
  this.deserializer.read(this.readableByteChannel);
  final TransferEnvelope transferEnvelope=this.deserializer.getFullyDeserializedTransferEnvelope();
  if (transferEnvelope != null) {
    this.byteBufferedChannelManager.queueIncomingTransferEnvelope(transferEnvelope);
  }
}",0.6919602529358627
56125,"public void reportTransmissionProblem(SelectionKey key,IOException ioe){
  if (!this.readsFromCheckpoint) {
    final SocketChannel socketChannel=(SocketChannel)this.readableByteChannel;
    LOG.error(""String_Node_Str"" + socketChannel.socket().getRemoteSocketAddress() + ""String_Node_Str"");
  }
  LOG.error(ioe);
  try {
    this.readableByteChannel.close();
  }
 catch (  IOException e) {
    LOG.debug(""String_Node_Str"");
  }
  if (key != null) {
    key.cancel();
  }
  if (this.deserializer.getBuffer() != null) {
    this.deserializer.getBuffer().recycleBuffer();
  }
  this.deserializer.reset();
  this.byteBufferedChannelManager.unregisterIncomingConnection(this.incomingConnectionID,this.readableByteChannel);
}","public void reportTransmissionProblem(SelectionKey key,IOException ioe){
  if (!this.readsFromCheckpoint) {
    final SocketChannel socketChannel=(SocketChannel)this.readableByteChannel;
    LOG.error(""String_Node_Str"" + socketChannel.socket().getRemoteSocketAddress() + ""String_Node_Str"");
  }
  LOG.error(ioe);
  try {
    this.readableByteChannel.close();
  }
 catch (  IOException e) {
    LOG.debug(""String_Node_Str"");
  }
  if (key != null) {
    key.cancel();
  }
  if (this.deserializer.getBuffer() != null) {
    this.deserializer.getBuffer().recycleBuffer();
  }
  this.deserializer.reset();
  if (!this.inactiveConnection) {
    this.byteBufferedChannelManager.unregisterIncomingConnection(this.incomingConnectionID,this.readableByteChannel);
  }
}",0.972936400541272
56126,"public void closeConnection(SelectionKey key){
  try {
    this.readableByteChannel.close();
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
  if (key != null) {
    key.cancel();
  }
  this.byteBufferedChannelManager.unregisterIncomingConnection(this.incomingConnectionID,this.readableByteChannel);
}","public void closeConnection(SelectionKey key){
  try {
    this.readableByteChannel.close();
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
  if (key != null) {
    key.cancel();
  }
  if (!this.inactiveConnection) {
    this.byteBufferedChannelManager.unregisterIncomingConnection(this.incomingConnectionID,this.readableByteChannel);
  }
}",0.9476439790575916
56127,"/** 
 * Requests all output gates to be closed.
 */
private void requestAllOutputGatesToClose() throws IOException {
  for (int i=0; i < getNumberOfOutputGates(); i++) {
    this.getOutputGate(i).requestClose();
  }
}","/** 
 * Requests all output gates to be closed.
 */
private void requestAllOutputGatesToClose() throws IOException, InterruptedException {
  for (int i=0; i < getNumberOfOutputGates(); i++) {
    this.getOutputGate(i).requestClose();
  }
}",0.9517543859649122
56128,"/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 */
public void publishEvent(AbstractTaskEvent event) throws IOException {
  Iterator<AbstractInputChannel<T>> it=this.inputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}","/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  Iterator<AbstractInputChannel<T>> it=this.inputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}",0.8427230046948356
56129,"/** 
 * Requests the output gate to closed. This means the application will send no records through this gate anymore.
 */
public void requestClose() throws IOException {
  for (int i=0; i < this.getNumberOfOutputChannels(); i++) {
    final AbstractOutputChannel<T> outputChannel=this.getOutputChannel(i);
    outputChannel.requestClose();
  }
}","/** 
 * Requests the output gate to closed. This means the application will send no records through this gate anymore.
 */
public void requestClose() throws IOException, InterruptedException {
  for (int i=0; i < this.getNumberOfOutputChannels(); i++) {
    final AbstractOutputChannel<T> outputChannel=this.getOutputChannel(i);
    outputChannel.requestClose();
  }
}",0.969187675070028
56130,"public void flush() throws IOException {
  final Iterator<AbstractOutputChannel<T>> it=this.outputChannels.iterator();
  while (it.hasNext()) {
    it.next().flush();
  }
}","public void flush() throws IOException, InterruptedException {
  final Iterator<AbstractOutputChannel<T>> it=this.outputChannels.iterator();
  while (it.hasNext()) {
    it.next().flush();
  }
}",0.9398907103825136
56131,"/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 */
public void publishEvent(AbstractTaskEvent event) throws IOException {
  final Iterator<AbstractOutputChannel<T>> it=this.outputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}","/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  final Iterator<AbstractOutputChannel<T>> it=this.outputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}",0.8456221198156681
56132,"/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 */
public void publishEvent(AbstractTaskEvent event) throws IOException {
  this.inputGate.publishEvent(event);
}","/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  this.inputGate.publishEvent(event);
}",0.7963525835866262
56133,"public void flush() throws IOException {
  this.outputGate.flush();
}","public void flush() throws IOException, InterruptedException {
  this.outputGate.flush();
}",0.8625
56134,"/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 */
public void publishEvent(AbstractTaskEvent event) throws IOException {
  this.outputGate.publishEvent(event);
}","/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  this.outputGate.publishEvent(event);
}",0.796969696969697
56135,"/** 
 * Connects a record writer to an output gate.
 * @param outputClass the class of the record that can be emitted with this record writer
 */
@SuppressWarnings(""String_Node_Str"") private void connectOutputGate(Class<T> outputClass,ChannelSelector selector){
  if (this.environment.hasUnboundOutputGates()) {
    final OutputGate<T> eog=(OutputGate<T>)this.environment.getUnboundOutputGate(0);
    if (!outputClass.equals(eog.getType())) {
      throw new RuntimeException(""String_Node_Str"");
    }
    this.outputGate=eog;
  }
 else {
    this.outputGate=new OutputGate<T>(outputClass,this.environment.getNumberOfOutputGates(),selector);
    this.environment.registerOutputGate(this.outputGate);
  }
}","/** 
 * Connects a record writer to an output gate.
 * @param outputClass the class of the record that can be emitted with this record writer
 */
@SuppressWarnings(""String_Node_Str"") private void connectOutputGate(Class<T> outputClass,ChannelSelector<T> selector){
  if (this.environment.hasUnboundOutputGates()) {
    final OutputGate<T> eog=(OutputGate<T>)this.environment.getUnboundOutputGate(0);
    if (!outputClass.equals(eog.getType())) {
      throw new RuntimeException(""String_Node_Str"");
    }
    this.outputGate=eog;
  }
 else {
    this.outputGate=new OutputGate<T>(outputClass,this.environment.getNumberOfOutputGates(),selector);
    this.environment.registerOutputGate(this.outputGate);
  }
}",0.5803255484784147
56136,public abstract void transferEvent(AbstractEvent event) throws IOException ;,"public abstract void transferEvent(AbstractEvent event) throws IOException, InterruptedException ;",0.8735632183908046
56137,public abstract void flush() throws IOException ;,"public abstract void flush() throws IOException, InterruptedException ;",0.8166666666666667
56138,"/** 
 * Requests the output channel to close. After calling this method no more records can be written to the channel. The channel is finally closed when all remaining data that may exist in internal buffers are written to the channel.
 */
public abstract void requestClose() throws IOException ;","/** 
 * Requests the output channel to close. After calling this method no more records can be written to the channel. The channel is finally closed when all remaining data that may exist in internal buffers are written to the channel.
 * @throws IOException thrown if an I/O error occurs while requesting the channel to close
 * @throws InterruptedException thrown if the thread is interrupted while requesting the channel to close
 */
public abstract void requestClose() throws IOException, InterruptedException ;",0.6362515413070283
56139,"@SuppressWarnings(""String_Node_Str"") private AbstractDirectInputChannel<T> getConnectedInputChannel() throws IOException {
  AbstractDirectInputChannel<T> directInputChannel=null;
  if (this.directChannelBroker == null) {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < this.numberOfConnectionRetries; i++) {
    directInputChannel=(AbstractDirectInputChannel<T>)this.directChannelBroker.getDirectInputChannelByID(getConnectedChannelID());
    if (directInputChannel != null) {
      return directInputChannel;
    }
    try {
      Thread.sleep(CONNECTION_SLEEP_INTERVAL);
    }
 catch (    InterruptedException e) {
      LOG.error(e);
    }
  }
  throw new IOException(""String_Node_Str"" + getID());
}","@SuppressWarnings(""String_Node_Str"") private AbstractDirectInputChannel<T> getConnectedInputChannel() throws IOException, InterruptedException {
  AbstractDirectInputChannel<T> directInputChannel=null;
  if (this.directChannelBroker == null) {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < this.numberOfConnectionRetries; i++) {
    directInputChannel=(AbstractDirectInputChannel<T>)this.directChannelBroker.getDirectInputChannelByID(getConnectedChannelID());
    if (directInputChannel != null) {
      return directInputChannel;
    }
    Thread.sleep(CONNECTION_SLEEP_INTERVAL);
  }
  throw new IOException(""String_Node_Str"" + getID());
}",0.8618705035971223
56140,"@Override public void flush() throws IOException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.requestFlush();
}","@Override public void flush() throws IOException, InterruptedException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.requestFlush();
}",0.9527896995708156
56141,"@Override public void transferEvent(AbstractEvent event) throws IOException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.processEvent(event);
}","@Override public void transferEvent(AbstractEvent event) throws IOException, InterruptedException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.processEvent(event);
}",0.958490566037736
56142,"/** 
 * {@inheritDoc}
 */
@Override public void requestClose(){
  this.closeRequested=true;
  if (this.connectedDirectInputChannel == null) {
    try {
      this.connectedDirectInputChannel=getConnectedInputChannel();
    }
 catch (    IOException e) {
      this.connectionFailureException=e;
      return;
    }
  }
  this.connectedDirectInputChannel.requestClose();
}","/** 
 * {@inheritDoc}
 */
@Override public void requestClose() throws InterruptedException {
  this.closeRequested=true;
  if (this.connectedDirectInputChannel == null) {
    try {
      this.connectedDirectInputChannel=getConnectedInputChannel();
    }
 catch (    IOException e) {
      this.connectionFailureException=e;
      return;
    }
  }
  this.connectedDirectInputChannel.requestClose();
}",0.9623865110246432
56143,"/** 
 * This test checks the correct registration/deregistration of   {@link AbstractDirectInputChannel} and{@link AbstractDirectOutputChannel} objects.
 */
@Test public void testDirectChannelManager(){
  final DirectChannelManager dcm=new DirectChannelManager();
  when(this.deserializer.getRecordType()).thenReturn(StringRecord.class);
  final InMemoryInputChannel<StringRecord> inputChannel=new InMemoryInputChannel<StringRecord>(this.inputGate,0,this.deserializer,this.inputChannelID,CompressionLevel.NO_COMPRESSION);
  final InMemoryOutputChannel<StringRecord> outputChannel=new InMemoryOutputChannel<StringRecord>(this.outputGate,0,this.outputChannelID,CompressionLevel.NO_COMPRESSION);
  inputChannel.setConnectedChannelID(this.outputChannelID);
  outputChannel.setConnectedChannelID(this.inputChannelID);
  dcm.registerDirectInputChannel(inputChannel);
  dcm.registerDirectOutputChannel(outputChannel);
  try {
    outputChannel.transferEvent(new StringTaskEvent(""String_Node_Str""));
  }
 catch (  IOException ioe) {
    fail(ioe.getMessage());
  }
  assertEquals(inputChannel,dcm.getDirectInputChannelByID(this.inputChannelID));
  assertEquals(outputChannel,dcm.getDirectOutputChannelByID(this.outputChannelID));
  dcm.unregisterDirectInputChannel(inputChannel);
  dcm.unregisterDirectOutputChannel(outputChannel);
  assertEquals(null,dcm.getDirectInputChannelByID(this.inputChannelID));
  assertEquals(null,dcm.getDirectOutputChannelByID(this.outputChannelID));
}","/** 
 * This test checks the correct registration/deregistration of   {@link AbstractDirectInputChannel} and{@link AbstractDirectOutputChannel} objects.
 */
@Test public void testDirectChannelManager(){
  final DirectChannelManager dcm=new DirectChannelManager();
  when(this.deserializer.getRecordType()).thenReturn(StringRecord.class);
  final InMemoryInputChannel<StringRecord> inputChannel=new InMemoryInputChannel<StringRecord>(this.inputGate,0,this.deserializer,this.inputChannelID,CompressionLevel.NO_COMPRESSION);
  final InMemoryOutputChannel<StringRecord> outputChannel=new InMemoryOutputChannel<StringRecord>(this.outputGate,0,this.outputChannelID,CompressionLevel.NO_COMPRESSION);
  inputChannel.setConnectedChannelID(this.outputChannelID);
  outputChannel.setConnectedChannelID(this.inputChannelID);
  dcm.registerDirectInputChannel(inputChannel);
  dcm.registerDirectOutputChannel(outputChannel);
  try {
    outputChannel.transferEvent(new StringTaskEvent(""String_Node_Str""));
  }
 catch (  IOException ioe) {
    fail(ioe.getMessage());
  }
catch (  InterruptedException ie) {
    fail(ie.getMessage());
  }
  assertEquals(inputChannel,dcm.getDirectInputChannelByID(this.inputChannelID));
  assertEquals(outputChannel,dcm.getDirectOutputChannelByID(this.outputChannelID));
  dcm.unregisterDirectInputChannel(inputChannel);
  dcm.unregisterDirectOutputChannel(outputChannel);
  assertEquals(null,dcm.getDirectInputChannelByID(this.inputChannelID));
  assertEquals(null,dcm.getDirectOutputChannelByID(this.outputChannelID));
}",0.9777630268835048
56144,"/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(UnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  freeSegmentsAtShutdown(outputSegments);
  List<CircularElement> cache=new ArrayList<CircularElement>(buffersToKeepBeforeSpilling);
  CircularElement element=null;
  boolean cacheOnly=false;
  if (buffersToKeepBeforeSpilling > 0) {
    while (isRunning()) {
      if (cache.size() >= buffersToKeepBeforeSpilling) {
        cacheOnly=false;
        break;
      }
      element=queues.spill.take();
      cache.add(element);
      if (element == SENTINEL) {
        cacheOnly=true;
        break;
      }
    }
  }
  if (cacheOnly) {
    LOG.debug(""String_Node_Str"");
    List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>();
    for (    CircularElement cached : cache) {
      iterators.add(cached.buffer.getIterator());
    }
    LOG.debug(""String_Node_Str"");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    setResultIterator(new MergeIterator<K,V>(iterators,keyComparator));
  }
 else {
    LOG.debug(""String_Node_Str"");
    while (isRunning() && (element=takeNext(queues.spill,cache)) != SENTINEL) {
      Channel.ID channel=enumerator.next();
      channelIDs.add(channel);
      ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
      LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
      element.buffer.writeToChannel(writer);
      LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
      outputSegments=writer.close();
      element.buffer.reset();
      queues.empty.put(element);
    }
    LOG.debug(""String_Node_Str"");
    LOG.debug(""String_Node_Str"");
    memoryManager.release(outputSegments);
    LOG.debug(""String_Node_Str"");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    while (channelIDs.size() > maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,ioMemorySize);
    }
    setResultIterator(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  List<CircularElement> cache=new ArrayList<CircularElement>(buffersToKeepBeforeSpilling);
  CircularElement element=null;
  boolean cacheOnly=false;
  if (buffersToKeepBeforeSpilling > 0) {
    while (isRunning()) {
      if (cache.size() >= buffersToKeepBeforeSpilling) {
        cacheOnly=false;
        break;
      }
      element=queues.spill.take();
      cache.add(element);
      if (element == SENTINEL) {
        cacheOnly=true;
        break;
      }
    }
  }
  if (cacheOnly) {
    LOG.debug(""String_Node_Str"");
    List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>();
    Iterator<CircularElement> iter=cache.iterator();
    while (iter.hasNext()) {
      CircularElement cached=iter.next();
      if (cached != SENTINEL) {
        iterators.add(cached.buffer.getIterator());
      }
    }
    LOG.debug(""String_Node_Str"");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    setResultIterator(new MergeIterator<K,V>(iterators,keyComparator));
  }
 else {
    LOG.debug(""String_Node_Str"");
    final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
    List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
    outputSegments=memoryManager.allocate(UnilateralSortMerger.this.parent,2,ioMemorySize / 2);
    freeSegmentsAtShutdown(outputSegments);
    while (isRunning() && (element=takeNext(queues.spill,cache)) != SENTINEL) {
      Channel.ID channel=enumerator.next();
      channelIDs.add(channel);
      ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
      LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
      element.buffer.writeToChannel(writer);
      LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
      outputSegments=writer.close();
      element.buffer.reset();
      queues.empty.put(element);
    }
    LOG.debug(""String_Node_Str"");
    LOG.debug(""String_Node_Str"");
    memoryManager.release(outputSegments);
    LOG.debug(""String_Node_Str"");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    while (channelIDs.size() > maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,ioMemorySize);
    }
    setResultIterator(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}",0.4029197080291971
56145,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (this.inetAddress != null) {
    return this.inetAddress.equals(obj);
  }
 else {
    return this.fileName.equals(obj);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (!(obj instanceof IncomingConnectionID)) {
    return false;
  }
  final IncomingConnectionID ici=(IncomingConnectionID)obj;
  if (this.inetAddress != null) {
    return this.inetAddress.equals(ici.inetAddress);
  }
 else {
    return this.fileName.equals(ici.fileName);
  }
}",0.705244122965642
56146,"@Override public byte[] writeLine(KeyValuePair<PactInteger,CoordVector> pair){
  StringBuilder line=new StringBuilder();
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  line.append(pair.getKey().getValue());
  for (  double coord : pair.getValue().getCoordinates()) {
    line.append('|');
    line.append(df.format(coord));
  }
  line.append('|');
  line.append('\n');
  return line.toString().getBytes();
}","@Override public byte[] writeLine(KeyValuePair<PactInteger,CoordVector> pair){
  StringBuilder line=new StringBuilder();
  line.append(pair.getKey().getValue());
  for (  double coord : pair.getValue().getCoordinates()) {
    line.append('|');
    line.append(df.format(coord));
  }
  line.append('|');
  line.append('\n');
  return line.toString().getBytes();
}",0.9270166453265044
56147,"private void doWrite(SelectionKey key){
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final OutgoingConnection outgoingConnection=(OutgoingConnection)key.attachment();
  try {
    if (!outgoingConnection.write(socketChannel)) {
      outgoingConnection.closeConnection(socketChannel,key);
    }
  }
 catch (  IOException ioe) {
    outgoingConnection.reportTransmissionProblem(socketChannel,key,ioe);
  }
}","private void doWrite(SelectionKey key){
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final OutgoingConnection outgoingConnection=(OutgoingConnection)key.attachment();
  try {
    if (!outgoingConnection.write(socketChannel)) {
    }
  }
 catch (  IOException ioe) {
    outgoingConnection.reportTransmissionProblem(socketChannel,key,ioe);
  }
}",0.9232704402515725
56148,"@Override public KeyValuePair<K,V> deserialize(DataInput in){
  try {
    KeyValuePair<K,V> pair=getInstance();
    pair.read(in);
    return pair;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Override public KeyValuePair<K,V> deserialize(DataInput in){
  try {
    KeyValuePair<K,V> pair=getInstance();
    pair.read(in);
    return pair;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9954128440366972
56149,"@Override public boolean next(){
  if (!iterator1.nextKey() || !iterator2.nextKey()) {
    return false;
  }
  K key1=iterator1.getKey();
  K key2=iterator2.getKey();
  while (key1.compareTo(key2) != 0) {
    if (key1.compareTo(key2) > 0) {
      if (!iterator2.nextKey()) {
        return false;
      }
      key2=iterator2.getKey();
    }
 else     if (key1.compareTo(key2) < 0) {
      if (!iterator1.nextKey()) {
        return false;
      }
      key1=iterator1.getKey();
    }
  }
  key=key1;
  return true;
}","@Override public V next(){
  return next.getValue();
}",0.1646234676007005
56150,"@Override public K getKey(){
  return key;
}","public K getKey(){
  return next.getKey();
}",0.75
56151,"@Override public void open() throws IOException, MemoryAllocationException {
  final Comparator<K> keyComparator=new Comparator<K>(){
    @Override public int compare(    K k1,    K k2){
      return k1.compareTo(k2);
    }
  }
;
{
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>(keyClass);
    final SerializationFactory<V1> valSerialization=new WritableSerializationFactory<V1>(valueClass1);
    this.sortMerger1=new UnilateralSortMerger<K,V1>(memoryManager,ioManager,numSortBufferPerChannel,sizeSortBufferPerChannel,ioMemoryPerChannel,fileHandlesPerChannel,keySerialization,valSerialization,keyComparator,reader1,parentTask);
  }
{
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>(keyClass);
    final SerializationFactory<V2> valSerialization=new WritableSerializationFactory<V2>(valueClass2);
    this.sortMerger2=new UnilateralSortMerger<K,V2>(memoryManager,ioManager,numSortBufferPerChannel,sizeSortBufferPerChannel,ioMemoryPerChannel,fileHandlesPerChannel,keySerialization,valSerialization,keyComparator,reader2,parentTask);
  }
  this.iterator1=new KeyGroupedIterator<K,V1>(sortMerger1.getIterator());
  this.iterator2=new KeyGroupedIterator<K,V2>(sortMerger2.getIterator());
}","@Override public void open() throws IOException, MemoryAllocationException {
  final Comparator<K> keyComparator=new Comparator<K>(){
    @Override public int compare(    K k1,    K k2){
      return k1.compareTo(k2);
    }
  }
;
{
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>(keyClass);
    final SerializationFactory<V1> valSerialization=new WritableSerializationFactory<V1>(valueClass1);
    this.sortMerger1=new UnilateralSortMerger<K,V1>(memoryManager,ioManager,numSortBufferPerChannel,sizeSortBufferPerChannel,ioMemoryPerChannel,fileHandlesPerChannel,keySerialization,valSerialization,keyComparator,reader1,parentTask);
  }
{
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>(keyClass);
    final SerializationFactory<V2> valSerialization=new WritableSerializationFactory<V2>(valueClass2);
    this.sortMerger2=new UnilateralSortMerger<K,V2>(memoryManager,ioManager,numSortBufferPerChannel,sizeSortBufferPerChannel,ioMemoryPerChannel,fileHandlesPerChannel,keySerialization,valSerialization,keyComparator,reader2,parentTask);
  }
  this.iterator1=new KeyValueIterator<V1>(sortMerger1.getIterator());
  this.iterator2=new KeyValueIterator<V2>(sortMerger2.getIterator());
}",0.9904686258935664
56152,"/** 
 * This method is periodically called by the framework to check the state of the task threads. If any task thread has unexpectedly switch to TERMINATED, this indicates that an   {@link Error} has occurredduring its execution.
 */
private void checkTaskExecution(){
synchronized (this.runningTasks) {
    final Iterator<ExecutionVertexID> it=this.runningTasks.keySet().iterator();
    while (it.hasNext()) {
      final ExecutionVertexID executionVertexID=it.next();
      final Environment environment=this.runningTasks.get(executionVertexID);
      if (environment.getExecutingThread().getState() == Thread.State.TERMINATED) {
        it.remove();
        environment.changeExecutionState(ExecutionState.FAILED,""String_Node_Str"");
      }
    }
  }
}","/** 
 * This method is periodically called by the framework to check the state of the task threads. If any task thread has unexpectedly switch to TERMINATED, this indicates that an   {@link Error} has occurredduring its execution.
 */
private void checkTaskExecution(){
  final List<Environment> crashEnvironments=new LinkedList<Environment>();
synchronized (this.runningTasks) {
    final Iterator<ExecutionVertexID> it=this.runningTasks.keySet().iterator();
    while (it.hasNext()) {
      final ExecutionVertexID executionVertexID=it.next();
      final Environment environment=this.runningTasks.get(executionVertexID);
      if (environment.getExecutingThread().getState() == Thread.State.TERMINATED) {
        it.remove();
        crashEnvironments.add(environment);
      }
    }
  }
  final Iterator<Environment> it2=crashEnvironments.iterator();
  while (it2.hasNext()) {
    it2.next().changeExecutionState(ExecutionState.FAILED,""String_Node_Str"");
  }
}",0.85
56153,"/** 
 * {@inheritDoc}
 */
@Override public TaskCancelResult cancelTask(ExecutionVertexID id) throws IOException {
  Environment tmpEnvironment;
synchronized (this.runningTasks) {
    tmpEnvironment=this.runningTasks.get(id);
    if (tmpEnvironment == null) {
      final TaskCancelResult taskCancelResult=new TaskCancelResult(id,AbstractTaskResult.ReturnCode.ERROR);
      taskCancelResult.setDescription(""String_Node_Str"" + id + ""String_Node_Str"");
      return taskCancelResult;
    }
  }
  final Environment environment=tmpEnvironment;
  Thread tmpThread=new Thread(new Runnable(){
    @Override public void run(){
      environment.cancelExecution();
    }
  }
);
  tmpThread.start();
  return new TaskCancelResult(id,AbstractTaskResult.ReturnCode.SUCCESS);
}","/** 
 * {@inheritDoc}
 */
@Override public TaskCancelResult cancelTask(ExecutionVertexID id) throws IOException {
  Environment tmpEnvironment;
synchronized (this.runningTasks) {
    tmpEnvironment=this.runningTasks.get(id);
    if (tmpEnvironment == null) {
      final TaskCancelResult taskCancelResult=new TaskCancelResult(id,AbstractTaskResult.ReturnCode.ERROR);
      taskCancelResult.setDescription(""String_Node_Str"" + id + ""String_Node_Str"");
      return taskCancelResult;
    }
  }
  final Environment environment=tmpEnvironment;
  final Thread tmpThread=new Thread(new Runnable(){
    @Override public void run(){
      environment.cancelExecution();
    }
  }
);
  tmpThread.start();
  return new TaskCancelResult(id,AbstractTaskResult.ReturnCode.SUCCESS);
}",0.9960835509138382
56154,"@Test public void testIterator() throws InterruptedException {
  Map<Key,Collection<Value>> expectedValuesMap1=collectData(generator1,INPUT_1_SIZE);
  Map<Key,Collection<Value>> expectedValuesMap2=collectData(generator2,INPUT_2_SIZE);
  Map<Key,Collection<Match>> expectedMatchesMap=matchValues(expectedValuesMap1,expectedValuesMap2);
  generator1.reset();
  generator2.reset();
  SortMergeMatchIterator<TestData.Key,TestData.Value,TestData.Value> iterator=new SortMergeMatchIterator<TestData.Key,TestData.Value,TestData.Value>(memoryManager,ioManager,reader1,reader2,TestData.Key.class,TestData.Value.class,TestData.Value.class,NUM_SORT_BUFFERS,SIZE_SORT_BUFFER,MEMORY_IO,128,null);
  iterator.open();
  while (iterator.next()) {
    TestData.Key key=new TestData.Key(iterator.getKey().getKey());
    Assert.assertTrue(""String_Node_Str"" + key + ""String_Node_Str"",expectedMatchesMap.containsKey(key));
    Iterator<TestData.Value> iter1=iterator.getValues1();
    Iterator<TestData.Value> iter2=iterator.getValues2();
    List<TestData.Value> values1=new ArrayList<TestData.Value>();
    while (iter1.hasNext()) {
      values1.add(new TestData.Value(iter1.next().getValue()));
    }
    List<TestData.Value> values2=new ArrayList<TestData.Value>();
    while (iter2.hasNext()) {
      values2.add(new TestData.Value(iter2.next().getValue()));
    }
    for (    Value value1 : values1) {
      for (      Value value2 : values2) {
        Collection<Match> expectedValues=expectedMatchesMap.get(key);
        Match match=new Match(value1,value2);
        Assert.assertTrue(""String_Node_Str"" + match + ""String_Node_Str""+ key,expectedValues.contains(match));
        expectedValues.remove(match);
      }
    }
  }
  iterator.close();
  for (  Entry<Key,Collection<Match>> entry : expectedMatchesMap.entrySet()) {
    Assert.assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",entry.getValue().isEmpty());
  }
}","@Test public void testIterator() throws InterruptedException {
  Map<Key,Collection<Value>> expectedValuesMap1=collectData(generator1,INPUT_1_SIZE);
  Map<Key,Collection<Value>> expectedValuesMap2=collectData(generator2,INPUT_2_SIZE);
  Map<Key,Collection<Match>> expectedMatchesMap=matchValues(expectedValuesMap1,expectedValuesMap2);
  generator1.reset();
  generator2.reset();
  SortMergeMatchIterator<TestData.Key,TestData.Value,TestData.Value> iterator=new SortMergeMatchIterator<TestData.Key,TestData.Value,TestData.Value>(memoryManager,ioManager,reader1,reader2,TestData.Key.class,TestData.Value.class,TestData.Value.class,NUM_SORT_BUFFERS,SIZE_SORT_BUFFER,MEMORY_IO,128,parentTask);
  iterator.open();
  while (iterator.next()) {
    TestData.Key key=new TestData.Key(iterator.getKey().getKey());
    Assert.assertTrue(""String_Node_Str"" + key + ""String_Node_Str"",expectedMatchesMap.containsKey(key));
    Iterator<TestData.Value> iter1=iterator.getValues1();
    Iterator<TestData.Value> iter2=iterator.getValues2();
    List<TestData.Value> values1=new ArrayList<TestData.Value>();
    while (iter1.hasNext()) {
      values1.add(new TestData.Value(iter1.next().getValue()));
    }
    List<TestData.Value> values2=new ArrayList<TestData.Value>();
    while (iter2.hasNext()) {
      values2.add(new TestData.Value(iter2.next().getValue()));
    }
    for (    Value value1 : values1) {
      for (      Value value2 : values2) {
        Collection<Match> expectedValues=expectedMatchesMap.get(key);
        Match match=new Match(value1,value2);
        Assert.assertTrue(""String_Node_Str"" + match + ""String_Node_Str""+ key,expectedValues.contains(match));
        expectedValues.remove(match);
      }
    }
  }
  iterator.close();
  for (  Entry<Key,Collection<Match>> entry : expectedMatchesMap.entrySet()) {
    Assert.assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",entry.getValue().isEmpty());
  }
}",0.9963674104826156
56155,"/** 
 * Creates a new channel to the path indicated by the given ID. The channel hands IO requests to the given request queue to be processed.
 * @param channelID The id describing the path of the file that the channel accessed.
 * @param requestQueue The queue that this channel hands its IO requests to.
 */
protected ChannelAccess(Channel.ID channelID,RequestQueue<IORequest<T>> requestQueue,Collection<T> buffers) throws IOException {
  if (channelID == null || requestQueue == null) {
    throw new NullPointerException();
  }
  this.id=channelID;
  this.numBuffers=buffers.size();
  this.requestQueue=requestQueue;
  this.returnBuffers=new ArrayBlockingQueue<T>(buffers.size(),false);
  try {
    RandomAccessFile file=new RandomAccessFile(id.getPath(),""String_Node_Str"");
    this.fileChannel=file.getChannel();
  }
 catch (  IOException e) {
    throw new IOException(""String_Node_Str"" + channelID.getPath() + ""String_Node_Str"",e);
  }
}","/** 
 * Creates a new channel to the path indicated by the given ID. The channel hands IO requests to the given request queue to be processed.
 * @param channelID The id describing the path of the file that the channel accessed.
 * @param requestQueue The queue that this channel hands its IO requests to.
 */
protected ChannelAccess(Channel.ID channelID,RequestQueue<IORequest<T>> requestQueue,Collection<T> buffers) throws IOException {
  if (channelID == null || requestQueue == null || buffers == null) {
    throw new IllegalArgumentException();
  }
  if (buffers.isEmpty()) {
    throw new IllegalArgumentException();
  }
  this.id=channelID;
  this.numBuffers=buffers.size();
  this.requestQueue=requestQueue;
  this.returnBuffers=new ArrayBlockingQueue<T>(buffers.size(),false);
  try {
    RandomAccessFile file=new RandomAccessFile(id.getPath(),""String_Node_Str"");
    this.fileChannel=file.getChannel();
  }
 catch (  IOException e) {
    throw new IOException(""String_Node_Str"" + channelID.getPath() + ""String_Node_Str"",e);
  }
}",0.9405840886203424
56156,"/** 
 * @param channelID
 * @param requestQueue
 * @param buffers
 * @param deleteWhenDone
 * @throws IOException
 */
public ChannelReader(Channel.ID channelID,RequestQueue<IORequest<Buffer.Input>> requestQueue,Collection<Buffer.Input> buffers,boolean deleteWhenDone) throws IOException {
  super(channelID,requestQueue,buffers);
  this.deleteWhenDone=deleteWhenDone;
  for (  Buffer.Input buffer : buffers) {
    this.requestQueue.add(new IORequest<Buffer.Input>(this,buffer));
  }
}","/** 
 * @param channelID
 * @param requestQueue
 * @param buffers
 * @param deleteWhenDone
 * @throws IOException
 */
protected ChannelReader(Channel.ID channelID,RequestQueue<IORequest<Buffer.Input>> requestQueue,Collection<Buffer.Input> buffers,boolean deleteWhenDone) throws IOException {
  super(channelID,requestQueue,buffers);
  this.deleteWhenDone=deleteWhenDone;
  for (  Buffer.Input buffer : buffers) {
    this.requestQueue.add(new IORequest<Buffer.Input>(this,buffer));
  }
}",0.9866117404737385
56157,"/** 
 * @param channelID
 * @param requestQueue
 * @param buffers
 * @param filledBuffers
 * @throws IOException
 */
public ChannelWriter(Channel.ID channelID,RequestQueue<IORequest<Buffer.Output>> requestQueue,Collection<Buffer.Output> buffers,boolean filledBuffers) throws IOException {
  super(channelID,requestQueue,buffers);
  try {
    this.fileChannel.truncate(0);
  }
 catch (  IOException e) {
    throw new IOException(""String_Node_Str"" + channelID.getPath() + ""String_Node_Str"",e);
  }
  if (filledBuffers) {
    for (    Buffer.Output buffer : buffers) {
      this.requestQueue.add(new IORequest<Buffer.Output>(this,buffer));
    }
  }
 else {
    this.returnBuffers.addAll(buffers);
  }
  try {
    currentBuffer=nextBuffer();
    checkErroneous();
  }
 catch (  InterruptedException iex) {
    throw new IOException(""String_Node_Str"");
  }
}","/** 
 * @param channelID
 * @param requestQueue
 * @param buffers
 * @param filledBuffers
 * @throws IOException
 */
protected ChannelWriter(Channel.ID channelID,RequestQueue<IORequest<Buffer.Output>> requestQueue,Collection<Buffer.Output> buffers,boolean filledBuffers) throws IOException {
  super(channelID,requestQueue,buffers);
  try {
    this.fileChannel.truncate(0);
  }
 catch (  IOException e) {
    throw new IOException(""String_Node_Str"" + channelID.getPath() + ""String_Node_Str"",e);
  }
  if (filledBuffers) {
    for (    Buffer.Output buffer : buffers) {
      this.requestQueue.add(new IORequest<Buffer.Output>(this,buffer));
    }
  }
 else {
    this.returnBuffers.addAll(buffers);
  }
  try {
    currentBuffer=nextBuffer();
    checkErroneous();
  }
 catch (  InterruptedException iex) {
    throw new IOException(""String_Node_Str"");
  }
}",0.9924198250728864
56158,"/** 
 * <p> Creates a ChannelWriter for the anonymous file identified by the specified   {@code channelID} using the provided{@code memorySegments} as backing memory for an internal flow of output buffers. If the boolean variable {@code filled} is set, the content of the memorySegments is flushed to the file before reusing.</p>
 * @param channelID
 * @param freeSegments
 * @param filled
 * @return
 * @throws IOException
 */
public ChannelWriter createChannelWriter(Channel.ID channelID,Collection<Buffer.Output> buffers,boolean filled) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelWriter(channelID,writer.requestQueue,buffers,filled);
}","/** 
 * Creates a ChannelWriter for the anonymous file identified by the specified   {@code channelID} using the provided{@code memorySegments} as backing memory for an internal flow of output buffers. If the boolean variable {@code filled} is set, the content of the memorySegments is flushed to the file before reusing.
 * @param channelID
 * @param freeSegments
 * @param filled
 * @return
 * @throws IOException
 */
public ChannelWriter createChannelWriter(Channel.ID channelID,Collection<Buffer.Output> buffers,boolean filled) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelWriter(channelID,writer.requestQueue,buffers,filled);
}",0.9943661971830986
56159,"/** 
 * <p> Creates a ChannelWriter for the anonymous file written on secondary storage and identified by the specified  {@code channelID} using the provided {@code freeSegments} as backing memory for an internal flow of inputbuffers. </p>
 * @param channelID
 * @param freeSegments
 * @return
 * @throws IOException
 */
public ChannelReader createChannelReader(Channel.ID channelID,Collection<MemorySegment> freeSegments,boolean deleteFileAfterRead) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelReader(channelID,reader.requestQueue,createBuffer(Buffer.Type.INPUT,freeSegments),deleteFileAfterRead);
}","/** 
 * Creates a ChannelWriter for the anonymous file written on secondary storage and identified by the specified  {@code channelID} using the provided {@code freeSegments} as backing memory for an internal flow of inputbuffers.
 * @param channelID
 * @param freeSegments
 * @return
 * @throws IOException
 */
public ChannelReader createChannelReader(Channel.ID channelID,Collection<MemorySegment> freeSegments,boolean deleteFileAfterRead) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelReader(channelID,reader.requestQueue,createBuffer(Buffer.Type.INPUT,freeSegments),deleteFileAfterRead);
}",0.9932885906040269
56160,"/** 
 * Close method. Shuts down the reader and writer threads immediately, not waiting for their pending requests to be served. This method waits until the threads have actually ceased their operation.
 */
public synchronized final void shutdown(){
  if (!isClosed) {
    isClosed=true;
    LOG.info(""String_Node_Str"");
    try {
      writer.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      reader.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      this.writer.join();
      this.reader.join();
    }
 catch (    InterruptedException iex) {
    }
  }
}","/** 
 * Close method. Shuts down the reader and writer threads immediately, not waiting for their pending requests to be served. This method waits until the threads have actually ceased their operation.
 */
public synchronized final void shutdown(){
  if (!isClosed) {
    isClosed=true;
    try {
      writer.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      reader.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      this.writer.join();
      this.reader.join();
    }
 catch (    InterruptedException iex) {
    }
  }
}",0.8401544401544402
56161,"/** 
 * Checks the behavior of the resourceAllocated() method
 * @throws Exception
 */
@Test public void testResourceAllocated() throws Exception {
  QueueScheduler toTest=spy(new QueueScheduler(this.schedulingListener,this.instanceManager));
  JobID jobid=mock(JobID.class);
  AllocatedResource resource=mock(AllocatedResource.class);
  InstanceType instanceType=new InstanceType();
  InstanceConnectionInfo instanceConnectionInfo=mock(InstanceConnectionInfo.class);
  when(instanceConnectionInfo.toString()).thenReturn(""String_Node_Str"");
  LocalInstance instance=spy(new LocalInstance(instanceType,instanceConnectionInfo,null,null,null));
  toTest.resourceAllocated(null,null);
  verify(this.loggerMock).error(Matchers.anyString());
  final Method methodToMock=MemberMatcher.method(QueueScheduler.class,JobID.class);
  PowerMockito.when(toTest,methodToMock).withArguments(Matchers.any(JobID.class)).thenReturn(null);
  when(resource.getInstance()).thenReturn(instance);
  toTest.resourceAllocated(jobid,resource);
  try {
    verify(this.instanceManager).releaseAllocatedResource(Matchers.any(JobID.class),Matchers.any(Configuration.class),Matchers.any(AllocatedResource.class));
  }
 catch (  InstanceException e1) {
    e1.printStackTrace();
  }
  PowerMockito.when(toTest,methodToMock).withArguments(Matchers.any(JobID.class)).thenReturn(this.executionGraph);
  when(this.graphIterator.next()).thenReturn(this.vertex1);
  when(this.graphIterator.hasNext()).thenReturn(true,true,true,true,false);
  when(this.graphIterator2.next()).thenReturn(this.vertex1);
  when(this.graphIterator2.hasNext()).thenReturn(true,true,true,true,false);
  when(this.vertex1.getExecutionState()).thenReturn(ExecutionState.ASSIGNING);
  try {
    whenNew(ExecutionGraphIterator.class).withArguments(Matchers.any(ExecutionGraph.class),Matchers.anyBoolean()).thenReturn(this.graphIterator);
    whenNew(ExecutionGraphIterator.class).withArguments(Matchers.any(ExecutionGraph.class),Matchers.anyInt(),Matchers.anyBoolean(),Matchers.anyBoolean()).thenReturn(this.graphIterator2);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  when(this.executionGraph.getJobID()).thenReturn(jobid);
  Deque<ExecutionGraph> jobQueue=Whitebox.getInternalState(toTest,""String_Node_Str"");
  jobQueue.add(this.executionGraph);
  Whitebox.setInternalState(toTest,""String_Node_Str"",jobQueue);
  when(this.vertex1.getAllocatedResource()).thenReturn(null);
  when(resource.getInstance()).thenReturn(instance);
  toTest.resourceAllocated(jobid,resource);
  verify(this.loggerMock).warn(Matchers.anyString());
  when(this.graphIterator2.hasNext()).thenReturn(true,true,true,true,false);
  when(this.graphIterator.hasNext()).thenReturn(true,true,true,true,false);
  when(this.vertex1.getAllocatedResource()).thenReturn(resource);
  toTest.resourceAllocated(jobid,resource);
  verify(this.vertex1,times(4)).setExecutionState(ExecutionState.ASSIGNED);
}","/** 
 * Checks the behavior of the resourceAllocated() method
 * @throws Exception
 */
@Test public void testResourceAllocated() throws Exception {
  QueueScheduler toTest=spy(new QueueScheduler(this.schedulingListener,this.instanceManager));
  JobID jobid=mock(JobID.class);
  AllocatedResource resource=mock(AllocatedResource.class);
  InstanceType instanceType=new InstanceType();
  InstanceConnectionInfo instanceConnectionInfo=mock(InstanceConnectionInfo.class);
  when(instanceConnectionInfo.toString()).thenReturn(""String_Node_Str"");
  LocalInstance instance=spy(new LocalInstance(instanceType,instanceConnectionInfo,null,null,null));
  toTest.resourceAllocated(null,null);
  verify(this.loggerMock).error(Matchers.anyString());
  final Method methodToMock=MemberMatcher.method(QueueScheduler.class,JobID.class);
  PowerMockito.when(toTest,methodToMock).withArguments(Matchers.any(JobID.class)).thenReturn(null);
  when(resource.getInstance()).thenReturn(instance);
  toTest.resourceAllocated(jobid,resource);
  try {
    verify(this.instanceManager).releaseAllocatedResource(Matchers.any(JobID.class),Matchers.any(Configuration.class),Matchers.any(AllocatedResource.class));
  }
 catch (  InstanceException e1) {
    e1.printStackTrace();
  }
  PowerMockito.when(toTest,methodToMock).withArguments(Matchers.any(JobID.class)).thenReturn(this.executionGraph);
  when(this.graphIterator.next()).thenReturn(this.vertex1);
  when(this.graphIterator.hasNext()).thenReturn(true,true,true,true,false);
  when(this.graphIterator2.next()).thenReturn(this.vertex1);
  when(this.graphIterator2.hasNext()).thenReturn(true,true,true,true,false);
  when(this.vertex1.getExecutionState()).thenReturn(ExecutionState.ASSIGNING);
  try {
    whenNew(ExecutionGraphIterator.class).withArguments(Matchers.any(ExecutionGraph.class),Matchers.anyBoolean()).thenReturn(this.graphIterator);
    whenNew(ExecutionGraphIterator.class).withArguments(Matchers.any(ExecutionGraph.class),Matchers.anyInt(),Matchers.anyBoolean(),Matchers.anyBoolean()).thenReturn(this.graphIterator2);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  when(this.executionGraph.getJobID()).thenReturn(jobid);
  Deque<ExecutionGraph> jobQueue=Whitebox.getInternalState(toTest,""String_Node_Str"");
  jobQueue.add(this.executionGraph);
  Whitebox.setInternalState(toTest,""String_Node_Str"",jobQueue);
  when(this.vertex1.getAllocatedResource()).thenReturn(null);
  when(resource.getInstance()).thenReturn(instance);
  toTest.resourceAllocated(jobid,resource);
  verify(this.loggerMock).warn(Matchers.anyString());
  when(this.graphIterator2.hasNext()).thenReturn(true,true,true,true,false);
  when(this.graphIterator.hasNext()).thenReturn(true,true,true,true,false);
  when(this.vertex1.getAllocatedResource()).thenReturn(resource);
  when(resource.getInstanceType()).thenReturn(instanceType);
  toTest.resourceAllocated(jobid,resource);
  verify(this.vertex1,times(4)).setExecutionState(ExecutionState.ASSIGNED);
}",0.9896837476746152
56162,"public ChannelReader(Channel.ID channelID,RequestQueue<IORequest<Buffer.Input>> requestQueue,Collection<Buffer.Input> buffers) throws IOException {
  super(channelID,requestQueue,buffers);
  for (  Buffer.Input buffer : buffers) {
    this.requestQueue.add(new IORequest<Buffer.Input>(this,buffer));
  }
}","public ChannelReader(Channel.ID channelID,RequestQueue<IORequest<Buffer.Input>> requestQueue,Collection<Buffer.Input> buffers,boolean deleteWhenDone) throws IOException {
  super(channelID,requestQueue,buffers);
  this.deleteWhenDone=deleteWhenDone;
  for (  Buffer.Input buffer : buffers) {
    this.requestQueue.add(new IORequest<Buffer.Input>(this,buffer));
  }
}",0.9090909090909092
56163,"/** 
 * <p> Creates a ChannelWriter for the anonymous file identified by the specified   {@code channelID} using the provided{@code memorySegments} as backing memory for an internal flow of output buffers. If the boolean variable {@code filled} is set, the content of the memorySegments is flushed to the file before reusing.</p>
 * @param channelID
 * @param freeSegments
 * @param filled
 * @return
 * @throws ServiceException
 */
public ChannelWriter createChannelWriter(Channel.ID channelID,Collection<Buffer.Output> buffers,boolean filled) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelWriter(channelID,writer.requestQueue,buffers,filled);
}","/** 
 * <p> Creates a ChannelWriter for the anonymous file identified by the specified   {@code channelID} using the provided{@code memorySegments} as backing memory for an internal flow of output buffers. If the boolean variable {@code filled} is set, the content of the memorySegments is flushed to the file before reusing.</p>
 * @param channelID
 * @param freeSegments
 * @param filled
 * @return
 * @throws IOException
 */
public ChannelWriter createChannelWriter(Channel.ID channelID,Collection<Buffer.Output> buffers,boolean filled) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelWriter(channelID,writer.requestQueue,buffers,filled);
}",0.9937194696441032
56164,"/** 
 * <p> Creates a ChannelWriter for the anonymous file written on secondary storage and identified by the specified  {@code channelID} using the provided {@code freeSegments} as backing memory for an internal flow of inputbuffers. </p>
 * @param channelID
 * @param freeSegments
 * @return
 * @throws ServiceException
 */
public ChannelReader createChannelReader(Channel.ID channelID,Collection<MemorySegment> freeSegments) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelReader(channelID,reader.requestQueue,createBuffer(Buffer.Type.INPUT,freeSegments));
}","/** 
 * <p> Creates a ChannelWriter for the anonymous file written on secondary storage and identified by the specified  {@code channelID} using the provided {@code freeSegments} as backing memory for an internal flow of inputbuffers. </p>
 * @param channelID
 * @param freeSegments
 * @return
 * @throws IOException
 */
public ChannelReader createChannelReader(Channel.ID channelID,Collection<MemorySegment> freeSegments,boolean deleteFileAfterRead) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelReader(channelID,reader.requestQueue,createBuffer(Buffer.Type.INPUT,freeSegments),deleteFileAfterRead);
}",0.956388676358072
56165,"/** 
 * Generic factory method for typed initialized collections of different buffer types.
 * @param < T >
 * @param bufferType
 * @param numberOfBuffers
 * @return Collection<T> an unsynchronized collection of initialized buffers
 * @throws ServiceException
 */
public static <T extends Buffer>Collection<T> createBuffer(Buffer.Type<T> bufferType,Collection<MemorySegment> freeSegments){
  ArrayList<T> buffers=new ArrayList<T>(freeSegments.size());
  for (  MemorySegment segment : freeSegments) {
    T buffer=createBuffer(bufferType);
    buffer.bind(segment);
    buffers.add(buffer);
  }
  return buffers;
}","/** 
 * Generic factory method for typed initialized collections of different buffer types.
 * @param < T >
 * @param bufferType
 * @param numberOfBuffers
 * @return Collection<T> an unsynchronized collection of initialized buffers
 */
public static <T extends Buffer>Collection<T> createBuffer(Buffer.Type<T> bufferType,Collection<MemorySegment> freeSegments){
  ArrayList<T> buffers=new ArrayList<T>(freeSegments.size());
  for (  MemorySegment segment : freeSegments) {
    T buffer=createBuffer(bufferType);
    buffer.bind(segment);
    buffers.add(buffer);
  }
  return buffers;
}",0.9766666666666668
56166,"/** 
 * Close method.
 */
public synchronized final void shutdown(){
  if (!isClosed) {
    isClosed=true;
    LOG.info(""String_Node_Str"");
    try {
      writer.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      reader.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      this.writer.join();
      this.reader.join();
    }
 catch (    InterruptedException iex) {
    }
  }
}","/** 
 * Close method. Shuts down the reader and writer threads immediately, not waiting for their pending requests to be served. This method waits until the threads have actually ceased their operation.
 */
public synchronized final void shutdown(){
  if (!isClosed) {
    isClosed=true;
    LOG.info(""String_Node_Str"");
    try {
      writer.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      reader.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      this.writer.join();
      this.reader.join();
    }
 catch (    InterruptedException iex) {
    }
  }
}",0.8421970357454228
56167,"public boolean isProperlyShutDown(){
  return isClosed && (this.writer.getState() == Thread.State.TERMINATED) && (this.reader.getState() == Thread.State.TERMINATED);
}","/** 
 * Utility method to check whether the IO manager has been properly shut down. The IO manager is considered to be properly shut down when it is closed and its threads have ceased operation.
 * @return True, if the IO manager has properly shut down, false otherwise.
 */
public boolean isProperlyShutDown(){
  return isClosed && (this.writer.getState() == Thread.State.TERMINATED) && (this.reader.getState() == Thread.State.TERMINATED);
}",0.548440065681445
56168,"private int readFromChannel(Channel.ID channelID) throws IOException, MemoryAllocationException {
  Collection<MemorySegment> freeSegments=memoryManager.allocate(new DummyInvokable(),NUMBER_OF_SEGMENTS,SEGMENT_SIZE);
  ChannelReader channelReader=ioManager.createChannelReader(channelID,freeSegments);
  generator.reset();
  Value value=new Value();
  int readCounter=0;
  while (channelReader.read(value)) {
    Assert.assertEquals(""String_Node_Str"",generator.next(),value);
    readCounter++;
  }
  memoryManager.release(channelReader.close());
  return readCounter;
}","private int readFromChannel(Channel.ID channelID) throws IOException, MemoryAllocationException {
  Collection<MemorySegment> freeSegments=memoryManager.allocate(new DummyInvokable(),NUMBER_OF_SEGMENTS,SEGMENT_SIZE);
  ChannelReader channelReader=ioManager.createChannelReader(channelID,freeSegments,true);
  generator.reset();
  Value value=new Value();
  int readCounter=0;
  while (channelReader.read(value)) {
    Assert.assertEquals(""String_Node_Str"",generator.next(),value);
    readCounter++;
  }
  memoryManager.release(channelReader.close());
  return readCounter;
}",0.9956331877729258
56169,"/** 
 * This utility method picks the instance type to be used for scheduling PACT processor instances.
 * @param types The available types.
 * @return The type to be used for scheduling.
 */
private InstanceTypeDescription getType(Map<InstanceType,InstanceTypeDescription> types){
  if (types == null || types.size() < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long minMemory=0;
  int minCPUCores=Integer.MAX_VALUE;
  InstanceTypeDescription retValue=null;
  final Iterator<InstanceTypeDescription> it=types.values().iterator();
  while (it.hasNext()) {
    final InstanceTypeDescription descr=it.next();
    if (retValue == null) {
      retValue=descr;
    }
    if (descr.getInstanceType().getNumberOfCores() < minCPUCores && descr.getHardwareDescription().getSizeOfFreeMemory() > minMemory) {
      minCPUCores=descr.getInstanceType().getNumberOfCores();
      minMemory=descr.getHardwareDescription().getSizeOfFreeMemory();
      retValue=descr;
    }
  }
  return retValue;
}","/** 
 * This utility method picks the instance type to be used for scheduling PACT processor instances. <p>
 * @param types The available types.
 * @return The type to be used for scheduling.
 * @throws CompilerException
 * @throws IllegalArgumentException
 */
private InstanceTypeDescription getType(Map<InstanceType,InstanceTypeDescription> types) throws CompilerException {
  if (types == null || types.size() < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InstanceTypeDescription retValue=null;
  long totalMemory=0;
  int numInstances=0;
  final Iterator<InstanceTypeDescription> it=types.values().iterator();
  while (it.hasNext()) {
    final InstanceTypeDescription descr=it.next();
    if (descr.getHardwareDescription() == null || descr.getInstanceType() == null) {
      continue;
    }
    final int curInstances=descr.getMaximumNumberOfAvailableInstances();
    final long curMemory=curInstances * descr.getHardwareDescription().getSizeOfFreeMemory();
    if ((retValue == null) || (curInstances > numInstances && (int)(curMemory * 1.2f) > totalMemory) || (curInstances * retValue.getInstanceType().getNumberOfCores() >= numInstances && (int)(curMemory * 1.5f) > totalMemory)) {
      retValue=descr;
      numInstances=curInstances;
      totalMemory=curMemory;
    }
  }
  if (retValue == null) {
    throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return retValue;
}",0.528857961522718
56170,"@Override public boolean next() throws IOException, InterruptedException {
  KeyValuePair<K,VP> pair=probePairSerialization.newInstance();
  while (currentProbePartitionReader.read(pair)) {
    K key=pair.getKey();
    if (hashMap.contains(key)) {
      currentKey=key;
      currentBuildValuesIterable=hashMap.get(currentKey);
      currentProbeValuesIterable.value=pair.getValue();
      return true;
    }
  }
  if (currentPartition >= numberOfPartitions - 1) {
    return false;
  }
  try {
    currentProbePartitionReader.close();
    currentPartition++;
    LOG.debug(""String_Node_Str"" + currentPartition);
    hashMap.clear();
    currentBuildPartitionReader=ioManager.createChannelReader(buildPartitionIDs.get(currentPartition),freeSegments);
    KeyValuePair<K,VB> tmp=buildPairSerialization.newInstance();
    while (currentBuildPartitionReader.read(tmp)) {
      hashMap.put(tmp.getKey(),tmp.getValue());
      tmp=buildPairSerialization.newInstance();
    }
    currentBuildPartitionReader.close();
    currentProbePartitionReader=ioManager.createChannelReader(probePartitionIDs.get(currentPartition),freeSegments);
    return next();
  }
 catch (  ServiceException e) {
    throw new IOException(e);
  }
catch (  Exception e) {
    throw new IOException(e);
  }
}","@Override public boolean next() throws IOException, InterruptedException {
  KeyValuePair<K,VP> pair=probePairSerialization.newInstance();
  while (currentProbePartitionReader.read(pair)) {
    K key=pair.getKey();
    if (hashMap.contains(key)) {
      currentKey=key;
      currentBuildValuesIterable=hashMap.get(currentKey);
      currentProbeValuesIterable.value=pair.getValue();
      return true;
    }
  }
  if (currentPartition >= numberOfPartitions - 1) {
    return false;
  }
  try {
    currentProbePartitionReader.close();
    currentPartition++;
    LOG.debug(""String_Node_Str"" + currentPartition);
    hashMap.clear();
    currentBuildPartitionReader=ioManager.createChannelReader(buildPartitionIDs.get(currentPartition),freeSegments,false);
    KeyValuePair<K,VB> tmp=buildPairSerialization.newInstance();
    while (currentBuildPartitionReader.read(tmp)) {
      hashMap.put(tmp.getKey(),tmp.getValue());
      tmp=buildPairSerialization.newInstance();
    }
    currentBuildPartitionReader.close();
    currentProbePartitionReader=ioManager.createChannelReader(probePartitionIDs.get(currentPartition),freeSegments,false);
    return next();
  }
 catch (  ServiceException e) {
    throw new IOException(e);
  }
catch (  Exception e) {
    throw new IOException(e);
  }
}",0.9953198127925116
56171,"/** 
 * Repartitions the build side.
 * @throws IOException
 * @throws InterruptedException
 * @throws ServiceException
 */
private void repartitionBuildSide() throws IOException, InterruptedException, ServiceException {
  LOG.debug(""String_Node_Str"");
  KeyValuePair<K,VB> pair=buildPairSerialization.newInstance();
  int partition;
  for (  K key : hashMap.keys()) {
    partition=partitioner.getPartition(key);
    for (    VB value : hashMap.get(key)) {
      partitionWriters.get(partition).write(new KeyValuePair<K,VB>(key,value));
    }
  }
  hashMap.clear();
  ChannelReader partitionZeroReader=ioManager.createChannelReader(buildPartitionIDs.get(0),partitionWriters.get(0).close());
  while (partitionZeroReader.read(pair)) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
  partitionWriters.set(0,ioManager.createChannelWriter(buildPartitionIDs.get(0),partitionZeroReader.close()));
  LOG.debug(""String_Node_Str"");
  pair=overflowCause;
  partition=partitioner.getPartition(pair.getKey());
  if (partition == 0) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
 else {
    partitionWriters.get(partition).write(pair);
  }
  LOG.debug(""String_Node_Str"");
  while (readerBuild.hasNext()) {
    pair=readerBuild.next();
    partition=partitioner.getPartition(pair.getKey());
    if (partition == 0) {
      hashMap.put(pair.getKey(),pair.getValue());
    }
 else {
      partitionWriters.get(partition).write(pair);
    }
  }
}","/** 
 * Repartitions the build side.
 * @throws IOException
 * @throws InterruptedException
 * @throws ServiceException
 */
private void repartitionBuildSide() throws IOException, InterruptedException, ServiceException {
  LOG.debug(""String_Node_Str"");
  KeyValuePair<K,VB> pair=buildPairSerialization.newInstance();
  int partition;
  for (  K key : hashMap.keys()) {
    partition=partitioner.getPartition(key);
    for (    VB value : hashMap.get(key)) {
      partitionWriters.get(partition).write(new KeyValuePair<K,VB>(key,value));
    }
  }
  hashMap.clear();
  ChannelReader partitionZeroReader=ioManager.createChannelReader(buildPartitionIDs.get(0),partitionWriters.get(0).close(),false);
  while (partitionZeroReader.read(pair)) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
  partitionWriters.set(0,ioManager.createChannelWriter(buildPartitionIDs.get(0),partitionZeroReader.close()));
  LOG.debug(""String_Node_Str"");
  pair=overflowCause;
  partition=partitioner.getPartition(pair.getKey());
  if (partition == 0) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
 else {
    partitionWriters.get(partition).write(pair);
  }
  LOG.debug(""String_Node_Str"");
  while (readerBuild.hasNext()) {
    pair=readerBuild.next();
    partition=partitioner.getPartition(pair.getKey());
    if (partition == 0) {
      hashMap.put(pair.getKey(),pair.getValue());
    }
 else {
      partitionWriters.get(partition).write(pair);
    }
  }
}",0.9979267449896336
56172,"@Override public void initialize() throws ServiceException, IOException, InterruptedException {
  LOG.debug(""String_Node_Str"");
  numberOfPartitions=freeSegments.size() / 2;
  partitioner=new Partitioner(numberOfPartitions);
  partitionWriters=new ArrayList<ChannelWriter>(numberOfPartitions);
  buildPartitionIDs=new ArrayList<Channel.ID>(numberOfPartitions);
  probePartitionIDs=new ArrayList<Channel.ID>(numberOfPartitions);
  LOG.debug(""String_Node_Str"" + numberOfPartitions + ""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  Channel.Enumerator buildEnumerator=ioManager.createChannelEnumerator();
  allocatePartitionWriters(buildEnumerator,buildPartitionIDs);
  repartitionBuildSide();
  closePartitionWriters();
  LOG.debug(""String_Node_Str"");
  Channel.Enumerator probeEnumerator=ioManager.createChannelEnumerator();
  allocatePartitionWriters(probeEnumerator,probePartitionIDs);
  repartitionProbeSide();
  closePartitionWriters();
  currentPartition=0;
  currentBuildPartitionReader=ioManager.createChannelReader(buildPartitionIDs.get(currentPartition),freeSegments);
  KeyValuePair<K,VB> pair=buildPairSerialization.newInstance();
  while (currentBuildPartitionReader.read(pair)) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
  currentBuildPartitionReader.close();
  currentProbePartitionReader=ioManager.createChannelReader(probePartitionIDs.get(currentPartition),freeSegments);
}","@Override public void initialize() throws ServiceException, IOException, InterruptedException {
  LOG.debug(""String_Node_Str"");
  numberOfPartitions=freeSegments.size() / 2;
  partitioner=new Partitioner(numberOfPartitions);
  partitionWriters=new ArrayList<ChannelWriter>(numberOfPartitions);
  buildPartitionIDs=new ArrayList<Channel.ID>(numberOfPartitions);
  probePartitionIDs=new ArrayList<Channel.ID>(numberOfPartitions);
  LOG.debug(""String_Node_Str"" + numberOfPartitions + ""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  Channel.Enumerator buildEnumerator=ioManager.createChannelEnumerator();
  allocatePartitionWriters(buildEnumerator,buildPartitionIDs);
  repartitionBuildSide();
  closePartitionWriters();
  LOG.debug(""String_Node_Str"");
  Channel.Enumerator probeEnumerator=ioManager.createChannelEnumerator();
  allocatePartitionWriters(probeEnumerator,probePartitionIDs);
  repartitionProbeSide();
  closePartitionWriters();
  currentPartition=0;
  currentBuildPartitionReader=ioManager.createChannelReader(buildPartitionIDs.get(currentPartition),freeSegments,false);
  KeyValuePair<K,VB> pair=buildPairSerialization.newInstance();
  while (currentBuildPartitionReader.read(pair)) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
  currentBuildPartitionReader.close();
  currentProbePartitionReader=ioManager.createChannelReader(probePartitionIDs.get(currentPartition),freeSegments,false);
}",0.9957446808510638
56173,"public void reset(){
  try {
    next=null;
    if (fitsIntoMem) {
      if (currentBuffer != usedBuffers)       inputBuffers.get(currentBuffer).reset();
      currentBuffer=0;
    }
 else {
      ioReader.close();
      ioReader=ioManager.createChannelReader(bufferID,memorySegments);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  count=0;
}","public void reset(){
  try {
    next=null;
    if (fitsIntoMem) {
      if (currentBuffer != usedBuffers)       inputBuffers.get(currentBuffer).reset();
      currentBuffer=0;
    }
 else {
      ioReader.close();
      ioReader=ioManager.createChannelReader(bufferID,memorySegments,false);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  count=0;
}",0.9931350114416476
56174,"/** 
 * Open the iterator. This will serialize the complete content of the specified Reader<T> into a file and initialize the ResettableIterator to this File.
 * @throws ServiceException
 * @throws InterruptedException
 * @throws IOException
 */
public void open() throws ServiceException, IOException, InterruptedException {
  fitsIntoMem=true;
  ArrayList<Buffer.Output> outputBuffers=new ArrayList<Buffer.Output>(nrOfBuffers);
  for (  MemorySegment segment : memorySegments) {
    Buffer.Output out=new Buffer.Output();
    out.bind(segment);
    outputBuffers.add(out);
  }
  while (recordReader.hasNext()) {
    next=recordReader.next();
    count++;
    if (!outputBuffers.get(currentBuffer).write(next)) {
      currentBuffer++;
      if (currentBuffer == nrOfBuffers) {
        fitsIntoMem=false;
        break;
      }
      outputBuffers.get(currentBuffer).write(next);
    }
  }
  if (!fitsIntoMem) {
    bufferID=this.ioManager.createChannel();
    ChannelWriter writer=ioManager.createChannelWriter(bufferID,outputBuffers,true);
    writer.write(next);
    while (recordReader.hasNext()) {
      count++;
      writer.write(recordReader.next());
    }
    writer.close();
    ioReader=ioManager.createChannelReader(bufferID,memorySegments);
    LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  }
 else {
    usedBuffers=currentBuffer + 1;
    inputBuffers=new ArrayList<Buffer.Input>(nrOfBuffers);
    for (    Buffer.Output out : outputBuffers) {
      int offset=out.getPosition();
      MemorySegment segment=out.unbind();
      Buffer.Input in=new Buffer.Input();
      in.bind(segment);
      in.reset(offset);
      inputBuffers.add(in);
    }
    currentBuffer=0;
    LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  }
  count=0;
  next=null;
}","/** 
 * Open the iterator. This will serialize the complete content of the specified Reader<T> into a file and initialize the ResettableIterator to this File.
 * @throws ServiceException
 * @throws InterruptedException
 * @throws IOException
 */
public void open() throws ServiceException, IOException, InterruptedException {
  fitsIntoMem=true;
  ArrayList<Buffer.Output> outputBuffers=new ArrayList<Buffer.Output>(nrOfBuffers);
  for (  MemorySegment segment : memorySegments) {
    Buffer.Output out=new Buffer.Output();
    out.bind(segment);
    outputBuffers.add(out);
  }
  while (recordReader.hasNext()) {
    next=recordReader.next();
    count++;
    if (!outputBuffers.get(currentBuffer).write(next)) {
      currentBuffer++;
      if (currentBuffer == nrOfBuffers) {
        fitsIntoMem=false;
        break;
      }
      outputBuffers.get(currentBuffer).write(next);
    }
  }
  if (!fitsIntoMem) {
    bufferID=this.ioManager.createChannel();
    ChannelWriter writer=ioManager.createChannelWriter(bufferID,outputBuffers,true);
    writer.write(next);
    while (recordReader.hasNext()) {
      count++;
      writer.write(recordReader.next());
    }
    writer.close();
    ioReader=ioManager.createChannelReader(bufferID,memorySegments,false);
    LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  }
 else {
    usedBuffers=currentBuffer + 1;
    inputBuffers=new ArrayList<Buffer.Input>(nrOfBuffers);
    for (    Buffer.Output out : outputBuffers) {
      int offset=out.getPosition();
      MemorySegment segment=out.unbind();
      Buffer.Input in=new Buffer.Input();
      in.bind(segment);
      in.reset(offset);
      inputBuffers.add(in);
    }
    currentBuffer=0;
    LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  }
  count=0;
  next=null;
}",0.9983240223463687
56175,"/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortable<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  if (CombiningUnilateralSortMerger.this.combineLastMerge) {
    KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(getMergingIterator(channelIDs,ioMemorySize));
    lazyIterator.setTarget(new CombiningIterator<K,V>(combineStub,iter));
  }
 else {
    lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortable<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  if (CombiningUnilateralSortMerger.this.combineLastMerge) {
    KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(getMergingIterator(channelIDs,ioMemorySize));
    setResultIterator(new CombiningIterator<K,V>(combineStub,iter));
  }
 else {
    setResultIterator(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}",0.98967684021544
56176,"/** 
 * @param channelIDs
 * @param ioMemorySize
 * @return The ID of the channel that holds the merged data of all input channels.
 */
protected Channel.ID mergeChannels(List<Channel.ID> channelIDs,int ioMemorySize) throws IOException, MemoryAllocationException {
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>(channelIDs.size());
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
    freeSegmentsAtShutdown(inputSegments);
    final ChannelReader reader=ioManager.createChannelReader(id,inputSegments);
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  KeyGroupedIterator<K,V> groupedIter=new KeyGroupedIterator<K,V>(mi);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
  freeSegmentsAtShutdown(outputSegments);
  ChannelWriter writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  WriterCollector<K,V> collector=new WriterCollector<K,V>(writer);
  while (groupedIter.nextKey()) {
    this.combineStub.combine(groupedIter.getKey(),groupedIter.getValues(),collector);
  }
  outputSegments=writer.close();
  memoryManager.release(outputSegments);
  return mergedChannelID;
}","/** 
 * @param channelIDs
 * @param ioMemorySize
 * @return The ID of the channel that holds the merged data of all input channels.
 */
protected Channel.ID mergeChannels(List<Channel.ID> channelIDs,int ioMemorySize) throws IOException, MemoryAllocationException {
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>(channelIDs.size());
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
    freeSegmentsAtShutdown(inputSegments);
    final ChannelReader reader=ioManager.createChannelReader(id,inputSegments,true);
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  KeyGroupedIterator<K,V> groupedIter=new KeyGroupedIterator<K,V>(mi);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
  freeSegmentsAtShutdown(outputSegments);
  ChannelWriter writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  WriterCollector<K,V> collector=new WriterCollector<K,V>(writer);
  while (groupedIter.nextKey()) {
    this.combineStub.combine(groupedIter.getKey(),groupedIter.getValues(),collector);
  }
  outputSegments=writer.close();
  memoryManager.release(outputSegments);
  return mergedChannelID;
}",0.9984601170311056
56177,"/** 
 * Assigns the execution vertex with an   {@link AllocatedResource}.
 * @param allocatedResource the resources which are supposed to be allocated to this vertex
 */
public synchronized void setAllocatedResource(AllocatedResource allocatedResource){
  this.allocatedResource=allocatedResource;
}","/** 
 * Assigns the execution vertex with an   {@link AllocatedResource}.
 * @param allocatedResource the resources which are supposed to be allocated to this vertex
 */
public synchronized void setAllocatedResource(AllocatedResource allocatedResource){
  this.allocatedResource=allocatedResource;
  final Iterator<VertexAssignmentListener> it=this.vertexAssignmentListeners.iterator();
  while (it.hasNext()) {
    it.next().vertexAssignmentChanged(this.vertexID,this.allocatedResource);
  }
}",0.7540983606557377
56178,"/** 
 * Registers a job in form of its execution graph representation with the job progress collector. The collector will subscribe to state changes of the individual subtasks. A separate deregistration is not necessary since the job progress collector periodically discards outdated progress information.
 * @param executionGraph the execution graph representing the job
 * @param profilingAvailable indicates if profiling data is available for this job
 */
public void registerJob(ExecutionGraph executionGraph,boolean profilingAvailable){
  final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(executionGraph,true);
  while (it.hasNext()) {
    final ExecutionVertex vertex=it.next();
    vertex.getEnvironment().registerExecutionListener(new ExecutionListenerWrapper(this,vertex.getGroupVertex().getJobVertexID(),vertex.getID()));
  }
  executionGraph.registerJobStatusListener(new JobStatusListenerWrapper(this,executionGraph.getJobName(),profilingAvailable));
}","/** 
 * Registers a job in form of its execution graph representation with the job progress collector. The collector will subscribe to state changes of the individual subtasks. A separate deregistration is not necessary since the job progress collector periodically discards outdated progress information.
 * @param executionGraph the execution graph representing the job
 * @param profilingAvailable indicates if profiling data is available for this job
 */
public void registerJob(ExecutionGraph executionGraph,boolean profilingAvailable){
  final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(executionGraph,true);
  while (it.hasNext()) {
    final ExecutionVertex vertex=it.next();
    vertex.getEnvironment().registerExecutionListener(new ExecutionListenerWrapper(this,vertex.getGroupVertex().getJobVertexID(),vertex.getID()));
    vertex.registerVertexAssignmentListener(new VertexAssignmentListenerWrapper(this,executionGraph.getJobID()));
  }
  executionGraph.registerJobStatusListener(new JobStatusListenerWrapper(this,executionGraph.getJobName(),profilingAvailable));
}",0.9448209099709584
56179,"@Override public void processProfilingEvents(ProfilingEvent profilingEvent){
  addEvent(profilingEvent.getJobID(),profilingEvent);
}","/** 
 * {@inheritDoc}
 */
@Override public void processProfilingEvents(ProfilingEvent profilingEvent){
  addEvent(profilingEvent.getJobID(),profilingEvent);
}",0.9103448275862068
56180,"public void updateView(){
  if (this.threadChart != null) {
    this.threadChart.getChart().getXYPlot().configureDomainAxes();
    this.threadChart.getChart().fireChartChanged();
  }
  this.executionStateLabel.setText(this.managementVertex.getExecutionState().toString());
  final ManagementGroupVertex groupVertex=this.managementVertex.getGroupVertex();
  final GroupVertexVisualizationData groupVertexVisualizationData=(GroupVertexVisualizationData)groupVertex.getAttachment();
  if (groupVertexVisualizationData.isCPUBottleneck()) {
    if (this.warningComposite == null) {
      this.warningComposite=createWarningComposite(WARNINGTEXT,SWT.ICON_WARNING);
      Rectangle clientRect=getShell().getClientArea();
      clientRect.height+=ICONSIZE;
      getShell().setSize(clientRect.width,clientRect.height);
    }
  }
 else {
    if (this.warningComposite != null) {
      this.warningComposite.dispose();
      this.warningComposite=null;
      Rectangle clientRect=getShell().getClientArea();
      clientRect.height-=ICONSIZE;
      getShell().setSize(clientRect.width,clientRect.height);
    }
  }
}","public void updateView(){
  if (this.threadChart != null) {
    this.threadChart.getChart().getXYPlot().configureDomainAxes();
    this.threadChart.getChart().fireChartChanged();
  }
  this.executionStateLabel.setText(this.managementVertex.getExecutionState().toString());
  this.instanceIDLabel.setText(this.managementVertex.getInstanceName());
  this.instanceTypeLabel.setText(this.managementVertex.getInstanceType());
  final ManagementGroupVertex groupVertex=this.managementVertex.getGroupVertex();
  final GroupVertexVisualizationData groupVertexVisualizationData=(GroupVertexVisualizationData)groupVertex.getAttachment();
  if (groupVertexVisualizationData.isCPUBottleneck()) {
    if (this.warningComposite == null) {
      this.warningComposite=createWarningComposite(WARNINGTEXT,SWT.ICON_WARNING);
      Rectangle clientRect=getShell().getClientArea();
      clientRect.height+=ICONSIZE;
      getShell().setSize(clientRect.width,clientRect.height);
    }
  }
 else {
    if (this.warningComposite != null) {
      this.warningComposite.dispose();
      this.warningComposite=null;
      Rectangle clientRect=getShell().getClientArea();
      clientRect.height-=ICONSIZE;
      getShell().setSize(clientRect.width,clientRect.height);
    }
  }
}",0.9372881355932204
56181,"private void dispatchEvent(AbstractEvent event,GraphVisualizationData graphVisualizationData){
  if (event instanceof VertexProfilingEvent) {
    final VertexProfilingEvent vertexProfilingEvent=(VertexProfilingEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(vertexProfilingEvent.getVertexID());
    if (vertexProfilingEvent instanceof ThreadProfilingEvent) {
      final VertexVisualizationData vertexVisualizationData=(VertexVisualizationData)vertex.getAttachment();
      vertexVisualizationData.processThreadProfilingEvent((ThreadProfilingEvent)vertexProfilingEvent);
    }
 else     if (vertexProfilingEvent instanceof OutputGateProfilingEvent) {
      final OutputGateProfilingEvent outputGateProfilingEvent=(OutputGateProfilingEvent)vertexProfilingEvent;
      final ManagementGate managementGate=vertex.getOutputGate(outputGateProfilingEvent.getGateIndex());
      final GateVisualizationData gateVisualizationData=(GateVisualizationData)managementGate.getAttachment();
      gateVisualizationData.processOutputGateProfilingEvent(outputGateProfilingEvent);
    }
 else     if (vertexProfilingEvent instanceof InputGateProfilingEvent) {
      final InputGateProfilingEvent inputGateProfilingEvent=(InputGateProfilingEvent)vertexProfilingEvent;
      final ManagementGate managementGate=vertex.getInputGate(inputGateProfilingEvent.getGateIndex());
      final GateVisualizationData gateVisualizationData=(GateVisualizationData)managementGate.getAttachment();
      gateVisualizationData.processInputGateProfilingEvent(inputGateProfilingEvent);
    }
  }
 else   if (event instanceof InstanceProfilingEvent) {
    final NetworkTopology networkTopology=graphVisualizationData.getNetworkTopology();
    if (event instanceof InstanceSummaryProfilingEvent) {
      final InstanceVisualizationData instanceVisualizationData=(InstanceVisualizationData)networkTopology.getAttachment();
      instanceVisualizationData.processInstanceProfilingEvent((InstanceSummaryProfilingEvent)event);
    }
 else {
      final SingleInstanceProfilingEvent singleInstanceProfilingEvent=(SingleInstanceProfilingEvent)event;
      final NetworkNode networkNode=networkTopology.getNodeByName(singleInstanceProfilingEvent.getInstanceName());
      final InstanceVisualizationData instanceVisualizationData=(InstanceVisualizationData)networkNode.getAttachment();
      instanceVisualizationData.processInstanceProfilingEvent(singleInstanceProfilingEvent);
    }
  }
 else   if (event instanceof ExecutionStateChangeEvent) {
    final ExecutionStateChangeEvent executionStateChangeEvent=(ExecutionStateChangeEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(executionStateChangeEvent.getVertexID());
    vertex.setExecutionState(executionStateChangeEvent.getNewExecutionState());
  }
 else {
    System.out.println(""String_Node_Str"" + event);
  }
}","private void dispatchEvent(AbstractEvent event,GraphVisualizationData graphVisualizationData){
  if (event instanceof VertexProfilingEvent) {
    final VertexProfilingEvent vertexProfilingEvent=(VertexProfilingEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(vertexProfilingEvent.getVertexID());
    if (vertexProfilingEvent instanceof ThreadProfilingEvent) {
      final VertexVisualizationData vertexVisualizationData=(VertexVisualizationData)vertex.getAttachment();
      vertexVisualizationData.processThreadProfilingEvent((ThreadProfilingEvent)vertexProfilingEvent);
    }
 else     if (vertexProfilingEvent instanceof OutputGateProfilingEvent) {
      final OutputGateProfilingEvent outputGateProfilingEvent=(OutputGateProfilingEvent)vertexProfilingEvent;
      final ManagementGate managementGate=vertex.getOutputGate(outputGateProfilingEvent.getGateIndex());
      final GateVisualizationData gateVisualizationData=(GateVisualizationData)managementGate.getAttachment();
      gateVisualizationData.processOutputGateProfilingEvent(outputGateProfilingEvent);
    }
 else     if (vertexProfilingEvent instanceof InputGateProfilingEvent) {
      final InputGateProfilingEvent inputGateProfilingEvent=(InputGateProfilingEvent)vertexProfilingEvent;
      final ManagementGate managementGate=vertex.getInputGate(inputGateProfilingEvent.getGateIndex());
      final GateVisualizationData gateVisualizationData=(GateVisualizationData)managementGate.getAttachment();
      gateVisualizationData.processInputGateProfilingEvent(inputGateProfilingEvent);
    }
  }
 else   if (event instanceof InstanceProfilingEvent) {
    final NetworkTopology networkTopology=graphVisualizationData.getNetworkTopology();
    if (event instanceof InstanceSummaryProfilingEvent) {
      final InstanceVisualizationData instanceVisualizationData=(InstanceVisualizationData)networkTopology.getAttachment();
      instanceVisualizationData.processInstanceProfilingEvent((InstanceSummaryProfilingEvent)event);
    }
 else {
      final SingleInstanceProfilingEvent singleInstanceProfilingEvent=(SingleInstanceProfilingEvent)event;
      final NetworkNode networkNode=networkTopology.getNodeByName(singleInstanceProfilingEvent.getInstanceName());
      final InstanceVisualizationData instanceVisualizationData=(InstanceVisualizationData)networkNode.getAttachment();
      instanceVisualizationData.processInstanceProfilingEvent(singleInstanceProfilingEvent);
    }
  }
 else   if (event instanceof ExecutionStateChangeEvent) {
    final ExecutionStateChangeEvent executionStateChangeEvent=(ExecutionStateChangeEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(executionStateChangeEvent.getVertexID());
    vertex.setExecutionState(executionStateChangeEvent.getNewExecutionState());
  }
 else   if (event instanceof VertexAssignmentEvent) {
    final VertexAssignmentEvent vertexAssignmentEvent=(VertexAssignmentEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(vertexAssignmentEvent.getVertexID());
    vertex.setInstanceName(vertexAssignmentEvent.getInstanceName());
    vertex.setInstanceType(vertexAssignmentEvent.getInstanceType());
  }
 else {
    System.out.println(""String_Node_Str"" + event);
  }
}",0.9306777829241932
56182,"/** 
 * Initializes the output collector with a set of writers.  To specify for a writer that it must be fed with a deep-copy, set the bit in the copy flag bit mask to 1 that  corresponds to the position of the writer within the   {@link List}.
 * @param writers List of all writers.
 * @param fwdCopyFlags Bit mask that specifies which writer is fed with deep-copies.
 */
public OutputCollector(List<RecordWriter<KeyValuePair<K,V>>> writers,int fwdCopyFlags){
  this.writers=writers;
  this.fwdCopyFlags=fwdCopyFlags;
  this.copier=new SerializationCopier<KeyValuePair<K,V>>();
}","/** 
 * Initializes the output collector with a set of writers.  To specify for a writer that it must be fed with a deep-copy, set the bit in the copy flag bit mask to 1 that  corresponds to the position of the writer within the   {@link List}.
 * @param writers List of all writers.
 * @param fwdCopyFlags Bit mask that specifies which writer is fed with deep-copies.
 */
public OutputCollector(List<RecordWriter<KeyValuePair<K,V>>> writers,int fwdCopyFlags){
  this.writers=writers;
  this.fwdCopyFlags=fwdCopyFlags;
  this.kvpCopier=new SerializationCopier<KeyValuePair<K,V>>();
}",0.9957007738607052
56183,"/** 
 * Collects a   {@link Key} and {@link Value}, wraps them in a KeyValuePair, and emit them to all writers. Writers which require a deep-copy are fed with a copy obtained through de/serialization.
 */
@Override public void collect(K key,V value){
  try {
    final KeyValuePair<K,V> emitPair=new KeyValuePair<K,V>(key,value);
    if (fwdCopyFlags == 0) {
      for (int i=0; i < writers.size(); i++) {
        writers.get(i).emit(emitPair);
      }
    }
 else {
      copier.setCopy(emitPair);
      for (int i=0; i < writers.size(); i++) {
        if (((fwdCopyFlags >> i) & 0x1) != 0) {
          copier.getCopy(emitPair);
        }
        writers.get(i).emit(emitPair);
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Collects a   {@link Key} and {@link Value}, wraps them in a KeyValuePair, and emit them to all writers. Writers which require a deep-copy are fed with a copy obtained through de/serialization.
 */
@Override public void collect(K key,V value){
  try {
    KeyValuePair<K,V> emitPair=new KeyValuePair<K,V>(key,value);
    if (fwdCopyFlags == 0) {
      for (int i=0; i < writers.size(); i++) {
        writers.get(i).emit(emitPair);
      }
    }
 else {
      if (kvpSerialization == null) {
        this.kvpSerialization=new KeyValuePairSerializationFactory<K,V>(new WritableSerializationFactory<K>((Class<K>)key.getClass()),new WritableSerializationFactory<V>((Class<V>)value.getClass()));
      }
      kvpCopier.setCopy(emitPair);
      for (int i=0; i < writers.size(); i++) {
        if (((fwdCopyFlags >> i) & 0x1) != 0) {
          emitPair=kvpSerialization.newInstance();
          kvpCopier.getCopy(emitPair);
        }
        writers.get(i).emit(emitPair);
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}",0.8413583375570197
56184,"protected JobGraph getJobGraph() throws Exception {
  JobGraph jobGraph=new JobGraph(""String_Node_Str"");
  JobFileInputVertex input=new JobFileInputVertex(""String_Node_Str"",jobGraph);
  input.setFileInputClass(FileLineReader.class);
  input.setFilePath(new Path(hdfs.getTempDirPath() + ""String_Node_Str""));
  JobTaskVertex task=new JobTaskVertex(""String_Node_Str"",jobGraph);
  task.setTaskClass(GrepTask.class);
  JobFileOutputVertex output=new JobFileOutputVertex(""String_Node_Str"",jobGraph);
  output.setFileOutputClass(FileLineWriter.class);
  output.setFilePath(new Path(hdfs.getTempDirPath() + ""String_Node_Str""));
  input.connectTo(task,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  task.connectTo(output,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  return jobGraph;
}","protected JobGraph getJobGraph() throws Exception {
  JobGraph jobGraph=new JobGraph(""String_Node_Str"");
  JobFileInputVertex input=new JobFileInputVertex(""String_Node_Str"",jobGraph);
  input.setFileInputClass(FileLineReader.class);
  input.setFilePath(new Path(hdfs.getURIPrefix() + hdfs.getTempDirPath() + ""String_Node_Str""));
  JobTaskVertex task=new JobTaskVertex(""String_Node_Str"",jobGraph);
  task.setTaskClass(GrepTask.class);
  JobFileOutputVertex output=new JobFileOutputVertex(""String_Node_Str"",jobGraph);
  output.setFileOutputClass(FileLineWriter.class);
  output.setFilePath(new Path(hdfs.getURIPrefix() + hdfs.getTempDirPath() + ""String_Node_Str""));
  input.connectTo(task,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  task.connectTo(output,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  return jobGraph;
}",0.9731379731379732
56185,"protected void preSubmit() throws Exception {
  OutputStream os=hdfs.getOutputStream(""String_Node_Str"");
  Writer wr=new OutputStreamWriter(os);
  wr.write(""String_Node_Str"");
  wr.write(""String_Node_Str"");
  wr.write(""String_Node_Str"");
  wr.close();
}","protected void preSubmit() throws Exception {
  OutputStream os=hdfs.getOutputStream(hdfs.getTempDirPath() + ""String_Node_Str"");
  Writer wr=new OutputStreamWriter(os);
  wr.write(""String_Node_Str"");
  wr.write(""String_Node_Str"");
  wr.write(""String_Node_Str"");
  wr.close();
}",0.9547169811320756
56186,"/** 
 * Initializes the stub implementation and configuration.
 * @throws RuntimeException Thrown if instance of stub implementation can not be obtained.
 */
private void initStub(){
  config=new TaskConfig(getRuntimeConfiguration());
  NUM_SORT_BUFFERS=config.getNumSortBuffer();
  SIZE_SORT_BUFFER=config.getSortBufferSize() * 1024 * 1024;
  MEMORY_IO=config.getIOBufferSize() * 1024 * 1024;
  MAX_NUM_FILEHANLDES=config.getMergeFactor();
  try {
    ClassLoader cl=LibraryCacheManager.getClassLoader(getEnvironment().getJobID());
    Class<? extends MatchStub> matchClass=config.getStubClass(MatchStub.class,cl);
    matchStub=matchClass.newInstance();
    matchStub.configure(config.getStubParameters());
  }
 catch (  IOException ioe) {
    throw new RuntimeException(""String_Node_Str"",ioe);
  }
catch (  ClassNotFoundException cnfe) {
    throw new RuntimeException(""String_Node_Str"",cnfe);
  }
catch (  InstantiationException ie) {
    throw new RuntimeException(""String_Node_Str"",ie);
  }
catch (  IllegalAccessException iae) {
    throw new RuntimeException(""String_Node_Str"",iae);
  }
}","/** 
 * Initializes the stub implementation and configuration.
 * @throws RuntimeException Thrown if instance of stub implementation can not be obtained.
 */
private void initStub(){
  config=new TaskConfig(getRuntimeConfiguration());
  NUM_SORT_BUFFERS=config.getNumSortBuffer();
  SIZE_SORT_BUFFER=config.getSortBufferSize() * 1024 * 1024;
  MEMORY_IO=config.getIOBufferSize() * 1024 * 1024;
  MAX_NUM_FILEHANLDES=config.getMergeFactor();
  try {
    ClassLoader cl=LibraryCacheManager.getClassLoader(getEnvironment().getJobID());
    Class<? extends MatchStub> matchClass=config.getStubClass(MatchStub.class,cl);
    matchStub=matchClass.newInstance();
    matchStub.configure(config.getStubParameters());
    this.keySerialization=new WritableSerializationFactory<Key>(matchStub.getFirstInKeyType());
    this.v1Serialization=new WritableSerializationFactory<Value>(matchStub.getFirstInValueType());
    this.v2Serialization=new WritableSerializationFactory<Value>(matchStub.getSecondInValueType());
  }
 catch (  IOException ioe) {
    throw new RuntimeException(""String_Node_Str"",ioe);
  }
catch (  ClassNotFoundException cnfe) {
    throw new RuntimeException(""String_Node_Str"",cnfe);
  }
catch (  InstantiationException ie) {
    throw new RuntimeException(""String_Node_Str"",ie);
  }
catch (  IllegalAccessException iae) {
    throw new RuntimeException(""String_Node_Str"",iae);
  }
}",0.881383192601528
56187,"/** 
 * <p> Calls the <code>MatchStub#match()</code> method for all two key-value pairs that share the same key and come from different inputs. The output of the <code>match()</code> method is forwarded. <p> This method is called with a key and two iterator (one for each input) over all values that share this key. <p>
 * @param key A key.
 * @param values1 An iterator on values of the first input that were paired with the key.
 * @param values2 An iterator on values of the second input that were paired with the key.
 * @param out A collector that collects all output pairs.
 */
private void crossValues(Key key,final Iterator<Value> values1,final Iterator<Value> values2) throws RuntimeException {
  final Value firstV1=values1.next();
  final Value firstV2=values2.next();
  if (firstV1 == null || firstV2 == null) {
    return;
  }
  boolean v1HasNext=values1.hasNext();
  boolean v2HasNext=values2.hasNext();
  if (!v1HasNext && !v2HasNext) {
    matchStub.match(key,firstV1,firstV2,output);
    return;
  }
  Value v1;
  Value v2;
  final SerializationFactory<Key> keySerialization=new WritableSerializationFactory<Key>(matchStub.getFirstInKeyType());
  final SerializationCopier<Key> keyCopier=new SerializationCopier<Key>();
  keyCopier.setCopy(key);
  if (!v1HasNext) {
    final SerializationFactory<Value> v1Serialization=new WritableSerializationFactory<Value>(matchStub.getFirstInValueType());
    final SerializationCopier<Value> v1Copier=new SerializationCopier<Value>();
    v1Copier.setCopy(firstV1);
    matchStub.match(key,firstV1,firstV2,output);
    while (v2HasNext) {
      key=keySerialization.newInstance();
      keyCopier.getCopy(key);
      v1=v1Serialization.newInstance();
      v1Copier.getCopy(v1);
      v2=values2.next();
      v2HasNext=values2.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else   if (!v2HasNext) {
    final SerializationFactory<Value> v2Serialization=new WritableSerializationFactory<Value>(matchStub.getSecondInValueType());
    final SerializationCopier<Value> v2Copier=new SerializationCopier<Value>();
    v2Copier.setCopy(firstV2);
    matchStub.match(key,firstV1,firstV2,output);
    while (v1HasNext) {
      key=keySerialization.newInstance();
      keyCopier.getCopy(key);
      v2=v2Serialization.newInstance();
      v2Copier.getCopy(v2);
      v1=values1.next();
      v1HasNext=values1.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else {
    Reader<Value> v1Reader=new Reader<Value>(){
      boolean firstValue=true;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (firstValue)         return true;
        return values1.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return firstV1;
        }
        return values1.next();
      }
    }
;
    final SpillingResettableIterator<Value> v1ResettableIterator;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(matchStub.getFirstInValueType());
      v1ResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),v1Reader,((int)(MEMORY_IO * MEMORY_SHARE_RATIO)),v1Deserializer);
      v1ResettableIterator.open();
      final SerializationFactory<Value> v2Serialization=new WritableSerializationFactory<Value>(matchStub.getSecondInValueType());
      final SerializationCopier<Value> v2Copier=new SerializationCopier<Value>();
      v2Copier.setCopy(firstV2);
      while (v1ResettableIterator.hasNext()) {
        key=keySerialization.newInstance();
        keyCopier.getCopy(key);
        v2=v2Serialization.newInstance();
        v2Copier.getCopy(v2);
        v1=v1ResettableIterator.next();
        matchStub.match(key,v1,v2,output);
      }
      v1ResettableIterator.reset();
      while (values2.hasNext()) {
        v2=values2.next();
        v2Copier.setCopy(v2);
        while (v1ResettableIterator.hasNext()) {
          key=keySerialization.newInstance();
          keyCopier.getCopy(key);
          v2=v2Serialization.newInstance();
          v2Copier.getCopy(v2);
          v1=v1ResettableIterator.next();
          matchStub.match(key,v1,v2,output);
        }
        v1ResettableIterator.reset();
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}","/** 
 * <p> Calls the <code>MatchStub#match()</code> method for all two key-value pairs that share the same key and come from different inputs. The output of the <code>match()</code> method is forwarded. <p> This method is called with a key and two iterator (one for each input) over all values that share this key. <p>
 * @param key A key.
 * @param values1 An iterator on values of the first input that were paired with the key.
 * @param values2 An iterator on values of the second input that were paired with the key.
 * @param out A collector that collects all output pairs.
 */
private void crossValues(Key key,final Iterator<Value> values1,final Iterator<Value> values2) throws RuntimeException {
  final Value firstV1=values1.next();
  final Value firstV2=values2.next();
  if (firstV1 == null || firstV2 == null) {
    return;
  }
  boolean v1HasNext=values1.hasNext();
  boolean v2HasNext=values2.hasNext();
  if (!v1HasNext && !v2HasNext) {
    matchStub.match(key,firstV1,firstV2,output);
    return;
  }
  Value v1;
  Value v2;
  keyCopier.setCopy(key);
  if (!v1HasNext) {
    this.v1Copier.setCopy(firstV1);
    matchStub.match(key,firstV1,firstV2,output);
    while (v2HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v1=this.v1Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      v2=values2.next();
      v2HasNext=values2.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else   if (!v2HasNext) {
    this.v2Copier.setCopy(firstV2);
    matchStub.match(key,firstV1,firstV2,output);
    while (v1HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v2=this.v2Serialization.newInstance();
      this.v2Copier.getCopy(v2);
      v1=values1.next();
      v1HasNext=values1.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else {
    Reader<Value> v1Reader=new Reader<Value>(){
      boolean firstValue=true;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (firstValue)         return true;
        return values1.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return firstV1;
        }
        return values1.next();
      }
    }
;
    final SpillingResettableIterator<Value> v1ResettableIterator;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(matchStub.getFirstInValueType());
      v1ResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),v1Reader,((int)(MEMORY_IO * MEMORY_SHARE_RATIO)),v1Deserializer);
      v1ResettableIterator.open();
      this.v2Copier.setCopy(firstV2);
      while (v1ResettableIterator.hasNext()) {
        key=this.keySerialization.newInstance();
        this.keyCopier.getCopy(key);
        v2=this.v2Serialization.newInstance();
        this.v2Copier.getCopy(v2);
        v1=v1ResettableIterator.next();
        matchStub.match(key,v1,v2,output);
      }
      v1ResettableIterator.reset();
      while (values2.hasNext()) {
        v2=values2.next();
        this.v2Copier.setCopy(v2);
        while (v1ResettableIterator.hasNext()) {
          key=this.keySerialization.newInstance();
          this.keyCopier.getCopy(key);
          v2=this.v2Serialization.newInstance();
          this.v2Copier.getCopy(v2);
          v1=v1ResettableIterator.next();
          matchStub.match(key,v1,v2,output);
        }
        v1ResettableIterator.reset();
      }
      v1ResettableIterator.close();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}",0.8019683149303889
56188,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  this.instanceListener.resourceAllocated(this.allocatedSlice.getJobID(),new AllocatedResource(this.allocatedSlice.getHostingInstance(),this.allocatedSlice.getAllocationID()));
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  this.instanceListener.resourceAllocated(this.allocatedSlice.getJobID(),new AllocatedResource(this.allocatedSlice.getHostingInstance(),this.allocatedSlice.getType(),this.allocatedSlice.getAllocationID()));
}",0.939516129032258
56189,"@Override public synchronized void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  for (  ClusterInstance host : registeredHosts.values()) {
    final AllocatedSlice slice=host.createSlice(instanceType,jobID);
    if (slice != null) {
      List<AllocatedSlice> allocatedSlices=this.slicesOfJobs.get(jobID);
      if (allocatedSlices == null) {
        allocatedSlices=new ArrayList<AllocatedSlice>();
        this.slicesOfJobs.put(jobID,allocatedSlices);
      }
      allocatedSlices.add(slice);
      if (this.instanceListener != null) {
        ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,slice);
        clusterInstanceNotifier.start();
      }
      return;
    }
  }
  throw new InstanceException(""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public synchronized void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  for (  ClusterInstance host : registeredHosts.values()) {
    final AllocatedSlice slice=host.createSlice(instanceType,jobID);
    if (slice != null) {
      List<AllocatedSlice> allocatedSlices=this.slicesOfJobs.get(jobID);
      if (allocatedSlices == null) {
        allocatedSlices=new ArrayList<AllocatedSlice>();
        this.slicesOfJobs.put(jobID,allocatedSlices);
      }
      allocatedSlices.add(slice);
      if (this.instanceListener != null) {
        ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,slice);
        clusterInstanceNotifier.start();
      }
      return;
    }
  }
  throw new InstanceException(""String_Node_Str"");
}",0.9846517119244392
56190,"@Override public void run(){
synchronized (ClusterManager.this) {
    final List<Map.Entry<InstanceConnectionInfo,ClusterInstance>> hostsToRemove=new ArrayList<Map.Entry<InstanceConnectionInfo,ClusterInstance>>();
    for (    Map.Entry<InstanceConnectionInfo,ClusterInstance> entry : registeredHosts.entrySet()) {
      final ClusterInstance host=entry.getValue();
      if (!host.isStillAlive(cleanUpInterval)) {
        final List<AllocatedSlice> removedSlices=host.removeAllAllocatedSlices();
        for (        AllocatedSlice removedSlice : removedSlices) {
          final JobID jobID=removedSlice.getJobID();
          final List<AllocatedSlice> slicesOfJob=slicesOfJobs.get(jobID);
          if (slicesOfJob == null) {
            LOG.error(""String_Node_Str"" + jobID);
            continue;
          }
          slicesOfJob.remove(removedSlice);
          if (slicesOfJob.isEmpty()) {
            slicesOfJobs.remove(jobID);
          }
          if (instanceListener != null) {
            instanceListener.allocatedResourceDied(removedSlice.getJobID(),new AllocatedResource(removedSlice.getHostingInstance(),removedSlice.getAllocationID()));
          }
        }
        hostsToRemove.add(entry);
      }
    }
    registeredHosts.entrySet().removeAll(hostsToRemove);
    updateInstaceTypeDescriptionMap();
  }
}","@Override public void run(){
synchronized (ClusterManager.this) {
    final List<Map.Entry<InstanceConnectionInfo,ClusterInstance>> hostsToRemove=new ArrayList<Map.Entry<InstanceConnectionInfo,ClusterInstance>>();
    for (    Map.Entry<InstanceConnectionInfo,ClusterInstance> entry : registeredHosts.entrySet()) {
      final ClusterInstance host=entry.getValue();
      if (!host.isStillAlive(cleanUpInterval)) {
        final List<AllocatedSlice> removedSlices=host.removeAllAllocatedSlices();
        for (        AllocatedSlice removedSlice : removedSlices) {
          final JobID jobID=removedSlice.getJobID();
          final List<AllocatedSlice> slicesOfJob=slicesOfJobs.get(jobID);
          if (slicesOfJob == null) {
            LOG.error(""String_Node_Str"" + jobID);
            continue;
          }
          slicesOfJob.remove(removedSlice);
          if (slicesOfJob.isEmpty()) {
            slicesOfJobs.remove(jobID);
          }
          if (instanceListener != null) {
            instanceListener.allocatedResourceDied(removedSlice.getJobID(),new AllocatedResource(removedSlice.getHostingInstance(),removedSlice.getType(),removedSlice.getAllocationID()));
          }
        }
        hostsToRemove.add(entry);
      }
    }
    registeredHosts.entrySet().removeAll(hostsToRemove);
    updateInstaceTypeDescriptionMap();
  }
}",0.8665420560747663
56191,"/** 
 * Creates a new cloud instance.
 * @param instanceID the instance ID assigned by the cloud management system
 * @param type the instance type
 * @param instanceOwner the owner of the instance
 * @param instanceConnectionInfo the information required to connect to the instance's task manager
 * @param allocationTime the time the instance was allocated
 * @param parentNode the parent node in the network topology
 * @param hardwareDescription the hardware description reported by the instance itself
 */
public CloudInstance(String instanceID,InstanceType type,String instanceOwner,InstanceConnectionInfo instanceConnectionInfo,long allocationTime,NetworkNode parentNode,NetworkTopology networkTopology,HardwareDescription hardwareDescription){
  super(type,instanceConnectionInfo,parentNode,networkTopology,hardwareDescription);
  this.allocatedResource=new AllocatedResource(this,new AllocationID());
  this.instanceID=instanceID;
  this.instanceOwner=instanceOwner;
  this.allocationTime=allocationTime;
}","/** 
 * Creates a new cloud instance.
 * @param instanceID the instance ID assigned by the cloud management system
 * @param type the instance type
 * @param instanceOwner the owner of the instance
 * @param instanceConnectionInfo the information required to connect to the instance's task manager
 * @param allocationTime the time the instance was allocated
 * @param parentNode the parent node in the network topology
 * @param hardwareDescription the hardware description reported by the instance itself
 */
public CloudInstance(String instanceID,InstanceType type,String instanceOwner,InstanceConnectionInfo instanceConnectionInfo,long allocationTime,NetworkNode parentNode,NetworkTopology networkTopology,HardwareDescription hardwareDescription){
  super(type,instanceConnectionInfo,parentNode,networkTopology,hardwareDescription);
  this.allocatedResource=new AllocatedResource(this,type,new AllocationID());
  this.instanceID=instanceID;
  this.instanceOwner=instanceOwner;
  this.allocationTime=allocationTime;
}",0.9975429975429976
56192,"/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstance().getType().equals(allocatedResource.getInstance().getType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.warn(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstanceType().equals(allocatedResource.getInstanceType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.warn(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}",0.997060264576188
56193,"/** 
 * Creates an execution vertex from a job vertex.
 * @param jobVertex the job vertex to create the execution vertex from
 * @param instanceManager the instanceManager
 * @param initialExecutionStage the initial execution stage all group vertices are added to
 * @return the new execution vertex
 * @throws GraphConversionException thrown if the job vertex is of an unknown subclass
 */
private ExecutionVertex createVertex(AbstractJobVertex jobVertex,InstanceManager instanceManager,ExecutionStage initialExecutionStage) throws GraphConversionException {
  InstanceType instanceType=null;
  boolean userDefinedInstanceType=false;
  if (jobVertex.getInstanceType() != null) {
    userDefinedInstanceType=true;
    instanceType=instanceManager.getInstanceTypeByName(jobVertex.getInstanceType());
    if (instanceType == null) {
      throw new GraphConversionException(""String_Node_Str"" + jobVertex.getInstanceType() + ""String_Node_Str"");
    }
  }
  if (instanceType == null) {
    instanceType=instanceManager.getDefaultInstanceType();
  }
  final ExecutionSignature signature=ExecutionSignature.createSignature(jobVertex.getInvokableClass(),jobVertex.getJobGraph().getJobID());
  final ExecutionGroupVertex groupVertex=new ExecutionGroupVertex(jobVertex.getName(),jobVertex.getID(),this,jobVertex.getNumberOfSubtasks(),instanceType,userDefinedInstanceType,jobVertex.getNumberOfSubtasksPerInstance(),jobVertex.getVertexToShareInstancesWith() != null ? true : false,jobVertex.getConfiguration(),signature);
  final Class<? extends AbstractInvokable> invokableClass=jobVertex.getInvokableClass();
  if (invokableClass == null) {
    throw new GraphConversionException(""String_Node_Str"" + jobVertex.getID() + ""String_Node_Str""+ jobVertex.getName()+ ""String_Node_Str"");
  }
  initialExecutionStage.addStageMember(groupVertex);
  ExecutionVertex ev=null;
  try {
    ev=new ExecutionVertex(jobVertex.getJobGraph().getJobID(),invokableClass,this,groupVertex);
  }
 catch (  Exception e) {
    throw new GraphConversionException(StringUtils.stringifyException(e));
  }
  try {
    jobVertex.checkConfiguration(ev.getEnvironment().getInvokable());
  }
 catch (  IllegalConfigurationException e) {
    throw new GraphConversionException(StringUtils.stringifyException(e));
  }
  final int minimumNumberOfSubtasks=jobVertex.getMinimumNumberOfSubtasks(ev.getEnvironment().getInvokable());
  final int maximumNumberOfSubtasks=jobVertex.getMaximumNumberOfSubtasks(ev.getEnvironment().getInvokable());
  if (jobVertex.getNumberOfSubtasks() != -1) {
    if (jobVertex.getNumberOfSubtasks() < 1) {
      throw new GraphConversionException(""String_Node_Str"" + jobVertex.getName() + ""String_Node_Str""+ jobVertex.getNumberOfSubtasks()+ ""String_Node_Str"");
    }
    if (jobVertex.getNumberOfSubtasks() < minimumNumberOfSubtasks) {
      throw new GraphConversionException(""String_Node_Str"" + minimumNumberOfSubtasks);
    }
    if (maximumNumberOfSubtasks != -1) {
      if (jobVertex.getNumberOfSubtasks() > maximumNumberOfSubtasks) {
        throw new GraphConversionException(""String_Node_Str"" + jobVertex.getName() + ""String_Node_Str""+ maximumNumberOfSubtasks);
      }
    }
  }
  if (jobVertex.getNumberOfSubtasksPerInstance() != -1 && jobVertex.getNumberOfSubtasksPerInstance() < 1) {
    throw new GraphConversionException(""String_Node_Str"" + jobVertex.getNumberOfSubtasksPerInstance() + ""String_Node_Str""+ jobVertex.getName());
  }
  groupVertex.setMinMemberSize(minimumNumberOfSubtasks);
  groupVertex.setMaxMemberSize(maximumNumberOfSubtasks);
  ev.setAllocatedResource(new AllocatedResource(DummyInstance.createDummyInstance(instanceType),null));
  if (jobVertex instanceof JobInputVertex) {
    try {
      groupVertex.setInputSplits(((JobInputVertex)jobVertex).getInputSplits());
    }
 catch (    IllegalConfigurationException e) {
      throw new GraphConversionException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str""+ StringUtils.stringifyException(e));
    }
  }
  if (jobVertex instanceof JobFileOutputVertex) {
    final JobFileOutputVertex jbov=(JobFileOutputVertex)jobVertex;
    jobVertex.getConfiguration().setString(""String_Node_Str"",jbov.getFilePath().toString());
  }
  return ev;
}","/** 
 * Creates an execution vertex from a job vertex.
 * @param jobVertex the job vertex to create the execution vertex from
 * @param instanceManager the instanceManager
 * @param initialExecutionStage the initial execution stage all group vertices are added to
 * @return the new execution vertex
 * @throws GraphConversionException thrown if the job vertex is of an unknown subclass
 */
private ExecutionVertex createVertex(AbstractJobVertex jobVertex,InstanceManager instanceManager,ExecutionStage initialExecutionStage) throws GraphConversionException {
  InstanceType instanceType=null;
  boolean userDefinedInstanceType=false;
  if (jobVertex.getInstanceType() != null) {
    userDefinedInstanceType=true;
    instanceType=instanceManager.getInstanceTypeByName(jobVertex.getInstanceType());
    if (instanceType == null) {
      throw new GraphConversionException(""String_Node_Str"" + jobVertex.getInstanceType() + ""String_Node_Str"");
    }
  }
  if (instanceType == null) {
    instanceType=instanceManager.getDefaultInstanceType();
  }
  final ExecutionSignature signature=ExecutionSignature.createSignature(jobVertex.getInvokableClass(),jobVertex.getJobGraph().getJobID());
  final ExecutionGroupVertex groupVertex=new ExecutionGroupVertex(jobVertex.getName(),jobVertex.getID(),this,jobVertex.getNumberOfSubtasks(),instanceType,userDefinedInstanceType,jobVertex.getNumberOfSubtasksPerInstance(),jobVertex.getVertexToShareInstancesWith() != null ? true : false,jobVertex.getConfiguration(),signature);
  final Class<? extends AbstractInvokable> invokableClass=jobVertex.getInvokableClass();
  if (invokableClass == null) {
    throw new GraphConversionException(""String_Node_Str"" + jobVertex.getID() + ""String_Node_Str""+ jobVertex.getName()+ ""String_Node_Str"");
  }
  initialExecutionStage.addStageMember(groupVertex);
  ExecutionVertex ev=null;
  try {
    ev=new ExecutionVertex(jobVertex.getJobGraph().getJobID(),invokableClass,this,groupVertex);
  }
 catch (  Exception e) {
    throw new GraphConversionException(StringUtils.stringifyException(e));
  }
  try {
    jobVertex.checkConfiguration(ev.getEnvironment().getInvokable());
  }
 catch (  IllegalConfigurationException e) {
    throw new GraphConversionException(StringUtils.stringifyException(e));
  }
  final int minimumNumberOfSubtasks=jobVertex.getMinimumNumberOfSubtasks(ev.getEnvironment().getInvokable());
  final int maximumNumberOfSubtasks=jobVertex.getMaximumNumberOfSubtasks(ev.getEnvironment().getInvokable());
  if (jobVertex.getNumberOfSubtasks() != -1) {
    if (jobVertex.getNumberOfSubtasks() < 1) {
      throw new GraphConversionException(""String_Node_Str"" + jobVertex.getName() + ""String_Node_Str""+ jobVertex.getNumberOfSubtasks()+ ""String_Node_Str"");
    }
    if (jobVertex.getNumberOfSubtasks() < minimumNumberOfSubtasks) {
      throw new GraphConversionException(""String_Node_Str"" + minimumNumberOfSubtasks);
    }
    if (maximumNumberOfSubtasks != -1) {
      if (jobVertex.getNumberOfSubtasks() > maximumNumberOfSubtasks) {
        throw new GraphConversionException(""String_Node_Str"" + jobVertex.getName() + ""String_Node_Str""+ maximumNumberOfSubtasks);
      }
    }
  }
  if (jobVertex.getNumberOfSubtasksPerInstance() != -1 && jobVertex.getNumberOfSubtasksPerInstance() < 1) {
    throw new GraphConversionException(""String_Node_Str"" + jobVertex.getNumberOfSubtasksPerInstance() + ""String_Node_Str""+ jobVertex.getName());
  }
  groupVertex.setMinMemberSize(minimumNumberOfSubtasks);
  groupVertex.setMaxMemberSize(maximumNumberOfSubtasks);
  ev.setAllocatedResource(new AllocatedResource(DummyInstance.createDummyInstance(instanceType),instanceType,null));
  if (jobVertex instanceof JobInputVertex) {
    try {
      groupVertex.setInputSplits(((JobInputVertex)jobVertex).getInputSplits());
    }
 catch (    IllegalConfigurationException e) {
      throw new GraphConversionException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str""+ StringUtils.stringifyException(e));
    }
  }
  if (jobVertex instanceof JobFileOutputVertex) {
    final JobFileOutputVertex jbov=(JobFileOutputVertex)jobVertex;
    jobVertex.getConfiguration().setString(""String_Node_Str"",jbov.getFilePath().toString());
  }
  return ev;
}",0.9984588026081802
56194,"public synchronized void reassignInstances(){
  int numberOfRequiredInstances=0;
synchronized (this.groupMembers) {
    numberOfRequiredInstances=(this.groupMembers.size() / this.numberOfSubtasksPerInstance) + (((this.groupMembers.size() % this.numberOfSubtasksPerInstance) != 0) ? 1 : 0);
  }
  final List<AllocatedResource> availableInstances=collectAvailabbleResources();
  while (availableInstances.size() < numberOfRequiredInstances) {
    final AllocatedResource newAllocatedResource=new AllocatedResource(DummyInstance.createDummyInstance(this.instanceType),null);
    availableInstances.add(newAllocatedResource);
  }
synchronized (this.groupMembers) {
    final Iterator<ExecutionVertex> it=this.groupMembers.iterator();
    int instanceIndex=0, i=0;
    int sizeOfIndexStep=availableInstances.size() / numberOfRequiredInstances;
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      vertex.setAllocatedResource(availableInstances.get(instanceIndex));
      if ((++i % this.numberOfSubtasksPerInstance) == 0) {
        instanceIndex+=sizeOfIndexStep;
      }
    }
  }
synchronized (this.verticesSharingInstances) {
    final Iterator<ExecutionGroupVertex> it2=this.verticesSharingInstances.iterator();
    while (it2.hasNext()) {
      final ExecutionGroupVertex groupVertex=it2.next();
      groupVertex.reassignInstances();
    }
  }
}","public synchronized void reassignInstances(){
  int numberOfRequiredInstances=0;
synchronized (this.groupMembers) {
    numberOfRequiredInstances=(this.groupMembers.size() / this.numberOfSubtasksPerInstance) + (((this.groupMembers.size() % this.numberOfSubtasksPerInstance) != 0) ? 1 : 0);
  }
  final List<AllocatedResource> availableInstances=collectAvailabbleResources();
  while (availableInstances.size() < numberOfRequiredInstances) {
    final AllocatedResource newAllocatedResource=new AllocatedResource(DummyInstance.createDummyInstance(this.instanceType),this.instanceType,null);
    availableInstances.add(newAllocatedResource);
  }
synchronized (this.groupMembers) {
    final Iterator<ExecutionVertex> it=this.groupMembers.iterator();
    int instanceIndex=0, i=0;
    int sizeOfIndexStep=availableInstances.size() / numberOfRequiredInstances;
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      vertex.setAllocatedResource(availableInstances.get(instanceIndex));
      if ((++i % this.numberOfSubtasksPerInstance) == 0) {
        instanceIndex+=sizeOfIndexStep;
      }
    }
  }
synchronized (this.verticesSharingInstances) {
    final Iterator<ExecutionGroupVertex> it2=this.verticesSharingInstances.iterator();
    while (it2.hasNext()) {
      final ExecutionGroupVertex groupVertex=it2.next();
      groupVertex.reassignInstances();
    }
  }
}",0.993482983345402
56195,"/** 
 * {@inheritDoc}
 */
@Override public int hashCode(){
  return this.allocationID.hashCode();
}","/** 
 * {@inheritDoc}
 */
@Override public int hashCode(){
  if (this.allocationID == null) {
    return 0;
  }
  return this.allocationID.hashCode();
}",0.7888446215139442
56196,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (obj instanceof AllocatedResource) {
    final AllocatedResource allocatedResource=(AllocatedResource)obj;
    if (!this.instance.equals(allocatedResource.getInstance())) {
      return false;
    }
    if (this.allocationID == null) {
      if (allocatedResource.getAllocationID() == null) {
        return true;
      }
 else {
        return false;
      }
    }
    if (!this.allocationID.equals(allocatedResource.getAllocationID())) {
      return false;
    }
    return true;
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (obj instanceof AllocatedResource) {
    final AllocatedResource allocatedResource=(AllocatedResource)obj;
    if (!this.instance.equals(allocatedResource.getInstance())) {
      return false;
    }
    if (this.allocationID == null) {
      if (allocatedResource.getAllocationID() != null) {
        return false;
      }
    }
 else {
      if (!this.allocationID.equals(allocatedResource.getAllocationID())) {
        return false;
      }
    }
    if (this.instanceType == null) {
      if (allocatedResource.instance != null) {
        return false;
      }
    }
 else {
      if (!this.instanceType.equals(allocatedResource.getInstanceType())) {
        return false;
      }
    }
    return true;
  }
  return false;
}",0.6329479768786127
56197,"/** 
 * Constructs a new allocated resource object.
 * @param instance the instance a task is scheduled to run on.
 * @param allocationID the allocation ID identifying the allocated resources within the instance
 */
public AllocatedResource(AbstractInstance instance,AllocationID allocationID){
  this.instance=instance;
  this.allocationID=allocationID;
}","/** 
 * Constructs a new allocated resource object.
 * @param instance the instance a task is scheduled to run on.
 * @param instanceType the instance type this allocated resource represents
 * @param allocationID the allocation ID identifying the allocated resources within the instance
 */
public AllocatedResource(AbstractInstance instance,InstanceType instanceType,AllocationID allocationID){
  this.instance=instance;
  this.instanceType=instanceType;
  this.allocationID=allocationID;
}",0.7830188679245284
56198,"/** 
 * {@inheritDoc}
 */
@Override public void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  boolean assignmentSuccessful=false;
  AllocatedResource allocatedResource=null;
synchronized (this.synchronizationObject) {
    if (this.localInstance != null) {
      if (this.allocatedResource == null) {
        allocatedResource=new AllocatedResource(this.localInstance,new AllocationID());
        this.allocatedResource=allocatedResource;
        assignmentSuccessful=true;
      }
    }
  }
  if (assignmentSuccessful) {
    new LocalInstanceNotifier(this.instanceListener,jobID,allocatedResource).start();
  }
 else {
    throw new InstanceException(""String_Node_Str"" + instanceType + ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  boolean assignmentSuccessful=false;
  AllocatedResource allocatedResource=null;
synchronized (this.synchronizationObject) {
    if (this.localInstance != null) {
      if (this.allocatedResource == null) {
        allocatedResource=new AllocatedResource(this.localInstance,instanceType,new AllocationID());
        this.allocatedResource=allocatedResource;
        assignmentSuccessful=true;
      }
    }
  }
  if (assignmentSuccessful) {
    new LocalInstanceNotifier(this.instanceListener,jobID,allocatedResource).start();
  }
 else {
    throw new InstanceException(""String_Node_Str"" + instanceType + ""String_Node_Str"");
  }
}",0.9916074887023888
56199,"/** 
 * Adds an InputSplit to the Vertex with least InputSplits assigned that can locally read the split. If the InputSplit cannot be read locally by any Vertex, it is assigned to the Vertex with least assigned InputSplits.
 * @param inputSplit InputSplit that will be assigned
 * @throws ExecutionFailureException
 */
private void addFileSplit(InputSplit inputSplit) throws ExecutionFailureException {
  String[] splitLocations=inputSplit.getHostNames();
  if (splitLocations.length == 0)   throw new ExecutionFailureException(""String_Node_Str"" + inputSplit);
  boolean added=false;
  PriorityQueue<QueueElem> newVertexPrioQueue=new PriorityQueue<QueueElem>();
  while (this.vertexPrioQueue.size() > 0) {
    QueueElem topElem=this.vertexPrioQueue.poll();
    if (topElem.hostsSplit(splitLocations)) {
      topElem.assignInputSplit(inputSplit);
      added=true;
    }
    newVertexPrioQueue.add(topElem);
    if (added) {
      break;
    }
  }
  if (added) {
    newVertexPrioQueue.addAll(this.vertexPrioQueue);
  }
 else {
    QueueElem topElem=newVertexPrioQueue.poll();
    topElem.assignInputSplit(inputSplit);
    newVertexPrioQueue.add(topElem);
  }
  this.vertexPrioQueue=newVertexPrioQueue;
}","/** 
 * Adds an InputSplit to the Vertex with least InputSplits assigned that can locally read the split. If the InputSplit cannot be read locally by any Vertex, it is assigned to the Vertex with least assigned InputSplits.
 * @param inputSplit InputSplit that will be assigned
 * @throws ExecutionFailureException
 */
private void addFileSplit(InputSplit inputSplit) throws ExecutionFailureException {
  final String[] splitLocations=inputSplit.getHostNames();
  if (splitLocations.length == 0)   throw new ExecutionFailureException(""String_Node_Str"" + inputSplit);
  boolean added=false;
  final PriorityQueue<QueueElem> newVertexPrioQueue=new PriorityQueue<QueueElem>();
  while (this.vertexPrioQueue.size() > 0) {
    QueueElem topElem=this.vertexPrioQueue.poll();
    if (topElem.hostsSplit(splitLocations)) {
      topElem.assignInputSplit(inputSplit);
      added=true;
    }
    newVertexPrioQueue.add(topElem);
    if (added) {
      break;
    }
  }
  if (added) {
    newVertexPrioQueue.addAll(this.vertexPrioQueue);
  }
 else {
    final QueueElem topElem=newVertexPrioQueue.poll();
    topElem.assignInputSplit(inputSplit);
    newVertexPrioQueue.add(topElem);
  }
  this.vertexPrioQueue=newVertexPrioQueue;
}",0.9925803792250618
56200,"/** 
 * Assign InputSplits for a ExecutionGroupVertex
 * @param graph ExecutionGraph the ExecutionGroupVertex belongs to
 * @param groupVertex ExecutionGroupVertex who's InputSplits will be assigned
 * @throws ExecutionFailureException
 */
private void assignInputSplits(ExecutionGroupVertex groupVertex) throws ExecutionFailureException {
  InputSplit[] inputSplits=groupVertex.getInputSplits();
  if (inputSplits == null) {
    throw new ExecutionFailureException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + inputSplits.length + ""String_Node_Str""+ groupVertex.getName());
  initializePriorityQueue(groupVertex,inputSplits);
  for (int i=0; i < inputSplits.length; i++) {
    addFileSplit(inputSplits[i]);
  }
  verifyAssignments();
  vertexPrioQueue.clear();
}","/** 
 * Assign InputSplits for a ExecutionGroupVertex
 * @param graph ExecutionGraph the ExecutionGroupVertex belongs to
 * @param groupVertex ExecutionGroupVertex who's InputSplits will be assigned
 * @return <code>false</code> if the instance assignment could not be done because at least one vertex has not beenin state <code>READY</code>, <code>true/code> otherwise
 * @throws ExecutionFailureException
 */
private boolean assignInputSplits(ExecutionGroupVertex groupVertex) throws ExecutionFailureException {
  for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); i++) {
    if (!groupVertex.getGroupMember(i).getExecutionState().equals(ExecutionState.READY)) {
      return false;
    }
  }
  final InputSplit[] inputSplits=groupVertex.getInputSplits();
  if (inputSplits == null) {
    throw new ExecutionFailureException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + inputSplits.length + ""String_Node_Str""+ groupVertex.getName());
  initializePriorityQueue(groupVertex,inputSplits);
  for (int i=0; i < inputSplits.length; i++) {
    addFileSplit(inputSplits[i]);
  }
  verifyAssignments();
  vertexPrioQueue.clear();
  return true;
}",0.8037567968363816
56201,"/** 
 * Searches the current execution graph for execution vertices which have become ready for execution and triggers their execution.
 */
void runVerticesReadyForExecution(){
  final Set<ExecutionVertex> readyVertices=this.scheduler.getVerticesReadyToBeExecuted();
synchronized (this.verticesReadyToRun) {
    this.verticesReadyToRun.addAll(readyVertices);
    final Iterator<ExecutionVertex> it=this.verticesReadyToRun.iterator();
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() != ExecutionState.READY) {
        LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState());
      }
      if (vertex.isInputVertex() && vertex.getEnvironment().getInputSplits().length == 0 && vertex.getGroupVertex().getStageNumber() == 0) {
        try {
          InputSplitAssigner.assignInputSplits(vertex);
        }
 catch (        ExecutionFailureException e) {
          e.printStackTrace();
        }
      }
      LOG.info(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getAllocatedResource().getInstance());
      final TaskSubmissionResult submissionResult=vertex.startTask();
      it.remove();
      if (submissionResult.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
        vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,submissionResult.getDescription());
      }
    }
  }
}","/** 
 * Searches the current execution graph for execution vertices which have become ready for execution and triggers their execution.
 */
void runVerticesReadyForExecution(){
  final Set<ExecutionVertex> readyVertices=this.scheduler.getVerticesReadyToBeExecuted();
synchronized (this.verticesReadyToRun) {
    this.verticesReadyToRun.addAll(readyVertices);
    final Iterator<ExecutionVertex> it=this.verticesReadyToRun.iterator();
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() != ExecutionState.READY) {
        LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState());
      }
      if (vertex.isInputVertex() && vertex.getEnvironment().getInputSplits().length == 0 && vertex.getGroupVertex().getStageNumber() == 0) {
        try {
          if (!InputSplitAssigner.assignInputSplits(vertex)) {
            continue;
          }
        }
 catch (        ExecutionFailureException e) {
          e.printStackTrace();
        }
      }
      LOG.info(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getAllocatedResource().getInstance());
      final TaskSubmissionResult submissionResult=vertex.startTask();
      it.remove();
      if (submissionResult.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
        vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,submissionResult.getDescription());
      }
    }
  }
}",0.9856089856089856
56202,"/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstance().getType().equals(allocatedResource.getInstance().getType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.error(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstanceType().equals(allocatedResource.getInstanceType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.error(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}",0.9970617042115572
56203,"/** 
 * Verifies that at least one InputSplit was assigned to each vertex
 * @throws ExecutionFailureException
 */
private void verifyAssignments() throws ExecutionFailureException {
  while (this.vertexPrioQueue.size() > 0) {
    QueueElem topElem=this.vertexPrioQueue.poll();
    if (topElem.getNoAssignedSplits() == 0) {
      throw new ExecutionFailureException(""String_Node_Str"" + topElem.getVertex().getName() + ""String_Node_Str""+ topElem.getVertex().getAllocatedResource().getInstance().getInstanceConnectionInfo().getHostName()+ ""String_Node_Str""+ topElem.getVertex().getID()+ ""String_Node_Str"");
    }
    LOG.info(topElem.getNoAssignedSplits() + ""String_Node_Str"" + topElem.getVertex().getAllocatedResource().getInstance().getInstanceConnectionInfo().getHostName());
    for (    InputSplit is : topElem.getVertex().getEnvironment().getInputSplits()) {
      LOG.info(""String_Node_Str"" + ((FileInputSplit)is).getPath());
      for (      String hn : is.getHostNames()) {
        LOG.info(""String_Node_Str"" + hn);
      }
    }
  }
}","/** 
 * Verifies that at least one InputSplit was assigned to each vertex
 * @throws ExecutionFailureException
 */
private void verifyAssignments() throws ExecutionFailureException {
  while (this.vertexPrioQueue.size() > 0) {
    final QueueElem topElem=this.vertexPrioQueue.poll();
    if (topElem.getNoAssignedSplits() == 0) {
      continue;
    }
    LOG.info(topElem.getNoAssignedSplits() + ""String_Node_Str"" + topElem.getVertex().getAllocatedResource().getInstance().getInstanceConnectionInfo().getHostName());
    for (    InputSplit is : topElem.getVertex().getEnvironment().getInputSplits()) {
      LOG.info(""String_Node_Str"" + ((FileInputSplit)is).getPath());
      for (      String hn : is.getHostNames()) {
        LOG.info(""String_Node_Str"" + hn);
      }
    }
  }
}",0.8427397260273972
56204,"/** 
 * Assign InputSplits for a ExecutionGroupVertex
 * @param graph ExecutionGraph the ExecutionGroupVertex belongs to
 * @param groupVertex ExecutionGroupVertex who's InputSplits will be assigned
 * @return <code>false</code> if the instance assignment could not be done because at least one vertex has not beenin state <code>READY</code>, <code>true/code> otherwise
 * @throws ExecutionFailureException
 */
private boolean assignInputSplits(ExecutionGroupVertex groupVertex) throws ExecutionFailureException {
  for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); i++) {
    if (!groupVertex.getGroupMember(i).getExecutionState().equals(ExecutionState.READY)) {
      return false;
    }
  }
  final InputSplit[] inputSplits=groupVertex.getInputSplits();
  if (inputSplits == null) {
    throw new ExecutionFailureException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + inputSplits.length + ""String_Node_Str""+ groupVertex.getName());
  initializePriorityQueue(groupVertex,inputSplits);
  for (int i=0; i < inputSplits.length; i++) {
    addFileSplit(inputSplits[i]);
  }
  verifyAssignments();
  vertexPrioQueue.clear();
  return true;
}","/** 
 * Assign InputSplits for a ExecutionGroupVertex
 * @param graph ExecutionGraph the ExecutionGroupVertex belongs to
 * @param groupVertex ExecutionGroupVertex who's InputSplits will be assigned
 * @return <code>false</code> if the instance assignment could not be done because at least one vertex has not yetbeen assigned to a real instance, <code>true/code> otherwise
 * @throws ExecutionFailureException
 */
private boolean assignInputSplits(ExecutionGroupVertex groupVertex) throws ExecutionFailureException {
  for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); i++) {
    final AllocatedResource ar=groupVertex.getGroupMember(i).getAllocatedResource();
    if (ar.getInstance() instanceof DummyInstance) {
      return false;
    }
  }
  final InputSplit[] inputSplits=groupVertex.getInputSplits();
  if (inputSplits == null) {
    throw new ExecutionFailureException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + inputSplits.length + ""String_Node_Str""+ groupVertex.getName());
  initializePriorityQueue(groupVertex,inputSplits);
  for (int i=0; i < inputSplits.length; i++) {
    addFileSplit(inputSplits[i]);
  }
  verifyAssignments();
  vertexPrioQueue.clear();
  return true;
}",0.9183922046285018
56205,"public ServiceException(Throwable cause){
  super(cause);
}","public ServiceException(String message,Throwable cause){
  super(message,cause);
}",0.8368794326241135
56206,"/** 
 * Factory method for MemorySegment implementations.
 * @param descriptor
 * @return
 */
private DefaultMemorySegment factory(MemorySegmentDescriptor descriptor){
  DefaultRandomAccessView randomAccessView=new DefaultRandomAccessView(descriptor);
  DefaultDataInputView inputView=new DefaultDataInputView(descriptor);
  DefaultDataOutputView outputView=new DefaultDataOutputView(descriptor);
  return new DefaultMemorySegment(descriptor,randomAccessView,inputView,outputView);
}","/** 
 * Factory method for MemorySegment implementations.
 * @param descriptor
 * @return
 */
private static DefaultMemorySegment factory(MemorySegmentDescriptor descriptor){
  DefaultRandomAccessView randomAccessView=new DefaultRandomAccessView(descriptor);
  DefaultDataInputView inputView=new DefaultDataInputView(descriptor);
  DefaultDataOutputView outputView=new DefaultDataOutputView(descriptor);
  return new DefaultMemorySegment(descriptor,randomAccessView,inputView,outputView);
}",0.9928057553956836
56207,"@Override public void shutdown(){
  if (!isShutDown) {
    LOG.debug(""String_Node_Str"" + toString());
    isShutDown=true;
    memory=null;
    chunkSize=0L;
  }
}","@Override public void shutdown(){
synchronized (this) {
    if (!isShutDown) {
      LOG.debug(""String_Node_Str"" + toString());
      isShutDown=true;
      memory=null;
      chunkSize=0L;
    }
  }
}",0.8956043956043956
56208,"/** 
 * Creates a new channel selector that uses the given strategy (broadcasting, partitioning, ...), using the supplied salt to randomize hashes.
 * @param strategy The distribution strategy to be used.
 * @param salt The salt used to randomize hash values.
 */
public OutputEmitter(ShipStrategy strategy,byte[] salt){
  if (strategy != ShipStrategy.BROADCAST && strategy != ShipStrategy.PARTITION_HASH && strategy != ShipStrategy.FORWARD) {
    throw new UnsupportedOperationException(""String_Node_Str"" + strategy.name());
  }
  this.strategy=strategy;
  this.salt=salt;
}","/** 
 * Creates a new channel selector that uses the given strategy (broadcasting, partitioning, ...), using the supplied salt to randomize hashes.
 * @param strategy The distribution strategy to be used.
 * @param salt The salt used to randomize hash values.
 */
public OutputEmitter(ShipStrategy strategy,byte[] salt){
  this.strategy=strategy;
  this.salt=salt;
}",0.6971307120085016
56209,"@Override public int[] selectChannels(KeyValuePair<K,V> pair,int numberOfChannels){
switch (strategy) {
case BROADCAST:
    return broadcast(numberOfChannels);
case PARTITION_HASH:
  return partition(pair,numberOfChannels);
case FORWARD:
return robin(numberOfChannels);
default :
throw new UnsupportedOperationException();
}
}","@Override public int[] selectChannels(KeyValuePair<K,V> pair,int numberOfChannels){
switch (strategy) {
case BROADCAST:
    return broadcast(numberOfChannels);
case PARTITION_HASH:
  return partition(pair,numberOfChannels);
case FORWARD:
return robin(numberOfChannels);
default :
throw new UnsupportedOperationException(""String_Node_Str"" + strategy.name());
}
}",0.9490538573508006
56210,"/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  Collection<MemorySegment> outputSegments=memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortable<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  if (CombiningUnilateralSortMerger.this.combineLastMerge) {
    KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(getMergingIterator(channelIDs,ioMemorySize));
    lazyIterator.setTarget(new CombiningIterator<K,V>(combineStub,iter));
  }
 else {
    lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortable<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  if (CombiningUnilateralSortMerger.this.combineLastMerge) {
    KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(getMergingIterator(channelIDs,ioMemorySize));
    lazyIterator.setTarget(new CombiningIterator<K,V>(combineStub,iter));
  }
 else {
    lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}",0.9942119323241316
56211,"/** 
 * @param channelIDs
 * @param ioMemorySize
 * @return The ID of the channel that holds the merged data of all input channels.
 */
protected Channel.ID mergeChannels(List<Channel.ID> channelIDs,int ioMemorySize){
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>(channelIDs.size());
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    Collection<MemorySegment> inputSegments;
    final ChannelReader reader;
    try {
      inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
      freeSegmentsAtShutdown(inputSegments);
      reader=ioManager.createChannelReader(id,inputSegments);
    }
 catch (    MemoryAllocationException mae) {
      throw new RuntimeException(""String_Node_Str"",mae);
    }
catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  KeyGroupedIterator<K,V> groupedIter=new KeyGroupedIterator<K,V>(mi);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  Collection<MemorySegment> outputSegments;
  ChannelWriter writer;
  try {
    outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
    freeSegmentsAtShutdown(outputSegments);
    writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException(""String_Node_Str"",mae);
  }
catch (  ServiceException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  WriterCollector<K,V> collector=new WriterCollector<K,V>(writer);
  while (groupedIter.nextKey()) {
    this.combineStub.combine(groupedIter.getKey(),groupedIter.getValues(),collector);
  }
  try {
    outputSegments=writer.close();
  }
 catch (  ServiceException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  memoryManager.release(outputSegments);
  return mergedChannelID;
}","/** 
 * @param channelIDs
 * @param ioMemorySize
 * @return The ID of the channel that holds the merged data of all input channels.
 */
protected Channel.ID mergeChannels(List<Channel.ID> channelIDs,int ioMemorySize){
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>(channelIDs.size());
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    final ChannelReader reader;
    try {
      inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
      freeSegmentsAtShutdown(inputSegments);
      reader=ioManager.createChannelReader(id,inputSegments);
    }
 catch (    MemoryAllocationException mae) {
      throw new RuntimeException(""String_Node_Str"",mae);
    }
catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  KeyGroupedIterator<K,V> groupedIter=new KeyGroupedIterator<K,V>(mi);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  ChannelWriter writer;
  try {
    outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
    freeSegmentsAtShutdown(outputSegments);
    writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException(""String_Node_Str"",mae);
  }
catch (  ServiceException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  WriterCollector<K,V> collector=new WriterCollector<K,V>(writer);
  while (groupedIter.nextKey()) {
    this.combineStub.combine(groupedIter.getKey(),groupedIter.getValues(),collector);
  }
  try {
    outputSegments=writer.close();
  }
 catch (  ServiceException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  memoryManager.release(outputSegments);
  return mergedChannelID;
}",0.9796011918404768
56212,"/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  Collection<MemorySegment> outputSegments=memoryManager.allocate(UnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  freeSegmentsAtShutdown(outputSegments);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    element.buffer.writeToChannel(writer);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(UnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  freeSegmentsAtShutdown(outputSegments);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    element.buffer.writeToChannel(writer);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  LOG.debug(""String_Node_Str"");
}",0.9903129657228018
56213,"/** 
 * Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently working on. This terminates cleanly for the JVM, but looses intermediate results.
 */
public void shutdown(){
  this.alive=false;
  this.interrupt();
}","@Override public void shutdown(){
  this.memoryManager.release(outputSegments);
  super.shutdown();
}",0.3060109289617486
56214,"/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  if (args.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String dataPointInput=args[1];
  String clusterInput=args[2];
  String output=args[3];
  DataSourceContract<PactInteger,CoordVector> dataPoints=new DataSourceContract<PactInteger,CoordVector>(PointInFormat.class,dataPointInput,""String_Node_Str"");
  dataPoints.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  dataPoints.setDegreeOfParallelism(noSubTasks);
  dataPoints.setOutputContract(UniqueKey.class);
  DataSourceContract<PactInteger,CoordVector> clusterPoints=new DataSourceContract<PactInteger,CoordVector>(PointInFormat.class,clusterInput,""String_Node_Str"");
  clusterPoints.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  clusterPoints.setDegreeOfParallelism(1);
  clusterPoints.setOutputContract(UniqueKey.class);
  CrossContract<PactInteger,CoordVector,PactInteger,CoordVector,PactInteger,Distance> computeDistance=new CrossContract<PactInteger,CoordVector,PactInteger,CoordVector,PactInteger,Distance>(ComputeDistance.class,""String_Node_Str"");
  computeDistance.setDegreeOfParallelism(noSubTasks);
  computeDistance.getCompilerHints().setAvgBytesPerRecord(48);
  ReduceContract<PactInteger,Distance,PactInteger,CoordVectorCountSum> findNearestClusterCenters=new ReduceContract<PactInteger,Distance,PactInteger,CoordVectorCountSum>(FindNearestCenter.class,""String_Node_Str"");
  findNearestClusterCenters.setDegreeOfParallelism(noSubTasks);
  findNearestClusterCenters.getCompilerHints().setAvgBytesPerRecord(48);
  ReduceContract<PactInteger,CoordVectorCountSum,PactInteger,CoordVector> recomputeClusterCenter=new ReduceContract<PactInteger,CoordVectorCountSum,PactInteger,CoordVector>(RecomputeClusterCenter.class,""String_Node_Str"");
  recomputeClusterCenter.setDegreeOfParallelism(noSubTasks);
  recomputeClusterCenter.getCompilerHints().setAvgBytesPerRecord(36);
  DataSinkContract<PactInteger,CoordVector> newClusterPoints=new DataSinkContract<PactInteger,CoordVector>(PointOutFormat.class,output,""String_Node_Str"");
  newClusterPoints.setDegreeOfParallelism(noSubTasks);
  newClusterPoints.setInput(recomputeClusterCenter);
  recomputeClusterCenter.setInput(findNearestClusterCenters);
  findNearestClusterCenters.setInput(computeDistance);
  computeDistance.setFirstInput(dataPoints);
  computeDistance.setSecondInput(clusterPoints);
  return new Plan(newClusterPoints,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String dataPointInput=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String clusterInput=(args.length > 2 ? args[2] : ""String_Node_Str"");
  String output=(args.length > 3 ? args[3] : ""String_Node_Str"");
  DataSourceContract<PactInteger,CoordVector> dataPoints=new DataSourceContract<PactInteger,CoordVector>(PointInFormat.class,dataPointInput,""String_Node_Str"");
  dataPoints.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  dataPoints.setDegreeOfParallelism(noSubTasks);
  dataPoints.setOutputContract(UniqueKey.class);
  DataSourceContract<PactInteger,CoordVector> clusterPoints=new DataSourceContract<PactInteger,CoordVector>(PointInFormat.class,clusterInput,""String_Node_Str"");
  clusterPoints.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  clusterPoints.setDegreeOfParallelism(1);
  clusterPoints.setOutputContract(UniqueKey.class);
  CrossContract<PactInteger,CoordVector,PactInteger,CoordVector,PactInteger,Distance> computeDistance=new CrossContract<PactInteger,CoordVector,PactInteger,CoordVector,PactInteger,Distance>(ComputeDistance.class,""String_Node_Str"");
  computeDistance.setDegreeOfParallelism(noSubTasks);
  computeDistance.getCompilerHints().setAvgBytesPerRecord(48);
  ReduceContract<PactInteger,Distance,PactInteger,CoordVectorCountSum> findNearestClusterCenters=new ReduceContract<PactInteger,Distance,PactInteger,CoordVectorCountSum>(FindNearestCenter.class,""String_Node_Str"");
  findNearestClusterCenters.setDegreeOfParallelism(noSubTasks);
  findNearestClusterCenters.getCompilerHints().setAvgBytesPerRecord(48);
  ReduceContract<PactInteger,CoordVectorCountSum,PactInteger,CoordVector> recomputeClusterCenter=new ReduceContract<PactInteger,CoordVectorCountSum,PactInteger,CoordVector>(RecomputeClusterCenter.class,""String_Node_Str"");
  recomputeClusterCenter.setDegreeOfParallelism(noSubTasks);
  recomputeClusterCenter.getCompilerHints().setAvgBytesPerRecord(36);
  DataSinkContract<PactInteger,CoordVector> newClusterPoints=new DataSinkContract<PactInteger,CoordVector>(PointOutFormat.class,output,""String_Node_Str"");
  newClusterPoints.setDegreeOfParallelism(noSubTasks);
  newClusterPoints.setInput(recomputeClusterCenter);
  recomputeClusterCenter.setInput(findNearestClusterCenters);
  findNearestClusterCenters.setInput(computeDistance);
  computeDistance.setFirstInput(dataPoints);
  computeDistance.setSecondInput(clusterPoints);
  return new Plan(newClusterPoints,""String_Node_Str"");
}",0.9545365853658536
56215,"/** 
 * Assembles the Plan of the All-2-All Shortest Paths example Pact program. The program computes one iteration of the All-2-All Shortest Paths algorithm. For the first iteration, two input formats can be chosen: 1) RDF triples with foaf:knows predicates 2) Text-serialized paths (see PathInFormat and PathOutFormat) To choose 1) set the forth parameter to ""true"". If set to ""false"" 2) will be used.
 */
@Override public Plan getPlan(String... args){
  if (args.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String paths=args[1];
  String output=args[2];
  boolean rdfInput=Boolean.parseBoolean(args[3]);
  DataSourceContract<NodePair,Path> pathsInput;
  if (rdfInput) {
    pathsInput=new DataSourceContract<NodePair,Path>(RDFTripleInFormat.class,paths);
  }
 else {
    pathsInput=new DataSourceContract<NodePair,Path>(PathInFormat.class,paths);
  }
  pathsInput.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  pathsInput.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathStarts=new MapContract<NodePair,Path,PactString,Path>(ProjectPathStart.class,""String_Node_Str"");
  pathStarts.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathEnds=new MapContract<NodePair,Path,PactString,Path>(ProjectPathEnd.class,""String_Node_Str"");
  pathEnds.setDegreeOfParallelism(noSubTasks);
  MatchContract<PactString,Path,Path,NodePair,Path> concatPaths=new MatchContract<PactString,Path,Path,NodePair,Path>(ConcatPaths.class,""String_Node_Str"");
  concatPaths.setDegreeOfParallelism(noSubTasks);
  CoGroupContract<NodePair,Path,Path,PactNull,Path> findShortestPaths=new CoGroupContract<NodePair,Path,Path,PactNull,Path>(FindShortestPath.class,""String_Node_Str"");
  findShortestPaths.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactNull,Path> result=new DataSinkContract<PactNull,Path>(PathOutFormat.class,output);
  result.setDegreeOfParallelism(noSubTasks);
  result.setInput(findShortestPaths);
  findShortestPaths.setFirstInput(pathsInput);
  findShortestPaths.setSecondInput(concatPaths);
  concatPaths.setFirstInput(pathStarts);
  pathStarts.setInput(pathsInput);
  concatPaths.setSecondInput(pathEnds);
  pathEnds.setInput(pathsInput);
  return new Plan(result,""String_Node_Str"");
}","/** 
 * Assembles the Plan of the All-2-All Shortest Paths example Pact program. The program computes one iteration of the All-2-All Shortest Paths algorithm. For the first iteration, two input formats can be chosen: 1) RDF triples with foaf:knows predicates 2) Text-serialized paths (see PathInFormat and PathOutFormat) To choose 1) set the forth parameter to ""true"". If set to ""false"" 2) will be used.
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String paths=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String output=(args.length > 2 ? args[2] : ""String_Node_Str"");
  boolean rdfInput=(args.length > 3 ? Boolean.parseBoolean(args[3]) : false);
  DataSourceContract<NodePair,Path> pathsInput;
  if (rdfInput) {
    pathsInput=new DataSourceContract<NodePair,Path>(RDFTripleInFormat.class,paths);
  }
 else {
    pathsInput=new DataSourceContract<NodePair,Path>(PathInFormat.class,paths);
  }
  pathsInput.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  pathsInput.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathStarts=new MapContract<NodePair,Path,PactString,Path>(ProjectPathStart.class,""String_Node_Str"");
  pathStarts.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathEnds=new MapContract<NodePair,Path,PactString,Path>(ProjectPathEnd.class,""String_Node_Str"");
  pathEnds.setDegreeOfParallelism(noSubTasks);
  MatchContract<PactString,Path,Path,NodePair,Path> concatPaths=new MatchContract<PactString,Path,Path,NodePair,Path>(ConcatPaths.class,""String_Node_Str"");
  concatPaths.setDegreeOfParallelism(noSubTasks);
  CoGroupContract<NodePair,Path,Path,PactNull,Path> findShortestPaths=new CoGroupContract<NodePair,Path,Path,PactNull,Path>(FindShortestPath.class,""String_Node_Str"");
  findShortestPaths.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactNull,Path> result=new DataSinkContract<PactNull,Path>(PathOutFormat.class,output);
  result.setDegreeOfParallelism(noSubTasks);
  result.setInput(findShortestPaths);
  findShortestPaths.setFirstInput(pathsInput);
  findShortestPaths.setSecondInput(concatPaths);
  concatPaths.setFirstInput(pathStarts);
  pathStarts.setInput(pathsInput);
  concatPaths.setSecondInput(pathEnds);
  pathEnds.setInput(pathsInput);
  return new Plan(result,""String_Node_Str"");
}",0.953326293558606
56216,"/** 
 * Assembles the Plan of the triangle enumeration example Pact program.
 */
@Override public Plan getPlan(String... args){
  if (args.length != 3) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String edgeInput=args[1];
  String output=args[2];
  DataSourceContract<Edge,PactNull> edges=new DataSourceContract<Edge,PactNull>(EdgeListInFormat.class,edgeInput);
  edges.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  edges.setDegreeOfParallelism(noSubTasks);
  edges.setOutputContract(UniqueKey.class);
  MapContract<Edge,PactNull,PactString,Edge> assignKeys=new MapContract<Edge,PactNull,PactString,Edge>(AssignKeys.class,""String_Node_Str"");
  assignKeys.setDegreeOfParallelism(noSubTasks);
  ReduceContract<PactString,Edge,Edge,EdgeList> buildTriads=new ReduceContract<PactString,Edge,Edge,EdgeList>(BuildTriads.class,""String_Node_Str"");
  buildTriads.setDegreeOfParallelism(noSubTasks);
  MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList> closeTriads=new MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList>(CloseTriads.class,""String_Node_Str"");
  closeTriads.setDegreeOfParallelism(noSubTasks);
  closeTriads.getStubParameters().setString(PactCompiler.HINT_LOCAL_STRATEGY,PactCompiler.HINT_LOCAL_STRATEGY_SORT);
  DataSinkContract<PactNull,EdgeList> triangles=new DataSinkContract<PactNull,EdgeList>(EdgeListOutFormat.class,output);
  triangles.setDegreeOfParallelism(noSubTasks);
  triangles.setInput(closeTriads);
  closeTriads.setSecondInput(edges);
  closeTriads.setFirstInput(buildTriads);
  buildTriads.setInput(assignKeys);
  assignKeys.setInput(edges);
  return new Plan(triangles,""String_Node_Str"");
}","/** 
 * Assembles the Plan of the triangle enumeration example Pact program.
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String edgeInput=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String output=(args.length > 2 ? args[2] : ""String_Node_Str"");
  DataSourceContract<Edge,PactNull> edges=new DataSourceContract<Edge,PactNull>(EdgeListInFormat.class,edgeInput);
  edges.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  edges.setDegreeOfParallelism(noSubTasks);
  edges.setOutputContract(UniqueKey.class);
  MapContract<Edge,PactNull,PactString,Edge> assignKeys=new MapContract<Edge,PactNull,PactString,Edge>(AssignKeys.class,""String_Node_Str"");
  assignKeys.setDegreeOfParallelism(noSubTasks);
  ReduceContract<PactString,Edge,Edge,EdgeList> buildTriads=new ReduceContract<PactString,Edge,Edge,EdgeList>(BuildTriads.class,""String_Node_Str"");
  buildTriads.setDegreeOfParallelism(noSubTasks);
  MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList> closeTriads=new MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList>(CloseTriads.class,""String_Node_Str"");
  closeTriads.setDegreeOfParallelism(noSubTasks);
  closeTriads.getStubParameters().setString(PactCompiler.HINT_LOCAL_STRATEGY,PactCompiler.HINT_LOCAL_STRATEGY_SORT);
  DataSinkContract<PactNull,EdgeList> triangles=new DataSinkContract<PactNull,EdgeList>(EdgeListOutFormat.class,output);
  triangles.setDegreeOfParallelism(noSubTasks);
  triangles.setInput(closeTriads);
  closeTriads.setSecondInput(edges);
  closeTriads.setFirstInput(buildTriads);
  buildTriads.setInput(assignKeys);
  assignKeys.setInput(edges);
  return new Plan(triangles,""String_Node_Str"");
}",0.9429657794676806
56217,"/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(final String... args){
  int degreeOfParallelism=1;
  String ordersPath=""String_Node_Str"";
  String lineitemsPath=""String_Node_Str"";
  String resultPath=""String_Node_Str"";
  if (args.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  degreeOfParallelism=Integer.parseInt(args[0]);
  ordersPath=args[1];
  lineitemsPath=args[2];
  resultPath=args[3];
  DataSourceContract<PactInteger,Tuple> orders=new DataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,ordersPath,""String_Node_Str"");
  orders.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  orders.setDegreeOfParallelism(degreeOfParallelism);
  orders.setOutputContract(UniqueKey.class);
  orders.getCompilerHints().setAvgNumValuesPerKey(1);
  DataSourceContract<PactInteger,Tuple> lineitems=new DataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,lineitemsPath,""String_Node_Str"");
  lineitems.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  lineitems.setDegreeOfParallelism(degreeOfParallelism);
  lineitems.getCompilerHints().setAvgNumValuesPerKey(4);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> filterO=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(FilterO.class,""String_Node_Str"");
  filterO.setDegreeOfParallelism(degreeOfParallelism);
  filterO.getCompilerHints().setAvgBytesPerRecord(32);
  filterO.getCompilerHints().setSelectivity(0.05f);
  filterO.getCompilerHints().setAvgNumValuesPerKey(1);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> projectLi=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(ProjectLi.class,""String_Node_Str"");
  projectLi.setDegreeOfParallelism(degreeOfParallelism);
  projectLi.getCompilerHints().setAvgBytesPerRecord(48);
  projectLi.getCompilerHints().setSelectivity(1.0f);
  projectLi.getCompilerHints().setAvgNumValuesPerKey(4);
  MatchContract<PactInteger,Tuple,Tuple,N_IntStringPair,Tuple> joinLiO=new MatchContract<PactInteger,Tuple,Tuple,N_IntStringPair,Tuple>(JoinLiO.class,""String_Node_Str"");
  joinLiO.setDegreeOfParallelism(degreeOfParallelism);
  joinLiO.getCompilerHints().setSelectivity(0.05f);
  joinLiO.getCompilerHints().setAvgBytesPerRecord(64);
  joinLiO.getCompilerHints().setAvgNumValuesPerKey(4);
  ReduceContract<N_IntStringPair,Tuple,PactInteger,Tuple> aggLiO=new ReduceContract<N_IntStringPair,Tuple,PactInteger,Tuple>(AggLiO.class,""String_Node_Str"");
  aggLiO.setDegreeOfParallelism(degreeOfParallelism);
  aggLiO.getCompilerHints().setAvgBytesPerRecord(64);
  aggLiO.getCompilerHints().setSelectivity(0.25f);
  aggLiO.getCompilerHints().setAvgNumValuesPerKey(1);
  DataSinkContract<PactString,Tuple> result=new DataSinkContract<PactString,Tuple>(StringTupleDataOutFormat.class,resultPath,""String_Node_Str"");
  result.setDegreeOfParallelism(degreeOfParallelism);
  result.setInput(aggLiO);
  aggLiO.setInput(joinLiO);
  joinLiO.setFirstInput(filterO);
  filterO.setInput(orders);
  joinLiO.setSecondInput(projectLi);
  projectLi.setInput(lineitems);
  return new Plan(result,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(final String... args){
  int noSubtasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String ordersPath=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String lineitemsPath=(args.length > 2 ? args[2] : ""String_Node_Str"");
  String output=(args.length > 3 ? args[3] : ""String_Node_Str"");
  DataSourceContract<PactInteger,Tuple> orders=new DataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,ordersPath,""String_Node_Str"");
  orders.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  orders.setDegreeOfParallelism(noSubtasks);
  orders.setOutputContract(UniqueKey.class);
  orders.getCompilerHints().setAvgNumValuesPerKey(1);
  DataSourceContract<PactInteger,Tuple> lineitems=new DataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,lineitemsPath,""String_Node_Str"");
  lineitems.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  lineitems.setDegreeOfParallelism(noSubtasks);
  lineitems.getCompilerHints().setAvgNumValuesPerKey(4);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> filterO=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(FilterO.class,""String_Node_Str"");
  filterO.setDegreeOfParallelism(noSubtasks);
  filterO.getCompilerHints().setAvgBytesPerRecord(32);
  filterO.getCompilerHints().setSelectivity(0.05f);
  filterO.getCompilerHints().setAvgNumValuesPerKey(1);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> projectLi=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(ProjectLi.class,""String_Node_Str"");
  projectLi.setDegreeOfParallelism(noSubtasks);
  projectLi.getCompilerHints().setAvgBytesPerRecord(48);
  projectLi.getCompilerHints().setSelectivity(1.0f);
  projectLi.getCompilerHints().setAvgNumValuesPerKey(4);
  MatchContract<PactInteger,Tuple,Tuple,N_IntStringPair,Tuple> joinLiO=new MatchContract<PactInteger,Tuple,Tuple,N_IntStringPair,Tuple>(JoinLiO.class,""String_Node_Str"");
  joinLiO.setDegreeOfParallelism(noSubtasks);
  joinLiO.getCompilerHints().setSelectivity(0.05f);
  joinLiO.getCompilerHints().setAvgBytesPerRecord(64);
  joinLiO.getCompilerHints().setAvgNumValuesPerKey(4);
  ReduceContract<N_IntStringPair,Tuple,PactInteger,Tuple> aggLiO=new ReduceContract<N_IntStringPair,Tuple,PactInteger,Tuple>(AggLiO.class,""String_Node_Str"");
  aggLiO.setDegreeOfParallelism(noSubtasks);
  aggLiO.getCompilerHints().setAvgBytesPerRecord(64);
  aggLiO.getCompilerHints().setSelectivity(0.25f);
  aggLiO.getCompilerHints().setAvgNumValuesPerKey(1);
  DataSinkContract<PactString,Tuple> result=new DataSinkContract<PactString,Tuple>(StringTupleDataOutFormat.class,output,""String_Node_Str"");
  result.setDegreeOfParallelism(noSubtasks);
  result.setInput(aggLiO);
  aggLiO.setInput(joinLiO);
  joinLiO.setFirstInput(filterO);
  filterO.setInput(orders);
  joinLiO.setSecondInput(projectLi);
  projectLi.setInput(lineitems);
  return new Plan(result,""String_Node_Str"");
}",0.8335842114065898
56218,"/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  if (args.length != 5) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String docsInput=args[1];
  String ranksInput=args[2];
  String visitsInput=args[3];
  String output=args[4];
  DataSourceContract<PactString,Tuple> docs=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,docsInput,""String_Node_Str"");
  docs.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  docs.setDegreeOfParallelism(noSubTasks);
  docs.setOutputContract(UniqueKey.class);
  DataSourceContract<PactString,Tuple> ranks=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,ranksInput,""String_Node_Str"");
  ranks.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  ranks.setDegreeOfParallelism(noSubTasks);
  DataSourceContract<PactString,Tuple> visits=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,visitsInput,""String_Node_Str"");
  visits.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  visits.setDegreeOfParallelism(noSubTasks);
  MapContract<PactString,Tuple,PactString,PactNull> filterDocs=new MapContract<PactString,Tuple,PactString,PactNull>(FilterDocs.class,""String_Node_Str"");
  filterDocs.setDegreeOfParallelism(noSubTasks);
  filterDocs.getCompilerHints().setSelectivity(0.15f);
  filterDocs.getCompilerHints().setAvgBytesPerRecord(60);
  MapContract<PactString,Tuple,PactString,Tuple> filterRanks=new MapContract<PactString,Tuple,PactString,Tuple>(FilterRanks.class,""String_Node_Str"");
  filterRanks.setDegreeOfParallelism(noSubTasks);
  filterRanks.getCompilerHints().setSelectivity(0.25f);
  MapContract<PactString,Tuple,PactString,PactNull> filterVisits=new MapContract<PactString,Tuple,PactString,PactNull>(FilterVisits.class,""String_Node_Str"");
  filterVisits.setDegreeOfParallelism(noSubTasks);
  filterVisits.getCompilerHints().setAvgBytesPerRecord(60);
  filterVisits.getCompilerHints().setSelectivity(0.2f);
  MatchContract<PactString,Tuple,PactNull,PactString,Tuple> joinDocsRanks=new MatchContract<PactString,Tuple,PactNull,PactString,Tuple>(JoinDocRanks.class,""String_Node_Str"");
  joinDocsRanks.setDegreeOfParallelism(noSubTasks);
  joinDocsRanks.getCompilerHints().setSelectivity(0.15f);
  CoGroupContract<PactString,PactNull,Tuple,PactString,Tuple> antiJoinVisits=new CoGroupContract<PactString,PactNull,Tuple,PactString,Tuple>(AntiJoinVisits.class,""String_Node_Str"");
  antiJoinVisits.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactString,Tuple> result=new DataSinkContract<PactString,Tuple>(StringTupleDataOutFormat.class,output,""String_Node_Str"");
  result.setDegreeOfParallelism(noSubTasks);
  filterDocs.setInput(docs);
  filterRanks.setInput(ranks);
  filterVisits.setInput(visits);
  joinDocsRanks.setFirstInput(filterRanks);
  joinDocsRanks.setSecondInput(filterDocs);
  antiJoinVisits.setFirstInput(filterVisits);
  antiJoinVisits.setSecondInput(joinDocsRanks);
  result.setInput(antiJoinVisits);
  return new Plan(result,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String docsInput=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String ranksInput=(args.length > 2 ? args[2] : ""String_Node_Str"");
  String visitsInput=(args.length > 3 ? args[3] : ""String_Node_Str"");
  String output=(args.length > 4 ? args[4] : ""String_Node_Str"");
  DataSourceContract<PactString,Tuple> docs=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,docsInput,""String_Node_Str"");
  docs.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  docs.setDegreeOfParallelism(noSubTasks);
  docs.setOutputContract(UniqueKey.class);
  DataSourceContract<PactString,Tuple> ranks=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,ranksInput,""String_Node_Str"");
  ranks.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  ranks.setDegreeOfParallelism(noSubTasks);
  DataSourceContract<PactString,Tuple> visits=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,visitsInput,""String_Node_Str"");
  visits.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  visits.setDegreeOfParallelism(noSubTasks);
  MapContract<PactString,Tuple,PactString,PactNull> filterDocs=new MapContract<PactString,Tuple,PactString,PactNull>(FilterDocs.class,""String_Node_Str"");
  filterDocs.setDegreeOfParallelism(noSubTasks);
  filterDocs.getCompilerHints().setSelectivity(0.15f);
  filterDocs.getCompilerHints().setAvgBytesPerRecord(60);
  MapContract<PactString,Tuple,PactString,Tuple> filterRanks=new MapContract<PactString,Tuple,PactString,Tuple>(FilterRanks.class,""String_Node_Str"");
  filterRanks.setDegreeOfParallelism(noSubTasks);
  filterRanks.getCompilerHints().setSelectivity(0.25f);
  MapContract<PactString,Tuple,PactString,PactNull> filterVisits=new MapContract<PactString,Tuple,PactString,PactNull>(FilterVisits.class,""String_Node_Str"");
  filterVisits.setDegreeOfParallelism(noSubTasks);
  filterVisits.getCompilerHints().setAvgBytesPerRecord(60);
  filterVisits.getCompilerHints().setSelectivity(0.2f);
  MatchContract<PactString,Tuple,PactNull,PactString,Tuple> joinDocsRanks=new MatchContract<PactString,Tuple,PactNull,PactString,Tuple>(JoinDocRanks.class,""String_Node_Str"");
  joinDocsRanks.setDegreeOfParallelism(noSubTasks);
  joinDocsRanks.getCompilerHints().setSelectivity(0.15f);
  CoGroupContract<PactString,PactNull,Tuple,PactString,Tuple> antiJoinVisits=new CoGroupContract<PactString,PactNull,Tuple,PactString,Tuple>(AntiJoinVisits.class,""String_Node_Str"");
  antiJoinVisits.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactString,Tuple> result=new DataSinkContract<PactString,Tuple>(StringTupleDataOutFormat.class,output,""String_Node_Str"");
  result.setDegreeOfParallelism(noSubTasks);
  filterDocs.setInput(docs);
  filterRanks.setInput(ranks);
  filterVisits.setInput(visits);
  joinDocsRanks.setFirstInput(filterRanks);
  joinDocsRanks.setSecondInput(filterDocs);
  antiJoinVisits.setFirstInput(filterVisits);
  antiJoinVisits.setSecondInput(joinDocsRanks);
  result.setInput(antiJoinVisits);
  return new Plan(result,""String_Node_Str"");
}",0.9569707401032702
56219,"/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  if (args.length != 3) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String dataInput=args[1];
  String output=args[2];
  DataSourceContract<PactNull,PactString> data=new DataSourceContract<PactNull,PactString>(LineInFormat.class,dataInput,""String_Node_Str"");
  data.setDegreeOfParallelism(noSubTasks);
  MapContract<PactNull,PactString,PactString,PactInteger> mapper=new MapContract<PactNull,PactString,PactString,PactInteger>(TokenizeLine.class,""String_Node_Str"");
  mapper.setDegreeOfParallelism(noSubTasks);
  ReduceContract<PactString,PactInteger,PactString,PactInteger> reducer=new ReduceContract<PactString,PactInteger,PactString,PactInteger>(CountWords.class,""String_Node_Str"");
  reducer.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactString,PactInteger> out=new DataSinkContract<PactString,PactInteger>(WordCountOutFormat.class,output,""String_Node_Str"");
  out.setDegreeOfParallelism(noSubTasks);
  out.setInput(reducer);
  reducer.setInput(mapper);
  mapper.setInput(data);
  return new Plan(out,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String dataInput=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String output=(args.length > 2 ? args[2] : ""String_Node_Str"");
  DataSourceContract<PactNull,PactString> data=new DataSourceContract<PactNull,PactString>(LineInFormat.class,dataInput,""String_Node_Str"");
  data.setDegreeOfParallelism(noSubTasks);
  MapContract<PactNull,PactString,PactString,PactInteger> mapper=new MapContract<PactNull,PactString,PactString,PactInteger>(TokenizeLine.class,""String_Node_Str"");
  mapper.setDegreeOfParallelism(noSubTasks);
  ReduceContract<PactString,PactInteger,PactString,PactInteger> reducer=new ReduceContract<PactString,PactInteger,PactString,PactInteger>(CountWords.class,""String_Node_Str"");
  reducer.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactString,PactInteger> out=new DataSinkContract<PactString,PactInteger>(WordCountOutFormat.class,output,""String_Node_Str"");
  out.setDegreeOfParallelism(noSubTasks);
  out.setInput(reducer);
  reducer.setInput(mapper);
  mapper.setInput(data);
  return new Plan(out,""String_Node_Str"");
}",0.9186683522966708
56220,"/** 
 * Creates a new channel selector that uses the given strategy (broadcasting, partitioning, ...), using the supplied salt to randomize hashes.
 * @param strategy The distribution strategy to be used.
 * @param salt The salt used to randomize hash values.
 */
public OutputEmitter(ShipStrategy strategy,byte[] salt){
  if (strategy != ShipStrategy.BROADCAST && strategy != ShipStrategy.PARTITION_HASH && strategy != ShipStrategy.NONE) {
    throw new UnsupportedOperationException(""String_Node_Str"" + strategy.name());
  }
  this.strategy=strategy;
  this.salt=salt;
}","/** 
 * Creates a new channel selector that uses the given strategy (broadcasting, partitioning, ...), using the supplied salt to randomize hashes.
 * @param strategy The distribution strategy to be used.
 * @param salt The salt used to randomize hash values.
 */
public OutputEmitter(ShipStrategy strategy,byte[] salt){
  if (strategy != ShipStrategy.BROADCAST && strategy != ShipStrategy.PARTITION_HASH && strategy != ShipStrategy.FORWARD) {
    throw new UnsupportedOperationException(""String_Node_Str"" + strategy.name());
  }
  this.strategy=strategy;
  this.salt=salt;
}",0.992153443766347
56221,"@Override public int[] selectChannels(KeyValuePair<K,V> pair,int numberOfChannels){
switch (strategy) {
case BROADCAST:
    return broadcast(numberOfChannels);
case PARTITION_HASH:
  return partition(pair,numberOfChannels);
case NONE:
return robin(numberOfChannels);
default :
throw new UnsupportedOperationException();
}
}","@Override public int[] selectChannels(KeyValuePair<K,V> pair,int numberOfChannels){
switch (strategy) {
case BROADCAST:
    return broadcast(numberOfChannels);
case PARTITION_HASH:
  return partition(pair,numberOfChannels);
case FORWARD:
return robin(numberOfChannels);
default :
throw new UnsupportedOperationException();
}
}",0.9830508474576272
56222,"/** 
 * Sets the bytes the ID consists of.
 * @param src the bytes the ID consists of
 */
private void setBytes(byte[] src){
  if (src == null) {
    return;
  }
  if (src.length != SIZE) {
    return;
  }
  System.arraycopy(bytes,0,this.bytes,0,SIZE);
}","/** 
 * Sets the bytes the ID consists of.
 * @param src the bytes the ID consists of
 */
private void setBytes(byte[] src){
  if (src == null) {
    return;
  }
  if (src.length != SIZE) {
    return;
  }
  System.arraycopy(src,0,this.bytes,0,SIZE);
}",0.984189723320158
56223,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=this.instanceManager.getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    executionGraph.collectInstanceTypesRequiredForStage(i,requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=this.instanceManager.getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    executionGraph.collectInstanceTypesRequiredForStage(i,requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
}",0.8391912908242612
56224,"void removeJobFromSchedule(ExecutionGraph executionGraphToRemove){
  boolean removedFromQueue=false;
  ;
synchronized (this.jobQueue) {
    final Iterator<ExecutionGraph> it=this.jobQueue.iterator();
    while (it.hasNext()) {
      final ExecutionGraph executionGraph=it.next();
      if (executionGraph.getJobID().equals(executionGraphToRemove.getJobID())) {
        removedFromQueue=true;
        it.remove();
        break;
      }
    }
  }
  if (removedFromQueue) {
    this.schedulingListener.jobRemovedFromScheduler(executionGraphToRemove);
  }
 else {
    LOG.error(""String_Node_Str"" + executionGraphToRemove.getJobName() + ""String_Node_Str""+ executionGraphToRemove.getJobID()+ ""String_Node_Str"");
  }
}","void removeJobFromSchedule(ExecutionGraph executionGraphToRemove){
  boolean removedFromQueue=false;
synchronized (this.jobQueue) {
    final Iterator<ExecutionGraph> it=this.jobQueue.iterator();
    while (it.hasNext()) {
      final ExecutionGraph executionGraph=it.next();
      if (executionGraph.getJobID().equals(executionGraphToRemove.getJobID())) {
        removedFromQueue=true;
        it.remove();
        break;
      }
    }
  }
  if (removedFromQueue) {
    this.schedulingListener.jobRemovedFromScheduler(executionGraphToRemove);
  }
 else {
    LOG.error(""String_Node_Str"" + executionGraphToRemove.getJobName() + ""String_Node_Str""+ executionGraphToRemove.getJobID()+ ""String_Node_Str"");
  }
}",0.9971830985915492
56225,"void removeJobFromSchedule(ExecutionGraph executionGraphToRemove){
  boolean removedFromQueue=false;
  ;
synchronized (this.jobQueue) {
    final Iterator<ExecutionGraph> it=this.jobQueue.iterator();
    while (it.hasNext()) {
      final ExecutionGraph executionGraph=it.next();
      if (executionGraph.getJobID().equals(executionGraphToRemove.getJobID())) {
        removedFromQueue=true;
        it.remove();
        break;
      }
    }
  }
  if (removedFromQueue) {
    this.schedulingListener.jobRemovedFromScheduler(executionGraphToRemove);
  }
 else {
    LOG.error(""String_Node_Str"" + executionGraphToRemove.getJobName() + ""String_Node_Str""+ executionGraphToRemove.getJobID()+ ""String_Node_Str"");
  }
}","void removeJobFromSchedule(ExecutionGraph executionGraphToRemove){
  boolean removedFromQueue=false;
synchronized (this.jobQueue) {
    final Iterator<ExecutionGraph> it=this.jobQueue.iterator();
    while (it.hasNext()) {
      final ExecutionGraph executionGraph=it.next();
      if (executionGraph.getJobID().equals(executionGraphToRemove.getJobID())) {
        removedFromQueue=true;
        it.remove();
        break;
      }
    }
  }
  if (removedFromQueue) {
    this.schedulingListener.jobRemovedFromScheduler(executionGraphToRemove);
  }
 else {
    LOG.error(""String_Node_Str"" + executionGraphToRemove.getJobName() + ""String_Node_Str""+ executionGraphToRemove.getJobID()+ ""String_Node_Str"");
  }
}",0.9971830985915492
56226,"private void createBufferMock(BufferedReader mock,String fileString) throws FileNotFoundException, Exception {
  FileReader reader=new FileReader(fileString);
  whenNew(FileReader.class).withArguments(fileString).thenReturn(reader);
  whenNew(BufferedReader.class).withArguments(reader).thenReturn(mock);
}","private void createBufferMock(BufferedReader mock,String fileString) throws FileNotFoundException, Exception {
  whenNew(FileReader.class).withArguments(fileString).thenReturn(this.fileReaderMock);
  whenNew(BufferedReader.class).withArguments(this.fileReaderMock).thenReturn(mock);
}",0.6644067796610169
56227,"public boolean isAnySuccessorIOBottleneck(Map<ManagementGroupEdge,Boolean> successorIOBottleneckMap){
  Boolean anySuccessorIsIOBottleneck=successorIOBottleneckMap.get(this.managementGroupEdge);
  if (anySuccessorIsIOBottleneck == null) {
    final ManagementGroupVertex groupVertex=this.managementGroupEdge.getTarget();
    for (int i=0; i < groupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupEdge successorEdge=groupVertex.getForwardEdge(i);
      final GroupEdgeVisualizationData groupEdgeVisualizationData=(GroupEdgeVisualizationData)successorEdge.getAttachment();
      groupEdgeVisualizationData.updateIOBottleneckFlag(successorIOBottleneckMap);
      if (groupEdgeVisualizationData.isIOBottleneck() || groupEdgeVisualizationData.isAnySuccessorIOBottleneck(successorIOBottleneckMap)) {
        successorIOBottleneckMap.put(this.managementGroupEdge,new Boolean(true));
        return true;
      }
    }
    successorIOBottleneckMap.put(this.managementGroupEdge,new Boolean(false));
    return false;
  }
  return anySuccessorIsIOBottleneck.booleanValue();
}","public boolean isAnySuccessorIOBottleneck(Map<ManagementGroupEdge,Boolean> successorIOBottleneckMap){
  Boolean anySuccessorIsIOBottleneck=successorIOBottleneckMap.get(this.managementGroupEdge);
  if (anySuccessorIsIOBottleneck == null) {
    final ManagementGroupVertex groupVertex=this.managementGroupEdge.getTarget();
    for (int i=0; i < groupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupEdge successorEdge=groupVertex.getForwardEdge(i);
      final GroupEdgeVisualizationData groupEdgeVisualizationData=(GroupEdgeVisualizationData)successorEdge.getAttachment();
      groupEdgeVisualizationData.updateIOBottleneckFlag(successorIOBottleneckMap);
      if (groupEdgeVisualizationData.isIOBottleneck() || groupEdgeVisualizationData.isAnySuccessorIOBottleneck(successorIOBottleneckMap)) {
        successorIOBottleneckMap.put(this.managementGroupEdge,Boolean.valueOf(true));
        return true;
      }
    }
    successorIOBottleneckMap.put(this.managementGroupEdge,Boolean.valueOf(false));
    return false;
  }
  return anySuccessorIsIOBottleneck.booleanValue();
}",0.9761248852157944
56228,"public boolean isAnySuccessorCPUBottleneck(Map<ManagementGroupVertex,Boolean> successorCPUBottleneckMap){
  Boolean anySuccessorIsCPUBottleneck=successorCPUBottleneckMap.get(this.managementGroupVertex);
  if (anySuccessorIsCPUBottleneck == null) {
    for (int i=0; i < this.managementGroupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupVertex targetVertex=this.managementGroupVertex.getForwardEdge(i).getTarget();
      final GroupVertexVisualizationData groupVertexVisualizationData=(GroupVertexVisualizationData)targetVertex.getAttachment();
      groupVertexVisualizationData.updateCPUBottleneckFlag(successorCPUBottleneckMap);
      if (groupVertexVisualizationData.isCPUBottleneck() || groupVertexVisualizationData.isAnySuccessorCPUBottleneck(successorCPUBottleneckMap)) {
        successorCPUBottleneckMap.put(this.managementGroupVertex,new Boolean(true));
        return true;
      }
    }
    successorCPUBottleneckMap.put(this.managementGroupVertex,new Boolean(false));
    return false;
  }
  return anySuccessorIsCPUBottleneck.booleanValue();
}","public boolean isAnySuccessorCPUBottleneck(Map<ManagementGroupVertex,Boolean> successorCPUBottleneckMap){
  Boolean anySuccessorIsCPUBottleneck=successorCPUBottleneckMap.get(this.managementGroupVertex);
  if (anySuccessorIsCPUBottleneck == null) {
    for (int i=0; i < this.managementGroupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupVertex targetVertex=this.managementGroupVertex.getForwardEdge(i).getTarget();
      final GroupVertexVisualizationData groupVertexVisualizationData=(GroupVertexVisualizationData)targetVertex.getAttachment();
      groupVertexVisualizationData.updateCPUBottleneckFlag(successorCPUBottleneckMap);
      if (groupVertexVisualizationData.isCPUBottleneck() || groupVertexVisualizationData.isAnySuccessorCPUBottleneck(successorCPUBottleneckMap)) {
        successorCPUBottleneckMap.put(this.managementGroupVertex,Boolean.valueOf(true));
        return true;
      }
    }
    successorCPUBottleneckMap.put(this.managementGroupVertex,Boolean.valueOf(false));
    return false;
  }
  return anySuccessorIsCPUBottleneck.booleanValue();
}",0.9759704251386322
56229,"private final double toMBitPerSec(long numberOfBytes,long profilingPeriod){
  return ((double)numberOfBytes / (BYTE_TO_MEGABIT * profilingPeriod / 1000));
}","private final double toMBitPerSec(long numberOfBytes,long profilingPeriod){
  return (((double)numberOfBytes) / ((double)(BYTE_TO_MEGABIT * profilingPeriod / 1000L)));
}",0.96
56230,"private Map<ManagementGroupVertex,SWTGroupVertex> addGroupVertices(Map<ManagementStage,SWTStage> stageMap){
  Map<ManagementGroupVertex,SWTGroupVertex> groupMap=new HashMap<ManagementGroupVertex,SWTGroupVertex>();
  Iterator<ManagementStage> iterator=stageMap.keySet().iterator();
  while (iterator.hasNext()) {
    final ManagementStage managementStage=iterator.next();
    final SWTStage parent=stageMap.get(managementStage);
    for (int i=0; i < managementStage.getNumberOfGroupVertices(); i++) {
      final ManagementGroupVertex groupVertex=managementStage.getGroupVertex(i);
      final SWTGroupVertex visualGroupVertex=new SWTGroupVertex(parent,groupVertex);
      groupMap.put(groupVertex,visualGroupVertex);
    }
  }
  iterator=stageMap.keySet().iterator();
  while (iterator.hasNext()) {
    final ManagementStage executionStage=iterator.next();
    for (int i=0; i < executionStage.getNumberOfGroupVertices(); i++) {
      final ManagementGroupVertex sourceVertex=executionStage.getGroupVertex(i);
      final SWTGroupVertex sourceGroupVertex=groupMap.get(sourceVertex);
      for (int j=0; j < sourceVertex.getNumberOfForwardEdges(); j++) {
        final ManagementGroupEdge edge=sourceVertex.getForwardEdge(j);
        final ManagementGroupVertex targetVertex=edge.getTarget();
        final SWTGroupVertex targetGroupVertex=groupMap.get(targetVertex);
        sourceGroupVertex.connectTo(targetGroupVertex);
      }
    }
  }
  return groupMap;
}","private Map<ManagementGroupVertex,SWTGroupVertex> addGroupVertices(Map<ManagementStage,SWTStage> stageMap){
  Map<ManagementGroupVertex,SWTGroupVertex> groupMap=new HashMap<ManagementGroupVertex,SWTGroupVertex>();
  Iterator<Map.Entry<ManagementStage,SWTStage>> iterator=stageMap.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<ManagementStage,SWTStage> entry=iterator.next();
    final ManagementStage managementStage=entry.getKey();
    final SWTStage parent=entry.getValue();
    for (int i=0; i < managementStage.getNumberOfGroupVertices(); i++) {
      final ManagementGroupVertex groupVertex=managementStage.getGroupVertex(i);
      final SWTGroupVertex visualGroupVertex=new SWTGroupVertex(parent,groupVertex);
      groupMap.put(groupVertex,visualGroupVertex);
    }
  }
  iterator=stageMap.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<ManagementStage,SWTStage> entry=iterator.next();
    final ManagementStage executionStage=entry.getKey();
    for (int i=0; i < executionStage.getNumberOfGroupVertices(); i++) {
      final ManagementGroupVertex sourceVertex=executionStage.getGroupVertex(i);
      final SWTGroupVertex sourceGroupVertex=groupMap.get(sourceVertex);
      for (int j=0; j < sourceVertex.getNumberOfForwardEdges(); j++) {
        final ManagementGroupEdge edge=sourceVertex.getForwardEdge(j);
        final ManagementGroupVertex targetVertex=edge.getTarget();
        final SWTGroupVertex targetGroupVertex=groupMap.get(targetVertex);
        sourceGroupVertex.connectTo(targetGroupVertex);
      }
    }
  }
  return groupMap;
}",0.8629111038749593
56231,"@Override public void layout(){
  if (this.networkNode.isLeafNode()) {
    if (LEAFNODEIMAGE != null) {
      this.imageScaleFactor=(float)(this.rect.height - TEXTBOXHEIGHT) / (float)LEAFNODEIMAGERECT.height;
    }
  }
 else {
    if (NODEIMAGE != null) {
      this.imageScaleFactor=(float)(this.rect.height - TEXTBOXHEIGHT) / (float)NODEIMAGERECT.height;
    }
  }
}","@Override public void layout(){
  if (this.networkNode.isLeafNode()) {
    if (this.leafNodeImage != null) {
      this.imageScaleFactor=(float)(this.rect.height - TEXTBOXHEIGHT) / (float)this.leafNodeImageRect.height;
    }
  }
 else {
    if (this.nodeImage != null) {
      this.imageScaleFactor=(float)(this.rect.height - TEXTBOXHEIGHT) / (float)this.nodeImageRect.height;
    }
  }
}",0.8465608465608465
56232,"@Override protected void paintInternal(GC gc,Device device){
  if (this.parentNode != null) {
    gc.drawLine(this.rect.x + (rect.width / 2),this.rect.y + (this.rect.height - TEXTBOXHEIGHT) / 2,this.parentNode.getX() + (this.parentNode.getWidth() / 2),this.parentNode.getY() + this.parentNode.getHeight());
  }
  if (this.networkNode.isLeafNode()) {
    if (LEAFNODEIMAGE != null) {
      final int destHeight=(int)((float)LEAFNODEIMAGERECT.height * imageScaleFactor);
      final int destWidth=(int)((float)LEAFNODEIMAGERECT.width * imageScaleFactor);
      final int destX=this.rect.x + (this.rect.width - destWidth) / 2;
      final int destY=this.rect.y + ((this.rect.height - TEXTBOXHEIGHT) - destHeight) / 2;
      gc.drawImage(LEAFNODEIMAGE,LEAFNODEIMAGERECT.x,LEAFNODEIMAGERECT.y,LEAFNODEIMAGERECT.width,LEAFNODEIMAGERECT.height,destX,destY,destWidth,destHeight);
    }
  }
 else {
    if (NODEIMAGE != null) {
      final int destHeight=(int)((float)NODEIMAGERECT.height * imageScaleFactor);
      final int destWidth=(int)((float)NODEIMAGERECT.width * imageScaleFactor);
      final int destX=this.rect.x + (this.rect.width - destWidth) / 2;
      final int destY=this.rect.y + ((this.rect.height - TEXTBOXHEIGHT) - destHeight) / 2;
      gc.drawImage(NODEIMAGE,NODEIMAGERECT.x,NODEIMAGERECT.y,NODEIMAGERECT.width,NODEIMAGERECT.height,destX,destY,destWidth,destHeight);
    }
  }
  String name=this.networkNode.getName();
  Point pt=gc.textExtent(name);
  boolean cropped=false;
  while (pt.x > this.rect.width) {
    cropped=true;
    name=name.substring(0,name.length() - 1);
    pt=gc.textExtent(name + ""String_Node_Str"");
  }
  if (cropped) {
    name+=""String_Node_Str"";
  }
  gc.setBackground(ColorScheme.getNetworkNodeBackgroundColor(device));
  gc.fillRectangle(this.rect.x + (this.rect.width - pt.x) / 2 - TEXTBOXSPACING,this.rect.y + this.rect.height - TEXTBOXHEIGHT,pt.x + (2 * TEXTBOXSPACING),TEXTBOXHEIGHT);
  gc.setForeground(ColorScheme.getNetworkNodeBorderColor(device));
  gc.drawRectangle(this.rect.x + (this.rect.width - pt.x) / 2 - TEXTBOXSPACING,this.rect.y + this.rect.height - TEXTBOXHEIGHT,pt.x + (2 * TEXTBOXSPACING),TEXTBOXHEIGHT);
  gc.setForeground(ColorScheme.getNetworkNodeBorderColor(device));
  final int textX=this.rect.x + ((this.rect.width - pt.x) / 2);
  final int textY=this.rect.y + this.rect.height - TEXTBOXHEIGHT + ((TEXTBOXHEIGHT - pt.y) / 2);
  gc.drawText(name,textX,textY);
}","@Override protected void paintInternal(GC gc,Device device){
  if (this.parentNode != null) {
    gc.drawLine(this.rect.x + (rect.width / 2),this.rect.y + (this.rect.height - TEXTBOXHEIGHT) / 2,this.parentNode.getX() + (this.parentNode.getWidth() / 2),this.parentNode.getY() + this.parentNode.getHeight());
  }
  if (this.networkNode.isLeafNode()) {
    if (this.leafNodeImage != null) {
      final int destHeight=(int)((float)this.leafNodeImageRect.height * imageScaleFactor);
      final int destWidth=(int)((float)this.leafNodeImageRect.width * imageScaleFactor);
      final int destX=this.rect.x + (this.rect.width - destWidth) / 2;
      final int destY=this.rect.y + ((this.rect.height - TEXTBOXHEIGHT) - destHeight) / 2;
      gc.drawImage(this.leafNodeImage,this.leafNodeImageRect.x,this.leafNodeImageRect.y,this.leafNodeImageRect.width,this.leafNodeImageRect.height,destX,destY,destWidth,destHeight);
    }
  }
 else {
    if (this.nodeImage != null) {
      final int destHeight=(int)((float)this.nodeImageRect.height * imageScaleFactor);
      final int destWidth=(int)((float)this.nodeImageRect.width * imageScaleFactor);
      final int destX=this.rect.x + (this.rect.width - destWidth) / 2;
      final int destY=this.rect.y + ((this.rect.height - TEXTBOXHEIGHT) - destHeight) / 2;
      gc.drawImage(this.nodeImage,this.nodeImageRect.x,this.nodeImageRect.y,this.nodeImageRect.width,this.nodeImageRect.height,destX,destY,destWidth,destHeight);
    }
  }
  String name=this.networkNode.getName();
  Point pt=gc.textExtent(name);
  boolean cropped=false;
  while (pt.x > this.rect.width) {
    cropped=true;
    name=name.substring(0,name.length() - 1);
    pt=gc.textExtent(name + ""String_Node_Str"");
  }
  if (cropped) {
    name+=""String_Node_Str"";
  }
  gc.setBackground(ColorScheme.getNetworkNodeBackgroundColor(device));
  gc.fillRectangle(this.rect.x + (this.rect.width - pt.x) / 2 - TEXTBOXSPACING,this.rect.y + this.rect.height - TEXTBOXHEIGHT,pt.x + (2 * TEXTBOXSPACING),TEXTBOXHEIGHT);
  gc.setForeground(ColorScheme.getNetworkNodeBorderColor(device));
  gc.drawRectangle(this.rect.x + (this.rect.width - pt.x) / 2 - TEXTBOXSPACING,this.rect.y + this.rect.height - TEXTBOXHEIGHT,pt.x + (2 * TEXTBOXSPACING),TEXTBOXHEIGHT);
  gc.setForeground(ColorScheme.getNetworkNodeBorderColor(device));
  final int textX=this.rect.x + ((this.rect.width - pt.x) / 2);
  final int textY=this.rect.y + this.rect.height - TEXTBOXHEIGHT + ((TEXTBOXHEIGHT - pt.y) / 2);
  gc.drawText(name,textX,textY);
}",0.8696356275303644
56233,"public SWTNetworkNode(Display display,AbstractSWTComponent parentComponent,NetworkNode networkNode){
  super(parentComponent);
  this.networkNode=networkNode;
  if (LEAFNODEIMAGE == null) {
    InputStream in=getClass().getResourceAsStream(""String_Node_Str"");
    try {
      LEAFNODEIMAGE=new Image(display,in);
      LEAFNODEIMAGERECT=LEAFNODEIMAGE.getBounds();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (NODEIMAGE == null) {
    InputStream in=getClass().getResourceAsStream(""String_Node_Str"");
    try {
      NODEIMAGE=new Image(display,in);
      NODEIMAGERECT=NODEIMAGE.getBounds();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","public SWTNetworkNode(Display display,AbstractSWTComponent parentComponent,NetworkNode networkNode){
  super(parentComponent);
  this.networkNode=networkNode;
synchronized (SWTNetworkNode.class) {
    if (LEAFNODEIMAGE == null) {
      InputStream in=getClass().getResourceAsStream(""String_Node_Str"");
      try {
        LEAFNODEIMAGE=new Image(display,in);
        LEAFNODEIMAGERECT=LEAFNODEIMAGE.getBounds();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    this.leafNodeImage=LEAFNODEIMAGE;
    this.leafNodeImageRect=LEAFNODEIMAGERECT;
    if (NODEIMAGE == null) {
      InputStream in=getClass().getResourceAsStream(""String_Node_Str"");
      try {
        NODEIMAGE=new Image(display,in);
        NODEIMAGERECT=NODEIMAGE.getBounds();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    this.nodeImage=NODEIMAGE;
    this.nodeImageRect=NODEIMAGERECT;
  }
}",0.8545006165228114
56234,"private SWTNetworkTopology createSWTNetworkTopology(NetworkTopology networkTopology){
  final SWTNetworkTopology swtNetworkTopology=new SWTNetworkTopology(networkTopology);
  final Map<NetworkNode,SWTNetworkNode> nodeMap=new HashMap<NetworkNode,SWTNetworkNode>();
  Iterator<NetworkNode> it=networkTopology.iterator();
  while (it.hasNext()) {
    final NetworkNode networkNode=it.next();
    final SWTNetworkNode swtNetworkNode=new SWTNetworkNode(getDisplay(),swtNetworkTopology,networkNode);
    swtNetworkTopology.addChild(swtNetworkNode);
    nodeMap.put(networkNode,swtNetworkNode);
    if (networkNode.getParentNode() == null) {
      swtNetworkTopology.setRootNode(swtNetworkNode);
    }
  }
  it=nodeMap.keySet().iterator();
  while (it.hasNext()) {
    final NetworkNode childNode=it.next();
    final NetworkNode parentNode=childNode.getParentNode();
    if (parentNode != null) {
      final SWTNetworkNode swtChildNode=nodeMap.get(childNode);
      final SWTNetworkNode swtParentNode=nodeMap.get(parentNode);
      swtChildNode.setParentNode(swtParentNode);
    }
  }
  return swtNetworkTopology;
}","private SWTNetworkTopology createSWTNetworkTopology(NetworkTopology networkTopology){
  final SWTNetworkTopology swtNetworkTopology=new SWTNetworkTopology(networkTopology);
  final Map<NetworkNode,SWTNetworkNode> nodeMap=new HashMap<NetworkNode,SWTNetworkNode>();
  final Iterator<NetworkNode> it=networkTopology.iterator();
  while (it.hasNext()) {
    final NetworkNode networkNode=it.next();
    final SWTNetworkNode swtNetworkNode=new SWTNetworkNode(getDisplay(),swtNetworkTopology,networkNode);
    swtNetworkTopology.addChild(swtNetworkNode);
    nodeMap.put(networkNode,swtNetworkNode);
    if (networkNode.getParentNode() == null) {
      swtNetworkTopology.setRootNode(swtNetworkNode);
    }
  }
  final Iterator<Map.Entry<NetworkNode,SWTNetworkNode>> it2=nodeMap.entrySet().iterator();
  while (it2.hasNext()) {
    final Map.Entry<NetworkNode,SWTNetworkNode> entry=it2.next();
    final NetworkNode childNode=entry.getKey();
    final NetworkNode parentNode=childNode.getParentNode();
    if (parentNode != null) {
      final SWTNetworkNode swtChildNode=entry.getValue();
      final SWTNetworkNode swtParentNode=nodeMap.get(parentNode);
      swtChildNode.setParentNode(swtParentNode);
    }
  }
  return swtNetworkTopology;
}",0.9127288207747978
56235,"/** 
 * Starts a new discovery service.
 * @param ipcPort the network port that is announced for the job manager's IPC service.
 * @throws DiscoveryException thrown if the discovery service could not be started because of network difficulties
 */
public static void startDiscoveryService(int ipcPort) throws DiscoveryException {
  if (discoveryService == null) {
    discoveryService=new DiscoveryService(ipcPort);
    discoveryService.startService();
  }
}","/** 
 * Starts a new discovery service.
 * @param ipcPort the network port that is announced for the job manager's IPC service.
 * @throws DiscoveryException thrown if the discovery service could not be started because of network difficulties
 */
public static synchronized void startDiscoveryService(int ipcPort) throws DiscoveryException {
  if (discoveryService == null) {
    discoveryService=new DiscoveryService(ipcPort);
    discoveryService.startService();
  }
}",0.9859762675296656
56236,"/** 
 * Stops the discovery service.
 */
public static void stopDiscoveryService(){
  if (discoveryService != null) {
    discoveryService.stopService();
  }
}","/** 
 * Stops the discovery service.
 */
public static synchronized void stopDiscoveryService(){
  if (discoveryService != null) {
    discoveryService.stopService();
  }
}",0.9607250755287008
56237,"public void repairStages(){
  final Map<ExecutionGroupVertex,Integer> stageNumbers=new HashMap<ExecutionGroupVertex,Integer>();
  ExecutionGroupVertexIterator it=new ExecutionGroupVertexIterator(this,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    int precedingNumber=0;
    if (stageNumbers.containsKey(groupVertex)) {
      precedingNumber=stageNumbers.get(groupVertex).intValue();
    }
 else {
      stageNumbers.put(groupVertex,new Integer(precedingNumber));
    }
    for (int i=0; i < groupVertex.getNumberOfForwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getForwardEdge(i);
      if (!stageNumbers.containsKey(edge.getTargetVertex())) {
        if (edge.getChannelType() != ChannelType.FILE) {
          stageNumbers.put(edge.getTargetVertex(),new Integer(precedingNumber));
        }
 else {
          stageNumbers.put(edge.getTargetVertex(),new Integer(precedingNumber + 1));
        }
      }
 else {
        final int stageNumber=stageNumbers.get(edge.getTargetVertex()).intValue();
        if (edge.getChannelType() != ChannelType.FILE) {
          if (stageNumber != precedingNumber) {
            stageNumbers.put(edge.getTargetVertex(),(int)Math.max(precedingNumber,stageNumber));
          }
        }
 else {
          if (stageNumber != (precedingNumber + 1)) {
            stageNumbers.put(edge.getTargetVertex(),(int)Math.max(precedingNumber + 1,stageNumber));
          }
        }
      }
    }
  }
  it=new ExecutionGroupVertexIterator(this,false,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final int succeedingNumber=stageNumbers.get(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfBackwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getBackwardEdge(i);
      final int stageNumber=stageNumbers.get(edge.getSourceVertex());
      if (edge.getChannelType() == ChannelType.FILE) {
        if (stageNumber < (succeedingNumber - 1)) {
          stageNumbers.put(edge.getSourceVertex(),new Integer(succeedingNumber - 1));
        }
      }
 else {
        if (stageNumber != succeedingNumber) {
          LOG.error(edge.getSourceVertex() + ""String_Node_Str"" + edge.getTargetVertex()+ ""String_Node_Str"");
        }
      }
    }
  }
  this.stages.clear();
  final Iterator<ExecutionGroupVertex> it2=stageNumbers.keySet().iterator();
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    final int stageNumber=stageNumbers.get(groupVertex).intValue();
    while (this.stages.size() <= stageNumber) {
      this.stages.add(null);
    }
    ExecutionStage executionStage=this.stages.get(stageNumber);
    if (executionStage == null) {
      executionStage=new ExecutionStage(stageNumber);
      this.stages.set(stageNumber,executionStage);
    }
    executionStage.addStageMember(groupVertex);
    groupVertex.setExecutionStage(executionStage);
  }
}","public void repairStages(){
  final Map<ExecutionGroupVertex,Integer> stageNumbers=new HashMap<ExecutionGroupVertex,Integer>();
  ExecutionGroupVertexIterator it=new ExecutionGroupVertexIterator(this,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    int precedingNumber=0;
    if (stageNumbers.containsKey(groupVertex)) {
      precedingNumber=stageNumbers.get(groupVertex).intValue();
    }
 else {
      stageNumbers.put(groupVertex,Integer.valueOf(precedingNumber));
    }
    for (int i=0; i < groupVertex.getNumberOfForwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getForwardEdge(i);
      if (!stageNumbers.containsKey(edge.getTargetVertex())) {
        if (edge.getChannelType() != ChannelType.FILE) {
          stageNumbers.put(edge.getTargetVertex(),Integer.valueOf(precedingNumber));
        }
 else {
          stageNumbers.put(edge.getTargetVertex(),Integer.valueOf(precedingNumber + 1));
        }
      }
 else {
        final int stageNumber=stageNumbers.get(edge.getTargetVertex()).intValue();
        if (edge.getChannelType() != ChannelType.FILE) {
          if (stageNumber != precedingNumber) {
            stageNumbers.put(edge.getTargetVertex(),(int)Math.max(precedingNumber,stageNumber));
          }
        }
 else {
          if (stageNumber != (precedingNumber + 1)) {
            stageNumbers.put(edge.getTargetVertex(),(int)Math.max(precedingNumber + 1,stageNumber));
          }
        }
      }
    }
  }
  it=new ExecutionGroupVertexIterator(this,false,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final int succeedingNumber=stageNumbers.get(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfBackwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getBackwardEdge(i);
      final int stageNumber=stageNumbers.get(edge.getSourceVertex());
      if (edge.getChannelType() == ChannelType.FILE) {
        if (stageNumber < (succeedingNumber - 1)) {
          stageNumbers.put(edge.getSourceVertex(),Integer.valueOf(succeedingNumber - 1));
        }
      }
 else {
        if (stageNumber != succeedingNumber) {
          LOG.error(edge.getSourceVertex() + ""String_Node_Str"" + edge.getTargetVertex()+ ""String_Node_Str"");
        }
      }
    }
  }
  this.stages.clear();
  final Iterator<Map.Entry<ExecutionGroupVertex,Integer>> it2=stageNumbers.entrySet().iterator();
  while (it2.hasNext()) {
    final Map.Entry<ExecutionGroupVertex,Integer> entry=it2.next();
    final ExecutionGroupVertex groupVertex=entry.getKey();
    final int stageNumber=entry.getValue().intValue();
    while (this.stages.size() <= stageNumber) {
      this.stages.add(null);
    }
    ExecutionStage executionStage=this.stages.get(stageNumber);
    if (executionStage == null) {
      executionStage=new ExecutionStage(stageNumber);
      this.stages.set(stageNumber,executionStage);
    }
    executionStage.addStageMember(groupVertex);
    groupVertex.setExecutionStage(executionStage);
  }
}",0.9595046854083
56238,"/** 
 * Applies the user defined settings to the execution graph.
 * @param temporaryGroupVertexMap mapping between job vertices and the corresponding group vertices.
 * @throws GraphConversionException thrown if an error occurs while applying the user settings.
 */
private void applyUserDefinedSettings(HashMap<AbstractJobVertex,ExecutionGroupVertex> temporaryGroupVertexMap) throws GraphConversionException {
  Iterator<AbstractJobVertex> it=temporaryGroupVertexMap.keySet().iterator();
  while (it.hasNext()) {
    final AbstractJobVertex jobVertex=it.next();
    if (jobVertex.getVertexToShareInstancesWith() != null) {
      final AbstractJobVertex vertexToShareInstancesWith=jobVertex.getVertexToShareInstancesWith();
      final ExecutionGroupVertex groupVertex=temporaryGroupVertexMap.get(jobVertex);
      final ExecutionGroupVertex groupVertexToShareInstancesWith=temporaryGroupVertexMap.get(vertexToShareInstancesWith);
      groupVertex.shareInstancesWith(groupVertexToShareInstancesWith);
    }
  }
  Iterator<ExecutionGroupVertex> it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    if (groupVertex.isNumberOfMembersUserDefined()) {
      groupVertex.changeNumberOfGroupMembers(groupVertex.getUserDefinedNumberOfMembers());
    }
  }
  repairInstanceAssignment();
  it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    for (int i=0; i < groupVertex.getNumberOfForwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getForwardEdge(i);
      if (edge.isChannelTypeUserDefined()) {
        edge.changeChannelType(edge.getChannelType());
      }
      if (edge.isCompressionLevelUserDefined()) {
        edge.changeCompressionLevel(edge.getCompressionLevel());
      }
    }
  }
  it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    if (groupVertex.getVertexToShareInstancesWith() == null) {
      groupVertex.reassignInstances();
      this.repairInstanceAssignment();
    }
  }
}","/** 
 * Applies the user defined settings to the execution graph.
 * @param temporaryGroupVertexMap mapping between job vertices and the corresponding group vertices.
 * @throws GraphConversionException thrown if an error occurs while applying the user settings.
 */
private void applyUserDefinedSettings(HashMap<AbstractJobVertex,ExecutionGroupVertex> temporaryGroupVertexMap) throws GraphConversionException {
  final Iterator<Map.Entry<AbstractJobVertex,ExecutionGroupVertex>> it=temporaryGroupVertexMap.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<AbstractJobVertex,ExecutionGroupVertex> entry=it.next();
    final AbstractJobVertex jobVertex=entry.getKey();
    if (jobVertex.getVertexToShareInstancesWith() != null) {
      final AbstractJobVertex vertexToShareInstancesWith=jobVertex.getVertexToShareInstancesWith();
      final ExecutionGroupVertex groupVertex=entry.getValue();
      final ExecutionGroupVertex groupVertexToShareInstancesWith=temporaryGroupVertexMap.get(vertexToShareInstancesWith);
      groupVertex.shareInstancesWith(groupVertexToShareInstancesWith);
    }
  }
  Iterator<ExecutionGroupVertex> it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    if (groupVertex.isNumberOfMembersUserDefined()) {
      groupVertex.changeNumberOfGroupMembers(groupVertex.getUserDefinedNumberOfMembers());
    }
  }
  repairInstanceAssignment();
  it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    for (int i=0; i < groupVertex.getNumberOfForwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getForwardEdge(i);
      if (edge.isChannelTypeUserDefined()) {
        edge.changeChannelType(edge.getChannelType());
      }
      if (edge.isCompressionLevelUserDefined()) {
        edge.changeCompressionLevel(edge.getCompressionLevel());
      }
    }
  }
  it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    if (groupVertex.getVertexToShareInstancesWith() == null) {
      groupVertex.reassignInstances();
      this.repairInstanceAssignment();
    }
  }
}",0.95750452079566
56239,"/** 
 * Changes the channel type for this edge.
 * @param newChannelType the channel type for this edge
 * @throws GraphConversionException thrown if the new channel type violates a user setting
 */
public synchronized void changeChannelType(ChannelType newChannelType) throws GraphConversionException {
  if (!this.channelType.equals(newChannelType) && this.userDefinedChannelType) {
    throw new GraphConversionException(""String_Node_Str"");
  }
  final List<ExecutionGroupEdge> edges=this.getSourceVertex().getForwardEdges(this.getTargetVertex());
  final Iterator<ExecutionGroupEdge> it=edges.iterator();
  while (it.hasNext()) {
    final ExecutionGroupEdge edge=it.next();
    this.executionGraph.unwire(edge.sourceVertex,edge.indexOfOutputGate,edge.targetVertex,edge.indexOfInputGate);
    this.executionGraph.wire(edge.sourceVertex,edge.indexOfOutputGate,edge.targetVertex,edge.indexOfInputGate,newChannelType,edge.compressionLevel);
    edge.channelType=newChannelType;
  }
  this.executionGraph.repairStages();
  this.executionGraph.repairInstanceAssignment();
}","/** 
 * Changes the channel type for this edge.
 * @param newChannelType the channel type for this edge
 * @throws GraphConversionException thrown if the new channel type violates a user setting
 */
public synchronized void changeChannelType(ChannelType newChannelType) throws GraphConversionException {
  if (!this.channelType.equals(newChannelType) && this.userDefinedChannelType) {
    throw new GraphConversionException(""String_Node_Str"");
  }
  final List<ExecutionGroupEdge> edges=this.getSourceVertex().getForwardEdges(this.getTargetVertex());
  final Iterator<ExecutionGroupEdge> it=edges.iterator();
  while (it.hasNext()) {
    final ExecutionGroupEdge edge=it.next();
    CompressionLevel cl=null;
synchronized (edge) {
      edge.channelType=newChannelType;
      cl=edge.compressionLevel;
    }
    this.executionGraph.unwire(edge.sourceVertex,edge.indexOfOutputGate,edge.targetVertex,edge.indexOfInputGate);
    this.executionGraph.wire(edge.sourceVertex,edge.indexOfOutputGate,edge.targetVertex,edge.indexOfInputGate,newChannelType,cl);
  }
  this.executionGraph.repairStages();
  this.executionGraph.repairInstanceAssignment();
}",0.8326567433468651
56240,"/** 
 * Returns the number of the stage this group vertex belongs to.
 * @return the number of the stage this group vertex belongs to
 */
public int getStageNumber(){
  ExecutionStage executionStage=null;
synchronized (this.executionStage) {
    executionStage=this.executionStage;
  }
  return executionStage.getStageNumber();
}","/** 
 * Returns the number of the stage this group vertex belongs to.
 * @return the number of the stage this group vertex belongs to
 */
public int getStageNumber(){
  ExecutionStage executionStage=null;
synchronized (this) {
    executionStage=this.executionStage;
  }
  return executionStage.getStageNumber();
}",0.9766718506998444
56241,"/** 
 * Deploys and starts the task represented by this vertex on the assigned instance.
 * @return the result of the task submission attempt
 */
public TaskSubmissionResult startTask(){
  AllocatedResource allocatedRes=null;
synchronized (this) {
    if (this.allocatedResource == null) {
      final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
      result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
      return result;
    }
    try {
      prepareChannels();
    }
 catch (    ChannelSetupException e) {
      final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
      result.setDescription(StringUtils.stringifyException(e));
      return result;
    }
    allocatedRes=this.allocatedResource;
  }
  try {
    return allocatedRes.getInstance().submitTask(this.vertexID,this.executionGraph.getJobConfiguration(),this.environment);
  }
 catch (  IOException e) {
    final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
    result.setDescription(StringUtils.stringifyException(e));
    return result;
  }
}","/** 
 * Deploys and starts the task represented by this vertex on the assigned instance.
 * @return the result of the task submission attempt
 */
public TaskSubmissionResult startTask(){
  AllocatedResource allocatedRes=null;
  Environment env=null;
synchronized (this) {
    if (this.allocatedResource == null) {
      final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
      result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
      return result;
    }
    try {
      prepareChannels();
    }
 catch (    ChannelSetupException e) {
      final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
      result.setDescription(StringUtils.stringifyException(e));
      return result;
    }
    allocatedRes=this.allocatedResource;
    env=this.environment;
  }
  try {
    return allocatedRes.getInstance().submitTask(this.vertexID,this.executionGraph.getJobConfiguration(),env);
  }
 catch (  IOException e) {
    final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
    result.setDescription(StringUtils.stringifyException(e));
    return result;
  }
}",0.9741273100616016
56242,"/** 
 * Returns a duplicate of this execution vertex.
 * @param preserveVertexID <code>true</code> to copy the vertex's ID to the duplicated vertex, <code>false</code> to create a new ID
 * @return a duplicate of this execution vertex
 */
public synchronized ExecutionVertex duplicateVertex(boolean preserveVertexID){
  ExecutionVertexID newVertexID;
  if (preserveVertexID) {
    newVertexID=this.vertexID;
  }
 else {
    newVertexID=new ExecutionVertexID();
  }
  final ExecutionVertex duplicatedVertex=new ExecutionVertex(newVertexID,this.invokableClass,this.executionGraph,this.groupVertex);
  duplicatedVertex.environment=this.environment.duplicateEnvironment();
  duplicatedVertex.allocatedResource=this.allocatedResource;
  return duplicatedVertex;
}","/** 
 * Returns a duplicate of this execution vertex.
 * @param preserveVertexID <code>true</code> to copy the vertex's ID to the duplicated vertex, <code>false</code> to create a new ID
 * @return a duplicate of this execution vertex
 */
public synchronized ExecutionVertex duplicateVertex(boolean preserveVertexID){
  ExecutionVertexID newVertexID;
  if (preserveVertexID) {
    newVertexID=this.vertexID;
  }
 else {
    newVertexID=new ExecutionVertexID();
  }
  final ExecutionVertex duplicatedVertex=new ExecutionVertex(newVertexID,this.invokableClass,this.executionGraph,this.groupVertex);
synchronized (duplicatedVertex) {
    duplicatedVertex.environment=this.environment.duplicateEnvironment();
    duplicatedVertex.allocatedResource=this.allocatedResource;
  }
  return duplicatedVertex;
}",0.9730423620025674
56243,"private static Map<ExecutionGroupVertex,ManagementGroupVertex> addGroupVertices(Map<ExecutionStage,ManagementStage> stageMap){
  final Map<ExecutionGroupVertex,ManagementGroupVertex> groupMap=new HashMap<ExecutionGroupVertex,ManagementGroupVertex>();
  Iterator<ExecutionStage> iterator=stageMap.keySet().iterator();
  while (iterator.hasNext()) {
    final ExecutionStage executionStage=iterator.next();
    ManagementStage parent=stageMap.get(executionStage);
    for (int i=0; i < executionStage.getNumberOfStageMembers(); i++) {
      final ExecutionGroupVertex groupVertex=executionStage.getStageMember(i);
      final ManagementGroupVertex managementGroupVertex=new ManagementGroupVertex(parent,groupVertex.getName());
      groupMap.put(groupVertex,managementGroupVertex);
    }
  }
  iterator=stageMap.keySet().iterator();
  while (iterator.hasNext()) {
    final ExecutionStage executionStage=iterator.next();
    for (int i=0; i < executionStage.getNumberOfStageMembers(); i++) {
      final ExecutionGroupVertex sourceVertex=executionStage.getStageMember(i);
      final ManagementGroupVertex sourceGroupVertex=groupMap.get(sourceVertex);
      for (int j=0; j < sourceVertex.getNumberOfForwardLinks(); j++) {
        final ExecutionGroupEdge edge=sourceVertex.getForwardEdge(j);
        final ExecutionGroupVertex targetVertex=edge.getTargetVertex();
        final ManagementGroupVertex targetGroupVertex=groupMap.get(targetVertex);
        new ManagementGroupEdge(sourceGroupVertex,j,targetGroupVertex,edge.getIndexOfInputGate(),edge.getChannelType(),edge.getCompressionLevel());
      }
    }
  }
  return groupMap;
}","private static Map<ExecutionGroupVertex,ManagementGroupVertex> addGroupVertices(Map<ExecutionStage,ManagementStage> stageMap){
  final Map<ExecutionGroupVertex,ManagementGroupVertex> groupMap=new HashMap<ExecutionGroupVertex,ManagementGroupVertex>();
  Iterator<Map.Entry<ExecutionStage,ManagementStage>> iterator=stageMap.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<ExecutionStage,ManagementStage> entry=iterator.next();
    final ExecutionStage executionStage=entry.getKey();
    final ManagementStage parent=entry.getValue();
    for (int i=0; i < executionStage.getNumberOfStageMembers(); i++) {
      final ExecutionGroupVertex groupVertex=executionStage.getStageMember(i);
      final ManagementGroupVertex managementGroupVertex=new ManagementGroupVertex(parent,groupVertex.getName());
      groupMap.put(groupVertex,managementGroupVertex);
    }
  }
  iterator=stageMap.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<ExecutionStage,ManagementStage> entry=iterator.next();
    final ExecutionStage executionStage=entry.getKey();
    for (int i=0; i < executionStage.getNumberOfStageMembers(); i++) {
      final ExecutionGroupVertex sourceVertex=executionStage.getStageMember(i);
      final ManagementGroupVertex sourceGroupVertex=groupMap.get(sourceVertex);
      for (int j=0; j < sourceVertex.getNumberOfForwardLinks(); j++) {
        final ExecutionGroupEdge edge=sourceVertex.getForwardEdge(j);
        final ExecutionGroupVertex targetVertex=edge.getTargetVertex();
        final ManagementGroupVertex targetGroupVertex=groupMap.get(targetVertex);
        new ManagementGroupEdge(sourceGroupVertex,j,targetGroupVertex,edge.getIndexOfInputGate(),edge.getChannelType(),edge.getCompressionLevel());
      }
    }
  }
  return groupMap;
}",0.6794759825327511
56244,"/** 
 * Returns the size of the physical memory in bytes on a Mac OS-based operating system
 * @return the size of the physical memory in bytes or <code>-1</code> if the size could not be determined
 */
private static long getSizeOfPhysicalMemoryForMac(){
  try {
    Process proc=Runtime.getRuntime().exec(""String_Node_Str"");
    BufferedReader bi=new BufferedReader(new InputStreamReader(proc.getInputStream()));
    String line;
    while ((line=bi.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        long memsize=Long.parseLong(line.split(""String_Node_Str"")[1].trim());
        bi.close();
        proc.destroy();
        return memsize;
      }
    }
  }
 catch (  Exception e) {
    LOG.error(e);
    return -1;
  }
  return -1;
}","/** 
 * Returns the size of the physical memory in bytes on a Mac OS-based operating system
 * @return the size of the physical memory in bytes or <code>-1</code> if the size could not be determined
 */
private static long getSizeOfPhysicalMemoryForMac(){
  BufferedReader bi=null;
  try {
    Process proc=Runtime.getRuntime().exec(""String_Node_Str"");
    bi=new BufferedReader(new InputStreamReader(proc.getInputStream()));
    String line;
    while ((line=bi.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        long memsize=Long.parseLong(line.split(""String_Node_Str"")[1].trim());
        bi.close();
        proc.destroy();
        return memsize;
      }
    }
  }
 catch (  Exception e) {
    LOG.error(e);
    return -1;
  }
 finally {
    if (bi != null) {
      try {
        bi.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
  return -1;
}",0.9006622516556292
56245,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String iaString;
  if (this.hostname != null) {
    iaString=this.hostname;
  }
 else {
    iaString=inetAddress.toString();
    iaString=iaString.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return new String(iaString);
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String iaString;
  if (this.hostname != null) {
    iaString=this.hostname;
  }
 else {
    iaString=inetAddress.toString();
    iaString=iaString.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return iaString;
}",0.940766550522648
56246,"/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstance().getType().equals(allocatedResource.getInstance().getType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.error(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstance().getType().equals(allocatedResource.getInstance().getType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.error(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}",0.9965703086722196
56247,"/** 
 * Collects the instances required to run the job from the given   {@link ExecutionGraph} and requests them at theloaded instance manager.
 * @param executionGraph the execution graph to collect the required instances from
 * @throws InstanceException thrown if the given execution graph is already processing its final stage
 */
private void requestInstances(ExecutionGraph executionGraph) throws InstanceException {
  final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
  executionGraph.collectInstanceTypesRequiredForCurrentStage(requiredInstanceTypes,ExecutionState.SCHEDULED);
  if (requiredInstanceTypes.isEmpty()) {
    return;
  }
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,executionGraph.getIndexOfCurrentExecutionStage(),true,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() == ExecutionState.SCHEDULED) {
      vertex.setExecutionState(ExecutionState.ASSIGNING);
    }
  }
  final Iterator<InstanceType> it=requiredInstanceTypes.keySet().iterator();
  while (it.hasNext()) {
    final InstanceType type=it.next();
    for (int i=0; i < requiredInstanceTypes.get(type).intValue(); i++) {
      LOG.info(""String_Node_Str"" + type.getIdentifier());
      this.instanceManager.requestInstance(executionGraph.getJobID(),executionGraph.getJobConfiguration(),type);
    }
  }
}","/** 
 * Collects the instances required to run the job from the given   {@link ExecutionGraph} and requests them at theloaded instance manager.
 * @param executionGraph the execution graph to collect the required instances from
 * @throws InstanceException thrown if the given execution graph is already processing its final stage
 */
private void requestInstances(ExecutionGraph executionGraph) throws InstanceException {
  final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
  executionGraph.collectInstanceTypesRequiredForCurrentStage(requiredInstanceTypes,ExecutionState.SCHEDULED);
  if (requiredInstanceTypes.isEmpty()) {
    return;
  }
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,executionGraph.getIndexOfCurrentExecutionStage(),true,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() == ExecutionState.SCHEDULED) {
      vertex.setExecutionState(ExecutionState.ASSIGNING);
    }
  }
  final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    final InstanceType type=entry.getKey();
    for (int i=0; i < entry.getValue().intValue(); i++) {
      LOG.info(""String_Node_Str"" + type.getIdentifier());
      this.instanceManager.requestInstance(executionGraph.getJobID(),executionGraph.getJobConfiguration(),type);
    }
  }
}",0.9505833905284832
56248,"/** 
 * Shuts the task manager down.
 */
public synchronized void shutdown(){
  if (this.isShutDown) {
    return;
  }
  LOG.info(""String_Node_Str"");
  RPC.stopProxy(this.jobManager);
  this.taskManagerServer.stop();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  this.byteBufferedChannelManager.shutdown();
  if (this.ioManager != null) {
    this.ioManager.shutdown();
    this.ioManager=null;
  }
  if (this.memoryManager != null) {
    this.memoryManager.shutdown();
    this.memoryManager=null;
  }
  this.isShutDown=true;
}","/** 
 * Shuts the task manager down.
 */
public synchronized void shutdown(){
  if (this.isShutDown) {
    return;
  }
  LOG.info(""String_Node_Str"");
  RPC.stopProxy(this.jobManager);
  this.taskManagerServer.stop();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  this.byteBufferedChannelManager.shutdown();
  if (this.ioManager != null) {
    this.ioManager.shutdown();
  }
  if (this.memoryManager != null) {
    this.memoryManager.shutdown();
  }
  this.isShutDown=true;
}",0.9003831417624522
56249,"public ReadBufferDumpThread(Queue<TransferEnvelope> queueOfTransferEnvelopes,Deque<ByteBuffer> emptyReadBuffers){
  this.queueOfTransferEnvelopes=queueOfTransferEnvelopes;
  this.emptyReadBuffers=emptyReadBuffers;
}","public ReadBufferDumpThread(Queue<TransferEnvelope> queueOfTransferEnvelopes,Deque<ByteBuffer> emptyReadBuffers){
  this.queueOfTransferEnvelopes=queueOfTransferEnvelopes;
}",0.8917525773195877
56250,"@Override public void run(){
synchronized (this.queueOfTransferEnvelopes) {
    if (this.queueOfTransferEnvelopes.isEmpty()) {
      return;
    }
    final TransferEnvelope queueHead=this.queueOfTransferEnvelopes.peek();
    final Iterator<TransferEnvelope> it=this.queueOfTransferEnvelopes.iterator();
    while (it.hasNext()) {
      final TransferEnvelope transferEnvelope=it.next();
    }
  }
}","@Override public void run(){
synchronized (this.queueOfTransferEnvelopes) {
    if (this.queueOfTransferEnvelopes.isEmpty()) {
      return;
    }
    final Iterator<TransferEnvelope> it=this.queueOfTransferEnvelopes.iterator();
    while (it.hasNext()) {
      it.next();
    }
  }
}",0.5212298682284041
56251,"public synchronized void discard(){
  final Iterator<TransferEnvelope> it=this.queuedEnvelopes.iterator();
  while (it.hasNext()) {
    final TransferEnvelope transferEnvelope=it.next();
    transferEnvelope.getProcessingLog().setWrittenToCheckpoint();
  }
  this.queuedEnvelopes.clear();
  final File file=new File(getFilename());
  if (file.exists()) {
    file.delete();
  }
}","public synchronized void discard(){
  final Iterator<TransferEnvelope> it=this.queuedEnvelopes.iterator();
  while (it.hasNext()) {
    final TransferEnvelope transferEnvelope=it.next();
    transferEnvelope.getProcessingLog().setWrittenToCheckpoint();
  }
  this.queuedEnvelopes.clear();
  final File file=new File(getFilename());
  if (file.exists()) {
    try {
      file.delete();
    }
 catch (    SecurityException e) {
      LOG.error(e);
    }
  }
}",0.8697729988052568
56252,"/** 
 * Called by the channel wrapper to retrieve a new processing log for a transfer envelope. The processing log determines whether the envelope is later written to the checkpoint, sent via the network, or both.
 * @return the newly created processing log.
 */
public TransferEnvelopeProcessingLog getProcessingLog(){
  return new TransferEnvelopeProcessingLog((this.channelType == ChannelType.NETWORK),(this.ephemeralCheckpoint != null));
}","/** 
 * Called by the channel wrapper to retrieve a new processing log for a transfer envelope. The processing log determines whether the envelope is later written to the checkpoint, sent via the network, or both.
 * @param individualChannelType the type of the individual channel asking for the processing log
 * @return the newly created processing log.
 */
public TransferEnvelopeProcessingLog getProcessingLog(final ChannelType individualChannelType){
  return new TransferEnvelopeProcessingLog((individualChannelType == ChannelType.NETWORK),(this.ephemeralCheckpoint != null));
}",0.8510223953261928
56253,"/** 
 * Called by the attached output channel wrapper to forward a   {@link TransferEnvelope} objectto its final destination. Within this method the provided transfer envelope is possibly also forwarded to the assigned ephemeral checkpoint.
 * @param channelWrapper the channel wrapper which called this method
 * @param outgoingTransferEnvelope the transfer envelope to be forwarded
 */
public void processEnvelope(ByteBufferedOutputChannelWrapper channelWrapper,TransferEnvelope outgoingTransferEnvelope){
  final TransferEnvelopeProcessingLog processingLog=outgoingTransferEnvelope.getProcessingLog();
  if (this.ephemeralCheckpoint != null && processingLog.mustBeWrittenToCheckpoint()) {
    this.ephemeralCheckpoint.addTransferEnvelope(outgoingTransferEnvelope);
    final EventList eventList=outgoingTransferEnvelope.getEventList();
    if (!eventList.isEmpty() && this.channelType == ChannelType.FILE) {
      final Iterator<AbstractEvent> it=eventList.iterator();
      while (it.hasNext()) {
        if (it.next() instanceof ByteBufferedChannelCloseEvent) {
          this.ephemeralCheckpoint.markChannelAsFinished(outgoingTransferEnvelope.getSource());
          if (this.ephemeralCheckpoint.isPersistent()) {
            channelWrapper.processEvent(new ByteBufferedChannelCloseEvent());
          }
          break;
        }
      }
    }
  }
  if (processingLog.mustBeSentViaNetwork()) {
    this.byteBufferedChannelManager.queueOutgoingTransferEnvelope(outgoingTransferEnvelope);
  }
}","/** 
 * Called by the attached output channel wrapper to forward a   {@link TransferEnvelope} objectto its final destination. Within this method the provided transfer envelope is possibly also forwarded to the assigned ephemeral checkpoint.
 * @param channelWrapper the channel wrapper which called this method
 * @param outgoingTransferEnvelope the transfer envelope to be forwarded
 */
public void processEnvelope(ByteBufferedOutputChannelWrapper channelWrapper,TransferEnvelope outgoingTransferEnvelope){
  final TransferEnvelopeProcessingLog processingLog=outgoingTransferEnvelope.getProcessingLog();
  if (this.ephemeralCheckpoint != null && processingLog.mustBeWrittenToCheckpoint()) {
    this.ephemeralCheckpoint.addTransferEnvelope(outgoingTransferEnvelope);
    final EventList eventList=outgoingTransferEnvelope.getEventList();
    if (!eventList.isEmpty() && this.commonChannelType == ChannelType.FILE) {
      final Iterator<AbstractEvent> it=eventList.iterator();
      while (it.hasNext()) {
        if (it.next() instanceof ByteBufferedChannelCloseEvent) {
          this.ephemeralCheckpoint.markChannelAsFinished(outgoingTransferEnvelope.getSource());
          if (this.ephemeralCheckpoint.isPersistent()) {
            channelWrapper.processEvent(new ByteBufferedChannelCloseEvent());
          }
          break;
        }
      }
    }
  }
  if (processingLog.mustBeSentViaNetwork()) {
    this.byteBufferedChannelManager.queueOutgoingTransferEnvelope(outgoingTransferEnvelope);
  }
}",0.9980026631158456
56254,"/** 
 * Constructs a new byte buffered output channel group object.
 * @param byteBufferedChannelManager the byte buffered channel manager this object is attached to
 * @param checkpointManager the checkpoint manager used to create ephemeral checkpoints
 * @param channelType the channel type all of the channels attached to this group have in common, possibly <code>null</code>
 * @param executionVertexID the id of the execution vertex this channel group object belongs to
 */
public ByteBufferedOutputChannelGroup(ByteBufferedChannelManager byteBufferedChannelManager,CheckpointManager checkpointManager,ChannelType channelType,ExecutionVertexID executionVertexID){
  this.byteBufferedChannelManager=byteBufferedChannelManager;
  this.channelType=channelType;
  if (channelType == ChannelType.FILE) {
    this.ephemeralCheckpoint=EphemeralCheckpoint.forFileChannel(checkpointManager,executionVertexID);
  }
 else   if (channelType == ChannelType.NETWORK) {
    this.ephemeralCheckpoint=EphemeralCheckpoint.forNetworkChannel(checkpointManager,executionVertexID);
  }
 else {
    this.ephemeralCheckpoint=null;
  }
  if (this.ephemeralCheckpoint != null) {
    this.byteBufferedChannelManager.registerOutOfWriterBuffersListener(this.ephemeralCheckpoint);
  }
}","/** 
 * Constructs a new byte buffered output channel group object.
 * @param byteBufferedChannelManager the byte buffered channel manager this object is attached to
 * @param checkpointManager the checkpoint manager used to create ephemeral checkpoints
 * @param commonChannelType the channel type all of the channels attached to this group have in common, possibly <code>null</code>
 * @param executionVertexID the id of the execution vertex this channel group object belongs to
 */
public ByteBufferedOutputChannelGroup(ByteBufferedChannelManager byteBufferedChannelManager,CheckpointManager checkpointManager,ChannelType commonChannelType,ExecutionVertexID executionVertexID){
  this.byteBufferedChannelManager=byteBufferedChannelManager;
  this.commonChannelType=commonChannelType;
  if (commonChannelType == ChannelType.FILE) {
    this.ephemeralCheckpoint=EphemeralCheckpoint.forFileChannel(checkpointManager,executionVertexID);
  }
 else   if (commonChannelType == ChannelType.NETWORK) {
    this.ephemeralCheckpoint=EphemeralCheckpoint.forNetworkChannel(checkpointManager,executionVertexID);
  }
 else {
    this.ephemeralCheckpoint=null;
  }
  if (this.ephemeralCheckpoint != null) {
    this.byteBufferedChannelManager.registerOutOfWriterBuffersListener(this.ephemeralCheckpoint);
  }
}",0.9859265050820952
56255,"/** 
 * Creates a new   {@link TransferEnvelope} object. The method assignsand increases the sequence number.
 * @return a new {@link TransferEnvelope} object
 */
private TransferEnvelope createNewOutgoingTransferEnvelope(){
  final TransferEnvelope transferEnvelope=new TransferEnvelope(this.byteBufferedOutputChannel.getID(),this.byteBufferedOutputChannel.getConnectedChannelID(),this.byteBufferedOutputChannelGroup.getProcessingLog());
  transferEnvelope.setSequenceNumber(this.sequenceNumber++);
  return transferEnvelope;
}","/** 
 * Creates a new   {@link TransferEnvelope} object. The method assignsand increases the sequence number.
 * @return a new {@link TransferEnvelope} object
 */
private TransferEnvelope createNewOutgoingTransferEnvelope(){
  final TransferEnvelope transferEnvelope=new TransferEnvelope(this.byteBufferedOutputChannel.getID(),this.byteBufferedOutputChannel.getConnectedChannelID(),this.byteBufferedOutputChannelGroup.getProcessingLog(this.byteBufferedOutputChannel.getType()));
  transferEnvelope.setSequenceNumber(this.sequenceNumber++);
  return transferEnvelope;
}",0.9635036496350364
56256,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  final int numberOfMapEntries=in.readInt();
  for (int i=0; i < numberOfMapEntries; i++) {
    final String keyType=StringRecord.readString(in);
    Class<K> keyClass=null;
    try {
      keyClass=(Class<K>)Class.forName(keyType);
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    K key=null;
    try {
      key=keyClass.newInstance();
    }
 catch (    Exception e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    key.read(in);
    final String valueType=StringRecord.readString(in);
    Class<V> valueClass=null;
    try {
      valueClass=(Class<V>)Class.forName(valueType);
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    V value=null;
    try {
      value=valueClass.newInstance();
    }
 catch (    Exception e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    put(key,value);
  }
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  final int numberOfMapEntries=in.readInt();
  for (int i=0; i < numberOfMapEntries; i++) {
    final String keyType=StringRecord.readString(in);
    Class<K> keyClass=null;
    try {
      keyClass=(Class<K>)Class.forName(keyType);
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    K key=null;
    try {
      key=keyClass.newInstance();
    }
 catch (    Exception e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    key.read(in);
    final String valueType=StringRecord.readString(in);
    Class<V> valueClass=null;
    try {
      valueClass=(Class<V>)Class.forName(valueType);
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    V value=null;
    try {
      value=valueClass.newInstance();
    }
 catch (    Exception e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    value.read(in);
    put(key,value);
  }
}",0.9911032028469752
56257,"/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ManagementVertex getCandidateVertex(final TraversalEntry te,final boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getOutputGate(te.getCurrentGate()).getNumberOfForwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge forwardEdge=te.getManagementVertex().getOutputGate(te.getCurrentGate()).getForwardEdge(te.getCurrentChannel());
        final ManagementVertex target=forwardEdge.getTarget().getVertex();
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(target)) {
          return target;
        }
      }
    }
  }
 else {
    while (true) {
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getInputGate(te.getCurrentGate()).getNumberOfBackwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge backwardEdge=te.getManagementVertex().getInputGate(te.getCurrentGate()).getBackwardEdge(te.getCurrentChannel());
        final ManagementVertex source=backwardEdge.getSource().getVertex();
        if (source == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(source)) {
          return source;
        }
      }
    }
  }
  return null;
}","/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ManagementVertex getCandidateVertex(final TraversalEntry te,final boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getOutputGate(te.getCurrentGate()).getNumberOfForwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge forwardEdge=te.getManagementVertex().getOutputGate(te.getCurrentGate()).getForwardEdge(te.getCurrentChannel());
        final ManagementVertex target=forwardEdge.getTarget().getVertex();
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(target)) {
          return target;
        }
      }
    }
  }
 else {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getInputGate(te.getCurrentGate()).getNumberOfBackwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge backwardEdge=te.getManagementVertex().getInputGate(te.getCurrentGate()).getBackwardEdge(te.getCurrentChannel());
        final ManagementVertex source=backwardEdge.getSource().getVertex();
        if (source == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(source)) {
          return source;
        }
      }
    }
  }
  return null;
}",0.9599123767798466
56258,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (super.equals(obj)) {
    return false;
  }
  if (!(obj instanceof ThreadProfilingEvent)) {
    return false;
  }
  final ThreadProfilingEvent threadProfilingEvent=(ThreadProfilingEvent)obj;
  if (this.userTime != threadProfilingEvent.getUserTime()) {
    return false;
  }
  if (this.systemTime != threadProfilingEvent.getSystemTime()) {
    return false;
  }
  if (this.blockedTime != threadProfilingEvent.getBlockedTime()) {
    return false;
  }
  if (this.waitedTime != threadProfilingEvent.getWaitedTime()) {
    return false;
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (!super.equals(obj)) {
    return false;
  }
  if (!(obj instanceof ThreadProfilingEvent)) {
    return false;
  }
  final ThreadProfilingEvent threadProfilingEvent=(ThreadProfilingEvent)obj;
  if (this.userTime != threadProfilingEvent.getUserTime()) {
    return false;
  }
  if (this.systemTime != threadProfilingEvent.getSystemTime()) {
    return false;
  }
  if (this.blockedTime != threadProfilingEvent.getBlockedTime()) {
    return false;
  }
  if (this.waitedTime != threadProfilingEvent.getWaitedTime()) {
    return false;
  }
  return true;
}",0.999205718824464
56259,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (!super.equals(obj)) {
    return false;
  }
  if (!(obj instanceof SingleInstanceProfilingEvent)) {
    return false;
  }
  final SingleInstanceProfilingEvent singleInstanceProfilingEvent=(SingleInstanceProfilingEvent)obj;
  if (this.instanceName.equals(singleInstanceProfilingEvent.getInstanceName())) {
    return false;
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (!super.equals(obj)) {
    return false;
  }
  if (!(obj instanceof SingleInstanceProfilingEvent)) {
    return false;
  }
  final SingleInstanceProfilingEvent singleInstanceProfilingEvent=(SingleInstanceProfilingEvent)obj;
  if (!this.instanceName.equals(singleInstanceProfilingEvent.getInstanceName())) {
    return false;
  }
  return true;
}",0.9988109393579072
56260,"public List<ManagementGroupVertex> getGroupVerticesInReverseTopologicalOrder(){
  final List<ManagementGroupVertex> reverseTopologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noOutgoingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> outdegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,false,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    outdegrees.put(groupVertex,new Integer(groupVertex.getNumberOfForwardEdges()));
    if (groupVertex.getNumberOfForwardEdges() == 0) {
      noOutgoingEdges.add(groupVertex);
    }
  }
  while (!noOutgoingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noOutgoingEdges.removeFirst();
    reverseTopologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfBackwardEdges(); i++) {
      final ManagementGroupVertex sourceVertex=groupVertex.getBackwardEdge(i).getSource();
      Integer outdegree=outdegrees.get(sourceVertex);
      outdegree=new Integer(outdegree.intValue() - 1);
      outdegrees.put(sourceVertex,outdegree);
      if (outdegree.intValue() == 0) {
        noOutgoingEdges.add(sourceVertex);
      }
    }
  }
  return reverseTopologicalSort;
}","public List<ManagementGroupVertex> getGroupVerticesInReverseTopologicalOrder(){
  final List<ManagementGroupVertex> reverseTopologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noOutgoingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> outdegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,false,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    outdegrees.put(groupVertex,Integer.valueOf(groupVertex.getNumberOfForwardEdges()));
    if (groupVertex.getNumberOfForwardEdges() == 0) {
      noOutgoingEdges.add(groupVertex);
    }
  }
  while (!noOutgoingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noOutgoingEdges.removeFirst();
    reverseTopologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfBackwardEdges(); i++) {
      final ManagementGroupVertex sourceVertex=groupVertex.getBackwardEdge(i).getSource();
      Integer outdegree=outdegrees.get(sourceVertex);
      outdegree=Integer.valueOf(outdegree.intValue() - 1);
      outdegrees.put(sourceVertex,outdegree);
      if (outdegree.intValue() == 0) {
        noOutgoingEdges.add(sourceVertex);
      }
    }
  }
  return reverseTopologicalSort;
}",0.9910846953937592
56261,"public List<ManagementGroupVertex> getGroupVerticesInTopologicalOrder(){
  final List<ManagementGroupVertex> topologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noIncomingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> indegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,true,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    indegrees.put(groupVertex,new Integer(groupVertex.getNumberOfBackwardEdges()));
    if (groupVertex.getNumberOfBackwardEdges() == 0) {
      noIncomingEdges.add(groupVertex);
    }
  }
  while (!noIncomingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noIncomingEdges.removeFirst();
    topologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupVertex targetVertex=groupVertex.getForwardEdge(i).getTarget();
      Integer indegree=indegrees.get(targetVertex);
      indegree=new Integer(indegree.intValue() - 1);
      indegrees.put(targetVertex,indegree);
      if (indegree.intValue() == 0) {
        noIncomingEdges.add(targetVertex);
      }
    }
  }
  return topologicalSort;
}","public List<ManagementGroupVertex> getGroupVerticesInTopologicalOrder(){
  final List<ManagementGroupVertex> topologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noIncomingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> indegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,true,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    indegrees.put(groupVertex,Integer.valueOf(groupVertex.getNumberOfBackwardEdges()));
    if (groupVertex.getNumberOfBackwardEdges() == 0) {
      noIncomingEdges.add(groupVertex);
    }
  }
  while (!noIncomingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noIncomingEdges.removeFirst();
    topologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupVertex targetVertex=groupVertex.getForwardEdge(i).getTarget();
      Integer indegree=indegrees.get(targetVertex);
      indegree=Integer.valueOf(indegree.intValue() - 1);
      indegrees.put(targetVertex,indegree);
      if (indegree.intValue() == 0) {
        noIncomingEdges.add(targetVertex);
      }
    }
  }
  return topologicalSort;
}",0.9908256880733946
56262,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String str;
  if (this.childNodes.isEmpty()) {
    str=this.name;
  }
 else {
    str=""String_Node_Str"";
    final Iterator<NetworkNode> it=this.childNodes.iterator();
    while (it.hasNext()) {
      str+=it.next().toString();
      if (it.hasNext()) {
        str+=""String_Node_Str"";
      }
    }
    str+=""String_Node_Str"";
  }
  return str;
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String str;
  if (this.childNodes.isEmpty()) {
    str=this.name;
  }
 else {
    final Iterator<NetworkNode> it=this.childNodes.iterator();
    final StringBuffer buf=new StringBuffer(""String_Node_Str"");
    while (it.hasNext()) {
      buf.append(it.next().toString());
      if (it.hasNext()) {
        buf.append(""String_Node_Str"");
      }
    }
    buf.append(""String_Node_Str"");
    str=buf.toString();
  }
  return str;
}",0.329646017699115
56263,"/** 
 * Loads the configuration files from the specified directory.
 * @param configDir the directory which contains the configuration files
 */
public static void loadConfiguration(String configDir){
  if (configDir == null) {
    if (configDir == null) {
      LOG.warn(""String_Node_Str"");
      return;
    }
  }
  final File confDirFile=new File(configDir);
  if (!(confDirFile.exists() && confDirFile.isDirectory())) {
    LOG.warn(""String_Node_Str"" + configDir + ""String_Node_Str""+ confDirFile.getAbsolutePath()+ ""String_Node_Str"");
    return;
  }
  File[] files=confDirFile.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return dir == confDirFile && name != null && name.endsWith(""String_Node_Str"");
    }
  }
);
  if (files == null || files.length == 0) {
    LOG.warn(""String_Node_Str"" + configDir + ""String_Node_Str""+ confDirFile.getAbsolutePath()+ ""String_Node_Str"");
    return;
  }
  for (  File f : files) {
    get().loadResource(""String_Node_Str"" + f.getAbsolutePath());
  }
  if (configuration != null) {
    configuration.confData.put(CONFIGDIRKEY,configDir);
  }
}","/** 
 * Loads the configuration files from the specified directory.
 * @param configDir the directory which contains the configuration files
 */
public static void loadConfiguration(String configDir){
  if (configDir == null) {
    LOG.warn(""String_Node_Str"");
    return;
  }
  final File confDirFile=new File(configDir);
  if (!(confDirFile.exists() && confDirFile.isDirectory())) {
    LOG.warn(""String_Node_Str"" + configDir + ""String_Node_Str""+ confDirFile.getAbsolutePath()+ ""String_Node_Str"");
    return;
  }
  File[] files=confDirFile.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return dir == confDirFile && name != null && name.endsWith(""String_Node_Str"");
    }
  }
);
  if (files == null || files.length == 0) {
    LOG.warn(""String_Node_Str"" + configDir + ""String_Node_Str""+ confDirFile.getAbsolutePath()+ ""String_Node_Str"");
    return;
  }
  for (  File f : files) {
    get().loadResource(""String_Node_Str"" + f.getAbsolutePath());
  }
  if (configuration != null) {
    configuration.confData.put(CONFIGDIRKEY,configDir);
  }
}",0.9826280623608018
56264,"@Override public boolean equals(Object obj){
  if (obj instanceof FSKey) {
    final FSKey key=(FSKey)obj;
    if (!this.scheme.equals(key.scheme)) {
      return false;
    }
    if ((this.authority == null) || (key.authority == null)) {
      if (this.authority == null && key.authority == null) {
        return true;
      }
      return false;
    }
    if (!this.authority.equals(key.authority)) {
      return false;
    }
    return true;
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (obj instanceof FSKey) {
    final FSKey key=(FSKey)obj;
    if (!this.scheme.equals(key.scheme)) {
      return false;
    }
    if ((this.authority == null) || (key.authority == null)) {
      if (this.authority == null && key.authority == null) {
        return true;
      }
      return false;
    }
    if (!this.authority.equals(key.authority)) {
      return false;
    }
    return true;
  }
  return false;
}",0.972972972972973
56265,"public void map(PactString key,PactString value,Collector<PactString,PactInteger> out){
  if (Integer.parseInt(key.toString()) + Integer.parseInt(value.toString()) < 10) {
    out.collect(value,new PactInteger(Integer.parseInt(key.toString()) + 10));
    LOG.debug(""String_Node_Str"" + key + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
}","public void map(PactString key,PactString value,Collector<PactString,PactInteger> out){
  LOG.debug(""String_Node_Str"" + key + ""String_Node_Str""+ value+ ""String_Node_Str"");
  if (Integer.parseInt(key.toString()) + Integer.parseInt(value.toString()) < 10) {
    out.collect(value,new PactInteger(Integer.parseInt(key.toString()) + 10));
  }
}",0.5190615835777126
56266,"/** 
 * {@inheritDoc}
 */
@Override public InputSplit[] getInputSplits() throws IllegalConfigurationException {
  if (this.path == null) {
    throw new IllegalConfigurationException(""String_Node_Str"");
  }
  final int numSubtasks=getNumberOfSubtasks();
  final List<FileInputSplit> inputSplits=new ArrayList<FileInputSplit>(numSubtasks);
  List<FileStatus> files=new ArrayList<FileStatus>();
  long totalLength=0;
  try {
    final FileSystem fs=this.path.getFileSystem();
    final FileStatus pathFile=fs.getFileStatus(this.path);
    if (pathFile.isDir()) {
      final FileStatus[] dir=fs.listStatus(this.path);
      for (int i=0; i < dir.length; i++) {
        if (!dir[i].isDir()) {
          files.add(dir[i]);
          totalLength+=dir[i].getLen();
        }
      }
    }
 else {
      files.add(pathFile);
      totalLength+=pathFile.getLen();
    }
    final long minSplitSize=1;
    final long maxSplitSize=totalLength / numSubtasks + (totalLength % numSubtasks == 0 ? 0 : 1);
    for (    FileStatus file : files) {
      final long len=file.getLen();
      final long blockSize=file.getBlockSize();
      final long splitSize=Math.max(minSplitSize,Math.min(maxSplitSize,blockSize));
      final long halfSplit=splitSize >>> 1;
      final long maxBytesForLastSplit=(long)(splitSize * MAX_SPLIT_SIZE_DISCREPANCY);
      BlockLocation[] blocks=fs.getFileBlockLocations(file,0,len);
      Arrays.sort(blocks);
      long bytesUnassigned=len;
      long position=0;
      int blockIndex=0;
      while (bytesUnassigned > maxBytesForLastSplit) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(file.getPath(),position,splitSize,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
        position+=splitSize;
        bytesUnassigned-=splitSize;
      }
      if (bytesUnassigned > 0) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(file.getPath(),position,bytesUnassigned,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
      }
    }
  }
 catch (  IOException ioe) {
    throw new IllegalConfigurationException(""String_Node_Str"" + this.path.toString() + ""String_Node_Str""+ StringUtils.stringifyException(ioe));
  }
  return inputSplits.toArray(new InputSplit[inputSplits.size()]);
}","/** 
 * {@inheritDoc}
 */
@Override public InputSplit[] getInputSplits() throws IllegalConfigurationException {
  if (this.path == null) {
    throw new IllegalConfigurationException(""String_Node_Str"");
  }
  final int numSubtasks=getNumberOfSubtasks();
  final List<FileInputSplit> inputSplits=new ArrayList<FileInputSplit>();
  List<FileStatus> files=new ArrayList<FileStatus>();
  long totalLength=0;
  try {
    final FileSystem fs=this.path.getFileSystem();
    final FileStatus pathFile=fs.getFileStatus(this.path);
    if (pathFile.isDir()) {
      final FileStatus[] dir=fs.listStatus(this.path);
      for (int i=0; i < dir.length; i++) {
        if (!dir[i].isDir()) {
          files.add(dir[i]);
          totalLength+=dir[i].getLen();
        }
      }
    }
 else {
      files.add(pathFile);
      totalLength+=pathFile.getLen();
    }
    final long minSplitSize=1;
    final long maxSplitSize=(numSubtasks < 1) ? Long.MAX_VALUE : (totalLength / numSubtasks + (totalLength % numSubtasks == 0 ? 0 : 1));
    for (    FileStatus file : files) {
      final long len=file.getLen();
      final long blockSize=file.getBlockSize();
      final long splitSize=Math.max(minSplitSize,Math.min(maxSplitSize,blockSize));
      final long halfSplit=splitSize >>> 1;
      final long maxBytesForLastSplit=(long)(splitSize * MAX_SPLIT_SIZE_DISCREPANCY);
      BlockLocation[] blocks=fs.getFileBlockLocations(file,0,len);
      Arrays.sort(blocks);
      long bytesUnassigned=len;
      long position=0;
      int blockIndex=0;
      while (bytesUnassigned > maxBytesForLastSplit) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(file.getPath(),position,splitSize,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
        position+=splitSize;
        bytesUnassigned-=splitSize;
      }
      if (bytesUnassigned > 0) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(file.getPath(),position,bytesUnassigned,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
      }
    }
  }
 catch (  IOException ioe) {
    throw new IllegalConfigurationException(""String_Node_Str"" + this.path.toString() + ""String_Node_Str""+ StringUtils.stringifyException(ioe));
  }
  return inputSplits.toArray(new InputSplit[inputSplits.size()]);
}",0.9874739039665972
56267,"/** 
 * Main method. accepts a single parameter, which is the config directory.
 * @param args The parameters to the entry point.
 */
public static void main(String[] args){
  try {
    String configDir=null;
    if (args.length >= 2 && args[0].equals(""String_Node_Str"")) {
      configDir=args[1];
    }
    if (configDir == null) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
      return;
    }
    GlobalConfiguration.loadConfiguration(configDir);
    Configuration config=GlobalConfiguration.getConfiguration();
    int port=config.getInteger(PactConfigConstants.WEB_FRONTEND_PORT_KEY,PactConfigConstants.DEFAULT_WEB_FRONTEND_PORT);
    WebInterfaceServer server=new WebInterfaceServer(config,port);
    LOG.info(""String_Node_Str"" + port + '.');
    server.start();
    server.join();
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"" + t.getMessage(),t);
  }
}","/** 
 * Main method. accepts a single parameter, which is the config directory.
 * @param args The parameters to the entry point.
 */
public static void main(String[] args){
  try {
    String configDir=null;
    if (args.length >= 2 && args[0].equals(""String_Node_Str"")) {
      configDir=args[1];
    }
    if (configDir == null) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
      return;
    }
    GlobalConfiguration.loadConfiguration(configDir);
    Configuration config=GlobalConfiguration.getConfiguration();
    config.setString(PactConfigConstants.STRATOSPHERE_BASE_DIR_PATH_KEY,configDir + ""String_Node_Str"");
    int port=config.getInteger(PactConfigConstants.WEB_FRONTEND_PORT_KEY,PactConfigConstants.DEFAULT_WEB_FRONTEND_PORT);
    WebInterfaceServer server=new WebInterfaceServer(config,port);
    LOG.info(""String_Node_Str"" + port + '.');
    server.start();
    server.join();
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"" + t.getMessage(),t);
  }
}",0.9453781512605042
56268,"/** 
 * Creates a new web interface server. The server runs the servlets that implement the logic to upload, list, delete and submit jobs, to compile them and to show the optimizer plan. It serves the asynchronous requests for the plans and all other static resources, like static web pages, stylesheets or javascript files.
 * @param nepheleConfig The configuration for the nephele job manager. All compiled jobs will be sent to the manager described by this configuration.
 * @param port The port to launch the server on.
 * @throws IOException Thrown, if the server setup failed for an I/O related reason.
 */
public WebInterfaceServer(Configuration nepheleConfig,int port) throws IOException {
  Configuration config=GlobalConfiguration.getConfiguration();
  if (nepheleConfig == null) {
    nepheleConfig=config;
  }
  File webDir=new File(config.getString(PactConfigConstants.WEB_ROOT_PATH_KEY,PactConfigConstants.DEFAULT_WEB_ROOT_DIR));
  File tmpDir=new File(config.getString(PactConfigConstants.WEB_TMP_DIR_KEY,PactConfigConstants.DEFAULT_WEB_TMP_DIR));
  File uploadDir=new File(config.getString(PactConfigConstants.WEB_JOB_UPLOAD_DIR_KEY,PactConfigConstants.DEFAULT_WEB_JOB_STORAGE_DIR));
  File planDumpDir=new File(config.getString(PactConfigConstants.WEB_PLAN_DUMP_DIR_KEY,PactConfigConstants.DEFAULT_WEB_PLAN_DUMP_DIR));
  LOG.debug(""String_Node_Str"" + webDir.getAbsolutePath() + ""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + tmpDir.getAbsolutePath() + ""String_Node_Str""+ uploadDir.getAbsolutePath()+ ""String_Node_Str""+ planDumpDir.getAbsolutePath()+ ""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + config.getString(ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_ADDRESS) + ""String_Node_Str""+ config.getInteger(ConfigConstants.JOB_MANAGER_IPC_PORT_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_PORT)+ ""String_Node_Str"");
  server=new Server(port);
  if (!webDir.exists()) {
    throw new FileNotFoundException(""String_Node_Str"" + webDir.getAbsolutePath());
  }
  checkAndCreateDirectories(tmpDir,true);
  checkAndCreateDirectories(uploadDir,true);
  checkAndCreateDirectories(planDumpDir,true);
  ServletContextHandler servletContext=new ServletContextHandler(ServletContextHandler.SESSIONS);
  servletContext.setContextPath(""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new PactJobJSONServlet(uploadDir)),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new PlanDisplayServlet()),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new JobsServlet(uploadDir,tmpDir,""String_Node_Str"")),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new JobSubmissionServlet(nepheleConfig,uploadDir,planDumpDir)),""String_Node_Str"");
  ResourceHandler pactPlanHandler=new ResourceHandler();
  pactPlanHandler.setDirectoriesListed(false);
  pactPlanHandler.setResourceBase(planDumpDir.getAbsolutePath());
  ContextHandler pactPlanContext=new ContextHandler();
  pactPlanContext.setContextPath(""String_Node_Str"");
  pactPlanContext.setHandler(pactPlanHandler);
  ResourceHandler resourceHandler=new ResourceHandler();
  resourceHandler.setDirectoriesListed(false);
  resourceHandler.setResourceBase(webDir.getAbsolutePath());
  HandlerList handlers=new HandlerList();
  handlers.addHandler(servletContext);
  handlers.addHandler(pactPlanContext);
  handlers.addHandler(resourceHandler);
  File af=null;
  String authFile=config.getString(PactConfigConstants.WEB_ACCESS_FILE_KEY,PactConfigConstants.DEFAULT_WEB_ACCESS_FILE_PATH);
  if (authFile != null) {
    af=new File(authFile);
    if (!af.exists()) {
      LOG.error(""String_Node_Str"" + af.getAbsolutePath() + ""String_Node_Str"");
      af=null;
    }
  }
  if (af != null) {
    HashLoginService loginService=new HashLoginService(""String_Node_Str"",authFile);
    server.addBean(loginService);
    Constraint constraint=new Constraint();
    constraint.setName(Constraint.__BASIC_AUTH);
    constraint.setAuthenticate(true);
    constraint.setRoles(new String[]{""String_Node_Str""});
    ConstraintMapping mapping=new ConstraintMapping();
    mapping.setPathSpec(""String_Node_Str"");
    mapping.setConstraint(constraint);
    ConstraintSecurityHandler sh=new ConstraintSecurityHandler();
    sh.addConstraintMapping(mapping);
    sh.setAuthenticator(new BasicAuthenticator());
    sh.setLoginService(loginService);
    sh.setStrict(true);
    sh.setHandler(handlers);
    server.setHandler(sh);
  }
 else {
    server.setHandler(handlers);
  }
}","/** 
 * Creates a new web interface server. The server runs the servlets that implement the logic to upload, list, delete and submit jobs, to compile them and to show the optimizer plan. It serves the asynchronous requests for the plans and all other static resources, like static web pages, stylesheets or javascript files.
 * @param nepheleConfig The configuration for the nephele job manager. All compiled jobs will be sent to the manager described by this configuration.
 * @param port The port to launch the server on.
 * @throws IOException Thrown, if the server setup failed for an I/O related reason.
 */
public WebInterfaceServer(Configuration nepheleConfig,int port) throws IOException {
  Configuration config=GlobalConfiguration.getConfiguration();
  if (nepheleConfig == null) {
    nepheleConfig=config;
  }
  String basePath=nepheleConfig.getString(PactConfigConstants.STRATOSPHERE_BASE_DIR_PATH_KEY,""String_Node_Str"");
  File webDir;
  File tmpDir;
  File uploadDir;
  File planDumpDir;
  String webDirPath=config.getString(PactConfigConstants.WEB_ROOT_PATH_KEY,PactConfigConstants.DEFAULT_WEB_ROOT_DIR);
  if (webDirPath.startsWith(""String_Node_Str"")) {
    webDir=new File(webDirPath);
  }
 else {
    webDir=new File(basePath + ""String_Node_Str"" + webDirPath);
  }
  String tmpDirPath=config.getString(PactConfigConstants.WEB_TMP_DIR_KEY,PactConfigConstants.DEFAULT_WEB_TMP_DIR);
  if (tmpDirPath.startsWith(""String_Node_Str"")) {
    tmpDir=new File(tmpDirPath);
  }
 else {
    tmpDir=new File(basePath + ""String_Node_Str"" + tmpDirPath);
  }
  String uploadDirPath=config.getString(PactConfigConstants.WEB_JOB_UPLOAD_DIR_KEY,PactConfigConstants.DEFAULT_WEB_JOB_STORAGE_DIR);
  if (uploadDirPath.startsWith(""String_Node_Str"")) {
    uploadDir=new File(uploadDirPath);
  }
 else {
    uploadDir=new File(basePath + ""String_Node_Str"" + uploadDirPath);
  }
  String planDumpDirPath=config.getString(PactConfigConstants.WEB_PLAN_DUMP_DIR_KEY,PactConfigConstants.DEFAULT_WEB_PLAN_DUMP_DIR);
  if (planDumpDirPath.startsWith(""String_Node_Str"")) {
    planDumpDir=new File(planDumpDirPath);
  }
 else {
    planDumpDir=new File(basePath + ""String_Node_Str"" + planDumpDirPath);
  }
  LOG.debug(""String_Node_Str"" + webDir.getAbsolutePath() + ""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + tmpDir.getAbsolutePath() + ""String_Node_Str""+ uploadDir.getAbsolutePath()+ ""String_Node_Str""+ planDumpDir.getAbsolutePath()+ ""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + config.getString(ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_ADDRESS) + ""String_Node_Str""+ config.getInteger(ConfigConstants.JOB_MANAGER_IPC_PORT_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_PORT)+ ""String_Node_Str"");
  server=new Server(port);
  if (!webDir.exists()) {
    throw new FileNotFoundException(""String_Node_Str"" + webDir.getAbsolutePath());
  }
  checkAndCreateDirectories(tmpDir,true);
  checkAndCreateDirectories(uploadDir,true);
  checkAndCreateDirectories(planDumpDir,true);
  ServletContextHandler servletContext=new ServletContextHandler(ServletContextHandler.SESSIONS);
  servletContext.setContextPath(""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new PactJobJSONServlet(uploadDir)),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new PlanDisplayServlet()),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new JobsServlet(uploadDir,tmpDir,""String_Node_Str"")),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new JobSubmissionServlet(nepheleConfig,uploadDir,planDumpDir)),""String_Node_Str"");
  ResourceHandler pactPlanHandler=new ResourceHandler();
  pactPlanHandler.setDirectoriesListed(false);
  pactPlanHandler.setResourceBase(planDumpDir.getAbsolutePath());
  ContextHandler pactPlanContext=new ContextHandler();
  pactPlanContext.setContextPath(""String_Node_Str"");
  pactPlanContext.setHandler(pactPlanHandler);
  ResourceHandler resourceHandler=new ResourceHandler();
  resourceHandler.setDirectoriesListed(false);
  resourceHandler.setResourceBase(webDir.getAbsolutePath());
  HandlerList handlers=new HandlerList();
  handlers.addHandler(servletContext);
  handlers.addHandler(pactPlanContext);
  handlers.addHandler(resourceHandler);
  File af=null;
  String authFile=config.getString(PactConfigConstants.WEB_ACCESS_FILE_KEY,PactConfigConstants.DEFAULT_WEB_ACCESS_FILE_PATH);
  if (authFile != null) {
    af=new File(authFile);
    if (!af.exists()) {
      LOG.error(""String_Node_Str"" + af.getAbsolutePath() + ""String_Node_Str"");
      af=null;
    }
  }
  if (af != null) {
    HashLoginService loginService=new HashLoginService(""String_Node_Str"",authFile);
    server.addBean(loginService);
    Constraint constraint=new Constraint();
    constraint.setName(Constraint.__BASIC_AUTH);
    constraint.setAuthenticate(true);
    constraint.setRoles(new String[]{""String_Node_Str""});
    ConstraintMapping mapping=new ConstraintMapping();
    mapping.setPathSpec(""String_Node_Str"");
    mapping.setConstraint(constraint);
    ConstraintSecurityHandler sh=new ConstraintSecurityHandler();
    sh.addConstraintMapping(mapping);
    sh.setAuthenticator(new BasicAuthenticator());
    sh.setLoginService(loginService);
    sh.setStrict(true);
    sh.setHandler(handlers);
    server.setHandler(sh);
  }
 else {
    server.setHandler(handlers);
  }
}",0.9034741213410312
56269,"/** 
 * Reads the instance types configured in the config file. The config file needs to contain a key <code>clustermgr.nrtypes</code> that indicates the number of instance types that are supported by the cluster. This is followed by entries <code>clustermgr.instancetype.X</code> where X is a number from 1 to the specified number of entries. Each entry follows the format: ""instancename,numComputeUnits,numCores,memorySize,diskCapacity,pricePerHour"" (see   {@link InstanceType}).
 * @return list of available instance types sorted by price (cheapest tomost expensive)
 */
private InstanceType[] populateInstanceTypeArray(){
  final List<InstanceType> instanceTypes=Lists.newArrayList();
  int count=1;
  while (true) {
    final String key=INSTANCE_TYPE_PREFIX_KEY + Integer.toString(count);
    String descr=GlobalConfiguration.getString(key,null);
    if (descr == null) {
      if (count == 1) {
        LOG.error(""String_Node_Str"" + DEFAULT_INSTANCE_TYPE);
        descr=DEFAULT_INSTANCE_TYPE;
      }
 else {
        break;
      }
    }
    try {
      instanceTypes.add(InstanceType.getTypeFromString(descr));
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"" + key + ""String_Node_Str""+ descr,t);
    }
    ++count;
  }
  Collections.sort(instanceTypes,new Comparator<InstanceType>(){
    @Override public int compare(    InstanceType o1,    InstanceType o2){
      return o1.getPricePerHour() - o2.getPricePerHour();
    }
  }
);
  return instanceTypes.toArray(new InstanceType[0]);
}","/** 
 * Reads the instance types configured in the config file. The config file needs to contain a key <code>clustermgr.nrtypes</code> that indicates the number of instance types that are supported by the cluster. This is followed by entries <code>clustermgr.instancetype.X</code> where X is a number from 1 to the specified number of entries. Each entry follows the format: ""instancename,numComputeUnits,numCores,memorySize,diskCapacity,pricePerHour"" (see   {@link InstanceType}).
 * @return list of available instance types sorted by price (cheapest tomost expensive)
 */
public static InstanceType[] populateInstanceTypeArray(Log log){
  final List<InstanceType> instanceTypes=new ArrayList<InstanceType>();
  int count=1;
  while (true) {
    final String key=ConfigConstants.INSTANCE_MANAGER_INSTANCE_TYPE_PREFIX_KEY + Integer.toString(count);
    String descr=GlobalConfiguration.getString(key,null);
    if (descr == null) {
      if (count == 1) {
        if (log != null) {
          LOG.error(""String_Node_Str"" + ""String_Node_Str"" + ConfigConstants.DEFAULT_INSTANCE_TYPE);
        }
        descr=ConfigConstants.DEFAULT_INSTANCE_TYPE;
      }
 else {
        break;
      }
    }
    try {
      instanceTypes.add(InstanceType.getTypeFromString(descr));
    }
 catch (    Throwable t) {
      if (log != null) {
        LOG.error(""String_Node_Str"" + key + ""String_Node_Str""+ descr+ ""String_Node_Str""+ ConfigConstants.DEFAULT_INSTANCE_TYPE+ ""String_Node_Str""+ count+ ""String_Node_Str"",t);
      }
      instanceTypes.add(InstanceType.getTypeFromString(ConfigConstants.DEFAULT_INSTANCE_TYPE));
    }
    ++count;
  }
  return instanceTypes.toArray(new InstanceType[instanceTypes.size()]);
}",0.7775700934579439
56270,"/** 
 * {@inheritDoc}
 */
@Override public InstanceType getDefaultInstanceType(){
  return this.availableInstanceTypes[this.defaultInstanceTypeIndex - 1];
}","/** 
 * {@inheritDoc}
 */
@Override public InstanceType getDefaultInstanceType(){
  return this.availableInstanceTypes[this.defaultInstanceTypeIndex];
}",0.987012987012987
56271,"/** 
 * Constructor.
 */
public ClusterManager(){
  this.availableInstanceTypes=populateInstanceTypeArray();
  long tmpCleanUpInterval=(long)GlobalConfiguration.getInteger(CLEANUP_INTERVAL_KEY,DEFAULT_CLEANUP_INTERVAL) * 1000;
  if ((tmpCleanUpInterval % BASE_INTERVAL) != 0) {
    LOG.warn(""String_Node_Str"" + DEFAULT_CLEANUP_INTERVAL);
    tmpCleanUpInterval=DEFAULT_CLEANUP_INTERVAL;
  }
  this.cleanUpInterval=tmpCleanUpInterval;
  int tmpDefaultInstanceTypeIndex=GlobalConfiguration.getInteger(DEFAULT_INSTANCE_TYPE_INDEX_KEY,DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
  if (tmpDefaultInstanceTypeIndex >= this.availableInstanceTypes.length) {
    LOG.warn(""String_Node_Str"" + DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
    tmpDefaultInstanceTypeIndex=DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX;
  }
  this.defaultInstanceTypeIndex=tmpDefaultInstanceTypeIndex;
  this.networkTopology=loadNetworkTopology();
  loadIPToInstanceTypeMapping();
  final boolean runTimerAsDaemon=true;
  new Timer(runTimerAsDaemon).schedule(cleanupStaleMachines,BASE_INTERVAL,BASE_INTERVAL);
}","/** 
 * Constructor.
 */
public ClusterManager(){
  this.availableInstanceTypes=populateInstanceTypeArray(LOG);
  long tmpCleanUpInterval=(long)GlobalConfiguration.getInteger(ConfigConstants.INSTANCE_MANAGER_CLEANUP_INTERVAL_KEY,DEFAULT_CLEANUP_INTERVAL) * 1000;
  if ((tmpCleanUpInterval % BASE_INTERVAL) != 0) {
    LOG.warn(""String_Node_Str"" + DEFAULT_CLEANUP_INTERVAL + ""String_Node_Str"");
    tmpCleanUpInterval=DEFAULT_CLEANUP_INTERVAL;
  }
  this.cleanUpInterval=tmpCleanUpInterval;
  int tmpDefaultInstanceTypeIndex=GlobalConfiguration.getInteger(ConfigConstants.INSTANCE_MANAGER_DEFAULT_INSTANCE_TYPE_INDEX_KEY,ConfigConstants.DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
  if (tmpDefaultInstanceTypeIndex > this.availableInstanceTypes.length) {
    LOG.warn(""String_Node_Str"" + tmpDefaultInstanceTypeIndex + ""String_Node_Str""+ ConfigConstants.DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
    tmpDefaultInstanceTypeIndex=ConfigConstants.DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX;
  }
  this.defaultInstanceTypeIndex=tmpDefaultInstanceTypeIndex - 1;
  this.networkTopology=loadNetworkTopology();
  loadIPToInstanceTypeMapping();
  final boolean runTimerAsDaemon=true;
  new Timer(runTimerAsDaemon).schedule(cleanupStaleMachines,BASE_INTERVAL,BASE_INTERVAL);
}",0.9171366594360086
56272,"protected static String scanAfterClosedParenthesis(String currentToken,Scanner scanner){
  int countParenthesisOpen=countChar(currentToken,'(');
  int countParenthesisClose=countChar(currentToken,')');
  if (countParenthesisOpen == countParenthesisClose) {
    return scanner.next();
  }
  Deque<Integer> stack=new ArrayDeque<>();
  for (int iCount=0; iCount < countParenthesisOpen - countParenthesisClose; iCount++) {
    stack.push(1);
  }
  String token=scanner.next();
  whilestack:   do {
    for (    Examiner examiner : JavaSourceInspector.getInstance().getExaminers()) {
      if (examiner.getTypeFromToken(token) != null) {
        break whilestack;
      }
    }
    if (token.indexOf('(') > -1) {
      int countOpenParenthesis=countChar(token,'(');
      for (int iCount=0; iCount < countOpenParenthesis; iCount++) {
        stack.push(1);
      }
    }
    if (token.indexOf(')') > -1) {
      int countClosedParenthesis=countChar(token,')');
      for (int iCount=0; iCount < countClosedParenthesis; iCount++) {
        stack.pop();
      }
    }
    if (scanner.hasNext()) {
      token=scanner.next();
    }
 else {
      break;
    }
  }
 while (stack.size() > 0);
  return token;
}","protected static String scanAfterClosedParenthesis(String currentToken,Scanner scanner){
  int countParenthesisOpen=countChar(currentToken,'(');
  int countParenthesisClose=countChar(currentToken,')');
  if (countParenthesisOpen == countParenthesisClose) {
    return scanner.next();
  }
  Deque<Integer> stack=new ArrayDeque<>();
  for (int iCount=0; iCount < countParenthesisOpen - countParenthesisClose; iCount++) {
    stack.push(1);
  }
  if (!scanner.hasNext()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String token=scanner.next();
  whilestack:   do {
    for (    Examiner examiner : JavaSourceInspector.getInstance().getExaminers()) {
      if (examiner.getTypeFromToken(token) != null) {
        break whilestack;
      }
    }
    if (token.indexOf('(') > -1) {
      int countOpenParenthesis=countChar(token,'(');
      for (int iCount=0; iCount < countOpenParenthesis; iCount++) {
        stack.push(1);
      }
    }
    if (token.indexOf(')') > -1) {
      int countClosedParenthesis=countChar(token,')');
      for (int iCount=0; iCount < countClosedParenthesis; iCount++) {
        stack.pop();
      }
    }
    if (scanner.hasNext()) {
      token=scanner.next();
    }
 else {
      break;
    }
  }
 while (stack.size() > 0);
  return token;
}",0.963439132181599
56273,"protected static void findAndSetPackage(JavaSource javaSource){
  Scanner scanner=Examiner.getSourceCodeScanner(javaSource.getSourceCode());
  while (scanner.hasNext()) {
    String token=scanner.next();
    if (javaSource.getPackagePath() == null && token.equals(""String_Node_Str"")) {
      token=scanner.next();
      if (token.endsWith(""String_Node_Str"")) {
        String packagePath=token.substring(0,token.indexOf(';'));
        javaSource.setPackagePath(packagePath);
      }
    }
  }
}","protected static void findAndSetPackage(JavaSource javaSource){
  Scanner scanner=Examiner.getSourceCodeScanner(javaSource.getSourceCode());
  while (scanner.hasNext()) {
    String token=scanner.next();
    if (javaSource.getPackagePath() == null && token.equals(""String_Node_Str"")) {
      if (!scanner.hasNext()) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      token=scanner.next();
      if (token.endsWith(""String_Node_Str"")) {
        String packagePath=token.substring(0,token.indexOf(';'));
        javaSource.setPackagePath(packagePath);
      }
    }
  }
}",0.8285976168652612
56274,"protected static String jumpOverJavaToken(String token,Scanner scanner){
  String nextToken=token;
  while (isAJavaToken(nextToken)) {
    if (nextToken.startsWith(""String_Node_Str"") && nextToken.indexOf('(') > -1 && !nextToken.endsWith(""String_Node_Str"")) {
      nextToken=scanAfterClosedParenthesis(nextToken,scanner);
    }
 else {
      nextToken=scanner.next();
    }
  }
  return nextToken;
}","protected static String jumpOverJavaToken(String token,Scanner scanner){
  String nextToken=token;
  while (isAJavaToken(nextToken)) {
    if (!scanner.hasNext()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (nextToken.startsWith(""String_Node_Str"") && nextToken.indexOf('(') > -1 && !nextToken.endsWith(""String_Node_Str"")) {
      nextToken=scanAfterClosedParenthesis(nextToken,scanner);
    }
 else {
      nextToken=scanner.next();
    }
  }
  return nextToken;
}",0.8916201117318435
56275,"public void request(final String method,final String url,final Map<String,Object> headers,final List<Object> json,final Closure<Response> handler){
  request(method,url,toMultiMap(headers),new Buffer(new JsonArray(json).encode()),new Handler<Response>(){
    @Override public void handle(    Response event){
      handler.call(event);
    }
  }
);
}","public void request(final String method,final String url,final Map<String,Object> headers,final List<Object> json,final Closure<Response> handler){
  request(method,url,toMultiMap(headers),new org.vertx.java.core.buffer.Buffer(new JsonArray(json).encode()),new Handler<Response>(){
    @Override public void handle(    Response event){
      handler.call(event);
    }
  }
);
}",0.9628610729023384
56276,"/** 
 * Write a file into the response body
 * @param request
 * @param file
 * @param props
 */
private void sendFile(final YokeRequest request,final String file,final FileProps props){
  String contentType=MimeType.getMime(file);
  String charset=MimeType.getCharset(contentType);
  request.response().setContentType(contentType,charset);
  request.response().putHeader(""String_Node_Str"",Long.toString(props.size()));
  if (""String_Node_Str"".equals(request.method())) {
    request.response().end();
  }
 else {
    request.response().sendFile(file);
    request.response().end();
  }
}","/** 
 * Write a file into the response body
 * @param request
 * @param file
 * @param props
 */
private void sendFile(final YokeRequest request,final String file,final FileProps props){
  String contentType=MimeType.getMime(file);
  String charset=MimeType.getCharset(contentType);
  request.response().setContentType(contentType,charset);
  request.response().putHeader(""String_Node_Str"",Long.toString(props.size()));
  if (""String_Node_Str"".equals(request.method())) {
    request.response().end();
  }
 else {
    request.response().sendFile(file);
  }
}",0.9738219895287958
56277,"@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, InvalidAttributeValueException, MBeanException, ReflectionException {
}","@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, InvalidAttributeValueException, MBeanException, ReflectionException {
  throw new MBeanException(new UnsupportedOperationException());
}",0.8329048843187661
56278,"@Override public Object getAttribute(String attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  return null;
}","@Override public synchronized Object getAttribute(String name) throws AttributeNotFoundException {
  Matcher m=middlewarePattern.matcher(name);
  if (m.matches()) {
    return middleware.get(Integer.parseInt(m.group(1))).getClass().getName();
  }
  throw new AttributeNotFoundException(""String_Node_Str"" + name);
}",0.4104803493449782
56279,"@Override public AttributeList getAttributes(String[] attributes){
  return null;
}","private MBeanAttributeInfo[] getAttributes(){
  MBeanAttributeInfo[] attrs=new MBeanAttributeInfo[middleware.size()];
  for (int i=0; i < middleware.size(); i++) {
    attrs[i]=new MBeanAttributeInfo(""String_Node_Str"" + i + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + i,true,false,false);
  }
  return attrs;
}",0.0592592592592592
56280,"@Override public Object invoke(String actionName,Object[] params,String[] signature) throws MBeanException, ReflectionException {
  return null;
}","@Override public Object invoke(String actionName,Object[] params,String[] signature) throws MBeanException, ReflectionException {
  throw new MBeanException(new UnsupportedOperationException());
}",0.8128654970760234
56281,"@Override public AttributeList setAttributes(AttributeList attributes){
  return null;
}","@Override public AttributeList setAttributes(AttributeList attributes){
  return new AttributeList();
}",0.900523560209424
56282,"@Override public MBeanInfo getMBeanInfo(){
  return new MBeanInfo(this.getClass().getName(),""String_Node_Str"",null,null,null,null);
}","@Override public MBeanInfo getMBeanInfo(){
  return new MBeanInfo(this.getClass().getName(),""String_Node_Str"",getAttributes(),null,null,null);
}",0.9386281588447654
56283,"void addMiddleware(@NotNull Middleware[] middleware){
  Collections.addAll(this.middleware,middleware);
}","private void addMiddleware(@NotNull Middleware[] middleware){
  Collections.addAll(this.middleware,middleware);
  try {
    mbs.unregisterMBean(objectName);
  }
 catch (  InstanceNotFoundException e) {
  }
catch (  MBeanRegistrationException e) {
    throw new RuntimeException(e);
  }
  try {
    mbs.registerMBean(new RouteMBean(this.middleware),objectName);
  }
 catch (  InstanceAlreadyExistsException e) {
  }
catch (  MBeanRegistrationException|NotCompliantMBeanException e) {
    throw new RuntimeException(e);
  }
}",0.3312101910828025
56284,"private void addPattern(String verb,String input,Middleware[] handler,List<PatternBinding> bindings){
  Matcher m=Pattern.compile(""String_Node_Str"").matcher(input);
  StringBuffer sb=new StringBuffer();
  Set<String> groups=new HashSet<>();
  while (m.find()) {
    String group=m.group().substring(1);
    if (groups.contains(group)) {
      throw new IllegalArgumentException(""String_Node_Str"" + group + ""String_Node_Str"");
    }
    m.appendReplacement(sb,""String_Node_Str"");
    groups.add(group);
  }
  m.appendTail(sb);
  if (sb.charAt(sb.length() - 1) != '/') {
    sb.append(""String_Node_Str"");
  }
  Pattern regex=Pattern.compile(sb.toString());
  boolean exists=false;
  for (  PatternBinding pb : bindings) {
    if (pb.pattern.equals(regex)) {
      pb.addMiddleware(handler);
      exists=true;
      break;
    }
  }
  if (!exists) {
    PatternBinding binding=new PatternBinding(hashCode(),verb,input,regex,groups,handler);
    bindings.add(binding);
  }
  for (  Middleware h : handler) {
    if (!h.isInitialized() && isInitialized()) {
      h.init(yoke,mount);
    }
  }
}","private void addPattern(String verb,String input,Middleware[] handler,List<PatternBinding> bindings){
  Matcher m=Pattern.compile(""String_Node_Str"").matcher(input);
  StringBuffer sb=new StringBuffer();
  Set<String> groups=new HashSet<>();
  while (m.find()) {
    String group=m.group().substring(1);
    if (groups.contains(group)) {
      throw new IllegalArgumentException(""String_Node_Str"" + group + ""String_Node_Str"");
    }
    m.appendReplacement(sb,""String_Node_Str"");
    groups.add(group);
  }
  m.appendTail(sb);
  if (sb.charAt(sb.length() - 1) != '/') {
    sb.append(""String_Node_Str"");
  }
  Pattern regex=Pattern.compile(sb.toString());
  boolean exists=false;
  for (  PatternBinding pb : bindings) {
    if (pb.isFor(input)) {
      exists=true;
      pb.addMiddleware(handler);
      break;
    }
  }
  if (!exists) {
    PatternBinding binding=new PatternBinding(hashCode(),verb,input,regex,groups,handler);
    bindings.add(binding);
  }
  for (  Middleware h : handler) {
    if (!h.isInitialized() && isInitialized()) {
      h.init(yoke,mount);
    }
  }
}",0.966405890473999
56285,"private PatternBinding(int hasCode,@NotNull String verb,@Nullable String route,@NotNull Pattern pattern,Set<String> paramNames,@NotNull Middleware[] middleware){
  this.pattern=pattern;
  this.paramNames=paramNames;
  Collections.addAll(this.middleware,middleware);
  final MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    mbs.registerMBean(new RouteMBean(),new ObjectName(""String_Node_Str"" + hasCode + ""String_Node_Str""+ verb+ ""String_Node_Str""+ ObjectName.quote(route)));
  }
 catch (  InstanceAlreadyExistsException e) {
  }
catch (  MalformedObjectNameException|MBeanRegistrationException|NotCompliantMBeanException e) {
    throw new RuntimeException(e);
  }
}","private PatternBinding(int hasCode,@NotNull String verb,@Nullable String route,@NotNull Pattern pattern,@Nullable Set<String> paramNames,@NotNull Middleware[] middleware){
  this.route=route;
  this.pattern=pattern;
  this.paramNames=paramNames;
  Collections.addAll(this.middleware,middleware);
  try {
    objectName=new ObjectName(""String_Node_Str"" + hasCode + ""String_Node_Str""+ verb+ ""String_Node_Str""+ ObjectName.quote(route));
  }
 catch (  MalformedObjectNameException e) {
    throw new RuntimeException(e);
  }
  try {
    mbs.registerMBean(new RouteMBean(this.middleware),objectName);
  }
 catch (  InstanceAlreadyExistsException e) {
  }
catch (  MBeanRegistrationException|NotCompliantMBeanException e) {
    throw new RuntimeException(e);
  }
}",0.5145228215767634
56286,"private void addRegEx(String verb,Pattern regex,Middleware handler[],List<PatternBinding> bindings){
  boolean exists=false;
  for (  PatternBinding pb : bindings) {
    if (pb.pattern.equals(regex)) {
      pb.addMiddleware(handler);
      exists=true;
      break;
    }
  }
  if (!exists) {
    PatternBinding binding=new PatternBinding(hashCode(),verb,regex.pattern(),regex,null,handler);
    bindings.add(binding);
  }
  for (  Middleware h : handler) {
    if (!h.isInitialized() && isInitialized()) {
      h.init(yoke,mount);
    }
  }
}","private void addRegEx(String verb,Pattern regex,Middleware handler[],List<PatternBinding> bindings){
  boolean exists=false;
  for (  PatternBinding pb : bindings) {
    if (pb.isFor(regex)) {
      pb.addMiddleware(handler);
      exists=true;
      break;
    }
  }
  if (!exists) {
    PatternBinding binding=new PatternBinding(hashCode(),verb,null,regex,null,handler);
    bindings.add(binding);
  }
  for (  Middleware h : handler) {
    if (!h.isInitialized() && isInitialized()) {
      h.init(yoke,mount);
    }
  }
}",0.6822429906542056
56287,"@Override public void handle(@NotNull final YokeRequest request,@NotNull final Handler<Object> next){
  String token=null;
  if (""String_Node_Str"".equals(request.method()) && request.getHeader(""String_Node_Str"") != null) {
    for (    String ctrlReq : request.getHeader(""String_Node_Str"").split(""String_Node_Str"")) {
      if (ctrlReq.contains(""String_Node_Str"")) {
        next.handle(null);
        return;
      }
    }
  }
  if (skip != null && skip.contains(request.normalizedPath())) {
    next.handle(null);
    return;
  }
  final String authorization=request.getHeader(""String_Node_Str"");
  if (authorization != null) {
    String[] parts=authorization.split(""String_Node_Str"");
    if (parts.length == 2) {
      final String scheme=parts[0], credentials=parts[1];
      if (BEARER.matcher(scheme).matches()) {
        token=credentials;
      }
    }
 else {
      next.handle(new YokeException(401,""String_Node_Str""));
      return;
    }
  }
 else {
    next.handle(new YokeException(401,""String_Node_Str""));
    return;
  }
  try {
    final JsonObject jwtToken=jwt.decode(token);
    final long now=System.currentTimeMillis();
    if (jwtToken.containsField(""String_Node_Str"")) {
      Long iat=jwtToken.getLong(""String_Node_Str"");
      if (iat >= now) {
        next.handle(new YokeException(401,""String_Node_Str""));
        return;
      }
    }
    if (jwtToken.containsField(""String_Node_Str"")) {
      Long nbf=jwtToken.getLong(""String_Node_Str"");
      if (nbf >= now) {
        next.handle(new YokeException(401,""String_Node_Str""));
        return;
      }
    }
    if (jwtToken.containsField(""String_Node_Str"")) {
      Long exp=jwtToken.getLong(""String_Node_Str"");
      if (exp >= now) {
        next.handle(new YokeException(401,""String_Node_Str""));
        return;
      }
    }
    request.put(""String_Node_Str"",jwt.decode(token));
    if (handler == null) {
      next.handle(null);
      return;
    }
    handler.handle(jwtToken,next);
  }
 catch (  RuntimeException e) {
    next.handle(new YokeException(401,e));
  }
}","@Override public void handle(@NotNull final YokeRequest request,@NotNull final Handler<Object> next){
  String token=null;
  if (""String_Node_Str"".equals(request.method()) && request.getHeader(""String_Node_Str"") != null) {
    for (    String ctrlReq : request.getHeader(""String_Node_Str"").split(""String_Node_Str"")) {
      if (ctrlReq.contains(""String_Node_Str"")) {
        next.handle(null);
        return;
      }
    }
  }
  if (skip != null && skip.contains(request.normalizedPath())) {
    next.handle(null);
    return;
  }
  final String authorization=request.getHeader(""String_Node_Str"");
  if (authorization != null) {
    String[] parts=authorization.split(""String_Node_Str"");
    if (parts.length == 2) {
      final String scheme=parts[0], credentials=parts[1];
      if (BEARER.matcher(scheme).matches()) {
        token=credentials;
      }
    }
 else {
      next.handle(new YokeException(401,""String_Node_Str""));
      return;
    }
  }
 else {
    next.handle(new YokeException(401,""String_Node_Str""));
    return;
  }
  try {
    final JsonObject jwtToken=jwt.decode(token);
    final long now=System.currentTimeMillis();
    if (jwtToken.containsField(""String_Node_Str"")) {
      Long iat=jwtToken.getLong(""String_Node_Str"");
      if (iat >= now) {
        next.handle(new YokeException(401,""String_Node_Str""));
        return;
      }
    }
    if (jwtToken.containsField(""String_Node_Str"")) {
      Long nbf=jwtToken.getLong(""String_Node_Str"");
      if (nbf >= now) {
        next.handle(new YokeException(401,""String_Node_Str""));
        return;
      }
    }
    if (jwtToken.containsField(""String_Node_Str"")) {
      Long exp=jwtToken.getLong(""String_Node_Str"");
      if (now > exp) {
        next.handle(new YokeException(401,""String_Node_Str""));
        return;
      }
    }
    request.put(""String_Node_Str"",jwt.decode(token));
    if (handler == null) {
      next.handle(null);
      return;
    }
    handler.handle(jwtToken,next);
  }
 catch (  RuntimeException e) {
    next.handle(new YokeException(401,e));
  }
}",0.9968346725103482
56288,"public String encode(JsonObject payload,String algorithm){
  Crypto crypto=CRYPTO_MAP.get(algorithm);
  if (crypto == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  JsonObject header=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",algorithm);
  String headerSegment=base64urlEncode(header.encode());
  String payloadSegment=base64urlEncode(payload.encode());
  String signingInput=headerSegment + ""String_Node_Str"" + payloadSegment;
  String signSegment=base64urlEscape(Base64.encodeBytes(crypto.sign(signingInput.getBytes())));
  return headerSegment + ""String_Node_Str"" + payloadSegment+ ""String_Node_Str""+ signSegment;
}","public String encode(JsonObject payload,String algorithm){
  Crypto crypto=CRYPTO_MAP.get(algorithm);
  if (crypto == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  JsonObject header=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",algorithm);
  String headerSegment=base64urlEncode(header.encode());
  String payloadSegment=base64urlEncode(payload.encode());
  String signingInput=headerSegment + ""String_Node_Str"" + payloadSegment;
  String signSegment=base64urlEscape(Base64.encodeBytes(crypto.sign(signingInput.getBytes()),Base64.DONT_BREAK_LINES));
  return headerSegment + ""String_Node_Str"" + payloadSegment+ ""String_Node_Str""+ signSegment;
}",0.9827833572453372
56289,"public JWT(final String secret){
  CRYPTO_MAP.put(""String_Node_Str"",new Crypto(){
    final Mac mac=Utils.newHmac(""String_Node_Str"",secret);
    @Override public byte[] sign(    byte[] payload){
      return mac.doFinal(payload);
    }
    @Override public boolean verify(    byte[] signature,    byte[] payload){
      return Arrays.equals(payload,mac.doFinal(payload));
    }
  }
);
  CRYPTO_MAP.put(""String_Node_Str"",new Crypto(){
    final Mac mac=Utils.newHmac(""String_Node_Str"",secret);
    @Override public byte[] sign(    byte[] payload){
      return mac.doFinal(payload);
    }
    @Override public boolean verify(    byte[] signature,    byte[] payload){
      return Arrays.equals(payload,mac.doFinal(payload));
    }
  }
);
  CRYPTO_MAP.put(""String_Node_Str"",new Crypto(){
    final Mac mac=Utils.newHmac(""String_Node_Str"",secret);
    @Override public byte[] sign(    byte[] payload){
      return mac.doFinal(payload);
    }
    @Override public boolean verify(    byte[] signature,    byte[] payload){
      return Arrays.equals(payload,mac.doFinal(payload));
    }
  }
);
  CRYPTO_MAP.put(""String_Node_Str"",new Crypto(){
    final Signature sig=Utils.newSignature(""String_Node_Str"");
    @Override public byte[] sign(    byte[] payload){
      try {
        sig.update(payload);
        return sig.sign();
      }
 catch (      SignatureException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public boolean verify(    byte[] signature,    byte[] payload){
      try {
        sig.update(payload);
        return sig.verify(signature);
      }
 catch (      SignatureException e) {
        throw new RuntimeException(e);
      }
    }
  }
);
}","public JWT(final String secret){
  CRYPTO_MAP.put(""String_Node_Str"",new Crypto(){
    final Mac mac=Utils.newHmac(""String_Node_Str"",secret);
    @Override public byte[] sign(    byte[] payload){
      return mac.doFinal(payload);
    }
    @Override public boolean verify(    byte[] signature,    byte[] payload){
      return Arrays.equals(signature,mac.doFinal(payload));
    }
  }
);
  CRYPTO_MAP.put(""String_Node_Str"",new Crypto(){
    final Mac mac=Utils.newHmac(""String_Node_Str"",secret);
    @Override public byte[] sign(    byte[] payload){
      return mac.doFinal(payload);
    }
    @Override public boolean verify(    byte[] signature,    byte[] payload){
      return Arrays.equals(signature,mac.doFinal(payload));
    }
  }
);
  CRYPTO_MAP.put(""String_Node_Str"",new Crypto(){
    final Mac mac=Utils.newHmac(""String_Node_Str"",secret);
    @Override public byte[] sign(    byte[] payload){
      return mac.doFinal(payload);
    }
    @Override public boolean verify(    byte[] signature,    byte[] payload){
      return Arrays.equals(signature,mac.doFinal(payload));
    }
  }
);
  CRYPTO_MAP.put(""String_Node_Str"",new Crypto(){
    final Signature sig=Utils.newSignature(""String_Node_Str"");
    @Override public byte[] sign(    byte[] payload){
      try {
        sig.update(payload);
        return sig.sign();
      }
 catch (      SignatureException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public boolean verify(    byte[] signature,    byte[] payload){
      try {
        sig.update(payload);
        return sig.verify(signature);
      }
 catch (      SignatureException e) {
        throw new RuntimeException(e);
      }
    }
  }
);
}",0.9857904085257548
56290,"private static String base64urlDecode(String str){
  return new String(Base64.decode(base64urlUnescape(str)));
}","private static String base64urlDecode(String str){
  return new String(Base64.decode(base64urlUnescape(str),Base64.DONT_BREAK_LINES));
}",0.9032258064516128
56291,"public JsonObject decode(final String token,boolean noVerify){
  String[] segments=token.split(""String_Node_Str"");
  if (segments.length != 3) {
    throw new RuntimeException(""String_Node_Str"");
  }
  String headerSeg=segments[0];
  String payloadSeg=segments[1];
  String signatureSeg=segments[2];
  JsonObject header=new JsonObject(base64urlDecode(headerSeg));
  JsonObject payload=new JsonObject(base64urlDecode(payloadSeg));
  if (!noVerify) {
    Crypto crypto=CRYPTO_MAP.get(header.getString(""String_Node_Str""));
    if (crypto == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    String signingInput=headerSeg + ""String_Node_Str"" + payloadSeg;
    if (!crypto.verify(signatureSeg.getBytes(),signingInput.getBytes())) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return payload;
}","public JsonObject decode(final String token,boolean noVerify){
  String[] segments=token.split(""String_Node_Str"");
  if (segments.length != 3) {
    throw new RuntimeException(""String_Node_Str"");
  }
  String headerSeg=segments[0];
  String payloadSeg=segments[1];
  String signatureSeg=segments[2];
  JsonObject header=new JsonObject(base64urlDecode(headerSeg));
  JsonObject payload=new JsonObject(base64urlDecode(payloadSeg));
  if (!noVerify) {
    Crypto crypto=CRYPTO_MAP.get(header.getString(""String_Node_Str""));
    if (crypto == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    String signingInput=headerSeg + ""String_Node_Str"" + payloadSeg;
    if (!crypto.verify(Base64.decode(base64urlUnescape(signatureSeg),Base64.DONT_BREAK_LINES),signingInput.getBytes())) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return payload;
}",0.9490333919156416
56292,"private static String base64urlEncode(String str){
  return base64urlEscape(Base64.encodeBytes(str.getBytes()));
}","private static String base64urlEncode(String str){
  return base64urlEscape(Base64.encodeBytes(str.getBytes(),Base64.DONT_BREAK_LINES));
}",0.9047619047619048
56293,"public Object getAt(String key){
  List<String> out=impl.getAll(key);
  if (out != null) {
    if (out.size() == 1) {
      return out.get(0);
    }
  }
  return out;
}","public Object getAt(String key){
  List<String> out=impl.getAll(key);
  if (out != null) {
    if (out.size() == 1) {
      return out.get(0);
    }
    if (out.size() == 0) {
      return null;
    }
  }
  return out;
}",0.7783505154639175
56294,"@Override public void handle(YokeRequest request,Handler<Object> next){
  try {
    if (consumes != null) {
      boolean canConsume=false;
      for (      String c : consumes) {
        if (request.is(c)) {
          canConsume=true;
          break;
        }
      }
      if (!canConsume) {
        next.handle(415);
        return;
      }
    }
    if (produces != null) {
      String bestContentType=request.accepts(produces);
      if (bestContentType == null) {
        next.handle(406);
        return;
      }
      request.response().setContentType(bestContentType);
    }
    m.invoke(o,request,next);
  }
 catch (  Throwable e) {
    next.handle(e);
  }
}","@Override public void handle(Object err){
  if (err == null) {
    next();
  }
 else {
    next.handle(err);
  }
}",0.2751592356687898
56295,"private void route(final YokeRequest request,final PatternBinding binding,final Handler<Object> next){
  final Matcher m=binding.pattern.matcher(request.path());
  if (m.matches()) {
    final MultiMap params=request.params();
    if (binding.paramNames != null) {
      new AsyncIterator<String>(binding.paramNames){
        @Override public void handle(        String param){
          if (hasNext()) {
            params.add(param,m.group(param));
            Middleware paramMiddleware=paramProcessors.get(param);
            if (paramMiddleware != null) {
              paramMiddleware.handle(request,new Handler<Object>(){
                @Override public void handle(                Object err){
                  if (err == null) {
                    next();
                  }
 else {
                    next.handle(err);
                  }
                }
              }
);
            }
 else {
              next();
            }
          }
 else {
            binding.middleware.handle(request,next);
          }
        }
      }
;
    }
 else {
      for (int i=0; i < m.groupCount(); i++) {
        params.add(""String_Node_Str"" + i,m.group(i + 1));
      }
      binding.middleware.handle(request,next);
    }
  }
 else {
    next.handle(null);
  }
}","private void route(final YokeRequest request,final PatternBinding binding,final Handler<Object> next){
  final Matcher m=binding.pattern.matcher(request.path());
  if (m.matches()) {
    final MultiMap params=request.params();
    if (binding.paramNames != null) {
      new AsyncIterator<String>(binding.paramNames){
        @Override public void handle(        String param){
          if (hasNext()) {
            params.set(param,m.group(param));
            Middleware paramMiddleware=paramProcessors.get(param);
            if (paramMiddleware != null) {
              paramMiddleware.handle(request,new Handler<Object>(){
                @Override public void handle(                Object err){
                  if (err == null) {
                    next();
                  }
 else {
                    next.handle(err);
                  }
                }
              }
);
            }
 else {
              next();
            }
          }
 else {
            binding.middleware.handle(request,next);
          }
        }
      }
;
    }
 else {
      for (int i=0; i < m.groupCount(); i++) {
        params.set(""String_Node_Str"" + i,m.group(i + 1));
      }
      binding.middleware.handle(request,next);
    }
  }
 else {
    next.handle(null);
  }
}",0.9952904238618524
56296,"public HandlebarsEngine(final String views){
  super(null);
  if (""String_Node_Str"".equals(views)) {
    prefix=views;
  }
 else {
    prefix=views.endsWith(""String_Node_Str"") ? views : views + ""String_Node_Str"";
  }
  handlebars=new Handlebars(new TemplateLoader(){
    @Override public TemplateSource sourceAt(    final String location) throws IOException {
      try {
        return new TemplateSource(){
          @Override public String content() throws IOException {
            return read(resolve(location));
          }
          @Override public String filename(){
            return location;
          }
          @Override public long lastModified(){
            return HandlebarsEngine.this.lastModified(location);
          }
        }
;
      }
 catch (      Exception e) {
        e.printStackTrace();
        throw new IOException(e);
      }
    }
    @Override public String resolve(    String location){
      return HandlebarsEngine.this.resolve(location);
    }
    @Override public String getPrefix(){
      return prefix;
    }
    @Override public String getSuffix(){
      return extension;
    }
  }
);
}","public HandlebarsEngine(final String views){
  super(null);
  if (""String_Node_Str"".equals(views)) {
    prefix=views;
  }
 else {
    prefix=views.endsWith(""String_Node_Str"") ? views : views + ""String_Node_Str"";
  }
  handlebars=new Handlebars(new TemplateLoader(){
    @Override public TemplateSource sourceAt(    final String location) throws IOException {
      final String buffer=read(resolve(location));
      if (buffer == null) {
        throw new FileNotFoundException(location);
      }
      return new TemplateSource(){
        @Override public String content() throws IOException {
          return buffer;
        }
        @Override public String filename(){
          return location;
        }
        @Override public long lastModified(){
          return HandlebarsEngine.this.lastModified(location);
        }
      }
;
    }
    @Override public String resolve(    String location){
      return HandlebarsEngine.this.resolve(location);
    }
    @Override public String getPrefix(){
      return prefix;
    }
    @Override public String getSuffix(){
      return extension;
    }
  }
);
}",0.8169265033407572
56297,"@Override public TemplateSource sourceAt(final String location) throws IOException {
  try {
    return new TemplateSource(){
      @Override public String content() throws IOException {
        return read(resolve(location));
      }
      @Override public String filename(){
        return location;
      }
      @Override public long lastModified(){
        return HandlebarsEngine.this.lastModified(location);
      }
    }
;
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new IOException(e);
  }
}","@Override public TemplateSource sourceAt(final String location) throws IOException {
  final String buffer=read(resolve(location));
  if (buffer == null) {
    throw new FileNotFoundException(location);
  }
  return new TemplateSource(){
    @Override public String content() throws IOException {
      return buffer;
    }
    @Override public String filename(){
      return location;
    }
    @Override public long lastModified(){
      return HandlebarsEngine.this.lastModified(location);
    }
  }
;
}",0.7205452775073028
56298,"@Override public String content() throws IOException {
  return read(resolve(location));
}","@Override public String content() throws IOException {
  return buffer;
}",0.8343558282208589
56299,"@Test public void testEngine(){
  try {
    File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    FileOutputStream out=new FileOutputStream(temp);
    out.write(""String_Node_Str"".getBytes());
    out.close();
    final String location=temp.getAbsolutePath();
    Yoke yoke=new Yoke(this);
    yoke.engine(""String_Node_Str"",new com.jetdrone.vertx.yoke.extras.engine.Jade4JEngine());
    yoke.use(new Middleware(){
      @Override public void handle(      YokeRequest request,      Handler<Object> next){
        request.response().render(location,next);
      }
    }
);
    new YokeTester(vertx,yoke).request(""String_Node_Str"",""String_Node_Str"",new Handler<Response>(){
      @Override public void handle(      Response resp){
        assertEquals(200,resp.getStatusCode());
        assertEquals(""String_Node_Str"",resp.body.toString());
        testComplete();
      }
    }
);
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}","@Test public void testEngine(){
  try {
    File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    FileOutputStream out=new FileOutputStream(temp);
    out.write(""String_Node_Str"".getBytes());
    out.close();
    final String location=temp.getAbsolutePath();
    Yoke yoke=new Yoke(this);
    yoke.engine(""String_Node_Str"",new com.jetdrone.vertx.yoke.extras.engine.Jade4JEngine(""String_Node_Str"",""String_Node_Str""));
    yoke.use(new Middleware(){
      @Override public void handle(      YokeRequest request,      Handler<Object> next){
        request.response().render(location,next);
      }
    }
);
    new YokeTester(vertx,yoke).request(""String_Node_Str"",""String_Node_Str"",new Handler<Response>(){
      @Override public void handle(      Response resp){
        assertEquals(200,resp.getStatusCode());
        assertEquals(""String_Node_Str"",resp.body.toString());
        testComplete();
      }
    }
);
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}",0.9820236260914228
56300,"@Test public void testEngine2(){
  try {
    File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    FileOutputStream out=new FileOutputStream(temp);
    String template=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    out.write(template.getBytes());
    out.close();
    final String location=temp.getAbsolutePath();
    Yoke yoke=new Yoke(this);
    yoke.engine(""String_Node_Str"",new com.jetdrone.vertx.yoke.extras.engine.Jade4JEngine());
    yoke.use(new Middleware(){
      @Override public void handle(      YokeRequest request,      Handler<Object> next){
        request.put(""String_Node_Str"",""String_Node_Str"");
        request.response().render(location,next);
      }
    }
);
    new YokeTester(vertx,yoke).request(""String_Node_Str"",""String_Node_Str"",new Handler<Response>(){
      @Override public void handle(      Response resp){
        assertEquals(200,resp.getStatusCode());
        assertEquals(""String_Node_Str"",resp.body.toString());
        testComplete();
      }
    }
);
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}","@Test public void testEngine2(){
  try {
    File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    FileOutputStream out=new FileOutputStream(temp);
    String template=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    out.write(template.getBytes());
    out.close();
    final String location=temp.getAbsolutePath();
    Yoke yoke=new Yoke(this);
    yoke.engine(""String_Node_Str"",new com.jetdrone.vertx.yoke.extras.engine.Jade4JEngine(""String_Node_Str"",""String_Node_Str""));
    yoke.use(new Middleware(){
      @Override public void handle(      YokeRequest request,      Handler<Object> next){
        request.put(""String_Node_Str"",""String_Node_Str"");
        request.response().render(location,next);
      }
    }
);
    new YokeTester(vertx,yoke).request(""String_Node_Str"",""String_Node_Str"",new Handler<Response>(){
      @Override public void handle(      Response resp){
        assertEquals(200,resp.getStatusCode());
        assertEquals(""String_Node_Str"",resp.body.toString());
        testComplete();
      }
    }
);
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}",0.986050219210841
56301,"@Override public void handle(YokeRequest request,Handler<Object> next){
  String token=request.get(key);
  if (token == null) {
    token=UUID.randomUUID().toString();
    request.put(key,token);
  }
  if (""String_Node_Str"".equals(request.method()) || ""String_Node_Str"".equals(request.method()) || ""String_Node_Str"".equals(request.method())) {
    next.handle(null);
    return;
  }
  String val=valueHandler.handle(request);
  if (!token.equals(val)) {
    next.handle(403);
  }
  next.handle(null);
}","@Override public void handle(YokeRequest request,Handler<Object> next){
  String token=request.get(key);
  if (token == null) {
    token=UUID.randomUUID().toString();
    request.put(key,token);
  }
  if (""String_Node_Str"".equals(request.method()) || ""String_Node_Str"".equals(request.method()) || ""String_Node_Str"".equals(request.method())) {
    next.handle(null);
    return;
  }
  request.expectMultiPart(true);
  String val=valueHandler.handle(request);
  if (!token.equals(val)) {
    next.handle(403);
    return;
  }
  next.handle(null);
}",0.9571020019065776
56302,"@Override public HttpServerRequest expectMultiPart(boolean expect){
  request.expectMultiPart(expect);
  return this;
}","@Override public HttpServerRequest expectMultiPart(boolean expect){
  if (expect) {
    if (!expectMultiPartCalled) {
      expectMultiPartCalled=true;
      request.expectMultiPart(expect);
    }
  }
 else {
    expectMultiPartCalled=false;
    request.expectMultiPart(expect);
  }
  return this;
}",0.569377990430622
56303,"public Object getJson(){
  Object _body=body();
  if (_body != null && _body instanceof String) {
    char initial=((String)_body).charAt(0);
    if (initial == '{') {
      JsonSlurper slurper=new JsonSlurper();
      return slurper.parseText((String)_body);
    }
  }
  return null;
}","public Object getJson(){
  Object _body=body();
  if (_body != null && _body instanceof String) {
    Boolean validObject=(Boolean)get(""String_Node_Str"");
    Boolean validArray=(Boolean)get(""String_Node_Str"");
    if (validObject != null && validObject) {
      return parseText((String)_body);
    }
    if (validArray != null && validArray) {
      return parseText((String)_body);
    }
  }
  return null;
}",0.4992826398852223
56304,"private void parseJson(final YokeRequest request,final Buffer buffer,final Handler<Object> next){
  try {
    String content=buffer.toString();
    if (content.length() > 0) {
      char initial=content.charAt(0);
      if (initial == '{' || initial == '[') {
        request.setBody(content);
        next.handle(null);
      }
 else {
        next.handle(400);
      }
    }
 else {
      next.handle(400);
    }
  }
 catch (  DecodeException ex) {
    next.handle(ex);
  }
}","private void parseJson(final YokeRequest request,final Buffer buffer,final Handler<Object> next){
  try {
    String content=buffer.toString();
    if (content.length() > 0) {
switch (content.charAt(0)) {
case '{':
        request.setBody(content);
      request.put(""String_Node_Str"",true);
    next.handle(null);
  break;
case '[':
request.setBody(content);
request.put(""String_Node_Str"",true);
next.handle(null);
break;
default :
next.handle(400);
}
}
 else {
next.handle(400);
}
}
 catch (DecodeException ex) {
next.handle(ex);
}
}",0.616600790513834
56305,"/** 
 * The request setBody and eventually a parsed version of it in json or map
 */
public JsonObject jsonBody(){
  if (body != null && body instanceof String) {
    char initial=((String)body).charAt(0);
    if (initial == '{') {
      return new JsonObject((String)body);
    }
  }
  return null;
}","/** 
 * A parsed Json Array if body is detected to contain a valid String for Json Object.
 */
public JsonObject jsonBody(){
  if (body != null && body instanceof String) {
    Boolean flag=(Boolean)get(""String_Node_Str"");
    if (flag != null && flag) {
      return new JsonObject((String)body);
    }
  }
  return null;
}",0.5824
56306,"/** 
 * Check if the given type(s) is acceptable, returning the best match when true, otherwise null, in which case you should respond with 406 ""Not Acceptable"". The type value must be a single mime type string such as ""application/json"" and is validated by checking if the request string starts with it.
 */
public String accepts(String... types){
  String accept=getHeader(""String_Node_Str"");
  if (accept == null) {
    return types[0];
  }
  String[] acceptTypes=accept.split(""String_Node_Str"");
  Arrays.sort(acceptTypes,ACCEPT_X_COMPARATOR);
  for (  String senderAccept : acceptTypes) {
    for (    String appAccept : types) {
      if (senderAccept.startsWith(appAccept)) {
        return senderAccept;
      }
    }
  }
  return null;
}","/** 
 * Check if the given type(s) is acceptable, returning the best match when true, otherwise null, in which case you should respond with 406 ""Not Acceptable"". The type value must be a single mime type string such as ""application/json"" and is validated by checking if the request string starts with it.
 */
public String accepts(String... types){
  String accept=getHeader(""String_Node_Str"");
  if (accept == null) {
    return types[0];
  }
  String[] acceptTypes=accept.split(""String_Node_Str"");
  Arrays.sort(acceptTypes,ACCEPT_X_COMPARATOR);
  for (  String senderAccept : acceptTypes) {
    String[] sAccept=splitMime(senderAccept);
    for (    String appAccept : types) {
      String[] aAccept=splitMime(appAccept);
      if ((sAccept[0].equals(aAccept[0]) || ""String_Node_Str"".equals(sAccept[0]) || ""String_Node_Str"".equals(aAccept[0])) && (sAccept[1].equals(aAccept[1]) || ""String_Node_Str"".equals(sAccept[1]) || ""String_Node_Str"".equals(aAccept[1]))) {
        return senderAccept;
      }
    }
  }
  return null;
}",0.8033802816901409
56307,"/** 
 * Builds a Router from an annotated Java Object
 */
public static Router from(Object... objs){
  Router router=new Router();
  for (  Object o : objs) {
    for (    final Method m : o.getClass().getMethods()) {
      Annotation[] annotations=m.getAnnotations();
      if (annotations == null) {
        continue;
      }
      Class[] paramTypes=m.getParameterTypes();
      int type=0;
      if (paramTypes != null) {
        if (paramTypes.length == 1 && paramTypes[0].equals(YokeRequest.class)) {
          type=1;
        }
        if (paramTypes.length == 2 && paramTypes[0].equals(YokeRequest.class) && paramTypes[0].equals(Handler.class)) {
          type=2;
        }
      }
      if (type == 0) {
        continue;
      }
      String path=getPath(o,m);
      for (      Annotation a : annotations) {
        if (a instanceof GET) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof PUT) {
          router.put(path,wrap(o,m,type == 1));
        }
        if (a instanceof POST) {
          router.post(path,wrap(o,m,type == 1));
        }
        if (a instanceof DELETE) {
          router.delete(path,wrap(o,m,type == 1));
        }
        if (a instanceof OPTIONS) {
          router.options(path,wrap(o,m,type == 1));
        }
        if (a instanceof HEAD) {
          router.head(path,wrap(o,m,type == 1));
        }
        if (a instanceof TRACE) {
          router.trace(path,wrap(o,m,type == 1));
        }
        if (a instanceof PATCH) {
          router.patch(path,wrap(o,m,type == 1));
        }
        if (a instanceof CONNECT) {
          router.connect(path,wrap(o,m,type == 1));
        }
        if (a instanceof ALL) {
          router.all(path,wrap(o,m,type == 1));
        }
      }
    }
  }
  return router;
}","/** 
 * Builds a Router from an annotated Java Object
 */
public static Router from(Object... objs){
  Router router=new Router();
  for (  Object o : objs) {
    for (    final Method m : o.getClass().getMethods()) {
      Annotation[] annotations=m.getAnnotations();
      if (annotations == null) {
        continue;
      }
      Class[] paramTypes=m.getParameterTypes();
      int type=0;
      if (paramTypes != null) {
        if (paramTypes.length == 1 && paramTypes[0].equals(YokeRequest.class)) {
          type=1;
        }
        if (paramTypes.length == 2 && paramTypes[0].equals(YokeRequest.class) && paramTypes[1].equals(Handler.class)) {
          type=2;
        }
      }
      if (type == 0) {
        continue;
      }
      String path=getPath(o,m);
      for (      Annotation a : annotations) {
        if (a instanceof GET) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof PUT) {
          router.put(path,wrap(o,m,type == 1));
        }
        if (a instanceof POST) {
          router.post(path,wrap(o,m,type == 1));
        }
        if (a instanceof DELETE) {
          router.delete(path,wrap(o,m,type == 1));
        }
        if (a instanceof OPTIONS) {
          router.options(path,wrap(o,m,type == 1));
        }
        if (a instanceof HEAD) {
          router.head(path,wrap(o,m,type == 1));
        }
        if (a instanceof TRACE) {
          router.trace(path,wrap(o,m,type == 1));
        }
        if (a instanceof PATCH) {
          router.patch(path,wrap(o,m,type == 1));
        }
        if (a instanceof CONNECT) {
          router.connect(path,wrap(o,m,type == 1));
        }
        if (a instanceof ALL) {
          router.all(path,wrap(o,m,type == 1));
        }
      }
    }
  }
  return router;
}",0.999441028507546
56308,"@Override public void handle(final YokeRequest request,final Handler<Object> next){
  final Map<String,String> urlEncoded=request.formAttributes();
  if (urlEncoded != null) {
    String method=urlEncoded.get(key);
    if (method != null) {
      urlEncoded.remove(key);
      request.setMethod(method);
      next.handle(null);
      return;
    }
  }
  final JsonObject json=request.jsonBody();
  if (json != null) {
    String method=json.getString(key);
    if (method != null) {
      json.removeField(key);
      request.setMethod(method);
      next.handle(null);
      return;
    }
  }
  String xHttpMethodOverride=request.getHeader(""String_Node_Str"");
  if (xHttpMethodOverride != null) {
    request.setMethod(xHttpMethodOverride);
    next.handle(null);
  }
}","@Override public void handle(final YokeRequest request,final Handler<Object> next){
  final Map<String,String> urlEncoded=request.formAttributes();
  if (urlEncoded != null) {
    String method=urlEncoded.get(key);
    if (method != null) {
      urlEncoded.remove(key);
      request.setMethod(method);
      next.handle(null);
      return;
    }
  }
  final JsonObject json=request.jsonBody();
  if (json != null) {
    String method=json.getString(key);
    if (method != null) {
      json.removeField(key);
      request.setMethod(method);
      next.handle(null);
      return;
    }
  }
  String xHttpMethodOverride=request.getHeader(""String_Node_Str"");
  if (xHttpMethodOverride != null) {
    request.setMethod(xHttpMethodOverride);
  }
  next.handle(null);
}",0.9961038961038962
56309,"/** 
 * Builds a Router from an annotated Java Object
 */
public static Router from(Object... objs){
  Router router=new Router();
  for (  Object o : objs) {
    for (    final Method m : o.getClass().getMethods()) {
      Annotation[] annotations=m.getAnnotations();
      if (annotations == null) {
        continue;
      }
      Class[] paramTypes=m.getParameterTypes();
      int type=0;
      if (paramTypes != null) {
        if (paramTypes.length == 1 && paramTypes[0].equals(YokeRequest.class)) {
          type=1;
        }
        if (paramTypes.length == 2 && paramTypes[0].equals(YokeRequest.class) && paramTypes[0].equals(Handler.class)) {
          type=2;
        }
      }
      if (type == 0) {
        continue;
      }
      String path=getPath(o,m);
      for (      Annotation a : annotations) {
        if (a instanceof GET) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof PUT) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof POST) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof DELETE) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof OPTIONS) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof HEAD) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof TRACE) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof PATCH) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof CONNECT) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof ALL) {
          router.get(path,wrap(o,m,type == 1));
        }
      }
    }
  }
  return router;
}","/** 
 * Builds a Router from an annotated Java Object
 */
public static Router from(Object... objs){
  Router router=new Router();
  for (  Object o : objs) {
    for (    final Method m : o.getClass().getMethods()) {
      Annotation[] annotations=m.getAnnotations();
      if (annotations == null) {
        continue;
      }
      Class[] paramTypes=m.getParameterTypes();
      int type=0;
      if (paramTypes != null) {
        if (paramTypes.length == 1 && paramTypes[0].equals(YokeRequest.class)) {
          type=1;
        }
        if (paramTypes.length == 2 && paramTypes[0].equals(YokeRequest.class) && paramTypes[0].equals(Handler.class)) {
          type=2;
        }
      }
      if (type == 0) {
        continue;
      }
      String path=getPath(o,m);
      for (      Annotation a : annotations) {
        if (a instanceof GET) {
          router.get(path,wrap(o,m,type == 1));
        }
        if (a instanceof PUT) {
          router.put(path,wrap(o,m,type == 1));
        }
        if (a instanceof POST) {
          router.post(path,wrap(o,m,type == 1));
        }
        if (a instanceof DELETE) {
          router.delete(path,wrap(o,m,type == 1));
        }
        if (a instanceof OPTIONS) {
          router.options(path,wrap(o,m,type == 1));
        }
        if (a instanceof HEAD) {
          router.head(path,wrap(o,m,type == 1));
        }
        if (a instanceof TRACE) {
          router.trace(path,wrap(o,m,type == 1));
        }
        if (a instanceof PATCH) {
          router.patch(path,wrap(o,m,type == 1));
        }
        if (a instanceof CONNECT) {
          router.connect(path,wrap(o,m,type == 1));
        }
        if (a instanceof ALL) {
          router.all(path,wrap(o,m,type == 1));
        }
      }
    }
  }
  return router;
}",0.981746700365066
56310,"@Override public void setVertx(Vertx vertx){
  try {
    super.setVertx(vertx);
    if (path == null) {
      icon=new Icon(Utils.readResourceToBuffer(getClass(),""String_Node_Str""));
    }
 else {
      icon=new Icon(vertx.fileSystem().readFileSync(path));
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Override public Middleware setVertx(Vertx vertx){
  try {
    super.setVertx(vertx);
    if (path == null) {
      icon=new Icon(Utils.readResourceToBuffer(getClass(),""String_Node_Str""));
    }
 else {
      icon=new Icon(vertx.fileSystem().readFileSync(path));
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return this;
}",0.9547445255474452
56311,"@Override public void handle(Object error){
  if (error == null) {
    currentMiddleware++;
    if (currentMiddleware < middlewareList.size()) {
      MountedMiddleware mountedMiddleware=middlewareList.get(currentMiddleware);
      if (request.path().startsWith(mountedMiddleware.mount)) {
        Middleware middlewareItem=mountedMiddleware.middleware;
        middlewareItem.handle(request,this);
      }
 else {
        handle(null);
      }
    }
 else {
      HttpServerResponse response=request.response();
      response.setStatusCode(404);
      response.setStatusMessage(HttpResponseStatus.valueOf(404).reasonPhrase());
      if (errorHandler != null) {
        errorHandler.handle(request,null);
      }
 else {
        response.end(HttpResponseStatus.valueOf(404).reasonPhrase());
      }
    }
  }
 else {
    request.put(""String_Node_Str"",error);
    if (errorHandler != null) {
      errorHandler.handle(request,null);
    }
 else {
      HttpServerResponse response=request.response();
      if (error instanceof Integer) {
        int code=(Integer)error;
        response.setStatusCode(code);
        response.setStatusMessage(HttpResponseStatus.valueOf(code).reasonPhrase());
        response.end(HttpResponseStatus.valueOf(code).reasonPhrase());
      }
 else {
        response.setStatusCode(500);
        response.setStatusMessage(HttpResponseStatus.valueOf(500).reasonPhrase());
        response.end(HttpResponseStatus.valueOf(500).reasonPhrase());
      }
    }
  }
}","@Override public void handle(Object error){
  if (error == null) {
    currentMiddleware++;
    if (currentMiddleware < middlewareList.size()) {
      MountedMiddleware mountedMiddleware=middlewareList.get(currentMiddleware);
      if (request.path().startsWith(mountedMiddleware.mount)) {
        Middleware middlewareItem=mountedMiddleware.middleware;
        middlewareItem.handle(request,this);
      }
 else {
        handle(null);
      }
    }
 else {
      HttpServerResponse response=request.response();
      response.setStatusCode(404);
      response.setStatusMessage(HttpResponseStatus.valueOf(404).reasonPhrase());
      if (errorHandler != null) {
        errorHandler.handle(request,null);
      }
 else {
        response.end(HttpResponseStatus.valueOf(404).reasonPhrase());
      }
    }
  }
 else {
    request.put(""String_Node_Str"",error);
    if (errorHandler != null) {
      errorHandler.handle(request,null);
    }
 else {
      HttpServerResponse response=request.response();
      int errorCode=500;
      if (response.getStatusCode() >= 400) {
        errorCode=response.getStatusCode();
      }
      if (error instanceof Integer) {
        errorCode=(Integer)error;
      }
      response.setStatusCode(errorCode);
      response.setStatusMessage(HttpResponseStatus.valueOf(errorCode).reasonPhrase());
      response.end(HttpResponseStatus.valueOf(errorCode).reasonPhrase());
    }
  }
}",0.8045423262216105
56312,"/** 
 * Starts listening at a already created server.
 * @return Yoke
 */
public Yoke listen(final HttpServer server){
  final boolean secure=server.isSSL();
  server.requestHandler(new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest req){
      final Map<String,Object> context=new HashMap<>(defaultContext);
      final YokeHttpServerRequest request=requestWrapper.wrap(req,secure,context,engineMap);
      new Handler<Object>(){
        int currentMiddleware=-1;
        @Override public void handle(        Object error){
          if (error == null) {
            currentMiddleware++;
            if (currentMiddleware < middlewareList.size()) {
              MountedMiddleware mountedMiddleware=middlewareList.get(currentMiddleware);
              if (request.path().startsWith(mountedMiddleware.mount)) {
                Middleware middlewareItem=mountedMiddleware.middleware;
                middlewareItem.handle(request,this);
              }
 else {
                handle(null);
              }
            }
 else {
              HttpServerResponse response=request.response();
              response.setStatusCode(404);
              response.setStatusMessage(HttpResponseStatus.valueOf(404).reasonPhrase());
              if (errorHandler != null) {
                errorHandler.handle(request,null);
              }
 else {
                response.end(HttpResponseStatus.valueOf(404).reasonPhrase());
              }
            }
          }
 else {
            request.put(""String_Node_Str"",error);
            if (errorHandler != null) {
              errorHandler.handle(request,null);
            }
 else {
              HttpServerResponse response=request.response();
              if (error instanceof Integer) {
                int code=(Integer)error;
                response.setStatusCode(code);
                response.setStatusMessage(HttpResponseStatus.valueOf(code).reasonPhrase());
                response.end(HttpResponseStatus.valueOf(code).reasonPhrase());
              }
 else {
                response.setStatusCode(500);
                response.setStatusMessage(HttpResponseStatus.valueOf(500).reasonPhrase());
                response.end(HttpResponseStatus.valueOf(500).reasonPhrase());
              }
            }
          }
        }
      }
.handle(null);
    }
  }
);
  return this;
}","/** 
 * Starts listening at a already created server.
 * @return Yoke
 */
public Yoke listen(final HttpServer server){
  final boolean secure=server.isSSL();
  server.requestHandler(new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest req){
      final Map<String,Object> context=new HashMap<>(defaultContext);
      final YokeHttpServerRequest request=requestWrapper.wrap(req,secure,context,engineMap);
      new Handler<Object>(){
        int currentMiddleware=-1;
        @Override public void handle(        Object error){
          if (error == null) {
            currentMiddleware++;
            if (currentMiddleware < middlewareList.size()) {
              MountedMiddleware mountedMiddleware=middlewareList.get(currentMiddleware);
              if (request.path().startsWith(mountedMiddleware.mount)) {
                Middleware middlewareItem=mountedMiddleware.middleware;
                middlewareItem.handle(request,this);
              }
 else {
                handle(null);
              }
            }
 else {
              HttpServerResponse response=request.response();
              response.setStatusCode(404);
              response.setStatusMessage(HttpResponseStatus.valueOf(404).reasonPhrase());
              if (errorHandler != null) {
                errorHandler.handle(request,null);
              }
 else {
                response.end(HttpResponseStatus.valueOf(404).reasonPhrase());
              }
            }
          }
 else {
            request.put(""String_Node_Str"",error);
            if (errorHandler != null) {
              errorHandler.handle(request,null);
            }
 else {
              HttpServerResponse response=request.response();
              int errorCode=500;
              if (response.getStatusCode() >= 400) {
                errorCode=response.getStatusCode();
              }
              if (error instanceof Integer) {
                errorCode=(Integer)error;
              }
              response.setStatusCode(errorCode);
              response.setStatusMessage(HttpResponseStatus.valueOf(errorCode).reasonPhrase());
              response.end(HttpResponseStatus.valueOf(errorCode).reasonPhrase());
            }
          }
        }
      }
.handle(null);
    }
  }
);
  return this;
}",0.8391099700470689
56313,"public void close(){
  try {
    getEntityManagerFactory().close();
  }
 catch (  Exception e) {
  }
}","public void close(){
  try {
    if (entityManagerProvider.getEntityManagerFactory().isOpen()) {
      entityManagerProvider.getEntityManagerFactory().close();
    }
 else {
      logger.info(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"",e);
  }
}",0.5051020408163265
56314,"public EntityManager getEntityManager(){
  if (entityManager == null) {
    entityManager=config.getEntityManagerFactory().createEntityManager();
    if (readOnly) {
      entityManager.setProperty(""String_Node_Str"",readOnly);
    }
  }
  return entityManager;
}","public EntityManager getEntityManager(){
  if (entityManager == null) {
    entityManager=config.getEntityManagerProvider().getEntityManager();
    if (readOnly) {
      entityManager.setProperty(""String_Node_Str"",readOnly);
    }
  }
  return entityManager;
}",0.9540229885057472
56315,"@Test public void shouldClose(){
  config.close();
  verify(emf).close();
}","@Test public void shouldClose(){
  when(emf.isOpen()).thenReturn(true);
  config.close();
  verify(emf).close();
}",0.7936507936507936
56316,"@BeforeMethod public void setup(){
  config=mock(JPAConfig.class);
  entityManager=mock(EntityManager.class);
  emf=mock(EntityManagerFactory.class);
  when(config.getEntityManagerFactory()).thenReturn(emf);
  when(emf.createEntityManager()).thenReturn(entityManager);
  context=new JPAContext(config,false);
}","@BeforeMethod public void setup(){
  config=mock(JPAConfig.class);
  entityManager=mock(EntityManager.class);
  emf=mock(EntityManagerFactory.class);
  emp=new EntityManagerProviderImpl(emf);
  when(config.getEntityManagerProvider()).thenReturn(emp);
  when(emf.createEntityManager()).thenReturn(entityManager);
  context=new JPAContext(config,false);
}",0.8295625942684767
56317,"@Test public void shouldClose(){
  jpa.addPersistenceUnit(""String_Node_Str"");
  jpa.addPersistenceUnit(""String_Node_Str"");
  jpa.close();
  assertNull(jpa.getConfig(""String_Node_Str""));
  assertNull(jpa.getConfig(""String_Node_Str""));
  verify(emf,times(2)).close();
}","@Test public void shouldClose(){
  when(emf.isOpen()).thenReturn(true);
  jpa.addPersistenceUnit(""String_Node_Str"");
  jpa.addPersistenceUnit(""String_Node_Str"");
  jpa.close();
  assertNull(jpa.getConfig(""String_Node_Str""));
  assertNull(jpa.getConfig(""String_Node_Str""));
  verify(emf,times(2)).close();
}",0.9319371727748692
56318,"private void assertDefaultConfig(JPAConfig config,boolean isDefault){
  assertNotNull(config);
  if (isDefault) {
    assertEquals(config,jpa.getDefaultConfig());
  }
 else {
    assertNotEquals(config,jpa.getDefaultConfig());
  }
  assertEquals(config.getEntityManagerFactory(),emf);
}","private void assertDefaultConfig(JPAConfig config,boolean isDefault){
  assertNotNull(config);
  if (isDefault) {
    assertEquals(config,jpa.getDefaultConfig());
  }
 else {
    assertNotEquals(config,jpa.getDefaultConfig());
  }
  assertEquals(config.getEntityManagerProvider().getEntityManagerFactory(),emf);
}",0.9549248747913188
56319,"@BeforeMethod public void setup() throws Exception {
  jpa=spy(JPA.instance);
  emf=mock(EntityManagerFactory.class);
  doReturn(emf).when(jpa).createEntityManagerFactory(""String_Node_Str"",Collections.<String,String>emptyMap());
  doReturn(emf).when(jpa).createEntityManagerFactory(""String_Node_Str"",Collections.<String,String>emptyMap());
}","@BeforeMethod public void setup() throws Exception {
  jpa=spy(JPA.instance);
  emf=mock(EntityManagerFactory.class);
  emp=new EntityManagerProviderImpl(emf);
  doReturn(emf).when(jpa).createEntityManagerFactory(""String_Node_Str"",Collections.<String,String>emptyMap());
  doReturn(emf).when(jpa).createEntityManagerFactory(""String_Node_Str"",Collections.<String,String>emptyMap());
}",0.9419889502762432
56320,"public boolean isTxnOpen(){
  return entityManager != null && entityManager.getTransaction() != null && entityManager.getTransaction().isActive();
}","public boolean isTxnOpen(){
  return entityManager != null && entityManager.isOpen() && entityManager.getTransaction() != null && entityManager.getTransaction().isActive();
}",0.9192546583850932
56321,"public void close(){
  try {
    if (entityManager.isOpen()) {
      entityManager.close();
    }
  }
  finally {
    config.clearContext();
  }
}","public void close(){
  try {
    if (entityManager != null && entityManager.isOpen()) {
      entityManager.close();
    }
  }
  finally {
    config.clearContext();
  }
}",0.9211356466876972
56322,"private EntityTransaction mockTransaction(JPAContext context,boolean active){
  EntityManager entityManager=context.getEntityManager();
  EntityTransaction txn=mock(EntityTransaction.class);
  when(entityManager.getTransaction()).thenReturn(txn);
  when(txn.isActive()).thenReturn(active);
  return txn;
}","private EntityTransaction mockTransaction(JPAContext context,boolean active){
  EntityManager entityManager=context.getEntityManager();
  EntityTransaction txn=mock(EntityTransaction.class);
  when(entityManager.isOpen()).thenReturn(true);
  when(entityManager.getTransaction()).thenReturn(txn);
  when(txn.isActive()).thenReturn(active);
  return txn;
}",0.8801213960546282
56323,"public <T extends Model>void constructQuery(CriteriaBuilder builder,CriteriaQuery<?> query,Root<T> root){
  if (conditions != null || !conditions.isEmpty()) {
    List<Predicate> predicates=new ArrayList<Predicate>();
    for (    Condition condition : conditions) {
      predicates.add(condition.constructQuery(builder,root));
    }
    query.where(predicates.toArray(new Predicate[0]));
  }
}","public <T extends Model>void constructQuery(CriteriaBuilder builder,CriteriaQuery<?> query,Root<T> root){
  if (conditions != null || !conditions.isEmpty()) {
    List<Predicate> predicates=new ArrayList<Predicate>();
    for (    Condition condition : conditions) {
      predicates.add(condition.constructQuery(builder,root));
    }
    query.where(predicates.toArray(new Predicate[0]));
  }
  if (sortFields != null && !sortFields.isEmpty()) {
    List<Order> orders=new ArrayList<Order>();
    for (    SortField sortField : sortFields) {
      orders.add(sortField.getOrder(builder,root));
    }
    query.orderBy(orders);
  }
}",0.7684824902723736
56324,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void loadMap(Map map,Map attributes,Class<?> elementType) throws Exception {
  for (  Entry entry : (Set<Entry>)attributes.entrySet()) {
    Object value=map.get(entry.getKey());
    if (value == null) {
      value=elementType.newInstance();
    }
    load(value,(Map)entry.getValue());
    map.put(entry.getKey(),value);
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void loadMap(Map map,Map attributes,Class<?> elementType) throws Exception {
  for (  Entry entry : (Set<Entry>)attributes.entrySet()) {
    if (PropertyUtil.isSimpleValueType(elementType)) {
      map.put(entry.getKey(),ConvertUtil.convert(entry.getValue(),elementType));
    }
 else {
      Object value=map.get(entry.getKey());
      if (value == null) {
        value=elementType.newInstance();
      }
      load(value,(Map)entry.getValue());
      map.put(entry.getKey(),value);
    }
  }
}",0.8264462809917356
56325,"@Test public void shouldSetParametersForInQuery(){
  Object value=Arrays.asList(""String_Node_Str"");
  Condition condition=new Condition(""String_Node_Str"",Operator.in,value);
  condition.setParameters(query,value);
  verify(query).setParameter(""String_Node_Str"",value);
}","@Test public void shouldSetParametersForInQuery(){
  Object value=Arrays.asList(""String_Node_Str"");
  Condition condition=new Condition(""String_Node_Str"",Operator.in,value);
  condition.setPath(path);
  condition.setParameters(query,value);
  verify(query).setParameter(""String_Node_Str"",value);
}",0.9523809523809524
56326,"@Test public void shouldSetParametersForBetweenQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.between,new Object[]{""String_Node_Str"",""String_Node_Str""});
  condition.setParameters(query,new String[]{""String_Node_Str"",""String_Node_Str""});
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldSetParametersForBetweenQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.between,new Object[]{""String_Node_Str"",""String_Node_Str""});
  condition.setPath(path);
  condition.setParameters(query,new String[]{""String_Node_Str"",""String_Node_Str""});
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}",0.9671931956257594
56327,"@Test public void shouldSetParametersForLeQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.le,""String_Node_Str"");
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldSetParametersForLeQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.le,""String_Node_Str"");
  condition.setPath(path);
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}",0.9500924214417744
56328,"@Test public void shouldSetParametersForLtQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.lt,""String_Node_Str"");
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldSetParametersForLtQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.lt,""String_Node_Str"");
  condition.setPath(path);
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}",0.9500924214417744
56329,"@Test public void shouldSetParametersForLikeQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.like,""String_Node_Str"");
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldSetParametersForLikeQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.like,""String_Node_Str"");
  condition.setPath(path);
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}",0.9508196721311476
56330,"@Test public void shouldSetParametersForEqQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.eq,""String_Node_Str"");
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldSetParametersForEqQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.eq,""String_Node_Str"");
  condition.setPath(path);
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}",0.9500924214417744
56331,"@Test public void shouldSetParametersForGeQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.ge,""String_Node_Str"");
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldSetParametersForGeQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.ge,""String_Node_Str"");
  condition.setPath(path);
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}",0.9500924214417744
56332,"@Test public void shouldSetParametersForNeQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.ne,""String_Node_Str"");
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldSetParametersForNeQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.ne,""String_Node_Str"");
  condition.setPath(path);
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}",0.9500924214417744
56333,"@Test public void shouldSetParametersForGtQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.gt,""String_Node_Str"");
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldSetParametersForGtQuery(){
  Condition condition=new Condition(""String_Node_Str"",Operator.gt,""String_Node_Str"");
  condition.setPath(path);
  condition.setParameters(query,""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}",0.9500924214417744
56334,"@Test public void shouldSetParameters(){
  Filter filter=new Filter();
  filter.addCondition(""String_Node_Str"",Operator.eq,""String_Node_Str"");
  filter.addCondition(""String_Node_Str"",Operator.eq,""String_Node_Str"");
  Query query=mock(Query.class);
  Parameter param=mock(Parameter.class);
  when(param.getParameterType()).thenReturn(String.class);
  when(query.getParameter(anyString())).thenReturn(param);
  filter.setParameters(query);
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldSetParameters(){
  Filter filter=new Filter();
  filter.addCondition(""String_Node_Str"",Operator.eq,""String_Node_Str"");
  filter.addCondition(""String_Node_Str"",Operator.eq,""String_Node_Str"");
  Path path=mock(Path.class);
  when(path.getJavaType()).thenReturn(String.class);
  filter.getConditions().get(0).setPath(path);
  filter.getConditions().get(1).setPath(path);
  Query query=mock(Query.class);
  Parameter param=mock(Parameter.class);
  when(param.getParameterType()).thenReturn(String.class);
  when(query.getParameter(anyString())).thenReturn(param);
  filter.setParameters(query);
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
  verify(query).setParameter(""String_Node_Str"",""String_Node_Str"");
}",0.8662131519274376
56335,"@Override public byte[] transform(ClassLoader loader,String className,Class<?> classBeingRedefined,ProtectionDomain protectionDomain,byte[] classfileBuffer) throws IllegalClassFormatException {
  try {
    logger.trace(""String_Node_Str"" + className);
    if (loader == null) {
      loader=Thread.currentThread().getContextClassLoader();
    }
    return enhancer.enhance(loader,className);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + className,e);
    throw new IllegalClassFormatException(e.getMessage());
  }
}","@Override public byte[] transform(ClassLoader loader,String className,Class<?> classBeingRedefined,ProtectionDomain protectionDomain,byte[] classfileBuffer) throws IllegalClassFormatException {
  if (skipClass(className)) {
    return null;
  }
  try {
    logger.trace(""String_Node_Str"" + className);
    if (loader == null) {
      loader=Thread.currentThread().getContextClassLoader();
    }
    return enhancer.enhance(loader,className);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + className,e);
    throw new IllegalClassFormatException(e.getMessage());
  }
}",0.9545049063336308
56336,"@Test public void shouldTransform() throws IllegalClassFormatException {
  ClassLoader loader=mock(ClassLoader.class);
  DomainClassFileTransformer transformer=new DomainClassFileTransformer(enhancer);
  transformer.transform(loader,String.class.getName(),null,null,null);
  verify(enhancer).enhance(loader,String.class.getName());
}","@Test public void shouldTransform() throws IllegalClassFormatException {
  ClassLoader loader=mock(ClassLoader.class);
  DomainClassFileTransformer transformer=new DomainClassFileTransformer(enhancer);
  transformer.transform(loader,DomainClassEnhancer.class.getName(),null,null,null);
  verify(enhancer).enhance(loader,DomainClassEnhancer.class.getName());
}",0.7341040462427746
56337,"public T one(Object... paramValues){
  Filter filter=createFilter(paramValues);
  TypedQuery<T> query=createCollectionQuery(filter);
  filter.setParameters(query);
  return query.getSingleResult();
}","public T one(Object... paramValues){
  Filter filter=createFilter(paramValues);
  return createCollectionQuery(filter).getSingleResult();
}",0.8047337278106509
56338,"private TypedQuery<T> createCollectionQuery(Filter filter){
  filter.addCondition(""String_Node_Str"",parent.getId());
  TypedQuery<T> query=createQuery(parent.getClass(),name,elementType,filter);
  filter.setParameters(query);
  return query;
}","private TypedQuery<T> createCollectionQuery(Filter filter){
  filter.addCondition(""String_Node_Str"",parent.getId());
  TypedQuery<T> query=createQuery(parent.getClass(),name,elementType,filter);
  return query;
}",0.9010989010989012
56339,"protected static <T extends Model>long count(final Class<T> clazz,Filter filter){
  CriteriaBuilder builder=getEntityManager().getCriteriaBuilder();
  CriteriaQuery<Long> cQuery=builder.createQuery(Long.class);
  Root<T> root=cQuery.from(clazz);
  cQuery.select(builder.count(root));
  filter.constructQuery(builder,cQuery,root);
  TypedQuery<Long> query=getEntityManager().createQuery(cQuery);
  filter.setParameters(query);
  return query.getSingleResult();
}","protected static <T extends Model>long count(final Class<T> clazz,Filter filter){
  CriteriaBuilder builder=getEntityManager().getCriteriaBuilder();
  CriteriaQuery<Long> cQuery=builder.createQuery(Long.class);
  Root<T> root=cQuery.from(clazz);
  cQuery.select(builder.count(root));
  filter.constructQuery(builder,cQuery,root);
  TypedQuery<Long> query=createQuery(cQuery,filter);
  return query.getSingleResult();
}",0.8805460750853242
56340,"private JPA(){
}","private JPA(){
  List<PersistenceProvider> providers=PersistenceProviderResolverHolder.getPersistenceProviderResolver().getPersistenceProviders();
  if (providers != null) {
    String providerClass=providers.get(0).getClass().getCanonicalName();
    if (providerClass.equals(HIBERNATE_PERSISTENCE)) {
      cacheableHint=""String_Node_Str"";
    }
 else     if (providerClass.equals(ECLIPSE_PERSISTENCE)) {
      cacheableHint=""String_Node_Str"";
    }
 else     if (providerClass.equals(OPENJPA_PERSISTENCE)) {
      cacheableHint=""String_Node_Str"";
    }
  }
}",0.0555555555555555
56341,"public void close(){
  entityManager.close();
}","public void close(){
  if (entityManager.isOpen()) {
    entityManager.close();
  }
}",0.7121212121212122
56342,"@Test public void shouldClose(){
  EntityManager entityManager=context.getEntityManager();
  context.close();
  verify(entityManager).close();
}","@Test public void shouldClose(){
  EntityManager entityManager=context.getEntityManager();
  when(entityManager.isOpen()).thenReturn(true);
  context.close();
  verify(entityManager).close();
}",0.8545994065281899
56343,"private String getUrl(Repository repository,Settings settings){
  final String jenkinsUrl=settings.getString(JENKINS_BASE).replaceFirst(""String_Node_Str"",""String_Node_Str"");
  final String stashBaseUrl=settings.getString(STASH_BASE);
  String repoUrl=navBuilder.repo(repository).clone(""String_Node_Str"").buildAbsoluteWithoutUsername();
  if (!Strings.isNullOrEmpty(stashBaseUrl)) {
    repoUrl=repoUrl.replace(applicationProperties.getBaseUrl(),stashBaseUrl.replaceFirst(""String_Node_Str"",""String_Node_Str""));
  }
  return String.format(URL,jenkinsUrl,urlEncode(repoUrl));
}","private String getUrl(Repository repository,Settings settings){
  final String jenkinsUrl=settings.getString(JENKINS_BASE).replaceFirst(""String_Node_Str"",""String_Node_Str"");
  final String stashBaseUrl=settings.getString(STASH_BASE);
  String repoUrl=navBuilder.repo(repository).clone(""String_Node_Str"").buildAbsoluteWithoutUsername();
  if (!Strings.isNullOrEmpty(stashBaseUrl)) {
    repoUrl=repoUrl.replace(applicationProperties.getBaseUrl(),stashBaseUrl.replaceFirst(""String_Node_Str"",""String_Node_Str""));
    if (stashBaseUrl.indexOf(""String_Node_Str"") == 0) {
      repoUrl=repoUrl.replace(""String_Node_Str"",""String_Node_Str"");
    }
  }
  return String.format(URL,jenkinsUrl,urlEncode(repoUrl));
}",0.8982785602503912
56344,"@Exported public List<Component> getPipelines(){
  try {
    LOG.fine(""String_Node_Str"");
    List<Component> components=new ArrayList<Component>();
    if (componentSpecs != null) {
      for (      ComponentSpec componentSpec : componentSpecs) {
        AbstractProject firstJob=ProjectUtil.getProject(componentSpec.getFirstJob(),getOwnerItemGroup());
        AbstractProject lastJob=ProjectUtil.getProject(componentSpec.getLastJob(),getOwnerItemGroup());
        if (firstJob != null) {
          components.add(getComponent(componentSpec.getName(),firstJob,lastJob,showAggregatedPipeline));
        }
 else {
          throw new PipelineException(""String_Node_Str"" + componentSpec.getFirstJob());
        }
      }
    }
    if (regexpFirstJobs != null) {
      for (      RegExpSpec regexp : regexpFirstJobs) {
        Map<String,AbstractProject> matches=ProjectUtil.getProjects(regexp.getRegexp());
        for (        Map.Entry<String,AbstractProject> entry : matches.entrySet()) {
          components.add(getComponent(entry.getKey(),entry.getValue(),null,showAggregatedPipeline));
        }
      }
    }
    if (getSorting() != null && !getSorting().equals(NONE_SORTER)) {
      ComponentComparatorDescriptor comparatorDescriptor=ComponentComparator.all().find(sorting);
      if (comparatorDescriptor != null) {
        Collections.sort(components,comparatorDescriptor.createInstance());
      }
    }
    LOG.fine(""String_Node_Str"" + components);
    error=null;
    for (int i=0; i < components.size(); i++) {
      components.get(i).setComponentNumber(i + 1);
    }
    return components;
  }
 catch (  PipelineException e) {
    error=e.getMessage();
    return new ArrayList<Component>();
  }
}","@Exported public List<Component> getPipelines(){
  try {
    LOG.fine(""String_Node_Str"");
    List<Component> components=new ArrayList<Component>();
    if (componentSpecs != null) {
      for (      ComponentSpec componentSpec : componentSpecs) {
        AbstractProject firstJob=ProjectUtil.getProject(componentSpec.getFirstJob(),getOwnerItemGroup());
        AbstractProject lastJob=ProjectUtil.getProject(componentSpec.getLastJob(),getOwnerItemGroup());
        if (firstJob != null) {
          components.add(getComponent(componentSpec.getName(),firstJob,lastJob,showAggregatedPipeline,(componentSpecs.indexOf(componentSpec) + 1)));
        }
 else {
          throw new PipelineException(""String_Node_Str"" + componentSpec.getFirstJob());
        }
      }
    }
    if (regexpFirstJobs != null) {
      for (      RegExpSpec regexp : regexpFirstJobs) {
        Map<String,AbstractProject> matches=ProjectUtil.getProjects(regexp.getRegexp());
        int index=1;
        for (        Map.Entry<String,AbstractProject> entry : matches.entrySet()) {
          components.add(getComponent(entry.getKey(),entry.getValue(),null,showAggregatedPipeline,index));
          index++;
        }
      }
    }
    if (getSorting() != null && !getSorting().equals(NONE_SORTER)) {
      ComponentComparatorDescriptor comparatorDescriptor=ComponentComparator.all().find(sorting);
      if (comparatorDescriptor != null) {
        Collections.sort(components,comparatorDescriptor.createInstance());
      }
    }
    LOG.fine(""String_Node_Str"" + components);
    error=null;
    return components;
  }
 catch (  PipelineException e) {
    error=e.getMessage();
    return new ArrayList<Component>();
  }
}",0.9415908423833284
56345,"private Component getComponent(String name,AbstractProject firstJob,AbstractProject lastJob,boolean showAggregatedPipeline) throws PipelineException {
  Pipeline pipeline=Pipeline.extractPipeline(name,firstJob,lastJob);
  List<Pipeline> pipelines=new ArrayList<Pipeline>();
  if (showAggregatedPipeline) {
    pipelines.add(pipeline.createPipelineAggregated(getOwnerItemGroup(),showAggregatedChanges));
  }
  if (isFullScreenView()) {
    pipelines.addAll(pipeline.createPipelineLatest(noOfPipelines,getOwnerItemGroup(),false));
  }
 else {
    pipelines.addAll(pipeline.createPipelineLatest(noOfPipelines,getOwnerItemGroup(),pagingEnabled));
  }
  return new Component(name,firstJob.getName(),firstJob.getUrl(),firstJob.isParameterized(),pipelines,noOfPipelines,pagingEnabled);
}","private Component getComponent(String name,AbstractProject firstJob,AbstractProject lastJob,boolean showAggregatedPipeline,int componentNumber) throws PipelineException {
  Pipeline pipeline=Pipeline.extractPipeline(name,firstJob,lastJob);
  Component component=new Component(name,firstJob.getName(),firstJob.getUrl(),firstJob.isParameterized(),noOfPipelines,pagingEnabled,componentNumber);
  List<Pipeline> pipelines=new ArrayList<Pipeline>();
  if (showAggregatedPipeline) {
    pipelines.add(pipeline.createPipelineAggregated(getOwnerItemGroup(),showAggregatedChanges));
  }
  if (isFullScreenView()) {
    pipelines.addAll(pipeline.createPipelineLatest(noOfPipelines,getOwnerItemGroup(),false,component));
  }
 else {
    pipelines.addAll(pipeline.createPipelineLatest(noOfPipelines,getOwnerItemGroup(),pagingEnabled,component));
  }
  component.setPipelines(pipelines);
  return component;
}",0.7863961813842482
56346,"private boolean isFullScreenView(){
  StaplerRequest req=Stapler.getCurrentRequest();
  return req != null && req.getParameter(""String_Node_Str"") != null && Boolean.parseBoolean(req.getParameter(""String_Node_Str""));
}","public boolean isFullScreenView(){
  StaplerRequest req=Stapler.getCurrentRequest();
  return req == null ? false : req.getParameter(""String_Node_Str"") == null ? false : Boolean.parseBoolean(req.getParameter(""String_Node_Str""));
}",0.854586129753915
56347,"private int getCurrentPage(){
  StaplerRequest req=Stapler.getCurrentRequest();
  if (req == null) {
    return 1;
  }
  int page=req.getParameter(""String_Node_Str"") == null ? 1 : Integer.parseInt(req.getParameter(""String_Node_Str"").toString());
  page=Math.max(page,1);
  int component=req.getParameter(""String_Node_Str"") == null ? 1 : Integer.parseInt(req.getParameter(""String_Node_Str"").toString());
  if (component != componentNumber) {
    page=1;
  }
  return page;
}","public int getCurrentPage(){
  StaplerRequest req=Stapler.getCurrentRequest();
  int page=req == null ? 1 : req.getParameter(""String_Node_Str"") == null ? 1 : Integer.parseInt(req.getParameter(""String_Node_Str"").toString());
  page=Math.max(page,1);
  int component=req == null ? 1 : req.getParameter(""String_Node_Str"") == null ? 1 : Integer.parseInt(req.getParameter(""String_Node_Str"").toString());
  if (component != componentNumber) {
    page=1;
  }
  return page;
}",0.208067940552017
56348,"private PipelinePagination getPagination(){
  if (pagingEnabled) {
    return new PipelinePagination(this.getCurrentPage(),pipelines.size(),noOfPipelines,""String_Node_Str"" + (this.isFullScreenView() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ componentNumber+ ""String_Node_Str"");
  }
  return null;
}","public PipelinePagination getPagination(){
  if (pagingEnabled) {
    return new PipelinePagination(this.getCurrentPage(),totalNoOfPipelines,noOfPipelines,""String_Node_Str"" + (this.isFullScreenView() == true ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ componentNumber+ ""String_Node_Str"");
  }
  return null;
}",0.9116279069767442
56349,"@Exported public List<Pipeline> getPipelines(){
  if (pagingEnabled && !isFullScreenView()) {
    int startIndex=((this.getCurrentPage() - 1) * noOfPipelines);
    int retrieveSize=Math.min(pipelines.size() - ((this.getCurrentPage() - 1) * noOfPipelines),noOfPipelines);
    return pipelines.subList(startIndex,startIndex + retrieveSize);
  }
  return pipelines;
}","@Exported public List<Pipeline> getPipelines(){
  return pipelines;
}",0.3187066974595843
56350,"public Component(String name,String firstJob,String firstJobUrl,boolean firstJobParameterized,List<Pipeline> pipelines,int noOfPipelines,boolean pagingEnabled){
  super(name);
  this.pipelines=ImmutableList.copyOf(pipelines);
  this.firstJob=firstJob;
  this.firstJobUrl=firstJobUrl;
  this.firstJobParameterized=firstJobParameterized;
  this.noOfPipelines=noOfPipelines;
  this.pagingEnabled=pagingEnabled;
}","public Component(String name,String firstJob,String firstJobUrl,boolean firstJobParameterized,int noOfPipelines,boolean pagingEnabled,int componentNumber){
  super(name);
  this.firstJob=firstJob;
  this.firstJobUrl=firstJobUrl;
  this.firstJobParameterized=firstJobParameterized;
  this.noOfPipelines=noOfPipelines;
  this.pagingEnabled=pagingEnabled;
  this.componentNumber=componentNumber;
}",0.4084682440846824
56351,"/** 
 * Populates and return pipelines for the supplied pipeline prototype with the current status.
 * @param noOfPipelines number of pipeline instances
 */
public List<Pipeline> createPipelineLatest(int noOfPipelines,ItemGroup context,boolean pagingEnabled){
  List<Pipeline> result=new ArrayList<Pipeline>();
  int no=noOfPipelines;
  if (firstProject.isInQueue()) {
    String pipeLineTimestamp=PipelineUtils.formatTimestamp(firstProject.getQueueItem().getInQueueSince());
    List<Stage> pipelineStages=new ArrayList<Stage>();
    for (    Stage stage : getStages()) {
      pipelineStages.add(stage.createLatestStage(context,null));
    }
    Pipeline pipelineLatest=new Pipeline(getName(),firstProject,lastProject,""String_Node_Str"" + firstProject.getNextBuildNumber(),pipeLineTimestamp,TriggerCause.getTriggeredBy(firstProject,null),null,pipelineStages,false);
    result.add(pipelineLatest);
    no--;
  }
  int pipelineCount=noOfPipelines;
  if (pagingEnabled) {
    pipelineCount=firstProject.getBuilds().size();
  }
  Iterator it=firstProject.getBuilds().iterator();
  for (int i=0; i < pipelineCount && it.hasNext(); i++) {
    AbstractBuild firstBuild=(AbstractBuild)it.next();
    List<Change> pipelineChanges=Change.getChanges(firstBuild);
    String pipeLineTimestamp=PipelineUtils.formatTimestamp(firstBuild.getTimeInMillis());
    List<Stage> pipelineStages=new ArrayList<Stage>();
    for (    Stage stage : getStages()) {
      pipelineStages.add(stage.createLatestStage(context,firstBuild));
    }
    Pipeline pipelineLatest=new Pipeline(getName(),firstProject,lastProject,firstBuild.getDisplayName(),pipeLineTimestamp,TriggerCause.getTriggeredBy(firstProject,firstBuild),UserInfo.getContributors(firstBuild),pipelineStages,false);
    pipelineLatest.setChanges(pipelineChanges);
    pipelineLatest.calculateTotalBuildTime();
    result.add(pipelineLatest);
  }
  return result;
}","/** 
 * Populates and return pipelines for the supplied pipeline prototype with the current status.
 * @param noOfPipelines number of pipeline instances
 */
public List<Pipeline> createPipelineLatest(int noOfPipelines,ItemGroup context,boolean pagingEnabled,Component component){
  List<Pipeline> result=new ArrayList<Pipeline>();
  int no=noOfPipelines;
  if (firstProject.isInQueue()) {
    String pipeLineTimestamp=PipelineUtils.formatTimestamp(firstProject.getQueueItem().getInQueueSince());
    List<Stage> pipelineStages=new ArrayList<Stage>();
    for (    Stage stage : getStages()) {
      pipelineStages.add(stage.createLatestStage(context,null));
    }
    Pipeline pipelineLatest=new Pipeline(getName(),firstProject,lastProject,""String_Node_Str"" + firstProject.getNextBuildNumber(),pipeLineTimestamp,TriggerCause.getTriggeredBy(firstProject,null),null,pipelineStages,false);
    result.add(pipelineLatest);
    no--;
  }
  int totalNoOfPipelines=firstProject.getBuilds().size();
  component.setTotalNoOfPipelines(totalNoOfPipelines);
  int startIndex=0;
  int retrieveSize=noOfPipelines;
  if (pagingEnabled && !component.isFullScreenView()) {
    startIndex=(component.getCurrentPage() - 1) * noOfPipelines;
    retrieveSize=Math.min(totalNoOfPipelines - ((component.getCurrentPage() - 1) * noOfPipelines),noOfPipelines);
  }
  Iterator it=firstProject.getBuilds().listIterator(startIndex);
  for (int i=startIndex; i < (startIndex + retrieveSize) && it.hasNext(); i++) {
    AbstractBuild firstBuild=(AbstractBuild)it.next();
    List<Change> pipelineChanges=Change.getChanges(firstBuild);
    String pipeLineTimestamp=PipelineUtils.formatTimestamp(firstBuild.getTimeInMillis());
    List<Stage> pipelineStages=new ArrayList<Stage>();
    for (    Stage stage : getStages()) {
      pipelineStages.add(stage.createLatestStage(context,firstBuild));
    }
    Pipeline pipelineLatest=new Pipeline(getName(),firstProject,lastProject,firstBuild.getDisplayName(),pipeLineTimestamp,TriggerCause.getTriggeredBy(firstProject,firstBuild),UserInfo.getContributors(firstBuild),pipelineStages,false);
    pipelineLatest.setChanges(pipelineChanges);
    pipelineLatest.calculateTotalBuildTime();
    result.add(pipelineLatest);
  }
  return result;
}",0.8342967244701349
56352,"@Test public void testComponent(){
  Component componentA=new Component(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,new ArrayList<Pipeline>(),3,pagingEnabledTrue);
  componentA.setComponentNumber(1);
  assertNotNull(componentA.getPagingData());
  assertNotNull(componentA.getPipelines());
}","@Test public void testComponent(){
  Component componentA=new Component(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,3,pagingEnabledTrue,1);
  componentA.setPipelines(new ArrayList<Pipeline>());
  assertNotNull(componentA.getPagingData());
  assertNotNull(componentA.getPipelines());
}",0.5874587458745875
56353,"@Test public void testComponentNumber(){
  Component componentB=new Component(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,new ArrayList<Pipeline>(),3,pagingEnabledTrue);
  componentB.setComponentNumber(2);
  Component componentA=new Component(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,new ArrayList<Pipeline>(),3,pagingEnabledTrue);
  componentA.setComponentNumber(1);
  List<Component> list=new ArrayList<Component>();
  list.add(componentA);
  list.add(componentB);
  assertEquals(1,list.get(0).getComponentNumber());
  assertEquals(2,list.get(1).getComponentNumber());
}","@Test public void testComponentNumber(){
  Component componentB=new Component(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,3,pagingEnabledTrue,2);
  Component componentA=new Component(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,3,pagingEnabledTrue,1);
  List<Component> list=new ArrayList<Component>();
  list.add(componentA);
  list.add(componentB);
  assertEquals(1,list.get(0).getComponentNumber());
  assertEquals(2,list.get(1).getComponentNumber());
}",0.583180987202925
56354,"static void setVersion(AbstractBuild build,String version){
  PipelineVersionAction action=build.getAction(PipelineVersionAction.class);
  if (action == null) {
    build.addAction(new PipelineVersionAction(version));
  }
 else {
    build.replaceAction(action);
  }
  build.replaceAction(getVersionParameterAction(version));
}","static void setVersion(AbstractBuild build,String version){
  PipelineVersionAction action=build.getAction(PipelineVersionAction.class);
  if (action == null) {
    build.addAction(new PipelineVersionAction(version));
  }
 else {
    build.replaceAction(action);
  }
  build.replaceAction(getVersionParameterAction(build,version));
}",0.990909090909091
56355,"private static ParametersAction getVersionParameterAction(String version){
  ParameterValue value=new StringParameterValue(PipelineVersionContributor.VERSION_PARAMETER,version);
  return new ParametersAction(value);
}","private static ParametersAction getVersionParameterAction(AbstractBuild build,String version){
  ParameterValue value=new StringParameterValue(PipelineVersionContributor.VERSION_PARAMETER,version);
  ParametersAction action=build.getAction(ParametersAction.class);
  if (action != null) {
    List<ParameterValue> parameters=new ArrayList<ParameterValue>(action.getParameters());
    parameters.add(value);
    return new ParametersAction(parameters);
  }
  return new ParametersAction(value);
}",0.5196629213483146
56356,"public static void setVersion(AbstractBuild build,String version){
  ParametersAction action=new ParametersAction(new StringParameterValue(PipelineVersionContributor.VERSION_PARAMETER,version));
  build.addAction(action);
}","public static void setVersion(AbstractBuild build,String version){
  ParameterValue value=new StringParameterValue(PipelineVersionContributor.VERSION_PARAMETER,version);
  ParametersAction action=build.getAction(ParametersAction.class);
  if (action == null) {
    action=new ParametersAction(value);
    build.addAction(action);
  }
 else {
    List<ParameterValue> parameters=new ArrayList<ParameterValue>(action.getParameters());
    parameters.add(value);
    action=new ParametersAction(parameters);
    build.replaceAction(action);
  }
}",0.4099216710182767
56357,"@Test public void testTriggerNewParameterizedPipeline() throws Exception {
  FreeStyleProject start=jenkins.createFreeStyleProject(""String_Node_Str"");
  start.addProperty(new ParametersDefinitionProperty(new StringParameterDefinition(""String_Node_Str"",""String_Node_Str"")));
  jenkins.createFreeStyleProject(""String_Node_Str"");
  start.getPublishersList().add(new BuildTrigger(""String_Node_Str"",true));
  jenkins.getInstance().rebuildDependencyGraph();
  DeliveryPipelineView view=new DeliveryPipelineView(""String_Node_Str"");
  List<DeliveryPipelineView.ComponentSpec> specs=new ArrayList<DeliveryPipelineView.ComponentSpec>();
  specs.add(new DeliveryPipelineView.ComponentSpec(""String_Node_Str"",""String_Node_Str""));
  view.setComponentSpecs(specs);
  view.setAllowPipelineStart(true);
  jenkins.getInstance().addView(view);
  DeliveryPipelinePage page=new DeliveryPipelinePage(webDriver,jenkins.getURL().toExternalForm(),""String_Node_Str"");
  page.open();
  page.triggerNewParameterizedPipelineBuild(""String_Node_Str"");
  jenkins.waitUntilNoActivity();
  assertNotNull(start.getLastBuild());
}","@Test public void testTriggerNewParameterizedPipeline() throws Exception {
  FreeStyleProject start=jenkins.createFreeStyleProject(""String_Node_Str"");
  start.addProperty(new ParametersDefinitionProperty(new StringParameterDefinition(""String_Node_Str"",""String_Node_Str"")));
  jenkins.createFreeStyleProject(""String_Node_Str"");
  start.getPublishersList().add(new BuildTrigger(""String_Node_Str"",true));
  jenkins.getInstance().rebuildDependencyGraph();
  DeliveryPipelineView view=new DeliveryPipelineView(""String_Node_Str"");
  List<DeliveryPipelineView.ComponentSpec> specs=new ArrayList<DeliveryPipelineView.ComponentSpec>();
  specs.add(new DeliveryPipelineView.ComponentSpec(""String_Node_Str"",""String_Node_Str"",null));
  view.setComponentSpecs(specs);
  view.setAllowPipelineStart(true);
  jenkins.getInstance().addView(view);
  DeliveryPipelinePage page=new DeliveryPipelinePage(webDriver,jenkins.getURL().toExternalForm(),""String_Node_Str"");
  page.open();
  page.triggerNewParameterizedPipelineBuild(""String_Node_Str"");
  jenkins.waitUntilNoActivity();
  assertNotNull(start.getLastBuild());
}",0.997720018239854
56358,"public static void setVersion(AbstractBuild build,String version){
  ParametersAction action=new ParametersAction(new StringParameterValue(PipelineVersionContributor.VERSION_PARAMETER,version));
  build.addAction(action);
}","public static void setVersion(AbstractBuild build,String version){
  ParameterValue value=new StringParameterValue(PipelineVersionContributor.VERSION_PARAMETER,version);
  ParametersAction action=build.getAction(ParametersAction.class);
  if (action == null) {
    action=new ParametersAction(value);
    build.addAction(action);
  }
 else {
    List<ParameterValue> parameters=new ArrayList<ParameterValue>(action.getParameters());
    parameters.add(value);
    action=new ParametersAction(parameters);
    build.replaceAction(action);
  }
}",0.4099216710182767
56359,"public static void setVersion(AbstractBuild build,String version){
  ParametersAction action=new ParametersAction(new StringParameterValue(PipelineVersionContributor.VERSION_PARAMETER,version));
  build.addAction(action);
}","public static void setVersion(AbstractBuild build,String version){
  ParameterValue value=new StringParameterValue(PipelineVersionContributor.VERSION_PARAMETER,version);
  ParametersAction action=build.getAction(ParametersAction.class);
  if (action == null) {
    action=new ParametersAction(value);
    build.addAction(action);
  }
 else {
    List<ParameterValue> parameters=new ArrayList<ParameterValue>(action.getParameters());
    parameters.add(value);
    action=new ParametersAction(parameters);
    build.replaceAction(action);
  }
}",0.4099216710182767
56360,"/** 
 * Get all downstream projects for a given project. This will recursively call all downstream projects for a given first project. A project that has a downstream project and will eventually loop back to itself will log a warning, and will NOT add. Adding a project that already exists will produce a stack overflow.
 * @param first The first project
 * @param projects Current map of all sub projects.
 * @return A map of all downstream projects.
 */
public static Map<String,AbstractProject<?,?>> getAllDownstreamProjects(AbstractProject first,Map<String,AbstractProject<?,?>> projects){
  if (first == null) {
    return projects;
  }
  if (projects.containsValue(first)) {
    LOG.warning(""String_Node_Str"" + first.getFullDisplayName() + ""String_Node_Str"");
    return projects;
  }
  projects.put(first.getName(),first);
  for (  AbstractProject p : getDownstreamProjects(first)) {
    projects.putAll(getAllDownstreamProjects(p,projects));
  }
  return projects;
}","/** 
 * Get all downstream projects for a given project. This will recursively call all downstream projects for a given first project. A project that has a downstream project and will eventually loop back to itself will log a warning, and will NOT add. Adding a project that already exists will produce a stack overflow.
 * @param first The first project
 * @param projects Current map of all sub projects.
 * @return A map of all downstream projects.
 */
public static Map<String,AbstractProject<?,?>> getAllDownstreamProjects(AbstractProject first,Map<String,AbstractProject<?,?>> projects){
  if (first == null) {
    return projects;
  }
  if (projects.containsValue(first)) {
    LOG.warning(""String_Node_Str"" + first.getFullDisplayName() + ""String_Node_Str"");
    return projects;
  }
  projects.put(first.getFullName(),first);
  for (  AbstractProject p : getDownstreamProjects(first)) {
    projects.putAll(getAllDownstreamProjects(p,projects));
  }
  return projects;
}",0.9979508196721312
56361,"public static Map<String,AbstractProject> getProjects(String regExp){
  try {
    Pattern pattern=Pattern.compile(regExp);
    Map<String,AbstractProject> result=new HashMap<String,AbstractProject>();
    for (    AbstractProject<?,?> project : Jenkins.getInstance().getAllItems(AbstractProject.class)) {
      Matcher matcher=pattern.matcher(project.getName());
      if (matcher.find()) {
        if (matcher.groupCount() >= 1) {
          String name=matcher.group(1);
          result.put(name,project);
        }
 else {
          LOG.log(Level.WARNING,""String_Node_Str"");
        }
      }
    }
    return result;
  }
 catch (  PatternSyntaxException e) {
    LOG.log(Level.WARNING,""String_Node_Str"",e);
    return Collections.emptyMap();
  }
}","public static Map<String,AbstractProject> getProjects(String regExp){
  try {
    Pattern pattern=Pattern.compile(regExp);
    Map<String,AbstractProject> result=new HashMap<String,AbstractProject>();
    for (    AbstractProject<?,?> project : Jenkins.getInstance().getAllItems(AbstractProject.class)) {
      Matcher matcher=pattern.matcher(project.getFullName());
      if (matcher.find()) {
        if (matcher.groupCount() >= 1) {
          String name=matcher.group(1);
          result.put(name,project);
        }
 else {
          LOG.log(Level.WARNING,""String_Node_Str"");
        }
      }
    }
    return result;
  }
 catch (  PatternSyntaxException e) {
    LOG.log(Level.WARNING,""String_Node_Str"",e);
    return Collections.emptyMap();
  }
}",0.99734395750332
56362,"@Override public void triggerManual(AbstractProject<?,?> project,AbstractProject<?,?> upstream,String buildId,ItemGroup<? extends TopLevelItem> itemGroup) throws TriggerException {
  MyView view=new MyView(itemGroup);
  if (upstream != null && upstream.getBuild(buildId) != null) {
    try {
      view.triggerManualBuild(Integer.parseInt(buildId),project.getName(),upstream.getName());
    }
 catch (    Exception e) {
      throw new TriggerException(""String_Node_Str"",e);
    }
  }
 else {
    throw new TriggerException(""String_Node_Str"" + buildId + ""String_Node_Str""+ upstream);
  }
}","@Override public void triggerManual(AbstractProject<?,?> project,AbstractProject<?,?> upstream,String buildId,ItemGroup<? extends TopLevelItem> itemGroup) throws TriggerException {
  MyView view=new MyView(itemGroup);
  if (upstream != null && upstream.getBuild(buildId) != null) {
    try {
      view.triggerManualBuild(Integer.parseInt(buildId),project.getRelativeNameFrom(itemGroup),upstream.getRelativeNameFrom(itemGroup));
    }
 catch (    Exception e) {
      throw new TriggerException(""String_Node_Str"",e);
    }
  }
 else {
    throw new TriggerException(""String_Node_Str"" + buildId + ""String_Node_Str""+ upstream);
  }
}",0.9622950819672133
56363,"public static AbstractBuild getUpstreamBuild(AbstractBuild build){
  List<CauseAction> actions=build.getActions(CauseAction.class);
  for (  CauseAction action : actions) {
    List<Cause> causes=action.getCauses();
    for (    Cause cause : causes) {
      if (cause instanceof Cause.UpstreamCause) {
        Cause.UpstreamCause upstreamCause=(Cause.UpstreamCause)cause;
        AbstractProject upstreamProject=(AbstractProject)Jenkins.getInstance().getItemMap().get(upstreamCause.getUpstreamProject());
        if (upstreamProject == null) {
          return null;
        }
        return upstreamProject.getBuildByNumber(upstreamCause.getUpstreamBuild());
      }
    }
  }
  return null;
}","public static AbstractBuild getUpstreamBuild(AbstractBuild build){
  List<CauseAction> actions=build.getActions(CauseAction.class);
  for (  CauseAction action : actions) {
    List<Cause> causes=action.getCauses();
    for (    Cause cause : causes) {
      if (cause instanceof Cause.UpstreamCause) {
        Cause.UpstreamCause upstreamCause=(Cause.UpstreamCause)cause;
        AbstractProject upstreamProject=ProjectUtil.getProject(upstreamCause.getUpstreamProject());
        if (upstreamProject == null) {
          return null;
        }
        return upstreamProject.getBuildByNumber(upstreamCause.getUpstreamBuild());
      }
    }
  }
  return null;
}",0.9609432571849668
56364,"public static AbstractProject<?,?> getProject(String name,ItemGroup context){
  return Jenkins.getInstance().getItem(name,context,AbstractProject.class);
}","public static AbstractProject getProject(String name){
  Map<String,TopLevelItem> items=Jenkins.getInstance().getItemMap();
  if (items.containsKey(name)) {
    return (AbstractProject)items.get(name);
  }
 else {
    List<ItemGroup> groups=Util.createSubList(items.values(),ItemGroup.class);
    for (int i=0; i < groups.size(); i++) {
      ItemGroup group=groups.get(i);
      AbstractProject project=find(group,name);
      if (project != null) {
        return project;
      }
    }
  }
  return null;
}",0.2198795180722891
56365,"@Override protected void submit(StaplerRequest req) throws IOException, ServletException, Descriptor.FormException {
  req.bindJSON(this,req.getSubmittedForm());
}","@Override protected void submit(StaplerRequest req) throws IOException, ServletException, Descriptor.FormException {
  req.bindJSON(this,req.getSubmittedForm());
  componentSpecs=req.bindJSONToList(ComponentSpec.class,req.getSubmittedForm().get(""String_Node_Str""));
  regexpFirstJobs=req.bindJSONToList(RegExpSpec.class,req.getSubmittedForm().get(""String_Node_Str""));
}",0.6127819548872181
56366,"@Override public int compare(Component o1,Component o2){
  return Long.valueOf(getLastActivity(o1)).compareTo(Long.valueOf(getLastActivity(o2)));
}","@Override public int compare(Component o1,Component o2){
  return Long.valueOf(getLastActivity(o2)).compareTo(getLastActivity(o1));
}",0.9357142857142856
56367,"/** 
 * Returns the build for a projects that has been triggered by the supplied upstream project.
 */
private static AbstractBuild match(RunList runList,AbstractBuild firstBuild){
  if (firstBuild != null) {
    for (    Object aRunList : runList) {
      AbstractBuild currentBuild=(AbstractBuild)aRunList;
      if (firstBuild.equals(getFirstUpstreamBuild(currentBuild))) {
        return currentBuild;
      }
    }
  }
  return null;
}","/** 
 * Returns the build for a projects that has been triggered by the supplied upstream project.
 */
private static AbstractBuild match(RunList<? extends AbstractBuild> runList,AbstractBuild firstBuild){
  if (firstBuild != null) {
    for (    AbstractBuild currentBuild : runList) {
      if (firstBuild.equals(getFirstUpstreamBuild(currentBuild,firstBuild.getProject()))) {
        return currentBuild;
      }
    }
  }
  return null;
}",0.5600907029478458
56368,"private static AbstractBuild getFirstUpstreamBuild(AbstractProject<?,?> project,AbstractProject<?,?> first){
  RunList<? extends AbstractBuild> builds=project.getBuilds();
  for (  AbstractBuild build : builds) {
    AbstractBuild upstream=getFirstUpstreamBuild(build);
    if (upstream != null && upstream.getProject().equals(first)) {
      return upstream;
    }
  }
  return null;
}","private static AbstractBuild getFirstUpstreamBuild(AbstractProject<?,?> project,AbstractProject<?,?> first){
  RunList<? extends AbstractBuild> builds=project.getBuilds();
  for (  AbstractBuild build : builds) {
    AbstractBuild upstream=getFirstUpstreamBuild(build,first);
    if (upstream != null && upstream.getProject().equals(first)) {
      return upstream;
    }
  }
  return null;
}",0.9922879177377892
56369,"/** 
 * Populates and return pipelines for the supplied pipeline prototype with the current status.
 * @param pipeline      the pipeline prototype
 * @param noOfPipelines number of pipeline instances
 */
public static List<Pipeline> createPipelineLatest(Pipeline pipeline,int noOfPipelines){
  Task firstTask=pipeline.getStages().get(0).getTasks().get(0);
  AbstractProject firstProject=getProject(firstTask);
  List<Pipeline> result=new ArrayList<Pipeline>();
  Iterator it=firstProject.getBuilds().iterator();
  for (int i=0; i < noOfPipelines && it.hasNext(); i++) {
    AbstractBuild firstBuild=(AbstractBuild)it.next();
    List<Change> changes=getChanges(firstBuild);
    String timestamp=PipelineUtils.formatTimestamp(firstBuild.getTimeInMillis());
    List<Stage> stages=new ArrayList<Stage>();
    for (    Stage stage : pipeline.getStages()) {
      List<Task> tasks=new ArrayList<Task>();
      for (      Task task : stage.getTasks()) {
        AbstractProject taskProject=getProject(task);
        AbstractBuild currentBuild=match(taskProject.getBuilds(),firstBuild);
        tasks.add(getTask(task,currentBuild));
      }
      stages.add(new Stage(stage.getName(),tasks));
    }
    result.add(new Pipeline(pipeline.getName(),firstBuild.getDisplayName(),changes,timestamp,getTriggeredBy(firstBuild),stages,false));
  }
  return result;
}","/** 
 * Populates and return pipelines for the supplied pipeline prototype with the current status.
 * @param pipeline      the pipeline prototype
 * @param noOfPipelines number of pipeline instances
 */
public static List<Pipeline> createPipelineLatest(Pipeline pipeline,int noOfPipelines){
  Task firstTask=pipeline.getStages().get(0).getTasks().get(0);
  AbstractProject firstProject=getProject(firstTask);
  List<Pipeline> result=new ArrayList<Pipeline>();
  Iterator it=firstProject.getBuilds().iterator();
  for (int i=0; i < noOfPipelines && it.hasNext(); i++) {
    AbstractBuild firstBuild=(AbstractBuild)it.next();
    List<Change> changes=getChanges(firstBuild);
    String timestamp=PipelineUtils.formatTimestamp(firstBuild.getTimeInMillis());
    List<Stage> stages=new ArrayList<Stage>();
    for (    Stage stage : pipeline.getStages()) {
      List<Task> tasks=new ArrayList<Task>();
      for (      Task task : stage.getTasks()) {
        AbstractProject<?,?> taskProject=getProject(task);
        AbstractBuild currentBuild=match(taskProject.getBuilds(),firstBuild);
        tasks.add(getTask(task,currentBuild));
      }
      stages.add(new Stage(stage.getName(),tasks));
    }
    result.add(new Pipeline(pipeline.getName(),firstBuild.getDisplayName(),changes,timestamp,getTriggeredBy(firstBuild),stages,false));
  }
  return result;
}",0.998154300479882
56370,"private static List<Change> getChanges(AbstractBuild<?,?> build){
  RepositoryBrowser repositoryBrowser=build.getProject().getScm().getBrowser();
  List<Change> result=new ArrayList<Change>();
  for (  ChangeLogSet.Entry entry : build.getChangeSet()) {
    UserInfo user=getUser(entry.getAuthor());
    String changeLink=null;
    if (repositoryBrowser != null) {
      try {
        URL link=repositoryBrowser.getChangeSetLink(entry);
        if (link != null) {
          changeLink=link.toExternalForm();
        }
      }
 catch (      IOException e) {
      }
    }
    result.add(new Change(user,entry.getMsg(),entry.getCommitId(),changeLink));
  }
  return result;
}","protected static List<Change> getChanges(AbstractBuild<?,?> build){
  RepositoryBrowser repositoryBrowser=build.getProject().getScm().getBrowser();
  List<Change> result=new ArrayList<Change>();
  for (  ChangeLogSet.Entry entry : build.getChangeSet()) {
    UserInfo user=getUser(entry.getAuthor());
    String changeLink=null;
    if (repositoryBrowser != null) {
      try {
        URL link=repositoryBrowser.getChangeSetLink(entry);
        if (link != null) {
          changeLink=link.toExternalForm();
        }
      }
 catch (      IOException e) {
      }
    }
    result.add(new Change(user,entry.getMsg(),entry.getCommitId(),changeLink));
  }
  return result;
}",0.9910979228486648
56371,"public static Pipeline createPipelineAggregated(Pipeline pipeline){
  AbstractProject firstProject=getProject(pipeline.getStages().get(0).getTasks().get(0));
  List<Stage> stages=new ArrayList<Stage>();
  for (  Stage stage : pipeline.getStages()) {
    List<Task> tasks=new ArrayList<Task>();
    AbstractBuild versionBuild=getHighestBuild(stage.getTasks(),firstProject);
    String version=null;
    if (versionBuild != null) {
      version=versionBuild.getDisplayName();
    }
    for (    Task task : stage.getTasks()) {
      AbstractProject taskProject=getProject(task);
      AbstractBuild currentBuild=match(taskProject.getBuilds(),versionBuild);
      if (currentBuild != null) {
        Status status=resolveStatus(taskProject,currentBuild);
        String link=status.isIdle() ? task.getLink() : currentBuild.getUrl();
        tasks.add(new Task(task.getId(),task.getName(),String.valueOf(currentBuild.getNumber()),status,link,task.isManual(),getTestResult(currentBuild)));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),null,StatusFactory.idle(),task.getLink(),task.isManual(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,null,null,stages,true);
}","public static Pipeline createPipelineAggregated(Pipeline pipeline){
  AbstractProject firstProject=getProject(pipeline.getStages().get(0).getTasks().get(0));
  List<Stage> stages=new ArrayList<Stage>();
  for (  Stage stage : pipeline.getStages()) {
    List<Task> tasks=new ArrayList<Task>();
    AbstractBuild versionBuild=getHighestBuild(stage.getTasks(),firstProject);
    String version=null;
    if (versionBuild != null) {
      version=versionBuild.getDisplayName();
    }
    for (    Task task : stage.getTasks()) {
      AbstractProject<?,?> taskProject=getProject(task);
      AbstractBuild currentBuild=match(taskProject.getBuilds(),versionBuild);
      if (currentBuild != null) {
        Status status=resolveStatus(taskProject,currentBuild);
        String link=status.isIdle() ? task.getLink() : currentBuild.getUrl();
        tasks.add(new Task(task.getId(),task.getName(),String.valueOf(currentBuild.getNumber()),status,link,task.isManual(),getTestResult(currentBuild)));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),null,StatusFactory.idle(),task.getLink(),task.isManual(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,null,null,stages,true);
}",0.9980415197806504
56372,"@DataBoundConstructor public DeliveryPipelineView(String name,int noOfColumns,List<ComponentSpec> componentSpecs,int noOfPipelines,boolean showAggregatedPipeline){
  super(name);
  this.componentSpecs=componentSpecs;
  this.noOfColumns=noOfColumns;
  this.noOfPipelines=noOfPipelines;
  this.showAggregatedPipeline=showAggregatedPipeline;
}","@DataBoundConstructor public DeliveryPipelineView(String name,List<ComponentSpec> componentSpecs){
  super(name);
  this.componentSpecs=componentSpecs;
}",0.6206896551724138
56373,"@Override public int hashCode(){
  return Objects.hash(super.hashCode(),stages);
}","@Override public int hashCode(){
  return Objects.hash(super.hashCode(),version,stages);
}",0.9534883720930232
56374,"public static Pipeline createPipelineAggregated(Pipeline pipeline){
  AbstractProject firstProject=getProject(pipeline.getStages().get(0).getTasks().get(0));
  List<Stage> stages=new ArrayList<>();
  for (  Stage stage : pipeline.getStages()) {
    AbstractProject project=getProject(stage.getTasks().get(0));
    List<Task> tasks=new ArrayList<>();
    AbstractBuild versionBuild=getFirstUpstreamBuild(project,firstProject);
    String version=null;
    if (versionBuild != null) {
      version=versionBuild.getDisplayName();
    }
    for (    Task task : stage.getTasks()) {
      AbstractProject taskProject=getProject(task);
      AbstractBuild currentBuild=match(taskProject.getBuilds(),versionBuild);
      if (currentBuild != null) {
        Status status=resolveStatus(taskProject,currentBuild);
        String link=status.isIdle() ? task.getLink() : currentBuild.getUrl();
        tasks.add(new Task(task.getId(),task.getName(),String.valueOf(currentBuild.getNumber()),status,link,task.isManual(),getTestResult(currentBuild)));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),null,StatusFactory.idle(),task.getLink(),task.isManual(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,null,stages,true);
}","public static Pipeline createPipelineAggregated(Pipeline pipeline){
  AbstractProject firstProject=getProject(pipeline.getStages().get(0).getTasks().get(0));
  List<Stage> stages=new ArrayList<>();
  for (  Stage stage : pipeline.getStages()) {
    AbstractProject project=getProject(stage.getTasks().get(0));
    List<Task> tasks=new ArrayList<>();
    AbstractBuild versionBuild=getHighestBuild(stage.getTasks(),firstProject);
    String version=null;
    if (versionBuild != null) {
      version=versionBuild.getDisplayName();
    }
    for (    Task task : stage.getTasks()) {
      AbstractProject taskProject=getProject(task);
      AbstractBuild currentBuild=match(taskProject.getBuilds(),versionBuild);
      if (currentBuild != null) {
        Status status=resolveStatus(taskProject,currentBuild);
        String link=status.isIdle() ? task.getLink() : currentBuild.getUrl();
        tasks.add(new Task(task.getId(),task.getName(),String.valueOf(currentBuild.getNumber()),status,link,task.isManual(),getTestResult(currentBuild)));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),null,StatusFactory.idle(),task.getLink(),task.isManual(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,null,stages,true);
}",0.9837551945598793
56375,"@Override public Collection<TopLevelItem> getItems(){
  List<TopLevelItem> result=new ArrayList<>();
  for (  ComponentSpec componentSpec : componentSpecs) {
    AbstractProject project=ProjectUtil.getProject(componentSpec.getFirstJob());
    List<AbstractProject<?,?>> projects=ProjectUtil.getAllDownstreamProjects(project);
    for (    AbstractProject<?,?> abstractProject : projects) {
      result.add(getItem(abstractProject.getName()));
    }
  }
  return result;
}","@Override public Collection<TopLevelItem> getItems(){
  List<TopLevelItem> result=new ArrayList<>();
  for (  ComponentSpec componentSpec : componentSpecs) {
    AbstractProject project=ProjectUtil.getProject(componentSpec.getFirstJob());
    Collection<AbstractProject<?,?>> projects=ProjectUtil.getAllDownstreamProjects(project).values();
    for (    AbstractProject<?,?> abstractProject : projects) {
      result.add(getItem(abstractProject.getName()));
    }
  }
  return result;
}",0.9760166840458812
56376,"/** 
 * Populates and return pipelines for the supplied pipeline prototype with the current status.
 * @param pipeline      the pipeline prototype
 * @param noOfPipelines number of pipeline instances
 */
public static List<Pipeline> createPipelineLatest(Pipeline pipeline,int noOfPipelines){
  Task firstTask=pipeline.getStages().get(0).getTasks().get(0);
  AbstractProject firstProject=getProject(firstTask);
  List<Pipeline> result=new ArrayList<>();
  Iterator it=firstProject.getBuilds().iterator();
  for (int i=0; i < noOfPipelines && it.hasNext(); i++) {
    AbstractBuild firstBuild=(AbstractBuild)it.next();
    String timestamp=PipelineUtils.formatTimestamp(firstBuild.getTimeInMillis());
    List<Stage> stages=new ArrayList<>();
    for (    Stage stage : pipeline.getStages()) {
      List<Task> tasks=new ArrayList<>();
      for (      Task task : stage.getTasks()) {
        AbstractProject taskProject=getProject(task);
        AbstractBuild currentBuild=match(taskProject.getBuilds(),firstBuild);
        Status status=resolveStatus(taskProject,currentBuild);
        String link=currentBuild == null || status.isIdle() || status.isQueued() ? task.getLink() : currentBuild.getUrl();
        String buildId=currentBuild == null || status.isIdle() || status.isQueued() ? null : String.valueOf(currentBuild.getNumber());
        tasks.add(new Task(task.getId(),task.getName(),buildId,status,link,task.isManual(),getTestResult(currentBuild)));
      }
      stages.add(new Stage(stage.getName(),tasks));
    }
    result.add(new Pipeline(pipeline.getName(),firstBuild.getDisplayName(),timestamp,getTriggeredBy(firstBuild),stages,false));
  }
  return result;
}","/** 
 * Populates and return pipelines for the supplied pipeline prototype with the current status.
 * @param pipeline      the pipeline prototype
 * @param noOfPipelines number of pipeline instances
 */
public static List<Pipeline> createPipelineLatest(Pipeline pipeline,int noOfPipelines){
  Task firstTask=pipeline.getStages().get(0).getTasks().get(0);
  AbstractProject firstProject=getProject(firstTask);
  List<Pipeline> result=new ArrayList<>();
  Iterator it=firstProject.getBuilds().iterator();
  for (int i=0; i < noOfPipelines && it.hasNext(); i++) {
    AbstractBuild firstBuild=(AbstractBuild)it.next();
    String timestamp=PipelineUtils.formatTimestamp(firstBuild.getTimeInMillis());
    List<Stage> stages=new ArrayList<>();
    for (    Stage stage : pipeline.getStages()) {
      List<Task> tasks=new ArrayList<>();
      for (      Task task : stage.getTasks()) {
        AbstractProject taskProject=getProject(task);
        AbstractBuild currentBuild=match(taskProject.getBuilds(),firstBuild);
        tasks.add(getTask(task,currentBuild));
      }
      stages.add(new Stage(stage.getName(),tasks));
    }
    result.add(new Pipeline(pipeline.getName(),firstBuild.getDisplayName(),timestamp,getTriggeredBy(firstBuild),stages,false));
  }
  return result;
}",0.8509485094850948
56377,"/** 
 * Created a pipeline prototype for the supplied first project
 */
public static Pipeline extractPipeline(String name,AbstractProject<?,?> firstProject){
  Map<String,Stage> stages=newLinkedHashMap();
  for (  AbstractProject project : ProjectUtil.getAllDownstreamProjects(firstProject)) {
    PipelineProperty property=(PipelineProperty)project.getProperty(PipelineProperty.class);
    String taskName=property != null && !isNullOrEmpty(property.getTaskName()) ? property.getTaskName() : project.getDisplayName();
    Status status=project.isDisabled() ? disabled() : idle();
    Task task=new Task(project.getName(),taskName,null,status,project.getUrl(),false,null);
    String stageName=property != null && !isNullOrEmpty(property.getStageName()) ? property.getStageName() : project.getDisplayName();
    Stage stage=stages.get(stageName);
    if (stage == null)     stage=new Stage(stageName,Collections.<Task>emptyList());
    stages.put(stageName,new Stage(stage.getName(),newArrayList(concat(stage.getTasks(),singleton(task)))));
  }
  return new Pipeline(name,null,null,null,newArrayList(stages.values()),false);
}","/** 
 * Created a pipeline prototype for the supplied first project
 */
public static Pipeline extractPipeline(String name,AbstractProject<?,?> firstProject){
  Map<String,Stage> stages=newLinkedHashMap();
  for (  AbstractProject project : ProjectUtil.getAllDownstreamProjects(firstProject).values()) {
    Task task=getPrototypeTask(project);
    PipelineProperty property=(PipelineProperty)project.getProperty(PipelineProperty.class);
    String stageName=property != null && !isNullOrEmpty(property.getStageName()) ? property.getStageName() : project.getDisplayName();
    Stage stage=stages.get(stageName);
    if (stage == null)     stage=new Stage(stageName,Collections.<Task>emptyList());
    stages.put(stageName,new Stage(stage.getName(),newArrayList(concat(stage.getTasks(),singleton(task)))));
  }
  return new Pipeline(name,null,null,null,newArrayList(stages.values()),false);
}",0.7443012884043607
56378,"public static List<AbstractProject<?,?>> getAllDownstreamProjects(AbstractProject first){
  List<AbstractProject<?,?>> projects=new ArrayList<>();
  projects.add(first);
  for (  AbstractProject project : getDownstreamProjects(first))   projects.addAll(getAllDownstreamProjects(project));
  return projects;
}","public static Map<String,AbstractProject<?,?>> getAllDownstreamProjects(AbstractProject first){
  Map<String,AbstractProject<?,?>> projects=newLinkedHashMap();
  projects.put(first.getName(),first);
  for (  AbstractProject project : getDownstreamProjects(first))   projects.putAll(getAllDownstreamProjects(project));
  return projects;
}",0.8778979907264297
56379,"@Override public Collection<TopLevelItem> getItems(){
  return emptySet();
}","@Override public Collection<TopLevelItem> getItems(){
  return Jenkins.getInstance().getItems();
}",0.8045977011494253
56380,"@Override public boolean contains(TopLevelItem item){
  return false;
}","@Override public boolean contains(TopLevelItem item){
  return getItems().contains(item);
}",0.8518518518518519
56381,"public Pipeline createPipelineAggregated(Pipeline pipeline){
  AbstractProject firstProject=getProject(pipeline.getStages().get(0).getTasks().get(0));
  List<Stage> stages=new ArrayList<>();
  for (  Stage stage : pipeline.getStages()) {
    AbstractProject project=getProject(stage.getTasks().get(0));
    List<Task> tasks=new ArrayList<>();
    AbstractBuild versionBuild=getFirstUpstreamBuild(project,firstProject);
    String version=null;
    if (versionBuild != null) {
      version=versionBuild.getDisplayName();
    }
    for (    Task task : stage.getTasks()) {
      AbstractProject taskProject=getProject(task);
      AbstractBuild currentBuild=match(taskProject.getBuilds(),versionBuild);
      if (currentBuild != null) {
        Status status=resolveStatus(taskProject,currentBuild);
        if (!status.isIdle()) {
          tasks.add(new Task(task.getId(),task.getName(),status,Jenkins.getInstance().getRootUrl() + currentBuild.getUrl(),getTestResult(currentBuild)));
        }
 else {
          tasks.add(new Task(task.getId(),task.getName(),status,task.getLink(),getTestResult(currentBuild)));
        }
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),StatusFactory.idle(),task.getLink(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,stages,true);
}","public Pipeline createPipelineAggregated(Pipeline pipeline){
  AbstractProject firstProject=getProject(pipeline.getStages().get(0).getTasks().get(0));
  List<Stage> stages=new ArrayList<>();
  for (  Stage stage : pipeline.getStages()) {
    AbstractProject project=getProject(stage.getTasks().get(0));
    List<Task> tasks=new ArrayList<>();
    AbstractBuild versionBuild=getFirstUpstreamBuild(project,firstProject);
    String version=null;
    if (versionBuild != null) {
      version=versionBuild.getDisplayName();
    }
    for (    Task task : stage.getTasks()) {
      AbstractProject taskProject=getProject(task);
      AbstractBuild currentBuild=match(taskProject.getBuilds(),versionBuild);
      if (currentBuild != null) {
        Status status=resolveStatus(taskProject,currentBuild);
        if (!status.isIdle()) {
          tasks.add(new Task(task.getId(),task.getName(),status,currentBuild.getUrl(),getTestResult(currentBuild)));
        }
 else {
          tasks.add(new Task(task.getId(),task.getName(),status,task.getLink(),getTestResult(currentBuild)));
        }
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),StatusFactory.idle(),task.getLink(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,stages,true);
}",0.699228791773779
56382,"/** 
 * Created a pipeline prototype for the supplied first project
 */
public Pipeline extractPipeline(String name,AbstractProject<?,?> firstProject){
  Map<String,Stage> stages=newLinkedHashMap();
  for (  AbstractProject project : getAllDownstreamProjects(firstProject).values()) {
    PipelineProperty property=(PipelineProperty)project.getProperty(PipelineProperty.class);
    String taskName=property != null && property.getTaskName() != null && !property.getTaskName().equals(""String_Node_Str"") ? property.getTaskName() : project.getDisplayName();
    Status status=project.isDisabled() ? disabled() : idle();
    Task task=new Task(project.getName(),taskName,status,getUrl(project),null);
    String stageName=property != null && property.getStageName() != null && !property.getStageName().equals(""String_Node_Str"") ? property.getStageName() : project.getDisplayName();
    Stage stage=stages.get(stageName);
    if (stage == null)     stage=new Stage(stageName,Collections.<Task>emptyList());
    stages.put(stageName,new Stage(stage.getName(),newArrayList(concat(stage.getTasks(),singleton(task)))));
  }
  return new Pipeline(name,null,null,newArrayList(stages.values()),false);
}","/** 
 * Created a pipeline prototype for the supplied first project
 */
public Pipeline extractPipeline(String name,AbstractProject<?,?> firstProject){
  Map<String,Stage> stages=newLinkedHashMap();
  for (  AbstractProject project : getAllDownstreamProjects(firstProject).values()) {
    PipelineProperty property=(PipelineProperty)project.getProperty(PipelineProperty.class);
    String taskName=property != null && property.getTaskName() != null && !property.getTaskName().equals(""String_Node_Str"") ? property.getTaskName() : project.getDisplayName();
    Status status=project.isDisabled() ? disabled() : idle();
    Task task=new Task(project.getName(),taskName,status,getJobUrl(project),null);
    String stageName=property != null && property.getStageName() != null && !property.getStageName().equals(""String_Node_Str"") ? property.getStageName() : project.getDisplayName();
    Stage stage=stages.get(stageName);
    if (stage == null)     stage=new Stage(stageName,Collections.<Task>emptyList());
    stages.put(stageName,new Stage(stage.getName(),newArrayList(concat(stage.getTasks(),singleton(task)))));
  }
  return new Pipeline(name,null,null,newArrayList(stages.values()),false);
}",0.99874213836478
56383,"/** 
 * Populates and return pipelines for the supplied pipeline prototype with the current status.
 * @param pipeline      the pipeline prototype
 * @param noOfPipelines number of pipeline instances
 */
public List<Pipeline> createPipelineLatest(Pipeline pipeline,int noOfPipelines){
  Task firstTask=pipeline.getStages().get(0).getTasks().get(0);
  AbstractProject firstProject=getProject(firstTask);
  List<Pipeline> result=new ArrayList<>();
  Iterator it=firstProject.getBuilds().iterator();
  for (int i=0; i < noOfPipelines && it.hasNext(); i++) {
    AbstractBuild firstBuild=(AbstractBuild)it.next();
    List<Stage> stages=new ArrayList<>();
    for (    Stage stage : pipeline.getStages()) {
      List<Task> tasks=new ArrayList<>();
      for (      Task task : stage.getTasks()) {
        AbstractProject taskProject=getProject(task);
        AbstractBuild currentBuild=match(taskProject.getBuilds(),firstBuild);
        Status status=resolveStatus(taskProject,currentBuild);
        if (status.isIdle()) {
          tasks.add(new Task(task.getId(),task.getName(),status,task.getLink(),getTestResult(currentBuild)));
        }
 else {
          tasks.add(new Task(task.getId(),task.getName(),status,Jenkins.getInstance().getRootUrl() + currentBuild.getUrl(),getTestResult(currentBuild)));
        }
      }
      stages.add(new Stage(stage.getName(),tasks));
    }
    result.add(new Pipeline(pipeline.getName(),firstBuild.getDisplayName(),getTriggeredBy(firstBuild),stages,false));
  }
  return result;
}","/** 
 * Populates and return pipelines for the supplied pipeline prototype with the current status.
 * @param pipeline      the pipeline prototype
 * @param noOfPipelines number of pipeline instances
 */
public List<Pipeline> createPipelineLatest(Pipeline pipeline,int noOfPipelines){
  Task firstTask=pipeline.getStages().get(0).getTasks().get(0);
  AbstractProject firstProject=getProject(firstTask);
  List<Pipeline> result=new ArrayList<>();
  Iterator it=firstProject.getBuilds().iterator();
  for (int i=0; i < noOfPipelines && it.hasNext(); i++) {
    AbstractBuild firstBuild=(AbstractBuild)it.next();
    List<Stage> stages=new ArrayList<>();
    for (    Stage stage : pipeline.getStages()) {
      List<Task> tasks=new ArrayList<>();
      for (      Task task : stage.getTasks()) {
        AbstractProject taskProject=getProject(task);
        AbstractBuild currentBuild=match(taskProject.getBuilds(),firstBuild);
        Status status=resolveStatus(taskProject,currentBuild);
        if (status.isIdle()) {
          tasks.add(new Task(task.getId(),task.getName(),status,task.getLink(),getTestResult(currentBuild)));
        }
 else {
          tasks.add(new Task(task.getId(),task.getName(),status,currentBuild.getUrl(),getTestResult(currentBuild)));
        }
      }
      stages.add(new Stage(stage.getName(),tasks));
    }
    result.add(new Pipeline(pipeline.getName(),firstBuild.getDisplayName(),getTriggeredBy(firstBuild),stages,false));
  }
  return result;
}",0.9876625541847284
56384,"/** 
 * Returns the build for a projects that has been triggered by the supplied upstream project.
 */
private AbstractBuild match(RunList runList,AbstractBuild firstJob){
  for (  Object aRunList : runList) {
    AbstractBuild currentBuild=(AbstractBuild)aRunList;
    if (firstJob.equals(getFirstUpstreamBuild(currentBuild))) {
      return currentBuild;
    }
  }
  return null;
}","/** 
 * Returns the build for a projects that has been triggered by the supplied upstream project.
 */
private AbstractBuild match(RunList runList,AbstractBuild firstJob){
  if (firstJob != null) {
    for (    Object aRunList : runList) {
      AbstractBuild currentBuild=(AbstractBuild)aRunList;
      if (firstJob.equals(getFirstUpstreamBuild(currentBuild))) {
        return currentBuild;
      }
    }
  }
  return null;
}",0.9333333333333332
56385,"public Pipeline createPipelineAggregated(Pipeline pipeline){
  List<Stage> stages=new ArrayList<>();
  for (  Stage stage : pipeline.getStages()) {
    List<Task> tasks=new ArrayList<>();
    AbstractBuild firstTask=getJenkinsJob(stage.getTasks().get(0)).getLastBuild();
    AbstractBuild versionBuild=getFirstUpstreamBuild(firstTask);
    String version=versionBuild.getDisplayName();
    for (    Task task : stage.getTasks()) {
      AbstractProject job=getJenkinsJob(task);
      AbstractBuild currentBuild=match(job.getBuilds(),versionBuild);
      if (currentBuild != null) {
        tasks.add(new Task(task.getId(),task.getName(),resolveStatus(job,currentBuild),Jenkins.getInstance().getRootUrl() + currentBuild.getUrl(),getTestResult(currentBuild)));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),StatusFactory.idle(),task.getLink(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,stages);
}","public Pipeline createPipelineAggregated(Pipeline pipeline){
  List<Stage> stages=new ArrayList<>();
  for (  Stage stage : pipeline.getStages()) {
    List<Task> tasks=new ArrayList<>();
    AbstractBuild firstTask=getJenkinsJob(stage.getTasks().get(0)).getLastBuild();
    AbstractBuild versionBuild=getFirstUpstreamBuild(firstTask);
    String version=null;
    if (versionBuild != null) {
      version=versionBuild.getDisplayName();
    }
    for (    Task task : stage.getTasks()) {
      AbstractProject job=getJenkinsJob(task);
      AbstractBuild currentBuild=match(job.getBuilds(),versionBuild);
      if (currentBuild != null) {
        tasks.add(new Task(task.getId(),task.getName(),resolveStatus(job,currentBuild),Jenkins.getInstance().getRootUrl() + currentBuild.getUrl(),getTestResult(currentBuild)));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),StatusFactory.idle(),task.getLink(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,stages);
}",0.9721153846153846
56386,"public Pipeline createPipelineAggregated(Pipeline pipeline){
  List<Stage> stages=new ArrayList<>();
  for (  Stage stage : pipeline.getStages()) {
    String version=null;
    AbstractBuild versionBuild=null;
    List<Task> tasks=new ArrayList<>();
    for (    Task task : stage.getTasks()) {
      AbstractProject job=getJenkinsJob(task);
      AbstractBuild currentBuild=job.getLastBuild();
      AbstractBuild firstBuild=getFirstUpstreamBuild(currentBuild);
      if (firstBuild != null && version == null) {
        version=firstBuild.getDisplayName();
        versionBuild=firstBuild;
      }
      if (firstBuild != null && firstBuild.equals(versionBuild)) {
        tasks.add(new Task(task.getId(),task.getName(),resolveStatus(job,currentBuild),task.getLink(),getTestResult(currentBuild)));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),StatusFactory.idle(),task.getLink(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,stages);
}","public Pipeline createPipelineAggregated(Pipeline pipeline){
  List<Stage> stages=new ArrayList<>();
  for (  Stage stage : pipeline.getStages()) {
    List<Task> tasks=new ArrayList<>();
    AbstractBuild firstTask=getJenkinsJob(stage.getTasks().get(0)).getLastBuild();
    AbstractBuild versionBuild=getFirstUpstreamBuild(firstTask);
    String version=versionBuild.getDisplayName();
    for (    Task task : stage.getTasks()) {
      AbstractProject job=getJenkinsJob(task);
      AbstractBuild currentBuild=match(job.getBuilds(),versionBuild);
      if (currentBuild != null) {
        tasks.add(new Task(task.getId(),task.getName(),resolveStatus(job,currentBuild),Jenkins.getInstance().getRootUrl() + currentBuild.getUrl(),getTestResult(currentBuild)));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),StatusFactory.idle(),task.getLink(),null));
      }
    }
    stages.add(new Stage(stage.getName(),tasks,version));
  }
  return new Pipeline(pipeline.getName(),null,null,stages);
}",0.3053805138148328
56387,"@DataBoundConstructor public AggregatedPipelineView(String name,List<Component> components){
  super(name,components);
}","@DataBoundConstructor public AggregatedPipelineView(String name,int noOfColumns,List<Component> components){
  super(name,noOfColumns,components);
}",0.8955223880597015
56388,"@DataBoundConstructor public MultiPipelineView(String name,List<Component> components){
  super(name);
  this.components=components;
}","@DataBoundConstructor public MultiPipelineView(String name,int noOfColumns,List<Component> components){
  super(name);
  this.components=components;
  this.noOfColumns=noOfColumns;
}",0.8481012658227848
56389,"/** 
 * Opens up for testing and mocking, since Jenkins has getDownstreamProjects() final 
 */
List<AbstractProject<?,?>> getDownstreamProjects(AbstractProject project){
  return project.getDownstreamProjects();
}","/** 
 * Opens up for testing and mocking, since Jenkins has getDownstreamProjects() final
 */
List<AbstractProject<?,?>> getDownstreamProjects(AbstractProject project){
  return project.getDownstreamProjects();
}",0.9976470588235294
56390,"public Pipeline createPipelineLatest(Pipeline pipeline){
  AbstractBuild prevBuild=null;
  List<AbstractBuild> builds=new ArrayList<>();
  List<Stage> stages=new ArrayList<>();
  for (  Stage stage : pipeline.getStages()) {
    List<Task> tasks=new ArrayList<>();
    for (    Task task : stage.getTasks()) {
      AbstractProject job=Jenkins.getInstance().getItem(task.getId().toString(),Jenkins.getInstance(),AbstractProject.class);
      AbstractBuild build=job.getLastBuild();
      if (stages.isEmpty() || build != null && build.equals(getDownstreamBuild(job,prevBuild))) {
        Status status=resolveStatus(build);
        tasks.add(new Task(task.getId(),task.getName(),status));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),StatusFactory.idle()));
      }
      prevBuild=build;
    }
    stages.add(new Stage(stage.getName(),tasks));
  }
  return new Pipeline(pipeline.getName(),stages);
}","public Pipeline createPipelineLatest(Pipeline pipeline){
  List<Stage> stages=new ArrayList<>();
  AbstractBuild firstBuild=null;
  for (  Stage stage : pipeline.getStages()) {
    List<Task> tasks=new ArrayList<>();
    for (    Task task : stage.getTasks()) {
      AbstractProject job=Jenkins.getInstance().getItem(task.getId().toString(),Jenkins.getInstance(),AbstractProject.class);
      AbstractBuild build=job.getLastBuild();
      if (firstBuild == null) {
        firstBuild=build;
      }
      if (build != null && firstBuild.equals(getFirstUpstreamBuild(build))) {
        Status status=resolveStatus(build);
        tasks.add(new Task(task.getId(),task.getName(),status));
      }
 else {
        tasks.add(new Task(task.getId(),task.getName(),StatusFactory.idle()));
      }
    }
    stages.add(new Stage(stage.getName(),tasks));
  }
  return new Pipeline(pipeline.getName(),stages);
}",0.8587075575027382
56391,"public static Pipeline extractPipeline(String name,AbstractProject<?,?> firstJob){
  Map<String,Stage> stages=newLinkedHashMap();
  for (  AbstractProject job : getAllDownstreamJobs(firstJob)) {
    PipelineProperty property=(PipelineProperty)job.getProperty(PipelineProperty.class);
    String taskName=property != null && !property.getTaskName().equals(""String_Node_Str"") ? property.getTaskName() : job.getDisplayName();
    Task task=new Task(taskName,StatusFactory.idle());
    String stageName=property != null && !property.getStageName().equals(""String_Node_Str"") ? property.getStageName() : job.getDisplayName();
    Stage stage=stages.get(stageName);
    if (stage == null)     stage=new Stage(stageName,Collections.<Task>emptyList());
    stages.put(stageName,new Stage(stage.getName(),newArrayList(concat(stage.getTasks(),singleton(task)))));
  }
  return new Pipeline(name,newArrayList(stages.values()));
}","public static Pipeline extractPipeline(String name,AbstractProject<?,?> firstJob){
  Map<String,Stage> stages=newLinkedHashMap();
  for (  AbstractProject job : getAllDownstreamJobs(firstJob)) {
    PipelineProperty property=(PipelineProperty)job.getProperty(PipelineProperty.class);
    String taskName=property != null && !property.getTaskName().equals(""String_Node_Str"") ? property.getTaskName() : job.getDisplayName();
    Task task=new Task(job.getName(),taskName,StatusFactory.idle());
    String stageName=property != null && !property.getStageName().equals(""String_Node_Str"") ? property.getStageName() : job.getDisplayName();
    Stage stage=stages.get(stageName);
    if (stage == null)     stage=new Stage(stageName,Collections.<Task>emptyList());
    stages.put(stageName,new Stage(stage.getName(),newArrayList(concat(stage.getTasks(),singleton(task)))));
  }
  return new Pipeline(name,newArrayList(stages.values()));
}",0.9924242424242424
56392,"public boolean isUpdated(long traktId,long lastUpdated){
  Cursor show=null;
  try {
    show=resolver.query(Shows.SHOWS,new String[]{ShowColumns.LAST_UPDATED},ShowColumns.TRAKT_ID + ""String_Node_Str"",new String[]{String.valueOf(traktId)},null);
    if (show.moveToFirst()) {
      final long showLastUpdated=Cursors.getLong(show,ShowColumns.LAST_UPDATED);
      final long currentTime=System.currentTimeMillis();
      if (showLastUpdated > currentTime + DateUtils.DAY_IN_MILLIS) {
        Timber.e(new IllegalArgumentException(""String_Node_Str"" + TimeUtils.getIsoTime(showLastUpdated) + ""String_Node_Str""+ TimeUtils.getIsoTime(currentTime)),""String_Node_Str"");
        return true;
      }
      return lastUpdated > showLastUpdated;
    }
    return false;
  }
  finally {
    if (show != null)     show.close();
  }
}","public boolean isUpdated(long traktId,long lastUpdated){
  Cursor show=null;
  try {
    show=resolver.query(Shows.SHOWS,new String[]{ShowColumns.LAST_UPDATED},ShowColumns.TRAKT_ID + ""String_Node_Str"",new String[]{String.valueOf(traktId)},null);
    if (show.moveToFirst()) {
      final long showLastUpdated=Cursors.getLong(show,ShowColumns.LAST_UPDATED);
      return lastUpdated > showLastUpdated;
    }
    return false;
  }
  finally {
    if (show != null)     show.close();
  }
}",0.7436878347360367
56393,"@Override public boolean handleResponse(List<RatingItem> ratings){
  Cursor episodes=getContentResolver().query(Episodes.EPISODES,new String[]{EpisodeColumns.ID},EpisodeColumns.RATED_AT + ""String_Node_Str"",null,null);
  List<Long> episodeIds=new ArrayList<>();
  while (episodes.moveToNext()) {
    final long episodeId=Cursors.getLong(episodes,EpisodeColumns.ID);
    episodeIds.add(episodeId);
  }
  episodes.close();
  ArrayList<ContentProviderOperation> ops=new ArrayList<>();
  for (  RatingItem rating : ratings) {
    final int seasonNumber=rating.getEpisode().getSeason();
    final int episodeNumber=rating.getEpisode().getNumber();
    final long showTraktId=rating.getShow().getIds().getTrakt();
    ShowDatabaseHelper.IdResult showResult=showHelper.getIdOrCreate(showTraktId);
    final long showId=showResult.showId;
    final boolean didShowExist=!showResult.didCreate;
    if (showResult.didCreate) {
      queue(new SyncShow(showTraktId));
    }
    SeasonDatabaseHelper.IdResult seasonResult=seasonHelper.getIdOrCreate(showId,seasonNumber);
    final long seasonId=seasonResult.id;
    final boolean didSeasonExist=!seasonResult.didCreate;
    if (seasonResult.didCreate) {
      if (didShowExist) {
        queue(new SyncShow(showTraktId));
      }
    }
    EpisodeDatabaseHelper.IdResult episodeResult=episodeHelper.getIdOrCreate(showId,seasonId,episodeNumber);
    final long episodeId=episodeResult.id;
    if (episodeResult.didCreate) {
      if (didShowExist && didSeasonExist) {
        queue(new SyncSeason(showTraktId,seasonNumber));
      }
    }
    episodeIds.remove(seasonId);
    ContentProviderOperation op=ContentProviderOperation.newUpdate(Episodes.withId(episodeId)).withValue(EpisodeColumns.USER_RATING,rating.getRating()).withValue(EpisodeColumns.RATED_AT,rating.getRatedAt().getTimeInMillis()).build();
    ops.add(op);
  }
  for (  Long episodeId : episodeIds) {
    ContentProviderOperation op=ContentProviderOperation.newUpdate(Episodes.withId(episodeId)).withValue(EpisodeColumns.USER_RATING,0).withValue(EpisodeColumns.RATED_AT,0).build();
    ops.add(op);
  }
  return applyBatch(ops);
}","@Override public boolean handleResponse(List<RatingItem> ratings){
  Cursor episodes=getContentResolver().query(Episodes.EPISODES,new String[]{EpisodeColumns.ID},EpisodeColumns.RATED_AT + ""String_Node_Str"",null,null);
  List<Long> episodeIds=new ArrayList<>();
  while (episodes.moveToNext()) {
    final long episodeId=Cursors.getLong(episodes,EpisodeColumns.ID);
    episodeIds.add(episodeId);
  }
  episodes.close();
  ArrayList<ContentProviderOperation> ops=new ArrayList<>();
  for (  RatingItem rating : ratings) {
    final int seasonNumber=rating.getEpisode().getSeason();
    final int episodeNumber=rating.getEpisode().getNumber();
    final long showTraktId=rating.getShow().getIds().getTrakt();
    ShowDatabaseHelper.IdResult showResult=showHelper.getIdOrCreate(showTraktId);
    final long showId=showResult.showId;
    final boolean didShowExist=!showResult.didCreate;
    if (showResult.didCreate) {
      queue(new SyncShow(showTraktId));
    }
    SeasonDatabaseHelper.IdResult seasonResult=seasonHelper.getIdOrCreate(showId,seasonNumber);
    final long seasonId=seasonResult.id;
    final boolean didSeasonExist=!seasonResult.didCreate;
    if (seasonResult.didCreate) {
      if (didShowExist) {
        queue(new SyncShow(showTraktId));
      }
    }
    EpisodeDatabaseHelper.IdResult episodeResult=episodeHelper.getIdOrCreate(showId,seasonId,episodeNumber);
    final long episodeId=episodeResult.id;
    if (episodeResult.didCreate) {
      if (didShowExist && didSeasonExist) {
        queue(new SyncSeason(showTraktId,seasonNumber));
      }
    }
    episodeIds.remove(episodeId);
    ContentProviderOperation op=ContentProviderOperation.newUpdate(Episodes.withId(episodeId)).withValue(EpisodeColumns.USER_RATING,rating.getRating()).withValue(EpisodeColumns.RATED_AT,rating.getRatedAt().getTimeInMillis()).build();
    ops.add(op);
  }
  for (  Long episodeId : episodeIds) {
    ContentProviderOperation op=ContentProviderOperation.newUpdate(Episodes.withId(episodeId)).withValue(EpisodeColumns.USER_RATING,0).withValue(EpisodeColumns.RATED_AT,0).build();
    ops.add(op);
  }
  return applyBatch(ops);
}",0.9969519343493553
56394,"public static void upgrade(Context context,final JobQueue jobQueue){
  legacyUpgrade(context,jobQueue);
  final int currentVersion=Settings.get(context).getInt(SETTINGS_VERSION,-1);
  if (currentVersion == -1) {
    Settings.get(context).edit().putInt(SETTINGS_VERSION,VERSION).putInt(Settings.VERSION_CODE,BuildConfig.VERSION_CODE).apply();
    return;
  }
  if (currentVersion < VERSION) {
    if (currentVersion < 1) {
      if (Jobs.usesScheduler()) {
        if (TraktLinkSettings.isLinked(context)) {
          Account account=Accounts.getAccount(context);
          ContentResolver.removePeriodicSync(account,BuildConfig.PROVIDER_AUTHORITY,new Bundle());
          ContentResolver.setSyncAutomatically(account,BuildConfig.PROVIDER_AUTHORITY,false);
          ContentResolver.setIsSyncable(account,BuildConfig.PROVIDER_AUTHORITY,0);
        }
      }
    }
    if (currentVersion < 2) {
      Settings.get(context).edit().remove(""String_Node_Str"").remove(""String_Node_Str"").remove(""String_Node_Str"").remove(""String_Node_Str"").apply();
      Timestamps.get(context).edit().remove(Timestamps.SHOWS_LAST_UPDATED).remove(Timestamps.MOVIES_LAST_UPDATED).apply();
      final long lastUpdated=System.currentTimeMillis() - DateUtils.WEEK_IN_MILLIS;
      Timestamps.get(context).edit().putLong(Timestamps.SHOWS_LAST_UPDATED,lastUpdated).putLong(Timestamps.MOVIES_LAST_UPDATED,lastUpdated).apply();
    }
    Settings.get(context).edit().putInt(SETTINGS_VERSION,VERSION).apply();
  }
  Settings.get(context).edit().putInt(Settings.VERSION_CODE,BuildConfig.VERSION_CODE).apply();
}","public static void upgrade(Context context,final JobQueue jobQueue){
  legacyUpgrade(context,jobQueue);
  final int currentVersion=Settings.get(context).getInt(SETTINGS_VERSION,-1);
  if (currentVersion == -1) {
    Settings.get(context).edit().putInt(SETTINGS_VERSION,VERSION).putInt(Settings.VERSION_CODE,BuildConfig.VERSION_CODE).apply();
    return;
  }
  if (currentVersion < VERSION) {
    if (currentVersion < 1) {
      if (Jobs.usesScheduler()) {
        if (TraktLinkSettings.isLinked(context)) {
          Account account=Accounts.getAccount(context);
          ContentResolver.removePeriodicSync(account,BuildConfig.PROVIDER_AUTHORITY,new Bundle());
          ContentResolver.setSyncAutomatically(account,BuildConfig.PROVIDER_AUTHORITY,false);
          ContentResolver.setIsSyncable(account,BuildConfig.PROVIDER_AUTHORITY,0);
        }
      }
    }
    if (currentVersion < 2) {
      Settings.get(context).edit().remove(""String_Node_Str"").remove(""String_Node_Str"").remove(""String_Node_Str"").remove(""String_Node_Str"").apply();
      Timestamps.get(context).edit().remove(Timestamps.SHOWS_LAST_UPDATED).remove(Timestamps.MOVIES_LAST_UPDATED).apply();
      final long lastUpdated=System.currentTimeMillis() - DateUtils.WEEK_IN_MILLIS;
      Timestamps.get(context).edit().putLong(Timestamps.SHOWS_LAST_UPDATED,lastUpdated).putLong(Timestamps.MOVIES_LAST_UPDATED,lastUpdated).apply();
    }
    if (currentVersion < 3) {
      jobQueue.add(new SyncEpisodesRatings());
    }
    Settings.get(context).edit().putInt(SETTINGS_VERSION,VERSION).apply();
  }
  Settings.get(context).edit().putInt(Settings.VERSION_CODE,BuildConfig.VERSION_CODE).apply();
}",0.9743748070392096
56395,"/** 
 * Check into a movie on trakt. Think of this method as in between a seen and a scrobble. After checking in, the trakt will automatically display it as watching then switch over to watched status once the duration has elapsed.
 * @param movieId The database id of the movie.
 */
public void checkin(final long movieId,final String message,final boolean facebook,final boolean twitter,final boolean tumblr){
  execute(new Runnable(){
    @Override public void run(){
      Cursor watching=context.getContentResolver().query(Movies.WATCHING,new String[]{MovieColumns.RUNTIME,MovieColumns.EXPIRES_AT},null,null,null);
      watching.moveToFirst();
      final long currentTime=System.currentTimeMillis();
      final int runtime=Cursors.getInt(watching,MovieColumns.RUNTIME);
      final long expires=Cursors.getLong(watching,MovieColumns.EXPIRES_AT);
      final long watchSlop=(long)(runtime * DateUtils.MINUTE_IN_MILLIS * 0.8f);
      Cursor movie=context.getContentResolver().query(Movies.withId(movieId),new String[]{MovieColumns.TITLE},null,null,null);
      movie.moveToFirst();
      final String title=Cursors.getString(movie,MovieColumns.TITLE);
      movie.close();
      if (watching.getCount() == 0 || ((expires - watchSlop) < currentTime && expires > 0)) {
        if (checkIn.movie(movieId,message,facebook,twitter,tumblr)) {
          movieHelper.checkIn(movieId);
        }
      }
 else {
        ErrorEvent.post(context.getString(R.string.checkin_error_watching,title));
      }
      watching.close();
      queue(new SyncWatching());
    }
  }
);
}","/** 
 * Check into a movie on trakt. Think of this method as in between a seen and a scrobble. After checking in, the trakt will automatically display it as watching then switch over to watched status once the duration has elapsed.
 * @param movieId The database id of the movie.
 */
public void checkin(final long movieId,final String message,final boolean facebook,final boolean twitter,final boolean tumblr){
  execute(new Runnable(){
    @Override public void run(){
      Cursor watching=context.getContentResolver().query(Movies.WATCHING,new String[]{MovieColumns.RUNTIME,MovieColumns.EXPIRES_AT},null,null,null);
      if (watching.moveToFirst()) {
        final long currentTime=System.currentTimeMillis();
        final int runtime=Cursors.getInt(watching,MovieColumns.RUNTIME);
        final long expires=Cursors.getLong(watching,MovieColumns.EXPIRES_AT);
        final long watchSlop=(long)(runtime * DateUtils.MINUTE_IN_MILLIS * 0.8f);
        Cursor movie=context.getContentResolver().query(Movies.withId(movieId),new String[]{MovieColumns.TITLE},null,null,null);
        movie.moveToFirst();
        final String title=Cursors.getString(movie,MovieColumns.TITLE);
        movie.close();
        if ((expires - watchSlop) < currentTime && expires > 0) {
          if (checkIn.movie(movieId,message,facebook,twitter,tumblr)) {
            movieHelper.checkIn(movieId);
          }
        }
 else {
          ErrorEvent.post(context.getString(R.string.checkin_error_watching,title));
        }
      }
 else {
        if (checkIn.movie(movieId,message,facebook,twitter,tumblr)) {
          movieHelper.checkIn(movieId);
        }
      }
      watching.close();
      queue(new SyncWatching());
    }
  }
);
}",0.9337788578371812
56396,"private void resume(){
  Timber.d(""String_Node_Str"",running);
  if (!running) {
    running=true;
    MainHandler.removeCallbacks(resumeRunnable);
    MainHandler.removeCallbacks(stopRunnable);
    onResume();
  }
}","private void resume(){
  if (!resumed) {
    resumed=true;
    onResume();
  }
}",0.4745762711864407
56397,"@Override public void onQueueFailed(){
  Timber.d(""String_Node_Str"",getClass().getSimpleName());
  pause();
  MainHandler.postDelayed(resumeRunnable,FAILURE_DELAY);
  dispatchQueueFailed();
}","@Override public void onQueueFailed(){
  Timber.d(""String_Node_Str"",getClass().getSimpleName());
  pause();
  MainHandler.postDelayed(new Runnable(){
    @Override public void run(){
      executor.unhalt();
    }
  }
,FAILURE_DELAY);
  dispatchQueueFailed();
}",0.8185840707964602
56398,"private void start(){
  Timber.d(""String_Node_Str"");
  executor.start();
  onStart();
}","private void start(){
  Timber.d(""String_Node_Str"",started);
  if (!started) {
    started=true;
    executor.start();
  }
}",0.7298578199052133
56399,"private void dispatchQueueEmpty(){
  for (  JobHandlerListener listener : listeners) {
    listener.onQueueEmpty();
  }
}","private void dispatchQueueEmpty(){
synchronized (listeners) {
    for (int i=listeners.size() - 1; i >= 0; i--) {
      JobHandlerListener listener=listeners.get(i);
      listener.onQueueEmpty();
    }
  }
}",0.6382978723404256
56400,"private void pause(){
  Timber.d(""String_Node_Str"",running);
  if (running) {
    running=false;
    MainHandler.removeCallbacks(resumeRunnable);
    MainHandler.removeCallbacks(stopRunnable);
    onPause();
  }
}","private void pause(){
  if (resumed) {
    resumed=false;
    onPause();
  }
}",0.4673539518900343
56401,"public void registerListener(JobHandlerListener listener){
  listeners.add(listener);
  MainHandler.removeCallbacks(resumeRunnable);
  MainHandler.removeCallbacks(stopRunnable);
  if (listeners.size() == 1) {
    start();
  }
  Timber.d(""String_Node_Str"",listeners.size());
}","public void registerListener(JobHandlerListener listener){
synchronized (listeners) {
    listeners.add(listener);
    MainHandler.removeCallbacks(stopRunnable);
    start();
    Timber.d(""String_Node_Str"",listeners.size());
  }
}",0.6178217821782178
56402,"public JobHandler(int withFlags,int withoutFlags,int threadCount){
  Injector.obtain().inject(this);
  executor=new JobExecutor(jobManager,executorListener,threadCount,withFlags,withoutFlags);
  executor.start();
}","public JobHandler(int withFlags,int withoutFlags,int threadCount){
  Injector.obtain().inject(this);
  executor=new JobExecutor(jobManager,executorListener,threadCount,withFlags,withoutFlags);
}",0.9509803921568628
56403,"private void dispatchQueueFailed(){
  for (  JobHandlerListener listener : listeners) {
    listener.onQueueFailed();
  }
}","private void dispatchQueueFailed(){
synchronized (listeners) {
    for (int i=listeners.size() - 1; i >= 0; i--) {
      JobHandlerListener listener=listeners.get(i);
      listener.onQueueFailed();
    }
  }
}",0.5705705705705706
56404,"public void unregisterListener(JobHandlerListener listener){
  listeners.remove(listener);
  if (listeners.isEmpty()) {
    Timber.d(""String_Node_Str"");
    MainHandler.postDelayed(stopRunnable,STOP_DELAY);
  }
 else {
    Timber.d(""String_Node_Str"",listeners.size());
  }
}","public void unregisterListener(JobHandlerListener listener){
synchronized (listeners) {
    listeners.remove(listener);
    if (listeners.isEmpty()) {
      Timber.d(""String_Node_Str"");
      MainHandler.postDelayed(stopRunnable,STOP_DELAY);
    }
 else {
      Timber.d(""String_Node_Str"",listeners.size());
    }
  }
}",0.924114671163575
56405,"private void stop(){
  Timber.d(""String_Node_Str"");
  executor.stop();
  pause();
  onStop();
}","private void stop(){
  Timber.d(""String_Node_Str"");
  if (started) {
    started=false;
    executor.stop();
    onStop();
  }
}",0.7713004484304933
56406,"@Override public void onQueueFailed(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,true);
  MainHandler.post(new Runnable(){
    @Override public void run(){
      jobHandler.unregisterListener(listener);
    }
  }
);
}","@Override public void onQueueFailed(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,true);
  jobHandler.unregisterListener(listener);
}",0.7980997624703088
56407,"@Override public void run(){
  jobHandler.unregisterListener(listener);
}","@Override public void run(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,false);
}",0.4761904761904761
56408,"@Override public void onQueueEmpty(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,false);
  MainHandler.post(new Runnable(){
    @Override public void run(){
      jobHandler.unregisterListener(listener);
    }
  }
);
}","@Override public void onQueueEmpty(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,false);
  jobHandler.unregisterListener(listener);
}",0.7980997624703088
56409,"@Override public void onQueueFailed(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,true);
  MainHandler.post(new Runnable(){
    @Override public void run(){
      jobHandler.unregisterListener(listener);
    }
  }
);
}","@Override public void onQueueFailed(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,true);
  jobHandler.unregisterListener(listener);
}",0.7980997624703088
56410,"@Override public void run(){
  jobHandler.unregisterListener(listener);
}","@Override public void run(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,false);
}",0.4761904761904761
56411,"@Override public void onQueueEmpty(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,false);
  MainHandler.post(new Runnable(){
    @Override public void run(){
      jobHandler.unregisterListener(listener);
    }
  }
);
}","@Override public void onQueueEmpty(){
  Timber.d(""String_Node_Str"",params.getJobId());
  service.jobFinished(params,false);
  jobHandler.unregisterListener(listener);
}",0.7980997624703088
56412,"public BaseUrlRequestHandler(Context context){
  this.context=context;
  Injector.obtain().inject(this);
  settings=PreferenceManager.getDefaultSharedPreferences(context);
}","public BaseUrlRequestHandler(Context context,ConfigurationService configurationService){
  this.context=context;
  this.configurationService=configurationService;
  settings=PreferenceManager.getDefaultSharedPreferences(context);
}",0.3910891089108911
56413,"public EpisodeRequestHandler(Context context,ImageDownloader downloader){
  super(context,downloader);
}","public EpisodeRequestHandler(Context context,ConfigurationService configurationService,ImageDownloader downloader,TvEpisodesService tvEpisodesService,ShowDatabaseHelper showHelper,EpisodeDatabaseHelper episodeHelper){
  super(context,configurationService,downloader);
  this.tvEpisodesService=tvEpisodesService;
  this.showHelper=showHelper;
  this.episodeHelper=episodeHelper;
}",0.4306418219461698
56414,"public static String retainImages(Context context,long id,Images images){
  ContentValues values=new ContentValues();
  values.put(EpisodeColumns.IMAGES_LAST_UPDATE,System.currentTimeMillis());
  Image screenshot=selectBest(images.stills);
  String path=null;
  if (screenshot != null) {
    final String screenshotPath=ImageUri.create(ImageType.BACKDROP,screenshot.file_path);
    values.put(EpisodeColumns.SCREENSHOT,screenshotPath);
    path=screenshotPath;
  }
 else {
    values.putNull(EpisodeColumns.SCREENSHOT);
  }
  context.getContentResolver().update(Episodes.withId(id),values,null,null);
  return path;
}","public static void retainImages(Context context,long id,Images images){
  ContentValues values=new ContentValues();
  values.put(EpisodeColumns.IMAGES_LAST_UPDATE,System.currentTimeMillis());
  Image screenshot=selectBest(images.stills);
  if (screenshot != null) {
    final String screenshotPath=ImageUri.create(ImageType.BACKDROP,screenshot.file_path);
    values.put(EpisodeColumns.SCREENSHOT,screenshotPath);
  }
 else {
    values.putNull(EpisodeColumns.SCREENSHOT);
  }
  context.getContentResolver().update(Episodes.withId(id),values,null,null);
}",0.940273037542662
56415,"@Override protected String getCachedPath(ImageType imageType,long id){
  Cursor c=null;
  try {
    c=context.getContentResolver().query(Episodes.withId(id),new String[]{EpisodeColumns.IMAGES_LAST_UPDATE,EpisodeColumns.SCREENSHOT},null,null,null);
    c.moveToFirst();
    long lastUpdate=Cursors.getLong(c,EpisodeColumns.IMAGES_LAST_UPDATE);
    final boolean needsUpdate=lastUpdate + DateUtils.WEEK_IN_MILLIS < System.currentTimeMillis();
    if (imageType == ImageType.STILL) {
      String path=Cursors.getString(c,EpisodeColumns.SCREENSHOT);
      if (!needsUpdate && !TextUtils.isEmpty(path)) {
        return path;
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + imageType.toString());
    }
  }
  finally {
    Closeables.closeQuietly(c);
  }
  return null;
}","@Override protected String getCachedPath(ImageType imageType,long id){
  Cursor c=null;
  try {
    c=context.getContentResolver().query(Episodes.withId(id),new String[]{EpisodeColumns.IMAGES_LAST_UPDATE,EpisodeColumns.SCREENSHOT},null,null,null);
    c.moveToFirst();
    if (imageType == ImageType.STILL) {
      return Cursors.getString(c,EpisodeColumns.SCREENSHOT);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + imageType.toString());
    }
  }
  finally {
    Closeables.closeQuietly(c);
  }
}",0.7419112114371708
56416,"@Provides @Singleton Picasso providePicasso(Context context){
  final File cacheDir=createCacheDir(context);
  final long cacheSize=calculateDiskCacheSize(cacheDir);
  OkHttpClient okClient=defaultOkHttpClient(cacheDir,cacheSize);
  Downloader downloader=new OkHttp3Downloader(okClient);
  ImageDownloader imageDownloader=new ImageDownloader(okClient);
  Picasso.Builder builder=new Picasso.Builder(context).requestTransformer(new ImageRequestTransformer(context)).addRequestHandler(new ImageRequestHandler(context,downloader)).addRequestHandler(new ShowRequestHandler(context,imageDownloader)).addRequestHandler(new SeasonRequestHandler(context,imageDownloader)).addRequestHandler(new EpisodeRequestHandler(context,imageDownloader)).addRequestHandler(new MovieRequestHandler(context,imageDownloader)).addRequestHandler(new PersonRequestHandler(context,imageDownloader)).downloader(downloader);
  if (BuildConfig.DEBUG) {
    builder.listener(new Picasso.Listener(){
      @Override public void onImageLoadFailed(      Picasso picasso,      Uri uri,      Exception exception){
        Timber.d(exception);
      }
    }
);
  }
  return builder.build();
}","@Provides @Singleton Picasso providePicasso(Context context,Downloader downloader,ImageRequestHandler imageRequestHandler,ShowRequestHandler showRequestHandler,SeasonRequestHandler seasonRequestHandler,EpisodeRequestHandler episodeRequestHandler,MovieRequestHandler movieRequestHandler,PersonRequestHandler personRequestHandler){
  Picasso.Builder builder=new Picasso.Builder(context).requestTransformer(new ImageRequestTransformer(context)).addRequestHandler(imageRequestHandler).addRequestHandler(showRequestHandler).addRequestHandler(seasonRequestHandler).addRequestHandler(episodeRequestHandler).addRequestHandler(movieRequestHandler).addRequestHandler(personRequestHandler).downloader(downloader);
  if (BuildConfig.DEBUG) {
    builder.listener(new Picasso.Listener(){
      @Override public void onImageLoadFailed(      Picasso picasso,      Uri uri,      Exception exception){
        Timber.d(exception);
      }
    }
);
  }
  return builder.build();
}",0.3648393194706994
56417,"public ImageRequestHandler(Context context,Downloader downloader){
  super(context);
  this.downloader=downloader;
}","public ImageRequestHandler(Context context,ConfigurationService configurationService,Downloader downloader){
  super(context,configurationService);
  this.downloader=downloader;
}",0.7864406779661017
56418,"@Override public void perform(){
  if (TraktTimestamps.shouldPurge(getContext())) {
    queue(new PurgeDatabase());
  }
  queue(new SyncConfiguration());
  queue(new SyncUserSettings());
  queue(new StartSyncUpdatedShows());
  queue(new StartSyncUpdatedMovies());
  queue(new SyncUserActivity());
  if (TraktTimestamps.suggestionsNeedsUpdate(getContext())) {
    TraktTimestamps.updateSuggestions(getContext());
    queue(new SyncTrendingShows());
    queue(new SyncTrendingMovies());
    queue(new SyncShowRecommendations());
    queue(new SyncMovieRecommendations());
    queue(new SyncAnticipatedShows());
    queue(new SyncAnticipatedMovies());
  }
  if (TraktTimestamps.hiddenNeedsUpdate(getContext())) {
    TraktTimestamps.updateHidden(getContext());
    queue(new SyncHiddenItems());
  }
  final long currentTime=System.currentTimeMillis();
  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(getContext());
  settings.edit().putLong(Settings.LAST_FULL_SYNC,currentTime).apply();
}","@Override public void perform(){
  queue(new SyncConfiguration());
  queue(new SyncUserSettings());
  queue(new StartSyncUpdatedShows());
  queue(new StartSyncUpdatedMovies());
  queue(new SyncUserActivity());
  if (TraktTimestamps.suggestionsNeedsUpdate(getContext())) {
    TraktTimestamps.updateSuggestions(getContext());
    queue(new SyncTrendingShows());
    queue(new SyncTrendingMovies());
    queue(new SyncShowRecommendations());
    queue(new SyncMovieRecommendations());
    queue(new SyncAnticipatedShows());
    queue(new SyncAnticipatedMovies());
  }
  if (TraktTimestamps.hiddenNeedsUpdate(getContext())) {
    TraktTimestamps.updateHidden(getContext());
    queue(new SyncHiddenItems());
  }
  final long currentTime=System.currentTimeMillis();
  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(getContext());
  settings.edit().putLong(Settings.LAST_FULL_SYNC,currentTime).apply();
}",0.9550851832731028
56419,"@OnUpgrade public static void onUpgrade(Context context,SQLiteDatabase db,int oldVersion,int newVersion){
  if (oldVersion < 12) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    CathodeDatabase.getInstance(context).onCreate(db);
  }
  if (oldVersion < 13) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SEASONS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SHOW_CAST,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CAST,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CREW,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 14) {
    db.execSQL(CathodeDatabase.LISTS);
    db.execSQL(CathodeDatabase.LIST_ITEMS);
  }
  if (oldVersion < 16) {
    Set<String> showColumns=SqlUtils.columns(db,Tables.SHOWS);
    if (!showColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
    Set<String> seasonColumns=SqlUtils.columns(db,Tables.SEASONS);
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
    Set<String> movieColumns=SqlUtils.columns(db,Tables.MOVIES);
    if (!movieColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 18) {
    db.execSQL(CathodeDatabase.COMMENTS);
    db.execSQL(CathodeDatabase.USERS);
  }
  if (oldVersion < 19) {
    Set<String> showColumns=SqlUtils.columns(db,Tables.SHOWS);
    if (!showColumns.contains(ShowColumns.LAST_COMMENT_SYNC)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ ShowColumns.LAST_COMMENT_SYNC+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 20) {
    Set<String> movieColumns=SqlUtils.columns(db,Tables.MOVIES);
    if (!movieColumns.contains(MovieColumns.LAST_COMMENT_SYNC)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ MovieColumns.LAST_COMMENT_SYNC+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 21) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_CREDITS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_CREDITS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    final long currentTime=System.currentTimeMillis();
    ContentValues values=new ContentValues();
    values.put(ShowColumns.LAST_SYNC,currentTime);
    values.put(ShowColumns.LAST_CREDITS_SYNC,currentTime);
    db.update(Tables.SHOWS,values,null,null);
    values=new ContentValues();
    values.put(MovieColumns.LAST_SYNC,currentTime);
    values.put(MovieColumns.LAST_CREDITS_SYNC,currentTime);
    db.update(Tables.MOVIES,values,null,null);
  }
  if (oldVersion < 22) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.ANTICIPATED_INDEX,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.ANTICIPATED_INDEX,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 23) {
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,EpisodeColumns.LAST_COMMENT_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 24) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.WATCHING,DataType.Type.INTEGER,""String_Node_Str"");
    db.execSQL(TRIGGER_EPISODE_UPDATE_WATCHING);
  }
  if (oldVersion < 25) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(CathodeDatabase.RECENT_QUERIES);
  }
  if (oldVersion < 26) {
    db.execSQL(CathodeDatabase.SHOW_RELATED);
    db.execSQL(CathodeDatabase.MOVIE_RELATED);
  }
  if (oldVersion < 27) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_RELATED_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_RELATED_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 28) {
    db.execSQL(""String_Node_Str"" + Tables.SHOW_CAST);
    db.execSQL(CathodeDatabase.SHOW_CREW);
  }
  if (oldVersion < 29) {
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,PersonColumns.SCREENSHOT,DataType.Type.TEXT,null);
  }
  if (oldVersion < 30) {
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,PersonColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 31) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_CREDITS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_CREDITS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 32) {
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,EpisodeColumns.IMAGES_LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,PersonColumns.IMAGES_LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 33) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.IMAGES_LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CAST,MovieColumns.IMAGES_LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 34) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.BACKDROP,DataType.Type.TEXT,null);
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.BACKDROP,DataType.Type.TEXT,null);
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,PersonColumns.SCREENSHOT,DataType.Type.TEXT,null);
  }
  if (oldVersion < 35) {
    ContentValues showValues=new ContentValues();
    showValues.putNull(ShowColumns.BACKDROP);
    showValues.putNull(ShowColumns.POSTER);
    db.update(Tables.SHOWS,showValues,null,null);
    ContentValues episodeValues=new ContentValues();
    episodeValues.putNull(EpisodeColumns.SCREENSHOT);
    db.update(Tables.EPISODES,episodeValues,null,null);
    ContentValues movieValues=new ContentValues();
    movieValues.putNull(MovieColumns.BACKDROP);
    movieValues.putNull(MovieColumns.POSTER);
    db.update(Tables.MOVIES,movieValues,null,null);
    ContentValues personValues=new ContentValues();
    personValues.putNull(PersonColumns.SCREENSHOT);
    personValues.putNull(PersonColumns.HEADSHOT);
    db.update(Tables.PEOPLE,personValues,null,null);
  }
  if (oldVersion < 36) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(TRIGGER_EPISODE_UPDATE_AIRED);
    db.execSQL(TRIGGER_EPISODE_UPDATE_WATCHED);
    db.execSQL(TRIGGER_EPISODE_UPDATE_COLLECTED);
    db.execSQL(TRIGGER_EPISODE_UPDATE_WATCHING);
    db.execSQL(TRIGGER_EPISODE_INSERT);
    db.execSQL(TRIGGER_SHOW_DELETE);
    db.execSQL(TRIGGER_SEASON_DELETE);
    db.execSQL(TRIGGER_EPISODE_DELETE);
    db.execSQL(TRIGGER_MOVIE_DELETE);
    db.execSQL(TRIGGER_SHOW_UPDATE);
    db.execSQL(TRIGGER_SEASON_UPDATE);
    db.execSQL(TRIGGER_EPISODE_UPDATE);
    db.execSQL(TRIGGER_MOVIES_UPDATE);
    db.execSQL(TRIGGER_PEOPLE_UPDATE);
    db.execSQL(TRIGGER_LIST_DELETE);
    db.execSQL(TRIGGER_LIST_UPDATE);
    db.execSQL(TRIGGER_LISTITEM_UPDATE);
    db.execSQL(TRIGGER_COMMENT_UPDATE);
    db.execSQL(""String_Node_Str"");
    db.execSQL(INDEX_CAST_SHOW_ID);
    db.execSQL(INDEX_CREW_SHOW_ID);
    db.execSQL(INDEX_RELATED_SHOW_ID);
    db.execSQL(INDEX_SEASON_SHOW_ID);
    db.execSQL(INDEX_GENRE_SHOW_ID);
    db.execSQL(INDEX_CAST_MOVIE_ID);
    db.execSQL(INDEX_CREW_MOVIE_ID);
    db.execSQL(INDEX_RELATED_MOVIE_ID);
    db.execSQL(INDEX_GENRE_MOVIE_ID);
    db.execSQL(INDEX_EPISODES_SHOW_ID);
    db.execSQL(INDEX_EPISODES_SEASON_ID);
  }
  if (oldVersion < 37) {
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,EpisodeColumns.NOTIFICATION_DISMISSED,DataType.Type.INTEGER,""String_Node_Str"");
  }
}","@OnUpgrade public static void onUpgrade(Context context,SQLiteDatabase db,int oldVersion,int newVersion){
  if (oldVersion < 12) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
  }
  if (oldVersion < 13) {
    CathodeDatabase.getInstance(context).onCreate(db);
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SEASONS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SHOW_CAST,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CAST,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CREW,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 14) {
    db.execSQL(CathodeDatabase.LISTS);
    db.execSQL(CathodeDatabase.LIST_ITEMS);
  }
  if (oldVersion < 16) {
    Set<String> showColumns=SqlUtils.columns(db,Tables.SHOWS);
    if (!showColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
    Set<String> seasonColumns=SqlUtils.columns(db,Tables.SEASONS);
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
    Set<String> movieColumns=SqlUtils.columns(db,Tables.MOVIES);
    if (!movieColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 18) {
    db.execSQL(CathodeDatabase.COMMENTS);
    db.execSQL(CathodeDatabase.USERS);
  }
  if (oldVersion < 19) {
    Set<String> showColumns=SqlUtils.columns(db,Tables.SHOWS);
    if (!showColumns.contains(ShowColumns.LAST_COMMENT_SYNC)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ ShowColumns.LAST_COMMENT_SYNC+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 20) {
    Set<String> movieColumns=SqlUtils.columns(db,Tables.MOVIES);
    if (!movieColumns.contains(MovieColumns.LAST_COMMENT_SYNC)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ MovieColumns.LAST_COMMENT_SYNC+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 21) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_CREDITS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_CREDITS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    final long currentTime=System.currentTimeMillis();
    ContentValues values=new ContentValues();
    values.put(ShowColumns.LAST_SYNC,currentTime);
    values.put(ShowColumns.LAST_CREDITS_SYNC,currentTime);
    db.update(Tables.SHOWS,values,null,null);
    values=new ContentValues();
    values.put(MovieColumns.LAST_SYNC,currentTime);
    values.put(MovieColumns.LAST_CREDITS_SYNC,currentTime);
    db.update(Tables.MOVIES,values,null,null);
  }
  if (oldVersion < 22) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.ANTICIPATED_INDEX,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.ANTICIPATED_INDEX,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 23) {
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,EpisodeColumns.LAST_COMMENT_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 24) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.WATCHING,DataType.Type.INTEGER,""String_Node_Str"");
    db.execSQL(TRIGGER_EPISODE_UPDATE_WATCHING);
  }
  if (oldVersion < 25) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(CathodeDatabase.RECENT_QUERIES);
  }
  if (oldVersion < 26) {
    db.execSQL(CathodeDatabase.SHOW_RELATED);
    db.execSQL(CathodeDatabase.MOVIE_RELATED);
  }
  if (oldVersion < 27) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_RELATED_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_RELATED_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 28) {
    db.execSQL(""String_Node_Str"" + Tables.SHOW_CAST);
    db.execSQL(CathodeDatabase.SHOW_CREW);
  }
  if (oldVersion < 29) {
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,PersonColumns.SCREENSHOT,DataType.Type.TEXT,null);
  }
  if (oldVersion < 30) {
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,PersonColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 31) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_CREDITS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_CREDITS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 32) {
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,EpisodeColumns.IMAGES_LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,PersonColumns.IMAGES_LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 33) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.IMAGES_LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CAST,MovieColumns.IMAGES_LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 34) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.BACKDROP,DataType.Type.TEXT,null);
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.BACKDROP,DataType.Type.TEXT,null);
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,PersonColumns.SCREENSHOT,DataType.Type.TEXT,null);
  }
  if (oldVersion < 35) {
    ContentValues showValues=new ContentValues();
    showValues.putNull(ShowColumns.BACKDROP);
    showValues.putNull(ShowColumns.POSTER);
    db.update(Tables.SHOWS,showValues,null,null);
    ContentValues episodeValues=new ContentValues();
    episodeValues.putNull(EpisodeColumns.SCREENSHOT);
    db.update(Tables.EPISODES,episodeValues,null,null);
    ContentValues movieValues=new ContentValues();
    movieValues.putNull(MovieColumns.BACKDROP);
    movieValues.putNull(MovieColumns.POSTER);
    db.update(Tables.MOVIES,movieValues,null,null);
    ContentValues personValues=new ContentValues();
    personValues.putNull(PersonColumns.SCREENSHOT);
    personValues.putNull(PersonColumns.HEADSHOT);
    db.update(Tables.PEOPLE,personValues,null,null);
  }
  if (oldVersion < 36) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(TRIGGER_EPISODE_UPDATE_AIRED);
    db.execSQL(TRIGGER_EPISODE_UPDATE_WATCHED);
    db.execSQL(TRIGGER_EPISODE_UPDATE_COLLECTED);
    db.execSQL(TRIGGER_EPISODE_UPDATE_WATCHING);
    db.execSQL(TRIGGER_EPISODE_INSERT);
    db.execSQL(TRIGGER_SHOW_DELETE);
    db.execSQL(TRIGGER_SEASON_DELETE);
    db.execSQL(TRIGGER_EPISODE_DELETE);
    db.execSQL(TRIGGER_MOVIE_DELETE);
    db.execSQL(TRIGGER_SHOW_UPDATE);
    db.execSQL(TRIGGER_SEASON_UPDATE);
    db.execSQL(TRIGGER_EPISODE_UPDATE);
    db.execSQL(TRIGGER_MOVIES_UPDATE);
    db.execSQL(TRIGGER_PEOPLE_UPDATE);
    db.execSQL(TRIGGER_LIST_DELETE);
    db.execSQL(TRIGGER_LIST_UPDATE);
    db.execSQL(TRIGGER_LISTITEM_UPDATE);
    db.execSQL(TRIGGER_COMMENT_UPDATE);
    db.execSQL(""String_Node_Str"");
    db.execSQL(INDEX_CAST_SHOW_ID);
    db.execSQL(INDEX_CREW_SHOW_ID);
    db.execSQL(INDEX_RELATED_SHOW_ID);
    db.execSQL(INDEX_SEASON_SHOW_ID);
    db.execSQL(INDEX_GENRE_SHOW_ID);
    db.execSQL(INDEX_CAST_MOVIE_ID);
    db.execSQL(INDEX_CREW_MOVIE_ID);
    db.execSQL(INDEX_RELATED_MOVIE_ID);
    db.execSQL(INDEX_GENRE_MOVIE_ID);
    db.execSQL(INDEX_EPISODES_SHOW_ID);
    db.execSQL(INDEX_EPISODES_SEASON_ID);
  }
  if (oldVersion < 37) {
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,EpisodeColumns.NOTIFICATION_DISMISSED,DataType.Type.INTEGER,""String_Node_Str"");
  }
}",0.995153758040356
56420,"@Override public Loader<SimpleCursor> onCreateLoader(int i,Bundle bundle){
  return new SimpleCursorLoader(getActivity(),ProviderSchematic.RelatedMovies.fromMovie(movieId),null,null,null,null);
}","@Override public Loader<SimpleCursor> onCreateLoader(int i,Bundle bundle){
  return new SimpleCursorLoader(getActivity(),RelatedMovies.fromMovie(movieId),MoviesAdapter.PROJECTION,null,null,null);
}",0.8826530612244898
56421,"@Override public void run(){
  setVisibility(GONE);
  collapse();
}","@Override public void run(){
  setVisibility(GONE);
  collapse();
  setAnimationProgress(1.0f);
}",0.8170731707317073
56422,"private void animateOut(){
  if (watchingViewListener != null) {
    watchingViewListener.onAnimatingOut(this);
  }
  if (getVisibility() != GONE) {
    animate().alpha(0.0f).withEndAction(new Runnable(){
      @Override public void run(){
        setVisibility(GONE);
        collapse();
      }
    }
);
  }
}","private void animateOut(){
  if (watchingViewListener != null) {
    watchingViewListener.onAnimatingOut(this);
  }
  if (getVisibility() != GONE) {
    animate().alpha(0.0f).withEndAction(new Runnable(){
      @Override public void run(){
        setVisibility(GONE);
        collapse();
        setAnimationProgress(1.0f);
      }
    }
);
  }
}",0.8966565349544073
56423,"private void clearVariables(){
  type=null;
  showId=-1L;
  showTitle=null;
  episodeId=-1L;
  episodeTitle=null;
  movieId=-1L;
  movieTitle=null;
  poster=null;
  startTime=0L;
  endTime=0L;
  isExpanded=false;
}","private void clearVariables(){
  type=null;
  showId=-1L;
  showTitle=null;
  episodeId=-1L;
  episodeTitle=null;
  movieId=-1L;
  movieTitle=null;
  poster=null;
  startTime=0L;
  endTime=0L;
}",0.9509803921568628
56424,"public void watchingMovie(long movieId,String movieTitle,String overview,String poster,long startTime,long endTime){
  clearVariables();
  this.type=Type.MOVIE;
  this.movieId=movieId;
  this.movieTitle=movieTitle;
  this.movieOverview=overview;
  this.poster=poster;
  this.startTime=startTime;
  this.endTime=endTime;
  posterView.setImage(poster);
  titleView.setText(movieTitle);
  subtitleView.setVisibility(GONE);
  animateIn();
}","public void watchingMovie(long movieId,String movieTitle,String overview,String poster,long startTime,long endTime){
  if (type != Type.MOVIE || movieId != this.movieId) {
    clearVariables();
    this.type=Type.MOVIE;
    this.movieId=movieId;
  }
  this.movieTitle=movieTitle;
  this.movieOverview=overview;
  this.poster=poster;
  this.startTime=startTime;
  this.endTime=endTime;
  posterView.setImage(poster);
  titleView.setText(movieTitle);
  subtitleView.setVisibility(GONE);
  progress.setMax((int)(endTime - startTime));
  progress.setProgress((int)(System.currentTimeMillis() - startTime));
  animateIn();
}",0.7298578199052133
56425,"public void watchingShow(long showId,String showTitle,long episodeId,String episodeTitle,String poster,long startTime,long endTime){
  clearVariables();
  this.type=Type.SHOW;
  this.showId=showId;
  this.showTitle=showTitle;
  this.episodeId=episodeId;
  this.episodeTitle=episodeTitle;
  this.poster=poster;
  this.startTime=startTime;
  this.endTime=endTime;
  posterView.setImage(poster);
  titleView.setText(showTitle);
  subtitleView.setVisibility(VISIBLE);
  subtitleView.setText(episodeTitle);
  progress.setMax((int)(endTime - startTime));
  progress.setProgress((int)(System.currentTimeMillis() - startTime));
  animateIn();
}","public void watchingShow(long showId,String showTitle,long episodeId,String episodeTitle,String poster,long startTime,long endTime){
  if (type != Type.SHOW || showId != this.showId) {
    clearVariables();
    this.type=Type.SHOW;
    this.showId=showId;
  }
  this.showTitle=showTitle;
  this.episodeId=episodeId;
  this.episodeTitle=episodeTitle;
  this.poster=poster;
  this.startTime=startTime;
  this.endTime=endTime;
  posterView.setImage(poster);
  titleView.setText(showTitle);
  subtitleView.setVisibility(VISIBLE);
  subtitleView.setText(episodeTitle);
  progress.setMax((int)(endTime - startTime));
  progress.setProgress((int)(System.currentTimeMillis() - startTime));
  animateIn();
}",0.8800599700149925
56426,"private void updateRelatedView(Cursor related){
  relatedContainer.removeAllViews();
  final int count=related.getCount();
  final int visibility=count > 0 ? View.VISIBLE : View.GONE;
  relatedParent.setVisibility(visibility);
  int index=0;
  related.moveToPosition(-1);
  while (related.moveToNext() && index < 3) {
    View v=LayoutInflater.from(getActivity()).inflate(R.layout.item_related,relatedContainer,false);
    final long relatedMovieId=Cursors.getLong(related,RelatedMoviesColumns.RELATED_MOVIE_ID);
    final String title=Cursors.getString(related,MovieColumns.TITLE);
    final String overview=Cursors.getString(related,MovieColumns.OVERVIEW);
    final int rating=Cursors.getInt(related,MovieColumns.RATING);
    final int votes=Cursors.getInt(related,MovieColumns.VOTES);
    final String poster=ImageUri.create(ImageUri.ITEM_MOVIE,ImageType.POSTER,relatedMovieId);
    RemoteImageView posterView=(RemoteImageView)v.findViewById(R.id.related_poster);
    posterView.addTransformation(new CircleTransformation());
    posterView.setImage(poster);
    TextView titleView=(TextView)v.findViewById(R.id.related_title);
    titleView.setText(title);
    float convertedRating=rating / 10.0f;
    final String formattedRating=String.format(Locale.getDefault(),""String_Node_Str"",convertedRating);
    String ratingText;
    if (votes >= 1000) {
      final float convertedVotes=votes / 1000.0f;
      final String formattedVotes=String.format(Locale.getDefault(),""String_Node_Str"",convertedVotes);
      ratingText=getString(R.string.related_rating_thousands,formattedRating,formattedVotes);
    }
 else {
      ratingText=getString(R.string.related_rating,formattedRating,votes);
    }
    TextView ratingView=(TextView)v.findViewById(R.id.related_rating);
    ratingView.setText(ratingText);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        navigationListener.onDisplayMovie(relatedMovieId,title,overview);
      }
    }
);
    relatedContainer.addView(v);
    index++;
  }
}","private void updateRelatedView(Cursor related){
  relatedContainer.removeAllViews();
  final int count=related.getCount();
  final int visibility=count > 0 ? View.VISIBLE : View.GONE;
  relatedParent.setVisibility(visibility);
  int index=0;
  related.moveToPosition(-1);
  while (related.moveToNext() && index < 3) {
    View v=LayoutInflater.from(getActivity()).inflate(R.layout.item_related,relatedContainer,false);
    final long relatedMovieId=Cursors.getLong(related,RelatedMoviesColumns.RELATED_MOVIE_ID);
    final String title=Cursors.getString(related,MovieColumns.TITLE);
    final String overview=Cursors.getString(related,MovieColumns.OVERVIEW);
    final float rating=Cursors.getFloat(related,MovieColumns.RATING);
    final int votes=Cursors.getInt(related,MovieColumns.VOTES);
    final String poster=ImageUri.create(ImageUri.ITEM_MOVIE,ImageType.POSTER,relatedMovieId);
    RemoteImageView posterView=(RemoteImageView)v.findViewById(R.id.related_poster);
    posterView.addTransformation(new CircleTransformation());
    posterView.setImage(poster);
    TextView titleView=(TextView)v.findViewById(R.id.related_title);
    titleView.setText(title);
    final String formattedRating=String.format(Locale.getDefault(),""String_Node_Str"",rating);
    String ratingText;
    if (votes >= 1000) {
      final float convertedVotes=votes / 1000.0f;
      final String formattedVotes=String.format(Locale.getDefault(),""String_Node_Str"",convertedVotes);
      ratingText=getString(R.string.related_rating_thousands,formattedRating,formattedVotes);
    }
 else {
      ratingText=getString(R.string.related_rating,formattedRating,votes);
    }
    TextView ratingView=(TextView)v.findViewById(R.id.related_rating);
    ratingView.setText(ratingText);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        navigationListener.onDisplayMovie(relatedMovieId,title,overview);
      }
    }
);
    relatedContainer.addView(v);
    index++;
  }
}",0.9839624969158648
56427,"private void updateRelatedView(Cursor related){
  relatedContainer.removeAllViews();
  final int count=related.getCount();
  final int visibility=count > 0 ? View.VISIBLE : View.GONE;
  relatedParent.setVisibility(visibility);
  int index=0;
  related.moveToPosition(-1);
  while (related.moveToNext() && index < 3) {
    View v=LayoutInflater.from(getActivity()).inflate(R.layout.item_related,this.relatedContainer,false);
    final long relatedShowId=Cursors.getLong(related,RelatedShowsColumns.RELATED_SHOW_ID);
    final String title=Cursors.getString(related,ShowColumns.TITLE);
    final String overview=Cursors.getString(related,ShowColumns.OVERVIEW);
    final int rating=Cursors.getInt(related,ShowColumns.RATING);
    final int votes=Cursors.getInt(related,ShowColumns.VOTES);
    final String poster=ImageUri.create(ImageUri.ITEM_SHOW,ImageType.POSTER,relatedShowId);
    RemoteImageView posterView=(RemoteImageView)v.findViewById(R.id.related_poster);
    posterView.addTransformation(new CircleTransformation());
    posterView.setImage(poster);
    TextView titleView=(TextView)v.findViewById(R.id.related_title);
    titleView.setText(title);
    float convertedRating=rating / 10.0f;
    final String formattedRating=String.format(Locale.getDefault(),""String_Node_Str"",convertedRating);
    String ratingText;
    if (votes >= 1000) {
      final float convertedVotes=votes / 1000.0f;
      final String formattedVotes=String.format(Locale.getDefault(),""String_Node_Str"",convertedVotes);
      ratingText=getString(R.string.related_rating_thousands,formattedRating,formattedVotes);
    }
 else {
      ratingText=getString(R.string.related_rating,formattedRating,votes);
    }
    TextView ratingView=(TextView)v.findViewById(R.id.related_rating);
    ratingView.setText(ratingText);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        navigationListener.onDisplayShow(relatedShowId,title,overview,LibraryType.WATCHED);
      }
    }
);
    relatedContainer.addView(v);
    index++;
  }
}","private void updateRelatedView(Cursor related){
  relatedContainer.removeAllViews();
  final int count=related.getCount();
  final int visibility=count > 0 ? View.VISIBLE : View.GONE;
  relatedParent.setVisibility(visibility);
  int index=0;
  related.moveToPosition(-1);
  while (related.moveToNext() && index < 3) {
    View v=LayoutInflater.from(getActivity()).inflate(R.layout.item_related,this.relatedContainer,false);
    final long relatedShowId=Cursors.getLong(related,RelatedShowsColumns.RELATED_SHOW_ID);
    final String title=Cursors.getString(related,ShowColumns.TITLE);
    final String overview=Cursors.getString(related,ShowColumns.OVERVIEW);
    final float rating=Cursors.getFloat(related,ShowColumns.RATING);
    final int votes=Cursors.getInt(related,ShowColumns.VOTES);
    final String poster=ImageUri.create(ImageUri.ITEM_SHOW,ImageType.POSTER,relatedShowId);
    RemoteImageView posterView=(RemoteImageView)v.findViewById(R.id.related_poster);
    posterView.addTransformation(new CircleTransformation());
    posterView.setImage(poster);
    TextView titleView=(TextView)v.findViewById(R.id.related_title);
    titleView.setText(title);
    final String formattedRating=String.format(Locale.getDefault(),""String_Node_Str"",rating);
    String ratingText;
    if (votes >= 1000) {
      final float convertedVotes=votes / 1000.0f;
      final String formattedVotes=String.format(Locale.getDefault(),""String_Node_Str"",convertedVotes);
      ratingText=getString(R.string.related_rating_thousands,formattedRating,formattedVotes);
    }
 else {
      ratingText=getString(R.string.related_rating,formattedRating,votes);
    }
    TextView ratingView=(TextView)v.findViewById(R.id.related_rating);
    ratingView.setText(ratingText);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        navigationListener.onDisplayShow(relatedShowId,title,overview,LibraryType.WATCHED);
      }
    }
);
    relatedContainer.addView(v);
    index++;
  }
}",0.9840725312423426
56428,"@Override public void handleResponse(SyncResponse response){
  movieHelper.setIsInWatchlist(traktId,inWatchlist,TimeUtils.getMillis(listedAt));
}","@Override public void handleResponse(SyncResponse response){
  queue(new SyncMoviesWatchlist());
}",0.6831275720164609
56429,"@Override public void handleResponse(SyncResponse response){
  episodeHelper.setIsInWatchlist(traktId,season,episode,inWatchlist,TimeUtils.getMillis(listedAt));
}","@Override public void handleResponse(SyncResponse response){
  queue(new SyncEpisodeWatchlist());
}",0.6513409961685823
56430,"@Override public void handleResponse(SyncResponse response){
}","@Override public void handleResponse(SyncResponse response){
  queue(new SyncShowsWatchlist());
}",0.779874213836478
56431,"private void scheduleAlarm(){
  Intent intent=new Intent(AuthJobService.this,AuthJobReceiver.class);
  final int retryDelay=Math.max(1,this.retryDelay);
  final int nextDelay=Math.min(retryDelay * 2,MAX_RETRY_DELAY);
  intent.putExtra(RETRY_DELAY,nextDelay);
  PendingIntent pi=PendingIntent.getBroadcast(AuthJobService.this,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  AlarmManager am=(AlarmManager)getSystemService(Context.ALARM_SERVICE);
  final long runAt=SystemClock.elapsedRealtime() + retryDelay * DateUtils.MINUTE_IN_MILLIS;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && retryDelay < 10) {
    am.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,runAt,pi);
  }
 else {
    am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,runAt,pi);
  }
  Timber.d(""String_Node_Str"",retryDelay);
}","private void scheduleAlarm(){
  Intent intent=new Intent(AuthJobService.this,AuthJobReceiver.class);
  final int retryDelay=Math.max(1,this.retryDelay);
  final int nextDelay=Math.min(retryDelay * 2,MAX_RETRY_DELAY);
  intent.putExtra(RETRY_DELAY,nextDelay);
  PendingIntent pi=PendingIntent.getBroadcast(AuthJobService.this,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AlarmManager am=(AlarmManager)getSystemService(Context.ALARM_SERVICE);
  am.cancel(pi);
  final long runAt=SystemClock.elapsedRealtime() + retryDelay * DateUtils.MINUTE_IN_MILLIS;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && retryDelay < 10) {
    am.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,runAt,pi);
  }
 else {
    am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,runAt,pi);
  }
  Timber.d(""String_Node_Str"",retryDelay);
}",0.9819987585350712
56432,"private void scheduleAlarm(){
  Intent intent=new Intent(JobService.this,JobReceiver.class);
  final int retryDelay=Math.max(1,this.retryDelay);
  final int nextDelay=Math.min(retryDelay * 2,MAX_RETRY_DELAY);
  intent.putExtra(RETRY_DELAY,nextDelay);
  PendingIntent pi=PendingIntent.getBroadcast(JobService.this,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  AlarmManager am=(AlarmManager)getSystemService(Context.ALARM_SERVICE);
  final long runAt=SystemClock.elapsedRealtime() + retryDelay * DateUtils.MINUTE_IN_MILLIS;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && retryDelay < 10) {
    am.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,runAt,pi);
  }
 else {
    am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,runAt,pi);
  }
  Timber.d(""String_Node_Str"",retryDelay);
}","private void scheduleAlarm(){
  Intent intent=new Intent(JobService.this,JobReceiver.class);
  final int retryDelay=Math.max(1,this.retryDelay);
  final int nextDelay=Math.min(retryDelay * 2,MAX_RETRY_DELAY);
  intent.putExtra(RETRY_DELAY,nextDelay);
  PendingIntent pi=PendingIntent.getBroadcast(JobService.this,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AlarmManager am=(AlarmManager)getSystemService(Context.ALARM_SERVICE);
  am.cancel(pi);
  final long runAt=SystemClock.elapsedRealtime() + retryDelay * DateUtils.MINUTE_IN_MILLIS;
  am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,runAt,pi);
  Timber.d(""String_Node_Str"",retryDelay);
}",0.8028070175438596
56433,"@OnUpgrade public static void onUpgrade(Context context,SQLiteDatabase db,int oldVersion,int newVersion){
  if (oldVersion < 12) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    CathodeDatabase.getInstance(context).onCreate(db);
  }
  if (oldVersion < 13) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SEASONS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SHOW_CHARACTERS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CAST,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CREW,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    db.execSQL(TRIGGER_SHOW_UPDATE);
    db.execSQL(TRIGGER_SEASON_UPDATE);
    db.execSQL(TRIGGER_EPISODE_UPDATE);
    db.execSQL(TRIGGER_MOVIES_UPDATE);
    db.execSQL(TRIGGER_PEOPLE_UPDATE);
  }
  if (oldVersion < 14) {
    db.execSQL(CathodeDatabase.LISTS);
    db.execSQL(CathodeDatabase.LIST_ITEMS);
    db.execSQL(TRIGGER_LIST_DELETE);
    db.execSQL(TRIGGER_LIST_UPDATE);
    db.execSQL(TRIGGER_LISTITEM_UPDATE);
  }
  if (oldVersion < 15) {
    db.execSQL(INDEX_SEASON_SHOW_ID);
    db.execSQL(INDEX_CHARACTERS_SHOW_ID);
    db.execSQL(INDEX_GENRE_SHOW_ID);
    db.execSQL(INDEX_CAST_MOVIE_ID);
    db.execSQL(INDEX_CREW_MOVIE_ID);
    db.execSQL(INDEX_GENRE_MOVIE_ID);
  }
  if (oldVersion < 16) {
    Set<String> showColumns=SqlUtils.columns(db,Tables.SHOWS);
    if (!showColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
    Set<String> seasonColumns=SqlUtils.columns(db,Tables.SEASONS);
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
    Set<String> movieColumns=SqlUtils.columns(db,Tables.MOVIES);
    if (!movieColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 17) {
    db.execSQL(INDEX_EPISODES_SHOW_ID);
    db.execSQL(INDEX_EPISODES_SEASON_ID);
  }
  if (oldVersion < 18) {
    db.execSQL(CathodeDatabase.COMMENTS);
    db.execSQL(CathodeDatabase.USERS);
    db.execSQL(""String_Node_Str"" + TriggerName.SHOW_DELETE);
    db.execSQL(""String_Node_Str"" + TriggerName.MOVIE_DELETE);
    db.execSQL(TRIGGER_SHOW_DELETE);
    db.execSQL(TRIGGER_MOVIE_DELETE);
    db.execSQL(TRIGGER_COMMENT_UPDATE);
    db.execSQL(TRIGGER_EPISODE_DELETE);
  }
  if (oldVersion < 19) {
    Set<String> showColumns=SqlUtils.columns(db,Tables.SHOWS);
    if (!showColumns.contains(ShowColumns.LAST_COMMENT_SYNC)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ ShowColumns.LAST_COMMENT_SYNC+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 20) {
    Set<String> movieColumns=SqlUtils.columns(db,Tables.MOVIES);
    if (!movieColumns.contains(MovieColumns.LAST_COMMENT_SYNC)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ MovieColumns.LAST_COMMENT_SYNC+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 21) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_ACTORS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_CREW_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    final long currentTime=System.currentTimeMillis();
    ContentValues values=new ContentValues();
    values.put(ShowColumns.LAST_SYNC,currentTime);
    values.put(ShowColumns.LAST_ACTORS_SYNC,currentTime);
    db.update(Tables.SHOWS,values,null,null);
    values=new ContentValues();
    values.put(MovieColumns.LAST_SYNC,currentTime);
    values.put(MovieColumns.LAST_CREW_SYNC,currentTime);
    db.update(Tables.MOVIES,values,null,null);
  }
  if (oldVersion < 22) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.ANTICIPATED_INDEX,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.ANTICIPATED_INDEX,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 23) {
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,EpisodeColumns.LAST_COMMENT_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
}","@OnUpgrade public static void onUpgrade(Context context,SQLiteDatabase db,int oldVersion,int newVersion){
  if (oldVersion < 12) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    CathodeDatabase.getInstance(context).onCreate(db);
  }
  if (oldVersion < 13) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SEASONS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SHOW_CHARACTERS,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CAST,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIE_CREW,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.PEOPLE,LastModifiedColumns.LAST_MODIFIED,DataType.Type.INTEGER,""String_Node_Str"");
    db.execSQL(TRIGGER_SHOW_UPDATE);
    db.execSQL(TRIGGER_SEASON_UPDATE);
    db.execSQL(TRIGGER_EPISODE_UPDATE);
    db.execSQL(TRIGGER_MOVIES_UPDATE);
    db.execSQL(TRIGGER_PEOPLE_UPDATE);
  }
  if (oldVersion < 14) {
    db.execSQL(CathodeDatabase.LISTS);
    db.execSQL(CathodeDatabase.LIST_ITEMS);
    db.execSQL(TRIGGER_LIST_DELETE);
    db.execSQL(TRIGGER_LIST_UPDATE);
    db.execSQL(TRIGGER_LISTITEM_UPDATE);
  }
  if (oldVersion < 15) {
    db.execSQL(INDEX_SEASON_SHOW_ID);
    db.execSQL(INDEX_CHARACTERS_SHOW_ID);
    db.execSQL(INDEX_GENRE_SHOW_ID);
    db.execSQL(INDEX_CAST_MOVIE_ID);
    db.execSQL(INDEX_CREW_MOVIE_ID);
    db.execSQL(INDEX_GENRE_MOVIE_ID);
  }
  if (oldVersion < 16) {
    Set<String> showColumns=SqlUtils.columns(db,Tables.SHOWS);
    if (!showColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!showColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
    Set<String> seasonColumns=SqlUtils.columns(db,Tables.SEASONS);
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!seasonColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.SEASONS + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
    Set<String> movieColumns=SqlUtils.columns(db,Tables.MOVIES);
    if (!movieColumns.contains(HiddenColumns.HIDDEN_CALENDAR)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_CALENDAR+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_COLLECTED)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_COLLECTED+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_WATCHED)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_WATCHED+ ""String_Node_Str"");
    }
    if (!movieColumns.contains(HiddenColumns.HIDDEN_RECOMMENDATIONS)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ HiddenColumns.HIDDEN_RECOMMENDATIONS+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 17) {
    db.execSQL(INDEX_EPISODES_SHOW_ID);
    db.execSQL(INDEX_EPISODES_SEASON_ID);
  }
  if (oldVersion < 18) {
    db.execSQL(CathodeDatabase.COMMENTS);
    db.execSQL(CathodeDatabase.USERS);
    db.execSQL(""String_Node_Str"" + TriggerName.SHOW_DELETE);
    db.execSQL(""String_Node_Str"" + TriggerName.MOVIE_DELETE);
    db.execSQL(TRIGGER_SHOW_DELETE);
    db.execSQL(TRIGGER_MOVIE_DELETE);
    db.execSQL(TRIGGER_COMMENT_UPDATE);
    db.execSQL(TRIGGER_EPISODE_DELETE);
  }
  if (oldVersion < 19) {
    Set<String> showColumns=SqlUtils.columns(db,Tables.SHOWS);
    if (!showColumns.contains(ShowColumns.LAST_COMMENT_SYNC)) {
      db.execSQL(""String_Node_Str"" + Tables.SHOWS + ""String_Node_Str""+ ShowColumns.LAST_COMMENT_SYNC+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 20) {
    Set<String> movieColumns=SqlUtils.columns(db,Tables.MOVIES);
    if (!movieColumns.contains(MovieColumns.LAST_COMMENT_SYNC)) {
      db.execSQL(""String_Node_Str"" + Tables.MOVIES + ""String_Node_Str""+ MovieColumns.LAST_COMMENT_SYNC+ ""String_Node_Str"");
    }
  }
  if (oldVersion < 21) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.LAST_ACTORS_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.LAST_CREW_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
    final long currentTime=System.currentTimeMillis();
    ContentValues values=new ContentValues();
    values.put(ShowColumns.LAST_SYNC,currentTime);
    values.put(ShowColumns.LAST_ACTORS_SYNC,currentTime);
    db.update(Tables.SHOWS,values,null,null);
    values=new ContentValues();
    values.put(MovieColumns.LAST_SYNC,currentTime);
    values.put(MovieColumns.LAST_CREW_SYNC,currentTime);
    db.update(Tables.MOVIES,values,null,null);
  }
  if (oldVersion < 22) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.ANTICIPATED_INDEX,DataType.Type.INTEGER,""String_Node_Str"");
    SqlUtils.createColumnIfNotExists(db,Tables.MOVIES,MovieColumns.ANTICIPATED_INDEX,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 23) {
    SqlUtils.createColumnIfNotExists(db,Tables.EPISODES,EpisodeColumns.LAST_COMMENT_SYNC,DataType.Type.INTEGER,""String_Node_Str"");
  }
  if (oldVersion < 24) {
    SqlUtils.createColumnIfNotExists(db,Tables.SHOWS,ShowColumns.WATCHING,DataType.Type.INTEGER,""String_Node_Str"");
    db.execSQL(TRIGGER_EPISODE_UPDATE_WATCHING);
  }
}",0.9875959079283888
56434,"@Override public void perform(){
  if (true) {
    return;
  }
  String showsWhere=ShowColumns.WATCHED_COUNT + ""String_Node_Str"" + ShowColumns.IN_COLLECTION_COUNT+ ""String_Node_Str""+ ShowColumns.IN_WATCHLIST_COUNT+ ""String_Node_Str""+ ShowColumns.IN_WATCHLIST+ ""String_Node_Str""+ Shows.getWatchingQuery()+ ""String_Node_Str""+ ShowColumns.RECOMMENDATION_INDEX+ ""String_Node_Str""+ ShowColumns.TRENDING_INDEX+ ""String_Node_Str"";
  Cursor shows=getContentResolver().query(Shows.SHOWS,new String[]{ShowColumns.ID,ShowColumns.TITLE},showsWhere,null,null);
  List<Long> showIds=new ArrayList<>();
  while (shows.moveToNext()) {
    final long id=Cursors.getLong(shows,ShowColumns.ID);
    final String title=Cursors.getString(shows,ShowColumns.TITLE);
    Timber.d(""String_Node_Str"",title);
    showIds.add(id);
  }
  shows.close();
  List<Long> showSearchIds=showSearchHandler.getResultIds();
  if (showSearchIds != null) {
    for (    Long id : showSearchIds) {
      showIds.remove(id);
    }
  }
  ArrayList<ContentProviderOperation> ops=new ArrayList<>();
  for (  Long id : showIds) {
    ContentProviderOperation op=ContentProviderOperation.newDelete(Shows.withId(id)).build();
    ops.add(op);
  }
  try {
    getContentResolver().applyBatch(BuildConfig.PROVIDER_AUTHORITY,ops);
  }
 catch (  RemoteException e) {
    Timber.e(e,""String_Node_Str"");
    throw new JobFailedException(e);
  }
catch (  OperationApplicationException e) {
    Timber.e(e,""String_Node_Str"");
    throw new JobFailedException(e);
  }
  String moviesWhere=MovieColumns.WATCHED + ""String_Node_Str"" + MovieColumns.IN_COLLECTION+ ""String_Node_Str""+ MovieColumns.IN_WATCHLIST+ ""String_Node_Str""+ MovieColumns.WATCHING+ ""String_Node_Str""+ MovieColumns.RECOMMENDATION_INDEX+ ""String_Node_Str""+ MovieColumns.TRENDING_INDEX+ ""String_Node_Str"";
  Cursor movies=getContentResolver().query(Movies.MOVIES,new String[]{MovieColumns.ID,MovieColumns.TITLE},moviesWhere,null,null);
  List<Long> movieIds=new ArrayList<>();
  while (movies.moveToNext()) {
    final long id=Cursors.getLong(movies,MovieColumns.ID);
    final String title=Cursors.getString(movies,MovieColumns.TITLE);
    Timber.d(""String_Node_Str"",title);
    movieIds.add(id);
  }
  movies.close();
  List<Long> movieSearchIds=movieSearchHandler.getResultIds();
  if (movieSearchIds != null) {
    for (    Long id : movieSearchIds) {
      movieIds.remove(id);
    }
  }
  ops=new ArrayList<>();
  for (  Long id : movieIds) {
    ContentProviderOperation op=ContentProviderOperation.newDelete(Movies.withId(id)).build();
    ops.add(op);
  }
  try {
    getContentResolver().applyBatch(BuildConfig.PROVIDER_AUTHORITY,ops);
  }
 catch (  RemoteException e) {
    Timber.e(e,""String_Node_Str"");
    throw new JobFailedException(e);
  }
catch (  OperationApplicationException e) {
    Timber.e(e,""String_Node_Str"");
    throw new JobFailedException(e);
  }
}","@Override public void perform(){
  if (true) {
    return;
  }
  String showsWhere=ShowColumns.WATCHED_COUNT + ""String_Node_Str"" + ShowColumns.IN_COLLECTION_COUNT+ ""String_Node_Str""+ ShowColumns.IN_WATCHLIST_COUNT+ ""String_Node_Str""+ ShowColumns.IN_WATCHLIST+ ""String_Node_Str""+ ShowColumns.WATCHING+ ""String_Node_Str""+ ShowColumns.RECOMMENDATION_INDEX+ ""String_Node_Str""+ ShowColumns.TRENDING_INDEX+ ""String_Node_Str"";
  Cursor shows=getContentResolver().query(Shows.SHOWS,new String[]{ShowColumns.ID,ShowColumns.TITLE},showsWhere,null,null);
  List<Long> showIds=new ArrayList<>();
  while (shows.moveToNext()) {
    final long id=Cursors.getLong(shows,ShowColumns.ID);
    final String title=Cursors.getString(shows,ShowColumns.TITLE);
    Timber.d(""String_Node_Str"",title);
    showIds.add(id);
  }
  shows.close();
  List<Long> showSearchIds=showSearchHandler.getResultIds();
  if (showSearchIds != null) {
    for (    Long id : showSearchIds) {
      showIds.remove(id);
    }
  }
  ArrayList<ContentProviderOperation> ops=new ArrayList<>();
  for (  Long id : showIds) {
    ContentProviderOperation op=ContentProviderOperation.newDelete(Shows.withId(id)).build();
    ops.add(op);
  }
  try {
    getContentResolver().applyBatch(BuildConfig.PROVIDER_AUTHORITY,ops);
  }
 catch (  RemoteException e) {
    Timber.e(e,""String_Node_Str"");
    throw new JobFailedException(e);
  }
catch (  OperationApplicationException e) {
    Timber.e(e,""String_Node_Str"");
    throw new JobFailedException(e);
  }
  String moviesWhere=MovieColumns.WATCHED + ""String_Node_Str"" + MovieColumns.IN_COLLECTION+ ""String_Node_Str""+ MovieColumns.IN_WATCHLIST+ ""String_Node_Str""+ MovieColumns.WATCHING+ ""String_Node_Str""+ MovieColumns.RECOMMENDATION_INDEX+ ""String_Node_Str""+ MovieColumns.TRENDING_INDEX+ ""String_Node_Str"";
  Cursor movies=getContentResolver().query(Movies.MOVIES,new String[]{MovieColumns.ID,MovieColumns.TITLE},moviesWhere,null,null);
  List<Long> movieIds=new ArrayList<>();
  while (movies.moveToNext()) {
    final long id=Cursors.getLong(movies,MovieColumns.ID);
    final String title=Cursors.getString(movies,MovieColumns.TITLE);
    Timber.d(""String_Node_Str"",title);
    movieIds.add(id);
  }
  movies.close();
  List<Long> movieSearchIds=movieSearchHandler.getResultIds();
  if (movieSearchIds != null) {
    for (    Long id : movieSearchIds) {
      movieIds.remove(id);
    }
  }
  ops=new ArrayList<>();
  for (  Long id : movieIds) {
    ContentProviderOperation op=ContentProviderOperation.newDelete(Movies.withId(id)).build();
    ops.add(op);
  }
  try {
    getContentResolver().applyBatch(BuildConfig.PROVIDER_AUTHORITY,ops);
  }
 catch (  RemoteException e) {
    Timber.e(e,""String_Node_Str"");
    throw new JobFailedException(e);
  }
catch (  OperationApplicationException e) {
    Timber.e(e,""String_Node_Str"");
    throw new JobFailedException(e);
  }
}",0.9940992710864284
56435,"private void upgrade(){
  final int currentVersion=settings.getInt(Settings.VERSION_CODE,-1);
  if (currentVersion == -1) {
    settings.edit().putInt(Settings.VERSION_CODE,BuildConfig.VERSION_CODE).apply();
    return;
  }
  if (currentVersion != BuildConfig.VERSION_CODE) {
    if (currentVersion < 20002) {
      Accounts.removeAccount(this);
      settings.edit().clear().apply();
    }
    if (currentVersion < 20501) {
      TraktTimestamps.clear(this);
    }
    if (currentVersion < 21001) {
      MainHandler.post(new Runnable(){
        @Override public void run(){
          jobManager.addJob(new ForceUpdateJob());
        }
      }
);
    }
    if (currentVersion <= 21001) {
      MainHandler.post(new Runnable(){
        @Override public void run(){
          jobManager.addJob(new UpdateShowCounts());
        }
      }
);
    }
    if (currentVersion <= 31001) {
      Account account=Accounts.getAccount(this);
      if (account != null) {
        ContentResolver.setIsSyncable(account,BuildConfig.AUTHORITY_DUMMY_CALENDAR,1);
        ContentResolver.setSyncAutomatically(account,BuildConfig.AUTHORITY_DUMMY_CALENDAR,true);
        ContentResolver.addPeriodicSync(account,BuildConfig.AUTHORITY_DUMMY_CALENDAR,new Bundle(),12 * DateUtils.HOUR_IN_SECONDS);
      }
      Accounts.requestCalendarSync(this);
    }
    if (currentVersion <= 31003) {
      settings.edit().remove(""String_Node_Str"").apply();
    }
    if (currentVersion <= 37000) {
      settings.edit().remove(Settings.START_PAGE).apply();
    }
    if (currentVersion <= 39003) {
      MainHandler.post(new Runnable(){
        @Override public void run(){
          jobManager.addJob(new SyncAnticipatedShows());
          jobManager.addJob(new SyncAnticipatedMovies());
        }
      }
);
    }
    MainHandler.post(new Runnable(){
      @Override public void run(){
        jobManager.addJob(new SyncJob());
      }
    }
);
    settings.edit().putInt(Settings.VERSION_CODE,BuildConfig.VERSION_CODE).apply();
  }
}","private void upgrade(){
  final int currentVersion=settings.getInt(Settings.VERSION_CODE,-1);
  if (currentVersion == -1) {
    settings.edit().putInt(Settings.VERSION_CODE,BuildConfig.VERSION_CODE).apply();
    return;
  }
  if (currentVersion != BuildConfig.VERSION_CODE) {
    if (currentVersion < 20002) {
      Accounts.removeAccount(this);
      settings.edit().clear().apply();
    }
    if (currentVersion < 20501) {
      TraktTimestamps.clear(this);
    }
    if (currentVersion < 21001) {
      MainHandler.post(new Runnable(){
        @Override public void run(){
          jobManager.addJob(new ForceUpdateJob());
        }
      }
);
    }
    if (currentVersion <= 21001) {
      MainHandler.post(new Runnable(){
        @Override public void run(){
          jobManager.addJob(new UpdateShowCounts());
        }
      }
);
    }
    if (currentVersion <= 31001) {
      Account account=Accounts.getAccount(this);
      if (account != null) {
        ContentResolver.setIsSyncable(account,BuildConfig.AUTHORITY_DUMMY_CALENDAR,1);
        ContentResolver.setSyncAutomatically(account,BuildConfig.AUTHORITY_DUMMY_CALENDAR,true);
        ContentResolver.addPeriodicSync(account,BuildConfig.AUTHORITY_DUMMY_CALENDAR,new Bundle(),12 * DateUtils.HOUR_IN_SECONDS);
      }
      Accounts.requestCalendarSync(this);
    }
    if (currentVersion <= 31003) {
      settings.edit().remove(""String_Node_Str"").apply();
    }
    if (currentVersion <= 37000) {
      settings.edit().remove(Settings.START_PAGE).apply();
    }
    if (currentVersion <= 39003) {
      MainHandler.post(new Runnable(){
        @Override public void run(){
          jobManager.addJob(new SyncAnticipatedShows());
          jobManager.addJob(new SyncAnticipatedMovies());
        }
      }
);
    }
    if (currentVersion <= 40102) {
      MainHandler.post(new Runnable(){
        @Override public void run(){
          jobManager.addJob(new EnsureSync());
        }
      }
);
    }
    MainHandler.post(new Runnable(){
      @Override public void run(){
        jobManager.addJob(new SyncJob());
      }
    }
);
    settings.edit().putInt(Settings.VERSION_CODE,BuildConfig.VERSION_CODE).apply();
  }
}",0.955794504181601
56436,"public boolean shouldUpdate(long traktId,String lastUpdated){
  if (lastUpdated == null)   return true;
  Cursor movie=null;
  try {
    movie=resolver.query(Movies.MOVIES,new String[]{MovieColumns.LAST_UPDATED,MovieColumns.WATCHED,MovieColumns.IN_COLLECTION,MovieColumns.IN_WATCHLIST},MovieColumns.TRAKT_ID + ""String_Node_Str"",new String[]{String.valueOf(traktId)},null);
    if (movie.moveToFirst()) {
      final boolean watched=Cursors.getBoolean(movie,MovieColumns.WATCHED);
      final boolean collected=Cursors.getBoolean(movie,MovieColumns.IN_COLLECTION);
      final boolean inWatchlist=Cursors.getBoolean(movie,MovieColumns.IN_WATCHLIST);
      final boolean isUpdated=TimeUtils.getMillis(lastUpdated) > Cursors.getLong(movie,MovieColumns.LAST_UPDATED);
      if (isUpdated) {
        if (watched || collected || inWatchlist) {
          return true;
        }
      }
    }
    return false;
  }
  finally {
    if (movie != null)     movie.close();
  }
}","public boolean shouldUpdate(long traktId,String lastUpdated){
  if (lastUpdated == null)   return true;
  Cursor movie=null;
  try {
    movie=resolver.query(Movies.MOVIES,new String[]{MovieColumns.WATCHED,MovieColumns.IN_COLLECTION,MovieColumns.IN_WATCHLIST},MovieColumns.TRAKT_ID + ""String_Node_Str"",new String[]{String.valueOf(traktId)},null);
    if (movie.moveToFirst()) {
      final boolean watched=Cursors.getBoolean(movie,MovieColumns.WATCHED);
      final boolean collected=Cursors.getBoolean(movie,MovieColumns.IN_COLLECTION);
      final boolean inWatchlist=Cursors.getBoolean(movie,MovieColumns.IN_WATCHLIST);
      if (watched || collected || inWatchlist) {
        return true;
      }
    }
    return false;
  }
  finally {
    if (movie != null)     movie.close();
  }
}",0.8848346636259977
56437,"public boolean shouldUpdate(long traktId,String lastUpdatedIso){
  long lastUpdated=TimeUtils.getMillis(lastUpdatedIso);
  Cursor show=null;
  try {
    show=resolver.query(Shows.SHOWS,new String[]{ShowColumns.LAST_UPDATED,ShowColumns.WATCHED_COUNT,ShowColumns.IN_COLLECTION_COUNT,ShowColumns.IN_WATCHLIST_COUNT,ShowColumns.IN_COLLECTION_COUNT,ShowColumns.IN_WATCHLIST},ShowColumns.TRAKT_ID + ""String_Node_Str"",new String[]{String.valueOf(traktId)},null);
    if (show.moveToFirst()) {
      final int watchedCount=Cursors.getInt(show,ShowColumns.WATCHED_COUNT);
      final int collectedCount=Cursors.getInt(show,ShowColumns.IN_COLLECTION_COUNT);
      final int watchlistCount=Cursors.getInt(show,ShowColumns.IN_WATCHLIST_COUNT);
      final boolean inWatchlist=Cursors.getBoolean(show,ShowColumns.IN_WATCHLIST);
      final boolean isUpdated=lastUpdated > Cursors.getLong(show,ShowColumns.LAST_UPDATED);
      if (isUpdated) {
        if (watchedCount > 0 || collectedCount > 0 || watchlistCount > 0 || inWatchlist) {
          return true;
        }
      }
    }
    return false;
  }
  finally {
    if (show != null)     show.close();
  }
}","public boolean shouldUpdate(long traktId){
  Cursor show=null;
  try {
    show=resolver.query(Shows.SHOWS,new String[]{ShowColumns.WATCHED_COUNT,ShowColumns.IN_COLLECTION_COUNT,ShowColumns.IN_WATCHLIST_COUNT,ShowColumns.IN_COLLECTION_COUNT,ShowColumns.IN_WATCHLIST},ShowColumns.TRAKT_ID + ""String_Node_Str"",new String[]{String.valueOf(traktId)},null);
    if (show.moveToFirst()) {
      final int watchedCount=Cursors.getInt(show,ShowColumns.WATCHED_COUNT);
      final int collectedCount=Cursors.getInt(show,ShowColumns.IN_COLLECTION_COUNT);
      final int watchlistCount=Cursors.getInt(show,ShowColumns.IN_WATCHLIST_COUNT);
      final boolean inWatchlist=Cursors.getBoolean(show,ShowColumns.IN_WATCHLIST);
      if (watchedCount > 0 || collectedCount > 0 || watchlistCount > 0 || inWatchlist) {
        return true;
      }
    }
    return false;
  }
  finally {
    if (show != null)     show.close();
  }
}",0.8874878758486906
56438,"@Override public void handleResponse(List<UpdatedItem> updated){
  for (  UpdatedItem item : updated) {
    final String updatedAt=item.getUpdatedAt();
    final Movie movie=item.getMovie();
    final long traktId=movie.getIds().getTrakt();
    final long movieId=movieHelper.getId(traktId);
    if (movieId != -1L) {
      final boolean shouldUpdate=movieHelper.shouldUpdate(traktId,updatedAt);
      if (shouldUpdate) {
        queue(new SyncMovie(traktId));
      }
 else {
        ContentValues values=new ContentValues();
        values.put(MovieColumns.NEEDS_SYNC,true);
        getContentResolver().update(Movies.withId(movieId),values,null,null);
      }
    }
  }
  if (updated.size() >= LIMIT) {
    queue(new SyncUpdatedMovies(updatedSince,page + 1));
  }
}","@Override public void handleResponse(List<UpdatedItem> updated){
  for (  UpdatedItem item : updated) {
    final String updatedAt=item.getUpdatedAt();
    final Movie movie=item.getMovie();
    final long traktId=movie.getIds().getTrakt();
    final long movieId=movieHelper.getId(traktId);
    if (movieId != -1L) {
      if (movieHelper.isUpdated(traktId,updatedAt)) {
        final boolean shouldUpdate=movieHelper.shouldUpdate(traktId,updatedAt);
        if (shouldUpdate) {
          queue(new SyncMovie(traktId));
        }
 else {
          ContentValues values=new ContentValues();
          values.put(MovieColumns.NEEDS_SYNC,true);
          getContentResolver().update(Movies.withId(movieId),values,null,null);
        }
      }
    }
  }
  if (updated.size() >= LIMIT) {
    queue(new SyncUpdatedMovies(updatedSince,page + 1));
  }
}",0.9516728624535316
56439,"@Override public void handleResponse(List<UpdatedItem> updated){
  List<Long> showSummaries=new ArrayList<>();
  for (  UpdatedItem item : updated) {
    final String updatedAt=item.getUpdatedAt();
    Show show=item.getShow();
    final long traktId=show.getIds().getTrakt();
    final long id=showHelper.getId(traktId);
    if (id != -1L) {
      final boolean shouldUpdate=showHelper.shouldUpdate(traktId,updatedAt);
      if (shouldUpdate) {
        queue(new SyncShow(traktId));
      }
 else {
        ContentValues values=new ContentValues();
        values.put(ShowColumns.NEEDS_SYNC,true);
        getContentResolver().update(Shows.withId(id),values,null,null);
      }
    }
  }
  if (updated.size() >= LIMIT) {
    queue(new SyncUpdatedShows(updatedSince,page + 1));
  }
}","@Override public void handleResponse(List<UpdatedItem> updated){
  for (  UpdatedItem item : updated) {
    final String updatedAt=item.getUpdatedAt();
    Show show=item.getShow();
    final long traktId=show.getIds().getTrakt();
    final long id=showHelper.getId(traktId);
    if (id != -1L) {
      if (showHelper.isUpdated(traktId,updatedAt)) {
        final boolean shouldUpdate=showHelper.shouldUpdate(traktId);
        if (shouldUpdate) {
          queue(new SyncShow(traktId));
        }
 else {
          ContentValues values=new ContentValues();
          values.put(ShowColumns.NEEDS_SYNC,true);
          getContentResolver().update(Shows.withId(id),values,null,null);
        }
      }
    }
  }
  if (updated.size() >= LIMIT) {
    queue(new SyncUpdatedShows(updatedSince,page + 1));
  }
}",0.9124133585381222
56440,"private void updateEpisodeViews(final Cursor cursor){
  if (cursor.moveToFirst()) {
    loaded=true;
    final int episodeNumber=Cursors.getInt(cursor,EpisodeColumns.EPISODE);
    season=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.SEASON));
    episodeTitle=cursor.getString(cursor.getColumnIndex(EpisodeColumns.TITLE));
    if (TextUtils.isEmpty(episodeTitle)) {
      if (season == 0) {
        episodeTitle=getResources().getString(R.string.special_x,episodeNumber);
      }
 else {
        episodeTitle=getResources().getString(R.string.episode_x,episodeNumber);
      }
    }
    title.setText(episodeTitle);
    overview.setText(cursor.getString(cursor.getColumnIndex(EpisodeColumns.OVERVIEW)));
    final String screenshot=cursor.getString(cursor.getColumnIndex(EpisodeColumns.SCREENSHOT));
    setBackdrop(screenshot,true);
    firstAired.setText(DateUtils.millisToString(getActivity(),cursor.getLong(cursor.getColumnIndex(EpisodeColumns.FIRST_AIRED)),true));
    watched=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.WATCHED)) == 1;
    collected=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.IN_COLLECTION)) == 1;
    inWatchlist=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.IN_WATCHLIST)) == 1;
    watching=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.WATCHING)) == 1;
    checkedIn=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.CHECKED_IN)) == 1;
    watchedView.setVisibility(watched ? View.VISIBLE : View.GONE);
    inCollectionView.setVisibility(collected ? View.VISIBLE : View.GONE);
    inWatchlistView.setVisibility(inWatchlist ? View.VISIBLE : View.GONE);
    currentRating=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.USER_RATING));
    final float ratingAll=cursor.getFloat(cursor.getColumnIndex(EpisodeColumns.RATING));
    rating.setValue(ratingAll);
    createMenu(toolbar);
  }
}","private void updateEpisodeViews(final Cursor cursor){
  if (cursor.moveToFirst()) {
    loaded=true;
    final int episodeNumber=Cursors.getInt(cursor,EpisodeColumns.EPISODE);
    season=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.SEASON));
    episodeTitle=cursor.getString(cursor.getColumnIndex(EpisodeColumns.TITLE));
    if (TextUtils.isEmpty(episodeTitle)) {
      if (season == 0) {
        episodeTitle=getResources().getString(R.string.special_x,episodeNumber);
      }
 else {
        episodeTitle=getResources().getString(R.string.episode_x,episodeNumber);
      }
    }
    title.setText(episodeTitle);
    overview.setText(cursor.getString(cursor.getColumnIndex(EpisodeColumns.OVERVIEW)));
    final String screenshot=cursor.getString(cursor.getColumnIndex(EpisodeColumns.SCREENSHOT));
    setBackdrop(screenshot,true);
    firstAired.setText(DateUtils.millisToString(getActivity(),cursor.getLong(cursor.getColumnIndex(EpisodeColumns.FIRST_AIRED)),true));
    watched=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.WATCHED)) == 1;
    collected=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.IN_COLLECTION)) == 1;
    inWatchlist=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.IN_WATCHLIST)) == 1;
    watching=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.WATCHING)) == 1;
    checkedIn=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.CHECKED_IN)) == 1;
    watchedView.setVisibility(watched ? View.VISIBLE : View.GONE);
    inCollectionView.setVisibility(collected ? View.VISIBLE : View.GONE);
    inWatchlistView.setVisibility(inWatchlist ? View.VISIBLE : View.GONE);
    currentRating=cursor.getInt(cursor.getColumnIndex(EpisodeColumns.USER_RATING));
    final float ratingAll=cursor.getFloat(cursor.getColumnIndex(EpisodeColumns.RATING));
    rating.setValue(ratingAll);
    invalidateMenu();
  }
}",0.9953892053159752
56441,"public void onViewCreated(View view,Bundle inState){
  super.onViewCreated(view,inState);
  recyclerView.setLayoutManager(getLayoutManager());
  RecyclerView.ItemAnimator itemAnimator=getItemAnimator();
  if (itemAnimator != null) {
    recyclerView.setItemAnimator(itemAnimator);
  }
  addItemDecorations(recyclerView);
  if (empty != null) {
    if (emptyText != null) {
      empty.setText(emptyText);
    }
    if (adapter != null && adapter.getItemCount() > 0) {
      empty.setVisibility(View.GONE);
      recyclerView.setVisibility(View.VISIBLE);
    }
 else {
      empty.setVisibility(View.VISIBLE);
      recyclerView.setVisibility(View.GONE);
    }
  }
  if (adapter != null) {
    recyclerView.setAdapter(adapter);
  }
  view.addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
    @Override public void onLayoutChange(    View v,    int left,    int top,    int right,    int bottom,    int oldLeft,    int oldTop,    int oldRight,    int oldBottom){
      v.removeOnLayoutChangeListener(this);
      if (adapter == null) {
        listContainer.setVisibility(View.GONE);
        progressContainer.setVisibility(View.VISIBLE);
        currentState=STATE_PROGRESS_VISIBLE;
      }
 else {
        currentState=STATE_CONTENT_VISIBLE;
        listContainer.setVisibility(View.VISIBLE);
        progressContainer.setVisibility(View.GONE);
      }
    }
  }
);
}","public void onViewCreated(View view,Bundle inState){
  super.onViewCreated(view,inState);
  recyclerView.setLayoutManager(getLayoutManager());
  RecyclerView.ItemAnimator itemAnimator=getItemAnimator();
  if (itemAnimator != null) {
    recyclerView.setItemAnimator(itemAnimator);
  }
  addItemDecorations(recyclerView);
  if (empty != null) {
    if (emptyText != null) {
      empty.setText(emptyText);
    }
    if (adapter != null && adapter.getItemCount() > 0) {
      empty.setVisibility(View.GONE);
      recyclerView.setVisibility(View.VISIBLE);
    }
 else {
      empty.setVisibility(View.VISIBLE);
      recyclerView.setVisibility(View.GONE);
    }
  }
  if (adapter != null) {
    recyclerView.setAdapter(adapter);
  }
  if (adapter == null) {
    listContainer.setVisibility(View.GONE);
    progressContainer.setVisibility(View.VISIBLE);
    currentState=STATE_PROGRESS_VISIBLE;
  }
 else {
    currentState=STATE_CONTENT_VISIBLE;
    listContainer.setVisibility(View.VISIBLE);
    progressContainer.setVisibility(View.GONE);
  }
}",0.8617416425918283
56442,"@Override protected Result doInBackground(String... params){
  String code=params[0];
  try {
    final AccessToken token=authorizationService.getToken(new TokenRequest(code,BuildConfig.TRAKT_CLIENT_ID,BuildConfig.TRAKT_SECRET,BuildConfig.TRAKT_REDIRECT_URL,GrantType.AUTHORIZATION_CODE));
    final String accessToken=token.getAccessToken();
    final SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(context);
    settings.edit().putString(Settings.TRAKT_TOKEN,accessToken).apply();
    userToken.setToken(accessToken);
    final UserSettings userSettings=usersService.getUserSettings();
    Settings.clearProfile(context);
    Settings.updateProfile(context,userSettings);
    return new Result(accessToken);
  }
 catch (  RetrofitError e) {
switch (e.getKind()) {
case NETWORK:
      return new Result(R.string.error_network);
case HTTP:
    Response response=e.getResponse();
  if (response != null) {
    int status=response.getStatus();
    if (status >= 500 && status < 600) {
      return new Result(R.string.login_error_5xx);
    }
  }
case CONVERSION:
case UNEXPECTED:
}
Timber.e(e,""String_Node_Str"");
return new Result(R.string.login_error_unknown);
}
}","@Override protected Result doInBackground(String... params){
  String code=params[0];
  try {
    final AccessToken token=authorizationService.getToken(new TokenRequest(code,BuildConfig.TRAKT_CLIENT_ID,BuildConfig.TRAKT_SECRET,BuildConfig.TRAKT_REDIRECT_URL,GrantType.AUTHORIZATION_CODE));
    final String accessToken=token.getAccessToken();
    final SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(context);
    settings.edit().putString(Settings.TRAKT_TOKEN,accessToken).apply();
    userToken.setToken(accessToken);
    final UserSettings userSettings=usersService.getUserSettings();
    Settings.clearProfile(context);
    Settings.updateProfile(context,userSettings);
    return new Result(accessToken);
  }
 catch (  RetrofitError e) {
switch (e.getKind()) {
case NETWORK:
      return new Result(R.string.login_error_network);
case HTTP:
    Response response=e.getResponse();
  if (response != null) {
    int status=response.getStatus();
    if (status >= 500 && status < 600) {
      return new Result(R.string.login_error_5xx);
    }
  }
case CONVERSION:
case UNEXPECTED:
}
Timber.e(e,""String_Node_Str"");
return new Result(R.string.login_error_unknown);
}
}",0.99748322147651
56443,"@Override public boolean onTouchEvent(MotionEvent ev){
  velocityTracker.addMovement(ev);
  final int action=ev.getAction() & MotionEvent.ACTION_MASK;
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      velocityTracker.clear();
      scroller.abortAnimation();
      lastTouchY=ev.getY();
      lastTouchX=ev.getX();
      final int x=(int)ev.getX();
      activePointerId=ev.getPointerId(0);
      touchRemainderY=0;
      motionPosition=getPositionAt(x,(int)lastTouchY);
      if (hasStableIds) {
        motionId=((LayoutParams)getChildAt(motionPosition).getLayoutParams()).id;
      }
      if (motionPosition != INVALID_POSITION && adapter != null && adapter.isEnabled(motionPosition)) {
        pendingTapCheck=new TapCheck();
        postDelayed(pendingTapCheck,ViewConfiguration.getTapTimeout());
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int index=ev.findPointerIndex(activePointerId);
    if (index < 0) {
      Log.e(TAG,""String_Node_Str"" + activePointerId + ""String_Node_Str""+ ""String_Node_Str"");
      return false;
    }
    final float y=ev.getY(index);
    final float x=ev.getX(index);
    final float dy=y - lastTouchY + touchRemainderY;
    final int deltaY=(int)dy;
    touchRemainderY=dy - deltaY;
    if (Math.abs(dy) > touchSlop) {
      touchMode=TOUCH_MODE_DRAGGING;
    }
    if (touchMode == TOUCH_MODE_DRAGGING) {
      if (pendingTapCheck != null) {
        removeCallbacks(pendingTapCheck);
      }
      if (!selectorRect.isEmpty()) {
        selectorRect.setEmpty();
      }
      if (motionPosition != INVALID_POSITION) {
        final View child=getChildAt(motionPosition - firstPosition);
        if (child != null) {
          child.setPressed(false);
        }
        setPressed(false);
        selector.setState(StateSet.NOTHING);
        motionPosition=INVALID_POSITION;
        motionId=-1L;
      }
      lastTouchY=y;
      lastTouchX=x;
      if (!trackMotionScroll(deltaY,true)) {
        velocityTracker.clear();
      }
    }
  }
break;
case MotionEvent.ACTION_CANCEL:
touchMode=TOUCH_MODE_IDLE;
if (motionPosition != INVALID_POSITION) {
View child=getChildAt(motionPosition);
child.setPressed(false);
setPressed(false);
}
motionPosition=INVALID_POSITION;
motionId=-1L;
if (pendingTapCheck != null) {
removeCallbacks(pendingTapCheck);
pendingTapCheck=null;
}
break;
case MotionEvent.ACTION_UP:
{
velocityTracker.computeCurrentVelocity(1000,maximumVelocity);
final float velocity=velocityTracker.getYVelocity(activePointerId);
if (pendingTapCheck != null) {
removeCallbacks(pendingTapCheck);
pendingTapCheck=null;
}
if (Math.abs(velocity) > flingVelocity) {
touchMode=TOUCH_MODE_FLINGING;
scroller.fling(0,0,0,(int)velocity,0,0,Integer.MIN_VALUE,Integer.MAX_VALUE);
lastTouchY=0;
postInvalidateOnAnimation();
}
 else {
if (touchMode != TOUCH_MODE_DRAGGING && motionPosition != INVALID_POSITION) {
if (adapter != null && adapter.isEnabled(motionPosition)) {
new TapCheck().run();
tapReset=new TapReset();
postDelayed(tapReset,ViewConfiguration.getPressedStateDuration());
}
 else {
motionPosition=INVALID_POSITION;
motionId=-1L;
}
}
touchMode=TOUCH_MODE_IDLE;
}
}
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  velocityTracker.addMovement(ev);
  final int action=ev.getAction() & MotionEvent.ACTION_MASK;
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      velocityTracker.clear();
      scroller.abortAnimation();
      lastTouchY=ev.getY();
      lastTouchX=ev.getX();
      final int x=(int)ev.getX();
      activePointerId=ev.getPointerId(0);
      touchRemainderY=0;
      motionPosition=getPositionAt(x,(int)lastTouchY);
      if (motionPosition != INVALID_POSITION && adapter != null && adapter.isEnabled(motionPosition)) {
        pendingTapCheck=new TapCheck();
        postDelayed(pendingTapCheck,ViewConfiguration.getTapTimeout());
        if (hasStableIds) {
          motionId=((LayoutParams)getChildAt(motionPosition - firstPosition).getLayoutParams()).id;
        }
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int index=ev.findPointerIndex(activePointerId);
    if (index < 0) {
      Log.e(TAG,""String_Node_Str"" + activePointerId + ""String_Node_Str""+ ""String_Node_Str"");
      return false;
    }
    final float y=ev.getY(index);
    final float x=ev.getX(index);
    final float dy=y - lastTouchY + touchRemainderY;
    final int deltaY=(int)dy;
    touchRemainderY=dy - deltaY;
    if (Math.abs(dy) > touchSlop) {
      touchMode=TOUCH_MODE_DRAGGING;
    }
    if (touchMode == TOUCH_MODE_DRAGGING) {
      if (pendingTapCheck != null) {
        removeCallbacks(pendingTapCheck);
      }
      if (!selectorRect.isEmpty()) {
        selectorRect.setEmpty();
      }
      if (motionPosition != INVALID_POSITION) {
        final View child=getChildAt(motionPosition - firstPosition);
        if (child != null) {
          child.setPressed(false);
        }
        setPressed(false);
        selector.setState(StateSet.NOTHING);
        motionPosition=INVALID_POSITION;
        motionId=-1L;
      }
      lastTouchY=y;
      lastTouchX=x;
      if (!trackMotionScroll(deltaY,true)) {
        velocityTracker.clear();
      }
    }
  }
break;
case MotionEvent.ACTION_CANCEL:
touchMode=TOUCH_MODE_IDLE;
if (motionPosition != INVALID_POSITION) {
View child=getChildAt(motionPosition - firstPosition);
child.setPressed(false);
setPressed(false);
}
motionPosition=INVALID_POSITION;
motionId=-1L;
selectorRect.setEmpty();
if (pendingTapCheck != null) {
removeCallbacks(pendingTapCheck);
pendingTapCheck=null;
}
break;
case MotionEvent.ACTION_UP:
{
velocityTracker.computeCurrentVelocity(1000,maximumVelocity);
final float velocity=velocityTracker.getYVelocity(activePointerId);
if (pendingTapCheck != null) {
removeCallbacks(pendingTapCheck);
pendingTapCheck=null;
}
if (Math.abs(velocity) > flingVelocity) {
touchMode=TOUCH_MODE_FLINGING;
scroller.fling(0,0,0,(int)velocity,0,0,Integer.MIN_VALUE,Integer.MAX_VALUE);
lastTouchY=0;
postInvalidateOnAnimation();
if (motionPosition != INVALID_POSITION) {
View child=getChildAt(motionPosition - firstPosition);
if (child != null) {
child.setPressed(false);
}
setPressed(false);
motionPosition=INVALID_POSITION;
motionId=-1L;
selectorRect.setEmpty();
if (pendingTapCheck != null) {
removeCallbacks(pendingTapCheck);
pendingTapCheck=null;
}
}
}
 else {
if (touchMode != TOUCH_MODE_DRAGGING && motionPosition != INVALID_POSITION) {
if (adapter != null && adapter.isEnabled(motionPosition)) {
new TapCheck().run();
tapReset=new TapReset();
postDelayed(tapReset,ViewConfiguration.getPressedStateDuration());
}
 else {
motionPosition=INVALID_POSITION;
motionId=-1L;
}
}
touchMode=TOUCH_MODE_IDLE;
}
}
break;
}
return true;
}",0.9073853484216796
56444,"@Override public void onChanged(){
  dataChanged=true;
  oldItemCount=itemCount;
  itemCount=adapter.getCount();
  recycler.clearTransientViews();
  if (!hasStableIds) {
    layoutRecords.clear();
    recycleAllViews();
    final int colCount=StaggeredGridView.this.colCount;
    for (int i=0; i < colCount; i++) {
      itemBottoms[i]=itemTops[i];
    }
  }
  if (firstPosition >= itemCount) {
    firstPosition=Math.max(Math.min(firstPosition,itemCount - 1),0);
  }
  for (int i=getChildCount() - 1; i >= 1; i--) {
    final View child=getChildAt(i);
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    removeViewAt(i);
    layoutRecords.removeAt(lp.position);
    recycler.addScrap(child);
  }
  requestLayout();
  updateEmptyState();
}","@Override public void onChanged(){
  dataChanged=true;
  oldItemCount=itemCount;
  itemCount=adapter.getCount();
  recycler.clearTransientViews();
  if (!hasStableIds) {
    layoutRecords.clear();
    recycleAllViews();
    final int colCount=StaggeredGridView.this.colCount;
    for (int i=0; i < colCount; i++) {
      itemBottoms[i]=itemTops[i];
    }
  }
  if (firstPosition >= itemCount) {
    firstPosition=Math.max(Math.min(firstPosition,itemCount - 1),0);
  }
  for (int i=getChildCount() - 1; i >= 1; i--) {
    final View child=getChildAt(i);
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    removeViewAt(i);
    layoutRecords.remove(lp.position);
    recycler.addScrap(child);
  }
  requestLayout();
  updateEmptyState();
}",0.9986648865153538
56445,"private void bindCollection(Context context,ViewHolder vh,Cursor cursor){
  final int airdateCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.AIRDATE_COUNT));
  final int unairedCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.UNAIRED_COUNT));
  final int collectedCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.IN_COLLECTION_COUNT));
  final int toCollect=airdateCount - unairedCount - collectedCount;
  vh.progress.setMax(airdateCount);
  vh.progress.setProgress(collectedCount);
  final String unwatched=resources.getQuantityString(R.plurals.x_uncollected,toCollect,toCollect);
  vh.summary.setText(unwatched);
}","private void bindCollection(Context context,ViewHolder vh,Cursor cursor){
  final int airdateCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.AIRDATE_COUNT));
  final int unairedCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.UNAIRED_COUNT));
  final int collectedCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.IN_COLLECTION_COUNT));
  int toCollect=airdateCount - unairedCount - collectedCount;
  toCollect=Math.max(toCollect,0);
  vh.progress.setMax(airdateCount);
  vh.progress.setProgress(collectedCount);
  String uncollected;
  if (toCollect == 0) {
    uncollected=resources.getString(R.string.all_collected);
  }
 else {
    uncollected=resources.getString(R.string.x_uncollected,toCollect);
  }
  vh.summary.setText(uncollected);
}",0.6622340425531915
56446,"private void bindWatched(Context context,ViewHolder vh,Cursor cursor){
  final int airdateCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.AIRDATE_COUNT));
  final int unairedCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.UNAIRED_COUNT));
  final int watchedCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.WATCHED_COUNT));
  final int toWatch=airdateCount - unairedCount - watchedCount;
  vh.progress.setMax(airdateCount);
  vh.progress.setProgress(watchedCount);
  TypedArray a=context.obtainStyledAttributes(new int[]{android.R.attr.textColorPrimary,android.R.attr.textColorSecondary});
  ColorStateList primaryColor=a.getColorStateList(0);
  ColorStateList secondaryColor=a.getColorStateList(1);
  a.recycle();
  final String unwatched=resources.getQuantityString(R.plurals.x_unwatched,toWatch,toWatch);
  String unaired;
  if (unairedCount > 0) {
    unaired=resources.getString(R.string.x_unaired,unairedCount);
  }
 else {
    unaired=""String_Node_Str"";
  }
  SpannableStringBuilder ssb=new SpannableStringBuilder().append(unwatched).append(""String_Node_Str"").append(unaired);
  ssb.setSpan(new TextAppearanceSpan(null,0,0,primaryColor,null),0,unwatched.length() - 1,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  if (unairedCount > 0) {
    ssb.setSpan(new TextAppearanceSpan(null,0,0,secondaryColor,null),unwatched.length(),unwatched.length() + unaired.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  }
  vh.summary.setText(ssb.toString());
}","private void bindWatched(Context context,ViewHolder vh,Cursor cursor){
  final int airdateCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.AIRDATE_COUNT));
  final int unairedCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.UNAIRED_COUNT));
  final int watchedCount=cursor.getInt(cursor.getColumnIndexOrThrow(CathodeContract.Seasons.WATCHED_COUNT));
  int toWatch=airdateCount - unairedCount - watchedCount;
  toWatch=Math.max(toWatch,0);
  vh.progress.setMax(airdateCount);
  vh.progress.setProgress(watchedCount);
  TypedArray a=context.obtainStyledAttributes(new int[]{android.R.attr.textColorPrimary,android.R.attr.textColorSecondary});
  ColorStateList primaryColor=a.getColorStateList(0);
  ColorStateList secondaryColor=a.getColorStateList(1);
  a.recycle();
  String unwatched;
  if (toWatch == 0) {
    unwatched=resources.getString(R.string.all_watched);
  }
 else {
    unwatched=resources.getString(R.string.x_unwatched,toWatch);
  }
  String unaired;
  if (unairedCount > 0) {
    unaired=resources.getString(R.string.x_unaired,unairedCount);
  }
 else {
    unaired=""String_Node_Str"";
  }
  SpannableStringBuilder ssb=new SpannableStringBuilder().append(unwatched).append(""String_Node_Str"").append(unaired);
  ssb.setSpan(new TextAppearanceSpan(null,0,0,primaryColor,null),0,unwatched.length() - 1,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  if (unairedCount > 0) {
    ssb.setSpan(new TextAppearanceSpan(null,0,0,secondaryColor,null),unwatched.length(),unwatched.length() + unaired.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  }
  vh.summary.setText(ssb.toString());
}",0.922880815806246
56447,"@Override public void onViewCreated(View view,Bundle inState){
  super.onViewCreated(view,inState);
  ButterKnife.inject(this,view);
  wait=true;
  view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      getView().getViewTreeObserver().removeOnGlobalLayoutListener(this);
      wait=false;
      if (currentState == STATE_CONTENT_VISIBLE) {
        content.setAlpha(1.0f);
        content.setVisibility(View.VISIBLE);
        progress.setVisibility(View.GONE);
      }
 else {
        content.setVisibility(View.GONE);
        progress.setAlpha(1.0f);
        progress.setVisibility(View.VISIBLE);
      }
      if (!isTablet && getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
        content.setScrollY(screen.getHeight() / 2);
      }
    }
  }
);
  ratingContainer.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      RatingDialog.newInstance(RatingDialog.Type.EPISODE,episodeId,currentRating).show(getFragmentManager(),DIALOG_RATING);
    }
  }
);
  if (!isTablet) {
    content.setListener(new ObservableScrollView.ScrollListener(){
      @Override public void onScrollChanged(      int l,      int t){
        final int offset=(int)(t / 2.0f);
        screen.setTranslationY(offset);
      }
    }
);
  }
  if (overflow != null) {
    overflow.setListener(new OverflowView.OverflowActionListener(){
      @Override public void onPopupShown(){
      }
      @Override public void onPopupDismissed(){
      }
      @Override public void onActionSelected(      int action){
        onActionSelected(action);
      }
    }
);
  }
}","@Override public void onViewCreated(View view,Bundle inState){
  super.onViewCreated(view,inState);
  ButterKnife.inject(this,view);
  wait=true;
  view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      getView().getViewTreeObserver().removeOnGlobalLayoutListener(this);
      wait=false;
      if (currentState == STATE_CONTENT_VISIBLE) {
        content.setAlpha(1.0f);
        content.setVisibility(View.VISIBLE);
        progress.setVisibility(View.GONE);
      }
 else {
        content.setVisibility(View.GONE);
        progress.setAlpha(1.0f);
        progress.setVisibility(View.VISIBLE);
      }
      if (!isTablet && getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
        content.setScrollY(screen.getHeight() / 2);
      }
    }
  }
);
  ratingContainer.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      RatingDialog.newInstance(RatingDialog.Type.EPISODE,episodeId,currentRating).show(getFragmentManager(),DIALOG_RATING);
    }
  }
);
  if (!isTablet) {
    content.setListener(new ObservableScrollView.ScrollListener(){
      @Override public void onScrollChanged(      int l,      int t){
        final int offset=(int)(t / 2.0f);
        screen.setTranslationY(offset);
      }
    }
);
  }
  if (overflow != null) {
    overflow.setListener(new OverflowView.OverflowActionListener(){
      @Override public void onPopupShown(){
      }
      @Override public void onPopupDismissed(){
      }
      @Override public void onActionSelected(      int action){
        EpisodeFragment.this.onActionSelected(action);
      }
    }
);
  }
}",0.9939218523878436
56448,"@Override protected void onCreate(Bundle inState){
  super.onCreate(inState);
  setContentView(R.layout.ui_content_view);
  messageBar=new MessageBar(this);
  if (!CathodeApp.accountExists(this) || isLoginAction(getIntent())) {
    Bundle loginState=inState != null ? inState.getBundle(STATE_LOGIN_CONTROLLER) : null;
    loginController=LoginController.newInstance(this);
    loginController.onCreate(loginState);
    activeController=loginController;
  }
 else {
    queue.add(new SyncUserActivityTask());
    Bundle uiState=inState != null ? inState.getBundle(STATE_UICONTROLLER) : null;
    uiController=PhoneController.newInstance(this);
    uiController.onCreate(uiState);
    activeController=uiController;
  }
  activeController.onAttach();
  syncHandler=new Handler();
  if (inState != null) {
    lastSync=inState.getLong(STATE_LAST_SYNC);
  }
}","@Override protected void onCreate(Bundle inState){
  super.onCreate(inState);
  setContentView(R.layout.ui_content_view);
  messageBar=new MessageBar(this);
  if (!CathodeApp.accountExists(this) || isLoginAction(getIntent())) {
    Bundle loginState=inState != null ? inState.getBundle(STATE_LOGIN_CONTROLLER) : null;
    loginController=LoginController.newInstance(this);
    loginController.onCreate(loginState);
    activeController=loginController;
  }
 else {
    Bundle uiState=inState != null ? inState.getBundle(STATE_UICONTROLLER) : null;
    uiController=PhoneController.newInstance(this);
    uiController.onCreate(uiState);
    activeController=uiController;
  }
  activeController.onAttach();
  syncHandler=new Handler();
  if (inState != null) {
    lastSync=inState.getLong(STATE_LAST_SYNC);
  }
}",0.9742051589682064
56449,"@Override protected void onResume(){
  super.onResume();
  bus.register(this);
  if (uiController != null) {
    if (lastSync + SYNC_DELAY < System.currentTimeMillis()) {
      queue.add(new SyncUserActivityTask());
    }
    syncHandler.postDelayed(syncRunnable,SYNC_DELAY);
  }
}","@Override protected void onResume(){
  super.onResume();
  bus.register(this);
  if (uiController != null) {
    if (lastSync + SYNC_DELAY < System.currentTimeMillis()) {
      syncRunnable.run();
    }
 else {
      syncHandler.postDelayed(syncRunnable,SYNC_DELAY);
    }
  }
}",0.8336314847942755
56450,"private void readConfig(){
  try {
    LookupOperationContext lookupContext=new LookupOperationContext(directory.getAdminSession(),directory.getDnFactory().create(""String_Node_Str""),SchemaConstants.ALL_USER_ATTRIBUTES,SchemaConstants.ALL_OPERATIONAL_ATTRIBUTES);
    Entry config=directory.getPartitionNexus().lookup(lookupContext);
    if (config.get(""String_Node_Str"") != null) {
      accessKey=config.get(""String_Node_Str"").getString();
    }
    if (config.get(""String_Node_Str"") != null) {
      secretKey=config.get(""String_Node_Str"").getString();
    }
    if (config.get(""String_Node_Str"") != null) {
      rootDN=config.get(""String_Node_Str"").getString();
    }
    groupsDN=""String_Node_Str"" + rootDN;
    usersDN=""String_Node_Str"" + rootDN;
    rolesDN=""String_Node_Str"" + rootDN;
    GROUP_FMT=""String_Node_Str"" + groupsDN;
    USER_FMT=""String_Node_Str"" + usersDN;
    ROLE_FMT=""String_Node_Str"" + rootDN;
    ensureRootDN();
    if (config.get(""String_Node_Str"") != null) {
      pollPeriod=Integer.parseInt(config.get(""String_Node_Str"").getString());
    }
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
}","private void readConfig(){
  try {
    LookupOperationContext lookupContext=new LookupOperationContext(directory.getAdminSession(),directory.getDnFactory().create(""String_Node_Str""),SchemaConstants.ALL_USER_ATTRIBUTES,SchemaConstants.ALL_OPERATIONAL_ATTRIBUTES);
    Entry config=directory.getPartitionNexus().lookup(lookupContext);
    if (config.get(""String_Node_Str"") != null) {
      accessKey=config.get(""String_Node_Str"").getString();
    }
    if (config.get(""String_Node_Str"") != null) {
      secretKey=config.get(""String_Node_Str"").getString();
    }
    if (config.get(""String_Node_Str"") != null) {
      rootDN=config.get(""String_Node_Str"").getString();
    }
    groupsDN=""String_Node_Str"" + rootDN;
    usersDN=""String_Node_Str"" + rootDN;
    rolesDN=""String_Node_Str"" + rootDN;
    GROUP_FMT=""String_Node_Str"" + groupsDN;
    USER_FMT=""String_Node_Str"" + usersDN;
    ROLE_FMT=""String_Node_Str"" + rootDN;
    ensureDNs();
    if (config.get(""String_Node_Str"") != null) {
      pollPeriod=Integer.parseInt(config.get(""String_Node_Str"").getString());
    }
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.9978098992553658
56451,"private void pollIAM(){
  LOG.info(""String_Node_Str"");
  try {
    populateGroupsFromIAM();
    populateUsersFromIAM();
    populateRolesFromIAM();
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
  LOG.info(""String_Node_Str"");
}","private void pollIAM(){
  LOG.info(""String_Node_Str"");
  try {
    clearDNs();
    populateGroupsFromIAM();
    populateUsersFromIAM();
    populateRolesFromIAM();
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
  LOG.info(""String_Node_Str"");
}",0.9688715953307392
56452,"private String getNextID(AmazonDynamoDBClient client){
  Map<String,AttributeValue> item=new HashMap<String,AttributeValue>();
  item.put(""String_Node_Str"",new AttributeValue().withS(""String_Node_Str""));
  item.put(""String_Node_Str"",new AttributeValue().withN(""String_Node_Str""));
  try {
    client.putItem(new PutItemRequest().withTableName(table).withItem(item).withExpected(Collections.singletonMap(""String_Node_Str"",new ExpectedAttributeValue(false))));
    return ""String_Node_Str"";
  }
 catch (  ConditionalCheckFailedException e) {
    UpdateItemResult updated=client.updateItem(new UpdateItemRequest().withTableName(table).withKey(new Key(new AttributeValue(""String_Node_Str""))).withAttributeUpdates(Collections.singletonMap(""String_Node_Str"",new AttributeValueUpdate(new AttributeValue().withN(""String_Node_Str""),AttributeAction.ADD))).withReturnValues(ReturnValue.UPDATED_NEW));
    return updated.getAttributes().get(""String_Node_Str"").getN();
  }
}","private String getNextID(AmazonDynamoDBClient client){
  UpdateItemResult updated=client.updateItem(new UpdateItemRequest().withTableName(""String_Node_Str"").withKey(new Key(new AttributeValue(""String_Node_Str""))).withAttributeUpdates(Collections.singletonMap(""String_Node_Str"",new AttributeValueUpdate(new AttributeValue().withN(""String_Node_Str""),AttributeAction.ADD))).withReturnValues(ReturnValue.UPDATED_NEW));
  return String.valueOf(1000 + Integer.parseInt(updated.getAttributes().get(""String_Node_Str"").getN()));
}",0.136302294197031
56453,"@After public void tearDown() throws Exception {
  Setup.popZssLocale();
}","@After public void tearDown() throws Exception {
  ExecutionsCtrl.setCurrent(null);
  Setup.popZssLocale();
}",0.8087431693989071
56454,"@Before public void startUp() throws Exception {
  Setup.pushZssLocale(Locale.TAIWAN);
}","@Before public void startUp() throws Exception {
  Setup.pushZssLocale(Locale.TAIWAN);
  final TemporaryExecution de=new TemporaryExecution();
  ExecutionsCtrl.setCurrent(de);
}",0.6641509433962264
56455,"@Test public void testZSS694CopyValidation(){
  Object[] books=_loadBooks(null,""String_Node_Str"");
  Book book=(Book)books[0];
  Sheet sheet=book.getSheet(""String_Node_Str"");
  SSheet ssheet=sheet.getInternalSheet();
  SDataValidation a1dv=ssheet.getDataValidation(0,0);
  Set<CellRegion> a1regions=a1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,a1regions.size());
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  SDataValidation d1dv=ssheet.getDataValidation(0,3);
  Set<CellRegion> d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",1,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Range a1=Ranges.range(sheet,""String_Node_Str"");
  a1.paste(Ranges.range(sheet,""String_Node_Str""),true);
  a1regions=a1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,a1regions.size());
  Assert.assertFalse(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,d1regions.size());
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Range b4=Ranges.range(sheet,""String_Node_Str"");
  b4.paste(Ranges.range(sheet,""String_Node_Str""),true);
  a1regions=a1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",4,a1regions.size());
  Assert.assertFalse(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,d1regions.size());
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Range e1=Ranges.range(sheet,""String_Node_Str"");
  e1.paste(Ranges.range(sheet,""String_Node_Str""));
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  e1.paste(Ranges.range(sheet,""String_Node_Str""),true);
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
}","@Test public void testZSS694CopyValidation(){
  Object[] books=_loadBooks(this,""String_Node_Str"");
  Book book=(Book)books[0];
  Sheet sheet=book.getSheet(""String_Node_Str"");
  SSheet ssheet=sheet.getInternalSheet();
  SDataValidation a1dv=ssheet.getDataValidation(0,0);
  Set<CellRegion> a1regions=a1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,a1regions.size());
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  SDataValidation d1dv=ssheet.getDataValidation(0,3);
  Set<CellRegion> d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",1,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Range a1=Ranges.range(sheet,""String_Node_Str"");
  a1.paste(Ranges.range(sheet,""String_Node_Str""),true);
  a1regions=a1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,a1regions.size());
  Assert.assertFalse(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,d1regions.size());
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Range b4=Ranges.range(sheet,""String_Node_Str"");
  b4.paste(Ranges.range(sheet,""String_Node_Str""),true);
  a1regions=a1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",4,a1regions.size());
  Assert.assertFalse(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",a1regions.contains(new CellRegion(""String_Node_Str"")));
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,d1regions.size());
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Range e1=Ranges.range(sheet,""String_Node_Str"");
  e1.paste(Ranges.range(sheet,""String_Node_Str""));
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  e1.paste(Ranges.range(sheet,""String_Node_Str""),true);
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",2,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
}",0.9988983751032772
56456,"@Test public void testZSS696CopyValidation(){
  Object[] books=_loadBooks(null,""String_Node_Str"");
  Book book=(Book)books[0];
  Sheet sheet=book.getSheet(""String_Node_Str"");
  SSheet ssheet=sheet.getInternalSheet();
  SDataValidation d1dv=ssheet.getDataValidation(0,3);
  Set<CellRegion> d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",1,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Range e1=Ranges.range(sheet,""String_Node_Str"");
  e1.paste(Ranges.range(sheet,""String_Node_Str""));
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",1,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",Ranges.range(sheet,""String_Node_Str"").isMergedCell());
  e1.paste(Ranges.range(sheet,""String_Node_Str""),true);
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",3,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",!Ranges.range(sheet,""String_Node_Str"").isMergedCell());
}","@Test public void testZSS696CopyValidation(){
  Object[] books=_loadBooks(this,""String_Node_Str"");
  Book book=(Book)books[0];
  Sheet sheet=book.getSheet(""String_Node_Str"");
  SSheet ssheet=sheet.getInternalSheet();
  SDataValidation d1dv=ssheet.getDataValidation(0,3);
  Set<CellRegion> d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",1,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Range e1=Ranges.range(sheet,""String_Node_Str"");
  e1.paste(Ranges.range(sheet,""String_Node_Str""));
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",1,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",Ranges.range(sheet,""String_Node_Str"").isMergedCell());
  e1.paste(Ranges.range(sheet,""String_Node_Str""),true);
  d1regions=d1dv.getRegions();
  Assert.assertEquals(""String_Node_Str"",3,d1regions.size());
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertFalse(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",d1regions.contains(new CellRegion(""String_Node_Str"")));
  Assert.assertTrue(""String_Node_Str"",!Ranges.range(sheet,""String_Node_Str"").isMergedCell());
}",0.9972844534962662
56457,"@Test public void testZSS693SortFormulaCells(){
  Object[] books=_loadBooks(null,""String_Node_Str"");
  Book book=(Book)books[0];
  Sheet sheet=book.getSheet(""String_Node_Str"");
  Range c1_10=Ranges.range(sheet,""String_Node_Str"");
  c1_10.sort(false);
  for (int r=0; r < 10; ++r) {
    Object cv=Ranges.range(sheet,r,2).getCellValue();
    Object ev=Ranges.range(sheet,r,4).getCellValue();
    Assert.assertEquals(""String_Node_Str"" + (r + 1) + ""String_Node_Str""+ (r + 1),ev,cv);
  }
}","@Test public void testZSS693SortFormulaCells(){
  Object[] books=_loadBooks(this,""String_Node_Str"");
  Book book=(Book)books[0];
  Sheet sheet=book.getSheet(""String_Node_Str"");
  Range c1_10=Ranges.range(sheet,""String_Node_Str"");
  c1_10.sort(false);
  for (int r=0; r < 10; ++r) {
    Object cv=Ranges.range(sheet,r,2).getCellValue();
    Object ev=Ranges.range(sheet,r,4).getCellValue();
    Assert.assertEquals(""String_Node_Str"" + (r + 1) + ""String_Node_Str""+ (r + 1),ev,cv);
  }
}",0.9917355371900828
56458,"public void copyFrom(PrintSetupImpl src){
  this._printGridlines=src._printGridlines;
  this._headerMargin=src._headerMargin;
  this._footerMargin=src._footerMargin;
  this._leftMargin=src._leftMargin;
  this._rightMargin=src._rightMargin;
  this._topMargin=src._topMargin;
  this._bottomMargin=src._bottomMargin;
  this._landscape=src._landscape;
  this._scale=src._scale;
  this._paperSize=src._paperSize;
  this._header=((HeaderFooterImpl)src._header).cloneHeaderFooterImpl();
  this._evenHeader=((HeaderFooterImpl)src._evenHeader).cloneHeaderFooterImpl();
  this._firstHeader=((HeaderFooterImpl)src._firstHeader).cloneHeaderFooterImpl();
  this._footer=((HeaderFooterImpl)src._footer).cloneHeaderFooterImpl();
  this._evenFooter=((HeaderFooterImpl)src._evenFooter).cloneHeaderFooterImpl();
  ;
  this._firstFooter=((HeaderFooterImpl)src._firstFooter).cloneHeaderFooterImpl();
  ;
  this._diffOddEven=src._diffOddEven;
  this._diffFirst=src._diffFirst;
  this._scaleWithDoc=src._scaleWithDoc;
  this._alignWithMargins=src._alignWithMargins;
  this._hCenter=src._hCenter;
  this._vCenter=src._vCenter;
  this._pageStart=src._pageStart;
  this._fitWidth=src._fitWidth;
  this._fitHeight=src._fitHeight;
  this._printArea=src._printArea;
  this._rowsTitle1=src._rowsTitle1;
  this._rowsTitle2=src._rowsTitle2;
  this._columnsTitle1=src._columnsTitle1;
  this._columnsTitle2=src._columnsTitle2;
  this._printHeadings=src._printHeadings;
  this._errorMode=src._errorMode;
  this._commentMode=src._commentMode;
  this._leftToRight=src._leftToRight;
}","public void copyFrom(PrintSetupImpl src){
  this._printGridlines=src._printGridlines;
  this._headerMargin=src._headerMargin;
  this._footerMargin=src._footerMargin;
  this._leftMargin=src._leftMargin;
  this._rightMargin=src._rightMargin;
  this._topMargin=src._topMargin;
  this._bottomMargin=src._bottomMargin;
  this._landscape=src._landscape;
  this._scale=src._scale;
  this._paperSize=src._paperSize;
  HeaderFooterImpl srcHF=(HeaderFooterImpl)src._header;
  if (srcHF != null) {
    this._header=srcHF.cloneHeaderFooterImpl();
  }
  srcHF=(HeaderFooterImpl)src._evenHeader;
  if (srcHF != null) {
    this._evenHeader=srcHF.cloneHeaderFooterImpl();
  }
  srcHF=(HeaderFooterImpl)src._firstHeader;
  if (srcHF != null) {
    this._firstHeader=srcHF.cloneHeaderFooterImpl();
  }
  srcHF=(HeaderFooterImpl)src._footer;
  if (srcHF != null) {
    this._footer=srcHF.cloneHeaderFooterImpl();
  }
  srcHF=(HeaderFooterImpl)src._evenFooter;
  if (srcHF != null) {
    this._evenFooter=((HeaderFooterImpl)src._evenFooter).cloneHeaderFooterImpl();
    ;
  }
  srcHF=(HeaderFooterImpl)src._firstFooter;
  if (srcHF != null) {
    this._firstFooter=((HeaderFooterImpl)src._firstFooter).cloneHeaderFooterImpl();
    ;
  }
  this._diffOddEven=src._diffOddEven;
  this._diffFirst=src._diffFirst;
  this._scaleWithDoc=src._scaleWithDoc;
  this._alignWithMargins=src._alignWithMargins;
  this._hCenter=src._hCenter;
  this._vCenter=src._vCenter;
  this._pageStart=src._pageStart;
  this._fitWidth=src._fitWidth;
  this._fitHeight=src._fitHeight;
  this._printArea=src._printArea;
  this._rowsTitle1=src._rowsTitle1;
  this._rowsTitle2=src._rowsTitle2;
  this._columnsTitle1=src._columnsTitle1;
  this._columnsTitle2=src._columnsTitle2;
  this._printHeadings=src._printHeadings;
  this._errorMode=src._errorMode;
  this._commentMode=src._commentMode;
  this._leftToRight=src._leftToRight;
}",0.7333722287047841
56459,"public SName getNameByName(String namename,String sheetName){
  if (_names == null)   return null;
  for (  SName name : _names) {
    if ((sheetName == null || sheetName.equalsIgnoreCase(name.getApplyToSheetName())) && name.getName().equalsIgnoreCase(namename)) {
      return name;
    }
  }
  return null;
}","public SName getNameByName(String namename,String sheetName){
  if (_names == null)   return null;
  for (  SName name : _names) {
    final String scopeSheetName=name.getApplyToSheetName();
    if ((sheetName == scopeSheetName || (sheetName != null && sheetName.equalsIgnoreCase(scopeSheetName))) && name.getName().equalsIgnoreCase(namename)) {
      return name;
    }
  }
  return null;
}",0.6390870185449358
56460,"@Override public void setFormula2(String formula2){
  checkOrphan();
  _evaluated=false;
  clearFormulaDependency(false);
  clearFormulaResultCache();
  FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
  Ref ref=getRef();
  if (formula2 != null) {
    _formula1Expr=fe.parse(formula2,new FormulaParseContext(_sheet,ref));
  }
 else {
    _formula1Expr=null;
  }
}","@Override public void setFormula2(String formula2){
  checkOrphan();
  _evaluated=false;
  clearFormulaDependency(false);
  clearFormulaResultCache();
  FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
  Ref ref=getRef();
  if (formula2 != null) {
    _formula2Expr=fe.parse(formula2,new FormulaParseContext(_sheet,ref));
  }
 else {
    _formula2Expr=null;
  }
}",0.9947643979057592
56461,"@Override @SuppressWarnings(""String_Node_Str"") public void clearCache(FormulaClearContext context){
  try {
    SBook book=context.getBook();
    SSheet sheet=context.getSheet();
    SCell cell=context.getCell();
    AbstractBookSeriesAdv bookSeries=(AbstractBookSeriesAdv)book.getBookSeries();
    Map<String,EvalContext> map=(Map<String,EvalContext>)bookSeries.getAttribute(KEY_EVALUATORS);
    if (map == null) {
      return;
    }
    if (cell != null && !cell.isNull()) {
      EvalContext ctx=map.get(book.getBookName());
      if (ctx == null) {
        _logger.warning(""String_Node_Str"" + book.getBookName());
        return;
      }
      String sheetName=sheet.getSheetName();
      EvalBook evalBook=ctx.getBook();
      EvaluationSheet evalSheet=evalBook.getSheet(evalBook.getSheetIndex(sheetName));
      EvaluationCell evalCell=evalSheet.getCell(cell.getRowIndex(),cell.getColumnIndex());
      WorkbookEvaluator evaluator=ctx.getEvaluator();
      evaluator.notifyUpdateCell(evalCell);
    }
 else {
      bookSeries.setAttribute(KEY_EVALUATORS,null);
      map.clear();
    }
  }
 catch (  Exception e) {
    _logger.error(e.getMessage(),e);
  }
}","@Override @SuppressWarnings(""String_Node_Str"") public void clearCache(FormulaClearContext context){
  try {
    SBook book=context.getBook();
    SSheet sheet=context.getSheet();
    SCell cell=context.getCell();
    AbstractBookSeriesAdv bookSeries=(AbstractBookSeriesAdv)book.getBookSeries();
    NonSerializableHolder<Map<String,EvalContext>> holder=(NonSerializableHolder<Map<String,EvalContext>>)bookSeries.getAttribute(KEY_EVALUATORS);
    Map<String,EvalContext> map=holder == null ? null : holder.getObject();
    if (map == null) {
      return;
    }
    if (cell != null && !cell.isNull()) {
      EvalContext ctx=map.get(book.getBookName());
      if (ctx == null) {
        _logger.warning(""String_Node_Str"" + book.getBookName());
        return;
      }
      String sheetName=sheet.getSheetName();
      EvalBook evalBook=ctx.getBook();
      EvaluationSheet evalSheet=evalBook.getSheet(evalBook.getSheetIndex(sheetName));
      EvaluationCell evalCell=evalSheet.getCell(cell.getRowIndex(),cell.getColumnIndex());
      WorkbookEvaluator evaluator=ctx.getEvaluator();
      evaluator.notifyUpdateCell(evalCell);
    }
 else {
      bookSeries.setAttribute(KEY_EVALUATORS,null);
      map.clear();
    }
  }
 catch (  Exception e) {
    _logger.error(e.getMessage(),e);
  }
}",0.9441500203832044
56462,"@Override @SuppressWarnings(""String_Node_Str"") public EvaluationResult evaluate(FormulaExpression expr,FormulaEvaluationContext context){
  if (expr.hasError()) {
    return new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  Ref dependant=context.getDependent();
  EvaluationResult result=null;
  try {
    SBook book=context.getBook();
    AbstractBookSeriesAdv bookSeries=(AbstractBookSeriesAdv)book.getBookSeries();
    DependencyTableAdv table=(DependencyTableAdv)bookSeries.getDependencyTable();
    Map<String,EvalContext> evalCtxMap=(Map<String,EvalContext>)bookSeries.getAttribute(KEY_EVALUATORS);
    if (evalCtxMap == null) {
      evalCtxMap=new LinkedHashMap<String,FormulaEngineImpl.EvalContext>();
      List<String> bookNames=new ArrayList<String>();
      List<WorkbookEvaluator> evaluators=new ArrayList<WorkbookEvaluator>();
      for (      SBook nb : bookSeries.getBooks()) {
        String bookName=nb.getBookName();
        EvalBook evalBook=new EvalBook(nb);
        WorkbookEvaluator we=new WorkbookEvaluator(evalBook,noCacheClassifier,null);
        bookNames.add(bookName);
        evaluators.add(we);
        evalCtxMap.put(bookName,new EvalContext(evalBook,we));
        FunctionResolver resolver=FunctionResolverFactory.createFunctionResolver();
        UDFFinder zkUDFF=resolver.getUDFFinder();
        if (zkUDFF != null) {
          IndexedUDFFinder bookUDFF=(IndexedUDFFinder)evalBook.getUDFFinder();
          bookUDFF.insert(0,zkUDFF);
        }
      }
      CollaboratingWorkbooksEnvironment.setup(bookNames.toArray(new String[0]),evaluators.toArray(new WorkbookEvaluator[0]));
      bookSeries.setAttribute(KEY_EVALUATORS,evalCtxMap);
    }
    EvalContext ctx=evalCtxMap.get(book.getBookName());
    if (ctx == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    EvalBook evalBook=ctx.getBook();
    WorkbookEvaluator evaluator=ctx.getEvaluator();
    Object oldXelCtx=getXelContext();
    XelContext xelCtx=getXelContextForResolving(context,evalBook,evaluator);
    setXelContext(xelCtx);
    try {
      result=evaluateFormula(expr,context,evalBook,evaluator);
    }
  finally {
      setXelContext(oldXelCtx);
    }
    if (dependant != null) {
      table.setEvaluated(dependant);
    }
  }
 catch (  NotImplementedException e) {
    _logger.info(e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_NAME,e.getMessage()));
  }
catch (  EvaluationException e) {
    _logger.warning(e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    ErrorEval error=e.getErrorEval();
    result=new EvaluationResultImpl(ResultType.ERROR,error == null ? new ErrorValue(ErrorValue.INVALID_FORMULA,e.getMessage()) : error);
  }
catch (  FormulaParseException e) {
    _logger.error(e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA,e.getMessage()));
  }
catch (  Exception e) {
    _logger.error(e.getMessage() + ""String_Node_Str"" + expr.getFormulaString(),e);
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA,e.getMessage()));
  }
  return result;
}","@Override @SuppressWarnings(""String_Node_Str"") public EvaluationResult evaluate(FormulaExpression expr,FormulaEvaluationContext context){
  if (expr.hasError()) {
    return new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  Ref dependant=context.getDependent();
  EvaluationResult result=null;
  try {
    SBook book=context.getBook();
    AbstractBookSeriesAdv bookSeries=(AbstractBookSeriesAdv)book.getBookSeries();
    DependencyTableAdv table=(DependencyTableAdv)bookSeries.getDependencyTable();
    NonSerializableHolder<Map<String,EvalContext>> holder=(NonSerializableHolder<Map<String,EvalContext>>)bookSeries.getAttribute(KEY_EVALUATORS);
    Map<String,EvalContext> evalCtxMap=holder == null ? null : holder.getObject();
    if (evalCtxMap == null) {
      evalCtxMap=new LinkedHashMap<String,FormulaEngineImpl.EvalContext>();
      List<String> bookNames=new ArrayList<String>();
      List<WorkbookEvaluator> evaluators=new ArrayList<WorkbookEvaluator>();
      for (      SBook nb : bookSeries.getBooks()) {
        String bookName=nb.getBookName();
        EvalBook evalBook=new EvalBook(nb);
        WorkbookEvaluator we=new WorkbookEvaluator(evalBook,noCacheClassifier,null);
        bookNames.add(bookName);
        evaluators.add(we);
        evalCtxMap.put(bookName,new EvalContext(evalBook,we));
        FunctionResolver resolver=FunctionResolverFactory.createFunctionResolver();
        UDFFinder zkUDFF=resolver.getUDFFinder();
        if (zkUDFF != null) {
          IndexedUDFFinder bookUDFF=(IndexedUDFFinder)evalBook.getUDFFinder();
          bookUDFF.insert(0,zkUDFF);
        }
      }
      CollaboratingWorkbooksEnvironment.setup(bookNames.toArray(new String[0]),evaluators.toArray(new WorkbookEvaluator[0]));
      bookSeries.setAttribute(KEY_EVALUATORS,new NonSerializableHolder<Map<String,EvalContext>>(evalCtxMap));
    }
    EvalContext ctx=evalCtxMap.get(book.getBookName());
    if (ctx == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    EvalBook evalBook=ctx.getBook();
    WorkbookEvaluator evaluator=ctx.getEvaluator();
    Object oldXelCtx=getXelContext();
    XelContext xelCtx=getXelContextForResolving(context,evalBook,evaluator);
    setXelContext(xelCtx);
    try {
      result=evaluateFormula(expr,context,evalBook,evaluator);
    }
  finally {
      setXelContext(oldXelCtx);
    }
    if (dependant != null) {
      table.setEvaluated(dependant);
    }
  }
 catch (  NotImplementedException e) {
    _logger.info(e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_NAME,e.getMessage()));
  }
catch (  EvaluationException e) {
    _logger.warning(e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    ErrorEval error=e.getErrorEval();
    result=new EvaluationResultImpl(ResultType.ERROR,error == null ? new ErrorValue(ErrorValue.INVALID_FORMULA,e.getMessage()) : error);
  }
catch (  FormulaParseException e) {
    _logger.error(e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA,e.getMessage()));
  }
catch (  Exception e) {
    _logger.error(e.getMessage() + ""String_Node_Str"" + expr.getFormulaString(),e);
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA,e.getMessage()));
  }
  return result;
}",0.96449093855901
56463,"public boolean validate(CellType cellType,Object value){
  ValidationType vtype=_validation.getValidationType();
  if (vtype == ValidationType.ANY) {
    return true;
  }
  if (vtype != ValidationType.TEXT_LENGTH && (value == null || (value instanceof String && ((String)value).length() == 0))) {
    if (_validation.isEmptyCellAllowed()) {
      return true;
    }
  }
  if (cellType == CellType.FORMULA) {
    FormulaEngine engine=EngineFactory.getInstance().createFormulaEngine();
    FormulaExpression expr=engine.parse((String)value,new FormulaParseContext(_sheet,null));
    if (expr.hasError()) {
      return false;
    }
    FormulaResultCellValue result=new FormulaResultCellValue(engine.evaluate(expr,new FormulaEvaluationContext(_sheet)));
    value=result.getValue();
    cellType=result.getCellType();
  }
  CalendarUtil cal=EngineFactory.getInstance().getCalendarUtil();
  boolean success=true;
switch (vtype) {
case INTEGER:
    if (!isInteger(value) || !validateOperation((Number)value)) {
      success=false;
    }
  break;
case DECIMAL:
if (!isDecimal(value) || !validateOperation((Number)value)) {
  success=false;
}
break;
case DATE:
case TIME:
success=(value instanceof Date) && validateOperation(cal.dateToDoubleValue((Date)value));
break;
case LIST:
if (!validateListOperation((value instanceof Date) ? cal.dateToDoubleValue((Date)value) : value)) {
;
success=false;
}
break;
case TEXT_LENGTH:
if (!isString(value) || !validateOperation(Integer.valueOf(value == null ? 0 : ((String)value).length()))) {
success=false;
}
break;
case FORMULA:
success=false;
}
return success;
}","public boolean validate(CellType cellType,Object value){
  ValidationType vtype=_validation.getValidationType();
  if (vtype == ValidationType.ANY) {
    return true;
  }
  if (vtype != ValidationType.TEXT_LENGTH && (value == null || (value instanceof String && ((String)value).length() == 0))) {
    if (_validation.isEmptyCellAllowed()) {
      return true;
    }
  }
  if (cellType == CellType.FORMULA) {
    FormulaEngine engine=EngineFactory.getInstance().createFormulaEngine();
    FormulaExpression expr=engine.parse((String)value,new FormulaParseContext(_sheet,null));
    if (expr.hasError()) {
      return false;
    }
    FormulaResultCellValue result=new FormulaResultCellValue(engine.evaluate(expr,new FormulaEvaluationContext(_sheet)));
    value=result.getValue();
    cellType=result.getCellType();
  }
  CalendarUtil cal=EngineFactory.getInstance().getCalendarUtil();
  boolean success=true;
switch (vtype) {
case INTEGER:
    if (!isInteger(value) || !validateOperation((Number)value)) {
      success=false;
    }
  break;
case DECIMAL:
if (!isDecimal(value) || !validateOperation((Number)value)) {
  success=false;
}
break;
case DATE:
case TIME:
success=(value instanceof Date) && validateOperation(cal.dateToDoubleValue((Date)value));
break;
case LIST:
if (!validateListOperation((value instanceof Date) ? cal.dateToDoubleValue((Date)value) : value)) {
;
success=false;
}
break;
case TEXT_LENGTH:
if ((value != null && !isString(value)) || !validateOperation(Integer.valueOf(value == null ? 0 : ((String)value).length()))) {
success=false;
}
break;
case FORMULA:
success=false;
}
return success;
}",0.9940975458216836
56464,"@Test public void testGeneralCellValue1(){
  SBook book=SBooks.createBook(""String_Node_Str"");
  SSheet sheet=book.createSheet(""String_Node_Str"");
  Date now=new Date();
  ErrorValue err=new ErrorValue(ErrorValue.INVALID_FORMULA);
  SCell cell=sheet.getCell(1,1);
  Assert.assertEquals(CellType.BLANK,cell.getType());
  Assert.assertNull(cell.getValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.STRING,cell.getType());
  Assert.assertEquals(""String_Node_Str"",cell.getValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.NUMBER,cell.getType());
  Assert.assertEquals(123,cell.getNumberValue().intValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.NUMBER,cell.getType());
  Assert.assertEquals(""String_Node_Str"",new SimpleDateFormat(""String_Node_Str"").format((Date)cell.getDateValue()));
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.BOOLEAN,cell.getType());
  Assert.assertEquals(Boolean.TRUE,cell.getBooleanValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.BOOLEAN,cell.getType());
  Assert.assertEquals(Boolean.FALSE,cell.getBooleanValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.FORMULA,cell.getType());
  Assert.assertEquals(CellType.NUMBER,cell.getFormulaResultType());
  Assert.assertEquals(""String_Node_Str"",cell.getFormulaValue());
  Assert.assertEquals(999D,cell.getValue());
  try {
    SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
    Assert.fail(""String_Node_Str"");
  }
 catch (  InvalidModelOpException x) {
    Assert.assertEquals(CellType.FORMULA,cell.getType());
    Assert.assertEquals(CellType.NUMBER,cell.getFormulaResultType());
    Assert.assertEquals(""String_Node_Str"",cell.getFormulaValue());
    Assert.assertEquals(999D,cell.getValue());
  }
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.STRING,cell.getType());
  Assert.assertEquals(""String_Node_Str"",cell.getValue());
}","@Test public void testGeneralCellValue1(){
  SBook book=SBooks.createBook(""String_Node_Str"");
  SSheet sheet=book.createSheet(""String_Node_Str"");
  Date now=new Date();
  ErrorValue err=new ErrorValue(ErrorValue.INVALID_FORMULA);
  SCell cell=sheet.getCell(1,1);
  Assert.assertEquals(CellType.BLANK,cell.getType());
  Assert.assertNull(cell.getValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.STRING,cell.getType());
  Assert.assertEquals(""String_Node_Str"",cell.getValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.NUMBER,cell.getType());
  Assert.assertEquals(123,cell.getNumberValue().intValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.NUMBER,cell.getType());
  Assert.assertEquals(""String_Node_Str"",new SimpleDateFormat(""String_Node_Str"").format((Date)cell.getDateValue()));
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.BOOLEAN,cell.getType());
  Assert.assertEquals(Boolean.TRUE,cell.getBooleanValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.BOOLEAN,cell.getType());
  Assert.assertEquals(Boolean.FALSE,cell.getBooleanValue());
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.FORMULA,cell.getType());
  Assert.assertEquals(CellType.NUMBER,cell.getFormulaResultType());
  Assert.assertEquals(""String_Node_Str"",cell.getFormulaValue());
  Assert.assertEquals(999D,cell.getValue());
  try {
    SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
    Assert.fail(""String_Node_Str"");
  }
 catch (  InvalidModelOpException x) {
    Assert.assertEquals(CellType.FORMULA,cell.getType());
    Assert.assertEquals(CellType.NUMBER,cell.getFormulaResultType());
    Assert.assertEquals(""String_Node_Str"",cell.getFormulaValue());
    Assert.assertEquals(999D,cell.getValue());
  }
  SRanges.range(sheet,1,1).setEditText(""String_Node_Str"");
  Assert.assertEquals(CellType.BLANK,cell.getType());
  Assert.assertEquals(null,cell.getValue());
}",0.99250936329588
56465,"@Override public void setEditText(final String editText){
  final InputEngine ie=EngineFactory.getInstance().createInputEngine();
  final ResultWrap<InputResult> input=new ResultWrap<InputResult>();
  final ResultWrap<HyperlinkType> hyperlinkType=new ResultWrap<HyperlinkType>();
  new CellVisitorTask(new CellVisitorForUpdate(){
    public boolean visit(    SCell cell){
      InputResult result;
      if ((result=input.get()) == null) {
        result=ie.parseInput(editText == null ? ""String_Node_Str"" : editText,cell.getCellStyle().getDataFormat(),new InputParseContext(Locales.getCurrent()));
        input.set(result);
        if (result.getType() == CellType.STRING) {
          hyperlinkType.set(getHyperlinkType((String)result.getValue()));
        }
      }
      Object cellval=cell.getValue();
      Object resultVal=result.getValue();
      String format=result.getFormat();
      if (euqlas(cellval,resultVal)) {
        return true;
      }
switch (result.getType()) {
case BLANK:
        cell.clearValue();
      break;
case BOOLEAN:
    cell.setBooleanValue((Boolean)resultVal);
  break;
case FORMULA:
cell.setFormulaValue((String)resultVal);
break;
case NUMBER:
if (resultVal instanceof Date) {
cell.setDateValue((Date)resultVal);
}
 else {
cell.setNumberValue((Double)resultVal);
}
break;
case STRING:
cell.setStringValue((String)resultVal);
if (hyperlinkType.get() != null) {
cell.setupHyperlink(hyperlinkType.get(),(String)resultVal,(String)resultVal);
}
break;
case ERROR:
default :
cell.setValue(resultVal);
}
String oldFormat=cell.getCellStyle().getDataFormat();
if (format != null && SCellStyle.FORMAT_GENERAL.equals(oldFormat)) {
StyleUtil.setDataFormat(cell.getSheet(),cell.getRowIndex(),cell.getColumnIndex(),format);
}
return true;
}
}
).doInWriteLock(getLock());
}","@Override public void setEditText(final String editText){
  final InputEngine ie=EngineFactory.getInstance().createInputEngine();
  final ResultWrap<InputResult> input=new ResultWrap<InputResult>();
  final ResultWrap<HyperlinkType> hyperlinkType=new ResultWrap<HyperlinkType>();
  new CellVisitorTask(new CellVisitorForUpdate(){
    public boolean visit(    SCell cell){
      InputResult result;
      if ((result=input.get()) == null) {
        result=ie.parseInput(editText == null ? ""String_Node_Str"" : editText,cell.getCellStyle().getDataFormat(),new InputParseContext(Locales.getCurrent()));
        input.set(result);
        if (result.getType() == CellType.STRING) {
          hyperlinkType.set(getHyperlinkType((String)result.getValue()));
        }
      }
      Object cellval=cell.getValue();
      Object resultVal=result.getValue();
      if (cell.getType() == result.getType() && euqlas(cellval,resultVal)) {
        return true;
      }
      String format=result.getFormat();
switch (result.getType()) {
case BLANK:
        cell.clearValue();
      break;
case BOOLEAN:
    cell.setBooleanValue((Boolean)resultVal);
  break;
case FORMULA:
cell.setFormulaValue((String)resultVal);
break;
case NUMBER:
if (resultVal instanceof Date) {
cell.setDateValue((Date)resultVal);
}
 else {
cell.setNumberValue((Double)resultVal);
}
break;
case STRING:
cell.setStringValue((String)resultVal);
if (hyperlinkType.get() != null) {
cell.setupHyperlink(hyperlinkType.get(),(String)resultVal,(String)resultVal);
}
break;
case ERROR:
default :
cell.setValue(resultVal);
}
String oldFormat=cell.getCellStyle().getDataFormat();
if (format != null && SCellStyle.FORMAT_GENERAL.equals(oldFormat)) {
StyleUtil.setDataFormat(cell.getSheet(),cell.getRowIndex(),cell.getColumnIndex(),format);
}
return true;
}
}
).doInWriteLock(getLock());
}",0.948180815876516
56466,"public void setCategoriesFormula(String expr){
  checkOrphan();
  evaluated=false;
  clearFormulaDependency();
  FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
  catFormula=fe.parse(expr,new FormulaParseContext(chart.getSheet(),getRef()));
}","public void setCategoriesFormula(String expr){
  checkOrphan();
  evaluated=false;
  clearFormulaDependency();
  if (expr != null) {
    FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
    catFormula=fe.parse(expr,new FormulaParseContext(chart.getSheet(),getRef()));
  }
 else {
    catFormula=null;
  }
}",0.8926746166950597
56467,"/** 
 * reference ChartHelper.prepareValues()
 * @param dataSource
 * @return
 */
private String getValueFormula(ChartDataSource<?> dataSource){
  if (dataSource.isReference()) {
    return dataSource.getFormulaString();
  }
 else {
    StringBuilder expression=new StringBuilder(""String_Node_Str"");
    int count=dataSource.getPointCount();
    for (int i=0; i < count; ++i) {
      Object value=dataSource.getPointAt(i);
      if (value == null) {
        if (dataSource.isNumeric()) {
          expression.append(""String_Node_Str"");
        }
 else {
          expression.append(""String_Node_Str"");
        }
      }
 else {
        if (dataSource.isNumeric()) {
          expression.append(value.toString());
        }
 else {
          expression.append(""String_Node_Str"").append(value).append(""String_Node_Str"");
        }
      }
      if (i != count - 1) {
        expression.append(""String_Node_Str"");
      }
    }
    expression.append(""String_Node_Str"");
    return expression.toString();
  }
}","/** 
 * reference ChartHelper.prepareValues()
 * @param dataSource
 * @return
 */
private String getValueFormula(ChartDataSource<?> dataSource){
  if (dataSource.isReference()) {
    return dataSource.getFormulaString();
  }
 else {
    int count=dataSource.getPointCount();
    if (count <= 0) {
      return null;
    }
    StringBuilder expression=new StringBuilder(""String_Node_Str"");
    for (int i=0; i < count; ++i) {
      Object value=dataSource.getPointAt(i);
      if (value == null) {
        if (dataSource.isNumeric()) {
          expression.append(""String_Node_Str"");
        }
 else {
          expression.append(""String_Node_Str"");
        }
      }
 else {
        if (dataSource.isNumeric()) {
          expression.append(value.toString());
        }
 else {
          expression.append(""String_Node_Str"").append(value).append(""String_Node_Str"");
        }
      }
      if (i != count - 1) {
        expression.append(""String_Node_Str"");
      }
    }
    expression.append(""String_Node_Str"");
    return expression.toString();
  }
}",0.9363768819815445
56468,"@Override public void setFormulaValue(String formula){
  checkOrphan();
  Validations.argNotNull(formula);
  FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
  FormulaExpression expr=fe.parse(formula,new FormulaParseContext(this,null));
  if (expr.hasError()) {
    String msg=expr.getErrorMessage();
    throw new InvalidateFormulaException(msg == null ? ""String_Node_Str"" : msg);
  }
  if (getType() == CellType.FORMULA) {
    clearValueForSet(true);
  }
  expr=fe.parse(formula,new FormulaParseContext(this,getRef()));
  setValue(expr);
}","@Override public void setFormulaValue(String formula){
  checkOrphan();
  Validations.argNotNull(formula);
  FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
  FormulaExpression expr=fe.parse(formula,new FormulaParseContext(this,null));
  if (expr.hasError()) {
    String msg=expr.getErrorMessage();
    throw new InvalidateFormulaException(msg == null ? ""String_Node_Str"" + formula + ""String_Node_Str"" : msg);
  }
  if (getType() == CellType.FORMULA) {
    clearValueForSet(true);
  }
  expr=fe.parse(formula,new FormulaParseContext(this,getRef()));
  setValue(expr);
}",0.9739130434782608
56469,"/** 
 * reference ChartHelper.prepareValues()
 * @param dataSource
 * @return
 */
private String getValueFormula(ChartDataSource<?> dataSource){
  if (dataSource.isReference()) {
    return dataSource.getFormulaString();
  }
 else {
    StringBuilder expression=new StringBuilder(""String_Node_Str"");
    int count=dataSource.getPointCount();
    for (int i=0; i < count; ++i) {
      Object value=dataSource.getPointAt(i);
      if (value == null) {
        if (dataSource.isNumeric()) {
          expression.append(""String_Node_Str"");
        }
 else {
          expression.append(""String_Node_Str"");
        }
      }
 else {
        expression.append(value.toString());
      }
      if (i != count - 1) {
        expression.append(""String_Node_Str"");
      }
    }
    expression.append(""String_Node_Str"");
    return expression.toString();
  }
}","/** 
 * reference ChartHelper.prepareValues()
 * @param dataSource
 * @return
 */
private String getValueFormula(ChartDataSource<?> dataSource){
  if (dataSource.isReference()) {
    return dataSource.getFormulaString();
  }
 else {
    StringBuilder expression=new StringBuilder(""String_Node_Str"");
    int count=dataSource.getPointCount();
    for (int i=0; i < count; ++i) {
      Object value=dataSource.getPointAt(i);
      if (value == null) {
        if (dataSource.isNumeric()) {
          expression.append(""String_Node_Str"");
        }
 else {
          expression.append(""String_Node_Str"");
        }
      }
 else {
        if (dataSource.isNumeric()) {
          expression.append(value.toString());
        }
 else {
          expression.append(""String_Node_Str"").append(value).append(""String_Node_Str"");
        }
      }
      if (i != count - 1) {
        expression.append(""String_Node_Str"");
      }
    }
    expression.append(""String_Node_Str"");
    return expression.toString();
  }
}",0.915948275862069
56470,"public static Book loadBook(Object base,String respath){
  if (base == null) {
    base=Util.class;
  }
  if (!(base instanceof Class)) {
    base=base.getClass();
  }
  final InputStream is=((Class)base).getResourceAsStream(respath);
  try {
    return Importers.getImporter().imports(is,respath);
  }
 catch (  IOException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","public static Book loadBook(Object base,String respath){
  if (base == null) {
    base=Util.class;
  }
  if (!(base instanceof Class)) {
    base=base.getClass();
  }
  final InputStream is=((Class)base).getResourceAsStream(respath);
  try {
    int index=respath.lastIndexOf(""String_Node_Str"");
    String bookName=index == -1 ? respath : respath.substring(index + 1);
    return Importers.getImporter().imports(is,bookName);
  }
 catch (  IOException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.8416447944007
56471,"protected void checkFormulaResultType(CellType... types){
  if (!getType().equals(CellType.FORMULA)) {
    throw new IllegalStateException(""String_Node_Str"" + getType() + ""String_Node_Str""+ types);
  }
  Set<CellType> set=new LinkedHashSet<CellType>();
  for (  CellType t : types) {
    set.add(t);
  }
  if (!set.contains(getFormulaResultType())) {
    throw new IllegalStateException(""String_Node_Str"" + getFormulaResultType() + ""String_Node_Str""+ types);
  }
}","protected void checkFormulaResultType(CellType... types){
  if (!getType().equals(CellType.FORMULA)) {
    throw new IllegalStateException(""String_Node_Str"" + getType() + ""String_Node_Str""+ types);
  }
  Set<CellType> set=new LinkedHashSet<CellType>();
  for (  CellType t : types) {
    set.add(t);
  }
  if (!set.contains(getFormulaResultType())) {
    throw new IllegalStateException(""String_Node_Str"" + getFormulaResultType() + ""String_Node_Str""+ Arrays.asList(types));
  }
}",0.9734888653234358
56472,"@Override public void deleteChart(final NChart chart){
  new ReadWriteTask(){
    @Override public Object invoke(){
      getSheet().deleteChart(chart);
      new NotifyChangeHelper().notifySheetChartAdd(getSheet(),chart.getId());
      return null;
    }
  }
.doInWriteLock(getLock());
}","@Override public void deleteChart(final NChart chart){
  new ReadWriteTask(){
    @Override public Object invoke(){
      getSheet().deleteChart(chart);
      new NotifyChangeHelper().notifySheetChartDelete(getSheet(),chart.getId());
      return null;
    }
  }
.doInWriteLock(getLock());
}",0.9844559585492229
56473,"@Override public void fillDown(){
  new ModelUpdateTask(){
    @Override Object doInvokePhase(){
      autoFillInLock(new CellRegion(getRow(),getColumn(),getLastRow(),getLastColumn()),new CellRegion(getRow(),getColumn(),getLastRow(),getLastColumn()),FillType.COPY);
      return null;
    }
    @Override void doNotifyPhase(){
    }
  }
.doInWriteLock(getLock());
}","@Override public void fillDown(){
  new ModelUpdateTask(){
    @Override Object doInvokePhase(){
      autoFillInLock(new CellRegion(getRow(),getColumn(),getRow(),getLastColumn()),new CellRegion(getRow(),getColumn(),getLastRow(),getLastColumn()),FillType.COPY);
      return null;
    }
    @Override void doNotifyPhase(){
    }
  }
.doInWriteLock(getLock());
}",0.9944903581267218
56474,"private void pasteValue(CellBuffer buffer,NCell destCell,boolean pasteFormula,int rowOffset,int columnOffset,boolean transpose,int rowOrigin,int columnOrigin){
  if (pasteFormula) {
    String formula=buffer.getFormula();
    if (formula != null) {
      FormulaEngine engine=getFormulaEignin();
      FormulaExpression expr=engine.shift(formula,rowOffset,columnOffset,new FormulaParseContext(destSheet,null));
      if (!expr.hasError() && transpose) {
        expr=engine.transpose(expr.getFormulaString(),rowOffset,columnOffset,new FormulaParseContext(destSheet,null));
      }
      if (!expr.hasError()) {
        destCell.setFormulaValue(expr.getFormulaString());
      }
      return;
    }
  }
  destCell.setValue(buffer.getValue());
}","private void pasteValue(CellBuffer buffer,NCell destCell,boolean pasteFormula,int rowOffset,int columnOffset,boolean transpose,int rowOrigin,int columnOrigin){
  if (pasteFormula) {
    String formula=buffer.getFormula();
    if (formula != null) {
      FormulaEngine engine=getFormulaEignin();
      FormulaExpression expr=engine.shift(formula,rowOffset,columnOffset,new FormulaParseContext(destSheet,null));
      if (!expr.hasError() && transpose) {
        expr=engine.transpose(expr.getFormulaString(),rowOrigin,columnOrigin,new FormulaParseContext(destSheet,null));
      }
      if (!expr.hasError()) {
        destCell.setFormulaValue(expr.getFormulaString());
      }
      return;
    }
  }
  destCell.setValue(buffer.getValue());
}",0.9865410497981156
56475,"private void pasteValue(CellBuffer buffer,NCell destCell,boolean pasteFormula,int rowOffset,int columnOffset,boolean transpose,int rowOrigin,int columnOrigin){
  if (pasteFormula) {
    String formula=buffer.getFormula();
    if (formula != null) {
      FormulaEngine engine=getFormulaEignin();
      FormulaExpression expr=engine.shift(formula,rowOffset,columnOffset,new FormulaParseContext(destSheet,null));
      if (!expr.hasError() && transpose) {
        expr=engine.transpose(expr.getFormulaString(),rowOffset,columnOffset,new FormulaParseContext(destSheet,null));
      }
      if (!expr.hasError()) {
        destCell.setFormulaValue(expr.getFormulaString());
      }
      return;
    }
  }
  destCell.setValue(buffer.getValue());
}","private void pasteValue(CellBuffer buffer,NCell destCell,boolean pasteFormula,int rowOffset,int columnOffset,boolean transpose,int rowOrigin,int columnOrigin){
  if (pasteFormula) {
    String formula=buffer.getFormula();
    if (formula != null) {
      FormulaEngine engine=getFormulaEignin();
      FormulaExpression expr=engine.shift(formula,rowOffset,columnOffset,new FormulaParseContext(destSheet,null));
      if (!expr.hasError() && transpose) {
        expr=engine.transpose(expr.getFormulaString(),rowOrigin,columnOrigin,new FormulaParseContext(destSheet,null));
      }
      if (!expr.hasError()) {
        destCell.setFormulaValue(expr.getFormulaString());
      }
      return;
    }
  }
  destCell.setValue(buffer.getValue());
}",0.9865410497981156
56476,"@Override public void setCellStyle(NCellStyle cellStyle){
  Validations.argNotNull(cellStyle);
  loadProxy();
  if (proxy == null) {
    proxy=(AbstractCellAdv)((AbstractRowAdv)((AbstractSheetAdv)getSheet()).getOrCreateRow(rowIdx)).getOrCreateCell(columnIdx);
  }
  proxy.setCellStyle(cellStyle);
}","@Override public void setCellStyle(NCellStyle cellStyle){
  loadProxy();
  if (proxy == null) {
    proxy=(AbstractCellAdv)((AbstractRowAdv)((AbstractSheetAdv)getSheet()).getOrCreateRow(rowIdx)).getOrCreateCell(columnIdx);
  }
  proxy.setCellStyle(cellStyle);
}",0.9338103756708408
56477,"private void buildCopyPaste(NBook book){
  NSheet sheet1=book.createSheet(""String_Node_Str"");
  NCellStyle totalStyle=book.createCellStyle(true);
  totalStyle.setDataFormat(""String_Node_Str"");
  totalStyle.setBorderBottom(BorderType.MEDIUM,book.createColor(""String_Node_Str""));
  NCellStyle headerStyle=book.createCellStyle(true);
  headerStyle.setFillColor(book.createColor(""String_Node_Str""));
  headerStyle.setFillPattern(FillPattern.SOLID_FOREGROUND);
  headerStyle.setAlignment(Alignment.CENTER);
  sheet1.getColumn(3).setWidth(150);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
  sheet1.getCell(""String_Node_Str"").setValue(10);
  StyleUtil.setDataFormat(sheet1,4,4,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(30);
  StyleUtil.setDataFormat(sheet1,5,4,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(50);
  StyleUtil.setDataFormat(sheet1,6,4,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(70);
  StyleUtil.setDataFormat(sheet1,7,4,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
  sheet1.getCell(""String_Node_Str"").setValue(20);
  StyleUtil.setDataFormat(sheet1,4,5,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(40);
  StyleUtil.setDataFormat(sheet1,5,5,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(60);
  StyleUtil.setDataFormat(sheet1,6,5,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(80);
  StyleUtil.setDataFormat(sheet1,7,5,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
}","private void buildCopyPaste(NBook book){
  NSheet sheet1=book.createSheet(""String_Node_Str"");
  NCellStyle totalStyle=book.createCellStyle(true);
  totalStyle.setDataFormat(""String_Node_Str"");
  totalStyle.setBorderBottom(BorderType.MEDIUM,book.createColor(""String_Node_Str""));
  NCellStyle headerStyle=book.createCellStyle(true);
  headerStyle.setFillColor(book.createColor(""String_Node_Str""));
  headerStyle.setFillPattern(FillPattern.SOLID_FOREGROUND);
  headerStyle.setAlignment(Alignment.CENTER);
  sheet1.getColumn(3).setWidth(150);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
  sheet1.getCell(""String_Node_Str"").setValue(10);
  StyleUtil.setDataFormat(sheet1,4,4,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(30);
  StyleUtil.setDataFormat(sheet1,5,4,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(50);
  StyleUtil.setDataFormat(sheet1,6,4,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(70);
  StyleUtil.setDataFormat(sheet1,7,4,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
  sheet1.getCell(""String_Node_Str"").setValue(20);
  StyleUtil.setDataFormat(sheet1,4,5,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(40);
  StyleUtil.setDataFormat(sheet1,5,5,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(60);
  StyleUtil.setDataFormat(sheet1,6,5,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(80);
  StyleUtil.setDataFormat(sheet1,7,5,""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
  sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
  sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
  NChart chart=sheet1.addChart(NChartType.LINE,new NViewAnchor(0,9,600,400));
  chart.setLegendPosition(NChartLegendPosition.RIGHT);
  NGeneralChartData data=(NGeneralChartData)chart.getData();
  data.setCategoriesFormula(""String_Node_Str"");
  data.addSeries().setFormula(""String_Node_Str"",""String_Node_Str"");
  data.addSeries().setFormula(""String_Node_Str"",""String_Node_Str"");
  data.addSeries().setFormula(""String_Node_Str"",""String_Node_Str"");
}",0.9230769230769232
56478,"@Override public NImporter createImporter(){
  return new AbstractImporter(){
    @Override public NBook imports(    InputStream is,    String bookName) throws IOException {
      NBook book=NBooks.createBook(bookName);
      buildCopyPaste(book);
      buildMove(book);
      buildMerge(book);
      buildAutoFilter(book);
      buildValidation(book);
      buildChartSheet(book);
      buildNormalSheet(book);
      buildFreeze(book);
      return book;
    }
    private void buildCopyPaste(    NBook book){
      NSheet sheet1=book.createSheet(""String_Node_Str"");
      NCellStyle totalStyle=book.createCellStyle(true);
      totalStyle.setDataFormat(""String_Node_Str"");
      totalStyle.setBorderBottom(BorderType.MEDIUM,book.createColor(""String_Node_Str""));
      NCellStyle headerStyle=book.createCellStyle(true);
      headerStyle.setFillColor(book.createColor(""String_Node_Str""));
      headerStyle.setFillPattern(FillPattern.SOLID_FOREGROUND);
      headerStyle.setAlignment(Alignment.CENTER);
      sheet1.getColumn(3).setWidth(150);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
      sheet1.getCell(""String_Node_Str"").setValue(10);
      StyleUtil.setDataFormat(sheet1,4,4,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(30);
      StyleUtil.setDataFormat(sheet1,5,4,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(50);
      StyleUtil.setDataFormat(sheet1,6,4,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(70);
      StyleUtil.setDataFormat(sheet1,7,4,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
      sheet1.getCell(""String_Node_Str"").setValue(20);
      StyleUtil.setDataFormat(sheet1,4,5,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(40);
      StyleUtil.setDataFormat(sheet1,5,5,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(60);
      StyleUtil.setDataFormat(sheet1,6,5,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(80);
      StyleUtil.setDataFormat(sheet1,7,5,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
    }
    private void buildMove(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(3);
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
    }
    private void buildMerge(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(""String_Node_Str""));
      NCellStyle style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getCell(""String_Node_Str"").setCellStyle(style);
      sheet.addMergedRegion(new CellRegion(""String_Node_Str""));
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getCell(""String_Node_Str"").setCellStyle(style);
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getCell(""String_Node_Str"").setCellStyle(style);
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
    }
    private void buildAutoFilter(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(1);
      sheet.getCell(""String_Node_Str"").setValue(2);
      sheet.getCell(""String_Node_Str"").setValue(3);
      sheet.getCell(""String_Node_Str"").setValue(1);
      sheet.getCell(""String_Node_Str"").setValue(3);
      sheet.getCell(""String_Node_Str"").setValue(4);
      sheet.getCell(""String_Node_Str"").setValue(5);
      sheet.getCell(""String_Node_Str"").setValue(6);
      sheet.getCell(""String_Node_Str"").setValue(5);
      sheet.getCell(""String_Node_Str"").setValue(5);
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").enableAutoFilter(true);
    }
    private void buildValidation(    NBook book){
      NSheet sheet1=book.createSheet(""String_Node_Str"");
      NRanges.range(sheet1,0,0).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,0,1).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,0,2).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,1,0).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,1,1).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,1,2).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,2,0).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,2,1).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,2,2).setEditText(""String_Node_Str"");
      NDataValidation dv0=sheet1.addDataValidation(new CellRegion(0,3));
      dv0.addRegion(new CellRegion(0,4,0,10));
      dv0.setValidationType(ValidationType.LIST);
      dv0.setShowPromptBox(true);
      dv0.setPromptBox(""String_Node_Str"",""String_Node_Str"");
      dv0.setShowErrorBox(true);
      dv0.setErrorBox(""String_Node_Str"",""String_Node_Str"");
      dv0.setShowDropDownArrow(true);
      dv0.setFormula(""String_Node_Str"");
      NDataValidation dv1=sheet1.addDataValidation(new CellRegion(1,3));
      dv1.setValidationType(ValidationType.LIST);
      dv1.setFormula(""String_Node_Str"");
      dv1.setShowErrorBox(true);
      dv1.setErrorBox(""String_Node_Str"",""String_Node_Str"");
      dv1.setShowDropDownArrow(true);
      NDataValidation dv2=sheet1.addDataValidation(new CellRegion(2,3));
      dv2.setValidationType(ValidationType.LIST);
      dv2.setFormula(""String_Node_Str"");
      dv2.setShowDropDownArrow(true);
      dv2.setShowErrorBox(true);
      NDataValidation dv3=sheet1.addDataValidation(new CellRegion(3,3));
      dv3.setValidationType(ValidationType.LIST);
      dv3.setFormula(""String_Node_Str"");
      dv3.setShowDropDownArrow(true);
      dv3.setShowErrorBox(true);
    }
    private void buildFreeze(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getViewInfo().setNumOfColumnFreeze(5);
      sheet.getViewInfo().setNumOfRowFreeze(7);
      sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(3,3,600,300));
    }
    private void buildChartSheet(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getViewInfo().setNumOfRowFreeze(6);
      sheet.getCell(0,0).setValue(""String_Node_Str"");
      sheet.getCell(0,1).setValue(""String_Node_Str"");
      sheet.getCell(0,2).setValue(""String_Node_Str"");
      sheet.getCell(0,3).setValue(""String_Node_Str"");
      sheet.getCell(0,4).setValue(""String_Node_Str"");
      sheet.getCell(0,5).setValue(""String_Node_Str"");
      sheet.getCell(1,0).setValue(""String_Node_Str"");
      sheet.getCell(2,0).setValue(""String_Node_Str"");
      sheet.getCell(3,0).setValue(""String_Node_Str"");
      sheet.getCell(4,0).setValue(""String_Node_Str"");
      sheet.getCell(5,0).setValue(""String_Node_Str"");
      sheet.getCell(6,0).setValue(""String_Node_Str"");
      NCellStyle style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      sheet.getCell(1,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(1,7).setCellStyle(style);
      sheet.getCell(2,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(2,7).setCellStyle(style);
      sheet.getCell(3,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(3,7).setCellStyle(style);
      sheet.getCell(4,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(4,7).setCellStyle(style);
      sheet.getCell(5,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(5,7).setCellStyle(style);
      sheet.getCell(6,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(6,7).setCellStyle(style);
      sheet.getCell(1,1).setValue(1);
      sheet.getCell(2,1).setValue(2);
      sheet.getCell(3,1).setValue(3);
      sheet.getCell(4,1).setValue(1);
      sheet.getCell(5,1).setValue(2);
      sheet.getCell(6,1).setValue(3);
      sheet.getCell(1,2).setValue(4);
      sheet.getCell(2,2).setValue(5);
      sheet.getCell(3,2).setValue(6);
      sheet.getCell(4,2).setValue(1);
      sheet.getCell(5,2).setValue(2);
      sheet.getCell(6,2).setValue(3);
      sheet.getCell(1,3).setValue(7);
      sheet.getCell(2,3).setValue(8);
      sheet.getCell(3,3).setValue(9);
      sheet.getCell(4,3).setValue(2);
      sheet.getCell(5,3).setValue(2);
      sheet.getCell(6,3).setValue(3);
      sheet.getCell(1,4).setValue(1);
      sheet.getCell(2,4).setValue(3);
      sheet.getCell(3,4).setValue(5);
      sheet.getCell(4,4).setValue(2);
      sheet.getCell(5,4).setValue(2);
      sheet.getCell(6,4).setValue(3);
      sheet.getCell(1,5).setValue(2);
      sheet.getCell(2,5).setValue(6);
      sheet.getCell(3,5).setValue(9);
      sheet.getCell(4,5).setValue(3);
      sheet.getCell(5,5).setValue(2);
      sheet.getCell(6,5).setValue(3);
      sheet.getCell(1,6).setValue(1);
      sheet.getCell(2,6).setValue(4);
      sheet.getCell(3,6).setValue(8);
      sheet.getCell(4,6).setValue(3);
      sheet.getCell(5,6).setValue(2);
      sheet.getCell(6,6).setValue(3);
      NChart chart=sheet.addChart(NChartType.PIE,new NViewAnchor(1,12,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.PIE,new NViewAnchor(1,18,300,200));
      buildChartData(chart);
      chart.setTitle(""String_Node_Str"");
      chart.setThreeD(true);
      chart=sheet.addChart(NChartType.BAR,new NViewAnchor(12,0,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.BOTTOM);
      chart=sheet.addChart(NChartType.BAR,new NViewAnchor(12,6,300,200));
      buildChartData(chart);
      chart.setThreeD(true);
      chart=sheet.addChart(NChartType.COLUMN,new NViewAnchor(12,12,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.LEFT);
      chart=sheet.addChart(NChartType.COLUMN,new NViewAnchor(12,18,300,200));
      buildChartData(chart);
      chart.setThreeD(true);
      chart=sheet.addChart(NChartType.DOUGHNUT,new NViewAnchor(12,18,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.LINE,new NViewAnchor(24,0,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.TOP);
      chart=sheet.addChart(NChartType.LINE,new NViewAnchor(24,6,300,200));
      buildChartData(chart);
      chart.setThreeD(true);
      chart=sheet.addChart(NChartType.AREA,new NViewAnchor(24,12,300,200));
      buildChartData(chart);
      chart=sheet.addChart(NChartType.SCATTER,new NViewAnchor(36,0,300,200));
      buildScatterChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.BUBBLE,new NViewAnchor(36,6,300,200));
      buildBubbleChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.STOCK,new NViewAnchor(36,12,600,200));
      buildStockChartData(chart);
    }
    private Date newDate(    String string){
      SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
      try {
        return sdf.parse(string);
      }
 catch (      ParseException e) {
        e.printStackTrace();
      }
      return null;
    }
    private void buildStockChartData(    NChart chart){
      NGeneralChartData data=(NGeneralChartData)chart.getData();
      data.setCategoriesFormula(""String_Node_Str"");
      NSeries series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
    }
    private void buildBubbleChartData(    NChart chart){
      NGeneralChartData data=(NGeneralChartData)chart.getData();
      NSeries series=data.addSeries();
      series.setXYZFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setXYZFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
    private void buildScatterChartData(    NChart chart){
      NGeneralChartData data=(NGeneralChartData)chart.getData();
      NSeries series=data.addSeries();
      series.setXYFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setXYFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
    private void buildChartData(    NChart chart){
      NGeneralChartData data=(NGeneralChartData)chart.getData();
      data.setCategoriesFormula(""String_Node_Str"");
      NSeries series=data.addSeries();
      series.setXYFormula(""String_Node_Str"",""String_Node_Str"",null);
      series=data.addSeries();
      series.setXYFormula(""String_Node_Str"",""String_Node_Str"",null);
      series=data.addSeries();
      series.setXYFormula(null,""String_Node_Str"",null);
    }
    private void buildNormalSheet(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getColumn(0).setWidth(120);
      sheet.getColumn(1).setWidth(120);
      sheet.getColumn(2).setWidth(120);
      sheet.getColumn(3).setWidth(120);
      sheet.getColumn(4).setWidth(120);
      sheet.getColumn(5).setWidth(120);
      sheet.getColumn(6).setWidth(120);
      sheet.getCell(0,11).setStringValue(""String_Node_Str"");
      sheet.getColumn(12).setHidden(true);
      sheet.getColumn(14).setHidden(true);
      sheet.getCell(15,0).setStringValue(""String_Node_Str"");
      sheet.getRow(16).setHidden(true);
      sheet.getRow(18).setHidden(true);
      NCellStyle style;
      NCell cell;
      SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
      Date now=new Date();
      Date dayonly=null;
      try {
        dayonly=sdf.parse(sdf.format(now));
      }
 catch (      ParseException e) {
        e.printStackTrace();
      }
      (cell=sheet.getCell(0,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(0,1)).setValue(123.45);
      (cell=sheet.getCell(0,2)).setValue(now);
      (cell=sheet.getCell(0,3)).setValue(Boolean.TRUE);
      (cell=sheet.getCell(1,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(1,1)).setValue(33);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,2)).setValue(44.55);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,3)).setValue(77.88);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,4)).setValue(-77.88);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(2,1)).setValue(dayonly);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,2)).setValue(dayonly);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,3)).setValue(now);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,4)).setValue(now);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(3,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(3,1)).setNumberValue(1D);
      (cell=sheet.getCell(3,2)).setNumberValue(2D);
      (cell=sheet.getCell(3,3)).setNumberValue(3D);
      (cell=sheet.getCell(3,4)).setFormulaValue(""String_Node_Str"");
      (cell=sheet.getCell(4,0)).setStringValue(""String_Node_Str"");
      (cell=sheet.getCell(5,0)).setStringValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(5,0,5,2));
      (cell=sheet.getCell(5,3)).setStringValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(5,3,6,4));
      cell=sheet.getCell(9,6);
      cell.setStringValue(""String_Node_Str"");
      style=book.createCellStyle(true);
      style.setFont(book.createFont(true));
      style.getFont().setColor(book.createColor(""String_Node_Str""));
      style.getFont().setHeightPoints(16);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getColumn(6).setWidth(150);
      sheet.getRow(9).setHeight(100);
      style.setAlignment(Alignment.RIGHT);
      style.setVerticalAlignment(VerticalAlignment.CENTER);
      style.setBorderTop(BorderType.THIN);
      style.setBorderBottom(BorderType.THIN);
      style.setBorderLeft(BorderType.THIN);
      style.setBorderRight(BorderType.THIN);
      style.setBorderTopColor(book.createColor(""String_Node_Str""));
      style.setBorderBottomColor(book.createColor(""String_Node_Str""));
      style.setBorderLeftColor(book.createColor(""String_Node_Str""));
      style.setBorderRightColor(book.createColor(""String_Node_Str""));
      cell.setCellStyle(style);
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getRow(17).setCellStyle(style);
      sheet.getCell(17,0).setStringValue(""String_Node_Str"");
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getColumn(17).setCellStyle(style);
      sheet.getColumn(17).setWidth(100);
      sheet.getCell(0,17).setStringValue(""String_Node_Str"");
      sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(12,3,30,5,600,300));
      sheet=book.createSheet(""String_Node_Str"");
      sheet.getCell(0,0).setValue(""String_Node_Str"");
    }
    private byte[] getTestImageData(){
      InputStream is=null;
      try {
        is=getClass().getResourceAsStream(""String_Node_Str"");
        ByteArrayOutputStream os=new ByteArrayOutputStream();
        byte[] b=new byte[1024];
        int r;
        while ((r=is.read(b)) != -1) {
          os.write(b,0,r);
        }
        return os.toByteArray();
      }
 catch (      IOException e) {
        throw new RuntimeException(e.getMessage(),e);
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
;
}","@Override public NImporter createImporter(){
  return new AbstractImporter(){
    @Override public NBook imports(    InputStream is,    String bookName) throws IOException {
      NBook book=NBooks.createBook(bookName);
      buildCopyPaste(book);
      buildMove(book);
      buildMerge(book);
      buildAutoFilter(book);
      buildValidation(book);
      buildChartSheet(book);
      buildNormalSheet(book);
      buildFreeze(book);
      return book;
    }
    private void buildTest(    NBook book){
      NSheet sheet1=book.createSheet(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(12);
      sheet1.getCell(""String_Node_Str"").setValue(34);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
    }
    private void buildCopyPaste(    NBook book){
      NSheet sheet1=book.createSheet(""String_Node_Str"");
      NCellStyle totalStyle=book.createCellStyle(true);
      totalStyle.setDataFormat(""String_Node_Str"");
      totalStyle.setBorderBottom(BorderType.MEDIUM,book.createColor(""String_Node_Str""));
      NCellStyle headerStyle=book.createCellStyle(true);
      headerStyle.setFillColor(book.createColor(""String_Node_Str""));
      headerStyle.setFillPattern(FillPattern.SOLID_FOREGROUND);
      headerStyle.setAlignment(Alignment.CENTER);
      sheet1.getColumn(3).setWidth(150);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
      sheet1.getCell(""String_Node_Str"").setValue(10);
      StyleUtil.setDataFormat(sheet1,4,4,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(30);
      StyleUtil.setDataFormat(sheet1,5,4,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(50);
      StyleUtil.setDataFormat(sheet1,6,4,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(70);
      StyleUtil.setDataFormat(sheet1,7,4,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
      sheet1.getCell(""String_Node_Str"").setValue(20);
      StyleUtil.setDataFormat(sheet1,4,5,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(40);
      StyleUtil.setDataFormat(sheet1,5,5,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(60);
      StyleUtil.setDataFormat(sheet1,6,5,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(80);
      StyleUtil.setDataFormat(sheet1,7,5,""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(headerStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
      sheet1.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet1.getCell(""String_Node_Str"").setCellStyle(totalStyle);
      NChart chart=sheet1.addChart(NChartType.LINE,new NViewAnchor(0,9,600,400));
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      NGeneralChartData data=(NGeneralChartData)chart.getData();
      data.setCategoriesFormula(""String_Node_Str"");
      data.addSeries().setFormula(""String_Node_Str"",""String_Node_Str"");
      data.addSeries().setFormula(""String_Node_Str"",""String_Node_Str"");
      data.addSeries().setFormula(""String_Node_Str"",""String_Node_Str"");
    }
    private void buildMove(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(3);
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
    }
    private void buildMerge(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(""String_Node_Str""));
      NCellStyle style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getCell(""String_Node_Str"").setCellStyle(style);
      sheet.addMergedRegion(new CellRegion(""String_Node_Str""));
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getCell(""String_Node_Str"").setCellStyle(style);
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getCell(""String_Node_Str"").setCellStyle(style);
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
    }
    private void buildAutoFilter(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(1);
      sheet.getCell(""String_Node_Str"").setValue(2);
      sheet.getCell(""String_Node_Str"").setValue(3);
      sheet.getCell(""String_Node_Str"").setValue(1);
      sheet.getCell(""String_Node_Str"").setValue(3);
      sheet.getCell(""String_Node_Str"").setValue(4);
      sheet.getCell(""String_Node_Str"").setValue(5);
      sheet.getCell(""String_Node_Str"").setValue(6);
      sheet.getCell(""String_Node_Str"").setValue(5);
      sheet.getCell(""String_Node_Str"").setValue(5);
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      sheet.getCell(""String_Node_Str"").setValue(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").setEditText(""String_Node_Str"");
      NRanges.range(sheet,""String_Node_Str"").enableAutoFilter(true);
    }
    private void buildValidation(    NBook book){
      NSheet sheet1=book.createSheet(""String_Node_Str"");
      NRanges.range(sheet1,0,0).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,0,1).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,0,2).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,1,0).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,1,1).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,1,2).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,2,0).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,2,1).setEditText(""String_Node_Str"");
      NRanges.range(sheet1,2,2).setEditText(""String_Node_Str"");
      NDataValidation dv0=sheet1.addDataValidation(new CellRegion(0,3));
      dv0.addRegion(new CellRegion(0,4,0,10));
      dv0.setValidationType(ValidationType.LIST);
      dv0.setShowPromptBox(true);
      dv0.setPromptBox(""String_Node_Str"",""String_Node_Str"");
      dv0.setShowErrorBox(true);
      dv0.setErrorBox(""String_Node_Str"",""String_Node_Str"");
      dv0.setShowDropDownArrow(true);
      dv0.setFormula(""String_Node_Str"");
      NDataValidation dv1=sheet1.addDataValidation(new CellRegion(1,3));
      dv1.setValidationType(ValidationType.LIST);
      dv1.setFormula(""String_Node_Str"");
      dv1.setShowErrorBox(true);
      dv1.setErrorBox(""String_Node_Str"",""String_Node_Str"");
      dv1.setShowDropDownArrow(true);
      NDataValidation dv2=sheet1.addDataValidation(new CellRegion(2,3));
      dv2.setValidationType(ValidationType.LIST);
      dv2.setFormula(""String_Node_Str"");
      dv2.setShowDropDownArrow(true);
      dv2.setShowErrorBox(true);
      NDataValidation dv3=sheet1.addDataValidation(new CellRegion(3,3));
      dv3.setValidationType(ValidationType.LIST);
      dv3.setFormula(""String_Node_Str"");
      dv3.setShowDropDownArrow(true);
      dv3.setShowErrorBox(true);
    }
    private void buildFreeze(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getViewInfo().setNumOfColumnFreeze(5);
      sheet.getViewInfo().setNumOfRowFreeze(7);
      sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(3,3,600,300));
    }
    private void buildChartSheet(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getViewInfo().setNumOfRowFreeze(6);
      sheet.getCell(0,0).setValue(""String_Node_Str"");
      sheet.getCell(0,1).setValue(""String_Node_Str"");
      sheet.getCell(0,2).setValue(""String_Node_Str"");
      sheet.getCell(0,3).setValue(""String_Node_Str"");
      sheet.getCell(0,4).setValue(""String_Node_Str"");
      sheet.getCell(0,5).setValue(""String_Node_Str"");
      sheet.getCell(1,0).setValue(""String_Node_Str"");
      sheet.getCell(2,0).setValue(""String_Node_Str"");
      sheet.getCell(3,0).setValue(""String_Node_Str"");
      sheet.getCell(4,0).setValue(""String_Node_Str"");
      sheet.getCell(5,0).setValue(""String_Node_Str"");
      sheet.getCell(6,0).setValue(""String_Node_Str"");
      NCellStyle style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      sheet.getCell(1,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(1,7).setCellStyle(style);
      sheet.getCell(2,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(2,7).setCellStyle(style);
      sheet.getCell(3,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(3,7).setCellStyle(style);
      sheet.getCell(4,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(4,7).setCellStyle(style);
      sheet.getCell(5,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(5,7).setCellStyle(style);
      sheet.getCell(6,7).setValue(newDate(""String_Node_Str""));
      sheet.getCell(6,7).setCellStyle(style);
      sheet.getCell(1,1).setValue(1);
      sheet.getCell(2,1).setValue(2);
      sheet.getCell(3,1).setValue(3);
      sheet.getCell(4,1).setValue(1);
      sheet.getCell(5,1).setValue(2);
      sheet.getCell(6,1).setValue(3);
      sheet.getCell(1,2).setValue(4);
      sheet.getCell(2,2).setValue(5);
      sheet.getCell(3,2).setValue(6);
      sheet.getCell(4,2).setValue(1);
      sheet.getCell(5,2).setValue(2);
      sheet.getCell(6,2).setValue(3);
      sheet.getCell(1,3).setValue(7);
      sheet.getCell(2,3).setValue(8);
      sheet.getCell(3,3).setValue(9);
      sheet.getCell(4,3).setValue(2);
      sheet.getCell(5,3).setValue(2);
      sheet.getCell(6,3).setValue(3);
      sheet.getCell(1,4).setValue(1);
      sheet.getCell(2,4).setValue(3);
      sheet.getCell(3,4).setValue(5);
      sheet.getCell(4,4).setValue(2);
      sheet.getCell(5,4).setValue(2);
      sheet.getCell(6,4).setValue(3);
      sheet.getCell(1,5).setValue(2);
      sheet.getCell(2,5).setValue(6);
      sheet.getCell(3,5).setValue(9);
      sheet.getCell(4,5).setValue(3);
      sheet.getCell(5,5).setValue(2);
      sheet.getCell(6,5).setValue(3);
      sheet.getCell(1,6).setValue(1);
      sheet.getCell(2,6).setValue(4);
      sheet.getCell(3,6).setValue(8);
      sheet.getCell(4,6).setValue(3);
      sheet.getCell(5,6).setValue(2);
      sheet.getCell(6,6).setValue(3);
      NChart chart=sheet.addChart(NChartType.PIE,new NViewAnchor(1,12,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.PIE,new NViewAnchor(1,18,300,200));
      buildChartData(chart);
      chart.setTitle(""String_Node_Str"");
      chart.setThreeD(true);
      chart=sheet.addChart(NChartType.BAR,new NViewAnchor(12,0,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.BOTTOM);
      chart=sheet.addChart(NChartType.BAR,new NViewAnchor(12,6,300,200));
      buildChartData(chart);
      chart.setThreeD(true);
      chart=sheet.addChart(NChartType.COLUMN,new NViewAnchor(12,12,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.LEFT);
      chart=sheet.addChart(NChartType.COLUMN,new NViewAnchor(12,18,300,200));
      buildChartData(chart);
      chart.setThreeD(true);
      chart=sheet.addChart(NChartType.DOUGHNUT,new NViewAnchor(12,18,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.LINE,new NViewAnchor(24,0,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.TOP);
      chart=sheet.addChart(NChartType.LINE,new NViewAnchor(24,6,300,200));
      buildChartData(chart);
      chart.setThreeD(true);
      chart=sheet.addChart(NChartType.AREA,new NViewAnchor(24,12,300,200));
      buildChartData(chart);
      chart=sheet.addChart(NChartType.SCATTER,new NViewAnchor(36,0,300,200));
      buildScatterChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.BUBBLE,new NViewAnchor(36,6,300,200));
      buildBubbleChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.STOCK,new NViewAnchor(36,12,600,200));
      buildStockChartData(chart);
    }
    private Date newDate(    String string){
      SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
      try {
        return sdf.parse(string);
      }
 catch (      ParseException e) {
        e.printStackTrace();
      }
      return null;
    }
    private void buildStockChartData(    NChart chart){
      NGeneralChartData data=(NGeneralChartData)chart.getData();
      data.setCategoriesFormula(""String_Node_Str"");
      NSeries series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"");
    }
    private void buildBubbleChartData(    NChart chart){
      NGeneralChartData data=(NGeneralChartData)chart.getData();
      NSeries series=data.addSeries();
      series.setXYZFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setXYZFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
    private void buildScatterChartData(    NChart chart){
      NGeneralChartData data=(NGeneralChartData)chart.getData();
      NSeries series=data.addSeries();
      series.setXYFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      series=data.addSeries();
      series.setXYFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
    private void buildChartData(    NChart chart){
      NGeneralChartData data=(NGeneralChartData)chart.getData();
      data.setCategoriesFormula(""String_Node_Str"");
      NSeries series=data.addSeries();
      series.setXYFormula(""String_Node_Str"",""String_Node_Str"",null);
      series=data.addSeries();
      series.setXYFormula(""String_Node_Str"",""String_Node_Str"",null);
      series=data.addSeries();
      series.setXYFormula(null,""String_Node_Str"",null);
    }
    private void buildNormalSheet(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getColumn(0).setWidth(120);
      sheet.getColumn(1).setWidth(120);
      sheet.getColumn(2).setWidth(120);
      sheet.getColumn(3).setWidth(120);
      sheet.getColumn(4).setWidth(120);
      sheet.getColumn(5).setWidth(120);
      sheet.getColumn(6).setWidth(120);
      sheet.getCell(0,11).setStringValue(""String_Node_Str"");
      sheet.getColumn(12).setHidden(true);
      sheet.getColumn(14).setHidden(true);
      sheet.getCell(15,0).setStringValue(""String_Node_Str"");
      sheet.getRow(16).setHidden(true);
      sheet.getRow(18).setHidden(true);
      NCellStyle style;
      NCell cell;
      SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
      Date now=new Date();
      Date dayonly=null;
      try {
        dayonly=sdf.parse(sdf.format(now));
      }
 catch (      ParseException e) {
        e.printStackTrace();
      }
      (cell=sheet.getCell(0,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(0,1)).setValue(123.45);
      (cell=sheet.getCell(0,2)).setValue(now);
      (cell=sheet.getCell(0,3)).setValue(Boolean.TRUE);
      (cell=sheet.getCell(1,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(1,1)).setValue(33);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,2)).setValue(44.55);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,3)).setValue(77.88);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,4)).setValue(-77.88);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(2,1)).setValue(dayonly);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,2)).setValue(dayonly);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,3)).setValue(now);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,4)).setValue(now);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(3,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(3,1)).setNumberValue(1D);
      (cell=sheet.getCell(3,2)).setNumberValue(2D);
      (cell=sheet.getCell(3,3)).setNumberValue(3D);
      (cell=sheet.getCell(3,4)).setFormulaValue(""String_Node_Str"");
      (cell=sheet.getCell(4,0)).setStringValue(""String_Node_Str"");
      (cell=sheet.getCell(5,0)).setStringValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(5,0,5,2));
      (cell=sheet.getCell(5,3)).setStringValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(5,3,6,4));
      cell=sheet.getCell(9,6);
      cell.setStringValue(""String_Node_Str"");
      style=book.createCellStyle(true);
      style.setFont(book.createFont(true));
      style.getFont().setColor(book.createColor(""String_Node_Str""));
      style.getFont().setHeightPoints(16);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getColumn(6).setWidth(150);
      sheet.getRow(9).setHeight(100);
      style.setAlignment(Alignment.RIGHT);
      style.setVerticalAlignment(VerticalAlignment.CENTER);
      style.setBorderTop(BorderType.THIN);
      style.setBorderBottom(BorderType.THIN);
      style.setBorderLeft(BorderType.THIN);
      style.setBorderRight(BorderType.THIN);
      style.setBorderTopColor(book.createColor(""String_Node_Str""));
      style.setBorderBottomColor(book.createColor(""String_Node_Str""));
      style.setBorderLeftColor(book.createColor(""String_Node_Str""));
      style.setBorderRightColor(book.createColor(""String_Node_Str""));
      cell.setCellStyle(style);
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getRow(17).setCellStyle(style);
      sheet.getCell(17,0).setStringValue(""String_Node_Str"");
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getColumn(17).setCellStyle(style);
      sheet.getColumn(17).setWidth(100);
      sheet.getCell(0,17).setStringValue(""String_Node_Str"");
      sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(12,3,30,5,600,300));
      sheet=book.createSheet(""String_Node_Str"");
      sheet.getCell(0,0).setValue(""String_Node_Str"");
    }
    private byte[] getTestImageData(){
      InputStream is=null;
      try {
        is=getClass().getResourceAsStream(""String_Node_Str"");
        ByteArrayOutputStream os=new ByteArrayOutputStream();
        byte[] b=new byte[1024];
        int r;
        while ((r=is.read(b)) != -1) {
          os.write(b,0,r);
        }
        return os.toByteArray();
      }
 catch (      IOException e) {
        throw new RuntimeException(e.getMessage(),e);
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
;
}",0.983538915913829
56479,"void rebuildFormulaDependency(){
  if (getType() == CellType.FORMULA && lastRef != null) {
    FormulaExpression expr=(FormulaExpression)getValue(false);
    if (!expr.hasError()) {
      clearFormulaDependency();
      FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
      fe.parse(expr.getFormulaString(),new FormulaParseContext(this,getRef()));
    }
  }
}","void rebuildFormulaDependency(){
  if (getType() == CellType.FORMULA && lastRef != null) {
    FormulaExpression expr=(FormulaExpression)getValue(false);
    if (!expr.hasError()) {
      clearFormulaDependency();
      FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
      fe.parse(expr.getFormulaString(),new FormulaParseContext(this,getRef()));
    }
  }
 else   if (lastRef != null) {
    lastRef=null;
  }
}",0.934648581997534
56480,"/** 
 * Convert CellStyle into NCellStyle
 * @param poiCellStyle
 */
protected NCellStyle importCellStyle(CellStyle poiCellStyle){
  NCellStyle cellStyle=null;
  if ((cellStyle=importedStyle.get(poiCellStyle.getIndex())) == null) {
    cellStyle=book.createCellStyle(true);
    importedStyle.put(poiCellStyle.getIndex(),cellStyle);
    String dataFormat=null;
    if ((dataFormat=BuiltinFormats.getBuiltinFormat(poiCellStyle.getDataFormat())) == null) {
      dataFormat=poiCellStyle.getDataFormatString();
    }
    cellStyle.setDataFormat(dataFormat);
    cellStyle.setWrapText(poiCellStyle.getWrapText());
    cellStyle.setLocked(poiCellStyle.getLocked());
    cellStyle.setAlignment(convertAlignment(poiCellStyle.getAlignment()));
    cellStyle.setVerticalAlignment(convertVerticalAlignment(poiCellStyle.getVerticalAlignment()));
    cellStyle.setFillColor(book.createColor(BookHelper.colorToBackgroundHTML(workbook,poiCellStyle.getFillForegroundColorColor())));
    cellStyle.setBorderLeft(convertBorderType(poiCellStyle.getBorderLeft()));
    cellStyle.setBorderTop(convertBorderType(poiCellStyle.getBorderTop()));
    cellStyle.setBorderRight(convertBorderType(poiCellStyle.getBorderRight()));
    cellStyle.setBorderBottom(convertBorderType(poiCellStyle.getBorderBottom()));
    cellStyle.setBorderLeftColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getLeftBorderColorColor())));
    cellStyle.setBorderTopColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getTopBorderColorColor())));
    cellStyle.setBorderRightColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getRightBorderColorColor())));
    cellStyle.setBorderBottomColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getBottomBorderColorColor())));
    cellStyle.setHidden(poiCellStyle.getHidden());
    cellStyle.setFillPattern(convertPoiFillPattern(poiCellStyle.getFillPattern()));
    cellStyle.setFont(importFont(poiCellStyle));
  }
  return cellStyle;
}","/** 
 * Convert CellStyle into NCellStyle
 * @param poiCellStyle
 */
protected NCellStyle importCellStyle(CellStyle poiCellStyle){
  NCellStyle cellStyle=null;
  if ((cellStyle=importedStyle.get(poiCellStyle.getIndex())) == null) {
    cellStyle=book.createCellStyle(true);
    importedStyle.put(poiCellStyle.getIndex(),cellStyle);
    String dataFormat=null;
    if ((dataFormat=BuiltinFormats.getBuiltinFormat(poiCellStyle.getDataFormat())) == null) {
      dataFormat=poiCellStyle.getDataFormatString();
    }
    if (dataFormat == null) {
      dataFormat=NCellStyle.FORMAT_GENERAL;
    }
    cellStyle.setDataFormat(dataFormat);
    cellStyle.setWrapText(poiCellStyle.getWrapText());
    cellStyle.setLocked(poiCellStyle.getLocked());
    cellStyle.setAlignment(convertAlignment(poiCellStyle.getAlignment()));
    cellStyle.setVerticalAlignment(convertVerticalAlignment(poiCellStyle.getVerticalAlignment()));
    cellStyle.setFillColor(book.createColor(BookHelper.colorToBackgroundHTML(workbook,poiCellStyle.getFillForegroundColorColor())));
    cellStyle.setBorderLeft(convertBorderType(poiCellStyle.getBorderLeft()));
    cellStyle.setBorderTop(convertBorderType(poiCellStyle.getBorderTop()));
    cellStyle.setBorderRight(convertBorderType(poiCellStyle.getBorderRight()));
    cellStyle.setBorderBottom(convertBorderType(poiCellStyle.getBorderBottom()));
    cellStyle.setBorderLeftColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getLeftBorderColorColor())));
    cellStyle.setBorderTopColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getTopBorderColorColor())));
    cellStyle.setBorderRightColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getRightBorderColorColor())));
    cellStyle.setBorderBottomColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getBottomBorderColorColor())));
    cellStyle.setHidden(poiCellStyle.getHidden());
    cellStyle.setFillPattern(convertPoiFillPattern(poiCellStyle.getFillPattern()));
    cellStyle.setFont(importFont(poiCellStyle));
  }
  return cellStyle;
}",0.9805825242718448
56481,"@Override public void setDataFormat(String dataFormat){
  Validations.argNotNull(dataFormat);
  this.dataFormat=dataFormat;
}","@Override public void setDataFormat(String dataFormat){
  if (dataFormat == null) {
    dataFormat=FORMAT_GENERAL;
  }
  this.dataFormat=dataFormat;
}",0.7563636363636363
56482,"/** 
 * Convert CellStyle into NCellStyle
 * @param poiCellStyle
 */
protected NCellStyle importCellStyle(CellStyle poiCellStyle){
  NCellStyle cellStyle=null;
  if ((cellStyle=importedStyle.get(poiCellStyle.getIndex())) == null) {
    cellStyle=book.createCellStyle(true);
    importedStyle.put(poiCellStyle.getIndex(),cellStyle);
    String dataFormat=null;
    if ((dataFormat=BuiltinFormats.getBuiltinFormat(poiCellStyle.getDataFormat())) == null) {
      dataFormat=poiCellStyle.getDataFormatString();
    }
    if (dataFormat == null) {
      dataFormat=NCellStyle.FORMAT_GENERAL;
    }
    cellStyle.setDataFormat(dataFormat);
    cellStyle.setWrapText(poiCellStyle.getWrapText());
    cellStyle.setLocked(poiCellStyle.getLocked());
    cellStyle.setAlignment(convertAlignment(poiCellStyle.getAlignment()));
    cellStyle.setVerticalAlignment(convertVerticalAlignment(poiCellStyle.getVerticalAlignment()));
    cellStyle.setFillColor(book.createColor(BookHelper.colorToBackgroundHTML(workbook,poiCellStyle.getFillForegroundColorColor())));
    cellStyle.setBorderLeft(convertBorderType(poiCellStyle.getBorderLeft()));
    cellStyle.setBorderTop(convertBorderType(poiCellStyle.getBorderTop()));
    cellStyle.setBorderRight(convertBorderType(poiCellStyle.getBorderRight()));
    cellStyle.setBorderBottom(convertBorderType(poiCellStyle.getBorderBottom()));
    cellStyle.setBorderLeftColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getLeftBorderColorColor())));
    cellStyle.setBorderTopColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getTopBorderColorColor())));
    cellStyle.setBorderRightColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getRightBorderColorColor())));
    cellStyle.setBorderBottomColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getBottomBorderColorColor())));
    cellStyle.setHidden(poiCellStyle.getHidden());
    cellStyle.setFillPattern(convertPoiFillPattern(poiCellStyle.getFillPattern()));
    cellStyle.setFont(importFont(poiCellStyle));
  }
  return cellStyle;
}","/** 
 * Convert CellStyle into NCellStyle
 * @param poiCellStyle
 */
protected NCellStyle importCellStyle(CellStyle poiCellStyle){
  NCellStyle cellStyle=null;
  short idx=poiCellStyle.getIndex();
  if ((cellStyle=importedStyle.get(idx)) == null) {
    cellStyle=book.createCellStyle(true);
    importedStyle.put(idx,cellStyle);
    String dataFormat=poiCellStyle.getRawDataFormatString();
    if (dataFormat == null) {
      dataFormat=NCellStyle.FORMAT_GENERAL;
    }
    cellStyle.setDataFormat(dataFormat);
    cellStyle.setWrapText(poiCellStyle.getWrapText());
    cellStyle.setLocked(poiCellStyle.getLocked());
    cellStyle.setAlignment(convertAlignment(poiCellStyle.getAlignment()));
    cellStyle.setVerticalAlignment(convertVerticalAlignment(poiCellStyle.getVerticalAlignment()));
    cellStyle.setFillColor(book.createColor(BookHelper.colorToBackgroundHTML(workbook,poiCellStyle.getFillForegroundColorColor())));
    cellStyle.setBorderLeft(convertBorderType(poiCellStyle.getBorderLeft()));
    cellStyle.setBorderTop(convertBorderType(poiCellStyle.getBorderTop()));
    cellStyle.setBorderRight(convertBorderType(poiCellStyle.getBorderRight()));
    cellStyle.setBorderBottom(convertBorderType(poiCellStyle.getBorderBottom()));
    cellStyle.setBorderLeftColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getLeftBorderColorColor())));
    cellStyle.setBorderTopColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getTopBorderColorColor())));
    cellStyle.setBorderRightColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getRightBorderColorColor())));
    cellStyle.setBorderBottomColor(book.createColor(BookHelper.colorToBorderHTML(workbook,poiCellStyle.getBottomBorderColorColor())));
    cellStyle.setHidden(poiCellStyle.getHidden());
    cellStyle.setFillPattern(convertPoiFillPattern(poiCellStyle.getFillPattern()));
    cellStyle.setFont(importFont(poiCellStyle));
  }
  return cellStyle;
}",0.9354917831739024
56483,"public void testInputDateObjectUS(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Date today=new Date();
  String todayStr, todayStrLong;
  Setup.setZssLocale(Locale.US);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  todayStr=Util.getDateFormat(""String_Node_Str"",Setup.getZssLocale()).format(today);
  todayStrLong=Util.getDateFormat(""String_Node_Str"",Setup.getZssLocale()).format(today);
  r.setCellEditText(todayStr);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
  r.getCellData().setValue(today);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStrLong,r.getCellEditText());
  r.getCellData().setValue(Util.getDateOnly(today));
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
  r.getCellData().setValue(Util.getDateOnly(today));
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
}","public void testInputDateObjectUS(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Date today=new Date();
  String todayStr, todayStrLong;
  Setup.setZssLocale(Locale.US);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  todayStr=Util.getDateFormat(""String_Node_Str"",Setup.getZssLocale()).format(today);
  todayStrLong=Util.getDateFormat(""String_Node_Str"",Setup.getZssLocale()).format(today);
  r.setCellEditText(todayStr);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
  r.getCellData().setValue(today);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStrLong,r.getCellEditText());
  r.getCellData().setValue(Util.getDateOnly(today));
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
  r.getCellData().setValue(Util.getDateOnly(today));
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
}",0.9836455545643772
56484,"public void testDateInput1(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.STRING,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.STRING,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.STRING,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}","public void testDateInput1(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.STRING,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.STRING,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.STRING,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}",0.9753271028037384
56485,"public void testDateDisplayNormal2(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}","public void testDateDisplayNormal2(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}",0.9845505617977528
56486,"public void testDateDisplayNormal1(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}","public void testDateDisplayNormal1(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}",0.9845505617977528
56487,"public void testInputDateObjectTW(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Date today=new Date();
  String todayStr;
  String todayStrLong;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  todayStr=new SimpleDateFormat(""String_Node_Str"",Setup.getZssLocale()).format(today);
  todayStrLong=new SimpleDateFormat(""String_Node_Str"",Setup.getZssLocale()).format(today);
  r.setCellEditText(todayStr);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
  r.getCellData().setValue(today);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStrLong,r.getCellEditText());
  r.getCellData().setValue(Util.getDateOnly(today));
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
}","public void testInputDateObjectTW(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Date today=new Date();
  String todayStr;
  String todayStrLong;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  todayStr=new SimpleDateFormat(""String_Node_Str"",Setup.getZssLocale()).format(today);
  todayStrLong=new SimpleDateFormat(""String_Node_Str"",Setup.getZssLocale()).format(today);
  r.setCellEditText(todayStr);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
  r.getCellData().setValue(today);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStrLong,r.getCellEditText());
  r.getCellData().setValue(Util.getDateOnly(today));
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(todayStr,r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(todayStr,r.getCellEditText());
}",0.98429693076374
56488,"public void testDateDisplaySpecial1(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}","public void testDateDisplaySpecial1(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}",0.984561403508772
56489,"public void testDateDisplaySpecial2(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}","public void testDateDisplaySpecial2(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.TAIWAN);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}",0.984561403508772
56490,"public void testDateDisplaySpecial3(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.US);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellStyle().getDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}","public void testDateDisplaySpecial3(Book book){
  Sheet sheet=book.getSheetAt(0);
  Range r;
  Setup.setZssLocale(Locale.US);
  r=Ranges.range(sheet,""String_Node_Str"");
  r.setCellEditText(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  CellOperationUtil.applyDataFormat(r,""String_Node_Str"");
  Setup.setZssLocale(Locale.TAIWAN);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.US);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
  Setup.setZssLocale(Locale.UK);
  Assert.assertEquals(""String_Node_Str"",r.getCellDataFormat());
  Assert.assertEquals(""String_Node_Str"",r.getCellFormatText());
  Assert.assertEquals(CellType.NUMERIC,r.getCellData().getType());
  Assert.assertEquals(""String_Node_Str"",r.getCellEditText());
}",0.984517945109078
56491,"/** 
 * Gets the first cell(top-left) format text of this range
 * @return format text
 * @see CellData#getFormatText()
 */
public String getCellFormatText();","/** 
 * Gets the first cell(top-left) formatted text of this range
 * @return format text
 * @see CellData#getFormatText()
 */
public String getCellFormatText();",0.9905956112852664
56492,"/** 
 * Gets the first(top-left) cell's formatted text
 * @return
 */
public String getCellFormatText();","/** 
 * Gets the first(top-left) cell's formatted text, if the cell's format is the special LOCALE aware format (such as m/d/yyyy),  it will formats the value by transferred format (e.g m/d/yyyy will transfer to yyyy/m/d in TW locale) 
 * @return
 */
public String getCellFormatText();",0.5347043701799485
56493,"protected void exportNamedRange(NBook book){
  for (  NName name : book.getNames()) {
    Name poiName=workbook.createName();
    poiName.setNameName(name.getName());
    poiName.setSheetIndex(workbook.getSheetIndex(name.getRefersToSheetName()));
    poiName.setRefersToFormula(name.getRefersToFormula());
  }
}","protected void exportNamedRange(NBook book){
  for (  NName name : book.getNames()) {
    Name poiName=workbook.createName();
    poiName.setNameName(name.getName());
    String sheetName=name.getRefersToSheetName();
    if (sheetName != null) {
      poiName.setSheetIndex(workbook.getSheetIndex(sheetName));
    }
    poiName.setRefersToFormula(name.getRefersToFormula());
  }
}",0.5962373371924746
56494,"@Override public void deleteSheet(NSheet sheet){
  checkOwnership(sheet);
  ((AbstractSheetAdv)sheet).destroy();
  int index=sheets.indexOf(sheet);
  sheets.remove(index);
  EngineFactory.getInstance().createFormulaEngine().clearCache(new FormulaClearContext(this));
  sendModelInternalEvent(ModelInternalEvents.createModelInternalEvent(ModelInternalEvents.ON_SHEET_DELETED,this,ModelInternalEvents.createDataMap(ModelInternalEvents.PARAM_SHEET_OLD_INDEX,index)));
  ModelUpdateUtil.handlePrecedentUpdate(getBookSeries(),new RefImpl(this.getBookName(),sheet.getSheetName()));
}","@Override public void deleteSheet(NSheet sheet){
  checkOwnership(sheet);
  destroyingSheet.set(sheet);
  try {
    ((AbstractSheetAdv)sheet).destroy();
  }
  finally {
    destroyingSheet.set(null);
  }
  int index=sheets.indexOf(sheet);
  sheets.remove(index);
  EngineFactory.getInstance().createFormulaEngine().clearCache(new FormulaClearContext(this));
  sendModelInternalEvent(ModelInternalEvents.createModelInternalEvent(ModelInternalEvents.ON_SHEET_DELETED,this,ModelInternalEvents.createDataMap(ModelInternalEvents.PARAM_SHEET_OLD_INDEX,index)));
  ModelUpdateUtil.handlePrecedentUpdate(getBookSeries(),new RefImpl(this.getBookName(),sheet.getSheetName()));
}",0.9269076305220884
56495,"@Override public void clearValue(){
  checkOrphan();
  validateDataGridValue(null);
  setDataGridValue(null);
  clearFormulaDependency();
  clearFormulaResultCache();
  OptFields opts=getOpts(false);
  if (opts != null) {
    opts.hyperlink=null;
  }
  ;
  addCellUpdate();
}","@Override public void clearValue(){
  checkOrphan();
  validateDataGridValue(null);
  setDataGridValue(null);
  clearFormulaDependency();
  clearFormulaResultCache();
  OptFields opts=getOpts(false);
  if (opts != null) {
    opts.hyperlink=null;
  }
  ;
  if (BookImpl.destroyingSheet.get() != getSheet()) {
    addCellUpdate();
  }
}",0.9016393442622952
56496,"@SuppressWarnings(""String_Node_Str"") public void merge(boolean across){
  int tRow=range.getRow();
  int lCol=range.getColumn();
  int bRow=range.getLastColumn();
  int rCol=range.getLastColumn();
  List<CellRegion> overlaps=sheet.getOverlapsMergedRegions(new CellRegion(tRow,lCol,bRow,rCol));
  if (overlaps != null && overlaps.size() > 0) {
    throw new InvalidateModelOpException(""String_Node_Str"" + overlaps.get(0).getReferenceString() + ""String_Node_Str"");
  }
  if (across) {
    for (int r=tRow; r <= bRow; ++r) {
      merge0(sheet,r,lCol,r,rCol);
    }
  }
 else {
    merge0(sheet,tRow,lCol,bRow,rCol);
  }
}","@SuppressWarnings(""String_Node_Str"") public void merge(boolean across){
  int tRow=range.getRow();
  int lCol=range.getColumn();
  int bRow=range.getLastRow();
  int rCol=range.getLastColumn();
  List<CellRegion> overlaps=sheet.getOverlapsMergedRegions(new CellRegion(tRow,lCol,bRow,rCol));
  if (overlaps != null && overlaps.size() > 0) {
    throw new InvalidateModelOpException(""String_Node_Str"" + overlaps.get(0).getReferenceString() + ""String_Node_Str"");
  }
  if (across) {
    for (int r=tRow; r <= bRow; ++r) {
      merge0(sheet,r,lCol,r,rCol);
    }
  }
 else {
    merge0(sheet,tRow,lCol,bRow,rCol);
  }
}",0.9927125506072876
56497,"private void importAutoFilter(Sheet poiSheet,NSheet sheet){
  AutoFilter poiAutoFilter=poiSheet.getAutoFilter();
  if (poiAutoFilter != null) {
    NAutoFilter autoFilter=sheet.createAutoFilter(new CellRegion(poiAutoFilter.getRangeAddress().formatAsString()));
    for (int i=0; i < poiAutoFilter.getFilterColumns().size(); i++) {
      FilterColumn srcColumn=poiAutoFilter.getFilterColumn(i);
      NFilterColumn destColumn=autoFilter.getFilterColumn(i,true);
      destColumn.setProperties(toFilterOperator(srcColumn.getOperator()),srcColumn.getCriteria1(),srcColumn.getCriteria2(),srcColumn.isOn());
    }
  }
}","/** 
 * A FilterColumn object only exists when we have set a criteria on that column.  For example, if we enable auto filter on 2 columns, but we only set criteria on 2nd column.  Thus, the size of filter column is 1. There is only one FilterColumn object and its column id is 1.   Only getFilterColumn(1) will return a FilterColumn, other get null.
 * @param poiSheet
 * @param sheet
 */
private void importAutoFilter(Sheet poiSheet,NSheet sheet){
  AutoFilter poiAutoFilter=poiSheet.getAutoFilter();
  if (poiAutoFilter != null) {
    CellRangeAddress filteringRange=poiAutoFilter.getRangeAddress();
    NAutoFilter autoFilter=sheet.createAutoFilter(new CellRegion(filteringRange.formatAsString()));
    int numberOfColumn=filteringRange.getLastColumn() - filteringRange.getFirstColumn() + 1;
    for (int i=0; i < numberOfColumn; i++) {
      FilterColumn srcColumn=poiAutoFilter.getFilterColumn(i);
      if (srcColumn == null) {
        continue;
      }
      NFilterColumn destColumn=autoFilter.getFilterColumn(i,true);
      destColumn.setProperties(toFilterOperator(srcColumn.getOperator()),srcColumn.getCriteria1(),srcColumn.getCriteria2(),srcColumn.isOn());
    }
  }
}",0.5518394648829431
56498,"/** 
 * Returns the column filter information of the specified column; null if the column is not filtered.
 * @param col the nth column (1st column in the filter range is 0)
 * @return the column filter information of the specified column; null if the column is not filtered.
 */
public NFilterColumn getFilterColumn(int index,boolean create);","/** 
 * Returns the column filter information of the specified column; null if the column is not filtered.
 * @param index the nth column (1st column in the filter range is 0)
 * @return the column filter information of the specified column; null if the column is not filtered.
 */
public NFilterColumn getFilterColumn(int index,boolean create);",0.9883720930232558
56499,"protected void autoFilter(NBook book){
  NAutoFilter filter1=book.getSheetByName(""String_Node_Str"").getAutoFilter();
  assertEquals(""String_Node_Str"",filter1.getRegion().getReferenceString());
  assertEquals(1,filter1.getFilterColumns().size());
  assertEquals(FilterOp.VALUES,filter1.getFilterColumn(0,false).getOperator());
  assertEquals(1,filter1.getFilterColumn(0,false).getFilters().size());
  assertEquals(1,filter1.getFilterColumn(0,false).getCriteria1().size());
  assertTrue(filter1.getFilterColumn(0,false).getCriteria1().contains(""String_Node_Str""));
  NAutoFilter filter2=book.getSheetByName(""String_Node_Str"").getAutoFilter();
  assertEquals(""String_Node_Str"",filter2.getRegion().getReferenceString());
  assertEquals(2,filter2.getFilterColumns().size());
  NFilterColumn firstFilterColumn=filter2.getFilterColumn(0,false);
  assertEquals(FilterOp.VALUES,firstFilterColumn.getOperator());
  assertEquals(3,firstFilterColumn.getFilters().size());
  assertEquals(3,firstFilterColumn.getCriteria1().size());
  assertTrue(firstFilterColumn.getCriteria1().contains(""String_Node_Str""));
  assertTrue(firstFilterColumn.getCriteria1().contains(""String_Node_Str""));
  assertTrue(firstFilterColumn.getCriteria1().contains(""String_Node_Str""));
  NFilterColumn secondFilterColumn=filter2.getFilterColumn(1,false);
  assertEquals(2,secondFilterColumn.getCriteria1().size());
  assertTrue(secondFilterColumn.getCriteria1().contains(""String_Node_Str""));
  assertTrue(secondFilterColumn.getCriteria1().contains(""String_Node_Str""));
}","protected void autoFilter(NBook book){
  NAutoFilter filter1=book.getSheetByName(""String_Node_Str"").getAutoFilter();
  assertEquals(""String_Node_Str"",filter1.getRegion().getReferenceString());
  assertEquals(1,filter1.getFilterColumns().size());
  assertEquals(FilterOp.VALUES,filter1.getFilterColumn(1,false).getOperator());
  assertEquals(1,filter1.getFilterColumn(1,false).getFilters().size());
  assertEquals(1,filter1.getFilterColumn(1,false).getCriteria1().size());
  assertTrue(filter1.getFilterColumn(1,false).getCriteria1().contains(""String_Node_Str""));
  NAutoFilter filter2=book.getSheetByName(""String_Node_Str"").getAutoFilter();
  assertEquals(""String_Node_Str"",filter2.getRegion().getReferenceString());
  assertEquals(2,filter2.getFilterColumns().size());
  NFilterColumn firstFilterColumn=filter2.getFilterColumn(0,false);
  assertEquals(FilterOp.VALUES,firstFilterColumn.getOperator());
  assertEquals(3,firstFilterColumn.getFilters().size());
  assertEquals(3,firstFilterColumn.getCriteria1().size());
  assertTrue(firstFilterColumn.getCriteria1().contains(""String_Node_Str""));
  assertTrue(firstFilterColumn.getCriteria1().contains(""String_Node_Str""));
  assertTrue(firstFilterColumn.getCriteria1().contains(""String_Node_Str""));
  NFilterColumn secondFilterColumn=filter2.getFilterColumn(1,false);
  assertEquals(2,secondFilterColumn.getCriteria1().size());
  assertTrue(secondFilterColumn.getCriteria1().contains(""String_Node_Str""));
  assertTrue(secondFilterColumn.getCriteria1().contains(""String_Node_Str""));
  NAutoFilter noCriteriaFilter=book.getSheetByName(""String_Node_Str"").getAutoFilter();
  assertEquals(""String_Node_Str"",noCriteriaFilter.getRegion().getReferenceString());
  assertEquals(0,noCriteriaFilter.getFilterColumns().size());
}",0.9265776699029126
56500,"@Override public int[] getColumnBreaks(){
  if (columnBreaks == null) {
    return new int[0];
  }
  int[] arr=new int[]{columnBreaks.size()};
  Iterator<Integer> iter=columnBreaks.iterator();
  for (int i=0; i < arr.length; i++) {
    arr[i]=iter.next();
  }
  return arr;
}","@Override public int[] getColumnBreaks(){
  if (columnBreaks == null) {
    return new int[0];
  }
  int[] arr=new int[columnBreaks.size()];
  Iterator<Integer> iter=columnBreaks.iterator();
  for (int i=0; i < arr.length; i++) {
    arr[i]=iter.next();
  }
  return arr;
}",0.9927007299270072
56501,"@Override public int[] getRowBreaks(){
  if (rowBreaks == null) {
    return new int[0];
  }
  int[] arr=new int[]{rowBreaks.size()};
  Iterator<Integer> iter=rowBreaks.iterator();
  for (int i=0; i < arr.length; i++) {
    arr[i]=iter.next();
  }
  return arr;
}","@Override public int[] getRowBreaks(){
  if (rowBreaks == null) {
    return new int[0];
  }
  int[] arr=new int[rowBreaks.size()];
  Iterator<Integer> iter=rowBreaks.iterator();
  for (int i=0; i < arr.length; i++) {
    arr[i]=iter.next();
  }
  return arr;
}",0.9923664122137404
56502,"@Override public boolean isPrintGridlines(){
  return getNative().getPrintInfo().isPrintGridline();
}","@Override public boolean isPrintGridlines(){
  return getNative().getPrintSetup().isPrintGridline();
}",0.955665024630542
56503,"public int getErrorCellValue(){
  ErrorValue errorValue=cell.getErrorValue();
switch (errorValue.getCode()) {
case ErrorValue.INVALID_FORMULA:
    return FormulaError.NA.getCode();
case ErrorValue.INVALID_NAME:
  return FormulaError.NAME.getCode();
case ErrorValue.INVALID_VALUE:
return FormulaError.VALUE.getCode();
default :
return FormulaError.VALUE.getCode();
}
}","public int getErrorCellValue(){
  ErrorValue errorValue=cell.getErrorValue();
switch (errorValue.getCode()) {
case ErrorValue.INVALID_FORMULA:
    return FormulaError.NA.getCode();
default :
  return errorValue.getCode();
}
}",0.6993243243243243
56504,"@Override @SuppressWarnings(""String_Node_Str"") public EvaluationResult evaluate(FormulaExpression expr,FormulaEvaluationContext context){
  if (expr.hasError()) {
    return new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  EvaluationResult result=null;
  try {
    NBook book=context.getBook();
    AbstractBookSeriesAdv bookSeries=(AbstractBookSeriesAdv)book.getBookSeries();
    Map<String,EvalContext> evalCtxMap=(Map<String,EvalContext>)bookSeries.getAttribute(KEY_EVALUATORS);
    if (evalCtxMap == null) {
      evalCtxMap=new LinkedHashMap<String,FormulaEngineImpl.EvalContext>();
      List<String> bookNames=new ArrayList<String>();
      List<WorkbookEvaluator> evaluators=new ArrayList<WorkbookEvaluator>();
      for (      NBook nb : bookSeries.getBooks()) {
        String bookName=nb.getBookName();
        EvalBook evalBook=new EvalBook(nb);
        WorkbookEvaluator we=new WorkbookEvaluator(evalBook,noCacheClassifier,null);
        bookNames.add(bookName);
        evaluators.add(we);
        evalCtxMap.put(bookName,new EvalContext(evalBook,we));
      }
      CollaboratingWorkbooksEnvironment.setup(bookNames.toArray(new String[0]),evaluators.toArray(new WorkbookEvaluator[0]));
      bookSeries.setAttribute(KEY_EVALUATORS,evalCtxMap);
    }
    EvalContext ctx=evalCtxMap.get(book.getBookName());
    if (ctx == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    EvalBook evalBook=ctx.getBook();
    WorkbookEvaluator evaluator=ctx.getEvaluator();
    Object oldXelCtx=getXelContext();
    XelContext xelCtx=getXelContextForResolving(context,evalBook,evaluator);
    setXelContext(xelCtx);
    try {
      result=evaluateFormula(expr,context,evalBook,evaluator);
    }
  finally {
      setXelContext(oldXelCtx);
    }
  }
 catch (  FormulaParseException e) {
    logger.log(Level.SEVERE,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString(),e);
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  return result;
}","@Override @SuppressWarnings(""String_Node_Str"") public EvaluationResult evaluate(FormulaExpression expr,FormulaEvaluationContext context){
  if (expr.hasError()) {
    return new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  EvaluationResult result=null;
  try {
    NBook book=context.getBook();
    AbstractBookSeriesAdv bookSeries=(AbstractBookSeriesAdv)book.getBookSeries();
    Map<String,EvalContext> evalCtxMap=(Map<String,EvalContext>)bookSeries.getAttribute(KEY_EVALUATORS);
    if (evalCtxMap == null) {
      evalCtxMap=new LinkedHashMap<String,FormulaEngineImpl.EvalContext>();
      List<String> bookNames=new ArrayList<String>();
      List<WorkbookEvaluator> evaluators=new ArrayList<WorkbookEvaluator>();
      for (      NBook nb : bookSeries.getBooks()) {
        String bookName=nb.getBookName();
        EvalBook evalBook=new EvalBook(nb);
        WorkbookEvaluator we=new WorkbookEvaluator(evalBook,noCacheClassifier,null);
        bookNames.add(bookName);
        evaluators.add(we);
        evalCtxMap.put(bookName,new EvalContext(evalBook,we));
      }
      CollaboratingWorkbooksEnvironment.setup(bookNames.toArray(new String[0]),evaluators.toArray(new WorkbookEvaluator[0]));
      bookSeries.setAttribute(KEY_EVALUATORS,evalCtxMap);
    }
    EvalContext ctx=evalCtxMap.get(book.getBookName());
    if (ctx == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    EvalBook evalBook=ctx.getBook();
    WorkbookEvaluator evaluator=ctx.getEvaluator();
    Object oldXelCtx=getXelContext();
    XelContext xelCtx=getXelContextForResolving(context,evalBook,evaluator);
    setXelContext(xelCtx);
    try {
      result=evaluateFormula(expr,context,evalBook,evaluator);
    }
  finally {
      setXelContext(oldXelCtx);
    }
  }
 catch (  NotImplementedException e) {
    logger.log(Level.INFO,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_NAME));
  }
catch (  FormulaParseException e) {
    logger.log(Level.SEVERE,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString(),e);
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  return result;
}",0.9528380634390652
56505,"private XelContext getXelContextForResolving(FormulaEvaluationContext context,EvaluationWorkbook evalBook,WorkbookEvaluator evaluator){
  XelContext xelContext=xelContexts.get(evalBook);
  if (xelContext == null) {
    NFunctionResolver resolver=NFunctionResolverFactory.getFunctionResolver();
    UDFFinder zkUDFF=resolver.getUDFFinder();
    if (zkUDFF != null) {
      IndexedUDFFinder bookUDFF=(IndexedUDFFinder)evalBook.getUDFFinder();
      bookUDFF.insert(0,zkUDFF);
    }
    DependencyTracker tracker=resolver.getDependencyTracker();
    if (tracker != null) {
      evaluator.setDependencyTracker(tracker);
    }
    NJoinFunctionMapper functionMapper=new NJoinFunctionMapper(null);
    FunctionMapper extraFunctionMapper=context.getFunctionMapper();
    if (extraFunctionMapper != null) {
      functionMapper.addFunctionMapper(extraFunctionMapper);
    }
    FunctionMapper zssFuncMapper=resolver.getFunctionMapper();
    if (zssFuncMapper != null) {
      functionMapper.addFunctionMapper(zssFuncMapper);
    }
    NJoinVariableResolver variableResolver=new NJoinVariableResolver();
    VariableResolver extraVariableResolver=context.getVariableResolver();
    if (extraVariableResolver != null) {
      variableResolver.addVariableResolver(extraVariableResolver);
    }
    xelContext=new SimpleXelContext(variableResolver,functionMapper);
    xelContext.setAttribute(""String_Node_Str"",Object.class);
    xelContexts.put(evalBook,xelContext);
  }
  return xelContext;
}","private XelContext getXelContextForResolving(FormulaEvaluationContext context,EvaluationWorkbook evalBook,WorkbookEvaluator evaluator){
  XelContext xelContext=xelContexts.get(evalBook);
  if (xelContext == null) {
    NFunctionResolver resolver=NFunctionResolverFactory.getFunctionResolver();
    DependencyTracker tracker=resolver.getDependencyTracker();
    if (tracker != null) {
      evaluator.setDependencyTracker(tracker);
    }
    NJoinFunctionMapper functionMapper=new NJoinFunctionMapper(null);
    FunctionMapper extraFunctionMapper=context.getFunctionMapper();
    if (extraFunctionMapper != null) {
      functionMapper.addFunctionMapper(extraFunctionMapper);
    }
    FunctionMapper zssFuncMapper=resolver.getFunctionMapper();
    if (zssFuncMapper != null) {
      functionMapper.addFunctionMapper(zssFuncMapper);
    }
    NJoinVariableResolver variableResolver=new NJoinVariableResolver();
    VariableResolver extraVariableResolver=context.getVariableResolver();
    if (extraVariableResolver != null) {
      variableResolver.addVariableResolver(extraVariableResolver);
    }
    xelContext=new SimpleXelContext(variableResolver,functionMapper);
    xelContext.setAttribute(""String_Node_Str"",Object.class);
    xelContexts.put(evalBook,xelContext);
  }
  return xelContext;
}",0.933093525179856
56506,"@Override @SuppressWarnings(""String_Node_Str"") public EvaluationResult evaluate(FormulaExpression expr,FormulaEvaluationContext context){
  if (expr.hasError()) {
    return new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  EvaluationResult result=null;
  try {
    NBook book=context.getBook();
    AbstractBookSeriesAdv bookSeries=(AbstractBookSeriesAdv)book.getBookSeries();
    Map<String,EvalContext> evalCtxMap=(Map<String,EvalContext>)bookSeries.getAttribute(KEY_EVALUATORS);
    if (evalCtxMap == null) {
      evalCtxMap=new LinkedHashMap<String,FormulaEngineImpl.EvalContext>();
      List<String> bookNames=new ArrayList<String>();
      List<WorkbookEvaluator> evaluators=new ArrayList<WorkbookEvaluator>();
      for (      NBook nb : bookSeries.getBooks()) {
        String bookName=nb.getBookName();
        EvalBook evalBook=new EvalBook(nb);
        WorkbookEvaluator we=new WorkbookEvaluator(evalBook,noCacheClassifier,null);
        bookNames.add(bookName);
        evaluators.add(we);
        evalCtxMap.put(bookName,new EvalContext(evalBook,we));
      }
      CollaboratingWorkbooksEnvironment.setup(bookNames.toArray(new String[0]),evaluators.toArray(new WorkbookEvaluator[0]));
      bookSeries.setAttribute(KEY_EVALUATORS,evalCtxMap);
    }
    EvalContext ctx=evalCtxMap.get(book.getBookName());
    if (ctx == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    EvalBook evalBook=ctx.getBook();
    WorkbookEvaluator evaluator=ctx.getEvaluator();
    Object oldXelCtx=getXelContext();
    XelContext xelCtx=getXelContextForResolving(context,evalBook,evaluator);
    setXelContext(xelCtx);
    try {
      result=evaluateFormula(expr,context,evalBook,evaluator);
    }
  finally {
      setXelContext(oldXelCtx);
    }
  }
 catch (  NotImplementedException e) {
    logger.log(Level.INFO,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_NAME));
  }
catch (  FormulaParseException e) {
    logger.log(Level.SEVERE,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString(),e);
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  return result;
}","@Override @SuppressWarnings(""String_Node_Str"") public EvaluationResult evaluate(FormulaExpression expr,FormulaEvaluationContext context){
  if (expr.hasError()) {
    return new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  EvaluationResult result=null;
  try {
    NBook book=context.getBook();
    AbstractBookSeriesAdv bookSeries=(AbstractBookSeriesAdv)book.getBookSeries();
    Map<String,EvalContext> evalCtxMap=(Map<String,EvalContext>)bookSeries.getAttribute(KEY_EVALUATORS);
    if (evalCtxMap == null) {
      evalCtxMap=new LinkedHashMap<String,FormulaEngineImpl.EvalContext>();
      List<String> bookNames=new ArrayList<String>();
      List<WorkbookEvaluator> evaluators=new ArrayList<WorkbookEvaluator>();
      for (      NBook nb : bookSeries.getBooks()) {
        String bookName=nb.getBookName();
        EvalBook evalBook=new EvalBook(nb);
        WorkbookEvaluator we=new WorkbookEvaluator(evalBook,noCacheClassifier,null);
        bookNames.add(bookName);
        evaluators.add(we);
        evalCtxMap.put(bookName,new EvalContext(evalBook,we));
        NFunctionResolver resolver=NFunctionResolverFactory.getFunctionResolver();
        UDFFinder zkUDFF=resolver.getUDFFinder();
        if (zkUDFF != null) {
          IndexedUDFFinder bookUDFF=(IndexedUDFFinder)evalBook.getUDFFinder();
          bookUDFF.insert(0,zkUDFF);
        }
      }
      CollaboratingWorkbooksEnvironment.setup(bookNames.toArray(new String[0]),evaluators.toArray(new WorkbookEvaluator[0]));
      bookSeries.setAttribute(KEY_EVALUATORS,evalCtxMap);
    }
    EvalContext ctx=evalCtxMap.get(book.getBookName());
    if (ctx == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    EvalBook evalBook=ctx.getBook();
    WorkbookEvaluator evaluator=ctx.getEvaluator();
    Object oldXelCtx=getXelContext();
    XelContext xelCtx=getXelContextForResolving(context,evalBook,evaluator);
    setXelContext(xelCtx);
    try {
      result=evaluateFormula(expr,context,evalBook,evaluator);
    }
  finally {
      setXelContext(oldXelCtx);
    }
  }
 catch (  NotImplementedException e) {
    logger.log(Level.INFO,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_NAME));
  }
catch (  FormulaParseException e) {
    logger.log(Level.SEVERE,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString());
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage() + ""String_Node_Str"" + expr.getFormulaString(),e);
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  return result;
}",0.945543621631807
56507,"@Override public void export(NBook book,File file) throws IOException {
  OutputStream os=null;
  try {
    os=new FileOutputStream(file);
    export(book,os);
  }
  finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      Exception x) {
      }
    }
  }
}","@Override public void export(NBook book,File file) throws IOException {
  OutputStream os=null;
  try {
    os=new FileOutputStream(file);
    export(book,os);
  }
  finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
}",0.8718801996672213
56508,"protected void sheetNamedRangeTest(NBook book){
  assertEquals(2,book.getNumOfName());
  assertEquals(""String_Node_Str"",book.getNameByName(""String_Node_Str"",""String_Node_Str"").getRefersToFormula());
  assertEquals(""String_Node_Str"",book.getNameByName(""String_Node_Str"",""String_Node_Str"").getRefersToFormula());
}","protected void sheetNamedRangeTest(NBook book){
  assertEquals(2,book.getNumOfName());
  assertEquals(""String_Node_Str"",book.getNameByName(""String_Node_Str"").getRefersToFormula());
  assertEquals(""String_Node_Str"",book.getNameByName(""String_Node_Str"").getRefersToFormula());
}",0.9387755102040816
56509,"@BeforeClass static public void setupTestFile(){
  IMPORT_FILE_UNDER_TEST=ImporterTest.class.getResource(""String_Node_Str"");
  CHART_IMPORT_FILE_UNDER_TEST=ImporterTest.class.getResource(""String_Node_Str"");
}","@Before public void setupTestFile(){
  IMPORT_FILE_UNDER_TEST=ImporterTest.class.getResource(""String_Node_Str"");
  CHART_IMPORT_FILE_UNDER_TEST=ImporterTest.class.getResource(""String_Node_Str"");
}",0.9702970297029704
56510,"public int getEndCellIndex(int row){
  AbstractRowAdv rowObj=(AbstractRowAdv)getRow(row,false);
  if (rowObj != null) {
    return rowObj.getEndCellIndex();
  }
  return -1;
}","public int getEndCellIndex(int row){
  int idx1=-1;
  AbstractRowAdv rowObj=(AbstractRowAdv)getRow(row,false);
  if (rowObj != null) {
    idx1=rowObj.getEndCellIndex();
  }
  NDataGrid dg=getDataGrid();
  if (dg == null || !dg.isSupportedDataStartEndIndex()) {
    return idx1;
  }
 else {
    int idx2=dg.getEndCellIndex(row);
    if (idx1 < 0)     return idx2;
    if (idx2 < 0)     return idx1;
    return Math.max(idx1,idx2);
  }
}",0.513911620294599
56511,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public Iterator<NRow> getRowIterator(){
  NDataGrid dg=getDataGrid();
  if (dg != null && dg.supportDataIterator()) {
    return new JoinRowIterator(this,((Collection)rows.values()).iterator(),dg.getRowIterator());
  }
 else {
    return Collections.unmodifiableCollection((Collection)rows.values()).iterator();
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public Iterator<NRow> getRowIterator(){
  NDataGrid dg=getDataGrid();
  if (dg != null && dg.isSupportedDataIterator()) {
    return new JoinRowIterator(this,((Collection)rows.values()).iterator(),dg.getRowIterator());
  }
 else {
    return Collections.unmodifiableCollection((Collection)rows.values()).iterator();
  }
}",0.9766839378238342
56512,"public int getStartCellIndex(int row){
  AbstractRowAdv rowObj=(AbstractRowAdv)getRow(row,false);
  if (rowObj != null) {
    return rowObj.getStartCellIndex();
  }
  return -1;
}","public int getStartCellIndex(int row){
  int idx1=-1;
  AbstractRowAdv rowObj=(AbstractRowAdv)getRow(row,false);
  if (rowObj != null) {
    idx1=rowObj.getStartCellIndex();
  }
  NDataGrid dg=getDataGrid();
  if (dg == null || !dg.isSupportedDataStartEndIndex()) {
    return idx1;
  }
 else {
    int idx2=dg.getStartCellIndex(row);
    if (idx1 < 0)     return idx2;
    if (idx2 < 0)     return idx1;
    return Math.min(idx1,idx2);
  }
}",0.5185185185185185
56513,"public int getStartRowIndex(){
  return rows.firstKey();
}","public int getStartRowIndex(){
  int idx1=rows.firstKey();
  NDataGrid dg=getDataGrid();
  if (dg == null || !dg.isSupportedDataStartEndIndex()) {
    return idx1;
  }
 else {
    int idx2=dg.getStartRowIndex();
    if (idx1 < 0)     return idx2;
    if (idx2 < 0)     return idx1;
    return Math.min(idx1,idx2);
  }
}",0.2705570291777188
56514,"public void deleteRow(int rowIdx,int size){
  checkOrphan();
  if (size <= 0)   return;
  NDataGrid dg=getDataGrid();
  if (dg != null) {
    if (!dg.supportOperations()) {
      throw new InvalidateModelOpException(""String_Node_Str"");
    }
    dg.deleteRow(rowIdx,size);
  }
  for (  AbstractRowAdv row : rows.subValues(rowIdx,rowIdx + size)) {
    row.destroy();
  }
  rows.delete(rowIdx,size);
  shiftAfterRowDelete(rowIdx,size);
  book.sendModelInternalEvent(createModelInternalEvent(ModelInternalEvents.ON_ROW_DELETED,ModelInternalEvents.PARAM_ROW_INDEX,rowIdx,ModelInternalEvents.PARAM_SIZE,size));
}","public void deleteRow(int rowIdx,int size){
  checkOrphan();
  if (size <= 0)   return;
  NDataGrid dg=getDataGrid();
  if (dg != null) {
    if (!dg.isSupportedOperations()) {
      throw new InvalidateModelOpException(""String_Node_Str"");
    }
    dg.deleteRow(rowIdx,size);
  }
  for (  AbstractRowAdv row : rows.subValues(rowIdx,rowIdx + size)) {
    row.destroy();
  }
  rows.delete(rowIdx,size);
  shiftAfterRowDelete(rowIdx,size);
  book.sendModelInternalEvent(createModelInternalEvent(ModelInternalEvents.ON_ROW_DELETED,ModelInternalEvents.PARAM_ROW_INDEX,rowIdx,ModelInternalEvents.PARAM_SIZE,size));
}",0.9950738916256158
56515,"public void insertColumn(int columnIdx,int size){
  checkOrphan();
  if (size <= 0)   return;
  NDataGrid dg=getDataGrid();
  if (dg != null) {
    if (!dg.supportOperations()) {
      throw new InvalidateModelOpException(""String_Node_Str"");
    }
    dg.insertColumn(columnIdx,size);
  }
  insertAndSplitColumnArray(columnIdx,size);
  for (  AbstractRowAdv row : rows.values()) {
    row.insertCell(columnIdx,size);
  }
  shiftAfterColumnInsert(columnIdx,size);
  book.sendModelInternalEvent(createModelInternalEvent(ModelInternalEvents.ON_COLUMN_INSERTED,ModelInternalEvents.PARAM_COLUMN_INDEX,columnIdx,ModelInternalEvents.PARAM_SIZE,size));
}","public void insertColumn(int columnIdx,int size){
  checkOrphan();
  if (size <= 0)   return;
  NDataGrid dg=getDataGrid();
  if (dg != null) {
    if (!dg.isSupportedOperations()) {
      throw new InvalidateModelOpException(""String_Node_Str"");
    }
    dg.insertColumn(columnIdx,size);
  }
  insertAndSplitColumnArray(columnIdx,size);
  for (  AbstractRowAdv row : rows.values()) {
    row.insertCell(columnIdx,size);
  }
  shiftAfterColumnInsert(columnIdx,size);
  book.sendModelInternalEvent(createModelInternalEvent(ModelInternalEvents.ON_COLUMN_INSERTED,ModelInternalEvents.PARAM_COLUMN_INDEX,columnIdx,ModelInternalEvents.PARAM_SIZE,size));
}",0.9861111111111112
56516,"public int getEndRowIndex(){
  return rows.lastKey();
}","public int getEndRowIndex(){
  int idx1=rows.lastKey();
  NDataGrid dg=getDataGrid();
  if (dg == null || !dg.isSupportedDataStartEndIndex()) {
    return idx1;
  }
 else {
    int idx2=dg.getEndRowIndex();
    if (idx1 < 0)     return idx2;
    if (idx2 < 0)     return idx1;
    return Math.max(idx1,idx2);
  }
}",0.2601626016260163
56517,"public void insertRow(int rowIdx,int size){
  checkOrphan();
  if (size <= 0)   return;
  NDataGrid dg=getDataGrid();
  if (dg != null) {
    if (!dg.supportOperations()) {
      throw new InvalidateModelOpException(""String_Node_Str"");
    }
    dg.insertRow(rowIdx,size);
  }
  rows.insert(rowIdx,size);
  shiftAfterRowInsert(rowIdx,size);
  book.sendModelInternalEvent(createModelInternalEvent(ModelInternalEvents.ON_ROW_INSERTED,ModelInternalEvents.PARAM_ROW_INDEX,rowIdx,ModelInternalEvents.PARAM_SIZE,size));
}","public void insertRow(int rowIdx,int size){
  checkOrphan();
  if (size <= 0)   return;
  NDataGrid dg=getDataGrid();
  if (dg != null) {
    if (!dg.isSupportedOperations()) {
      throw new InvalidateModelOpException(""String_Node_Str"");
    }
    dg.insertRow(rowIdx,size);
  }
  rows.insert(rowIdx,size);
  shiftAfterRowInsert(rowIdx,size);
  book.sendModelInternalEvent(createModelInternalEvent(ModelInternalEvents.ON_ROW_INSERTED,ModelInternalEvents.PARAM_ROW_INDEX,rowIdx,ModelInternalEvents.PARAM_SIZE,size));
}",0.9941972920696324
56518,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public Iterator<NCell> getCellIterator(int row){
  NDataGrid dg=getDataGrid();
  if (dg != null && dg.supportDataIterator()) {
    return new JoinCellIterator(this,row,(Iterator)((AbstractRowAdv)getRow(row)).getCellIterator(),dg.getCellIterator(row));
  }
 else {
    return (Iterator)((AbstractRowAdv)getRow(row)).getCellIterator();
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public Iterator<NCell> getCellIterator(int row){
  NDataGrid dg=getDataGrid();
  if (dg != null && dg.isSupportedDataIterator()) {
    return new JoinCellIterator(this,row,(Iterator)((AbstractRowAdv)getRow(row)).getCellIterator(),dg.getCellIterator(row));
  }
 else {
    return (Iterator)((AbstractRowAdv)getRow(row)).getCellIterator();
  }
}",0.9926470588235294
56519,"public void deleteColumn(int columnIdx,int size){
  checkOrphan();
  if (size <= 0)   return;
  NDataGrid dg=getDataGrid();
  if (dg != null) {
    if (!dg.supportOperations()) {
      throw new InvalidateModelOpException(""String_Node_Str"");
    }
    dg.deleteColumn(columnIdx,size);
  }
  deleteAndShrinkColumnArray(columnIdx,size);
  for (  AbstractRowAdv row : rows.values()) {
    row.deleteCell(columnIdx,size);
  }
  shiftAfterColumnDelete(columnIdx,size);
  book.sendModelInternalEvent(createModelInternalEvent(ModelInternalEvents.ON_COLUMN_DELETED,ModelInternalEvents.PARAM_COLUMN_INDEX,columnIdx,ModelInternalEvents.PARAM_SIZE,size));
}","public void deleteColumn(int columnIdx,int size){
  checkOrphan();
  if (size <= 0)   return;
  NDataGrid dg=getDataGrid();
  if (dg != null) {
    if (!dg.isSupportedOperations()) {
      throw new InvalidateModelOpException(""String_Node_Str"");
    }
    dg.deleteColumn(columnIdx,size);
  }
  deleteAndShrinkColumnArray(columnIdx,size);
  for (  AbstractRowAdv row : rows.values()) {
    row.deleteCell(columnIdx,size);
  }
  shiftAfterColumnDelete(columnIdx,size);
  book.sendModelInternalEvent(createModelInternalEvent(ModelInternalEvents.ON_COLUMN_DELETED,ModelInternalEvents.PARAM_COLUMN_INDEX,columnIdx,ModelInternalEvents.PARAM_SIZE,size));
}",0.9953703703703703
56520,"DataCellImpl getCell(int columnIdx,boolean create){
  DataCellImpl cellObj=cells.get(columnIdx);
  if (cellObj == null) {
    checkOrphan();
    cellObj=new DataCellImpl(this,columnIdx);
    cells.put(columnIdx,cellObj);
  }
  return cellObj;
}","DataCellImpl getCell(int columnIdx,boolean create){
  DataCellImpl cellObj=cells.get(columnIdx);
  if (cellObj == null && create) {
    checkOrphan();
    cellObj=new DataCellImpl(this,columnIdx);
    cells.put(columnIdx,cellObj);
  }
  return cellObj;
}",0.9799196787148594
56521,"DataRowImpl getRow(int rowIdx,boolean create){
  DataRowImpl rowObj=rows.get(rowIdx);
  if (rowObj == null) {
    rowObj=new DataRowImpl(this,rowIdx);
    rows.put(rowIdx,rowObj);
  }
  return rowObj;
}","DataRowImpl getRow(int rowIdx,boolean create){
  DataRowImpl rowObj=rows.get(rowIdx);
  if (rowObj == null && create) {
    rowObj=new DataRowImpl(this,rowIdx);
    rows.put(rowIdx,rowObj);
  }
  return rowObj;
}",0.9758454106280192
56522,"public static String getFontHTMLColor(Workbook book,Font font){
  if (font instanceof XSSFFont) {
    final XSSFFont f=(XSSFFont)font;
    final XSSFColor color=f.getXSSFColor();
    return BookHelper.colorToHTML(book,color);
  }
 else {
    final HSSFColor color=getHSSFFontColor((HSSFWorkbook)book,(HSSFFont)font);
    return BookHelper.colorToHTML(book,color);
  }
}","public static String getFontHTMLColor(Workbook book,Font font){
  String colorCode=null;
  if (font instanceof XSSFFont) {
    final XSSFFont f=(XSSFFont)font;
    final XSSFColor color=f.getXSSFColor();
    colorCode=BookHelper.colorToHTML(book,color);
  }
 else {
    final HSSFColor color=getHSSFFontColor((HSSFWorkbook)book,(HSSFFont)font);
    colorCode=BookHelper.colorToHTML(book,color);
  }
  if (AUTO_COLOR.equals(colorCode)) {
    colorCode=""String_Node_Str"";
  }
  return colorCode;
}",0.8217592592592593
56523,"/** 
 * not setXAxisTitle() because   {@link XSSFCategoryAxis} doesn't have API to get title. 
 */
@Override protected void importChart(Sheet poiSheet,NSheet sheet){
  List<ZssChartX> charts=importXSSFDrawings((XSSFSheet)poiSheet);
  for (  ZssChartX zssChart : charts) {
    XSSFChart xssfChart=(XSSFChart)zssChart.getChart();
    ClientAnchor clientAnchor=xssfChart.getPreferredSize();
    int width=getXSSFWidthInPx(poiSheet,clientAnchor);
    int height=getXSSFHeightInPx(poiSheet,clientAnchor);
    NViewAnchor viewAnchor=new NViewAnchor(clientAnchor.getRow1(),clientAnchor.getCol1(),width,height);
    NChart chart=null;
    CategoryData categoryData=null;
switch (xssfChart.getChartType()) {
case Area:
      chart=sheet.addChart(NChartType.AREA,viewAnchor);
    categoryData=new XSSFAreaChartData(xssfChart);
  chart.setGrouping(convertGrouping(((XSSFAreaChartData)categoryData).getGrouping()));
break;
case Area3D:
chart=sheet.addChart(NChartType.AREA,viewAnchor);
categoryData=new XSSFArea3DChartData(xssfChart);
chart.setGrouping(convertGrouping(((XSSFArea3DChartData)categoryData).getGrouping()));
break;
case Bar:
chart=sheet.addChart(NChartType.BAR,viewAnchor);
categoryData=new XSSFBarChartData(xssfChart);
chart.setBarDirection(convertBarDirection(((XSSFBarChartData)categoryData).getBarDirection()));
chart.setGrouping(convertGrouping(((XSSFBarChartData)categoryData).getGrouping()));
break;
case Bar3D:
chart=sheet.addChart(NChartType.BAR,viewAnchor);
categoryData=new XSSFBar3DChartData(xssfChart);
chart.setBarDirection(convertBarDirection(((XSSFBar3DChartData)categoryData).getBarDirection()));
chart.setGrouping(convertGrouping(((XSSFBar3DChartData)categoryData).getGrouping()));
break;
case Bubble:
chart=sheet.addChart(NChartType.BUBBLE,viewAnchor);
XYZData xyzData=new XSSFBubbleChartData(xssfChart);
importXyzSeries(xyzData.getSeries(),chart);
break;
case Column:
chart=sheet.addChart(NChartType.COLUMN,viewAnchor);
categoryData=new XSSFColumnChartData(xssfChart);
chart.setBarDirection(convertBarDirection(((XSSFColumnChartData)categoryData).getBarDirection()));
chart.setGrouping(convertGrouping(((XSSFColumnChartData)categoryData).getGrouping()));
break;
case Column3D:
chart=sheet.addChart(NChartType.COLUMN,viewAnchor);
categoryData=new XSSFColumn3DChartData(xssfChart);
chart.setBarDirection(convertBarDirection(((XSSFColumn3DChartData)categoryData).getBarDirection()));
chart.setGrouping(convertGrouping(((XSSFColumn3DChartData)categoryData).getGrouping()));
break;
case Doughnut:
chart=sheet.addChart(NChartType.DOUGHNUT,viewAnchor);
categoryData=new XSSFDoughnutChartData(xssfChart);
break;
case Line:
chart=sheet.addChart(NChartType.LINE,viewAnchor);
categoryData=new XSSFLineChartData(xssfChart);
break;
case Line3D:
chart=sheet.addChart(NChartType.LINE,viewAnchor);
categoryData=new XSSFLine3DChartData(xssfChart);
break;
case Pie:
chart=sheet.addChart(NChartType.PIE,viewAnchor);
categoryData=new XSSFPieChartData(xssfChart);
break;
case Pie3D:
chart=sheet.addChart(NChartType.PIE,viewAnchor);
categoryData=new XSSFPie3DChartData(xssfChart);
break;
case Scatter:
chart=sheet.addChart(NChartType.SCATTER,viewAnchor);
XYData xyData=new XSSFScatChartData(xssfChart);
importXySeries(xyData.getSeries(),chart);
break;
case Stock:
chart=sheet.addChart(NChartType.STOCK,viewAnchor);
categoryData=new XSSFStockChartData(xssfChart);
break;
default :
continue;
}
if (xssfChart.getTitle() != null) {
chart.setTitle(xssfChart.getTitle().getString());
}
chart.setThreeD(xssfChart.isSetView3D());
chart.setLegendPosition(convertLengendPosition(xssfChart.getOrCreateLegend().getPosition()));
if (categoryData != null) {
importSeries(categoryData.getSeries(),chart);
}
}
}","/** 
 * Not import X & Y axis title because   {@link XSSFCategoryAxis} doesn't provide API to get title. 
 */
@Override protected void importChart(Sheet poiSheet,NSheet sheet){
  List<ZssChartX> charts=importXSSFDrawings((XSSFSheet)poiSheet);
  for (  ZssChartX zssChart : charts) {
    XSSFChart xssfChart=(XSSFChart)zssChart.getChart();
    ClientAnchor clientAnchor=xssfChart.getPreferredSize();
    int width=getXSSFWidthInPx(poiSheet,clientAnchor);
    int height=getXSSFHeightInPx(poiSheet,clientAnchor);
    NViewAnchor viewAnchor=new NViewAnchor(clientAnchor.getRow1(),clientAnchor.getCol1(),width,height);
    NChart chart=null;
    CategoryData categoryData=null;
switch (xssfChart.getChartType()) {
case Area:
      chart=sheet.addChart(NChartType.AREA,viewAnchor);
    categoryData=new XSSFAreaChartData(xssfChart);
  chart.setGrouping(convertGrouping(((XSSFAreaChartData)categoryData).getGrouping()));
break;
case Area3D:
chart=sheet.addChart(NChartType.AREA,viewAnchor);
categoryData=new XSSFArea3DChartData(xssfChart);
chart.setGrouping(convertGrouping(((XSSFArea3DChartData)categoryData).getGrouping()));
break;
case Bar:
chart=sheet.addChart(NChartType.BAR,viewAnchor);
categoryData=new XSSFBarChartData(xssfChart);
chart.setBarDirection(convertBarDirection(((XSSFBarChartData)categoryData).getBarDirection()));
chart.setGrouping(convertGrouping(((XSSFBarChartData)categoryData).getGrouping()));
break;
case Bar3D:
chart=sheet.addChart(NChartType.BAR,viewAnchor);
categoryData=new XSSFBar3DChartData(xssfChart);
chart.setBarDirection(convertBarDirection(((XSSFBar3DChartData)categoryData).getBarDirection()));
chart.setGrouping(convertGrouping(((XSSFBar3DChartData)categoryData).getGrouping()));
break;
case Bubble:
chart=sheet.addChart(NChartType.BUBBLE,viewAnchor);
XYZData xyzData=new XSSFBubbleChartData(xssfChart);
importXyzSeries(xyzData.getSeries(),chart);
break;
case Column:
chart=sheet.addChart(NChartType.COLUMN,viewAnchor);
categoryData=new XSSFColumnChartData(xssfChart);
chart.setBarDirection(convertBarDirection(((XSSFColumnChartData)categoryData).getBarDirection()));
chart.setGrouping(convertGrouping(((XSSFColumnChartData)categoryData).getGrouping()));
break;
case Column3D:
chart=sheet.addChart(NChartType.COLUMN,viewAnchor);
categoryData=new XSSFColumn3DChartData(xssfChart);
chart.setBarDirection(convertBarDirection(((XSSFColumn3DChartData)categoryData).getBarDirection()));
chart.setGrouping(convertGrouping(((XSSFColumn3DChartData)categoryData).getGrouping()));
break;
case Doughnut:
chart=sheet.addChart(NChartType.DOUGHNUT,viewAnchor);
categoryData=new XSSFDoughnutChartData(xssfChart);
break;
case Line:
chart=sheet.addChart(NChartType.LINE,viewAnchor);
categoryData=new XSSFLineChartData(xssfChart);
break;
case Line3D:
chart=sheet.addChart(NChartType.LINE,viewAnchor);
categoryData=new XSSFLine3DChartData(xssfChart);
break;
case Pie:
chart=sheet.addChart(NChartType.PIE,viewAnchor);
categoryData=new XSSFPieChartData(xssfChart);
break;
case Pie3D:
chart=sheet.addChart(NChartType.PIE,viewAnchor);
categoryData=new XSSFPie3DChartData(xssfChart);
break;
case Scatter:
chart=sheet.addChart(NChartType.SCATTER,viewAnchor);
XYData xyData=new XSSFScatChartData(xssfChart);
importXySeries(xyData.getSeries(),chart);
break;
case Stock:
chart=sheet.addChart(NChartType.STOCK,viewAnchor);
categoryData=new XSSFStockChartData(xssfChart);
break;
default :
continue;
}
if (xssfChart.getTitle() != null) {
chart.setTitle(xssfChart.getTitle().getString());
}
chart.setThreeD(xssfChart.isSetView3D());
chart.setLegendPosition(convertLengendPosition(xssfChart.getOrCreateLegend().getPosition()));
if (categoryData != null) {
importSeries(categoryData.getSeries(),chart);
}
}
}",0.9950006755843804
56524,"private void handleRefDependent(NBookSeries bookSeries,HashSet<Ref> dependentSet){
  new RefDependentHandler(bookSeries).handleRefDependent(dependentSet);
}","private void handleRefDependent(NBookSeries bookSeries,HashSet<Ref> dependentSet){
  new RefDependentHelper(bookSeries).handle(dependentSet);
}",0.94314381270903
56525,"private void handleRefNotifySizeChange(NBookSeries bookSeries,HashSet<Ref> notifySet){
  new RefNotifySizeChangeHandler(bookSeries).handleRefNotify(notifySet);
}","private void handleRefNotifySizeChange(NBookSeries bookSeries,HashSet<Ref> notifySet){
  new RefNotifySizeChangeHelper(bookSeries).handle(notifySet);
}",0.9551282051282052
56526,"@Override public void setEditText(final String editText){
  final InputEngine ie=EngineFactory.getInstance().createInputEngine();
  final ResultWrap<InputResult> input=new ResultWrap<InputResult>();
  new CellVisitorTask(new CellVisitor(){
    public boolean visit(    NCell cell){
      InputResult result;
      if ((result=input.get()) == null) {
        result=ie.parseInput(editText == null ? ""String_Node_Str"" : editText,cell.getCellStyle().getDataFormat(),new InputParseContext(Locales.getCurrent()));
        input.set(result);
      }
      Object cellval=cell.getValue();
      Object resultVal=result.getValue();
      String format=result.getFormat();
      if (euqlas(cellval,resultVal)) {
        return false;
      }
switch (result.getType()) {
case BLANK:
        cell.clearValue();
      break;
case BOOLEAN:
    cell.setBooleanValue((Boolean)resultVal);
  break;
case FORMULA:
cell.setFormulaValue((String)resultVal);
break;
case NUMBER:
if (resultVal instanceof Date) {
cell.setDateValue((Date)resultVal);
}
 else {
cell.setNumberValue((Double)resultVal);
}
break;
case STRING:
cell.setStringValue((String)resultVal);
break;
case ERROR:
default :
cell.setValue(resultVal);
}
String oldFormat=cell.getCellStyle().getDataFormat();
if (format != null && NCellStyle.FORMAT_GENERAL.equals(oldFormat)) {
NStyles.setDataFormat(cell.getSheet(),cell.getRowIndex(),cell.getColumnIndex(),format);
}
return true;
}
}
).doInWriteLock(getLock());
}","@Override public void setEditText(final String editText){
  final InputEngine ie=EngineFactory.getInstance().createInputEngine();
  final ResultWrap<InputResult> input=new ResultWrap<InputResult>();
  new CellVisitorTask(new CellVisitor(){
    public boolean visit(    NCell cell){
      InputResult result;
      if ((result=input.get()) == null) {
        result=ie.parseInput(editText == null ? ""String_Node_Str"" : editText,cell.getCellStyle().getDataFormat(),new InputParseContext(Locales.getCurrent()));
        input.set(result);
      }
      Object cellval=cell.getValue();
      Object resultVal=result.getValue();
      String format=result.getFormat();
      if (euqlas(cellval,resultVal)) {
        return false;
      }
switch (result.getType()) {
case BLANK:
        cell.clearValue();
      break;
case BOOLEAN:
    cell.setBooleanValue((Boolean)resultVal);
  break;
case FORMULA:
cell.setFormulaValue((String)resultVal);
break;
case NUMBER:
if (resultVal instanceof Date) {
cell.setDateValue((Date)resultVal);
}
 else {
cell.setNumberValue((Double)resultVal);
}
break;
case STRING:
cell.setStringValue((String)resultVal);
break;
case ERROR:
default :
cell.setValue(resultVal);
}
String oldFormat=cell.getCellStyle().getDataFormat();
if (format != null && NCellStyle.FORMAT_GENERAL.equals(oldFormat)) {
StyleUtil.setDataFormat(cell.getSheet(),cell.getRowIndex(),cell.getColumnIndex(),format);
}
return true;
}
}
).doInWriteLock(getLock());
}",0.9979381443298968
56527,"private void handleRefNotifyContentChange(NBookSeries bookSeries,HashSet<Ref> notifySet){
  new RefNotifyContentChangeHandler(bookSeries).handleRefNotify(notifySet);
}","private void handleRefNotifyContentChange(NBookSeries bookSeries,HashSet<Ref> notifySet){
  new RefNotifyContentChangeHelper(bookSeries).handle(notifySet);
}",0.9567901234567902
56528,"private void buildNormalSheet(NBook book){
  NSheet sheet=book.createSheet(""String_Node_Str"");
  sheet.getColumn(0).setWidth(120);
  sheet.getColumn(1).setWidth(120);
  sheet.getColumn(2).setWidth(120);
  sheet.getColumn(3).setWidth(120);
  sheet.getColumn(4).setWidth(120);
  sheet.getColumn(5).setWidth(120);
  sheet.getColumn(6).setWidth(120);
  sheet.getCell(0,11).setStringValue(""String_Node_Str"");
  sheet.getColumn(12).setHidden(true);
  sheet.getColumn(14).setHidden(true);
  sheet.getCell(15,0).setStringValue(""String_Node_Str"");
  sheet.getRow(16).setHidden(true);
  sheet.getRow(18).setHidden(true);
  NCellStyle style;
  NCell cell;
  SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
  Date now=new Date();
  Date dayonly=null;
  try {
    dayonly=sdf.parse(sdf.format(now));
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
  (cell=sheet.getCell(0,0)).setValue(""String_Node_Str"");
  (cell=sheet.getCell(0,1)).setValue(123.45);
  (cell=sheet.getCell(0,2)).setValue(now);
  (cell=sheet.getCell(0,3)).setValue(Boolean.TRUE);
  (cell=sheet.getCell(1,0)).setValue(""String_Node_Str"");
  (cell=sheet.getCell(1,1)).setValue(33);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(1,2)).setValue(44.55);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(1,3)).setValue(77.88);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(1,4)).setValue(-77.88);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(2,0)).setValue(""String_Node_Str"");
  (cell=sheet.getCell(2,1)).setValue(dayonly);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(2,2)).setValue(dayonly);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(2,3)).setValue(now);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(2,4)).setValue(now);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(3,0)).setValue(""String_Node_Str"");
  (cell=sheet.getCell(3,1)).setNumberValue(1D);
  (cell=sheet.getCell(3,2)).setNumberValue(2D);
  (cell=sheet.getCell(3,3)).setNumberValue(3D);
  (cell=sheet.getCell(3,4)).setFormulaValue(""String_Node_Str"");
  (cell=sheet.getCell(4,0)).setStringValue(""String_Node_Str"");
  (cell=sheet.getCell(5,0)).setStringValue(""String_Node_Str"");
  sheet.addMergedRegion(new CellRegion(5,0,5,2));
  (cell=sheet.getCell(5,3)).setStringValue(""String_Node_Str"");
  sheet.addMergedRegion(new CellRegion(5,3,6,4));
  cell=sheet.getCell(9,6);
  cell.setStringValue(""String_Node_Str"");
  style=book.createCellStyle(true);
  style.setFont(book.createFont(true));
  style.getFont().setColor(book.createColor(""String_Node_Str""));
  style.getFont().setHeightPoints(16);
  style.setFillPattern(FillPattern.SOLID_FOREGROUND);
  style.setFillColor(book.createColor(""String_Node_Str""));
  sheet.getColumn(6).setWidth(150);
  sheet.getRow(9).setHeight(100);
  style.setAlignment(Alignment.RIGHT);
  style.setVerticalAlignment(VerticalAlignment.CENTER);
  style.setBorderTop(BorderType.THIN);
  style.setBorderBottom(BorderType.THIN);
  style.setBorderLeft(BorderType.THIN);
  style.setBorderRight(BorderType.THIN);
  style.setBorderTopColor(book.createColor(""String_Node_Str""));
  style.setBorderBottomColor(book.createColor(""String_Node_Str""));
  style.setBorderLeftColor(book.createColor(""String_Node_Str""));
  style.setBorderRightColor(book.createColor(""String_Node_Str""));
  cell.setCellStyle(style);
  style=book.createCellStyle(true);
  style.setFillPattern(FillPattern.SOLID_FOREGROUND);
  style.setFillColor(book.createColor(""String_Node_Str""));
  sheet.getRow(17).setCellStyle(style);
  sheet.getCell(17,0).setStringValue(""String_Node_Str"");
  style=book.createCellStyle(true);
  style.setFillPattern(FillPattern.SOLID_FOREGROUND);
  style.setFillColor(book.createColor(""String_Node_Str""));
  sheet.getColumn(17).setCellStyle(style);
  sheet.getColumn(17).setWidth(100);
  sheet.getCell(0,17).setStringValue(""String_Node_Str"");
  sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(12,3,30,5,600,300));
}","private void buildNormalSheet(NBook book){
  NSheet sheet=book.createSheet(""String_Node_Str"");
  sheet.getColumn(0).setWidth(120);
  sheet.getColumn(1).setWidth(120);
  sheet.getColumn(2).setWidth(120);
  sheet.getColumn(3).setWidth(120);
  sheet.getColumn(4).setWidth(120);
  sheet.getColumn(5).setWidth(120);
  sheet.getColumn(6).setWidth(120);
  sheet.getCell(0,11).setStringValue(""String_Node_Str"");
  sheet.getColumn(12).setHidden(true);
  sheet.getColumn(14).setHidden(true);
  sheet.getCell(15,0).setStringValue(""String_Node_Str"");
  sheet.getRow(16).setHidden(true);
  sheet.getRow(18).setHidden(true);
  NCellStyle style;
  NCell cell;
  SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
  Date now=new Date();
  Date dayonly=null;
  try {
    dayonly=sdf.parse(sdf.format(now));
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
  (cell=sheet.getCell(0,0)).setValue(""String_Node_Str"");
  (cell=sheet.getCell(0,1)).setValue(123.45);
  (cell=sheet.getCell(0,2)).setValue(now);
  (cell=sheet.getCell(0,3)).setValue(Boolean.TRUE);
  (cell=sheet.getCell(1,0)).setValue(""String_Node_Str"");
  (cell=sheet.getCell(1,1)).setValue(33);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(1,2)).setValue(44.55);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(1,3)).setValue(77.88);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(1,4)).setValue(-77.88);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(2,0)).setValue(""String_Node_Str"");
  (cell=sheet.getCell(2,1)).setValue(dayonly);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(2,2)).setValue(dayonly);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(2,3)).setValue(now);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(2,4)).setValue(now);
  style=book.createCellStyle(true);
  style.setDataFormat(""String_Node_Str"");
  cell.setCellStyle(style);
  (cell=sheet.getCell(3,0)).setValue(""String_Node_Str"");
  (cell=sheet.getCell(3,1)).setNumberValue(1D);
  (cell=sheet.getCell(3,2)).setNumberValue(2D);
  (cell=sheet.getCell(3,3)).setNumberValue(3D);
  (cell=sheet.getCell(3,4)).setFormulaValue(""String_Node_Str"");
  (cell=sheet.getCell(4,0)).setStringValue(""String_Node_Str"");
  (cell=sheet.getCell(5,0)).setStringValue(""String_Node_Str"");
  sheet.addMergedRegion(new CellRegion(5,0,5,2));
  (cell=sheet.getCell(5,3)).setStringValue(""String_Node_Str"");
  sheet.addMergedRegion(new CellRegion(5,3,6,4));
  cell=sheet.getCell(9,6);
  cell.setStringValue(""String_Node_Str"");
  style=book.createCellStyle(true);
  style.setFont(book.createFont(true));
  style.getFont().setColor(book.createColor(""String_Node_Str""));
  style.getFont().setHeightPoints(16);
  style.setFillPattern(FillPattern.SOLID_FOREGROUND);
  style.setFillColor(book.createColor(""String_Node_Str""));
  sheet.getColumn(6).setWidth(150);
  sheet.getRow(9).setHeight(100);
  style.setAlignment(Alignment.RIGHT);
  style.setVerticalAlignment(VerticalAlignment.CENTER);
  style.setBorderTop(BorderType.THIN);
  style.setBorderBottom(BorderType.THIN);
  style.setBorderLeft(BorderType.THIN);
  style.setBorderRight(BorderType.THIN);
  style.setBorderTopColor(book.createColor(""String_Node_Str""));
  style.setBorderBottomColor(book.createColor(""String_Node_Str""));
  style.setBorderLeftColor(book.createColor(""String_Node_Str""));
  style.setBorderRightColor(book.createColor(""String_Node_Str""));
  cell.setCellStyle(style);
  style=book.createCellStyle(true);
  style.setFillPattern(FillPattern.SOLID_FOREGROUND);
  style.setFillColor(book.createColor(""String_Node_Str""));
  sheet.getRow(17).setCellStyle(style);
  sheet.getCell(17,0).setStringValue(""String_Node_Str"");
  style=book.createCellStyle(true);
  style.setFillPattern(FillPattern.SOLID_FOREGROUND);
  style.setFillColor(book.createColor(""String_Node_Str""));
  sheet.getColumn(17).setCellStyle(style);
  sheet.getColumn(17).setWidth(100);
  sheet.getCell(0,17).setStringValue(""String_Node_Str"");
  sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(12,3,30,5,600,300));
  sheet=book.createSheet(""String_Node_Str"");
  sheet.getCell(0,0).setValue(""String_Node_Str"");
}",0.9896322165229728
56529,"@Override public NImporter createImporter(){
  return new AbstractImporter(){
    @Override public NBook imports(    InputStream is,    String bookName) throws IOException {
      NBook book=NBooks.createBook(bookName);
      buildChartSheet(book);
      buildNormalSheet(book);
      buildFreeze(book);
      return book;
    }
    private void buildFreeze(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getViewInfo().setNumOfColumnFreeze(5);
      sheet.getViewInfo().setNumOfRowFreeze(7);
      sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(3,3,600,300));
    }
    private void buildChartSheet(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getViewInfo().setNumOfRowFreeze(6);
      sheet.getCell(0,0).setValue(""String_Node_Str"");
      sheet.getCell(1,0).setValue(""String_Node_Str"");
      sheet.getCell(2,0).setValue(""String_Node_Str"");
      sheet.getCell(3,0).setValue(""String_Node_Str"");
      sheet.getCell(1,1).setValue(1);
      sheet.getCell(2,1).setValue(2);
      sheet.getCell(3,1).setValue(3);
      sheet.getCell(1,2).setValue(4);
      sheet.getCell(2,2).setValue(5);
      sheet.getCell(3,2).setValue(6);
      sheet.getCell(1,3).setValue(7);
      sheet.getCell(2,3).setValue(8);
      sheet.getCell(3,3).setValue(9);
      NChart chart=sheet.addChart(NChartType.PIE,new NViewAnchor(1,7,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.PIE,new NViewAnchor(1,12,400,200));
      buildChartData(chart);
      chart.setTitle(""String_Node_Str"");
      chart.setThreeD(true);
    }
    private void buildChartData(    NChart chart){
      NCategoryChartData data=(NCategoryChartData)chart.getData();
      data.setCategoriesFormula(""String_Node_Str"");
      NSeries series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"",null);
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"",null);
      series=data.addSeries();
      series.setFormula(null,""String_Node_Str"",null);
    }
    private void buildNormalSheet(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getColumn(0).setWidth(120);
      sheet.getColumn(1).setWidth(120);
      sheet.getColumn(2).setWidth(120);
      sheet.getColumn(3).setWidth(120);
      sheet.getColumn(4).setWidth(120);
      sheet.getColumn(5).setWidth(120);
      sheet.getColumn(6).setWidth(120);
      sheet.getCell(0,11).setStringValue(""String_Node_Str"");
      sheet.getColumn(12).setHidden(true);
      sheet.getColumn(14).setHidden(true);
      sheet.getCell(15,0).setStringValue(""String_Node_Str"");
      sheet.getRow(16).setHidden(true);
      sheet.getRow(18).setHidden(true);
      NCellStyle style;
      NCell cell;
      SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
      Date now=new Date();
      Date dayonly=null;
      try {
        dayonly=sdf.parse(sdf.format(now));
      }
 catch (      ParseException e) {
        e.printStackTrace();
      }
      (cell=sheet.getCell(0,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(0,1)).setValue(123.45);
      (cell=sheet.getCell(0,2)).setValue(now);
      (cell=sheet.getCell(0,3)).setValue(Boolean.TRUE);
      (cell=sheet.getCell(1,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(1,1)).setValue(33);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,2)).setValue(44.55);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,3)).setValue(77.88);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,4)).setValue(-77.88);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(2,1)).setValue(dayonly);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,2)).setValue(dayonly);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,3)).setValue(now);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,4)).setValue(now);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(3,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(3,1)).setNumberValue(1D);
      (cell=sheet.getCell(3,2)).setNumberValue(2D);
      (cell=sheet.getCell(3,3)).setNumberValue(3D);
      (cell=sheet.getCell(3,4)).setFormulaValue(""String_Node_Str"");
      (cell=sheet.getCell(4,0)).setStringValue(""String_Node_Str"");
      (cell=sheet.getCell(5,0)).setStringValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(5,0,5,2));
      (cell=sheet.getCell(5,3)).setStringValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(5,3,6,4));
      cell=sheet.getCell(9,6);
      cell.setStringValue(""String_Node_Str"");
      style=book.createCellStyle(true);
      style.setFont(book.createFont(true));
      style.getFont().setColor(book.createColor(""String_Node_Str""));
      style.getFont().setHeightPoints(16);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getColumn(6).setWidth(150);
      sheet.getRow(9).setHeight(100);
      style.setAlignment(Alignment.RIGHT);
      style.setVerticalAlignment(VerticalAlignment.CENTER);
      style.setBorderTop(BorderType.THIN);
      style.setBorderBottom(BorderType.THIN);
      style.setBorderLeft(BorderType.THIN);
      style.setBorderRight(BorderType.THIN);
      style.setBorderTopColor(book.createColor(""String_Node_Str""));
      style.setBorderBottomColor(book.createColor(""String_Node_Str""));
      style.setBorderLeftColor(book.createColor(""String_Node_Str""));
      style.setBorderRightColor(book.createColor(""String_Node_Str""));
      cell.setCellStyle(style);
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getRow(17).setCellStyle(style);
      sheet.getCell(17,0).setStringValue(""String_Node_Str"");
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getColumn(17).setCellStyle(style);
      sheet.getColumn(17).setWidth(100);
      sheet.getCell(0,17).setStringValue(""String_Node_Str"");
      sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(12,3,30,5,600,300));
    }
    private byte[] getTestImageData(){
      InputStream is=null;
      try {
        is=getClass().getResourceAsStream(""String_Node_Str"");
        ByteArrayOutputStream os=new ByteArrayOutputStream();
        byte[] b=new byte[1024];
        int r;
        while ((r=is.read(b)) != -1) {
          os.write(b,0,r);
        }
        return os.toByteArray();
      }
 catch (      IOException e) {
        throw new RuntimeException(e.getMessage(),e);
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
;
}","@Override public NImporter createImporter(){
  return new AbstractImporter(){
    @Override public NBook imports(    InputStream is,    String bookName) throws IOException {
      NBook book=NBooks.createBook(bookName);
      buildChartSheet(book);
      buildNormalSheet(book);
      buildFreeze(book);
      return book;
    }
    private void buildFreeze(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getViewInfo().setNumOfColumnFreeze(5);
      sheet.getViewInfo().setNumOfRowFreeze(7);
      sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(3,3,600,300));
    }
    private void buildChartSheet(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getViewInfo().setNumOfRowFreeze(6);
      sheet.getCell(0,0).setValue(""String_Node_Str"");
      sheet.getCell(1,0).setValue(""String_Node_Str"");
      sheet.getCell(2,0).setValue(""String_Node_Str"");
      sheet.getCell(3,0).setValue(""String_Node_Str"");
      sheet.getCell(1,1).setValue(1);
      sheet.getCell(2,1).setValue(2);
      sheet.getCell(3,1).setValue(3);
      sheet.getCell(1,2).setValue(4);
      sheet.getCell(2,2).setValue(5);
      sheet.getCell(3,2).setValue(6);
      sheet.getCell(1,3).setValue(7);
      sheet.getCell(2,3).setValue(8);
      sheet.getCell(3,3).setValue(9);
      NChart chart=sheet.addChart(NChartType.PIE,new NViewAnchor(1,7,300,200));
      buildChartData(chart);
      chart.setLegendPosition(NChartLegendPosition.RIGHT);
      chart=sheet.addChart(NChartType.PIE,new NViewAnchor(1,12,400,200));
      buildChartData(chart);
      chart.setTitle(""String_Node_Str"");
      chart.setThreeD(true);
    }
    private void buildChartData(    NChart chart){
      NCategoryChartData data=(NCategoryChartData)chart.getData();
      data.setCategoriesFormula(""String_Node_Str"");
      NSeries series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"",null);
      series=data.addSeries();
      series.setFormula(""String_Node_Str"",""String_Node_Str"",null);
      series=data.addSeries();
      series.setFormula(null,""String_Node_Str"",null);
    }
    private void buildNormalSheet(    NBook book){
      NSheet sheet=book.createSheet(""String_Node_Str"");
      sheet.getColumn(0).setWidth(120);
      sheet.getColumn(1).setWidth(120);
      sheet.getColumn(2).setWidth(120);
      sheet.getColumn(3).setWidth(120);
      sheet.getColumn(4).setWidth(120);
      sheet.getColumn(5).setWidth(120);
      sheet.getColumn(6).setWidth(120);
      sheet.getCell(0,11).setStringValue(""String_Node_Str"");
      sheet.getColumn(12).setHidden(true);
      sheet.getColumn(14).setHidden(true);
      sheet.getCell(15,0).setStringValue(""String_Node_Str"");
      sheet.getRow(16).setHidden(true);
      sheet.getRow(18).setHidden(true);
      NCellStyle style;
      NCell cell;
      SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
      Date now=new Date();
      Date dayonly=null;
      try {
        dayonly=sdf.parse(sdf.format(now));
      }
 catch (      ParseException e) {
        e.printStackTrace();
      }
      (cell=sheet.getCell(0,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(0,1)).setValue(123.45);
      (cell=sheet.getCell(0,2)).setValue(now);
      (cell=sheet.getCell(0,3)).setValue(Boolean.TRUE);
      (cell=sheet.getCell(1,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(1,1)).setValue(33);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,2)).setValue(44.55);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,3)).setValue(77.88);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(1,4)).setValue(-77.88);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(2,1)).setValue(dayonly);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,2)).setValue(dayonly);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,3)).setValue(now);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(2,4)).setValue(now);
      style=book.createCellStyle(true);
      style.setDataFormat(""String_Node_Str"");
      cell.setCellStyle(style);
      (cell=sheet.getCell(3,0)).setValue(""String_Node_Str"");
      (cell=sheet.getCell(3,1)).setNumberValue(1D);
      (cell=sheet.getCell(3,2)).setNumberValue(2D);
      (cell=sheet.getCell(3,3)).setNumberValue(3D);
      (cell=sheet.getCell(3,4)).setFormulaValue(""String_Node_Str"");
      (cell=sheet.getCell(4,0)).setStringValue(""String_Node_Str"");
      (cell=sheet.getCell(5,0)).setStringValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(5,0,5,2));
      (cell=sheet.getCell(5,3)).setStringValue(""String_Node_Str"");
      sheet.addMergedRegion(new CellRegion(5,3,6,4));
      cell=sheet.getCell(9,6);
      cell.setStringValue(""String_Node_Str"");
      style=book.createCellStyle(true);
      style.setFont(book.createFont(true));
      style.getFont().setColor(book.createColor(""String_Node_Str""));
      style.getFont().setHeightPoints(16);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getColumn(6).setWidth(150);
      sheet.getRow(9).setHeight(100);
      style.setAlignment(Alignment.RIGHT);
      style.setVerticalAlignment(VerticalAlignment.CENTER);
      style.setBorderTop(BorderType.THIN);
      style.setBorderBottom(BorderType.THIN);
      style.setBorderLeft(BorderType.THIN);
      style.setBorderRight(BorderType.THIN);
      style.setBorderTopColor(book.createColor(""String_Node_Str""));
      style.setBorderBottomColor(book.createColor(""String_Node_Str""));
      style.setBorderLeftColor(book.createColor(""String_Node_Str""));
      style.setBorderRightColor(book.createColor(""String_Node_Str""));
      cell.setCellStyle(style);
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getRow(17).setCellStyle(style);
      sheet.getCell(17,0).setStringValue(""String_Node_Str"");
      style=book.createCellStyle(true);
      style.setFillPattern(FillPattern.SOLID_FOREGROUND);
      style.setFillColor(book.createColor(""String_Node_Str""));
      sheet.getColumn(17).setCellStyle(style);
      sheet.getColumn(17).setWidth(100);
      sheet.getCell(0,17).setStringValue(""String_Node_Str"");
      sheet.addPicture(Format.JPG,getTestImageData(),new NViewAnchor(12,3,30,5,600,300));
      sheet=book.createSheet(""String_Node_Str"");
      sheet.getCell(0,0).setValue(""String_Node_Str"");
    }
    private byte[] getTestImageData(){
      InputStream is=null;
      try {
        is=getClass().getResourceAsStream(""String_Node_Str"");
        ByteArrayOutputStream os=new ByteArrayOutputStream();
        byte[] b=new byte[1024];
        int r;
        while ((r=is.read(b)) != -1) {
          os.write(b,0,r);
        }
        return os.toByteArray();
      }
 catch (      IOException e) {
        throw new RuntimeException(e.getMessage(),e);
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
;
}",0.9933919291717456
56530,"@Override public void setFormulaValue(String formula){
  checkOrphan();
  Validations.argNotNull(formula);
  FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
  FormulaExpression expr=fe.parse(formula,new FormulaParseContext(this,new RefImpl(this)));
  setValue(expr);
}","@Override public void setFormulaValue(String formula){
  checkOrphan();
  Validations.argNotNull(formula);
  clearValue();
  FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
  FormulaExpression expr=fe.parse(formula,new FormulaParseContext(this,new RefImpl(this)));
  setValue(expr);
}",0.972972972972973
56531,"@Override public void clearValue(){
  checkOrphan();
  value=null;
  richText=null;
  clearFormulaDependency();
  clearFormulaResultCache();
  type=CellType.BLANK;
}","private void clearValue(boolean clearDependency){
  checkOrphan();
  if (clearDependency) {
    clearFormulaDependency();
  }
  clearFormulaResultCache();
  value=null;
  richText=null;
  type=CellType.BLANK;
}",0.4106666666666667
56532,"private void clearFormulaDependency(){
  if (type == CellType.FORMULA) {
    Ref ref=new RefImpl(this);
    ((BookSeriesAdv)row.getSheet().getBook().getBookSeries()).getDependencyTable().clearDependents(ref);
  }
}","private void clearFormulaDependency(){
  if (type == CellType.FORMULA) {
    Ref ref=new RefImpl(this);
    ((BookSeriesAdv)getSheet().getBook().getBookSeries()).getDependencyTable().clearDependents(ref);
  }
}",0.9905660377358492
56533,"@Override public void setValue(Object newvalue){
  if (value != null && value.equals(newvalue)) {
    return;
  }
  clearValue();
  if (newvalue == null) {
  }
 else   if (newvalue instanceof String) {
    if (""String_Node_Str"".equals(newvalue)) {
      type=CellType.BLANK;
      newvalue=null;
    }
 else     if (isFormula((String)newvalue)) {
      setFormulaValue(((String)newvalue).substring(1));
      return;
    }
 else {
      type=CellType.STRING;
    }
  }
 else   if (newvalue instanceof FormulaExpression) {
    type=CellType.FORMULA;
  }
 else   if (newvalue instanceof Date) {
    type=CellType.NUMBER;
    newvalue=EngineFactory.getInstance().getCalendarUtil().dateToDoubleValue((Date)newvalue,false);
  }
 else   if (newvalue instanceof Boolean) {
    type=CellType.BOOLEAN;
  }
 else   if (newvalue instanceof Double) {
    type=CellType.NUMBER;
  }
 else   if (newvalue instanceof Number) {
    type=CellType.NUMBER;
    newvalue=((Number)newvalue).doubleValue();
  }
 else   if (newvalue instanceof ErrorValue) {
    type=CellType.ERROR;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + newvalue + ""String_Node_Str"");
  }
  value=newvalue;
}","@Override public void setValue(Object newvalue){
  if (value != null && value.equals(newvalue)) {
    return;
  }
  clearValue(!(newvalue instanceof FormulaExpression));
  if (newvalue == null) {
  }
 else   if (newvalue instanceof String) {
    if (""String_Node_Str"".equals(newvalue)) {
      type=CellType.BLANK;
      newvalue=null;
    }
 else     if (isFormula((String)newvalue)) {
      setFormulaValue(((String)newvalue).substring(1));
      return;
    }
 else {
      type=CellType.STRING;
    }
  }
 else   if (newvalue instanceof FormulaExpression) {
    type=CellType.FORMULA;
  }
 else   if (newvalue instanceof Date) {
    type=CellType.NUMBER;
    newvalue=EngineFactory.getInstance().getCalendarUtil().dateToDoubleValue((Date)newvalue,false);
  }
 else   if (newvalue instanceof Boolean) {
    type=CellType.BOOLEAN;
  }
 else   if (newvalue instanceof Double) {
    type=CellType.NUMBER;
  }
 else   if (newvalue instanceof Number) {
    type=CellType.NUMBER;
    newvalue=((Number)newvalue).doubleValue();
  }
 else   if (newvalue instanceof ErrorValue) {
    type=CellType.ERROR;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + newvalue + ""String_Node_Str"");
  }
  value=newvalue;
}",0.9833887043189368
56534,"private void checkColumnArrayStatus(){
  if (true)   return;
  ColumnArrayAdv prev=null;
  System.out.println(""String_Node_Str"");
  for (  ColumnArrayAdv array : columnArrays.values()) {
    System.out.println(""String_Node_Str"" + array.getIndex() + ""String_Node_Str""+ array.getLastIndex());
  }
  for (  ColumnArrayAdv array : columnArrays.values()) {
    if (prev == null) {
      if (array.getIndex() != 0) {
        throw new IllegalStateException(""String_Node_Str"" + array.getIndex());
      }
    }
 else {
      if (prev.getLastIndex() + 1 != array.getIndex()) {
        throw new IllegalStateException(""String_Node_Str"" + prev.getLastIndex() + ""String_Node_Str""+ array.getIndex());
      }
    }
    prev=array;
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * internal use only for developing/test state, should remove when stable
 */
private void checkColumnArrayStatus(){
  if (!DEBUG)   return;
  ColumnArrayAdv prev=null;
  try {
    for (    ColumnArrayAdv array : columnArrays.values()) {
      if (prev == null) {
        if (array.getIndex() != 0) {
          throw new IllegalStateException(""String_Node_Str"" + array.getIndex());
        }
      }
 else {
        if (prev.getLastIndex() + 1 != array.getIndex()) {
          throw new IllegalStateException(""String_Node_Str"" + prev.getLastIndex() + ""String_Node_Str""+ array.getIndex());
        }
      }
      prev=array;
    }
  }
 catch (  RuntimeException x) {
    System.out.println(""String_Node_Str"");
    for (    ColumnArrayAdv array : columnArrays.values()) {
      System.out.println(""String_Node_Str"" + array.getIndex() + ""String_Node_Str""+ array.getLastIndex());
    }
    System.out.println(""String_Node_Str"");
    throw x;
  }
}",0.6522753792298717
56535,"@Override public NColumnArray setupColumnArray(int index,int lastIndex){
  if (index < 0 && lastIndex > index) {
    throw new IllegalArgumentException(index + ""String_Node_Str"" + lastIndex);
  }
  int start1, end1;
  start1=end1=-1;
  ColumnArrayAdv ov=columnArrays.overlap(index,lastIndex);
  if (ov != null) {
    throw new IllegalStateException(""String_Node_Str"" + index + ""String_Node_Str""+ lastIndex+ ""String_Node_Str""+ ov);
  }
  if (columnArrays.size() > 0) {
    start1=columnArrays.lastLastKey() + 1;
  }
  end1=index - 1;
  ColumnArrayAdv array;
  if (start1 <= end1 && end1 > -1) {
    array=new ColumnArrayImpl(this,start1,end1);
    columnArrays.put(array);
  }
  array=new ColumnArrayImpl(this,index,lastIndex);
  columnArrays.put(array);
  checkColumnArrayStatus();
  return array;
}","@Override public NColumnArray setupColumnArray(int index,int lastIndex){
  if (index < 0 && lastIndex > index) {
    throw new IllegalArgumentException(index + ""String_Node_Str"" + lastIndex);
  }
  int start1, end1;
  start1=end1=-1;
  ColumnArrayAdv ov=columnArrays.overlap(index,lastIndex);
  if (ov != null) {
    throw new IllegalStateException(""String_Node_Str"" + index + ""String_Node_Str""+ lastIndex+ ""String_Node_Str""+ ov);
  }
  if (columnArrays.size() == 0) {
    start1=0;
  }
 else {
    start1=columnArrays.lastLastKey() + 1;
  }
  end1=index - 1;
  ColumnArrayAdv array;
  if (start1 <= end1 && end1 > -1) {
    array=new ColumnArrayImpl(this,start1,end1);
    columnArrays.put(array);
  }
  array=new ColumnArrayImpl(this,index,lastIndex);
  columnArrays.put(array);
  checkColumnArrayStatus();
  return array;
}",0.9821538461538462
56536,"@Override ColumnArrayAdv getOrSplitColumnArray(int columnIdx){
  ColumnArrayAdv contains=(ColumnArrayAdv)getColumnArray(columnIdx);
  if (contains != null && contains.getIndex() == columnIdx && contains.getLastIndex() == columnIdx) {
    return contains;
  }
  int start1, end1, start2, end2;
  start1=end1=start2=end2=-1;
  if (contains == null) {
    if (columnArrays.size() == 0) {
      start1=0;
      end1=columnIdx - 1;
    }
 else {
      start1=columnArrays.lastLastKey() + 1;
      end1=columnIdx - 1;
    }
  }
 else {
    if (contains.getIndex() == columnIdx) {
      start2=columnIdx + 1;
      end2=contains.getLastIndex();
    }
 else     if (contains.getLastIndex() == columnIdx) {
      start1=contains.getIndex();
      end1=columnIdx - 1;
    }
 else {
      start1=contains.getIndex();
      end1=columnIdx - 1;
      end2=contains.getLastIndex();
      start2=columnIdx + 1;
    }
  }
  ColumnArrayAdv array=null;
  ColumnArrayAdv prev=null;
  if (contains != null) {
    columnArrays.remove(contains);
  }
  if (start2 <= end2 && end2 > -1) {
    prev=new ColumnArrayImpl(this,start2,end2);
    columnArrays.put(prev);
    if (contains != null) {
      prev.setCellStyle(contains.getCellStyle());
      prev.setHidden(contains.isHidden());
      prev.setWidth(contains.getWidth());
    }
  }
  array=new ColumnArrayImpl(this,columnIdx,columnIdx);
  columnArrays.put(array);
  if (contains != null) {
    array.setCellStyle(contains.getCellStyle());
    array.setHidden(contains.isHidden());
    array.setWidth(contains.getWidth());
  }
  if (start1 <= end1 && end1 > -1) {
    prev=new ColumnArrayImpl(this,start1,end1);
    columnArrays.put(prev);
    if (contains != null) {
      prev.setCellStyle(contains.getCellStyle());
      prev.setHidden(contains.isHidden());
      prev.setWidth(contains.getWidth());
    }
  }
  checkColumnArrayStatus();
  return array;
}","@Override ColumnArrayAdv getOrSplitColumnArray(int columnIdx){
  ColumnArrayAdv contains=(ColumnArrayAdv)getColumnArray(columnIdx);
  if (contains != null && contains.getIndex() == columnIdx && contains.getLastIndex() == columnIdx) {
    return contains;
  }
  int start1, end1, start2, end2;
  start1=end1=start2=end2=-1;
  if (contains == null) {
    if (columnArrays.size() == 0) {
      start1=0;
    }
 else {
      start1=columnArrays.lastLastKey() + 1;
    }
    end1=columnIdx - 1;
  }
 else {
    if (contains.getIndex() == columnIdx) {
      start2=columnIdx + 1;
      end2=contains.getLastIndex();
    }
 else     if (contains.getLastIndex() == columnIdx) {
      start1=contains.getIndex();
      end1=columnIdx - 1;
    }
 else {
      start1=contains.getIndex();
      end1=columnIdx - 1;
      end2=contains.getLastIndex();
      start2=columnIdx + 1;
    }
  }
  ColumnArrayAdv array=null;
  ColumnArrayAdv prev=null;
  if (contains != null) {
    columnArrays.remove(contains);
  }
  if (start2 <= end2 && end2 > -1) {
    prev=new ColumnArrayImpl(this,start2,end2);
    columnArrays.put(prev);
    if (contains != null) {
      prev.setCellStyle(contains.getCellStyle());
      prev.setHidden(contains.isHidden());
      prev.setWidth(contains.getWidth());
    }
  }
  array=new ColumnArrayImpl(this,columnIdx,columnIdx);
  columnArrays.put(array);
  if (contains != null) {
    array.setCellStyle(contains.getCellStyle());
    array.setHidden(contains.isHidden());
    array.setWidth(contains.getWidth());
  }
  if (start1 <= end1 && end1 > -1) {
    prev=new ColumnArrayImpl(this,start1,end1);
    columnArrays.put(prev);
    if (contains != null) {
      prev.setCellStyle(contains.getCellStyle());
      prev.setHidden(contains.isHidden());
      prev.setWidth(contains.getWidth());
    }
  }
  checkColumnArrayStatus();
  return array;
}",0.9589333333333332
56537,"@Before public void beforeTest(){
  Locales.setThreadLocal(Locale.TAIWAN);
}","@Before public void beforeTest(){
  Locales.setThreadLocal(Locale.TAIWAN);
  SheetImpl.DEBUG=true;
}",0.8636363636363636
56538,"/** 
 * internal use only for developing/test state, should remove when stable
 */
private void checkColumnArrayStatus(){
  if (!DEBUG)   return;
  ColumnArrayAdv prev=null;
  try {
    for (    ColumnArrayAdv array : columnArrays.values()) {
      if (prev == null) {
        if (array.getIndex() != 0) {
          throw new IllegalStateException(""String_Node_Str"" + array.getIndex());
        }
      }
 else {
        if (prev.getLastIndex() + 1 != array.getIndex()) {
          throw new IllegalStateException(""String_Node_Str"" + prev.getLastIndex() + ""String_Node_Str""+ array.getIndex());
        }
      }
      prev=array;
    }
  }
 catch (  RuntimeException x) {
    System.out.println(""String_Node_Str"");
    for (    ColumnArrayAdv array : columnArrays.values()) {
      System.out.println(""String_Node_Str"" + array.getIndex() + ""String_Node_Str""+ array.getLastIndex());
    }
    System.out.println(""String_Node_Str"");
    throw x;
  }
}","private void checkColumnArrayStatus(){
  if (!DEBUG)   return;
  ColumnArrayAdv prev=null;
  try {
    for (    ColumnArrayAdv array : columnArrays.values()) {
      if (prev == null) {
        if (array.getIndex() != 0) {
          throw new IllegalStateException(""String_Node_Str"" + array.getIndex());
        }
      }
 else {
        if (prev.getLastIndex() + 1 != array.getIndex()) {
          throw new IllegalStateException(""String_Node_Str"" + prev.getLastIndex() + ""String_Node_Str""+ array.getIndex());
        }
      }
      prev=array;
    }
  }
 catch (  RuntimeException x) {
    System.out.println(""String_Node_Str"");
    for (    ColumnArrayAdv array : columnArrays.values()) {
      System.out.println(""String_Node_Str"" + array.getIndex() + ""String_Node_Str""+ array.getLastIndex());
    }
    System.out.println(""String_Node_Str"");
    throw x;
  }
}",0.9542699724517908
56539,"void evalFormula(){
  if (!evaluated) {
    FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
    NBook book=chart.getSheet().getBook();
    if (nameExpr != null) {
      EvaluationResult result=fe.evaluate(nameExpr,new FormulaEvaluationContext(book));
      Object val=result.getValue();
      if (result.getType() == ResultType.SUCCESS) {
        evalNameResult=val;
      }
 else       if (result.getType() == ResultType.ERROR) {
        evalNameResult=(val instanceof ErrorValue) ? val : new ErrorValue(ErrorValue.INVALID_NAME);
      }
    }
    if (valueExpr != null) {
      EvaluationResult result=fe.evaluate(valueExpr,new FormulaEvaluationContext(book));
      Object val=result.getValue();
      if (result.getType() == ResultType.SUCCESS) {
        evalValuesResult=val;
      }
 else       if (result.getType() == ResultType.ERROR) {
        evalValuesResult=(val instanceof ErrorValue) ? val : new ErrorValue(ErrorValue.INVALID_NAME);
      }
    }
    if (yValueExpr != null) {
      EvaluationResult result=fe.evaluate(yValueExpr,new FormulaEvaluationContext(book));
      Object val=result.getValue();
      if (result.getType() == ResultType.SUCCESS) {
        evalYValuesResult=val;
      }
 else       if (result.getType() == ResultType.ERROR) {
        evalYValuesResult=(val instanceof ErrorValue) ? val : new ErrorValue(ErrorValue.INVALID_NAME);
      }
    }
    evaluated=true;
  }
}","void evalFormula(){
  if (!evaluated) {
    FormulaEngine fe=EngineFactory.getInstance().createFormulaEngine();
    NSheet sheet=chart.getSheet();
    if (nameExpr != null) {
      EvaluationResult result=fe.evaluate(nameExpr,new FormulaEvaluationContext(sheet));
      Object val=result.getValue();
      if (result.getType() == ResultType.SUCCESS) {
        evalNameResult=val;
      }
 else       if (result.getType() == ResultType.ERROR) {
        evalNameResult=(val instanceof ErrorValue) ? val : new ErrorValue(ErrorValue.INVALID_NAME);
      }
    }
    if (valueExpr != null) {
      EvaluationResult result=fe.evaluate(valueExpr,new FormulaEvaluationContext(sheet));
      Object val=result.getValue();
      if (result.getType() == ResultType.SUCCESS) {
        evalValuesResult=val;
      }
 else       if (result.getType() == ResultType.ERROR) {
        evalValuesResult=(val instanceof ErrorValue) ? val : new ErrorValue(ErrorValue.INVALID_NAME);
      }
    }
    if (yValueExpr != null) {
      EvaluationResult result=fe.evaluate(yValueExpr,new FormulaEvaluationContext(sheet));
      Object val=result.getValue();
      if (result.getType() == ResultType.SUCCESS) {
        evalYValuesResult=val;
      }
 else       if (result.getType() == ResultType.ERROR) {
        evalYValuesResult=(val instanceof ErrorValue) ? val : new ErrorValue(ErrorValue.INVALID_NAME);
      }
    }
    evaluated=true;
  }
}",0.9799789251844048
56540,"@Override public void add(Ref dependant,Ref precedent){
  Set<Ref> precedents=map.get(dependant);
  if (precedents == null) {
    precedents=new HashSet<Ref>();
    map.put(dependant,precedents);
  }
  precedents.add(precedent);
}","@Override public void add(Ref dependant,Ref precedent){
  Set<Ref> precedents=map.get(dependant);
  if (precedents == null) {
    precedents=new LinkedHashSet<Ref>();
    map.put(dependant,precedents);
  }
  precedents.add(precedent);
}",0.9871244635193132
56541,"@Override public Set<Ref> getDependents(Ref precedent){
  Set<Ref> result=new HashSet<Ref>();
  Queue<Ref> queue=new LinkedList<Ref>();
  queue.add(precedent);
  while (!queue.isEmpty()) {
    Ref p=queue.remove();
    for (    Entry<Ref,Set<Ref>> entry : map.entrySet()) {
      Ref target=entry.getKey();
      if (!result.contains(target)) {
        for (        Ref pre : entry.getValue()) {
          if (isMatched(pre,p)) {
            result.add(target);
            queue.add(target);
            break;
          }
        }
      }
    }
  }
  return result;
}","@Override public Set<Ref> getDependents(Ref precedent){
  Set<Ref> result=new LinkedHashSet<Ref>();
  Queue<Ref> queue=new LinkedList<Ref>();
  queue.add(precedent);
  while (!queue.isEmpty()) {
    Ref p=queue.remove();
    for (    Entry<Ref,Set<Ref>> entry : map.entrySet()) {
      Ref target=entry.getKey();
      if (!result.contains(target)) {
        for (        Ref pre : entry.getValue()) {
          if (isMatched(pre,p)) {
            result.add(target);
            queue.add(target);
            break;
          }
        }
      }
    }
  }
  return result;
}",0.9947643979057592
56542,"@Override public EvaluationResult evaluate(FormulaExpression expr,FormulaEvaluationContext context){
  if (expr.hasError()) {
    return new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  EvaluationResult result=null;
  try {
    NBook book=context.getBook();
    EvalBook evalBook=null;
    WorkbookEvaluator evaluator=null;
    BookSeriesAdv bookSeries=(BookSeriesAdv)book.getBookSeries();
    NBook[] books=bookSeries.getBooks().toArray(new NBook[0]);
    String[] bookNames=new String[books.length];
    WorkbookEvaluator[] evaluators=new WorkbookEvaluator[books.length];
    for (int i=0; i < books.length; ++i) {
      bookNames[i]=books[i].getBookName();
      EvalBook eb=new EvalBook(books[i]);
      evaluators[i]=new WorkbookEvaluator(eb,null,null);
      if (context.getBook() == books[i]) {
        evalBook=eb;
        evaluator=evaluators[i];
      }
    }
    CollaboratingWorkbooksEnvironment.setup(bookNames,evaluators);
    if (evalBook == null || evaluator == null) {
      return new EvaluationResultImpl(ResultType.ERROR,""String_Node_Str"");
    }
    ValueEval value=null;
    int currentSheetIndex=book.getSheetIndex(context.getSheet());
    if (context.getCell().isNull()) {
      value=evaluator.evaluate(currentSheetIndex,expr.getFormulaString(),false);
    }
 else {
      NCell cell=context.getCell();
      EvaluationCell evalCell=evalBook.getSheet(currentSheetIndex).getCell(cell.getRowIndex(),cell.getColumnIndex());
      value=evaluator.evaluate(evalCell);
    }
    if (value instanceof ErrorEval) {
      int code=((ErrorEval)value).getErrorCode();
      result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue((byte)code));
    }
 else     if (value instanceof StringEval) {
      result=new EvaluationResultImpl(ResultType.SUCCESS,((StringEval)value).getStringValue());
    }
 else     if (value instanceof NumberEval) {
      result=new EvaluationResultImpl(ResultType.SUCCESS,((NumberEval)value).getNumberValue());
    }
 else     if (value instanceof ValuesEval) {
      ValueEval[] values=((ValuesEval)value).getValueEvals();
      Object[] array=new Object[values.length];
      for (int i=0; i < values.length; ++i) {
        if (value instanceof StringEval) {
          array[i]=((StringEval)values[i]).getStringValue();
        }
 else         if (value instanceof NumberEval) {
          array[i]=((NumberEval)values[i]).getNumberValue();
        }
 else {
          throw new Exception(""String_Node_Str"" + array[i]);
        }
      }
      return new EvaluationResultImpl(ResultType.SUCCESS,array);
    }
 else {
      throw new Exception(""String_Node_Str"" + value);
    }
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  return result;
}","@Override public EvaluationResult evaluate(FormulaExpression expr,FormulaEvaluationContext context){
  if (expr.hasError()) {
    return new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  EvaluationResult result=null;
  try {
    NBook book=context.getBook();
    EvalBook evalBook=null;
    WorkbookEvaluator evaluator=null;
    BookSeriesAdv bookSeries=(BookSeriesAdv)book.getBookSeries();
    NBook[] books=bookSeries.getBooks().toArray(new NBook[0]);
    String[] bookNames=new String[books.length];
    WorkbookEvaluator[] evaluators=new WorkbookEvaluator[books.length];
    for (int i=0; i < books.length; ++i) {
      bookNames[i]=books[i].getBookName();
      EvalBook eb=new EvalBook(books[i]);
      evaluators[i]=new WorkbookEvaluator(eb,null,null);
      if (context.getBook() == books[i]) {
        evalBook=eb;
        evaluator=evaluators[i];
      }
    }
    CollaboratingWorkbooksEnvironment.setup(bookNames,evaluators);
    if (evalBook == null || evaluator == null) {
      return new EvaluationResultImpl(ResultType.ERROR,""String_Node_Str"");
    }
    ValueEval value=null;
    int currentSheetIndex=book.getSheetIndex(context.getSheet());
    NCell cell=context.getCell();
    if (cell == null || cell.isNull()) {
      value=evaluator.evaluate(currentSheetIndex,expr.getFormulaString(),true);
    }
 else {
      EvaluationCell evalCell=evalBook.getSheet(currentSheetIndex).getCell(cell.getRowIndex(),cell.getColumnIndex());
      value=evaluator.evaluate(evalCell);
    }
    if (value instanceof ErrorEval) {
      int code=((ErrorEval)value).getErrorCode();
      result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue((byte)code));
    }
 else     if (value instanceof BlankEval) {
      result=new EvaluationResultImpl(ResultType.SUCCESS,""String_Node_Str"");
    }
 else     if (value instanceof StringEval) {
      result=new EvaluationResultImpl(ResultType.SUCCESS,((StringEval)value).getStringValue());
    }
 else     if (value instanceof NumberEval) {
      result=new EvaluationResultImpl(ResultType.SUCCESS,((NumberEval)value).getNumberValue());
    }
 else     if (value instanceof ValuesEval) {
      ValueEval[] values=((ValuesEval)value).getValueEvals();
      Object[] array=new Object[values.length];
      for (int i=0; i < values.length; ++i) {
        array[i]=getResolvedValue(values[i]);
      }
      result=new EvaluationResultImpl(ResultType.SUCCESS,array);
    }
 else     if (value instanceof AreaEval) {
      List<Object> list=new ArrayList<Object>();
      AreaEval area=(AreaEval)value;
      for (int r=0; r < area.getHeight(); ++r) {
        for (int c=0; c < area.getWidth(); ++c) {
          ValueEval v=area.getValue(r,c);
          list.add(getResolvedValue(v));
        }
      }
      result=new EvaluationResultImpl(ResultType.SUCCESS,list);
    }
 else     if (value instanceof RefEval) {
      ValueEval ve=((RefEval)value).getInnerValueEval();
      Object v=getResolvedValue(ve);
      result=new EvaluationResultImpl(ResultType.SUCCESS,v);
    }
 else {
      throw new Exception(""String_Node_Str"" + value);
    }
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    result=new EvaluationResultImpl(ResultType.ERROR,new ErrorValue(ErrorValue.INVALID_FORMULA));
  }
  return result;
}",0.7956746287927695
56543,"@Test public void testChartData(){
  NBook book=NBooks.createBook(""String_Node_Str"");
  NSheet sheet=book.createSheet(""String_Node_Str"");
  NChart p1=sheet.addChart(NChart.NChartType.BAR,new NViewAnchor(6,10,22,33,800,600));
  NCategoryChartData chartData=(NCategoryChartData)p1.getData();
  Assert.assertEquals(0,chartData.getNumOfCategory());
  Assert.assertEquals(0,chartData.getNumOfSeries());
  Assert.assertEquals(null,chartData.getCategory(100));
  chartData.setCategoriesFormula(""String_Node_Str"");
  Assert.assertEquals(3,chartData.getNumOfCategory());
  Assert.assertEquals(""String_Node_Str"",chartData.getCategory(0));
  Assert.assertEquals(""String_Node_Str"",chartData.getCategory(1));
  Assert.assertEquals(""String_Node_Str"",chartData.getCategory(2));
  NSeries nseries1=chartData.addSeries();
  Assert.assertEquals(1,chartData.getNumOfSeries());
  Assert.assertEquals(null,nseries1.getName());
  nseries1.setFormula(""String_Node_Str"",null,null);
  Assert.assertEquals(""String_Node_Str"",nseries1.getName());
  Assert.assertTrue(nseries1.isFormulaParsingError());
  nseries1.setFormula(""String_Node_Str"",null,null);
  Assert.assertEquals(""String_Node_Str"",nseries1.getName());
  Assert.assertEquals(0,nseries1.getNumOfValue());
  Assert.assertEquals(0,nseries1.getNumOfYValue());
  Assert.assertFalse(nseries1.isFormulaParsingError());
  nseries1.setFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(0,nseries1.getNumOfValue());
  Assert.assertEquals(0,nseries1.getNumOfYValue());
  Assert.assertTrue(nseries1.isFormulaParsingError());
  nseries1.setFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Assert.assertFalse(nseries1.isFormulaParsingError());
  Assert.assertEquals(3,nseries1.getNumOfValue());
  Assert.assertEquals(3,nseries1.getNumOfYValue());
  Assert.assertEquals(1D,nseries1.getValue(0));
  Assert.assertEquals(2D,nseries1.getValue(1));
  Assert.assertEquals(3D,nseries1.getValue(2));
  Assert.assertEquals(4D,nseries1.getYValue(0));
  Assert.assertEquals(5D,nseries1.getYValue(1));
  Assert.assertEquals(6D,nseries1.getYValue(2));
  NSeries nseries2=chartData.addSeries();
  Assert.assertEquals(2,chartData.getNumOfSeries());
  Assert.assertEquals(null,nseries2.getName());
  Assert.assertEquals(0,nseries2.getNumOfValue());
  nseries2.setFormula(null,""String_Node_Str"",null);
  Assert.assertEquals(3,nseries2.getNumOfValue());
  Assert.assertEquals(4D,nseries2.getValue(0));
  Assert.assertEquals(5D,nseries2.getValue(1));
  Assert.assertEquals(6D,nseries2.getValue(2));
}","@Test public void testChartData(){
  NBook book=NBooks.createBook(""String_Node_Str"");
  NSheet sheet=book.createSheet(""String_Node_Str"");
  sheet.getCell(0,0).setStringValue(""String_Node_Str"");
  sheet.getCell(1,0).setStringValue(""String_Node_Str"");
  sheet.getCell(2,0).setStringValue(""String_Node_Str"");
  sheet.getCell(0,3).setStringValue(""String_Node_Str"");
  sheet.getCell(0,1).setNumberValue(1.0);
  sheet.getCell(1,1).setNumberValue(2.0);
  sheet.getCell(2,1).setNumberValue(3.0);
  sheet.getCell(0,2).setNumberValue(4.0);
  sheet.getCell(1,2).setNumberValue(5.0);
  sheet.getCell(2,2).setNumberValue(6.0);
  NChart p1=sheet.addChart(NChart.NChartType.BAR,new NViewAnchor(6,10,22,33,800,600));
  NCategoryChartData chartData=(NCategoryChartData)p1.getData();
  Assert.assertEquals(0,chartData.getNumOfCategory());
  Assert.assertEquals(0,chartData.getNumOfSeries());
  Assert.assertEquals(null,chartData.getCategory(100));
  chartData.setCategoriesFormula(""String_Node_Str"");
  Assert.assertEquals(3,chartData.getNumOfCategory());
  Assert.assertEquals(""String_Node_Str"",chartData.getCategory(0));
  Assert.assertEquals(""String_Node_Str"",chartData.getCategory(1));
  Assert.assertEquals(""String_Node_Str"",chartData.getCategory(2));
  NSeries nseries1=chartData.addSeries();
  Assert.assertEquals(1,chartData.getNumOfSeries());
  Assert.assertEquals(null,nseries1.getName());
  nseries1.setFormula(""String_Node_Str"",null,null);
  Assert.assertEquals(""String_Node_Str"",nseries1.getName());
  nseries1.setFormula(""String_Node_Str"",null,null);
  Assert.assertEquals(""String_Node_Str"",nseries1.getName());
  Assert.assertEquals(0,nseries1.getNumOfValue());
  Assert.assertEquals(0,nseries1.getNumOfYValue());
  Assert.assertFalse(nseries1.isFormulaParsingError());
  nseries1.setFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(0,nseries1.getNumOfValue());
  Assert.assertEquals(0,nseries1.getNumOfYValue());
  nseries1.setFormula(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Assert.assertFalse(nseries1.isFormulaParsingError());
  Assert.assertEquals(3,nseries1.getNumOfValue());
  Assert.assertEquals(3,nseries1.getNumOfYValue());
  Assert.assertEquals(1D,nseries1.getValue(0));
  Assert.assertEquals(2D,nseries1.getValue(1));
  Assert.assertEquals(3D,nseries1.getValue(2));
  Assert.assertEquals(4D,nseries1.getYValue(0));
  Assert.assertEquals(5D,nseries1.getYValue(1));
  Assert.assertEquals(6D,nseries1.getYValue(2));
  NSeries nseries2=chartData.addSeries();
  Assert.assertEquals(2,chartData.getNumOfSeries());
  Assert.assertEquals(null,nseries2.getName());
  Assert.assertEquals(0,nseries2.getNumOfValue());
  nseries2.setFormula(null,""String_Node_Str"",null);
  Assert.assertEquals(3,nseries2.getNumOfValue());
  Assert.assertEquals(4D,nseries2.getValue(0));
  Assert.assertEquals(5D,nseries2.getValue(1));
  Assert.assertEquals(6D,nseries2.getValue(2));
}",0.8928702010968922
56544,"private HeaderPositionHelper myGetColumnPositionHelper(NSheet sheet){
  HelperContainer<HeaderPositionHelper> helpers=(HelperContainer)getAttribute(COLUMN_SIZE_HELPER_KEY);
  if (helpers == null) {
    setAttribute(COLUMN_SIZE_HELPER_KEY,helpers=new HelperContainer<HeaderPositionHelper>());
  }
  final String sheetId=sheet.getId();
  HeaderPositionHelper helper=helpers.getHelper(sheetId);
  if (helper == null) {
    final int defaultColSize=sheet.getDefaultColumnWidth();
    List<HeaderPositionInfo> infos=new ArrayList<HeaderPositionInfo>();
    for (    NColumn column : sheet.getColumnList()) {
      final boolean hidden=column.isHidden();
      final int columnWidth=column.getWidth();
      if (columnWidth != defaultColSize || hidden) {
        infos.add(new HeaderPositionInfo(column.getIndex(),columnWidth,_custColId.next(),hidden));
      }
    }
    helpers.putHelper(sheetId,helper=new HeaderPositionHelper(defaultColSize,infos));
  }
  return helper;
}","private HeaderPositionHelper myGetColumnPositionHelper(NSheet sheet){
  HelperContainer<HeaderPositionHelper> helpers=(HelperContainer)getAttribute(COLUMN_SIZE_HELPER_KEY);
  if (helpers == null) {
    setAttribute(COLUMN_SIZE_HELPER_KEY,helpers=new HelperContainer<HeaderPositionHelper>());
  }
  final String sheetId=sheet.getId();
  HeaderPositionHelper helper=helpers.getHelper(sheetId);
  if (helper == null) {
    final int defaultColSize=sheet.getDefaultColumnWidth();
    List<HeaderPositionInfo> infos=new ArrayList<HeaderPositionInfo>();
    Iterator<NColumn> iter=sheet.getColumnIterator();
    while (iter.hasNext()) {
      NColumn column=iter.next();
      final boolean hidden=column.isHidden();
      final int columnWidth=column.getWidth();
      if (columnWidth != defaultColSize || hidden) {
        infos.add(new HeaderPositionInfo(column.getIndex(),columnWidth,_custColId.next(),hidden));
      }
    }
    helpers.putHelper(sheetId,helper=new HeaderPositionHelper(defaultColSize,infos));
  }
  return helper;
}",0.9330669330669332
56545,"private HeaderPositionHelper[] getPositionHelpers(NSheet sheet){
  if (sheet == null) {
    return null;
  }
  HelperContainer<HeaderPositionHelper> helpers=(HelperContainer)getAttribute(ROW_SIZE_HELPER_KEY);
  if (helpers == null) {
    setAttribute(ROW_SIZE_HELPER_KEY,helpers=new HelperContainer<HeaderPositionHelper>());
  }
  final String sheetId=sheet.getId();
  HeaderPositionHelper helper=helpers.getHelper(sheetId);
  if (helper == null) {
    int defaultSize=this.getRowheight();
    List<HeaderPositionInfo> infos=new ArrayList<HeaderPositionInfo>();
    for (    NRow row : sheet.getRowList()) {
      final boolean hidden=row.isHidden();
      final int height=row.getHeight();
      if (height != defaultSize || hidden) {
        infos.add(new HeaderPositionInfo(row.getIndex(),height,_custRowId.next(),hidden));
      }
    }
    helpers.putHelper(sheetId,helper=new HeaderPositionHelper(defaultSize,infos));
  }
  return new HeaderPositionHelper[]{helper,myGetColumnPositionHelper(sheet)};
}","private HeaderPositionHelper[] getPositionHelpers(NSheet sheet){
  if (sheet == null) {
    return null;
  }
  HelperContainer<HeaderPositionHelper> helpers=(HelperContainer)getAttribute(ROW_SIZE_HELPER_KEY);
  if (helpers == null) {
    setAttribute(ROW_SIZE_HELPER_KEY,helpers=new HelperContainer<HeaderPositionHelper>());
  }
  final String sheetId=sheet.getId();
  HeaderPositionHelper helper=helpers.getHelper(sheetId);
  if (helper == null) {
    int defaultSize=this.getRowheight();
    List<HeaderPositionInfo> infos=new ArrayList<HeaderPositionInfo>();
    Iterator<NRow> iter=sheet.getRowIterator();
    while (iter.hasNext()) {
      NRow row=iter.next();
      final boolean hidden=row.isHidden();
      final int height=row.getHeight();
      if (height != defaultSize || hidden) {
        infos.add(new HeaderPositionInfo(row.getIndex(),height,_custRowId.next(),hidden));
      }
    }
    helpers.putHelper(sheetId,helper=new HeaderPositionHelper(defaultSize,infos));
  }
  return new HeaderPositionHelper[]{helper,myGetColumnPositionHelper(sheet)};
}",0.9532079112397492
56546,"private void importPoiCell(NRow row,Cell poiCell){
  NCell cell=row.getCell(poiCell.getColumnIndex());
switch (poiCell.getCellType()) {
case Cell.CELL_TYPE_NUMERIC:
    cell.setNumberValue(poiCell.getNumericCellValue());
  break;
case Cell.CELL_TYPE_STRING:
cell.setStringValue(poiCell.getStringCellValue());
break;
case Cell.CELL_TYPE_BOOLEAN:
cell.setBooleanValue(poiCell.getBooleanCellValue());
break;
case Cell.CELL_TYPE_FORMULA:
cell.setFormulaValue(poiCell.getCellFormula());
break;
case Cell.CELL_TYPE_ERROR:
cell.setErrorValue(convertErrorCode(poiCell.getErrorCellValue()));
break;
case Cell.CELL_TYPE_BLANK:
break;
default :
}
if (!importedStyle.containsKey(poiCell.getCellStyle().getIndex())) {
cell.setCellStyle(importXSSFCellStyle((XSSFCellStyle)poiCell.getCellStyle()));
}
}","private void importPoiCell(NRow row,Cell poiCell){
  NCell cell=row.getCell(poiCell.getColumnIndex());
switch (poiCell.getCellType()) {
case Cell.CELL_TYPE_NUMERIC:
    cell.setNumberValue(poiCell.getNumericCellValue());
  break;
case Cell.CELL_TYPE_STRING:
cell.setStringValue(poiCell.getStringCellValue());
break;
case Cell.CELL_TYPE_BOOLEAN:
cell.setBooleanValue(poiCell.getBooleanCellValue());
break;
case Cell.CELL_TYPE_FORMULA:
cell.setFormulaValue(poiCell.getCellFormula());
break;
case Cell.CELL_TYPE_ERROR:
cell.setErrorValue(convertErrorCode(poiCell.getErrorCellValue()));
break;
case Cell.CELL_TYPE_BLANK:
break;
default :
}
cell.setCellStyle(importXSSFCellStyle((XSSFCellStyle)poiCell.getCellStyle()));
}",0.8982035928143712
56547,"/** 
 * Convert CellStyle into NCellStyle
 * @param xssfCellStyle
 */
private NCellStyle importXSSFCellStyle(XSSFCellStyle xssfCellStyle){
  NCellStyle cellStyle=book.createCellStyle(true);
  importedStyle.put(xssfCellStyle.getIndex(),cellStyle);
  cellStyle.setDataFormat(xssfCellStyle.getDataFormatString());
  cellStyle.setWrapText(xssfCellStyle.getWrapText());
  cellStyle.setLocked(xssfCellStyle.getLocked());
  cellStyle.setAlignment(convertAlignment(xssfCellStyle.getAlignmentEnum()));
  cellStyle.setVerticalAlignment(convertVerticalAlignment(xssfCellStyle.getVerticalAlignmentEnum()));
  cellStyle.setFillColor(convertPoiColor(xssfCellStyle.getFillForegroundColorColor(),""String_Node_Str""));
  cellStyle.setBorderLeft(convertBorderType(xssfCellStyle.getBorderLeftEnum()));
  cellStyle.setBorderTop(convertBorderType(xssfCellStyle.getBorderTopEnum()));
  cellStyle.setBorderRight(convertBorderType(xssfCellStyle.getBorderRightEnum()));
  cellStyle.setBorderBottom(convertBorderType(xssfCellStyle.getBorderBottomEnum()));
  cellStyle.setBorderLeftColor(convertPoiColor(xssfCellStyle.getLeftBorderColorColor(),""String_Node_Str""));
  cellStyle.setBorderTopColor(convertPoiColor(xssfCellStyle.getTopBorderColorColor(),""String_Node_Str""));
  cellStyle.setBorderRightColor(convertPoiColor(xssfCellStyle.getRightBorderColorColor(),""String_Node_Str""));
  cellStyle.setBorderBottomColor(convertPoiColor(xssfCellStyle.getBottomBorderColorColor(),""String_Node_Str""));
  cellStyle.setFont(importFont(xssfCellStyle));
  return cellStyle;
}","/** 
 * Convert CellStyle into NCellStyle
 * @param xssfCellStyle
 */
private NCellStyle importXSSFCellStyle(XSSFCellStyle xssfCellStyle){
  NCellStyle cellStyle=null;
  if ((cellStyle=importedStyle.get(xssfCellStyle.getIndex())) == null) {
    cellStyle=book.createCellStyle(true);
    importedStyle.put(xssfCellStyle.getIndex(),cellStyle);
    cellStyle.setDataFormat(xssfCellStyle.getDataFormatString());
    cellStyle.setWrapText(xssfCellStyle.getWrapText());
    cellStyle.setLocked(xssfCellStyle.getLocked());
    cellStyle.setAlignment(convertAlignment(xssfCellStyle.getAlignmentEnum()));
    cellStyle.setVerticalAlignment(convertVerticalAlignment(xssfCellStyle.getVerticalAlignmentEnum()));
    cellStyle.setFillColor(convertPoiColor(xssfCellStyle.getFillForegroundColorColor(),""String_Node_Str""));
    cellStyle.setBorderLeft(convertBorderType(xssfCellStyle.getBorderLeftEnum()));
    cellStyle.setBorderTop(convertBorderType(xssfCellStyle.getBorderTopEnum()));
    cellStyle.setBorderRight(convertBorderType(xssfCellStyle.getBorderRightEnum()));
    cellStyle.setBorderBottom(convertBorderType(xssfCellStyle.getBorderBottomEnum()));
    cellStyle.setBorderLeftColor(convertPoiColor(xssfCellStyle.getLeftBorderColorColor(),""String_Node_Str""));
    cellStyle.setBorderTopColor(convertPoiColor(xssfCellStyle.getTopBorderColorColor(),""String_Node_Str""));
    cellStyle.setBorderRightColor(convertPoiColor(xssfCellStyle.getRightBorderColorColor(),""String_Node_Str""));
    cellStyle.setBorderBottomColor(convertPoiColor(xssfCellStyle.getBottomBorderColorColor(),""String_Node_Str""));
    cellStyle.setHidden(xssfCellStyle.getHidden());
    cellStyle.setFont(importFont(xssfCellStyle));
  }
  return cellStyle;
}",0.9442905509387504
56548,"@Test public void cellStyleTest(){
  NBook book=null;
  try {
    book=importer.imports(fileUnderTest,""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  NSheet sheet=book.getSheetByName(""String_Node_Str"");
  assertEquals(true,sheet.getCell(24,1).getCellStyle().isWrapText());
  assertEquals(VerticalAlignment.TOP,sheet.getCell(26,1).getCellStyle().getVerticalAlignment());
  assertEquals(VerticalAlignment.CENTER,sheet.getCell(26,2).getCellStyle().getVerticalAlignment());
  assertEquals(VerticalAlignment.BOTTOM,sheet.getCell(26,3).getCellStyle().getVerticalAlignment());
  assertEquals(Alignment.LEFT,sheet.getCell(27,1).getCellStyle().getAlignment());
  assertEquals(Alignment.CENTER,sheet.getCell(27,2).getCellStyle().getAlignment());
  assertEquals(Alignment.RIGHT,sheet.getCell(27,3).getCellStyle().getAlignment());
  assertEquals(""String_Node_Str"",sheet.getCell(11,0).getCellStyle().getFillColor().getHtmlColor());
  assertEquals(""String_Node_Str"",sheet.getCell(11,1).getCellStyle().getFillColor().getHtmlColor());
  assertEquals(""String_Node_Str"",sheet.getCell(11,2).getCellStyle().getFillColor().getHtmlColor());
  NSheet protectedSheet=book.getSheetByName(""String_Node_Str"");
  assertEquals(true,protectedSheet.getCell(0,0).getCellStyle().isLocked());
  assertEquals(false,protectedSheet.getCell(1,0).getCellStyle().isLocked());
}","@Test public void cellStyleTest(){
  NBook book=null;
  try {
    book=importer.imports(fileUnderTest,""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  NSheet sheet=book.getSheetByName(""String_Node_Str"");
  assertEquals(true,sheet.getCell(24,1).getCellStyle().isWrapText());
  assertEquals(VerticalAlignment.TOP,sheet.getCell(26,1).getCellStyle().getVerticalAlignment());
  assertEquals(VerticalAlignment.CENTER,sheet.getCell(26,2).getCellStyle().getVerticalAlignment());
  assertEquals(VerticalAlignment.BOTTOM,sheet.getCell(26,3).getCellStyle().getVerticalAlignment());
  assertEquals(Alignment.LEFT,sheet.getCell(27,1).getCellStyle().getAlignment());
  assertEquals(Alignment.CENTER,sheet.getCell(27,2).getCellStyle().getAlignment());
  assertEquals(Alignment.RIGHT,sheet.getCell(27,3).getCellStyle().getAlignment());
  assertEquals(""String_Node_Str"",sheet.getCell(11,0).getCellStyle().getFillColor().getHtmlColor());
  assertEquals(""String_Node_Str"",sheet.getCell(11,1).getCellStyle().getFillColor().getHtmlColor());
  assertEquals(""String_Node_Str"",sheet.getCell(11,2).getCellStyle().getFillColor().getHtmlColor());
  assertTrue(sheet.getCell(27,0).getCellStyle().equals(sheet.getCell(26,0).getCellStyle()));
  assertTrue(sheet.getCell(28,0).getCellStyle().equals(sheet.getCell(26,0).getCellStyle()));
  NSheet protectedSheet=book.getSheetByName(""String_Node_Str"");
  assertEquals(true,protectedSheet.getCell(0,0).getCellStyle().isLocked());
  assertEquals(false,protectedSheet.getCell(1,0).getCellStyle().isLocked());
}",0.9364754098360656
56549,"@Test public void testZSS401CutInSameSheet(){
  Book workbook=Util.loadBook(Issue400Test.class,""String_Node_Str"");
  Range srcRange=Ranges.range(workbook.getSheet(""String_Node_Str""),""String_Node_Str"");
  Range destRange=Ranges.range(workbook.getSheet(""String_Node_Str""),""String_Node_Str"");
  assertEquals(true,srcRange.hasMergedCell());
  CellOperationUtil.cut(srcRange,destRange);
  assertEquals(false,srcRange.hasMergedCell());
}","@Test public void testZSS401CutInSameSheet(){
  Book workbook=Util.loadBook(Issue400Test.class,""String_Node_Str"");
  Range srcRange=Ranges.range(workbook.getSheet(""String_Node_Str""),""String_Node_Str"");
  Range destRange=Ranges.range(workbook.getSheet(""String_Node_Str""),""String_Node_Str"");
  CellOperationUtil.cut(srcRange,destRange);
  assertEquals(false,srcRange.hasMergedCell());
}",0.8220858895705522
56550,"/** 
 * reference to a JavaBean is not evaluated to a cell reference even the value is ""=B2"". So it's not related to this issue.
 */
@Test public void testZSS441(){
  Book workbook=Util.loadBook(""String_Node_Str"");
  Sheet sheet=workbook.getSheet(""String_Node_Str"");
  Range sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(11,sumResult.getCellData().getDoubleValue().intValue());
  sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(22,sumResult.getCellData().getDoubleValue().intValue());
  sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(33,sumResult.getCellData().getDoubleValue().intValue());
}","/** 
 * reference to a JavaBean is not evaluated to a cell reference even the value is ""=B2"". So it's not related to this issue.
 */
@Test public void testZSS441(){
  Book workbook=Util.loadBook(this,""String_Node_Str"");
  Sheet sheet=workbook.getSheet(""String_Node_Str"");
  Range sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(11,sumResult.getCellData().getDoubleValue().intValue());
  sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(22,sumResult.getCellData().getDoubleValue().intValue());
  sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(33,sumResult.getCellData().getDoubleValue().intValue());
}",0.9961270333075136
56551,"@Test public void testZSS441ThreeDimensionalReference(){
  Book workbook=Util.loadBook(""String_Node_Str"");
  Sheet sheet=workbook.getSheet(""String_Node_Str"");
  Range sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(11,sumResult.getCellData().getDoubleValue().intValue());
  sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(22,sumResult.getCellData().getDoubleValue().intValue());
  sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(33,sumResult.getCellData().getDoubleValue().intValue());
}","@Test public void testZSS441ThreeDimensionalReference(){
  Book workbook=Util.loadBook(this,""String_Node_Str"");
  Sheet sheet=workbook.getSheet(""String_Node_Str"");
  Range sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(11,sumResult.getCellData().getDoubleValue().intValue());
  sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(22,sumResult.getCellData().getDoubleValue().intValue());
  sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(33,sumResult.getCellData().getDoubleValue().intValue());
}",0.9953488372093025
56552,"@Test public void testZSS441ExternalBook(){
  Book workbook=Util.loadBook(""String_Node_Str"");
  Book anotherWorkbook=Util.loadBook(""String_Node_Str"");
  BookSeriesBuilder.getInstance().buildBookSeries(new Book[]{workbook,anotherWorkbook});
  Sheet sheet=workbook.getSheet(""String_Node_Str"");
  Range sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(60,sumResult.getCellData().getDoubleValue().intValue());
}","@Test public void testZSS441ExternalBook(){
  Book workbook=Util.loadBook(this,""String_Node_Str"");
  Book anotherWorkbook=Util.loadBook(this,""String_Node_Str"");
  BookSeriesBuilder.getInstance().buildBookSeries(new Book[]{workbook,anotherWorkbook});
  Sheet sheet=workbook.getSheet(""String_Node_Str"");
  Range sumResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(60,sumResult.getCellData().getDoubleValue().intValue());
}",0.9882903981264636
56553,"/** 
 * ""array formula"" is the feature related to ZSS-441 http://office.microsoft.com/en-us/excel-help/guidelines-and-examples-of-array-formulas-HA010228458.aspx
 */
@Test public void testZSS441ArrayFormula(){
  Book workbook=Util.loadBook(""String_Node_Str"");
  Sheet sheet=workbook.getSheet(""String_Node_Str"");
  Range multiplyResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(4,multiplyResult.getCellData().getDoubleValue().intValue());
  multiplyResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(10,multiplyResult.getCellData().getDoubleValue().intValue());
  multiplyResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(18,multiplyResult.getCellData().getDoubleValue().intValue());
  Range arrayColumn=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(8,arrayColumn.getCellData().getDoubleValue().intValue());
  arrayColumn=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(9,arrayColumn.getCellData().getDoubleValue().intValue());
  arrayColumn=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(10,arrayColumn.getCellData().getDoubleValue().intValue());
  sheet=workbook.getSheet(""String_Node_Str"");
  Range arrayRow=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(1,arrayRow.getCellData().getDoubleValue().intValue());
  arrayRow=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(2,arrayRow.getCellData().getDoubleValue().intValue());
  arrayRow=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(3,arrayRow.getCellData().getDoubleValue().intValue());
}","/** 
 * ""array formula"" is the feature related to ZSS-441 http://office.microsoft.com/en-us/excel-help/guidelines-and-examples-of-array-formulas-HA010228458.aspx
 */
@Test public void testZSS441ArrayFormula(){
  Book workbook=Util.loadBook(this,""String_Node_Str"");
  Sheet sheet=workbook.getSheet(""String_Node_Str"");
  Range multiplyResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(4,multiplyResult.getCellData().getDoubleValue().intValue());
  multiplyResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(10,multiplyResult.getCellData().getDoubleValue().intValue());
  multiplyResult=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(18,multiplyResult.getCellData().getDoubleValue().intValue());
  Range arrayColumn=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(8,arrayColumn.getCellData().getDoubleValue().intValue());
  arrayColumn=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(9,arrayColumn.getCellData().getDoubleValue().intValue());
  arrayColumn=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(10,arrayColumn.getCellData().getDoubleValue().intValue());
  sheet=workbook.getSheet(""String_Node_Str"");
  Range arrayRow=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(1,arrayRow.getCellData().getDoubleValue().intValue());
  arrayRow=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(2,arrayRow.getCellData().getDoubleValue().intValue());
  arrayRow=Ranges.range(sheet,""String_Node_Str"");
  assertEquals(3,arrayRow.getCellData().getDoubleValue().intValue());
}",0.9983514671941972
56554,"private void initDefaultAuxHandlers(){
  String category=Category.AUXACTION.getName();
  registerHandler(category,AuxAction.CLOSE_BOOK.getAction(),new CloseBookHandler());
  registerHandler(category,AuxAction.ADD_SHEET.getAction(),new AddSheetHandler());
  registerHandler(category,AuxAction.DELETE_SHEET.getAction(),new DeleteSheetHandler());
  registerHandler(category,AuxAction.RENAME_SHEET.getAction(),new RenameSheetHandler());
  registerHandler(category,AuxAction.MOVE_SHEET_LEFT.getAction(),new MoveSheetHandler(true));
  registerHandler(category,AuxAction.MOVE_SHEET_RIGHT.getAction(),new MoveSheetHandler(false));
  registerHandler(category,AuxAction.GRIDLINES.getAction(),new DisplayGridlinesAction());
  registerHandler(category,AuxAction.PASTE.getAction(),new PasteHandler());
  registerHandler(category,AuxAction.CUT.getAction(),new CutHandler());
  registerHandler(category,AuxAction.COPY.getAction(),new CopyHandler());
  registerHandler(category,AuxAction.FONT_FAMILY.getAction(),new FontFamilyHandler());
  registerHandler(category,AuxAction.FONT_SIZE.getAction(),new FontSizeHandler());
  registerHandler(category,AuxAction.FONT_BOLD.getAction(),new FontBoldHandler());
  registerHandler(category,AuxAction.FONT_ITALIC.getAction(),new FontItalicHandler());
  registerHandler(category,AuxAction.FONT_UNDERLINE.getAction(),new FontUnderlineHandler());
  registerHandler(category,AuxAction.FONT_STRIKE.getAction(),new FontStrikeoutHandler());
  registerHandler(category,AuxAction.BORDER.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_BOTTOM,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_BOTTOM.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_BOTTOM,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_TOP.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_TOP,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_LEFT.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_LEFT,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_RIGHT.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_RIGHT,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_NO.getAction(),new ApplyBorderHandler(ApplyBorderType.FULL,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_ALL.getAction(),new ApplyBorderHandler(ApplyBorderType.FULL,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_OUTSIDE.getAction(),new ApplyBorderHandler(ApplyBorderType.OUTLINE,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_INSIDE.getAction(),new ApplyBorderHandler(ApplyBorderType.INSIDE,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_INSIDE_HORIZONTAL.getAction(),new ApplyBorderHandler(ApplyBorderType.INSIDE_HORIZONTAL,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_INSIDE_VERTICAL.getAction(),new ApplyBorderHandler(ApplyBorderType.INSIDE_VERTICAL,BorderType.THIN));
  registerHandler(category,AuxAction.FONT_COLOR.getAction(),new FontColorHandler());
  registerHandler(category,AuxAction.FILL_COLOR.getAction(),new FillColorHandler());
  registerHandler(category,AuxAction.VERTICAL_ALIGN_TOP.getAction(),new VerticalAlignHandler(VerticalAlignment.TOP));
  registerHandler(category,AuxAction.VERTICAL_ALIGN_MIDDLE.getAction(),new VerticalAlignHandler(VerticalAlignment.CENTER));
  registerHandler(category,AuxAction.VERTICAL_ALIGN_BOTTOM.getAction(),new VerticalAlignHandler(VerticalAlignment.BOTTOM));
  registerHandler(category,AuxAction.HORIZONTAL_ALIGN_LEFT.getAction(),new HorizontalAlignHandler(Alignment.LEFT));
  registerHandler(category,AuxAction.HORIZONTAL_ALIGN_CENTER.getAction(),new HorizontalAlignHandler(Alignment.CENTER));
  registerHandler(category,AuxAction.HORIZONTAL_ALIGN_RIGHT.getAction(),new HorizontalAlignHandler(Alignment.RIGHT));
  registerHandler(category,AuxAction.WRAP_TEXT.getAction(),new WrapTextHandler());
  registerHandler(category,AuxAction.INSERT_SHIFT_CELL_RIGHT.getAction(),new InsertCellRightHandler());
  registerHandler(category,AuxAction.INSERT_SHIFT_CELL_DOWN.getAction(),new InsertCellDownHandler());
  registerHandler(category,AuxAction.INSERT_SHEET_ROW.getAction(),new InsertRowHandler());
  registerHandler(category,AuxAction.INSERT_SHEET_COLUMN.getAction(),new InsertColumnHandler());
  registerHandler(category,AuxAction.DELETE_SHIFT_CELL_LEFT.getAction(),new DeleteCellLeftHandler());
  registerHandler(category,AuxAction.DELETE_SHIFT_CELL_UP.getAction(),new DeleteCellUpHandler());
  registerHandler(category,AuxAction.DELETE_SHEET_ROW.getAction(),new DeleteRowHandler());
  registerHandler(category,AuxAction.DELETE_SHEET_COLUMN.getAction(),new DeleteColumnHandler());
  registerHandler(category,AuxAction.SORT_ASCENDING.getAction(),new SortHandler(false));
  registerHandler(category,AuxAction.SORT_DESCENDING.getAction(),new SortHandler(true));
  registerHandler(category,AuxAction.CLEAR_CONTENT.getAction(),new ClearCellHandler(ClearCellAction.Type.CONTENT));
  registerHandler(category,AuxAction.CLEAR_STYLE.getAction(),new ClearCellHandler(ClearCellAction.Type.STYLE));
  registerHandler(category,AuxAction.CLEAR_ALL.getAction(),new ClearCellHandler(ClearCellAction.Type.ALL));
  registerHandler(category,AuxAction.HIDE_COLUMN.getAction(),new HideHeaderHandler(HideHeaderAction.Type.COLUMN,true));
  registerHandler(category,AuxAction.UNHIDE_COLUMN.getAction(),new HideHeaderHandler(HideHeaderAction.Type.COLUMN,false));
  registerHandler(category,AuxAction.HIDE_ROW.getAction(),new HideHeaderHandler(HideHeaderAction.Type.ROW,true));
  registerHandler(category,AuxAction.UNHIDE_ROW.getAction(),new HideHeaderHandler(HideHeaderAction.Type.ROW,false));
  UserActionHandler folderhandler=new AbstractProtectedHandler(){
    @Override protected boolean processAction(    UserActionContext ctx){
      return false;
    }
  }
;
  registerHandler(category,AuxAction.VERTICAL_ALIGN.getAction(),folderhandler);
  registerHandler(category,AuxAction.HORIZONTAL_ALIGN.getAction(),folderhandler);
  registerHandler(category,AuxAction.INSERT.getAction(),folderhandler);
  registerHandler(category,AuxAction.DELETE.getAction(),folderhandler);
  registerHandler(category,AuxAction.SORT_AND_FILTER.getAction(),folderhandler);
  registerHandler(category,AuxAction.CLEAR.getAction(),folderhandler);
  category=Category.KEYSTROKE.getName();
  registerHandler(category,""String_Node_Str"",new AbstractBookHandler(){
    @Override protected boolean processAction(    UserActionContext ctx){
      doUndo();
      return true;
    }
  }
);
  registerHandler(category,""String_Node_Str"",new AbstractBookHandler(){
    @Override protected boolean processAction(    UserActionContext ctx){
      doRedo();
      return true;
    }
  }
);
  registerHandler(category,""String_Node_Str"",new CutHandler());
  registerHandler(category,""String_Node_Str"",new CopyHandler());
  registerHandler(category,""String_Node_Str"",new PasteHandler());
  registerHandler(category,""String_Node_Str"",new FontBoldHandler());
  registerHandler(category,""String_Node_Str"",new FontItalicHandler());
  registerHandler(category,""String_Node_Str"",new ClearCellHandler(ClearCellAction.Type.CONTENT));
  category=Category.EVENT.getName();
}","private void initDefaultAuxHandlers(){
  String category=Category.AUXACTION.getName();
  registerHandler(category,AuxAction.CLOSE_BOOK.getAction(),new CloseBookHandler());
  registerHandler(category,AuxAction.ADD_SHEET.getAction(),new AddSheetHandler());
  registerHandler(category,AuxAction.DELETE_SHEET.getAction(),new DeleteSheetHandler());
  registerHandler(category,AuxAction.RENAME_SHEET.getAction(),new RenameSheetHandler());
  registerHandler(category,AuxAction.MOVE_SHEET_LEFT.getAction(),new MoveSheetHandler(true));
  registerHandler(category,AuxAction.MOVE_SHEET_RIGHT.getAction(),new MoveSheetHandler(false));
  registerHandler(category,AuxAction.GRIDLINES.getAction(),new DisplayGridlinesAction());
  registerHandler(category,AuxAction.PASTE.getAction(),new PasteHandler());
  registerHandler(category,AuxAction.CUT.getAction(),new CutHandler());
  registerHandler(category,AuxAction.COPY.getAction(),new CopyHandler());
  registerHandler(category,AuxAction.FONT_FAMILY.getAction(),new FontFamilyHandler());
  registerHandler(category,AuxAction.FONT_SIZE.getAction(),new FontSizeHandler());
  registerHandler(category,AuxAction.FONT_BOLD.getAction(),new FontBoldHandler());
  registerHandler(category,AuxAction.FONT_ITALIC.getAction(),new FontItalicHandler());
  registerHandler(category,AuxAction.FONT_UNDERLINE.getAction(),new FontUnderlineHandler());
  registerHandler(category,AuxAction.FONT_STRIKE.getAction(),new FontStrikeoutHandler());
  registerHandler(category,AuxAction.BORDER.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_BOTTOM,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_BOTTOM.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_BOTTOM,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_TOP.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_TOP,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_LEFT.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_LEFT,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_RIGHT.getAction(),new ApplyBorderHandler(ApplyBorderType.EDGE_RIGHT,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_NO.getAction(),new ApplyBorderHandler(ApplyBorderType.FULL,BorderType.NONE));
  registerHandler(category,AuxAction.BORDER_ALL.getAction(),new ApplyBorderHandler(ApplyBorderType.FULL,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_OUTSIDE.getAction(),new ApplyBorderHandler(ApplyBorderType.OUTLINE,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_INSIDE.getAction(),new ApplyBorderHandler(ApplyBorderType.INSIDE,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_INSIDE_HORIZONTAL.getAction(),new ApplyBorderHandler(ApplyBorderType.INSIDE_HORIZONTAL,BorderType.THIN));
  registerHandler(category,AuxAction.BORDER_INSIDE_VERTICAL.getAction(),new ApplyBorderHandler(ApplyBorderType.INSIDE_VERTICAL,BorderType.THIN));
  registerHandler(category,AuxAction.FONT_COLOR.getAction(),new FontColorHandler());
  registerHandler(category,AuxAction.FILL_COLOR.getAction(),new FillColorHandler());
  registerHandler(category,AuxAction.VERTICAL_ALIGN_TOP.getAction(),new VerticalAlignHandler(VerticalAlignment.TOP));
  registerHandler(category,AuxAction.VERTICAL_ALIGN_MIDDLE.getAction(),new VerticalAlignHandler(VerticalAlignment.CENTER));
  registerHandler(category,AuxAction.VERTICAL_ALIGN_BOTTOM.getAction(),new VerticalAlignHandler(VerticalAlignment.BOTTOM));
  registerHandler(category,AuxAction.HORIZONTAL_ALIGN_LEFT.getAction(),new HorizontalAlignHandler(Alignment.LEFT));
  registerHandler(category,AuxAction.HORIZONTAL_ALIGN_CENTER.getAction(),new HorizontalAlignHandler(Alignment.CENTER));
  registerHandler(category,AuxAction.HORIZONTAL_ALIGN_RIGHT.getAction(),new HorizontalAlignHandler(Alignment.RIGHT));
  registerHandler(category,AuxAction.WRAP_TEXT.getAction(),new WrapTextHandler());
  registerHandler(category,AuxAction.INSERT_SHIFT_CELL_RIGHT.getAction(),new InsertCellRightHandler());
  registerHandler(category,AuxAction.INSERT_SHIFT_CELL_DOWN.getAction(),new InsertCellDownHandler());
  registerHandler(category,AuxAction.INSERT_SHEET_ROW.getAction(),new InsertRowHandler());
  registerHandler(category,AuxAction.INSERT_SHEET_COLUMN.getAction(),new InsertColumnHandler());
  registerHandler(category,AuxAction.DELETE_SHIFT_CELL_LEFT.getAction(),new DeleteCellLeftHandler());
  registerHandler(category,AuxAction.DELETE_SHIFT_CELL_UP.getAction(),new DeleteCellUpHandler());
  registerHandler(category,AuxAction.DELETE_SHEET_ROW.getAction(),new DeleteRowHandler());
  registerHandler(category,AuxAction.DELETE_SHEET_COLUMN.getAction(),new DeleteColumnHandler());
  registerHandler(category,AuxAction.SORT_ASCENDING.getAction(),new SortHandler(false));
  registerHandler(category,AuxAction.SORT_DESCENDING.getAction(),new SortHandler(true));
  registerHandler(category,AuxAction.CLEAR_CONTENT.getAction(),new ClearCellHandler(ClearCellAction.Type.CONTENT));
  registerHandler(category,AuxAction.CLEAR_STYLE.getAction(),new ClearCellHandler(ClearCellAction.Type.STYLE));
  registerHandler(category,AuxAction.CLEAR_ALL.getAction(),new ClearCellHandler(ClearCellAction.Type.ALL));
  registerHandler(category,AuxAction.HIDE_COLUMN.getAction(),new HideHeaderHandler(HideHeaderAction.Type.COLUMN,true));
  registerHandler(category,AuxAction.UNHIDE_COLUMN.getAction(),new HideHeaderHandler(HideHeaderAction.Type.COLUMN,false));
  registerHandler(category,AuxAction.HIDE_ROW.getAction(),new HideHeaderHandler(HideHeaderAction.Type.ROW,true));
  registerHandler(category,AuxAction.UNHIDE_ROW.getAction(),new HideHeaderHandler(HideHeaderAction.Type.ROW,false));
  UserActionHandler folderhandler=new AbstractProtectedHandler(){
    @Override protected boolean processAction(    UserActionContext ctx){
      return false;
    }
  }
;
  registerHandler(category,AuxAction.VERTICAL_ALIGN.getAction(),folderhandler);
  registerHandler(category,AuxAction.HORIZONTAL_ALIGN.getAction(),folderhandler);
  registerHandler(category,AuxAction.INSERT.getAction(),folderhandler);
  registerHandler(category,AuxAction.DELETE.getAction(),folderhandler);
  registerHandler(category,AuxAction.SORT_AND_FILTER.getAction(),folderhandler);
  registerHandler(category,AuxAction.CLEAR.getAction(),folderhandler);
  category=Category.KEYSTROKE.getName();
  registerHandler(category,""String_Node_Str"",new AbstractBookHandler(){
    @Override protected boolean processAction(    UserActionContext ctx){
      doUndo();
      return true;
    }
  }
);
  registerHandler(category,""String_Node_Str"",new AbstractBookHandler(){
    @Override protected boolean processAction(    UserActionContext ctx){
      doRedo();
      return true;
    }
  }
);
  registerHandler(category,""String_Node_Str"",new CutHandler());
  registerHandler(category,""String_Node_Str"",new CopyHandler());
  registerHandler(category,""String_Node_Str"",new PasteHandler());
  registerHandler(category,""String_Node_Str"",new FontBoldHandler());
  registerHandler(category,""String_Node_Str"",new FontItalicHandler());
  registerHandler(category,""String_Node_Str"",new ClearCellHandler(ClearCellAction.Type.CONTENT));
  category=Category.EVENT.getName();
}",0.999442586399108
56555,"@Override public void doAfterCompose(Component comp) throws Exception {
  super.doAfterCompose(comp);
  boolean isEE=""String_Node_Str"".equals(Version.getEdition());
  UserActionManager uam=ss.getUserActionManager();
  uam.registerHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.NEW_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doOpenNewBook();
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return true;
    }
  }
);
  uam.setHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.SAVE_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doSaveBook(false);
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return book != null;
    }
  }
);
  if (isEE) {
    uam.setHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.EXPORT_PDF.getAction(),new UserActionHandler(){
      @Override public boolean process(      UserActionContext ctx){
        doExportPdf();
        return true;
      }
      @Override public boolean isEnabled(      Book book,      Sheet sheet){
        return book != null;
      }
    }
);
  }
  uam.registerHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.CLOSE_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doCloseBook();
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return book != null;
    }
  }
);
  ss.addEventListener(Events.ON_SHEET_SELECT,new EventListener<Event>(){
    @Override public void onEvent(    Event event) throws Exception {
      onSheetSelect();
    }
  }
);
  ss.addEventListener(Events.ON_AFTER_UNDOABLE_ACTION,new EventListener<Event>(){
    @Override public void onEvent(    Event event) throws Exception {
      onAfterUndoableAction();
    }
  }
);
  String bookName=null;
  Execution exec=Executions.getCurrent();
  bookName=(String)exec.getArg().get(""String_Node_Str"");
  if (bookName == null) {
    bookName=exec.getParameter(""String_Node_Str"");
  }
  BookInfo bookinfo=null;
  if (!Strings.isBlank(bookName)) {
    bookName=bookName.trim();
    for (    BookInfo info : getRepository().list()) {
      if (bookName.equals(info.getName())) {
        bookinfo=info;
        break;
      }
    }
  }
  String sheetName=Executions.getCurrent().getParameter(""String_Node_Str"");
  if (bookinfo != null) {
    doLoadBook(bookinfo,null,sheetName);
  }
 else {
    doOpenNewBook();
  }
}","@Override public void doAfterCompose(Component comp) throws Exception {
  super.doAfterCompose(comp);
  boolean isEE=""String_Node_Str"".equals(Version.getEdition());
  boolean readonly=UiUtil.isRepositoryReadonly();
  UserActionManager uam=ss.getUserActionManager();
  uam.registerHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.NEW_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doOpenNewBook();
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return true;
    }
  }
);
  if (!readonly) {
    uam.setHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.SAVE_BOOK.getAction(),new UserActionHandler(){
      @Override public boolean process(      UserActionContext ctx){
        doSaveBook(false);
        return true;
      }
      @Override public boolean isEnabled(      Book book,      Sheet sheet){
        return book != null;
      }
    }
);
  }
  if (isEE) {
    uam.setHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.EXPORT_PDF.getAction(),new UserActionHandler(){
      @Override public boolean process(      UserActionContext ctx){
        doExportPdf();
        return true;
      }
      @Override public boolean isEnabled(      Book book,      Sheet sheet){
        return book != null;
      }
    }
);
  }
  uam.registerHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.CLOSE_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doCloseBook();
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return book != null;
    }
  }
);
  ss.addEventListener(Events.ON_SHEET_SELECT,new EventListener<Event>(){
    @Override public void onEvent(    Event event) throws Exception {
      onSheetSelect();
    }
  }
);
  ss.addEventListener(Events.ON_AFTER_UNDOABLE_ACTION,new EventListener<Event>(){
    @Override public void onEvent(    Event event) throws Exception {
      onAfterUndoableAction();
    }
  }
);
  String bookName=null;
  Execution exec=Executions.getCurrent();
  bookName=(String)exec.getArg().get(""String_Node_Str"");
  if (bookName == null) {
    bookName=exec.getParameter(""String_Node_Str"");
  }
  BookInfo bookinfo=null;
  if (!Strings.isBlank(bookName)) {
    bookName=bookName.trim();
    for (    BookInfo info : getRepository().list()) {
      if (bookName.equals(info.getName())) {
        bookinfo=info;
        break;
      }
    }
  }
  String sheetName=Executions.getCurrent().getParameter(""String_Node_Str"");
  if (bookinfo != null) {
    doLoadBook(bookinfo,null,sheetName);
  }
 else {
    doOpenNewBook();
  }
}",0.977550647928454
56556,"@Override public boolean isRedoable(){
  return oldTexts == null && isSheetAvailable();
}","@Override public boolean isRedoable(){
  return oldTexts == null && isSheetAvailable() && !isRangeProtected();
}",0.8855721393034826
56557,"@Override public boolean isUndoable(){
  return oldTexts != null && isSheetAvailable();
}","@Override public boolean isUndoable(){
  return oldTexts != null && isSheetAvailable() && !isRangeProtected();
}",0.8855721393034826
56558,"@Override public void undoAction(){
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
  for (int i=row; i <= lastRow; i++) {
    for (int j=column; j <= lastColumn; j++) {
      Range r=Ranges.range(sheet,i,j);
      try {
        r.setCellEditText(oldTexts[i - row][j - column]);
      }
 catch (      IllegalFormulaException x) {
      }
      ;
    }
  }
  oldTexts=null;
}","@Override public void undoAction(){
  if (isRangeProtected())   return;
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
  for (int i=row; i <= lastRow; i++) {
    for (int j=column; j <= lastColumn; j++) {
      Range r=Ranges.range(sheet,i,j);
      try {
        r.setCellEditText(oldTexts[i - row][j - column]);
      }
 catch (      IllegalFormulaException x) {
      }
      ;
    }
  }
  oldTexts=null;
}",0.9652509652509652
56559,"@Override public void doAfterCompose(Component comp) throws Exception {
  super.doAfterCompose(comp);
  boolean isEE=""String_Node_Str"".equals(Version.getEdition());
  UserActionManager uam=ss.getUserActionManager();
  uam.registerHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.NEW_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doOpenNewBook();
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return true;
    }
  }
);
  uam.setHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.SAVE_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doSaveBook(false);
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return book != null;
    }
  }
);
  if (isEE) {
    uam.setHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.EXPORT_PDF.getAction(),new UserActionHandler(){
      @Override public boolean process(      UserActionContext ctx){
        doExportBook();
        return true;
      }
      @Override public boolean isEnabled(      Book book,      Sheet sheet){
        return book != null;
      }
    }
);
  }
  uam.registerHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.CLOSE_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doCloseBook();
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return book != null;
    }
  }
);
  ss.addEventListener(Events.ON_SHEET_SELECT,new EventListener<Event>(){
    @Override public void onEvent(    Event event) throws Exception {
      onSheetSelect();
    }
  }
);
  ss.addEventListener(Events.ON_AFTER_UNDOABLE_ACTION,new EventListener<Event>(){
    @Override public void onEvent(    Event event) throws Exception {
      onAfterUndoableAction();
    }
  }
);
  String bookName=null;
  Execution exec=Executions.getCurrent();
  bookName=(String)exec.getArg().get(""String_Node_Str"");
  if (bookName == null) {
    bookName=exec.getParameter(""String_Node_Str"");
  }
  BookInfo bookinfo=null;
  if (!Strings.isBlank(bookName)) {
    bookName=bookName.trim();
    for (    BookInfo info : getRepository().list()) {
      if (bookName.equals(info.getName())) {
        bookinfo=info;
        break;
      }
    }
  }
  String sheetName=Executions.getCurrent().getParameter(""String_Node_Str"");
  if (bookinfo != null) {
    doLoadBook(bookinfo,null,sheetName);
  }
 else {
    doOpenNewBook();
  }
}","@Override public void doAfterCompose(Component comp) throws Exception {
  super.doAfterCompose(comp);
  boolean isEE=""String_Node_Str"".equals(Version.getEdition());
  UserActionManager uam=ss.getUserActionManager();
  uam.registerHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.NEW_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doOpenNewBook();
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return true;
    }
  }
);
  uam.setHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.SAVE_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doSaveBook(false);
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return book != null;
    }
  }
);
  if (isEE) {
    uam.setHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.EXPORT_PDF.getAction(),new UserActionHandler(){
      @Override public boolean process(      UserActionContext ctx){
        doExportPdf();
        return true;
      }
      @Override public boolean isEnabled(      Book book,      Sheet sheet){
        return book != null;
      }
    }
);
  }
  uam.registerHandler(DefaultUserActionManagerCtrl.Category.AUXACTION.getName(),AuxAction.CLOSE_BOOK.getAction(),new UserActionHandler(){
    @Override public boolean process(    UserActionContext ctx){
      doCloseBook();
      return true;
    }
    @Override public boolean isEnabled(    Book book,    Sheet sheet){
      return book != null;
    }
  }
);
  ss.addEventListener(Events.ON_SHEET_SELECT,new EventListener<Event>(){
    @Override public void onEvent(    Event event) throws Exception {
      onSheetSelect();
    }
  }
);
  ss.addEventListener(Events.ON_AFTER_UNDOABLE_ACTION,new EventListener<Event>(){
    @Override public void onEvent(    Event event) throws Exception {
      onAfterUndoableAction();
    }
  }
);
  String bookName=null;
  Execution exec=Executions.getCurrent();
  bookName=(String)exec.getArg().get(""String_Node_Str"");
  if (bookName == null) {
    bookName=exec.getParameter(""String_Node_Str"");
  }
  BookInfo bookinfo=null;
  if (!Strings.isBlank(bookName)) {
    bookName=bookName.trim();
    for (    BookInfo info : getRepository().list()) {
      if (bookName.equals(info.getName())) {
        bookinfo=info;
        break;
      }
    }
  }
  String sheetName=Executions.getCurrent().getParameter(""String_Node_Str"");
  if (bookinfo != null) {
    doLoadBook(bookinfo,null,sheetName);
  }
 else {
    doOpenNewBook();
  }
}",0.9986996098829648
56560,"/** 
 * @return Area reference of this selection
 * @since 3.0.0
 */
public String toAreaReference(){
  if (areaRef == null) {
    areaRef=new AreaReference(new CellReference(_top,_left),new CellReference(_bottom,_right)).toString();
  }
  return areaRef;
}","/** 
 * @return Area reference of this selection
 * @since 3.0.0
 */
public String toAreaReference(){
  if (areaRef == null) {
    areaRef=new AreaReference(new CellReference(_top,_left),new CellReference(_bottom,_right)).formatAsString();
  }
  return areaRef;
}",0.9807692307692308
56561,"public SortCellAction(String label,Sheet sheet,int row,int column,int lastRow,int lastColumn,Range index1,boolean desc1,SortDataOption dataOption1,Range index2,boolean desc2,SortDataOption dataOption2,Range index3,boolean desc3,SortDataOption dataOption3,boolean header,boolean matchCase,boolean sortByRows){
  super(label,sheet,row,column,lastRow,lastColumn);
  _simpleMode=false;
  _desc=false;
  _index1=index1;
  _desc1=desc1;
  _dataOption1=dataOption1;
  _index2=index2;
  _desc2=desc2;
  _dataOption2=dataOption2;
  _index3=index3;
  _desc3=desc3;
  _dataOption3=dataOption3;
  _header=header;
  _matchCase=matchCase;
  _sortByRows=sortByRows;
}","public SortCellAction(String label,Sheet sheet,int row,int column,int lastRow,int lastColumn,Range index1,boolean desc1,SortDataOption dataOption1,Range index2,boolean desc2,SortDataOption dataOption2,Range index3,boolean desc3,SortDataOption dataOption3,boolean header,boolean matchCase,boolean sortByRows){
  super(label,sheet,row,column,lastRow,lastColumn,ReserveType.ALL);
  _simpleMode=false;
  _desc=false;
  _index1=index1;
  _desc1=desc1;
  _dataOption1=dataOption1;
  _index2=index2;
  _desc2=desc2;
  _dataOption2=dataOption2;
  _index3=index3;
  _desc3=desc3;
  _dataOption3=dataOption3;
  _header=header;
  _matchCase=matchCase;
  _sortByRows=sortByRows;
}",0.987878787878788
56562,"@Override public boolean isRedoable(){
  return oldTexts == null && isSheetAvailable() && !isSheetProtected();
}","@Override public boolean isRedoable(){
  return oldData == null && isSheetAvailable() && !isSheetProtected();
}",0.968609865470852
56563,"@Override public boolean isUndoable(){
  return oldTexts != null && isSheetAvailable() && !isSheetProtected();
}","@Override public boolean isUndoable(){
  return oldData != null && isSheetAvailable() && !isSheetProtected();
}",0.968609865470852
56564,"@Override public void doAction(){
  if (isSheetProtected())   return;
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
  oldTexts=new String[lastRow - row + 1][lastColumn - column + 1];
  for (int i=row; i <= lastRow; i++) {
    for (int j=column; j <= lastColumn; j++) {
      Range r=Ranges.range(sheet,i,j);
      CellData d=r.getCellData();
      if (d.isBlank()) {
        oldTexts[i - row][j - column]=null;
      }
 else {
        oldTexts[i - row][j - column]=d.getEditText();
      }
    }
  }
  applyAction();
}","@Override public void doAction(){
  if (isSheetProtected())   return;
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
  oldData=new ReservedCellData[lastRow - row + 1][lastColumn - column + 1];
  for (int i=row; i <= lastRow; i++) {
    for (int j=column; j <= lastColumn; j++) {
      Range r=Ranges.range(sheet,i,j);
      oldData[i - row][j - column]=ReservedCellData.reserve(r);
    }
  }
  applyAction();
}",0.8148774302620456
56565,"@Override public void undoAction(){
  if (isSheetProtected())   return;
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
  for (int i=row; i <= lastRow; i++) {
    for (int j=column; j <= lastColumn; j++) {
      Range r=Ranges.range(sheet,i,j);
      try {
        r.setCellEditText(oldTexts[i - row][j - column]);
      }
 catch (      IllegalFormulaException x) {
      }
      ;
    }
  }
  oldTexts=null;
}","@Override public void undoAction(){
  if (isSheetProtected())   return;
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
  for (int i=row; i <= lastRow; i++) {
    for (int j=column; j <= lastColumn; j++) {
      Range r=Ranges.range(sheet,i,j);
      oldData[i - row][j - column].apply(r);
    }
  }
  oldData=null;
}",0.839632277834525
56566,"@Override public void doAction(){
  if (isSheetProtected())   return;
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
switch (_reserveType) {
case DATA:
    _oldTexts=new String[lastRow - row + 1][lastColumn - column + 1];
  break;
case STYLE:
_oldStyles=new CellStyle[lastRow - row + 1][lastColumn - column + 1];
break;
case ALL:
_oldTexts=new String[lastRow - row + 1][lastColumn - column + 1];
_oldStyles=new CellStyle[lastRow - row + 1][lastColumn - column + 1];
}
for (int i=row; i <= lastRow; i++) {
for (int j=column; j <= lastColumn; j++) {
Range r=Ranges.range(sheet,i,j);
if (_oldStyles != null) {
_oldStyles[i - row][j - column]=r.getCellStyle();
}
if (_oldTexts != null) {
CellData d=r.getCellData();
if (d.isBlank()) {
_oldTexts[i - row][j - column]=null;
}
 else {
_oldTexts[i - row][j - column]=d.getEditText();
}
}
}
}
if (_newStyles != null || _newTexts != null) {
for (int i=row; i <= lastRow; i++) {
for (int j=column; j <= lastColumn; j++) {
Range r=Ranges.range(sheet,i,j);
if (_newStyles != null) {
r.setCellStyle(_newStyles[i - row][j - column]);
}
if (_newTexts != null) {
try {
r.setCellEditText(_newTexts[i - row][j - column]);
}
 catch (IllegalFormulaException x) {
}
;
}
}
}
_newStyles=null;
_newTexts=null;
}
 else {
applyAction();
}
}","@Override public void doAction(){
  if (isSheetProtected())   return;
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
switch (_reserveType) {
case DATA:
    _oldData=new ReservedCellData[lastRow - row + 1][lastColumn - column + 1];
  break;
case STYLE:
_oldStyles=new CellStyle[lastRow - row + 1][lastColumn - column + 1];
break;
case ALL:
_oldData=new ReservedCellData[lastRow - row + 1][lastColumn - column + 1];
_oldStyles=new CellStyle[lastRow - row + 1][lastColumn - column + 1];
}
for (int i=row; i <= lastRow; i++) {
for (int j=column; j <= lastColumn; j++) {
Range r=Ranges.range(sheet,i,j);
if (_oldStyles != null) {
_oldStyles[i - row][j - column]=r.getCellStyle();
}
if (_oldData != null) {
_oldData[i - row][j - column]=ReservedCellData.reserve(r);
}
}
}
if (_newStyles != null || _newData != null) {
for (int i=row; i <= lastRow; i++) {
for (int j=column; j <= lastColumn; j++) {
Range r=Ranges.range(sheet,i,j);
if (_newStyles != null) {
r.setCellStyle(_newStyles[i - row][j - column]);
}
if (_newData != null) {
try {
_newData[i - row][j - column].apply(r);
}
 catch (IllegalFormulaException x) {
}
;
}
}
}
_newStyles=null;
_newData=null;
}
 else {
applyAction();
}
}",0.85470719051149
56567,"@Override public void undoAction(){
  if (isSheetProtected())   return;
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
switch (_reserveType) {
case DATA:
    _newTexts=new String[lastRow - row + 1][lastColumn - column + 1];
  break;
case STYLE:
_newStyles=new CellStyle[lastRow - row + 1][lastColumn - column + 1];
break;
case ALL:
_newTexts=new String[lastRow - row + 1][lastColumn - column + 1];
_newStyles=new CellStyle[lastRow - row + 1][lastColumn - column + 1];
}
for (int i=row; i <= lastRow; i++) {
for (int j=column; j <= lastColumn; j++) {
Range r=Ranges.range(sheet,i,j);
if (_newStyles != null) {
_newStyles[i - row][j - column]=r.getCellStyle();
}
if (_newTexts != null) {
CellData d=r.getCellData();
if (d.isBlank()) {
_newTexts[i - row][j - column]=null;
}
 else {
_newTexts[i - row][j - column]=d.getEditText();
}
}
}
}
for (int i=row; i <= lastRow; i++) {
for (int j=column; j <= lastColumn; j++) {
Range r=Ranges.range(sheet,i,j);
if (_oldStyles != null) {
r.setCellStyle(_oldStyles[i - row][j - column]);
}
if (_oldTexts != null) {
try {
r.setCellEditText(_oldTexts[i - row][j - column]);
}
 catch (IllegalFormulaException x) {
}
;
}
}
}
_oldTexts=null;
_oldStyles=null;
}","@Override public void undoAction(){
  if (isSheetProtected())   return;
  int row=getReservedRow();
  int column=getReservedColumn();
  int lastRow=getReservedLastRow();
  int lastColumn=getReservedLastColumn();
  Sheet sheet=getReservedSheet();
switch (_reserveType) {
case DATA:
    _newData=new ReservedCellData[lastRow - row + 1][lastColumn - column + 1];
  break;
case STYLE:
_newStyles=new CellStyle[lastRow - row + 1][lastColumn - column + 1];
break;
case ALL:
_newData=new ReservedCellData[lastRow - row + 1][lastColumn - column + 1];
_newStyles=new CellStyle[lastRow - row + 1][lastColumn - column + 1];
}
for (int i=row; i <= lastRow; i++) {
for (int j=column; j <= lastColumn; j++) {
Range r=Ranges.range(sheet,i,j);
if (_newStyles != null) {
_newStyles[i - row][j - column]=r.getCellStyle();
}
if (_newData != null) {
_newData[i - row][j - column]=ReservedCellData.reserve(r);
}
}
}
for (int i=row; i <= lastRow; i++) {
for (int j=column; j <= lastColumn; j++) {
Range r=Ranges.range(sheet,i,j);
if (_oldStyles != null) {
r.setCellStyle(_oldStyles[i - row][j - column]);
}
if (_oldData != null) {
_oldData[i - row][j - column].apply(r);
}
}
}
_oldData=null;
_oldStyles=null;
}",0.8052673583399841
56568,"private Ref copyRef(Ref srcRef,int colRepeat,int rowRepeat,Ref dstRef,int pasteType,int pasteOp,boolean skipBlanks,boolean transpose,ChangeInfo info){
  final int srcRowCount=srcRef.getRowCount();
  final int srcColCount=srcRef.getColumnCount();
  final Ref pasteRef=getPasteRef(srcRowCount,srcColCount,rowRepeat,colRepeat,dstRef,transpose);
  if (pasteRef == null) {
    return null;
  }
  if (pasteType == XRange.PASTE_COLUMN_WIDTHS) {
    final int srclCol=srcRef.getLeftCol();
    final XSheet srcSheet=BookHelper.getSheet(_sheet,srcRef.getOwnerSheet());
    copyColumnWidths(srcSheet,srcColCount,srclCol,pasteRef);
    return pasteRef;
  }
  final int tRow=srcRef.getTopRow();
  final int lCol=srcRef.getLeftCol();
  final int bRow=srcRef.getBottomRow();
  final int rCol=srcRef.getRightCol();
  final RefSheet dstRefsheet=dstRef.getOwnerSheet();
  final XSheet srcSheet=BookHelper.getSheet(_sheet,srcRef.getOwnerSheet());
  final XSheet dstSheet=BookHelper.getSheet(_sheet,dstRefsheet);
  final Set<Ref> toEval=info.getToEval();
  final Set<Ref> affected=info.getAffected();
  final List<MergeChange> mergeChanges=info.getMergeChanges();
  if (!transpose) {
    int[][] repeatArea=new int[rowRepeat * colRepeat][2];
    for (int rr=rowRepeat, areaCount=0; rr > 0; --rr) {
      for (int cr=colRepeat; cr > 0; --cr, ++areaCount) {
        repeatArea[areaCount][0]=dstRef.getTopRow() + (srcRef.getRowCount() * (rowRepeat - rr));
        repeatArea[areaCount][1]=dstRef.getLeftCol() + (srcRef.getColumnCount() * (colRepeat - cr));
      }
    }
    Set<String> blankMap=new HashSet<String>();
    for (int areaCount=0; areaCount < repeatArea.length; areaCount++) {
      int srcRowPointer=areaCount <= 0 ? srcRef.getTopRow() : repeatArea[0][0];
      int srcColPointer=areaCount <= 0 ? srcRef.getLeftCol() : repeatArea[0][1];
      int dstRowPointer=areaCount <= 0 ? dstRef.getTopRow() : repeatArea[areaCount][0];
      int dstColPointer=areaCount <= 0 ? dstRef.getLeftCol() : repeatArea[areaCount][1];
      int rowStep=1;
      int colStep=1;
      int srcTopRow=srcRowPointer;
      int srcLeftCol=srcColPointer;
      if (srcRowPointer < dstRowPointer) {
        srcRowPointer+=srcRowCount - 1;
        dstRowPointer+=srcRowCount - 1;
        rowStep=-1;
      }
      if (srcColPointer < dstColPointer) {
        srcColPointer+=srcColCount - 1;
        dstColPointer+=srcColCount - 1;
        colStep=-1;
      }
      for (int rowCount=srcRef.getRowCount(); rowCount > 0; rowCount--, srcRowPointer+=rowStep, dstRowPointer+=rowStep) {
        for (int colCount=srcRef.getColumnCount(); colCount > 0; colCount--, srcColPointer+=colStep, dstColPointer+=colStep) {
          final Cell cell=BookHelper.getCell(srcSheet,srcRowPointer,srcColPointer);
          String hitBlankKey=Math.abs(srcRowPointer - srcTopRow) + ""String_Node_Str"" + Math.abs(srcColPointer - srcLeftCol);
          boolean hitBlank=(blankMap.contains(hitBlankKey));
          if (!hitBlank && (cell != null && cell.getCellType() != Cell.CELL_TYPE_BLANK)) {
            final ChangeInfo changeInfo0=BookHelper.copyCell(cell,dstSheet,dstRowPointer,dstColPointer,pasteType,pasteOp,transpose);
            BookHelper.assignChangeInfo(toEval,affected,mergeChanges,changeInfo0);
          }
 else {
            if (!hitBlank) {
              blankMap.add(hitBlankKey);
            }
            if (!skipBlanks) {
              final Set<Ref>[] refs=BookHelper.removeCell(dstSheet,dstRowPointer,dstColPointer);
              BookHelper.assignRefs(toEval,affected,refs);
            }
          }
        }
        srcColPointer-=(colStep * srcColCount);
        dstColPointer-=(colStep * srcColCount);
      }
    }
  }
 else {
    int dstCol=dstRef.getLeftCol();
    for (int rr=rowRepeat; rr > 0; --rr) {
      for (int srcRow=tRow; srcRow <= bRow; ++srcRow, ++dstCol) {
        int dstRow=dstRef.getTopRow();
        for (int cr=colRepeat; cr > 0; --cr) {
          for (int srcCol=lCol; srcCol <= rCol; ++srcCol, ++dstRow) {
            final Cell cell=BookHelper.getCell(srcSheet,srcRow,srcCol);
            if (cell != null) {
              if (!skipBlanks || cell.getCellType() != Cell.CELL_TYPE_BLANK) {
                final ChangeInfo changeInfo0=BookHelper.copyCell(cell,dstSheet,dstRow,dstCol,pasteType,pasteOp,transpose);
                BookHelper.assignChangeInfo(toEval,affected,mergeChanges,changeInfo0);
              }
            }
 else             if (!skipBlanks) {
              final Set<Ref>[] refs=BookHelper.removeCell(dstSheet,dstRow,dstCol);
              BookHelper.assignRefs(toEval,affected,refs);
            }
          }
        }
      }
    }
  }
  affected.add(pasteRef);
  return pasteRef;
}","private Ref copyRef(Ref srcRef,int colRepeat,int rowRepeat,Ref dstRef,int pasteType,int pasteOp,boolean skipBlanks,boolean transpose,ChangeInfo info){
  final int srcRowCount=srcRef.getRowCount();
  final int srcColCount=srcRef.getColumnCount();
  final Ref pasteRef=getPasteRef(srcRowCount,srcColCount,rowRepeat,colRepeat,dstRef,transpose);
  if (pasteRef == null) {
    return null;
  }
  if (pasteType == XRange.PASTE_COLUMN_WIDTHS) {
    final int srclCol=srcRef.getLeftCol();
    final XSheet srcSheet=BookHelper.getSheet(_sheet,srcRef.getOwnerSheet());
    copyColumnWidths(srcSheet,srcColCount,srclCol,pasteRef);
    return pasteRef;
  }
  final int tRow=srcRef.getTopRow();
  final int lCol=srcRef.getLeftCol();
  final int bRow=srcRef.getBottomRow();
  final int rCol=srcRef.getRightCol();
  final RefSheet dstRefsheet=dstRef.getOwnerSheet();
  final XSheet srcSheet=BookHelper.getSheet(_sheet,srcRef.getOwnerSheet());
  final XSheet dstSheet=BookHelper.getSheet(_sheet,dstRefsheet);
  final Set<Ref> toEval=info.getToEval();
  final Set<Ref> affected=info.getAffected();
  final List<MergeChange> mergeChanges=info.getMergeChanges();
  if (!transpose) {
    int[][] repeatArea=new int[rowRepeat * colRepeat][2];
    for (int rr=rowRepeat, areaCount=0; rr > 0; --rr) {
      for (int cr=colRepeat; cr > 0; --cr, ++areaCount) {
        repeatArea[areaCount][0]=dstRef.getTopRow() + (srcRef.getRowCount() * (rowRepeat - rr));
        repeatArea[areaCount][1]=dstRef.getLeftCol() + (srcRef.getColumnCount() * (colRepeat - cr));
      }
    }
    Set<String> blankMap=new HashSet<String>();
    for (int areaCount=0; areaCount < repeatArea.length; areaCount++) {
      int srcRowPointer=areaCount <= 0 ? srcRef.getTopRow() : repeatArea[0][0];
      int srcColPointer=areaCount <= 0 ? srcRef.getLeftCol() : repeatArea[0][1];
      int dstRowPointer=areaCount <= 0 ? dstRef.getTopRow() : repeatArea[areaCount][0];
      int dstColPointer=areaCount <= 0 ? dstRef.getLeftCol() : repeatArea[areaCount][1];
      int rowStep=1;
      int colStep=1;
      int srcTopRow=srcRowPointer;
      int srcLeftCol=srcColPointer;
      if (srcRowPointer < dstRowPointer) {
        srcRowPointer+=srcRowCount - 1;
        dstRowPointer+=srcRowCount - 1;
        rowStep=-1;
      }
      if (srcColPointer < dstColPointer) {
        srcColPointer+=srcColCount - 1;
        dstColPointer+=srcColCount - 1;
        colStep=-1;
      }
      for (int rowCount=srcRef.getRowCount(); rowCount > 0; rowCount--, srcRowPointer+=rowStep, dstRowPointer+=rowStep) {
        for (int colCount=srcRef.getColumnCount(); colCount > 0; colCount--, srcColPointer+=colStep, dstColPointer+=colStep) {
          final Cell cell=BookHelper.getCell(srcSheet,srcRowPointer,srcColPointer);
          String hitBlankKey=Math.abs(srcRowPointer - srcTopRow) + ""String_Node_Str"" + Math.abs(srcColPointer - srcLeftCol);
          boolean hitBlank=(blankMap.contains(hitBlankKey));
          if (!hitBlank && cell != null) {
            if (!(skipBlanks && cell.getCellType() == Cell.CELL_TYPE_BLANK)) {
              final ChangeInfo changeInfo0=BookHelper.copyCell(cell,dstSheet,dstRowPointer,dstColPointer,pasteType,pasteOp,transpose);
              BookHelper.assignChangeInfo(toEval,affected,mergeChanges,changeInfo0);
            }
          }
 else           if (!skipBlanks) {
            final Set<Ref>[] refs=BookHelper.removeCell(dstSheet,dstRowPointer,dstColPointer);
            BookHelper.assignRefs(toEval,affected,refs);
          }
          if (!hitBlank && cell != null && cell.getCellType() == Cell.CELL_TYPE_BLANK) {
            blankMap.add(hitBlankKey);
          }
        }
        srcColPointer-=(colStep * srcColCount);
        dstColPointer-=(colStep * srcColCount);
      }
    }
  }
 else {
    int dstCol=dstRef.getLeftCol();
    for (int rr=rowRepeat; rr > 0; --rr) {
      for (int srcRow=tRow; srcRow <= bRow; ++srcRow, ++dstCol) {
        int dstRow=dstRef.getTopRow();
        for (int cr=colRepeat; cr > 0; --cr) {
          for (int srcCol=lCol; srcCol <= rCol; ++srcCol, ++dstRow) {
            final Cell cell=BookHelper.getCell(srcSheet,srcRow,srcCol);
            if (cell != null) {
              if (!skipBlanks || cell.getCellType() != Cell.CELL_TYPE_BLANK) {
                final ChangeInfo changeInfo0=BookHelper.copyCell(cell,dstSheet,dstRow,dstCol,pasteType,pasteOp,transpose);
                BookHelper.assignChangeInfo(toEval,affected,mergeChanges,changeInfo0);
              }
            }
 else             if (!skipBlanks) {
              final Set<Ref>[] refs=BookHelper.removeCell(dstSheet,dstRow,dstCol);
              BookHelper.assignRefs(toEval,affected,refs);
            }
          }
        }
      }
    }
  }
  affected.add(pasteRef);
  return pasteRef;
}",0.8440037970678198
56569,"@Override public Set<String> getSupportedUserAction(Sheet sheet){
  Set<String> actions=super.getSupportedUserAction(sheet);
  actions.add(DefaultUserAction.NEW_BOOK.getAction());
  if (sheet != null) {
    actions.add(DefaultUserAction.SAVE_BOOK.getAction());
    actions.add(DefaultUserAction.EXPORT_PDF.getAction());
  }
  return actions;
}","@Override public Set<String> getSupportedUserAction(Sheet sheet){
  Set<String> actions=super.getSupportedUserAction(sheet);
  actions.add(DefaultUserAction.NEW_BOOK.getAction());
  if (sheet != null) {
    boolean readonly=UiUtil.isRepositoryReadonly();
    if (!readonly) {
      actions.add(DefaultUserAction.SAVE_BOOK.getAction());
    }
    actions.add(DefaultUserAction.EXPORT_PDF.getAction());
  }
  return actions;
}",0.894393741851369
56570,"/** 
 * Sort range
 * @param index1 the sort index 1
 * @param desc1 true for descent, false for ascent of index 1
 * @param header includes header or not
 * @param matchCase matches character chase of not
 * @param sortByRows  sorts by row or not
 * @param dataOption1 data option 1 for sort
 * @param index2 the sort index 2
 * @param desc2 true for descent, false for ascent of index 2
 * @param dataOption2 data option 2 for sort
 * @param index3 the sort index 3
 * @param desc3 true for descent, false for ascent of index 3
 * @param dataOption3 data option31 for sort
 */
public void sort(Range index1,boolean desc1,boolean header,boolean matchCase,boolean sortByRows,SortDataOption dataOption1,Range index2,boolean desc2,SortDataOption dataOption2,Range index3,boolean desc3,SortDataOption dataOption3);","/** 
 * Sort range
 * @param index1 the sort index 1
 * @param desc1 true for descent, false for ascent of index 1
 * @param header includes header or not
 * @param matchCase matches character chase of not
 * @param sortByRows  sorts by row or not
 * @param dataOption1 data option 1 for sort
 * @param index2 the sort index 2
 * @param desc2 true for descent, false for ascent of index 2
 * @param dataOption2 data option 2 for sort
 * @param index3 the sort index 3
 * @param desc3 true for descent, false for ascent of index 3
 * @param dataOption3 data option31 for sort
 */
public void sort(Range index1,boolean desc1,SortDataOption dataOption1,Range index2,boolean desc2,SortDataOption dataOption2,Range index3,boolean desc3,SortDataOption dataOption3,boolean header,boolean matchCase,boolean sortByRows);",0.8335388409371147
56571,"public void api4Internal(){
  range.notifyDeleteFriendFocus(null);
  range.notifyMoveFriendFocus(null);
}","private void api4Internal(){
  range.notifyDeleteFriendFocus(null);
  range.notifyMoveFriendFocus(null);
}",0.957345971563981
56572,"public void sort(Range index1,boolean desc1,boolean header,boolean matchCase,boolean sortByRows,SortDataOption dataOption1,Range index2,boolean desc2,SortDataOption dataOption2,Range index3,boolean desc3,SortDataOption dataOption3){
  range.sort(index1 == null ? null : ((RangeImpl)index1).getNative(),desc1,index2 == null ? null : ((RangeImpl)index1).getNative(),-1,desc2,index3 == null ? null : ((RangeImpl)index1).getNative(),desc3,header ? BookHelper.SORT_HEADER_YES : BookHelper.SORT_HEADER_NO,-1,matchCase,sortByRows,-1,dataOption1 == null ? BookHelper.SORT_NORMAL_DEFAULT : EnumUtil.toRangeSortDataOption(dataOption1),dataOption2 == null ? BookHelper.SORT_NORMAL_DEFAULT : EnumUtil.toRangeSortDataOption(dataOption2),dataOption3 == null ? BookHelper.SORT_NORMAL_DEFAULT : EnumUtil.toRangeSortDataOption(dataOption3));
}","public void sort(Range index1,boolean desc1,SortDataOption dataOption1,Range index2,boolean desc2,SortDataOption dataOption2,Range index3,boolean desc3,SortDataOption dataOption3,boolean header,boolean matchCase,boolean sortByRows){
  range.sort(index1 == null ? null : ((RangeImpl)index1).getNative(),desc1,index2 == null ? null : ((RangeImpl)index2).getNative(),-1,desc2,index3 == null ? null : ((RangeImpl)index3).getNative(),desc3,header ? BookHelper.SORT_HEADER_YES : BookHelper.SORT_HEADER_NO,-1,matchCase,sortByRows,-1,dataOption1 == null ? BookHelper.SORT_NORMAL_DEFAULT : EnumUtil.toRangeSortDataOption(dataOption1),dataOption2 == null ? BookHelper.SORT_NORMAL_DEFAULT : EnumUtil.toRangeSortDataOption(dataOption2),dataOption3 == null ? BookHelper.SORT_NORMAL_DEFAULT : EnumUtil.toRangeSortDataOption(dataOption3));
}",0.6779661016949152
56573,"public void apiNoOneUse(){
  range.getCount();
  range.getCurrentRegion();
  range.getDependents();
  range.getDirectDependents();
  range.getPrecedents();
  range.isCustomHeight();
}","private void apiNoOneUse(){
  range.getCount();
  range.getCurrentRegion();
  range.getDependents();
  range.getDirectDependents();
  range.getPrecedents();
  range.isCustomHeight();
}",0.9754768392370572
56574,"public void apply(Range cellRange,org.zkoss.zss.api.model.CellStyle newCellstyle){
  newCellstyle.setHidden(mfp_hidden.isChecked());
  newCellstyle.setLocked(mfp_hidden.isChecked());
}","@Override public void apply(Range cellRange,EditableCellStyle newCellstyle){
  newCellstyle.setHidden(mfp_hidden.isChecked());
  newCellstyle.setLocked(mfp_hidden.isChecked());
}",0.8950276243093923
56575,"public boolean ignore(Range cellRange,CellStyle oldCellstyle){
  return oldCellstyle.isHidden() == mfp_hidden.isChecked() && oldCellstyle.isLocked() == mfp_locked.isChecked();
}","@Override public boolean ignore(Range cellRange,CellStyle oldCellstyle){
  return oldCellstyle.isHidden() == mfp_hidden.isChecked() && oldCellstyle.isLocked() == mfp_locked.isChecked();
}",0.9725274725274724
56576,"public void onOK(){
  try {
    final Checkbox mfp_locked=(Checkbox)Path.getComponent(""String_Node_Str"");
    final Checkbox mfp_hidden=(Checkbox)Path.getComponent(""String_Node_Str"");
    Range range=Ranges.range(spreadsheet.getSelectedSheet(),spreadsheet.getSelection());
    CellOperationUtil.applyCellStyle(range,new EditableCellStyle(){
      public boolean ignore(      Range cellRange,      CellStyle oldCellstyle){
        return oldCellstyle.isHidden() == mfp_hidden.isChecked() && oldCellstyle.isLocked() == mfp_locked.isChecked();
      }
      public void apply(      Range cellRange,      org.zkoss.zss.api.model.CellStyle newCellstyle){
        newCellstyle.setHidden(mfp_hidden.isChecked());
        newCellstyle.setLocked(mfp_hidden.isChecked());
      }
    }
);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  Window formatMainWin=(Window)Path.getComponent(""String_Node_Str"");
  formatMainWin.setVisible(false);
  spreadsheet.setHighlight(null);
}","public void onOK(){
  try {
    final Checkbox mfp_locked=(Checkbox)Path.getComponent(""String_Node_Str"");
    final Checkbox mfp_hidden=(Checkbox)Path.getComponent(""String_Node_Str"");
    Range range=Ranges.range(spreadsheet.getSelectedSheet(),spreadsheet.getSelection());
    CellOperationUtil.applyCellStyle(range,new CellStyleApplier(){
      @Override public boolean ignore(      Range cellRange,      CellStyle oldCellstyle){
        return oldCellstyle.isHidden() == mfp_hidden.isChecked() && oldCellstyle.isLocked() == mfp_locked.isChecked();
      }
      @Override public void apply(      Range cellRange,      EditableCellStyle newCellstyle){
        newCellstyle.setHidden(mfp_hidden.isChecked());
        newCellstyle.setLocked(mfp_hidden.isChecked());
      }
    }
);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  Window formatMainWin=(Window)Path.getComponent(""String_Node_Str"");
  formatMainWin.setVisible(false);
  spreadsheet.setHighlight(null);
}",0.9565217391304348
56577,"@Override public boolean doCustomSort(){
  if (spreadsheet.getSelectedSheet() != null) {
    openCustomSortDialog(getSelection());
  }
  return true;
}","public boolean doCustomSort(){
  if (spreadsheet.getSelectedSheet() != null) {
    openCustomSortDialog(getSelection());
  }
  return true;
}",0.9657534246575342
56578,"@Override public boolean doRowHeight(){
  if (spreadsheet.getSelectedSheet() != null) {
    openModifyHeaderSizeDialog(WorkbookCtrl.HEADER_TYPE_ROW,getSelection());
  }
  return true;
}","public boolean doRowHeight(){
  if (spreadsheet.getSelectedSheet() != null) {
    openModifyHeaderSizeDialog(WorkbookCtrl.HEADER_TYPE_ROW,getSelection());
  }
  return true;
}",0.9722222222222222
56579,"@Override public boolean doInsertFunction(){
  openInsertFormulaDialog(getSelection());
  return true;
}","public boolean doInsertFunction(){
  openInsertFormulaDialog(getSelection());
  return true;
}",0.9494949494949496
56580,"@Override public boolean doSaveBook(){
  if (FileHelper.hasSavePermission() && spreadsheet.getBook() != null) {
    DesktopWorkbenchContext workbench=getDesktopWorkbenchContext();
    if (workbench.getWorkbookCtrl().hasFileExtentionName()) {
      workbench.getWorkbookCtrl().save();
      workbench.fireWorkbookSaved();
      _lastActionContext=getContext();
    }
 else {
      workbench.getWorkbenchCtrl().openSaveFileDialog();
      _lastActionContext=getContext();
    }
  }
  return true;
}","public boolean doSaveBook(){
  if (FileHelper.hasSavePermission() && spreadsheet.getBook() != null) {
    DesktopWorkbenchContext workbench=getDesktopWorkbenchContext();
    if (workbench.getWorkbookCtrl().hasFileExtentionName()) {
      workbench.getWorkbookCtrl().save();
      workbench.fireWorkbookSaved();
      _lastActionContext=getContext();
    }
 else {
      workbench.getWorkbenchCtrl().openSaveFileDialog();
      _lastActionContext=getContext();
    }
  }
  return true;
}",0.989816700610998
56581,"@Override public boolean doNewBook(){
  getDesktopWorkbenchContext().getWorkbookCtrl().newBook();
  getDesktopWorkbenchContext().fireWorkbookChanged();
  return true;
}","public boolean doNewBook(){
  getDesktopWorkbenchContext().getWorkbookCtrl().newBook();
  getDesktopWorkbenchContext().fireWorkbookChanged();
  return true;
}",0.9693251533742332
56582,"@Override public boolean doExportPDF(){
  Rect selection=getSelection();
  if (spreadsheet.getBook() != null) {
    openExportPdfDialog(selection);
    _lastActionContext=getContext();
  }
  return true;
}","public boolean doExportPDF(){
  Rect selection=getSelection();
  if (spreadsheet.getBook() != null) {
    openExportPdfDialog(selection);
    _lastActionContext=getContext();
  }
  return true;
}",0.975
56583,"@Override public boolean doPasteSpecial(){
  Rect selection=getSelection();
  Clipboard copyFrom=getClipboard();
  if (copyFrom == null) {
    Messagebox.show(""String_Node_Str"");
    return true;
  }
  if (spreadsheet.getSelectedSheet() != null) {
    spreadsheet.setSelection(selection);
    openPasteSpecialDialog();
    _lastActionContext=getContext();
  }
  return true;
}","public boolean doPasteSpecial(){
  Rect selection=getSelection();
  Clipboard copyFrom=getClipboard();
  if (copyFrom == null) {
    Messagebox.show(""String_Node_Str"");
    return true;
  }
  if (spreadsheet.getSelectedSheet() != null) {
    spreadsheet.setSelection(selection);
    openPasteSpecialDialog();
    _lastActionContext=getContext();
  }
  return true;
}",0.9865229110512128
56584,"@Override public boolean doFormatCell(){
  if (spreadsheet.getSelectedSheet() != null) {
    openFormatNumberDialog(getSelection());
  }
  return true;
}","public boolean doFormatCell(){
  if (spreadsheet.getSelectedSheet() != null) {
    openFormatNumberDialog(getSelection());
  }
  return true;
}",0.9662162162162162
56585,"@Override public boolean doColumnWidth(){
  if (spreadsheet.getSelectedSheet() != null) {
    openModifyHeaderSizeDialog(WorkbookCtrl.HEADER_TYPE_COLUMN,getSelection());
  }
  return true;
}","public boolean doColumnWidth(){
  if (spreadsheet.getSelectedSheet() != null) {
    openModifyHeaderSizeDialog(WorkbookCtrl.HEADER_TYPE_COLUMN,getSelection());
  }
  return true;
}",0.972972972972973
56586,"@Override public boolean doHyperlink(){
  if (spreadsheet.getSelectedSheet() != null) {
    openHyperlinkDialog(getSelection());
  }
  return true;
}","public boolean doHyperlink(){
  if (spreadsheet.getSelectedSheet() != null) {
    openHyperlinkDialog(getSelection());
  }
  return true;
}",0.9652777777777778
56587,"public void onClick$export() throws IOException, InterruptedException {
  applyPrintSetting();
  Exporter c=Exporters.getExporter(""String_Node_Str"");
  if (c == null) {
    Messagebox.show(""String_Node_Str"");
    return;
  }
  if (c.isSupportHeadings()) {
    c.enableHeadings(includeHeadings());
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  export(c,baos);
  final AMedia amedia=new AMedia(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",baos.toByteArray());
  Filedownload.save(amedia);
  revertPrintSetting();
  _exportToHtmlDialog.fireOnClose(null);
}","public void onClick$export() throws IOException, InterruptedException {
  applyPrintSetting();
  Exporter c=Exporters.getExporter(""String_Node_Str"");
  if (c == null) {
    Messagebox.show(""String_Node_Str"");
    return;
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  export(c,baos);
  final AMedia amedia=new AMedia(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",baos.toByteArray());
  Filedownload.save(amedia);
  revertPrintSetting();
  _exportToHtmlDialog.fireOnClose(null);
}",0.9298892988929888
56588,"public void onClick$export() throws InvalidFormatException, IOException, InterruptedException {
  applyPrintSetting();
  Exporter c=Exporters.getExporter(""String_Node_Str"");
  if (c == null) {
    Messagebox.show(""String_Node_Str"");
    return;
  }
  if (c.isSupportHeadings()) {
    c.enableHeadings(includeHeadings());
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  export(c,baos);
  final AMedia amedia=new AMedia(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",baos.toByteArray());
  Filedownload.save(amedia);
  revertPrintSetting();
  _exportToPdfDialog.fireOnClose(null);
}","public void onClick$export() throws InvalidFormatException, IOException, InterruptedException {
  applyPrintSetting();
  Exporter c=Exporters.getExporter(""String_Node_Str"");
  if (c == null) {
    Messagebox.show(""String_Node_Str"");
    return;
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  export(c,baos);
  final AMedia amedia=new AMedia(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",baos.toByteArray());
  Filedownload.save(amedia);
  revertPrintSetting();
  _exportToPdfDialog.fireOnClose(null);
}",0.9327433628318584
56589,"public void focusTo(int row,int column,boolean fireFocusEvent){
  spreadsheet.focusTo(row,column);
  if (fireFocusEvent) {
    org.zkoss.zk.ui.event.Events.sendEvent(new CellEvent(Events.ON_CELL_FOUCSED,spreadsheet,spreadsheet.getSelectedSheet(),row,column));
  }
}","public void focusTo(int row,int column,boolean fireFocusEvent){
  spreadsheet.focusTo(row,column);
  if (fireFocusEvent) {
    org.zkoss.zk.ui.event.Events.sendEvent(new CellEvent(Events.ON_CELL_FOUCSED,spreadsheet,spreadsheet.getSelectedSheet(),row,column,null));
  }
}",0.9906542056074766
56590,"/** 
 * Apply font style according to the   {@link FontStyleApplier}
 * @param range the range to be applied
 * @param applyer the font style appliler
 */
public static void applyFontStyle(Range range,final FontStyleApplier applyer){
  if (range.isProtected())   return;
  range.visit(new CellVisitor(){
    @Override public boolean visit(    Range cellRange){
      CellStyle ostyle=cellRange.getCellStyle();
      Font ofont=ostyle.getFont();
      if (applyer.ignore(cellRange,ostyle,ofont)) {
        return true;
      }
      EditableCellStyle nstyle=cellRange.getCellStyleHelper().createCellStyle(ostyle);
      EditableFont nfont=null;
      Font sfont=applyer.search(cellRange,ostyle,ofont);
      if (sfont == null) {
        nfont=cellRange.getCellStyleHelper().createFont(ofont);
        nstyle.setFont(nfont);
        applyer.apply(cellRange,nstyle,nfont);
      }
 else {
        nstyle.setFont(nfont);
      }
      cellRange.setCellStyle(nstyle);
      return true;
    }
    @Override public boolean ignoreIfNotExist(    int row,    int column){
      return false;
    }
    @Override public boolean createIfNotExist(    int row,    int column){
      return true;
    }
  }
);
}","/** 
 * Apply font style according to the   {@link FontStyleApplier}
 * @param range the range to be applied
 * @param applyer the font style appliler
 */
public static void applyFontStyle(Range range,final FontStyleApplier applyer){
  if (range.isProtected())   return;
  range.visit(new CellVisitor(){
    @Override public boolean visit(    Range cellRange){
      CellStyle ostyle=cellRange.getCellStyle();
      Font ofont=ostyle.getFont();
      if (applyer.ignore(cellRange,ostyle,ofont)) {
        return true;
      }
      EditableCellStyle nstyle=cellRange.getCellStyleHelper().createCellStyle(ostyle);
      EditableFont nfont=null;
      Font sfont=applyer.search(cellRange,ostyle,ofont);
      if (sfont == null) {
        nfont=cellRange.getCellStyleHelper().createFont(ofont);
        nstyle.setFont(nfont);
        applyer.apply(cellRange,nstyle,nfont);
      }
 else {
        nstyle.setFont(sfont);
      }
      cellRange.setCellStyle(nstyle);
      return true;
    }
    @Override public boolean ignoreIfNotExist(    int row,    int column){
      return false;
    }
    @Override public boolean createIfNotExist(    int row,    int column){
      return true;
    }
  }
);
}",0.9991645781119464
56591,"private void refreshToolbarDisabled(){
  Set<UserAction> disabled=new HashSet<UserAction>(_actionDisabled);
  disabled.clear();
  if (getBook() == null) {
    disabled.addAll(Arrays.asList(DefaultUserActionHandler.DisabledAction4BookClosed));
  }
 else {
    if (getSelectedSheet().isProtected()) {
      disabled.addAll(Arrays.asList(DefaultUserActionHandler.DisabledAction4SheetProtected));
    }
    if (!getSelectedSheet().isAutoFilterEnabled()) {
      disabled.addAll(Arrays.asList(DefaultUserActionHandler.DisabledAction4FilterDisabled));
    }
  }
  smartUpdate(""String_Node_Str"",convertActionDisabledToJSON(_actionDisabled));
}","private void refreshToolbarDisabled(){
  if (!isInvalidated()) {
    smartUpdate(""String_Node_Str"",convertActionDisabledToJSON(getDisabledUserAction()));
  }
}",0.3421383647798742
56592,"protected void renderProperties(ContentRenderer renderer) throws IOException {
  super.renderProperties(renderer);
  if (_showToolbar) {
    renderer.render(""String_Node_Str"",convertActionDisabledToJSON(_actionDisabled));
    renderer.render(""String_Node_Str"",_showToolbar);
  }
  renderer.render(""String_Node_Str"",_showFormulabar);
  XSheet sheet=this.getSelectedXSheet();
  if (sheet == null) {
    return;
  }
  if (_showContextMenu) {
    renderer.render(""String_Node_Str"",_showContextMenu);
  }
  if (_clientCacheDisabled)   renderer.render(""String_Node_Str"",_clientCacheDisabled);
  if (_maxRenderedCellSize != DEFAULT_MAX_RENDERED_CELL_SIZE)   renderer.render(""String_Node_Str"",_maxRenderedCellSize);
  List<LinkedHashMap<String,String>> sheetLabels=getSheetLabels();
  if (sheetLabels != null) {
    renderer.render(""String_Node_Str"",sheetLabels);
  }
  if (_showSheetbar)   renderer.render(""String_Node_Str"",_showSheetbar);
  if (!getLinkToNewTab()) {
    renderer.render(""String_Node_Str"",false);
  }
  Map afmap=convertAutoFilterToJSON(sheet.getAutoFilter());
  if (afmap != null) {
    renderer.render(""String_Node_Str"",afmap);
  }
 else {
    renderer.render(""String_Node_Str"",(String)null);
  }
  int rowHeight=getRowheight();
  if (rowHeight != DEFAULT_ROW_HEIGHT) {
    renderer.render(""String_Node_Str"",getRowheight());
  }
  renderer.render(""String_Node_Str"",getColumnwidth());
  if (_hideGridlines) {
    renderer.render(""String_Node_Str"",!_hideGridlines);
  }
  if (_protectSheet)   renderer.render(""String_Node_Str"",_protectSheet);
  renderer.render(""String_Node_Str"",isHidecolumnhead() ? 1 : this.getTopheadheight());
  renderer.render(""String_Node_Str"",isHiderowhead() ? 1 : this.getLeftheadwidth());
  if (_cellpadding != DEFAULT_CELL_PADDING)   renderer.render(""String_Node_Str"",_cellpadding);
  String sheetId=getSelectedSheetId();
  String css=getDynamicMediaURI(this,_cssVersion++,""String_Node_Str"" + this.getUuid() + ""String_Node_Str""+ sheetId,""String_Node_Str"");
  renderer.render(""String_Node_Str"",new JavaScriptValue(""String_Node_Str"" + css + ""String_Node_Str""+ this.getUuid()+ ""String_Node_Str""));
  renderer.render(""String_Node_Str"",css);
  int maxRows=getMaxrows();
  if (maxRows != DEFAULT_MAX_ROWS) {
    renderer.render(""String_Node_Str"",maxRows);
  }
  int maxCols=getMaxcolumns();
  if (maxCols != DEFAULT_MAX_COLUMNS) {
    renderer.render(""String_Node_Str"",maxCols);
  }
  int rowFreeze=getRowfreeze();
  if (rowFreeze != DEFAULT_ROW_FREEZE) {
    renderer.render(""String_Node_Str"",rowFreeze);
  }
  int colFreeze=getColumnfreeze();
  if (colFreeze != DEFAULT_COLUMN_FREEZE) {
    renderer.render(""String_Node_Str"",colFreeze);
  }
  renderer.render(""String_Node_Str"",getSelectedSheetId());
  renderer.render(""String_Node_Str"",getRectStr(_focusRect));
  renderer.render(""String_Node_Str"",getRectStr(_selectionRect));
  if (_highlightRect != null) {
    renderer.render(""String_Node_Str"",getRectStr(_highlightRect));
  }
  HeaderPositionHelper colHelper=getColumnPositionHelper(sheet);
  HeaderPositionHelper rowHelper=getRowPositionHelper(sheet);
  renderer.render(""String_Node_Str"",getSizeHelperStr(colHelper));
  renderer.render(""String_Node_Str"",getSizeHelperStr(rowHelper));
  MergeMatrixHelper mmhelper=getMergeMatrixHelper(sheet);
  Iterator iter=mmhelper.getRanges().iterator();
  StringBuffer merr=new StringBuffer();
  while (iter.hasNext()) {
    MergedRect block=(MergedRect)iter.next();
    int left=block.getLeft();
    int top=block.getTop();
    int right=block.getRight();
    int bottom=block.getBottom();
    int id=block.getId();
    merr.append(left).append(""String_Node_Str"").append(top).append(""String_Node_Str"").append(right).append(""String_Node_Str"").append(bottom).append(""String_Node_Str"").append(id);
    if (iter.hasNext()) {
      merr.append(""String_Node_Str"");
    }
  }
  renderer.render(""String_Node_Str"",merr.toString());
  final SpreadsheetCtrl spreadsheetCtrl=((SpreadsheetCtrl)this.getExtraCtrl());
  int initColSize=getInitColumnSize();
  int preloadColSize=getPreloadColumnSize();
  int initRowSize=getInitRowSize();
  int preloadRowSize=getPreloadRowSize();
  renderer.render(""String_Node_Str"",spreadsheetCtrl.getRangeAttrs(sheet,SpreadsheetCtrl.Header.BOTH,SpreadsheetCtrl.CellAttribute.ALL,0,0,initColSize,initRowSize));
  renderer.render(""String_Node_Str"",preloadColSize);
  renderer.render(""String_Node_Str"",preloadRowSize);
  renderer.render(""String_Node_Str"",initRowSize);
  renderer.render(""String_Node_Str"",initColSize);
  renderer.render(""String_Node_Str"",_hideColhead);
  renderer.render(""String_Node_Str"",_hideRowhead);
  List<Map> dvs=convertDataValidationToJSON(sheet.getDataValidations());
  if (dvs != null) {
    renderer.render(""String_Node_Str"",dvs);
  }
 else {
    renderer.render(""String_Node_Str"",(String)null);
  }
}","protected void renderProperties(ContentRenderer renderer) throws IOException {
  super.renderProperties(renderer);
  if (_showToolbar) {
    renderer.render(""String_Node_Str"",convertActionDisabledToJSON(getDisabledUserAction()));
    renderer.render(""String_Node_Str"",_showToolbar);
  }
  renderer.render(""String_Node_Str"",_showFormulabar);
  XSheet sheet=this.getSelectedXSheet();
  if (sheet == null) {
    return;
  }
  if (_showContextMenu) {
    renderer.render(""String_Node_Str"",_showContextMenu);
  }
  if (_clientCacheDisabled)   renderer.render(""String_Node_Str"",_clientCacheDisabled);
  if (_maxRenderedCellSize != DEFAULT_MAX_RENDERED_CELL_SIZE)   renderer.render(""String_Node_Str"",_maxRenderedCellSize);
  List<LinkedHashMap<String,String>> sheetLabels=getSheetLabels();
  if (sheetLabels != null) {
    renderer.render(""String_Node_Str"",sheetLabels);
  }
  if (_showSheetbar)   renderer.render(""String_Node_Str"",_showSheetbar);
  if (!getLinkToNewTab()) {
    renderer.render(""String_Node_Str"",false);
  }
  Map afmap=convertAutoFilterToJSON(sheet.getAutoFilter());
  if (afmap != null) {
    renderer.render(""String_Node_Str"",afmap);
  }
 else {
    renderer.render(""String_Node_Str"",(String)null);
  }
  int rowHeight=getRowheight();
  if (rowHeight != DEFAULT_ROW_HEIGHT) {
    renderer.render(""String_Node_Str"",getRowheight());
  }
  renderer.render(""String_Node_Str"",getColumnwidth());
  if (_hideGridlines) {
    renderer.render(""String_Node_Str"",!_hideGridlines);
  }
  if (_protectSheet)   renderer.render(""String_Node_Str"",_protectSheet);
  renderer.render(""String_Node_Str"",isHidecolumnhead() ? 1 : this.getTopheadheight());
  renderer.render(""String_Node_Str"",isHiderowhead() ? 1 : this.getLeftheadwidth());
  if (_cellpadding != DEFAULT_CELL_PADDING)   renderer.render(""String_Node_Str"",_cellpadding);
  String sheetId=getSelectedSheetId();
  String css=getDynamicMediaURI(this,_cssVersion++,""String_Node_Str"" + this.getUuid() + ""String_Node_Str""+ sheetId,""String_Node_Str"");
  renderer.render(""String_Node_Str"",new JavaScriptValue(""String_Node_Str"" + css + ""String_Node_Str""+ this.getUuid()+ ""String_Node_Str""));
  renderer.render(""String_Node_Str"",css);
  int maxRows=getMaxrows();
  if (maxRows != DEFAULT_MAX_ROWS) {
    renderer.render(""String_Node_Str"",maxRows);
  }
  int maxCols=getMaxcolumns();
  if (maxCols != DEFAULT_MAX_COLUMNS) {
    renderer.render(""String_Node_Str"",maxCols);
  }
  int rowFreeze=getRowfreeze();
  if (rowFreeze != DEFAULT_ROW_FREEZE) {
    renderer.render(""String_Node_Str"",rowFreeze);
  }
  int colFreeze=getColumnfreeze();
  if (colFreeze != DEFAULT_COLUMN_FREEZE) {
    renderer.render(""String_Node_Str"",colFreeze);
  }
  renderer.render(""String_Node_Str"",getSelectedSheetId());
  renderer.render(""String_Node_Str"",getRectStr(_focusRect));
  renderer.render(""String_Node_Str"",getRectStr(_selectionRect));
  if (_highlightRect != null) {
    renderer.render(""String_Node_Str"",getRectStr(_highlightRect));
  }
  HeaderPositionHelper colHelper=getColumnPositionHelper(sheet);
  HeaderPositionHelper rowHelper=getRowPositionHelper(sheet);
  renderer.render(""String_Node_Str"",getSizeHelperStr(colHelper));
  renderer.render(""String_Node_Str"",getSizeHelperStr(rowHelper));
  MergeMatrixHelper mmhelper=getMergeMatrixHelper(sheet);
  Iterator iter=mmhelper.getRanges().iterator();
  StringBuffer merr=new StringBuffer();
  while (iter.hasNext()) {
    MergedRect block=(MergedRect)iter.next();
    int left=block.getLeft();
    int top=block.getTop();
    int right=block.getRight();
    int bottom=block.getBottom();
    int id=block.getId();
    merr.append(left).append(""String_Node_Str"").append(top).append(""String_Node_Str"").append(right).append(""String_Node_Str"").append(bottom).append(""String_Node_Str"").append(id);
    if (iter.hasNext()) {
      merr.append(""String_Node_Str"");
    }
  }
  renderer.render(""String_Node_Str"",merr.toString());
  final SpreadsheetCtrl spreadsheetCtrl=((SpreadsheetCtrl)this.getExtraCtrl());
  int initColSize=getInitColumnSize();
  int preloadColSize=getPreloadColumnSize();
  int initRowSize=getInitRowSize();
  int preloadRowSize=getPreloadRowSize();
  renderer.render(""String_Node_Str"",spreadsheetCtrl.getRangeAttrs(sheet,SpreadsheetCtrl.Header.BOTH,SpreadsheetCtrl.CellAttribute.ALL,0,0,initColSize,initRowSize));
  renderer.render(""String_Node_Str"",preloadColSize);
  renderer.render(""String_Node_Str"",preloadRowSize);
  renderer.render(""String_Node_Str"",initRowSize);
  renderer.render(""String_Node_Str"",initColSize);
  renderer.render(""String_Node_Str"",_hideColhead);
  renderer.render(""String_Node_Str"",_hideRowhead);
  List<Map> dvs=convertDataValidationToJSON(sheet.getDataValidations());
  if (dvs != null) {
    renderer.render(""String_Node_Str"",dvs);
  }
 else {
    renderer.render(""String_Node_Str"",(String)null);
  }
}",0.9970978441127696
56593,"@Test public void testMergeCells(){
  XSheet sheet1=_workbook.getWorksheet(""String_Node_Str"");
  Row row1=sheet1.getRow(0);
  Row row2=sheet1.getRow(1);
  Row row6=sheet1.getRow(5);
  Row row7=sheet1.getRow(6);
  Row row9=sheet1.getRow(8);
  Row row10=sheet1.getRow(9);
  Row row11=sheet1.getRow(10);
  Row row12=sheet1.getRow(11);
  assertEquals(Cell.CELL_TYPE_BLANK,row1.getCell(0).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row1.getCell(1).getCellType());
  assertNull(row1.getCell(2));
  assertEquals(Cell.CELL_TYPE_BLANK,row2.getCell(0).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row2.getCell(1).getCellType());
  assertNull(row2.getCell(2));
  assertEquals(1,row9.getCell(0).getNumericCellValue(),0.0000000000000001);
  assertEquals(2,row7.getCell(3).getNumericCellValue(),0.0000000000000001);
  assertNull(sheet1.getRow(4));
  Cell cellC6=row6.getCell(2);
  CellValue valueC6=_evaluator.evaluate(cellC6);
  assertEquals(1,valueC6.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueC6.getCellType());
  testToFormulaString(cellC6,""String_Node_Str"");
  Cell cellA10=row10.getCell(0);
  CellValue valueA10=_evaluator.evaluate(cellA10);
  assertEquals(1,valueA10.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA10.getCellType());
  testToFormulaString(cellA10,""String_Node_Str"");
  Cell cellA11=row11.getCell(0);
  CellValue valueA11=_evaluator.evaluate(cellA11);
  assertEquals(0,valueA11.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA11.getCellType());
  testToFormulaString(cellA11,""String_Node_Str"");
  Cell cellA12=row12.getCell(0);
  CellValue valueA12=_evaluator.evaluate(cellA12);
  assertEquals(2,valueA12.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA12.getCellType());
  testToFormulaString(cellA12,""String_Node_Str"");
  BookHelper.merge(sheet1,4,1,6,3,true);
  Row row5=sheet1.getRow(4);
  assertEquals(Cell.CELL_TYPE_FORMULA,row5.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row5.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row5.getCell(3).getCellType());
  assertNull(row5.getCell(4));
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(3).getCellType());
  assertNull(row6.getCell(4));
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(3).getCellType());
  assertNull(row7.getCell(4));
  Cell cellB5=row5.getCell(1);
  CellValue valueB5=_evaluator.evaluate(cellB5);
  assertEquals(1,valueB5.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueB5.getCellType());
  testToFormulaString(cellB5,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA10);
  valueA10=_evaluator.evaluate(cellA10);
  assertEquals(1,valueA10.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA10.getCellType());
  testToFormulaString(cellA10,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA12);
  valueA12=_evaluator.evaluate(cellA12);
  assertEquals(0,valueA12.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA12.getCellType());
  testToFormulaString(cellA12,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA11);
  valueA11=_evaluator.evaluate(cellA11);
  assertEquals(Cell.CELL_TYPE_ERROR,valueA11.getCellType());
  assertEquals(ErrorConstants.ERROR_REF,valueA11.getErrorValue());
}","@Test public void testMergeCells(){
  XSheet sheet1=_workbook.getWorksheet(""String_Node_Str"");
  Row row1=sheet1.getRow(0);
  Row row2=sheet1.getRow(1);
  Row row6=sheet1.getRow(5);
  Row row7=sheet1.getRow(6);
  Row row9=sheet1.getRow(8);
  Row row10=sheet1.getRow(9);
  Row row11=sheet1.getRow(10);
  Row row12=sheet1.getRow(11);
  assertEquals(Cell.CELL_TYPE_BLANK,row1.getCell(0).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row1.getCell(1).getCellType());
  assertNull(row1.getCell(2));
  assertEquals(Cell.CELL_TYPE_BLANK,row2.getCell(0).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row2.getCell(1).getCellType());
  assertNull(row2.getCell(2));
  assertEquals(1,row9.getCell(0).getNumericCellValue(),0.0000000000000001);
  assertEquals(2,row7.getCell(3).getNumericCellValue(),0.0000000000000001);
  assertNull(sheet1.getRow(4));
  Cell cellC6=row6.getCell(2);
  CellValue valueC6=_evaluator.evaluate(cellC6);
  assertEquals(1,valueC6.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueC6.getCellType());
  testToFormulaString(cellC6,""String_Node_Str"");
  Cell cellA10=row10.getCell(0);
  CellValue valueA10=_evaluator.evaluate(cellA10);
  assertEquals(1,valueA10.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA10.getCellType());
  testToFormulaString(cellA10,""String_Node_Str"");
  Cell cellA11=row11.getCell(0);
  CellValue valueA11=_evaluator.evaluate(cellA11);
  assertEquals(0,valueA11.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA11.getCellType());
  testToFormulaString(cellA11,""String_Node_Str"");
  Cell cellA12=row12.getCell(0);
  CellValue valueA12=_evaluator.evaluate(cellA12);
  assertEquals(2,valueA12.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA12.getCellType());
  testToFormulaString(cellA12,""String_Node_Str"");
  BookHelper.merge(sheet1,4,1,6,3,false);
  Row row5=sheet1.getRow(4);
  assertEquals(Cell.CELL_TYPE_FORMULA,row5.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row5.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row5.getCell(3).getCellType());
  assertNull(row5.getCell(4));
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(3).getCellType());
  assertNull(row6.getCell(4));
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(3).getCellType());
  assertNull(row7.getCell(4));
  Cell cellB5=row5.getCell(1);
  CellValue valueB5=_evaluator.evaluate(cellB5);
  assertEquals(1,valueB5.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueB5.getCellType());
  testToFormulaString(cellB5,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA10);
  valueA10=_evaluator.evaluate(cellA10);
  assertEquals(1,valueA10.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA10.getCellType());
  testToFormulaString(cellA10,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA12);
  valueA12=_evaluator.evaluate(cellA12);
  assertEquals(0,valueA12.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA12.getCellType());
  testToFormulaString(cellA12,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA11);
  valueA11=_evaluator.evaluate(cellA11);
  assertEquals(Cell.CELL_TYPE_ERROR,valueA11.getCellType());
  assertEquals(ErrorConstants.ERROR_REF,valueA11.getErrorValue());
}",0.9990396487858416
56594,"@Test public void testMergeCells(){
  XSheet sheet1=_workbook.getWorksheet(""String_Node_Str"");
  Row row1=sheet1.getRow(0);
  Row row2=sheet1.getRow(1);
  Row row6=sheet1.getRow(5);
  Row row7=sheet1.getRow(6);
  Row row9=sheet1.getRow(8);
  Row row10=sheet1.getRow(9);
  Row row11=sheet1.getRow(10);
  Row row12=sheet1.getRow(11);
  assertEquals(Cell.CELL_TYPE_BLANK,row1.getCell(0).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row1.getCell(1).getCellType());
  assertNull(row1.getCell(2));
  assertEquals(Cell.CELL_TYPE_BLANK,row2.getCell(0).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row2.getCell(1).getCellType());
  assertNull(row2.getCell(2));
  assertEquals(1,row9.getCell(0).getNumericCellValue(),0.0000000000000001);
  assertEquals(2,row7.getCell(3).getNumericCellValue(),0.0000000000000001);
  assertNull(sheet1.getRow(4));
  Cell cellC6=row6.getCell(2);
  CellValue valueC6=_evaluator.evaluate(cellC6);
  assertEquals(1,valueC6.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueC6.getCellType());
  testToFormulaString(cellC6,""String_Node_Str"");
  Cell cellA10=row10.getCell(0);
  CellValue valueA10=_evaluator.evaluate(cellA10);
  assertEquals(1,valueA10.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA10.getCellType());
  testToFormulaString(cellA10,""String_Node_Str"");
  Cell cellA11=row11.getCell(0);
  CellValue valueA11=_evaluator.evaluate(cellA11);
  assertEquals(0,valueA11.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA11.getCellType());
  testToFormulaString(cellA11,""String_Node_Str"");
  Cell cellA12=row12.getCell(0);
  CellValue valueA12=_evaluator.evaluate(cellA12);
  assertEquals(2,valueA12.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA12.getCellType());
  testToFormulaString(cellA12,""String_Node_Str"");
  BookHelper.merge(sheet1,4,1,6,3,true);
  Row row5=sheet1.getRow(4);
  assertEquals(Cell.CELL_TYPE_FORMULA,row5.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row5.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row5.getCell(3).getCellType());
  assertNull(row5.getCell(4));
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(3).getCellType());
  assertNull(row6.getCell(4));
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(3).getCellType());
  assertNull(row7.getCell(4));
  Cell cellB5=row5.getCell(1);
  CellValue valueB5=_evaluator.evaluate(cellB5);
  assertEquals(1,valueB5.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueB5.getCellType());
  testToFormulaString(cellB5,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA10);
  valueA10=_evaluator.evaluate(cellA10);
  assertEquals(1,valueA10.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA10.getCellType());
  testToFormulaString(cellA10,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA12);
  valueA12=_evaluator.evaluate(cellA12);
  assertEquals(0,valueA12.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA12.getCellType());
  testToFormulaString(cellA12,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA11);
  valueA11=_evaluator.evaluate(cellA11);
  assertEquals(Cell.CELL_TYPE_ERROR,valueA11.getCellType());
  assertEquals(ErrorConstants.ERROR_REF,valueA11.getErrorValue());
}","@Test public void testMergeCells(){
  XSheet sheet1=_workbook.getWorksheet(""String_Node_Str"");
  Row row1=sheet1.getRow(0);
  Row row2=sheet1.getRow(1);
  Row row6=sheet1.getRow(5);
  Row row7=sheet1.getRow(6);
  Row row9=sheet1.getRow(8);
  Row row10=sheet1.getRow(9);
  Row row11=sheet1.getRow(10);
  Row row12=sheet1.getRow(11);
  assertEquals(Cell.CELL_TYPE_BLANK,row1.getCell(0).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row1.getCell(1).getCellType());
  assertNull(row1.getCell(2));
  assertEquals(Cell.CELL_TYPE_BLANK,row2.getCell(0).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row2.getCell(1).getCellType());
  assertNull(row2.getCell(2));
  assertEquals(1,row9.getCell(0).getNumericCellValue(),0.0000000000000001);
  assertEquals(2,row7.getCell(3).getNumericCellValue(),0.0000000000000001);
  assertNull(sheet1.getRow(4));
  Cell cellC6=row6.getCell(2);
  CellValue valueC6=_evaluator.evaluate(cellC6);
  assertEquals(1,valueC6.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueC6.getCellType());
  testToFormulaString(cellC6,""String_Node_Str"");
  Cell cellA10=row10.getCell(0);
  CellValue valueA10=_evaluator.evaluate(cellA10);
  assertEquals(1,valueA10.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA10.getCellType());
  testToFormulaString(cellA10,""String_Node_Str"");
  Cell cellA11=row11.getCell(0);
  CellValue valueA11=_evaluator.evaluate(cellA11);
  assertEquals(0,valueA11.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA11.getCellType());
  testToFormulaString(cellA11,""String_Node_Str"");
  Cell cellA12=row12.getCell(0);
  CellValue valueA12=_evaluator.evaluate(cellA12);
  assertEquals(2,valueA12.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA12.getCellType());
  testToFormulaString(cellA12,""String_Node_Str"");
  BookHelper.merge(sheet1,4,1,6,3,false);
  Row row5=sheet1.getRow(4);
  assertEquals(Cell.CELL_TYPE_FORMULA,row5.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row5.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row5.getCell(3).getCellType());
  assertNull(row5.getCell(4));
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row6.getCell(3).getCellType());
  assertNull(row6.getCell(4));
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(1).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(2).getCellType());
  assertEquals(Cell.CELL_TYPE_BLANK,row7.getCell(3).getCellType());
  assertNull(row7.getCell(4));
  Cell cellB5=row5.getCell(1);
  CellValue valueB5=_evaluator.evaluate(cellB5);
  assertEquals(1,valueB5.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueB5.getCellType());
  testToFormulaString(cellB5,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA10);
  valueA10=_evaluator.evaluate(cellA10);
  assertEquals(1,valueA10.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA10.getCellType());
  testToFormulaString(cellA10,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA12);
  valueA12=_evaluator.evaluate(cellA12);
  assertEquals(0,valueA12.getNumberValue(),0.0000000000000001);
  assertEquals(Cell.CELL_TYPE_NUMERIC,valueA12.getCellType());
  testToFormulaString(cellA12,""String_Node_Str"");
  _evaluator.notifySetFormula(cellA11);
  valueA11=_evaluator.evaluate(cellA11);
  assertEquals(Cell.CELL_TYPE_ERROR,valueA11.getCellType());
  assertEquals(ErrorConstants.ERROR_REF,valueA11.getErrorValue());
}",0.9990396487858416
56595,"@Test public void testParseDateInput(){
  for (int j=0; j < OK.length; ++j) {
    Object[] result=_formater.parseDateInput(OK[j][0]);
    assertTrue(OK[j][0] + ""String_Node_Str"" + j,result[1] != null);
    assertEquals(OK[j][0] + ""String_Node_Str"" + j,OK[j][1],(String)result[1]);
  }
  for (int j=0; j < FAIL.length; ++j) {
    Object[] result=_formater.parseDateInput(FAIL[j]);
    assertFalse(FAIL[j] + ""String_Node_Str"" + j,result[1] != null);
    assertEquals(FAIL[j] + ""String_Node_Str"" + j,FAIL[j],(String)result[0]);
  }
}","@Test public void testParseDateInput(){
  Locales.setThreadLocal(Locale.US);
  for (int j=0; j < OK.length; ++j) {
    Object[] result=_formater.parseDateInput(OK[j][0]);
    assertTrue(OK[j][0] + ""String_Node_Str"" + j,result[1] != null);
    assertEquals(OK[j][0] + ""String_Node_Str"" + j,OK[j][1],(String)result[1]);
  }
  for (int j=0; j < FAIL.length; ++j) {
    Object[] result=_formater.parseDateInput(FAIL[j]);
    assertFalse(FAIL[j] + ""String_Node_Str"" + j,result[1] != null);
    assertEquals(FAIL[j] + ""String_Node_Str"" + j,FAIL[j],(String)result[0]);
  }
}",0.9662716499544212
56596,"/** 
 * @throws java.lang.Exception
 */
@Before public void setUp() throws Exception {
  final String filename=""String_Node_Str"";
  final InputStream is=new ClassLocator().getResourceAsStream(filename);
  _book=(XBook)new ExcelImporter().imports(is,filename);
  assertTrue(_book instanceof XBook);
  assertTrue(_book instanceof HSSFBookImpl);
  assertTrue(_book instanceof HSSFWorkbook);
  assertEquals(filename,((XBook)_book).getBookName());
  assertEquals(""String_Node_Str"",_book.getSheetName(0));
  assertEquals(0,_book.getSheetIndex(""String_Node_Str""));
}","/** 
 * @throws java.lang.Exception
 */
@Before public void setUp() throws Exception {
  final String filename=""String_Node_Str"";
  final InputStream is=new ClassLocator().getResourceAsStream(filename);
  _book=(XBook)new ExcelImporter().imports(is,filename);
  assertTrue(_book instanceof XBook);
  assertTrue(_book instanceof HSSFBookImpl);
  assertTrue(_book instanceof HSSFWorkbook);
  assertEquals(filename,((XBook)_book).getBookName());
  assertEquals(""String_Node_Str"",_book.getSheetName(0));
  assertEquals(0,_book.getSheetIndex(""String_Node_Str""));
  Library.setProperty(""String_Node_Str"",""String_Node_Str"");
  Library.setProperty(""String_Node_Str"",""String_Node_Str"");
}",0.903069466882068
56597,"/** 
 * Returns true indicate spreadsheet index column/row is number 
 * @return
 */
private boolean isAllCellNumberType(int idx){
  XSheet sheet=ss.getSelectedXSheet();
  Rect rect=ss.getSelection();
  int top=sortOrientation ? idx : rect.getTop();
  int left=sortOrientation ? rect.getLeft() : idx;
  int bottom=sortOrientation ? idx : rect.getBottom();
  int right=sortOrientation ? rect.getRight() : idx;
  for (int row=top; row <= bottom; row++) {
    for (int col=left; col <= right; col++) {
      Cell c=Utils.getCell(sheet,row,col);
      if (c != null) {
        int type=c.getCellType() != Cell.CELL_TYPE_FORMULA ? c.getCellType() : c.getCachedFormulaResultType();
        if (type != Cell.CELL_TYPE_NUMERIC)         return false;
      }
    }
  }
  return true;
}","/** 
 * Returns true indicate spreadsheet index column/row is number 
 * @return
 */
private boolean isAllCellNumberType(int idx){
  Sheet sheet=ss.getSelectedSheet();
  Rect rect=ss.getSelection();
  int top=sortOrientation ? idx : rect.getTop();
  int left=sortOrientation ? rect.getLeft() : idx;
  int bottom=sortOrientation ? idx : rect.getBottom();
  int right=sortOrientation ? rect.getRight() : idx;
  for (int row=top; row <= bottom; row++) {
    for (int col=left; col <= right; col++) {
      Range r=Ranges.range(sheet,row,col);
      if (r.getCellData().getResultType() != CellType.NUMERIC) {
        return false;
      }
    }
  }
  return true;
}",0.8643006263048016
56598,"public void onClick$okBtn(){
  if (hasEmptyArgs(sortLevelModel.getInnerList())) {
    Messagebox.show(getLabel(""String_Node_Str""));
    return;
  }
  String dupTarget=checkDuplicateSortIndex(sortLevelModel.getInnerList());
  if (dupTarget != null) {
    Messagebox.show(dupTarget + ""String_Node_Str"" + getLabel(""String_Node_Str""));
    return;
  }
  int count=0;
  int size=sortLevelModel.size() <= 3 ? sortLevelModel.size() : 3;
  int[] index=new int[size];
  int[] dataOption=new int[size];
  boolean[] algorithm=new boolean[size];
  for (Iterator iter=sortLevelModel.iterator(); iter.hasNext() && count < index.length; count++) {
    SortLevel l=(SortLevel)iter.next();
    index[count]=l.sortIndex;
    algorithm[count]=l.order;
    dataOption[count]=l.dataOption;
  }
  Utils.sort(ss.getSelectedXSheet(),ss.getSelection(),index,algorithm,dataOption,hasHeader.isChecked(),caseSensitive.isChecked(),sortOrientation);
  _customSortDialog.fireOnClose(null);
}","public void onClick$okBtn(){
  if (hasEmptyArgs(sortLevelModel.getInnerList())) {
    Messagebox.show(getLabel(""String_Node_Str""));
    return;
  }
  String dupTarget=checkDuplicateSortIndex(sortLevelModel.getInnerList());
  if (dupTarget != null) {
    Messagebox.show(dupTarget + ""String_Node_Str"" + getLabel(""String_Node_Str""));
    return;
  }
  int count=0;
  int size=sortLevelModel.size() <= 3 ? sortLevelModel.size() : 3;
  int[] index=new int[size];
  int[] dataOption=new int[size];
  boolean[] algorithm=new boolean[size];
  for (Iterator iter=sortLevelModel.iterator(); iter.hasNext() && count < index.length; count++) {
    SortLevel l=(SortLevel)iter.next();
    index[count]=l.sortIndex;
    algorithm[count]=l.order;
    dataOption[count]=l.dataOption;
  }
  sort(ss.getSelectedSheet(),ss.getSelection(),index,algorithm,dataOption,hasHeader.isChecked(),caseSensitive.isChecked(),sortOrientation);
  _customSortDialog.fireOnClose(null);
}",0.9764767381076844
56599,"public void onOK(){
  try {
    Checkbox mfp_locked=(Checkbox)Path.getComponent(""String_Node_Str"");
    Checkbox mfp_hidden=(Checkbox)Path.getComponent(""String_Node_Str"");
    int left=spreadsheet.getSelection().getLeft();
    int right=spreadsheet.getSelection().getRight();
    int top=spreadsheet.getSelection().getTop();
    int bottom=spreadsheet.getSelection().getBottom();
    XSheet sheet=spreadsheet.getSelectedXSheet();
    for (int row=top; row <= bottom; row++) {
      for (int col=left; col <= right; col++) {
        final Cell cell=Utils.getCell(sheet,row,col);
        if (cell != null) {
          CellStyle cs=cell.getCellStyle();
          cs.setHidden(mfp_hidden.isChecked());
          cs.setLocked(mfp_hidden.isChecked());
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
  }
  Window formatMainWin=(Window)Path.getComponent(""String_Node_Str"");
  formatMainWin.setVisible(false);
  spreadsheet.setHighlight(null);
}","public void onOK(){
  try {
    Checkbox mfp_locked=(Checkbox)Path.getComponent(""String_Node_Str"");
    Checkbox mfp_hidden=(Checkbox)Path.getComponent(""String_Node_Str"");
    int left=spreadsheet.getSelection().getLeft();
    int right=spreadsheet.getSelection().getRight();
    int top=spreadsheet.getSelection().getTop();
    int bottom=spreadsheet.getSelection().getBottom();
    Sheet sheet=spreadsheet.getSelectedSheet();
    for (int row=top; row <= bottom; row++) {
      for (int col=left; col <= right; col++) {
        final Cell cell=Utils.getCell(sheet,row,col);
        if (cell != null) {
          CellStyle cs=cell.getCellStyle();
          cs.setHidden(mfp_hidden.isChecked());
          cs.setLocked(mfp_hidden.isChecked());
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
  }
  Window formatMainWin=(Window)Path.getComponent(""String_Node_Str"");
  formatMainWin.setVisible(false);
  spreadsheet.setHighlight(null);
}",0.9643211100099108
56600,"private Font getFont(Worksheet sheet,int row,int column){
  return sheet.getBook().getFontAt(getCell(sheet,3,0).getCellStyle().getFontIndex());
}","private Font getFont(Worksheet sheet,int row,int column){
  return sheet.getBook().getFontAt(getCell(sheet,row,column).getCellStyle().getFontIndex());
}",0.9629629629629628
56601,"private void onFriendFocusMove(SSDataEvent event){
  final Ref rng=event.getRef();
  if (getSheet(rng).equals(_selectedSheet)) {
    final Focus focus=(Focus)event.getPayload();
    final String id=focus.id;
    if (!id.equals(_focus.id)) {
      final Focus ofocus=_focuses.get(id);
      moveEditorFocus(id,focus.name,ofocus != null ? ofocus.color : nextFocusColor(),focus.row,focus.col);
    }
  }
}","private void onFriendFocusMove(SSDataEvent event){
  final Ref rng=event.getRef();
  Worksheet sheet=getSheet(rng);
  if (sheet == null) {
    return;
  }
  if (sheet.equals(_selectedSheet)) {
    final Focus focus=(Focus)event.getPayload();
    final String id=focus.id;
    if (!id.equals(_focus.id)) {
      final Focus ofocus=_focuses.get(id);
      moveEditorFocus(id,focus.name,ofocus != null ? ofocus.color : nextFocusColor(),focus.row,focus.col);
    }
  }
}",0.9170506912442395
56602,"private void onFriendFocusDelete(SSDataEvent event){
  final Ref rng=event.getRef();
  if (BookHelper.getSheet(_book,rng.getOwnerSheet()).equals(_selectedSheet)) {
    final Focus focus=(Focus)event.getPayload();
    removeEditorFocus(focus.id);
  }
}","private void onFriendFocusDelete(SSDataEvent event){
  final Ref rng=event.getRef();
  Worksheet sheet=BookHelper.getSheet(_book,rng.getOwnerSheet());
  if (sheet == null) {
    return;
  }
  if (sheet.equals(_selectedSheet)) {
    final Focus focus=(Focus)event.getPayload();
    removeEditorFocus(focus.id);
  }
}",0.872791519434629
56603,"public static String[] getValidationList(Worksheet sheet,DataValidation validation){
  DataValidationConstraint constraint=validation.getValidationConstraint();
  if (constraint.getValidationType() != ValidationType.LIST) {
    return null;
  }
  String[] list=constraint.getExplicitListValues();
  if (list != null) {
    return list;
  }
  String txt=constraint.getFormula1();
  Book book=sheet.getBook();
  final ValueEval ve=BookHelper.evaluateFormulaValueEval(book,book.getSheetIndex(sheet),txt,true);
  if (ve instanceof AreaEval) {
    final AreaEval ae=(AreaEval)ve;
    if (ae.isColumn() || ae.isRow()) {
      final int rows=ae.getHeight();
      final int cols=ae.getWidth();
      final int top=ae.getFirstRow();
      final int left=ae.getFirstColumn();
      String[] xlist=new String[rows * cols];
      for (int r=0, j=0; r < rows; ++r) {
        int rowIndex=r + top;
        for (int c=0; c < cols; ++c) {
          int colIndex=c + left;
          final Cell cell=BookHelper.getCell(sheet,rowIndex,colIndex);
          xlist[j++]=BookHelper.getCellText(cell);
        }
      }
      return xlist;
    }
  }
  return null;
}","public static String[] getValidationList(Worksheet sheet,DataValidation validation){
  DataValidationConstraint constraint=validation.getValidationConstraint();
  if (constraint.getValidationType() != ValidationType.LIST) {
    return null;
  }
  String[] list=constraint.getExplicitListValues();
  if (list != null) {
    return list;
  }
  String txt=constraint.getFormula1();
  Book book=sheet.getBook();
  final ValueEval ve=BookHelper.evaluateFormulaValueEval(book,book.getSheetIndex(sheet),txt,true);
  if (ve instanceof AreaEval) {
    final AreaEval ae=(AreaEval)ve;
    if (ae.isColumn() || ae.isRow()) {
      Worksheet worksheet=null;
      if (ae instanceof LazyAreaEval) {
        worksheet=book.getWorksheet(((LazyAreaEval)ve).getSheetName());
      }
 else {
        worksheet=sheet;
      }
      final int rows=ae.getHeight();
      final int cols=ae.getWidth();
      final int top=ae.getFirstRow();
      final int left=ae.getFirstColumn();
      String[] xlist=new String[rows * cols];
      for (int r=0, j=0; r < rows; ++r) {
        int rowIndex=r + top;
        for (int c=0; c < cols; ++c) {
          int colIndex=c + left;
          final Cell cell=BookHelper.getCell(worksheet,rowIndex,colIndex);
          xlist[j++]=BookHelper.getCellText(cell);
        }
      }
      return xlist;
    }
  }
  return null;
}",0.9206604913411196
56604,"private Map convertDataValidationToJSON(DataValidation dv){
  final CellRangeAddressList addrList=dv.getRegions();
  final int addrCount=addrList.countRanges();
  final List<Map> addrmapary=new ArrayList<Map>(addrCount);
  for (int j=0; j < addrCount; ++j) {
    final CellRangeAddress addr=addrList.getCellRangeAddress(j);
    final int left=addr.getFirstColumn();
    final int right=addr.getLastColumn();
    final int top=addr.getFirstRow();
    final int bottom=addr.getLastRow();
    final Worksheet sheet=this.getSelectedSheet();
    final Map<String,Integer> addrmap=new HashMap<String,Integer>();
    addrmap.put(""String_Node_Str"",left);
    addrmap.put(""String_Node_Str"",top);
    addrmap.put(""String_Node_Str"",right);
    addrmap.put(""String_Node_Str"",bottom);
    addrmapary.add(addrmap);
  }
  final Map validMap=new HashMap();
  validMap.put(""String_Node_Str"",addrmapary);
  validMap.put(""String_Node_Str"",dv.getSuppressDropDownArrow());
  validMap.put(""String_Node_Str"",dv.getShowPromptBox());
  validMap.put(""String_Node_Str"",dv.getPromptBoxTitle());
  validMap.put(""String_Node_Str"",dv.getPromptBoxText());
  String[] validationList=BookHelper.getValidationList(getSelectedSheet(),dv);
  if (validationList != null) {
    JSONArray jsonAry=new JSONArray();
    for (    String v : validationList) {
      jsonAry.add(v);
    }
    validMap.put(""String_Node_Str"",jsonAry);
  }
  return validMap;
}","private Map convertDataValidationToJSON(DataValidation dv){
  final CellRangeAddressList addrList=dv.getRegions();
  final int addrCount=addrList.countRanges();
  final List<Map> addrmapary=new ArrayList<Map>(addrCount);
  for (int j=0; j < addrCount; ++j) {
    final CellRangeAddress addr=addrList.getCellRangeAddress(j);
    final int left=addr.getFirstColumn();
    final int right=addr.getLastColumn();
    final int top=addr.getFirstRow();
    final int bottom=addr.getLastRow();
    final Worksheet sheet=this.getSelectedSheet();
    final Map<String,Integer> addrmap=new HashMap<String,Integer>();
    addrmap.put(""String_Node_Str"",left);
    addrmap.put(""String_Node_Str"",top);
    addrmap.put(""String_Node_Str"",right);
    addrmap.put(""String_Node_Str"",bottom);
    addrmapary.add(addrmap);
  }
  final Map validMap=new HashMap();
  validMap.put(""String_Node_Str"",addrmapary);
  validMap.put(""String_Node_Str"",dv.getShowPromptBox());
  validMap.put(""String_Node_Str"",dv.getPromptBoxTitle());
  validMap.put(""String_Node_Str"",dv.getPromptBoxText());
  String[] validationList=BookHelper.getValidationList(getSelectedSheet(),dv);
  if (validationList != null) {
    validMap.put(""String_Node_Str"",dv.getSuppressDropDownArrow());
    JSONArray jsonAry=new JSONArray();
    for (    String v : validationList) {
      jsonAry.add(v);
    }
    validMap.put(""String_Node_Str"",jsonAry);
  }
  return validMap;
}",0.9533239038189534
56605,"private static Set<Action> getDefaultActiobDisabled(){
  if (_defToolbarActiobDisabled == null) {
    _defToolbarActiobDisabled=new HashSet<Action>();
    HashMap<String,Action> toolbarActions=Action.getAll();
    String[] actions=Library.getProperty(TOOLBAR_DISABLED_ACTION,""String_Node_Str"").split(""String_Node_Str"");
    for (    String a : actions) {
      String action=a.trim();
      if (toolbarActions.containsKey(action)) {
        _defToolbarActiobDisabled.add(toolbarActions.get(action));
      }
    }
  }
  return _defToolbarActiobDisabled;
}","private static Set<Action> getDefaultActiobDisabled(){
  if (_defToolbarActiobDisabled == null) {
    _defToolbarActiobDisabled=new HashSet<Action>();
    HashMap<String,Action> toolbarActions=Action.getAll();
    String[] actions=Library.getProperty(TOOLBAR_DISABLED_ACTION,""String_Node_Str"").split(""String_Node_Str"");
    for (    String a : actions) {
      String action=a.trim();
      if (toolbarActions.containsKey(action)) {
        _defToolbarActiobDisabled.add(toolbarActions.get(action));
      }
    }
  }
  return new HashSet<Action>(_defToolbarActiobDisabled);
}",0.9814323607427056
56606,"T getHelper(String sheetId){
  return helpers.get(sheetId);
}","public T getHelper(String sheetId){
  return helpers.get(sheetId);
}",0.9457364341085271
56607,"void putHelper(String sheetId,T helper){
  helpers.put(sheetId,helper);
}","public void putHelper(String sheetId,T helper){
  helpers.put(sheetId,helper);
}",0.954248366013072
56608,"protected ClientAnchor getClientAnchor(int row,int col,int widgetWidth,int widgetHeight){
  HeaderPositionHelper rowSizeHelper=(HeaderPositionHelper)_spreadsheet.getAttribute(""String_Node_Str"");
  HeaderPositionHelper colSizeHelper=(HeaderPositionHelper)_spreadsheet.getAttribute(""String_Node_Str"");
  int lCol=col;
  int tRow=row;
  int rCol=lCol;
  int bRow=tRow;
  int offsetWidth=0;
  int offsetHeight=0;
  for (int r=tRow; r < _spreadsheet.getMaxrows(); r++) {
    int cellHeight=rowSizeHelper.getSize(r);
    widgetHeight-=cellHeight;
    if (widgetHeight <= 0) {
      bRow=r;
      if (widgetHeight < 0) {
        offsetHeight=cellHeight - Math.abs(widgetHeight);
      }
      break;
    }
  }
  for (int c=lCol; c < _spreadsheet.getMaxcolumns(); c++) {
    int cellWidth=colSizeHelper.getSize(c);
    widgetWidth-=cellWidth;
    if (widgetWidth <= 0) {
      rCol=c;
      if (widgetWidth < 0) {
        offsetWidth=cellWidth - Math.abs(widgetWidth);
      }
      break;
    }
  }
  if (_spreadsheet.getBook() instanceof HSSFWorkbook) {
    return new HSSFClientAnchor(0,0,offsetWidth,offsetHeight,(short)lCol,tRow,(short)rCol,bRow);
  }
 else {
    return new XSSFClientAnchor(0,0,pxToEmu(offsetWidth),pxToEmu(offsetHeight),lCol,tRow,rCol,bRow);
  }
}","protected ClientAnchor getClientAnchor(int row,int col,int widgetWidth,int widgetHeight){
  final String sid=((SheetCtrl)_spreadsheet.getSelectedSheet()).getUuid();
  HeaderPositionHelper rowSizeHelper=((HelperContainer<HeaderPositionHelper>)_spreadsheet.getAttribute(""String_Node_Str"")).getHelper(sid);
  HeaderPositionHelper colSizeHelper=((HelperContainer<HeaderPositionHelper>)_spreadsheet.getAttribute(""String_Node_Str"")).getHelper(sid);
  int lCol=col;
  int tRow=row;
  int rCol=lCol;
  int bRow=tRow;
  int offsetWidth=0;
  int offsetHeight=0;
  for (int r=tRow; r < _spreadsheet.getMaxrows(); r++) {
    int cellHeight=rowSizeHelper.getSize(r);
    widgetHeight-=cellHeight;
    if (widgetHeight <= 0) {
      bRow=r;
      if (widgetHeight < 0) {
        offsetHeight=cellHeight - Math.abs(widgetHeight);
      }
      break;
    }
  }
  for (int c=lCol; c < _spreadsheet.getMaxcolumns(); c++) {
    int cellWidth=colSizeHelper.getSize(c);
    widgetWidth-=cellWidth;
    if (widgetWidth <= 0) {
      rCol=c;
      if (widgetWidth < 0) {
        offsetWidth=cellWidth - Math.abs(widgetWidth);
      }
      break;
    }
  }
  if (_spreadsheet.getBook() instanceof HSSFWorkbook) {
    return new HSSFClientAnchor(0,0,offsetWidth,offsetHeight,(short)lCol,tRow,(short)rCol,bRow);
  }
 else {
    return new XSSFClientAnchor(0,0,pxToEmu(offsetWidth),pxToEmu(offsetHeight),lCol,tRow,rCol,bRow);
  }
}",0.9464218808542524
56609,"private void initBook0(Book book){
  if (_book != null) {
    if (_focusListener != null)     removeEventListener(Events.ON_CELL_FOUCSED,_focusListener);
    deleteFocus();
    _book.unsubscribe(_dataListener);
    _book.removeVariableResolver(_variableResolver);
    _book.removeFunctionMapper(_functionMapper);
    if (_focusListener != null)     removeEventListener(Events.ON_CELL_FOUCSED,_focusListener);
  }
  if (_selectedSheet != null) {
    doSheetClean(_selectedSheet);
  }
  _selectedSheet=null;
  _selectedSheetId=null;
  _selectedSheetName=null;
  _book=book;
  if (_book != null) {
    _book.subscribe(_dataListener);
    _book.addVariableResolver(_variableResolver);
    _book.addFunctionMapper(_functionMapper);
    if (_focus == null) {
      _focus=newFocus();
      ((BookCtrl)_book).addFocus(_focus);
    }
    if (EventQueues.APPLICATION.equals(_book.getShareScope()) || EventQueues.SESSION.equals(_book.getShareScope())) {
      this.addEventListener(Events.ON_CELL_FOUCSED,_focusListener=new EventListener(){
        @Override public void onEvent(        Event event) throws Exception {
          doMoveSelfFocus((CellEvent)event);
        }
      }
);
    }
  }
}","private void initBook0(Book book){
  if (_book != null) {
    if (_focusListener != null)     removeEventListener(Events.ON_CELL_FOUCSED,_focusListener);
    deleteFocus();
    _book.unsubscribe(_dataListener);
    _book.removeVariableResolver(_variableResolver);
    _book.removeFunctionMapper(_functionMapper);
    if (_focusListener != null)     removeEventListener(Events.ON_CELL_FOUCSED,_focusListener);
  }
  if (_selectedSheet != null) {
    doSheetClean(_selectedSheet);
  }
  if (!Objects.equals(_book,book)) {
    removeAttribute(MERGE_MATRIX_KEY);
    clearHeaderSizeHelper(true,true);
    _custColId=new SequenceId(-1,2);
    _custRowId=new SequenceId(-1,2);
  }
  _selectedSheet=null;
  _selectedSheetId=null;
  _selectedSheetName=null;
  _book=book;
  if (_book != null) {
    _book.subscribe(_dataListener);
    _book.addVariableResolver(_variableResolver);
    _book.addFunctionMapper(_functionMapper);
    if (_focus == null) {
      _focus=newFocus();
      ((BookCtrl)_book).addFocus(_focus);
    }
    if (EventQueues.APPLICATION.equals(_book.getShareScope()) || EventQueues.SESSION.equals(_book.getShareScope())) {
      this.addEventListener(Events.ON_CELL_FOUCSED,_focusListener=new EventListener(){
        @Override public void onEvent(        Event event) throws Exception {
          doMoveSelfFocus((CellEvent)event);
        }
      }
);
    }
  }
}",0.9251170046801872
56610,"private HeaderPositionHelper myGetColumnPositionHelper(Worksheet sheet,int maxcol){
  if (sheet != getSelectedSheet())   throw new UiException(""String_Node_Str"");
  HeaderPositionHelper helper=(HeaderPositionHelper)getAttribute(COLUMN_SIZE_HELPER_KEY);
  if (helper == null) {
    final int defaultColSize=sheet.getDefaultColumnWidth();
    final int defaultColSize256=defaultColSize * 256;
    final int charWidth=getDefaultCharWidth();
    final int defaultColSizeInPx=Utils.defaultColumnWidthToPx(defaultColSize,charWidth);
    List<HeaderPositionInfo> infos=new ArrayList<HeaderPositionInfo>();
    for (int j=0; j <= maxcol; ++j) {
      final boolean hidden=sheet.isColumnHidden(j);
      final int fileColumnWidth=sheet.getColumnWidth(j);
      if (fileColumnWidth != defaultColSize256 || hidden) {
        final int colwidth=fileColumnWidth != defaultColSize256 ? Utils.fileChar256ToPx(fileColumnWidth,charWidth) : defaultColSizeInPx;
        infos.add(new HeaderPositionInfo(j,colwidth,_custColId.next(),hidden));
      }
    }
    helper=new HeaderPositionHelper(defaultColSizeInPx,infos);
    setAttribute(COLUMN_SIZE_HELPER_KEY,helper);
  }
  return helper;
}","private HeaderPositionHelper myGetColumnPositionHelper(Worksheet sheet,int maxcol){
  HelperContainer<HeaderPositionHelper> helpers=(HelperContainer)getAttribute(COLUMN_SIZE_HELPER_KEY);
  if (helpers == null) {
    setAttribute(COLUMN_SIZE_HELPER_KEY,helpers=new HelperContainer<HeaderPositionHelper>());
  }
  final String sheetId=((SheetCtrl)sheet).getUuid();
  HeaderPositionHelper helper=helpers.getHelper(sheetId);
  if (helper == null) {
    final int defaultColSize=sheet.getDefaultColumnWidth();
    final int defaultColSize256=defaultColSize * 256;
    final int charWidth=getDefaultCharWidth();
    final int defaultColSizeInPx=Utils.defaultColumnWidthToPx(defaultColSize,charWidth);
    List<HeaderPositionInfo> infos=new ArrayList<HeaderPositionInfo>();
    for (int j=0; j <= maxcol; ++j) {
      final boolean hidden=sheet.isColumnHidden(j);
      final int fileColumnWidth=sheet.getColumnWidth(j);
      if (fileColumnWidth != defaultColSize256 || hidden) {
        final int colwidth=fileColumnWidth != defaultColSize256 ? Utils.fileChar256ToPx(fileColumnWidth,charWidth) : defaultColSizeInPx;
        infos.add(new HeaderPositionInfo(j,colwidth,_custColId.next(),hidden));
      }
    }
    helpers.putHelper(sheetId,helper=new HeaderPositionHelper(defaultColSizeInPx,infos));
  }
  return helper;
}",0.1663987138263665
56611,"/** 
 * Cell attributes <ul> <li>r: row number</li> <li>c: column number</li> <li>w: width index</li> <li>h: height index</li> <li>t: cell html text</li> <li>et: cell edit text</li> <li>ft: format text</li> <li>meft: merge cell html text, edit text and format text</li> <li>ct: cell type</li> <li>s: cell style</li> <li>is: cell inner style</li> <li>rb: cell right border</li> <li>l: locked</> <li>wp: wrap</li> <li>ha: horizontal alignment</> <li>va: vertical alignment</> <li>mi: merge id index</li> <li>mc: merge CSS index</li> <li>rf: Cell Reference</li> <li>fs: font size</li> <li>ovf: overflow</li> </ul> Ignore put attribute if it's default Default attributes <ul> <li>Cell type: blank</> <li>Locked: true</> <li>Wrap: false</li> <li>Horizontal alignment: left</> <li>Vertical alignment: top</> <li>Overflow: false</li> <li>Font size: 11pt</> </ul>
 */
public JSONObject getCellAttr(Worksheet sheet,CellAttribute type,int row,int col,StringAggregation styleAggregation,StringAggregation textAggregation,MergeAggregation mergeAggregation){
  boolean updateAll=type == CellAttribute.ALL, updateText=(updateAll || type == CellAttribute.TEXT), updateStyle=(updateAll || type == CellAttribute.STYLE), updateSize=(updateAll || type == CellAttribute.SIZE), updateMerge=(updateAll || type == CellAttribute.MERGE);
  Cell cell=Utils.getCell(sheet,row,col);
  JSONObject attrs=new JSONObject();
  CellReference cr=new CellReference(row,col,false,false);
  attrs.put(""String_Node_Str"",cr.formatAsString());
  MergeIndex mergeIndex=mergeAggregation.add(row,col);
  if (updateMerge && mergeIndex != null) {
    attrs.put(""String_Node_Str"",mergeIndex.getMergeId());
    attrs.put(""String_Node_Str"",mergeIndex.getMergeCSSId());
  }
  if (updateSize) {
    HeaderPositionHelper colHelper=Spreadsheet.this.getColumnPositionHelper(sheet);
    HeaderPositionInfo info=colHelper.getInfo(col);
    if (info != null && info.id >= 0) {
      attrs.put(""String_Node_Str"",info.id);
    }
    if (cell != null) {
      CellStyle cellStyle=cell.getCellStyle();
      if (cell.getCellType() == Cell.CELL_TYPE_STRING && mergeIndex == null && !cellStyle.getWrapText() && BookHelper.getRealAlignment(cell) == CellStyle.ALIGN_LEFT) {
        attrs.put(""String_Node_Str"",1);
        int c=getMaxOverflowableCellIndex(cell,sheet.getRow(row));
        if (c != col) {
          attrs.put(""String_Node_Str"",c);
        }
      }
    }
  }
  if (updateStyle) {
    CellFormatHelper cfh=new CellFormatHelper(sheet,row,col,getMergeMatrixHelper(sheet));
    String style=cfh.getHtmlStyle();
    if (!Strings.isEmpty(style)) {
      int idx=styleAggregation.add(style);
      attrs.put(""String_Node_Str"",idx);
    }
    String innerStyle=cfh.getInnerHtmlStyle();
    if (!Strings.isEmpty(innerStyle)) {
      int idx=styleAggregation.add(innerStyle);
      attrs.put(""String_Node_Str"",idx);
    }
    if (cfh.hasRightBorder()) {
      attrs.put(""String_Node_Str"",1);
    }
  }
  if (cell != null) {
    int cellType=cell.getCellType();
    if (cellType != Cell.CELL_TYPE_BLANK)     attrs.put(""String_Node_Str"",cellType);
    if (updateText) {
      if (cellType != Cell.CELL_TYPE_BLANK) {
        final String cellText=getCelltext(Spreadsheet.this,row,col);
        final String editText=getEdittext(Spreadsheet.this,row,col);
        final String formatText=getCellFormatText(Spreadsheet.this,row,col);
        if (Objects.equals(cellText,editText) && Objects.equals(editText,formatText)) {
          attrs.put(""String_Node_Str"",textAggregation.add(cellText));
        }
 else {
          attrs.put(""String_Node_Str"",textAggregation.add(cellText));
          attrs.put(""String_Node_Str"",textAggregation.add(editText));
          attrs.put(""String_Node_Str"",textAggregation.add(formatText));
        }
      }
    }
    if (updateStyle) {
      CellStyle cellStyle=cell.getCellStyle();
      boolean locked=cellStyle.getLocked();
      if (!locked)       attrs.put(""String_Node_Str"",""String_Node_Str"");
      boolean wrap=cellStyle.getWrapText();
      if (wrap)       attrs.put(""String_Node_Str"",1);
      int horizontalAlignment=BookHelper.getRealAlignment(cell);
switch (horizontalAlignment) {
case CellStyle.ALIGN_CENTER:
case CellStyle.ALIGN_CENTER_SELECTION:
        attrs.put(""String_Node_Str"",""String_Node_Str"");
      break;
case CellStyle.ALIGN_RIGHT:
    attrs.put(""String_Node_Str"",""String_Node_Str"");
  break;
}
int verticalAlignment=cellStyle.getVerticalAlignment();
switch (verticalAlignment) {
case CellStyle.VERTICAL_TOP:
attrs.put(""String_Node_Str"",""String_Node_Str"");
break;
case CellStyle.VERTICAL_CENTER:
attrs.put(""String_Node_Str"",""String_Node_Str"");
break;
}
Font font=_book.getFontAt(cellStyle.getFontIndex());
short fontHeight=font.getFontHeightInPoints();
if (fontHeight != XSSFFont.DEFAULT_FONT_SIZE) {
attrs.put(""String_Node_Str"",fontHeight);
}
}
}
return attrs;
}","/** 
 * Cell attributes <ul> <li>r: row number</li> <li>c: column number</li> <li>w: width index</li> <li>h: height index</li> <li>t: cell html text</li> <li>et: cell edit text</li> <li>ft: format text</li> <li>meft: merge cell html text, edit text and format text</li> <li>ct: cell type</li> <li>s: cell style</li> <li>is: cell inner style</li> <li>rb: cell right border</li> <li>l: locked</> <li>wp: wrap</li> <li>ha: horizontal alignment</> <li>va: vertical alignment</> <li>mi: merge id index</li> <li>mc: merge CSS index</li> <li>rf: Cell Reference</li> <li>fs: font size</li> <li>ovf: overflow</li> </ul> Ignore put attribute if it's default Default attributes <ul> <li>Cell type: blank</> <li>Locked: true</> <li>Wrap: false</li> <li>Horizontal alignment: left</> <li>Vertical alignment: top</> <li>Overflow: false</li> <li>Font size: 11pt</> </ul>
 */
public JSONObject getCellAttr(Worksheet sheet,CellAttribute type,int row,int col,StringAggregation styleAggregation,StringAggregation textAggregation,MergeAggregation mergeAggregation){
  boolean updateAll=type == CellAttribute.ALL, updateText=(updateAll || type == CellAttribute.TEXT), updateStyle=(updateAll || type == CellAttribute.STYLE), updateSize=(updateAll || type == CellAttribute.SIZE), updateMerge=(updateAll || type == CellAttribute.MERGE);
  Cell cell=Utils.getCell(sheet,row,col);
  JSONObject attrs=new JSONObject();
  CellReference cr=new CellReference(row,col,false,false);
  attrs.put(""String_Node_Str"",cr.formatAsString());
  MergeIndex mergeIndex=mergeAggregation.add(row,col);
  if (updateMerge && mergeIndex != null) {
    attrs.put(""String_Node_Str"",mergeIndex.getMergeId());
    attrs.put(""String_Node_Str"",mergeIndex.getMergeCSSId());
  }
  if (updateSize) {
    HeaderPositionHelper colHelper=Spreadsheet.this.getColumnPositionHelper(sheet);
    HeaderPositionInfo info=colHelper.getInfo(col);
    if (info != null && info.id >= 0) {
      attrs.put(""String_Node_Str"",info.id);
    }
    if (cell != null) {
      CellStyle cellStyle=cell.getCellStyle();
      if (cell.getCellType() == Cell.CELL_TYPE_STRING && mergeIndex == null && !cellStyle.getWrapText() && BookHelper.getRealAlignment(cell) == CellStyle.ALIGN_LEFT) {
        attrs.put(""String_Node_Str"",1);
        int c=getMaxOverflowableCellIndex(cell,sheet.getRow(row));
        if (c != col) {
          attrs.put(""String_Node_Str"",c);
        }
      }
    }
  }
  if (updateStyle) {
    CellFormatHelper cfh=new CellFormatHelper(sheet,row,col,getMergeMatrixHelper(sheet));
    String style=cfh.getHtmlStyle();
    if (!Strings.isEmpty(style)) {
      int idx=styleAggregation.add(style);
      attrs.put(""String_Node_Str"",idx);
    }
    String innerStyle=cfh.getInnerHtmlStyle();
    if (!Strings.isEmpty(innerStyle)) {
      int idx=styleAggregation.add(innerStyle);
      attrs.put(""String_Node_Str"",idx);
    }
    if (cfh.hasRightBorder()) {
      attrs.put(""String_Node_Str"",1);
    }
  }
  if (cell != null) {
    int cellType=cell.getCellType();
    if (cellType != Cell.CELL_TYPE_BLANK)     attrs.put(""String_Node_Str"",cellType);
    if (updateText) {
      if (cellType != Cell.CELL_TYPE_BLANK) {
        final String cellText=getCelltext(sheet,row,col);
        final String editText=getEdittext(sheet,row,col);
        final String formatText=getCellFormatText(sheet,row,col);
        if (Objects.equals(cellText,editText) && Objects.equals(editText,formatText)) {
          attrs.put(""String_Node_Str"",textAggregation.add(cellText));
        }
 else {
          attrs.put(""String_Node_Str"",textAggregation.add(cellText));
          attrs.put(""String_Node_Str"",textAggregation.add(editText));
          attrs.put(""String_Node_Str"",textAggregation.add(formatText));
        }
      }
    }
    if (updateStyle) {
      CellStyle cellStyle=cell.getCellStyle();
      boolean locked=cellStyle.getLocked();
      if (!locked)       attrs.put(""String_Node_Str"",""String_Node_Str"");
      boolean wrap=cellStyle.getWrapText();
      if (wrap)       attrs.put(""String_Node_Str"",1);
      int horizontalAlignment=BookHelper.getRealAlignment(cell);
switch (horizontalAlignment) {
case CellStyle.ALIGN_CENTER:
case CellStyle.ALIGN_CENTER_SELECTION:
        attrs.put(""String_Node_Str"",""String_Node_Str"");
      break;
case CellStyle.ALIGN_RIGHT:
    attrs.put(""String_Node_Str"",""String_Node_Str"");
  break;
}
int verticalAlignment=cellStyle.getVerticalAlignment();
switch (verticalAlignment) {
case CellStyle.VERTICAL_TOP:
attrs.put(""String_Node_Str"",""String_Node_Str"");
break;
case CellStyle.VERTICAL_CENTER:
attrs.put(""String_Node_Str"",""String_Node_Str"");
break;
}
Font font=_book.getFontAt(cellStyle.getFontIndex());
short fontHeight=font.getFontHeightInPoints();
if (fontHeight != XSSFFont.DEFAULT_FONT_SIZE) {
attrs.put(""String_Node_Str"",fontHeight);
}
}
}
return attrs;
}",0.9815178110480124
56612,"private HeaderPositionHelper[] getPositionHelpers(Worksheet sheet){
  if (sheet == null) {
    return null;
  }
  if (sheet != getSelectedSheet())   throw new UiException(""String_Node_Str"" + sheet.getSheetName());
  HeaderPositionHelper helper=(HeaderPositionHelper)getAttribute(ROW_SIZE_HELPER_KEY);
  int maxcol=0;
  if (helper == null) {
    int defaultSize=this.getRowheight();
    List<HeaderPositionInfo> infos=new ArrayList<HeaderPositionInfo>();
    for (    Row row : sheet) {
      final boolean hidden=row.getZeroHeight();
      final int height=Utils.getRowHeightInPx(sheet,row);
      if (height != defaultSize || hidden) {
        infos.add(new HeaderPositionInfo(row.getRowNum(),height,_custRowId.next(),hidden));
      }
      final int colnum=row.getLastCellNum() - 1;
      if (colnum > maxcol) {
        maxcol=colnum;
      }
    }
    helper=new HeaderPositionHelper(defaultSize,infos);
    setAttribute(ROW_SIZE_HELPER_KEY,helper);
  }
  return new HeaderPositionHelper[]{helper,myGetColumnPositionHelper(sheet,maxcol)};
}","private HeaderPositionHelper[] getPositionHelpers(Worksheet sheet){
  if (sheet == null) {
    return null;
  }
  HelperContainer<HeaderPositionHelper> helpers=(HelperContainer)getAttribute(ROW_SIZE_HELPER_KEY);
  if (helpers == null) {
    setAttribute(ROW_SIZE_HELPER_KEY,helpers=new HelperContainer<HeaderPositionHelper>());
  }
  final String sheetId=((SheetCtrl)sheet).getUuid();
  HeaderPositionHelper helper=helpers.getHelper(sheetId);
  int maxcol=0;
  if (helper == null) {
    int defaultSize=this.getRowheight();
    List<HeaderPositionInfo> infos=new ArrayList<HeaderPositionInfo>();
    for (    Row row : sheet) {
      final boolean hidden=row.getZeroHeight();
      final int height=Utils.getRowHeightInPx(sheet,row);
      if (height != defaultSize || hidden) {
        infos.add(new HeaderPositionInfo(row.getRowNum(),height,_custRowId.next(),hidden));
      }
      final int colnum=row.getLastCellNum() - 1;
      if (colnum > maxcol) {
        maxcol=colnum;
      }
    }
    helpers.putHelper(sheetId,helper=new HeaderPositionHelper(defaultSize,infos));
  }
  return new HeaderPositionHelper[]{helper,myGetColumnPositionHelper(sheet,maxcol)};
}",0.2740841248303934
56613,"private void updateCell(Worksheet sheet,int left,int top,int right,int bottom){
  if (this.isInvalidated())   return;
  String sheetId=Utils.getSheetUuid(sheet);
  if (!sheetId.equals(this.getSelectedSheetId()))   return;
  left=left > 0 ? left - 1 : 0;
  top=top > 0 ? top - 1 : 0;
  final Rect rect=getActiveRangeHelper().getRect(_selectedSheet);
  final int loadLeft=rect.getLeft();
  final int loadTop=rect.getTop();
  final int loadRight=rect.getRight();
  final int loadBottom=rect.getBottom();
  final int frRow=getRowfreeze();
  final int frCol=getColumnfreeze();
  final int frTop=top <= frRow ? top : -1;
  final int frBottom=frRow;
  final int frLeft=left <= frCol ? left : -1;
  final int frRight=frCol;
  if (loadLeft > left) {
    left=loadLeft;
  }
  if (loadRight < right) {
    right=loadRight;
  }
  if (loadTop > top) {
    top=loadTop;
  }
  if (loadBottom < bottom) {
    bottom=loadBottom;
  }
  if (frTop >= 0 && frTop <= frBottom && left >= 0 && left <= right) {
    responseUpdateCell(sheet,sheetId,left,frTop,right,frBottom);
  }
  if (frLeft >= 0 && frLeft <= frRight && top >= 0 && top <= bottom) {
    responseUpdateCell(sheet,sheetId,frLeft,top,frRight,bottom);
  }
  if (top >= 0 && top <= bottom && left >= 0 && left <= right) {
    responseUpdateCell(sheet,sheetId,left,top,right,bottom);
  }
}","private void updateCell(Worksheet sheet,int left,int top,int right,int bottom){
  if (this.isInvalidated())   return;
  String sheetId=Utils.getSheetUuid(sheet);
  if (!getActiveRangeHelper().containsSheet(sheet))   return;
  left=left > 0 ? left - 1 : 0;
  top=top > 0 ? top - 1 : 0;
  final Rect rect=getActiveRangeHelper().getRect(_selectedSheet);
  final int loadLeft=rect.getLeft();
  final int loadTop=rect.getTop();
  final int loadRight=rect.getRight();
  final int loadBottom=rect.getBottom();
  final int frRow=getRowfreeze();
  final int frCol=getColumnfreeze();
  final int frTop=top <= frRow ? top : -1;
  final int frBottom=frRow;
  final int frLeft=left <= frCol ? left : -1;
  final int frRight=frCol;
  if (loadLeft > left) {
    left=loadLeft;
  }
  if (loadRight < right) {
    right=loadRight;
  }
  if (loadTop > top) {
    top=loadTop;
  }
  if (loadBottom < bottom) {
    bottom=loadBottom;
  }
  if (frTop >= 0 && frTop <= frBottom && left >= 0 && left <= right) {
    responseUpdateCell(sheet,sheetId,left,frTop,right,frBottom);
  }
  if (frLeft >= 0 && frLeft <= frRight && top >= 0 && top <= bottom) {
    responseUpdateCell(sheet,sheetId,frLeft,top,frRight,bottom);
  }
  if (top >= 0 && top <= bottom && left >= 0 && left <= right) {
    responseUpdateCell(sheet,sheetId,left,top,right,bottom);
  }
}",0.8998493975903614
56614,"private void doSheetClean(Worksheet sheet){
  if (getBook().getSheetIndex(sheet) != -1)   deleteFocus();
  List list=loadWidgetLoaders();
  int size=list.size();
  for (int i=0; i < size; i++) {
    ((WidgetLoader)list.get(i)).onSheetClean(sheet);
  }
  removeAttribute(MERGE_MATRIX_KEY);
  clearHeaderSizeHelper(true,true);
  _custColId=new SequenceId(-1,2);
  _custRowId=new SequenceId(-1,2);
  _selectionRect.set(0,0,0,0);
  _focusRect.set(0,0,0,0);
  _colFreeze=-1;
  _colFreezeset=false;
  _rowFreeze=-1;
  _rowFreezeset=false;
}","private void doSheetClean(Worksheet sheet){
  if (getBook().getSheetIndex(sheet) != -1)   deleteFocus();
  List list=loadWidgetLoaders();
  int size=list.size();
  for (int i=0; i < size; i++) {
    ((WidgetLoader)list.get(i)).onSheetClean(sheet);
  }
  _selectionRect.set(0,0,0,0);
  _focusRect.set(0,0,0,0);
  _colFreeze=-1;
  _colFreezeset=false;
  _rowFreeze=-1;
  _rowFreezeset=false;
}",0.6227027027027027
56615,"/** 
 * Gets Cell text by given row and column
 */
static public String getCelltext(Spreadsheet ss,int row,int column){
  Worksheet sheet=ss.getSelectedSheet();
  final Cell cell=Utils.getCell(sheet,row,column);
  String text=""String_Node_Str"";
  if (cell != null) {
    boolean wrap=cell.getCellStyle().getWrapText();
    final FormatText ft=Utils.getFormatText(cell);
    if (ft != null) {
      if (ft.isRichTextString()) {
        final RichTextString rstr=ft.getRichTextString();
        text=rstr == null ? ""String_Node_Str"" : Utils.formatRichTextString(sheet,rstr,wrap);
      }
 else       if (ft.isCellFormatResult()) {
        text=Utils.escapeCellText(ft.getCellFormatResult().text,wrap,true);
      }
    }
    final Hyperlink hlink=Utils.getHyperlink(cell);
    if (hlink != null) {
      text=Utils.formatHyperlink(sheet,hlink,text,wrap);
    }
  }
  return text;
}","/** 
 * Gets Cell text by given row and column
 */
static public String getCelltext(Worksheet sheet,int row,int column){
  final Cell cell=Utils.getCell(sheet,row,column);
  String text=""String_Node_Str"";
  if (cell != null) {
    boolean wrap=cell.getCellStyle().getWrapText();
    final FormatText ft=Utils.getFormatText(cell);
    if (ft != null) {
      if (ft.isRichTextString()) {
        final RichTextString rstr=ft.getRichTextString();
        text=rstr == null ? ""String_Node_Str"" : Utils.formatRichTextString(sheet,rstr,wrap);
      }
 else       if (ft.isCellFormatResult()) {
        text=Utils.escapeCellText(ft.getCellFormatResult().text,wrap,true);
      }
    }
    final Hyperlink hlink=Utils.getHyperlink(cell);
    if (hlink != null) {
      text=Utils.formatHyperlink(sheet,hlink,text,wrap);
    }
  }
  return text;
}",0.959254947613504
56616,"static public String getCellFormatText(Spreadsheet ss,int row,int column){
  Worksheet sheet=ss.getSelectedSheet();
  final Cell cell=Utils.getCell(sheet,row,column);
  String text=""String_Node_Str"";
  if (cell != null) {
    final FormatText ft=Utils.getFormatText(cell);
    if (ft != null) {
      if (ft.isRichTextString()) {
        final RichTextString rstr=ft.getRichTextString();
        text=rstr == null ? ""String_Node_Str"" : rstr.toString();
      }
 else       if (ft.isCellFormatResult()) {
        text=ft.getCellFormatResult().text;
      }
    }
  }
  return text;
}","static public String getCellFormatText(Worksheet sheet,int row,int column){
  final Cell cell=Utils.getCell(sheet,row,column);
  String text=""String_Node_Str"";
  if (cell != null) {
    final FormatText ft=Utils.getFormatText(cell);
    if (ft != null) {
      if (ft.isRichTextString()) {
        final RichTextString rstr=ft.getRichTextString();
        text=rstr == null ? ""String_Node_Str"" : rstr.toString();
      }
 else       if (ft.isCellFormatResult()) {
        text=ft.getCellFormatResult().text;
      }
    }
  }
  return text;
}",0.9501779359430604
56617,"static public String getEdittext(Spreadsheet ss,int row,int column){
  Worksheet sheet=ss.getSelectedSheet();
  final Cell cell=Utils.getCell(sheet,row,column);
  return cell != null ? Utils.getEditText(cell) : ""String_Node_Str"";
}","static public String getEdittext(Worksheet sheet,int row,int column){
  final Cell cell=Utils.getCell(sheet,row,column);
  return cell != null ? Utils.getEditText(cell) : ""String_Node_Str"";
}",0.8720379146919431
56618,"private void updateNamedRanges(XSSFWorkbook wb,PtgShifter shifter){
  XSSFEvaluationWorkbook fpb=XSSFEvaluationWorkbook.create(wb);
  for (int i=0; i < wb.getNumberOfNames(); i++) {
    XSSFName name=wb.getNameAt(i);
    String formula=name.getRefersToFormula();
    int sheetIndex=name.getSheetIndex();
    Ptg[] ptgs=FormulaParser.parse(formula,fpb,FormulaType.NAMEDRANGE,sheetIndex);
    if (shifter.adjustFormula(ptgs,sheetIndex)) {
      String shiftedFmla=FormulaRenderer.toFormulaString(fpb,ptgs);
      name.setRefersToFormula(shiftedFmla);
    }
  }
}","private void updateNamedRanges(XSSFWorkbook wb,PtgShifter shifter){
  XSSFEvaluationWorkbook fpb=XSSFEvaluationWorkbook.create(wb);
  for (int i=0; i < wb.getNumberOfNames(); i++) {
    XSSFName name=wb.getNameAt(i);
    String formula=name.getRefersToFormula();
    int sheetIndex=name.getSheetIndex();
    if (formula != null) {
      Ptg[] ptgs=FormulaParser.parse(formula,fpb,FormulaType.NAMEDRANGE,sheetIndex);
      if (shifter.adjustFormula(ptgs,sheetIndex)) {
        String shiftedFmla=FormulaRenderer.toFormulaString(fpb,ptgs);
        name.setRefersToFormula(shiftedFmla);
      }
    }
  }
}",0.9630266552020637
56619,"private int getMaxday(int month,int year){
  int maxday=MAXDAYS[month];
  if (month == 2 && isLeapYear(year)) {
    return maxday + 1;
  }
  return maxday;
}","private int getMaxday(int month,int year){
  int maxday=MAXDAYS[month];
  if (month == 1 && isLeapYear(year)) {
    return maxday + 1;
  }
  return maxday;
}",0.9936305732484076
56620,"private void processChart(Worksheet sheet,Map data){
  String widgetId=(String)data.get(""String_Node_Str"");
  int keyCode=(Integer)data.get(""String_Node_Str"");
  DrawingManager dm=((SheetCtrl)sheet).getDrawingManager();
  if (KeyEvent.DELETE == keyCode) {
    List<ZssChartX> charts=dm.getChartXs();
    for (    ZssChartX chartX : charts) {
      Chart chart=chartX.getChart();
      if (chart != null && chart.getChartId().equals(widgetId)) {
        Ranges.range(sheet).deleteChart(chart);
      }
    }
  }
}","private void processChart(Worksheet sheet,Map data){
  String widgetId=(String)data.get(""String_Node_Str"");
  int keyCode=(Integer)data.get(""String_Node_Str"");
  DrawingManager dm=((SheetCtrl)sheet).getDrawingManager();
  if (KeyEvent.DELETE == keyCode) {
    List<Chart> charts=dm.getCharts();
    for (    Chart chart : charts) {
      if (chart != null && chart.getChartId().equals(widgetId)) {
        Ranges.range(sheet).deleteChart(chart);
        break;
      }
    }
  }
}",0.905241935483871
56621,"protected ClientAnchor getClientAnchor(int row,int col,int widgetWidth,int widgetHeight){
  HeaderPositionHelper rowSizeHelper=(HeaderPositionHelper)_spreadsheet.getAttribute(""String_Node_Str"");
  HeaderPositionHelper colSizeHelper=(HeaderPositionHelper)_spreadsheet.getAttribute(""String_Node_Str"");
  int lCol=col;
  int tRow=row;
  int rCol=lCol;
  int bRow=tRow;
  int offsetWidth=0;
  int offsetHeight=0;
  for (int r=tRow; r < _spreadsheet.getMaxrows(); r++) {
    int cellHeight=rowSizeHelper.getSize(r);
    widgetHeight-=cellHeight;
    if (widgetHeight <= 0) {
      bRow=r;
      if (widgetHeight < 0) {
        offsetHeight=cellHeight - Math.abs(widgetHeight);
      }
      break;
    }
  }
  for (int c=lCol; c < _spreadsheet.getMaxcolumns(); c++) {
    int cellWidth=colSizeHelper.getSize(c);
    widgetWidth-=cellWidth;
    if (widgetWidth <= 0) {
      rCol=c;
      if (widgetWidth < 0) {
        offsetWidth=cellWidth - Math.abs(widgetWidth);
      }
      break;
    }
  }
  ClientAnchor anchor=new XSSFClientAnchor(0,0,pxToEmu(offsetWidth),pxToEmu(offsetHeight),lCol,tRow,rCol,bRow);
  return anchor;
}","protected ClientAnchor getClientAnchor(int row,int col,int widgetWidth,int widgetHeight){
  HeaderPositionHelper rowSizeHelper=(HeaderPositionHelper)_spreadsheet.getAttribute(""String_Node_Str"");
  HeaderPositionHelper colSizeHelper=(HeaderPositionHelper)_spreadsheet.getAttribute(""String_Node_Str"");
  int lCol=col;
  int tRow=row;
  int rCol=lCol;
  int bRow=tRow;
  int offsetWidth=0;
  int offsetHeight=0;
  for (int r=tRow; r < _spreadsheet.getMaxrows(); r++) {
    int cellHeight=rowSizeHelper.getSize(r);
    widgetHeight-=cellHeight;
    if (widgetHeight <= 0) {
      bRow=r;
      if (widgetHeight < 0) {
        offsetHeight=cellHeight - Math.abs(widgetHeight);
      }
      break;
    }
  }
  for (int c=lCol; c < _spreadsheet.getMaxcolumns(); c++) {
    int cellWidth=colSizeHelper.getSize(c);
    widgetWidth-=cellWidth;
    if (widgetWidth <= 0) {
      rCol=c;
      if (widgetWidth < 0) {
        offsetWidth=cellWidth - Math.abs(widgetWidth);
      }
      break;
    }
  }
  if (_spreadsheet.getBook() instanceof HSSFWorkbook) {
    return new HSSFClientAnchor(0,0,offsetWidth,offsetHeight,(short)lCol,tRow,(short)rCol,bRow);
  }
 else {
    return new XSSFClientAnchor(0,0,pxToEmu(offsetWidth),pxToEmu(offsetHeight),lCol,tRow,rCol,bRow);
  }
}",0.9215932914046122
56622,"public void close(){
  unsubscribeBookListeners();
  removeBookFromDesktopIfNeeded();
  spreadsheet.setSrcName(null);
  spreadsheet.setBook(null);
}","public void close(){
  unsubscribeBookListeners();
  removeBookFromDesktopIfNeeded();
  spreadsheet.setSrcName(null);
  spreadsheet.setBook(null);
  spreadsheet.getActionHandler().disableActionOnBookClosed();
}",0.8268156424581006
56623,"private void processStopEditing0(String token,Worksheet sheet,int rowIdx,int colIdx,Object value){
  try {
    Utils.setEditText(sheet,rowIdx,colIdx,value == null ? ""String_Node_Str"" : value.toString());
    JSONObj result=new JSONObj();
    result.setData(""String_Node_Str"",rowIdx);
    result.setData(""String_Node_Str"",colIdx);
    result.setData(""String_Node_Str"",""String_Node_Str"");
    result.setData(""String_Node_Str"",""String_Node_Str"");
    updateRange(sheet,Utils.getSheetUuid(sheet),colIdx,rowIdx,colIdx,rowIdx);
    smartUpdate(""String_Node_Str"",new String[]{token,Utils.getSheetUuid(sheet),result.toString()});
  }
 catch (  RuntimeException x) {
    processCancelEditing0(token,sheet,rowIdx,colIdx);
    if (x instanceof FormulaParseException) {
      showFormulaError((FormulaParseException)x);
    }
 else {
      throw x;
    }
  }
}","private void processStopEditing0(String token,Worksheet sheet,int rowIdx,int colIdx,Object value){
  try {
    Utils.setEditText(sheet,rowIdx,colIdx,value == null ? ""String_Node_Str"" : value.toString());
    JSONObj result=new JSONObj();
    result.setData(""String_Node_Str"",rowIdx);
    result.setData(""String_Node_Str"",colIdx);
    result.setData(""String_Node_Str"",""String_Node_Str"");
    result.setData(""String_Node_Str"",""String_Node_Str"");
    if (getPreloadColumnSize() > 0 && getPreloadRowSize() > 0) {
      updateRange(sheet,Utils.getSheetUuid(sheet),colIdx,rowIdx,colIdx,rowIdx);
    }
    smartUpdate(""String_Node_Str"",new String[]{token,Utils.getSheetUuid(sheet),result.toString()});
  }
 catch (  RuntimeException x) {
    processCancelEditing0(token,sheet,rowIdx,colIdx);
    if (x instanceof FormulaParseException) {
      showFormulaError((FormulaParseException)x);
    }
 else {
      throw x;
    }
  }
}",0.9587337478801584
56624,"private static Step myGetDateStep(Cell[] srcCells,int b,int e,boolean positive,int fillType,int subType){
  final Cell srcCell1=srcCells[b];
  final int[] time1=getTimeParts(srcCell1);
  int j=0;
  int y1=time1[j];
  ++j;
  int m1=time1[j];
  ++j;
  int d1=time1[j];
  ++j;
  int h1=time1[j];
  ++j;
  int min1=time1[j];
  ++j;
  int s1=time1[j];
  ++j;
  int ms1=time1[j];
  int t1=(h1 < 0 ? 0 : h1 * 60 * 60* 1000) + min1 * 60 * 1000 + s1 * 1000 + ms1;
  if (b == e) {
switch (fillType) {
case FILL_DAYS:
      return new MsecondStep(srcCells[b].getDateCellValue(),positive ? 24 * 60 * 60* 1000 : -24 * 60 * 60* 1000,subType);
case FILL_HOURS:
    return new MsecondStep(srcCells[b].getDateCellValue(),positive ? 60 * 60 * 1000 : -60 * 60 * 1000,subType);
case FILL_MONTHS:
  return new DateStep(y1,m1,d1,t1,positive ? 1 : -1,0,subType);
case FILL_YEARS:
return new DateStep(y1,m1,d1,t1,positive ? 12 : -12,0,subType);
case FILL_WEEKDAYS:
return new MsecondStep(srcCells[b].getDateCellValue(),positive ? 7 * 24 * 60* 60* 1000 : -7 * 24 * 60* 60* 1000,subType);
default :
return CopyStep.instance;
}
}
final Cell srcCell2=srcCells[b + 1];
final int[] time2=getTimeParts(srcCell2);
j=0;
int y2=time2[j];
++j;
int m2=time2[j];
++j;
int d2=time2[j];
++j;
int h2=time2[j];
++j;
int min2=time2[j];
++j;
int s2=time2[j];
++j;
int ms2=time2[j];
int diffM=m2 - m1 + (y2 - y1) * 12;
int diffD=d2 - d1;
if (h1 < 0 && h2 >= 0) {
h1=h2;
min1=min2;
s1=s2;
ms1=ms2;
}
 else if (h1 >= 0 && h2 < 0) {
h2=h1;
min2=min1;
s2=s1;
ms2=ms1;
}
int t2=(h2 < 0 ? 0 : h2 * 60 * 60* 1000) + min2 * 60 * 1000 + s2 * 1000 + ms2;
int diffT=t2 - t1;
for (int k=b + 2; k <= e; ++k) {
y1=y2;
m1=m2;
d1=d2;
h1=h2;
min1=min2;
s1=s2;
ms1=ms2;
t1=t2;
final Cell srcCell=srcCells[k];
final int[] time=getTimeParts(srcCell);
j=0;
y2=time[j];
++j;
m2=time[j];
++j;
d2=time[j];
++j;
h2=time[j];
++j;
min2=time[j];
++j;
s2=time[j];
++j;
ms2=time[j];
if ((diffM != m2 - m1 + (y2 - y1) * 12) || (diffD != d2 - d1)) {
return CopyStep.instance;
}
if (h1 < 0 && h2 >= 0) {
h1=h2;
min1=min2;
s1=s2;
ms1=ms2;
}
 else if (h1 >= 0 && h2 < 0) {
h2=h1;
min2=min1;
s2=s1;
ms2=ms1;
}
t2=(h2 < 0 ? 0 : h2 * 60 * 60* 1000) + min2 * 60 * 1000 + s2 * 1000 + ms2;
if (diffT != t2 - t1) {
diffT=0;
}
}
if (diffD != 0) {
final Calendar cal1=Calendar.getInstance();
final Calendar cal2=Calendar.getInstance();
cal1.set(y1,m1,d1,h1,min1,s1);
cal1.set(Calendar.MILLISECOND,ms1);
cal2.set(y2,m2,d2,h2,min2,s2);
cal2.set(Calendar.MILLISECOND,ms2);
final long step=cal2.getTime().getTime() - cal1.getTime().getTime();
return new MsecondStep(cal2.getTime(),step,-1);
}
 else {
return new DateStep(y2,m2,d2,t2,diffM,diffT,-1);
}
}","private static Step myGetDateStep(Cell[] srcCells,int b,int e,boolean positive,int fillType,int subType){
  final Cell srcCell1=srcCells[b];
  final int[] time1=getTimeParts(srcCell1);
  int j=0;
  int y1=time1[j];
  ++j;
  int m1=time1[j];
  ++j;
  int d1=time1[j];
  ++j;
  int h1=time1[j];
  ++j;
  int min1=time1[j];
  ++j;
  int s1=time1[j];
  ++j;
  int ms1=time1[j];
  int t1=(h1 < 0 ? 0 : h1 * 60 * 60* 1000) + min1 * 60 * 1000 + s1 * 1000 + ms1;
  if (b == e) {
switch (fillType) {
case FILL_DAYS:
      return new MsecondStep(srcCells[b].getDateCellValue(),positive ? 24 * 60 * 60* 1000 : -24 * 60 * 60* 1000,subType);
case FILL_HOURS:
    return new MsecondStep(srcCells[b].getDateCellValue(),positive ? 60 * 60 * 1000 : -60 * 60 * 1000,subType);
case FILL_MONTHS:
  return new DateStep(y1,m1,d1,t1,positive ? 1 : -1,0,subType);
case FILL_YEARS:
return new DateStep(y1,m1,d1,t1,positive ? 12 : -12,0,subType);
case FILL_WEEKDAYS:
return new MsecondStep(srcCells[b].getDateCellValue(),positive ? 7 * 24 * 60* 60* 1000 : -7 * 24 * 60* 60* 1000,subType);
default :
return CopyStep.instance;
}
}
final Cell srcCell2=srcCells[b + 1];
final int[] time2=getTimeParts(srcCell2);
j=0;
int y2=time2[j];
++j;
int m2=time2[j];
++j;
int d2=time2[j];
++j;
int h2=time2[j];
++j;
int min2=time2[j];
++j;
int s2=time2[j];
++j;
int ms2=time2[j];
int diffM=m2 - m1 + (y2 - y1) * 12;
int diffD=d2 - d1;
if (h1 < 0 && h2 >= 0) {
h1=h2;
min1=min2;
s1=s2;
ms1=ms2;
}
 else if (h1 >= 0 && h2 < 0) {
h2=h1;
min2=min1;
s2=s1;
ms2=ms1;
}
int t2=(h2 < 0 ? 0 : h2 * 60 * 60* 1000) + min2 * 60 * 1000 + s2 * 1000 + ms2;
int diffT=t2 - t1;
for (int k=b + 2; k <= e; ++k) {
y1=y2;
m1=m2;
d1=d2;
h1=h2;
min1=min2;
s1=s2;
ms1=ms2;
t1=t2;
final Cell srcCell=srcCells[k];
final int[] time=getTimeParts(srcCell);
j=0;
y2=time[j];
++j;
m2=time[j];
++j;
d2=time[j];
++j;
h2=time[j];
++j;
min2=time[j];
++j;
s2=time[j];
++j;
ms2=time[j];
if ((diffM != m2 - m1 + (y2 - y1) * 12) || (diffD != d2 - d1)) {
return CopyStep.instance;
}
if (h1 < 0 && h2 >= 0) {
h1=h2;
min1=min2;
s1=s2;
ms1=ms2;
}
 else if (h1 >= 0 && h2 < 0) {
h2=h1;
min2=min1;
s2=s1;
ms2=ms1;
}
t2=(h2 < 0 ? 0 : h2 * 60 * 60* 1000) + min2 * 60 * 1000 + s2 * 1000 + ms2;
if (diffT != t2 - t1) {
diffT=0;
}
}
if (diffD != 0) {
if (h1 < 0) {
h1=0;
}
if (h2 < 0) {
h2=0;
}
final Calendar cal1=Calendar.getInstance();
final Calendar cal2=Calendar.getInstance();
cal1.set(y1,m1,d1,h1,min1,s1);
cal1.set(Calendar.MILLISECOND,ms1);
cal2.set(y2,m2,d2,h2,min2,s2);
cal2.set(Calendar.MILLISECOND,ms2);
final long step=cal2.getTime().getTime() - cal1.getTime().getTime();
return new MsecondStep(cal2.getTime(),step,-1);
}
 else {
return new DateStep(y2,m2,d2,t2,diffM,diffT,-1);
}
}",0.9918002236302648
56625,"@Override public AutoFilter autoFilter(int field,Object criteria1,int filterOp,Object criteria2,boolean visibleDropDown){
  AutoFilter af=_sheet.getAutoFilter();
  if (af == null) {
    af=autoFilter();
  }
  final FilterColumn fc=BookHelper.getOrCreateFilterColumn(af,field - 1);
  BookHelper.setProperties(fc,criteria1,filterOp,criteria2,visibleDropDown);
  final CellRangeAddress affectedArea=af.getRangeAddress();
  final int row1=affectedArea.getFirstRow();
  final int col1=affectedArea.getFirstColumn();
  final int col=col1 + field - 1;
  final int row=row1 + 1;
  final int row2=affectedArea.getLastRow();
  final int col2=affectedArea.getLastColumn();
  final Set cr1=fc.getCriteria1();
  final Set<Ref> all=new HashSet<Ref>();
  for (int r=row1; r <= row2; ++r) {
    final Cell cell=BookHelper.getCell(_sheet,r,col);
    final String val=BookHelper.isBlankCell(cell) ? ""String_Node_Str"" : BookHelper.getCellText(cell);
    if (!cr1.contains(val)) {
      final Row rowobj=_sheet.getRow(r);
      if (rowobj == null || !rowobj.getZeroHeight()) {
        new RangeImpl(r,col,_sheet,_sheet).getRows().setHidden(true);
      }
    }
 else {
      final Row rowobj=_sheet.getRow(r);
      if (rowobj != null && rowobj.getZeroHeight() && canUnhide(af,fc,r,col1)) {
        final RangeImpl rng=(RangeImpl)new RangeImpl(r,col1,r,col2,_sheet,_sheet).getRows();
        all.addAll(rng.getRefs());
        rng.getRows().setHidden(false);
      }
    }
  }
  BookHelper.notifyCellChanges(_sheet.getBook(),all);
  final RangeImpl buttonChange=(RangeImpl)Ranges.range(_sheet,row1,col,row1,col);
  BookHelper.notifyBtnChanges(new HashSet<Ref>(buttonChange.getRefs()));
  return af;
}","@Override public AutoFilter autoFilter(int field,Object criteria1,int filterOp,Object criteria2,boolean visibleDropDown){
  AutoFilter af=_sheet.getAutoFilter();
  if (af == null) {
    af=autoFilter();
  }
  final FilterColumn fc=BookHelper.getOrCreateFilterColumn(af,field - 1);
  BookHelper.setProperties(fc,criteria1,filterOp,criteria2,visibleDropDown);
  final CellRangeAddress affectedArea=af.getRangeAddress();
  final int row1=affectedArea.getFirstRow();
  final int col1=affectedArea.getFirstColumn();
  final int col=col1 + field - 1;
  final int row=row1 + 1;
  final int row2=affectedArea.getLastRow();
  final int col2=affectedArea.getLastColumn();
  final Set cr1=fc.getCriteria1();
  final Set<Ref> all=new HashSet<Ref>();
  for (int r=row; r <= row2; ++r) {
    final Cell cell=BookHelper.getCell(_sheet,r,col);
    final String val=BookHelper.isBlankCell(cell) ? ""String_Node_Str"" : BookHelper.getCellText(cell);
    if (!cr1.contains(val)) {
      final Row rowobj=_sheet.getRow(r);
      if (rowobj == null || !rowobj.getZeroHeight()) {
        new RangeImpl(r,col,_sheet,_sheet).getRows().setHidden(true);
      }
    }
 else {
      final Row rowobj=_sheet.getRow(r);
      if (rowobj != null && rowobj.getZeroHeight() && canUnhide(af,fc,r,col1)) {
        final RangeImpl rng=(RangeImpl)new RangeImpl(r,col1,r,col2,_sheet,_sheet).getRows();
        all.addAll(rng.getRefs());
        rng.getRows().setHidden(false);
      }
    }
  }
  BookHelper.notifyCellChanges(_sheet.getBook(),all);
  final RangeImpl buttonChange=(RangeImpl)Ranges.range(_sheet,row1,col,row1,col);
  BookHelper.notifyBtnChanges(new HashSet<Ref>(buttonChange.getRefs()));
  return af;
}",0.9997022923489134
56626,"private static void clearCutRangeIfNeed(Spreadsheet ss){
  if (!isCut(ss))   return;
  Worksheet srcSheet=getSourceSheet(ss);
  Worksheet dstSheet=ss.getSelectedSheet();
  Rect srcRange=getSourceRange(ss);
  int srcLeft=srcRange.getLeft();
  int srcRight=srcRange.getRight();
  int srcTop=srcRange.getTop();
  int srcBottom=srcRange.getBottom();
  int dstLeft=ss.getSelection().getLeft();
  int dstTop=ss.getSelection().getTop();
  int dstRight=dstLeft + (srcRight - srcLeft);
  int maxCol=ss.getMaxcolumns();
  dstRight=dstRight < maxCol ? dstRight : maxCol;
  int dstBottom=dstTop + (srcBottom - srcTop);
  int maxRow=ss.getMaxrows();
  dstBottom=dstBottom < maxRow ? dstBottom : maxRow;
  boolean sameSheet=ss.indexOfSheet(srcSheet) == ss.indexOfSheet(dstSheet);
  final CellStyle defaultStyle=ss.getBook().createCellStyle();
  for (int row=srcTop; row <= srcBottom; row++) {
    for (int col=srcLeft; col <= srcRight; col++) {
      if (sameSheet && (row >= dstTop && row <= dstBottom && col >= dstLeft && col <= dstRight))       continue;
      Range rng=Ranges.range(srcSheet,row,col);
      rng.setEditText(null);
      rng.setStyle(defaultStyle);
    }
  }
  ss.setAttribute(KEY_SRC_SHEET,null);
  ss.setAttribute(KEY_SRC_RANGE,null);
}","private static void clearCutRangeIfNeed(Spreadsheet ss){
  if (!isCut(ss))   return;
  int maxCol=ss.getMaxcolumns();
  int maxRow=ss.getMaxrows();
  Worksheet srcSheet=getSourceSheet(ss);
  Worksheet dstSheet=ss.getSelectedSheet();
  Rect srcRange=getSourceRange(ss);
  int srcLeft=srcRange.getLeft();
  int srcRight=srcRange.getRight();
  srcRight=srcRight < maxCol ? srcRight : maxCol;
  int srcTop=srcRange.getTop();
  int srcBottom=srcRange.getBottom();
  srcBottom=srcBottom < maxRow ? srcBottom : maxRow;
  int dstLeft=ss.getSelection().getLeft();
  int dstTop=ss.getSelection().getTop();
  int dstRight=dstLeft + (srcRight - srcLeft);
  dstRight=dstRight < maxCol ? dstRight : maxCol;
  int dstBottom=dstTop + (srcBottom - srcTop);
  dstBottom=dstBottom < maxRow ? dstBottom : maxRow;
  boolean sameSheet=ss.indexOfSheet(srcSheet) == ss.indexOfSheet(dstSheet);
  final CellStyle defaultStyle=ss.getBook().createCellStyle();
  for (int row=srcTop; row <= srcBottom; row++) {
    for (int col=srcLeft; col <= srcRight; col++) {
      if (sameSheet && (row >= dstTop && row <= dstBottom && col >= dstLeft && col <= dstRight))       continue;
      Range rng=Ranges.range(srcSheet,row,col);
      rng.setEditText(null);
      rng.setStyle(defaultStyle);
    }
  }
  ss.setAttribute(KEY_SRC_SHEET,null);
  ss.setAttribute(KEY_SRC_RANGE,null);
}",0.8869162485526824
56627,"private String getSheetDefaultRules(){
  Sheet sheet=getSelectedSheet();
  HeaderPositionHelper colHelper=this.getColumnPositionHelper(sheet);
  HeaderPositionHelper rowHelper=this.getRowPositionHelper(sheet);
  MergeMatrixHelper mmhelper=this.getMergeMatrixHelper(sheet);
  boolean hiderow=isHiderowhead();
  boolean hidecol=isHidecolumnhead();
  boolean showgrid=sheet.isDisplayGridlines();
  int th=hidecol ? 1 : this.getTopheadheight();
  int lw=hiderow ? 1 : this.getLeftheadwidth();
  int cp=this._cellpadding;
  int rh=this.getRowheight();
  int cw=this.getColumnwidth();
  int lh=20;
  if (lh > rh) {
    lh=rh;
  }
  String sheetid=getUuid();
  String name=""String_Node_Str"" + sheetid;
  int cellwidth;
  int cellheight;
  Execution exe=Executions.getCurrent();
  boolean isGecko=exe.isGecko();
  boolean isIE=exe.isExplorer();
  if (isGecko) {
    cellwidth=cw;
    cellheight=rh;
  }
 else {
    cellwidth=cw - 2 * cp - 1;
    cellheight=rh - 1;
  }
  int celltextwidth=cw - 2 * cp - 1;
  StringBuffer sb=new StringBuffer();
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(rh).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(""String_Node_Str"" + cp + ""String_Node_Str""+ cp+ ""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cellheight).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cellwidth).append(""String_Node_Str"");
  if (!showgrid) {
    sb.append(""String_Node_Str"").append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(celltextwidth).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cellheight).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  int toph=th - 1;
  int topheadh=(isGecko) ? toph : toph - 1;
  int cornertoph=th - 1;
  int fzr=getRowfreeze();
  int fzc=getColumnfreeze();
  if (fzr > -1) {
    toph=toph + rowHelper.getStartPixel(fzr + 1);
  }
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzr > -1 ? toph - 1 : toph).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(toph).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(topheadh).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cornertoph).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(""String_Node_Str"" + cp + ""String_Node_Str""+ cp+ ""String_Node_Str"");
  sb.append(""String_Node_Str"").append(topheadh).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cellwidth).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(topheadh).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(celltextwidth).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  int leftw=lw - 1;
  int leftheadw=leftw;
  int leftblockleft=leftw;
  if (fzc > -1) {
    leftw=leftw + colHelper.getStartPixel(fzc + 1);
  }
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzc > -1 ? leftw - 1 : leftw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(leftw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(leftheadw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(leftblockleft).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(leftheadw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(rh - 1).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(rh - 1).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzc > -1 ? leftw : leftw + 1).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzr > -1 ? toph : toph + 1).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw - 2).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th - 2).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzr > -1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzr > -1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzc > -1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzc > -1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  boolean transparentBorder=false;
  if (transparentBorder) {
    sb.append(name).append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (isIE) {
      String color_to_transparent=""String_Node_Str"";
      sb.append(""String_Node_Str"" + color_to_transparent + ""String_Node_Str"");
      sb.append(""String_Node_Str"" + color_to_transparent + ""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
  }
  List<HeaderPositionInfo> infos=colHelper.getInfos();
  for (  HeaderPositionInfo info : infos) {
    boolean hidden=info.hidden;
    int index=info.index;
    int width=hidden ? 0 : info.size;
    int cid=info.id;
    celltextwidth=width - 2 * cp - 1;
    if (celltextwidth < 0)     celltextwidth=0;
    if (!isGecko) {
      cellwidth=celltextwidth;
    }
 else {
      cellwidth=width;
    }
    if (width <= 0) {
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(cellwidth).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(celltextwidth).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  infos=rowHelper.getInfos();
  for (  HeaderPositionInfo info : infos) {
    boolean hidden=info.hidden;
    int index=info.index;
    int height=hidden ? 0 : info.size;
    int cid=info.id;
    cellheight=height;
    if (!isGecko) {
      cellheight=height - 1;
    }
    if (height <= 0) {
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(cellheight).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      int h2=(height < 1) ? 0 : height - 1;
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(h2).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(h2).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  List ranges=mmhelper.getRanges();
  Iterator iter=ranges.iterator();
  while (iter.hasNext()) {
    MergedRect block=(MergedRect)iter.next();
    int left=block.getLeft();
    int right=block.getRight();
    int width=0;
    for (int i=left; i <= right; i++) {
      final HeaderPositionInfo info=colHelper.getInfo(i);
      final boolean hidden=info.hidden;
      final int colSize=hidden ? 0 : info.size;
      width+=colSize;
    }
    if (width <= 0) {
      sb.append(name).append(""String_Node_Str"").append(block.getId()).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(block.getId());
      sb.append(""String_Node_Str"").append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
 else {
      celltextwidth=width - 2 * cp - 1;
      if (!isGecko) {
        cellwidth=celltextwidth;
      }
 else {
        cellwidth=width;
      }
      sb.append(name).append(""String_Node_Str"").append(block.getId()).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(cellwidth).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(block.getId());
      sb.append(""String_Node_Str"").append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(celltextwidth).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","private String getSheetDefaultRules(){
  Sheet sheet=getSelectedSheet();
  HeaderPositionHelper colHelper=this.getColumnPositionHelper(sheet);
  HeaderPositionHelper rowHelper=this.getRowPositionHelper(sheet);
  MergeMatrixHelper mmhelper=this.getMergeMatrixHelper(sheet);
  boolean hiderow=isHiderowhead();
  boolean hidecol=isHidecolumnhead();
  boolean showgrid=sheet.isDisplayGridlines();
  int th=hidecol ? 1 : this.getTopheadheight();
  int lw=hiderow ? 1 : this.getLeftheadwidth();
  int cp=this._cellpadding;
  int rh=this.getRowheight();
  int cw=this.getColumnwidth();
  int lh=20;
  if (lh > rh) {
    lh=rh;
  }
  String sheetid=getUuid();
  String name=""String_Node_Str"" + sheetid;
  int cellwidth;
  int cellheight;
  Execution exe=Executions.getCurrent();
  boolean isGecko=exe.isGecko();
  boolean isIE=exe.isExplorer();
  if (isGecko) {
    cellwidth=cw;
    cellheight=rh;
  }
 else {
    cellwidth=cw - 2 * cp - 1;
    cellheight=rh - 1;
  }
  int celltextwidth=cw - 2 * cp - 1;
  StringBuffer sb=new StringBuffer();
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(rh).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(""String_Node_Str"" + cp + ""String_Node_Str""+ cp+ ""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cellheight).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cellwidth).append(""String_Node_Str"");
  if (!showgrid) {
    sb.append(""String_Node_Str"").append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(celltextwidth).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cellheight).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  int toph=th - 1;
  int topheadh=(isGecko) ? toph : toph - 1;
  int cornertoph=th - 1;
  int fzr=getRowfreeze();
  int fzc=getColumnfreeze();
  if (fzr > -1) {
    toph=toph + rowHelper.getStartPixel(fzr + 1);
  }
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzr > -1 ? toph - 1 : toph).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(toph).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(topheadh).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cornertoph).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(""String_Node_Str"" + cp + ""String_Node_Str""+ cp+ ""String_Node_Str"");
  sb.append(""String_Node_Str"").append(topheadh).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(cellwidth).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(topheadh).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(celltextwidth).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  int leftw=lw - 1;
  int leftheadw=leftw;
  int leftblockleft=leftw;
  if (fzc > -1) {
    leftw=leftw + colHelper.getStartPixel(fzc + 1);
  }
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzc > -1 ? leftw - 1 : leftw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(leftw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(leftheadw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(leftblockleft).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(leftheadw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(rh - 1).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(rh - 1).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzc > -1 ? leftw : leftw + 1).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzr > -1 ? toph : toph + 1).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw - 2).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th - 2).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(lw).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(th).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzr > -1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzr > -1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzc > -1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(fzc > -1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  boolean transparentBorder=false;
  if (transparentBorder) {
    sb.append(name).append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (isIE) {
      String color_to_transparent=""String_Node_Str"";
      sb.append(""String_Node_Str"" + color_to_transparent + ""String_Node_Str"");
      sb.append(""String_Node_Str"" + color_to_transparent + ""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
  }
  List<HeaderPositionInfo> infos=colHelper.getInfos();
  for (  HeaderPositionInfo info : infos) {
    boolean hidden=info.hidden;
    int index=info.index;
    int width=hidden ? 0 : info.size;
    int cid=info.id;
    celltextwidth=width - 2 * cp - 1;
    if (celltextwidth < 0)     celltextwidth=0;
    if (!isGecko) {
      cellwidth=celltextwidth;
    }
 else {
      cellwidth=width;
    }
    if (width <= 0) {
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(cellwidth).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(celltextwidth).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  infos=rowHelper.getInfos();
  for (  HeaderPositionInfo info : infos) {
    boolean hidden=info.hidden;
    int index=info.index;
    int height=hidden ? 0 : info.size;
    int cid=info.id;
    cellheight=height;
    if (!isGecko) {
      cellheight=height - 1;
    }
    if (height <= 0) {
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(cellheight).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      int h2=(height < 1) ? 0 : height - 1;
      sb.append(name).append(""String_Node_Str"").append(cid).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(h2).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(h2).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  List ranges=mmhelper.getRanges();
  Iterator iter=ranges.iterator();
  final int defaultSize=colHelper.getDefaultSize();
  while (iter.hasNext()) {
    MergedRect block=(MergedRect)iter.next();
    int left=block.getLeft();
    int right=block.getRight();
    int width=0;
    for (int i=left; i <= right; i++) {
      final HeaderPositionInfo info=colHelper.getInfo(i);
      if (info != null) {
        final boolean hidden=info.hidden;
        final int colSize=hidden ? 0 : info.size;
        width+=colSize;
      }
 else {
        width+=defaultSize;
      }
    }
    if (width <= 0) {
      sb.append(name).append(""String_Node_Str"").append(block.getId()).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(block.getId());
      sb.append(""String_Node_Str"").append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
 else {
      celltextwidth=width - 2 * cp - 1;
      if (!isGecko) {
        cellwidth=celltextwidth;
      }
 else {
        cellwidth=width;
      }
      sb.append(name).append(""String_Node_Str"").append(block.getId()).append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(cellwidth).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(name).append(""String_Node_Str"").append(block.getId());
      sb.append(""String_Node_Str"").append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(celltextwidth).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.9905234657039712
56628,"/** 
 * Issues UPnP commands to a GatewayDevice that can be reached at the specified <tt>url</tt> The command is identified by a <tt>service</tt> and an <tt>action</tt> and can receive arguments
 * @param url the url to use to contact the device
 * @param service the service to invoke
 * @param action the specific action to perform
 * @param args the command arguments
 * @return the response to the performed command, as a name-vale map
 * @throws IOException on communication errors
 * @throws SAXException if errors occur while parsing the response
 */
public static Map<String,String> simpleUPnPcommand(String url,String service,String action,Map<String,String> args) throws IOException, SAXException {
  String soapAction=service + ""String_Node_Str"" + action;
  StringBuffer soapBody=new StringBuffer();
  soapBody.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + action + ""String_Node_Str""+ service+ ""String_Node_Str"");
  if (args != null && args.size() > 0) {
    Set<Map.Entry<String,String>> entrySet=args.entrySet();
    for (    Map.Entry<String,String> entry : entrySet) {
      soapBody.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str"");
    }
  }
  soapBody.append(""String_Node_Str"" + action + ""String_Node_Str"");
  soapBody.append(""String_Node_Str"");
  URL postUrl=new URL(url);
  HttpURLConnection conn=(HttpURLConnection)postUrl.openConnection();
  conn.setRequestMethod(""String_Node_Str"");
  conn.setDoOutput(true);
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  conn.setRequestProperty(""String_Node_Str"",soapAction);
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  byte[] soapBodyBytes=soapBody.toString().getBytes();
  conn.setRequestProperty(""String_Node_Str"",String.valueOf(soapBodyBytes.length));
  conn.getOutputStream().write(soapBodyBytes);
  Map<String,String> nameValue=new HashMap<String,String>();
  XMLReader parser=XMLReaderFactory.createXMLReader();
  parser.setContentHandler(new NameValueHandler(nameValue));
  if (conn.getResponseCode() == HttpURLConnection.HTTP_INTERNAL_ERROR) {
    parser.parse(new InputSource(conn.getErrorStream()));
    conn.disconnect();
    return nameValue;
  }
 else {
    parser.parse(new InputSource(conn.getInputStream()));
    conn.disconnect();
    return nameValue;
  }
}","/** 
 * Issues UPnP commands to a GatewayDevice that can be reached at the specified <tt>url</tt> The command is identified by a <tt>service</tt> and an <tt>action</tt> and can receive arguments
 * @param url the url to use to contact the device
 * @param service the service to invoke
 * @param action the specific action to perform
 * @param args the command arguments
 * @return the response to the performed command, as a name-value map.In case errors occur, the returned map will be <i>empty.</i>
 * @throws IOException on communication errors
 * @throws SAXException if errors occur while parsing the response
 */
public static Map<String,String> simpleUPnPcommand(String url,String service,String action,Map<String,String> args) throws IOException, SAXException {
  String soapAction=service + ""String_Node_Str"" + action;
  StringBuffer soapBody=new StringBuffer();
  soapBody.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + action + ""String_Node_Str""+ service+ ""String_Node_Str"");
  if (args != null && args.size() > 0) {
    Set<Map.Entry<String,String>> entrySet=args.entrySet();
    for (    Map.Entry<String,String> entry : entrySet) {
      soapBody.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str"");
    }
  }
  soapBody.append(""String_Node_Str"" + action + ""String_Node_Str"");
  soapBody.append(""String_Node_Str"");
  URL postUrl=new URL(url);
  HttpURLConnection conn=(HttpURLConnection)postUrl.openConnection();
  conn.setRequestMethod(""String_Node_Str"");
  conn.setDoOutput(true);
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  conn.setRequestProperty(""String_Node_Str"",soapAction);
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  byte[] soapBodyBytes=soapBody.toString().getBytes();
  conn.setRequestProperty(""String_Node_Str"",String.valueOf(soapBodyBytes.length));
  conn.getOutputStream().write(soapBodyBytes);
  Map<String,String> nameValue=new HashMap<String,String>();
  XMLReader parser=XMLReaderFactory.createXMLReader();
  parser.setContentHandler(new NameValueHandler(nameValue));
  if (conn.getResponseCode() == HttpURLConnection.HTTP_INTERNAL_ERROR) {
    try {
      parser.parse(new InputSource(conn.getErrorStream()));
    }
 catch (    SAXException e) {
    }
    conn.disconnect();
    return nameValue;
  }
 else {
    parser.parse(new InputSource(conn.getInputStream()));
    conn.disconnect();
    return nameValue;
  }
}",0.974769723668402
56629,"/** 
 * Receive notification of character data inside an element. Stores the characters as value, using   {@link #currentElement} as a key 
 * @param ch The characters.
 * @param start The start position in the character array.
 * @param length The number of characters to use from thecharacter array.
 * @exception org.xml.sax.SAXException Any SAX exception, possiblywrapping another exception.
 * @see org.xml.sax.ContentHandler#characters
 */
public void characters(char[] ch,int start,int length) throws SAXException {
  nameValue.put(currentElement,new String(ch,start,length));
}","/** 
 * Receive notification of character data inside an element. Stores the characters as value, using   {@link #currentElement} as a key 
 * @param ch The characters.
 * @param start The start position in the character array.
 * @param length The number of characters to use from thecharacter array.
 * @exception org.xml.sax.SAXException Any SAX exception, possiblywrapping another exception.
 * @see org.xml.sax.ContentHandler#characters
 */
public void characters(char[] ch,int start,int length) throws SAXException {
  if (currentElement != null) {
    String value=new String(ch,start,length);
    String old=nameValue.put(currentElement,value);
    if (old != null) {
      nameValue.put(currentElement,old + value);
    }
  }
}",0.8266464799394398
56630,"@Produces @Dependent public static Collection<MonetaryAmountFactory> amountFactories(InjectionPoint ip){
  AmountSpec specAnnot=ip.getAnnotated() != null ? ip.getAnnotated().getAnnotation(AmountSpec.class) : null;
  if (specAnnot != null) {
    return Collection.class.cast(Monetary.getAmountFactories(createAmountQuery(specAnnot)));
  }
  return Collection.class.cast(Monetary.getAmountFactories());
}","@SuppressWarnings(""String_Node_Str"") @Produces @Dependent public static Collection<MonetaryAmountFactory> amountFactories(InjectionPoint ip){
  AmountSpec specAnnot=ip.getAnnotated() != null ? ip.getAnnotated().getAnnotation(AmountSpec.class) : null;
  if (specAnnot != null) {
    return Collection.class.cast(Monetary.getAmountFactories(createAmountQuery(specAnnot)));
  }
  return Collection.class.cast(Monetary.getAmountFactories());
}",0.9560047562425684
56631,"public static BigDecimal zero(){
  return instance.zero;
}","/** 
 * Accesses the number '1' initialized with the current   {@link MathContext}.
 * @return the number instance, never null.
 */
public static BigDecimal zero(){
  return instance.zero;
}",0.4677419354838709
56632,"private void init(MathContext mathContext){
  one=new BigDecimal(1,mathContext);
  zero=new BigDecimal(0,mathContext);
  this.mathContext=mathContext;
}","private void init(MathContext mathContext){
  this.mathContext=mathContext;
  one=new BigDecimal(1,mathContext);
  zero=new BigDecimal(0,mathContext);
  ten=new BigDecimal(10,mathContext);
}",0.8011695906432749
56633,"public static BigDecimal one(){
  return instance.one;
}","/** 
 * Accesses the number '1' initialized with the current   {@link MathContext}.
 * @return the number instance, never null.
 */
public static BigDecimal one(){
  return instance.one;
}",0.4590163934426229
56634,"public static BigDecimal bigDecimal(BigDecimal num){
  return new BigDecimal(num.toString(),mathContext());
}","/** 
 * Creates the given number initialized with the current   {@link MathContext}.
 * @param num the number instance.
 * @return the number instance, never null.
 */
public static BigDecimal bigDecimal(BigDecimal num){
  return new BigDecimal(num.toString(),mathContext());
}",0.5647668393782384
56635,"public static BigDecimal zero(){
  return INSTANCE.zero;
}","public static BigDecimal zero(){
  return instance.zero;
}",0.8620689655172413
56636,"public static MathContext mathContext(){
  return INSTANCE.mathContext;
}","public static MathContext mathContext(){
  return instance.mathContext;
}",0.8904109589041096
56637,"public static BigDecimal one(){
  return INSTANCE.one;
}","public static BigDecimal one(){
  return instance.one;
}",0.8571428571428571
56638,"/** 
 * This method allows o set the   {@link MathContext} used for doing calculations.Not te that this affects all calculations at all stages.
 * @param mathContext the new match context, not null.
 */
public static void setMathContext(MathContext mathContext){
  INSTANCE.init(Objects.requireNonNull(mathContext));
}","/** 
 * This method allows o set the   {@link MathContext} used for doing calculations.Not te that this affects all calculations at all stages.
 * @param mathContext the new match context, not null.
 */
public static void setMathContext(MathContext mathContext){
  instance.init(Objects.requireNonNull(mathContext));
}",0.9748427672955976
56639,"/** 
 * Access the input type descriptor.
 * @return the input type descriptor, never null.
 */
public I getInputType();","/** 
 * Access the input type descriptor.
 * @return the input type descriptor, never null.
 */
I getInputType();",0.9699570815450644
56640,"/** 
 * Access the result type.
 * @return the result type, never null.
 */
public Class<T> getResultType();","/** 
 * Access the result type.
 * @return the result type, never null.
 */
Class<T> getResultType();",0.9665071770334928
56641,"/** 
 * Calulates the result.
 * @param input the input value
 * @return the result
 * @throws javax.money.MonetaryException if input validation fails, or an other monetary errors occurring.
 */
public T calculate(ComplexValue<I> input);","/** 
 * Calulates the result.
 * @param input the input value
 * @return the result
 * @throws javax.money.MonetaryException if input validation fails, or an other monetary errors occurring.
 */
T calculate(ComplexValue<I> input);",0.9850107066381156
56642,"public <T>T get(String key,Class<T> type,T defaultValue){
  @SuppressWarnings(""String_Node_Str"") T t=(T)this.args.get(key);
  if (t == null) {
    return defaultValue;
  }
  return t;
}","public <P>P get(String key,Class<P> type,P defaultValue){
  @SuppressWarnings(""String_Node_Str"") P t=(P)this.args.get(key);
  if (t == null) {
    return defaultValue;
  }
  return t;
}",0.9675675675675676
56643,"public CompositeMonetaryOperator(String name,MonetaryOperator... operations){
  Objects.requireNonNull(name);
  for (  MonetaryOperator monetaryOperator : operations) {
    functions.add(monetaryOperator);
  }
}","public CompositeMonetaryOperator(String name,MonetaryOperator... operations){
  Objects.requireNonNull(name);
  Collections.addAll(functions,operations);
}",0.7213114754098361
56644,"/** 
 * Performs the calculation.
 * @param amountPV  the present value, not null.
 * @param balloonAmount the balloon amount, not null and currency compatible with {@code amountPV}.
 * @param rate    the target rate, not null.
 * @param periods the periods, >= 0.
 * @return the resulting amount, never null.
 */
public static MonetaryAmount calculate(MonetaryAmount amountPV,MonetaryAmount balloonAmount,Rate rate,int periods){
  if (periods < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final BigDecimal ONE=new BigDecimal(1,MathContext.DECIMAL64);
  BigDecimal factor2=rate.get().divide(ONE.subtract(ONE.add(rate.get()).pow(-periods,MathContext.DECIMAL64)),MathContext.DECIMAL64);
  MonetaryAmount factor1=amountPV.subtract(balloonAmount.getFactory().setNumber(balloonAmount.getNumber().numberValue(BigDecimal.class).divide(ONE.add(rate.get()).pow(periods,MathContext.DECIMAL64),MathContext.DECIMAL64)).create());
  return factor1.multiply(factor2);
}","/** 
 * Performs the calculation.
 * @param amountPV  the present value, not null.
 * @param balloonAmount the balloon amount, not null and currency compatible with {@code amountPV}.
 * @param rate    the target rate, not null.
 * @param periods the periods, >= 0.
 * @return the resulting amount, never null.
 */
public static MonetaryAmount calculate(MonetaryAmount amountPV,MonetaryAmount balloonAmount,Rate rate,int periods){
  if (periods < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  BigDecimal factor2=rate.get().divide(one().subtract(one().add(rate.get()).pow(-periods,MathContext.DECIMAL64)),MathContext.DECIMAL64);
  MonetaryAmount factor1=amountPV.subtract(balloonAmount.getFactory().setNumber(balloonAmount.getNumber().numberValue(BigDecimal.class).divide(one().add(rate.get()).pow(periods,MathContext.DECIMAL64),MathContext.DECIMAL64)).create());
  return factor1.multiply(factor2);
}",0.694327731092437
56645,"/** 
 * Access the shared instance of   {@link BasisPoint} for use.
 * @return the shared instance, never {@code null}.
 */
private BasisPoint(final Number decimal){
  basisPointValue=calcBasisPoint(decimal);
}","private BasisPoint(final Number decimal){
  basisPointValue=calcBasisPoint(decimal);
}",0.581081081081081
56646,"/** 
 * Calculate a BigDecimal value for a Permil e.g. ""3"" (3 permil) will generate .003
 * @return java.math.BigDecimal
 * @param number the basis points number, 10'000-ends.
 */
private static final BigDecimal calcBasisPoint(Number number){
  return MoneyUtils.getBigDecimal(number).divide(ONE_TENTHOUSAND,CalculationContext.mathContext());
}","/** 
 * Calculate a BigDecimal value for a Permil e.g. ""3"" (3 permil) will generate .003
 * @return java.math.BigDecimal
 * @param number the basis points number, 10'000-ends.
 */
private static BigDecimal calcBasisPoint(Number number){
  return MoneyUtils.getBigDecimal(number).divide(ONE_TENTHOUSAND,CalculationContext.mathContext());
}",0.9912023460410556
56647,"/** 
 * Performs the calculation.
 * @param amount  the base amount, not null.
 * @param rate    the target rate, not null.
 * @param periods the periods, >= 0.
 * @return the resulting amount, never null.
 */
public static MonetaryAmount calculate(MonetaryAmount amount,Rate rate,int periods,int timesCompounded){
  final BigDecimal ONE=CalculationContext.one();
  BigDecimal part2=rate.get().divide(BigDecimal.valueOf(timesCompounded));
  BigDecimal base=ONE.add(part2);
  BigDecimal multiplicator=base.pow(periods * timesCompounded);
  return amount.multiply(multiplicator).subtract(amount);
}","/** 
 * Performs the calculation.
 * @param amount  the base amount, not null.
 * @param rate    the target rate, not null.
 * @param periods the periods, >= 0.
 * @return the resulting amount, never null.
 */
public static MonetaryAmount calculate(MonetaryAmount amount,Rate rate,int periods,int timesCompounded){
  BigDecimal part2=rate.get().divide(BigDecimal.valueOf(timesCompounded),mathContext());
  BigDecimal base=one().add(part2);
  BigDecimal multiplicator=base.pow(periods * timesCompounded,mathContext());
  return amount.multiply(multiplicator).subtract(amount);
}",0.927536231884058
56648,"/** 
 * This function returns the number of periods required to double an amount with continuous compounding, given a rate.
 */
public static BigDecimal calculate(Rate rate){
  if (rate.get().signum() == 0) {
    throw new MonetaryException(""String_Node_Str"");
  }
  return new BigDecimal(Math.log(2.0d),CalculationContext.mathContext()).divide(new BigDecimal(Math.log(1.0d + rate.get().doubleValue())),CalculationContext.mathContext());
}","/** 
 * This function returns the number of periods required to double an amount with continuous compounding, given a rate.
 */
public static BigDecimal calculate(Rate rate){
  if (rate.get().signum() == 0) {
    throw new MonetaryException(""String_Node_Str"");
  }
  return new BigDecimal(Math.log(2.0d),CalculationContext.mathContext()).divide(BigDecimal.valueOf(Math.log(1.0d + rate.get().doubleValue())),CalculationContext.mathContext());
}",0.9863945578231292
56649,"protected LocalDate[] getQueryDates(ConversionQuery query){
  if (Objects.nonNull(query.get(LocalDate.class)) || Objects.nonNull(query.get(LocalDateTime.class))) {
    LocalDate localDate=Optional.ofNullable(query.get(LocalDate.class)).orElseGet(() -> query.get(LocalDateTime.class).toLocalDate());
    return new LocalDate[]{localDate};
  }
 else   if (Objects.nonNull(query.get(LocalDate[].class))) {
    return query.get(LocalDate[].class);
  }
  return null;
}","@Override protected LocalDate[] getQueryDates(ConversionQuery query){
  if (Objects.nonNull(query.get(LocalDate.class)) || Objects.nonNull(query.get(LocalDateTime.class))) {
    LocalDate localDate=Optional.ofNullable(query.get(LocalDate.class)).orElseGet(() -> query.get(LocalDateTime.class).toLocalDate());
    return new LocalDate[]{localDate};
  }
 else   if (Objects.nonNull(query.get(LocalDate[].class))) {
    return query.get(LocalDate[].class);
  }
  return null;
}",0.9893390191897654
56650,"private ExchangeRate reverse(ExchangeRate rate){
  if (Objects.isNull(rate)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new ExchangeRateBuilder(rate).setRate(rate).setBase(rate.getCurrency()).setTerm(rate.getBaseCurrency()).setFactor(divide(DefaultNumberValue.ONE,rate.getFactor(),MathContext.DECIMAL64)).build();
}","private ExchangeRate reverse(ExchangeRate rate){
  if (Objects.isNull(rate)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new ExchangeRateBuilder(rate).setRate(rate).setBase(rate.getCurrency()).setTerm(rate.getBaseCurrency()).setContext(getExchangeContext(DIGIT_FRACTION_KEY)).setFactor(divide(DefaultNumberValue.ONE,rate.getFactor(),MathContext.DECIMAL64)).build();
}",0.9313593539703904
56651,"protected ConversionContext getExchangeContext(String key){
  int scale=getScale(key);
  if (scale < 0) {
    return ConversionContext.of(this.context.getProviderName(),RateType.HISTORIC);
  }
 else {
    return ConversionContext.of(this.context.getProviderName(),RateType.HISTORIC).toBuilder().set(KEY_SCALE,scale).build();
  }
}","@Override protected ConversionContext getExchangeContext(String key){
  int scale=getScale(key);
  if (scale < 0) {
    return ConversionContext.of(this.context.getProviderName(),RateType.HISTORIC);
  }
 else {
    return ConversionContext.of(this.context.getProviderName(),RateType.HISTORIC).toBuilder().set(KEY_SCALE,scale).build();
  }
}",0.9850746268656716
56652,"protected int getScale(String key){
  String string=MonetaryConfig.getConfig().getOrDefault(key,""String_Node_Str"");
  if (string.isEmpty()) {
    return -1;
  }
 else {
    try {
      return Integer.valueOf(string);
    }
 catch (    NumberFormatException e) {
      return -1;
    }
  }
}","@Override protected int getScale(String key){
  String string=MonetaryConfig.getConfig().getOrDefault(key,""String_Node_Str"");
  if (string.isEmpty()) {
    return -1;
  }
 else {
    try {
      return Integer.valueOf(string);
    }
 catch (    NumberFormatException e) {
      return -1;
    }
  }
}",0.9830508474576272
56653,"/** 
 * Performs the calculation.
 * @param amount  the base amount, not null.
 * @param rate    the target rate, not null.
 * @param periods the periods, >= 0.
 * @return the resulting amount, never null.
 */
public static MonetaryAmount calculate(MonetaryAmount amount,Rate rate,int periods){
  int power=rate.get().multiply(BigDecimal.valueOf(periods)).intValue();
  BigDecimal f=BigDecimal.valueOf(Math.E).pow(power);
  return amount.multiply(f);
}","/** 
 * Performs the calculation.
 * @param amount  the base amount, not null.
 * @param rate    the target rate, not null.
 * @param periods the periods, >= 0.
 * @return the resulting amount, never null.
 */
public static MonetaryAmount calculate(MonetaryAmount amount,Rate rate,int periods){
  int power=rate.get().multiply(BigDecimal.valueOf(periods)).intValue();
  BigDecimal f=BigDecimal.valueOf(Math.E).pow(power);
  return (amount.multiply(f));
}",0.9977924944812362
56654,"/** 
 * Calculates the discount factor.
 * @param rate    the target rate, not null.
 * @param periods the periods, >= 0.
 * @return the factor calculated.
 */
public static BigDecimal calculate(Rate rate,int periods){
  Objects.requireNonNull(rate);
  if (periods < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  BigDecimal div=BigDecimal.ONE.min(BigDecimal.ONE.add(rate.get()));
  BigDecimal factor=BigDecimal.ONE.subtract(BigDecimal.ONE.add(rate.get()).pow(periods)).divide(div);
  return BigDecimal.ONE.add(factor);
}","/** 
 * Calculates the discount factor.
 * @param rate    the target rate, not null.
 * @param periods the periods, >= 0.
 * @return the factor calculated.
 */
public static BigDecimal calculate(Rate rate,int periods){
  Objects.requireNonNull(rate);
  if (periods < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  BigDecimal div=BigDecimal.ONE.min(BigDecimal.ONE.add(rate.get()));
  BigDecimal factor=BigDecimal.ONE.subtract(BigDecimal.ONE.add(rate.get()).pow(periods)).divide(div,BigDecimal.ROUND_HALF_DOWN);
  return BigDecimal.ONE.add(factor);
}",0.9757847533632288
56655,"public FlavoredMonetaryAmount(MonetaryAmount baseAmount,String amountType){
  Objects.requireNonNull(baseAmount,""String_Node_Str"");
  this.baseAmount=baseAmount;
  if (amountType != null) {
    this.amountType=amountType;
  }
}","private FlavoredMonetaryAmount(MonetaryAmount baseAmount,String amountType){
  Objects.requireNonNull(baseAmount,""String_Node_Str"");
  this.baseAmount=baseAmount;
  if (amountType != null) {
    this.amountType=amountType;
  }
}",0.9758241758241758
56656,"@Override public MonetaryContext getMonetaryContext(){
  return null;
}","@Override public MonetaryContext getMonetaryContext(){
  return this.amount.getMonetaryContext();
}",0.8
56657,"@Override public Number getNumber(Class type){
  return null;
}","@Override public <N extends Number>N getNumber(Class<N> type){
  return this.amount.getNumber(type);
}",0.7393939393939394
56658,"public boolean isGreaterThanOrEqualTo(MonetaryAmount amount){
  return this.amount.isGreaterThanOrEqualTo(amount);
}","public boolean isGreaterThanOrEqualTo(MonetaryAmount<?> amount){
  return this.amount.isGreaterThanOrEqualTo(amount);
}",0.9872340425531916
56659,"/** 
 * Access an   {@link ConstraintMoney} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return
 */
private static ConstraintMoney of(Money amount,MonetaryPredicate<MonetaryAmount> predicate){
  return new ConstraintMoney(amount,predicate);
}","/** 
 * Access an   {@link ConstraintMoney} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return
 */
private static ConstraintMoney of(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount> predicate){
  return new ConstraintMoney(amount,predicate);
}",0.9736842105263158
56660,"@Override public MonetaryAmount divide(double amount){
  return null;
}","@Override public ConstraintMoney divide(double divisor){
  return new ConstraintMoney(amount.divide(divisor),predicate);
}",0.5699481865284974
56661,"@Override public MonetaryAmount multiply(double multiplicand){
  return null;
}","@Override public ConstraintMoney multiply(double multiplicand){
  return new ConstraintMoney(amount.multiply(multiplicand),predicate);
}",0.6511627906976745
56662,"@Override public MonetaryAmount add(MonetaryAmount amount){
  return null;
}","public ConstraintMoney add(MonetaryAmount<?> augend){
  return of(this.amount.add(augend),predicate);
}",0.5810055865921788
56663,"@Override public boolean isLessThan(MonetaryAmount amt){
  return false;
}","public boolean isLessThan(MonetaryAmount<?> amount){
  return this.amount.isLessThan(amount);
}",0.7337278106508875
56664,"/** 
 * Creates a new wrapper instance.
 * @param amount the underlying amount, not null and not negative.
 * @throws IllegalArgumentException if the amount passed is negative.
 */
ConstraintMoney(Money amount,MonetaryPredicate<MonetaryAmount> predicate){
  if (amount == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (predicate == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!predicate.test(amount)) {
    throw new IllegalArgumentException(""String_Node_Str"" + predicate + ""String_Node_Str""+ amount);
  }
  this.amount=amount;
  this.predicate=predicate;
}","/** 
 * Creates a new wrapper instance.
 * @param amount the underlying amount, not null and not negative.
 * @throws IllegalArgumentException if the amount passed is negative.
 */
ConstraintMoney(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount> predicate){
  if (amount == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (predicate == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!predicate.test(amount)) {
    throw new IllegalArgumentException(""String_Node_Str"" + predicate + ""String_Node_Str""+ amount);
  }
  this.amount=amount;
  this.predicate=predicate;
}",0.9904153354632588
56665,"@Override public Number getNumberExact(Class type){
  return null;
}","@Override public <N extends Number>N getNumberExact(Class<N> type){
  return this.amount.getNumberExact(type);
}",0.7333333333333333
56666,"@Override public MonetaryAmount subtract(MonetaryAmount amount){
  return null;
}","@Override public ConstraintMoney subtract(MonetaryAmount<?> amount){
  return new ConstraintMoney(amount.subtract(amount),predicate);
}",0.6481481481481481
56667,"@Override public <R>R query(MonetaryQuery<R> query){
  return null;
}","@Override public <R>R query(MonetaryQuery<R> query){
  return query.queryFrom(this);
}",0.8516129032258064
56668,"public boolean isGreaterThan(MonetaryAmount amount){
  return this.amount.isGreaterThan(amount);
}","public boolean isGreaterThan(MonetaryAmount<?> amount){
  return this.amount.isGreaterThan(amount);
}",0.984924623115578
56669,"@Override public MonetaryAmount divideToIntegralValue(double divisor){
  return null;
}","@Override public ConstraintMoney divideToIntegralValue(double divisor){
  return new ConstraintMoney(amount.divideToIntegralValue(divisor),predicate);
}",0.6527196652719666
56670,"@Override public MonetaryAmount with(CurrencyUnit unit,double amount){
  return null;
}","@Override public ConstraintMoney with(CurrencyUnit unit,double amount){
  return new ConstraintMoney(amount.with(unit,amount),predicate);
}",0.672566371681416
56671,"@Override public boolean isLessThanOrEqualTo(MonetaryAmount amt){
  return false;
}","public boolean isLessThanOrEqualTo(MonetaryAmount<?> amount){
  return this.amount.isLessThanOrEqualTo(amount);
}",0.7142857142857143
56672,"@Override public MonetaryAmount[] divideAndRemainder(double amount){
  return null;
}","@Override public ConstraintMoney[] divideAndRemainder(double divisor){
  return new ConstraintMoney(amount.divideAndRemainder(divisor),predicate);
}",0.592274678111588
56673,"@Override public MonetaryAmount stripTrailingZeros(){
  return null;
}","@Override public ConstraintMoney stripTrailingZeros(){
  return new ConstraintMoney(amount.stripTrailingZeros(),predicate);
}",0.6153846153846154
56674,"@Override public MonetaryAmount remainder(double amount){
  return null;
}","@Override public ConstraintMoney remainder(double divisor){
  return new ConstraintMoney(amount.remainder(divisor),predicate);
}",0.5742574257425742
56675,"public boolean isEqualTo(MonetaryAmount amount){
  return this.amount.isEqualTo(amount);
}","public boolean isEqualTo(MonetaryAmount<?> amount){
  return this.amount.isEqualTo(amount);
}",0.9836065573770492
56676,"@Override public FlavoredMonetaryAmount with(MonetaryOperator operator){
  return with(operator,UNKNOWN);
}","@Override public FlavoredMonetaryAmount with(CurrencyUnit unit,Number amount){
  return new FlavoredMonetaryAmount(this.baseAmount.with(unit,amount),null);
}",0.5681818181818182
56677,"/** 
 * Get the underlying   {@link String}.
 * @return the flavor of this amount, never {@code null}.
 */
public String getAmountFlavor(){
  return this.amountType;
}","/** 
 * Get the underlying   {@link String}.
 * @return the flavor of this amount, never {@code null}.
 */
public String getAmountFlavor(){
  if (this.amountType == null) {
    return UNKNOWN;
  }
  return this.amountType;
}",0.8132992327365729
56678,"/** 
 * Get the underlying base   {@link MonetaryAmount}, which is never an instance of   {@link FlavoredMonetaryAmount}.
 * @return the base amount, never {@code null}.
 */
public MonetaryAmount getBaseAmount(){
  return this.baseAmount;
}","/** 
 * Get the underlying base   {@link MonetaryAmount}, which is never an instance of   {@link FlavoredMonetaryAmount}.
 * @return the base amount, never {@code null}.
 */
public MonetaryAmount<?> getBaseAmount(){
  return this.baseAmount;
}",0.9937888198757764
56679,"public FlavoredMonetaryAmount(MonetaryAmount baseAmount,String amountType){
  if (baseAmount == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (amountType == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.baseAmount=baseAmount;
  this.amountType=amountType;
}","public FlavoredMonetaryAmount(MonetaryAmount<?> baseAmount,String amountType){
  Objects.requireNonNull(baseAmount,""String_Node_Str"");
  this.baseAmount=baseAmount;
  if (amountType != null) {
    this.amountType=amountType;
  }
}",0.4153005464480874
56680,"/** 
 * Creates an unsigned   {@link MonetaryAmount} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return an ansigned instance, that can never be negative.
 */
public static MonetaryAmount unsignedAmount(MonetaryAmount amount){
  return new ConstraintMoney(Money.from(amount),UNSIGED_PREDICATE);
}","/** 
 * Creates an unsigned   {@link MonetaryAmount} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return an ansigned instance, that can never be negative.
 */
public static MonetaryAmount<?> unsignedAmount(MonetaryAmount<?> amount){
  return new ConstraintMoney(amount,UNSIGNED_PREDICATE);
}",0.9502407704654896
56681,"/** 
 * Creates an predicated   {@link MonetaryAmount} based on the given{@link MonetaryAmount}.
 * @param amount The amount to decorated.
 * @return a predicated instance, that ensures the given predicate is alwaysensured on all operations.
 */
public static MonetaryAmount constraintAmount(MonetaryAmount amount,MonetaryPredicate<MonetaryAmount> predicate){
  return new ConstraintMoney(Money.from(amount),predicate);
}","/** 
 * Creates an predicated   {@link MonetaryAmount} based on the given{@link MonetaryAmount}.
 * @param amount The amount to decorated.
 * @return a predicated instance, that ensures the given predicate is alwaysensured on all operations.
 */
public static MonetaryAmount<?> constraintAmount(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount<?>> predicate){
  return new ConstraintMoney(amount,predicate);
}",0.9606674612634089
56682,"/** 
 * Access an   {@link ConstraintMoney} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return
 */
private static ConstraintMoney of(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount> predicate){
  return new ConstraintMoney(amount,predicate);
}","/** 
 * Access an   {@link ConstraintMoney} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return
 */
private static ConstraintMoney of(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount<?>> predicate){
  return new ConstraintMoney(amount,predicate);
}",0.9945155393053016
56683,"/** 
 * Creates a new wrapper instance.
 * @param amount the underlying amount, not null and not negative.
 * @throws IllegalArgumentException if the amount passed is negative.
 */
ConstraintMoney(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount> predicate){
  if (amount == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (predicate == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!predicate.test(amount)) {
    throw new IllegalArgumentException(""String_Node_Str"" + predicate + ""String_Node_Str""+ amount);
  }
  this.amount=amount;
  this.predicate=predicate;
}","/** 
 * Creates a new wrapper instance.
 * @param amount the underlying amount, not null and not negative.
 * @throws IllegalArgumentException if the amount passed is negative.
 */
ConstraintMoney(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount<?>> predicate){
  if (amount == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (predicate == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!predicate.test(amount)) {
    throw new IllegalArgumentException(""String_Node_Str"" + predicate + ""String_Node_Str""+ amount);
  }
  this.amount=amount;
  this.predicate=predicate;
}",0.9976322020520916
56684,"@Override public ConstraintMoney subtract(MonetaryAmount<?> amount){
  return new ConstraintMoney(amount.subtract(amount),predicate);
}","@Override public ConstraintMoney subtract(MonetaryAmount<?> amount){
  return new ConstraintMoney(this.amount.subtract(amount),predicate);
}",0.9818181818181818
56685,"@Override public ConstraintMoney with(CurrencyUnit unit,double amount){
  return new ConstraintMoney(amount.with(unit,amount),predicate);
}","@Override public ConstraintMoney with(CurrencyUnit unit,double amount){
  return new ConstraintMoney(this.amount.with(unit,amount),predicate);
}",0.9823321554770318
56686,"@Override public ConstraintMoney[] divideAndRemainder(double divisor){
  return new ConstraintMoney(amount.divideAndRemainder(divisor),predicate);
}","@SuppressWarnings(""String_Node_Str"") @Override public ConstraintMoney[] divideAndRemainder(double divisor){
  MonetaryAmount<?>[] result=this.amount.divideAndRemainder(divisor);
  return new ConstraintMoney[]{new ConstraintMoney(result[0],predicate),new ConstraintMoney(result[1],predicate)};
}",0.5113122171945701
56687,"/** 
 * Creates an unsigned   {@link MonetaryAmount} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return an ansigned instance, that can never be negative.
 */
public static MonetaryAmount unsignedAmount(MonetaryAmount amount){
  return new ConstraintMoney(Money.from(amount),UNSIGED_PREDICATE);
}","/** 
 * Creates an unsigned   {@link MonetaryAmount} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return an ansigned instance, that can never be negative.
 */
public static MonetaryAmount<?> unsignedAmount(MonetaryAmount<?> amount){
  return new ConstraintMoney(amount,UNSIGNED_PREDICATE);
}",0.9502407704654896
56688,"/** 
 * Creates an predicated   {@link MonetaryAmount} based on the given{@link MonetaryAmount}.
 * @param amount The amount to decorated.
 * @return a predicated instance, that ensures the given predicate is alwaysensured on all operations.
 */
public static MonetaryAmount constraintAmount(MonetaryAmount amount,MonetaryPredicate<MonetaryAmount> predicate){
  return new ConstraintMoney(Money.from(amount),predicate);
}","/** 
 * Creates an predicated   {@link MonetaryAmount} based on the given{@link MonetaryAmount}.
 * @param amount The amount to decorated.
 * @return a predicated instance, that ensures the given predicate is alwaysensured on all operations.
 */
public static MonetaryAmount<?> constraintAmount(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount<?>> predicate){
  return new ConstraintMoney(amount,predicate);
}",0.9606674612634089
56689,"/** 
 * Access an   {@link ConstraintMoney} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return
 */
private static ConstraintMoney of(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount> predicate){
  return new ConstraintMoney(amount,predicate);
}","/** 
 * Access an   {@link ConstraintMoney} based on the given{@link MonetaryAmount}.
 * @param amount
 * @return
 */
private static ConstraintMoney of(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount<?>> predicate){
  return new ConstraintMoney(amount,predicate);
}",0.9945155393053016
56690,"/** 
 * Creates a new wrapper instance.
 * @param amount the underlying amount, not null and not negative.
 * @throws IllegalArgumentException if the amount passed is negative.
 */
ConstraintMoney(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount> predicate){
  if (amount == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (predicate == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!predicate.test(amount)) {
    throw new IllegalArgumentException(""String_Node_Str"" + predicate + ""String_Node_Str""+ amount);
  }
  this.amount=amount;
  this.predicate=predicate;
}","/** 
 * Creates a new wrapper instance.
 * @param amount the underlying amount, not null and not negative.
 * @throws IllegalArgumentException if the amount passed is negative.
 */
ConstraintMoney(MonetaryAmount<?> amount,MonetaryPredicate<MonetaryAmount<?>> predicate){
  if (amount == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (predicate == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!predicate.test(amount)) {
    throw new IllegalArgumentException(""String_Node_Str"" + predicate + ""String_Node_Str""+ amount);
  }
  this.amount=amount;
  this.predicate=predicate;
}",0.9976322020520916
56691,"@Override public ConstraintMoney subtract(MonetaryAmount<?> amount){
  return new ConstraintMoney(amount.subtract(amount),predicate);
}","@Override public ConstraintMoney subtract(MonetaryAmount<?> amount){
  return new ConstraintMoney(this.amount.subtract(amount),predicate);
}",0.9818181818181818
56692,"@Override public ConstraintMoney with(CurrencyUnit unit,double amount){
  return new ConstraintMoney(amount.with(unit,amount),predicate);
}","@Override public ConstraintMoney with(CurrencyUnit unit,double amount){
  return new ConstraintMoney(this.amount.with(unit,amount),predicate);
}",0.9823321554770318
56693,"@Override public ConstraintMoney[] divideAndRemainder(double divisor){
  return new ConstraintMoney(amount.divideAndRemainder(divisor),predicate);
}","@SuppressWarnings(""String_Node_Str"") @Override public ConstraintMoney[] divideAndRemainder(double divisor){
  MonetaryAmount<?>[] result=this.amount.divideAndRemainder(divisor);
  return new ConstraintMoney[]{new ConstraintMoney(result[0],predicate),new ConstraintMoney(result[1],predicate)};
}",0.5113122171945701
56694,"private TablePerspective createTablePerspective(ATableBasedDataDomain dd,Perspective ownDimensionPerspective,Perspective foreignRecordPerspective){
  if (dd == null || ownDimensionPerspective == null || foreignRecordPerspective == null)   return null;
  Perspective convertedPerspective=dd.convertForeignPerspective(foreignRecordPerspective);
  TablePerspective tablePerspective=new TablePerspective(dd,convertedPerspective,ownDimensionPerspective);
  tablePerspective.setLabel(dd.getLabel() + ""String_Node_Str"" + foreignRecordPerspective.getLabel());
  return tablePerspective;
}","private TablePerspective createTablePerspective(ATableBasedDataDomain dd,Perspective ownPerspective,Perspective foreignPerspective){
  if (dd == null || ownPerspective == null || foreignPerspective == null)   return null;
  Perspective convertedPerspective=dd.convertForeignPerspective(foreignPerspective);
  Perspective recordPerspective=dd.getRecordIDCategory().equals(convertedPerspective.getIdType().getIDCategory()) ? convertedPerspective : ownPerspective;
  Perspective dimensionPerspective=dd.getDimensionIDCategory().equals(convertedPerspective.getIdType().getIDCategory()) ? convertedPerspective : ownPerspective;
  TablePerspective tablePerspective=new TablePerspective(dd,recordPerspective,dimensionPerspective);
  tablePerspective.setLabel(dd.getLabel() + ""String_Node_Str"" + foreignPerspective.getLabel());
  return tablePerspective;
}",0.6120448179271709
56695,"@Override public void pageChanged(PageChangedEvent event){
  if (event.getSelectedPage() == this) {
    FishersExactTestWizard wizard=(FishersExactTestWizard)getWizard();
    DataCellInfo info1=wizard.getInfo1();
    DataCellInfo info2=wizard.getInfo2();
    IDataClassifier classifier1=wizard.getCell1Classifier();
    IDataClassifier classifier2=wizard.getCell2Classifier();
    IDMappingManager mappingManager=IDMappingManagerRegistry.get().getIDMappingManager(info1.columnPerspective.getIdType());
    IIDTypeMapper<Object,Object> mapper=mappingManager.getIDTypeMapper(info1.columnPerspective.getIdType(),info2.columnPerspective.getIdType());
    contingencyTable=new int[2][2];
    for (    int cell1ColumnID : info1.columnPerspective.getVirtualArray()) {
      int index1=getContingencyIndex(info1.dataDomain,info1.columnPerspective.getIdType(),cell1ColumnID,info1.rowIDType,info1.rowID,classifier1);
      if (index1 == -1)       continue;
      Set<Object> cell2ColumnIDs=mapper.apply(cell1ColumnID);
      if (cell2ColumnIDs != null && !cell2ColumnIDs.isEmpty()) {
        Integer cell2ColumnID=(Integer)cell2ColumnIDs.iterator().next();
        if (info2.columnPerspective.getVirtualArray().contains(cell2ColumnID)) {
          int index2=getContingencyIndex(info2.dataDomain,info2.columnPerspective.getIdType(),cell2ColumnID,info2.rowIDType,info2.rowID,classifier2);
          if (index2 == -1)           continue;
          contingencyTable[index1][index2]++;
        }
      }
    }
    double[] result=FishersExactTest.fishersExactTest(contingencyTable[0][0],contingencyTable[0][1],contingencyTable[1][0],contingencyTable[1][1]);
    twoSidedPValueLabel.setText(String.format(Locale.ENGLISH,""String_Node_Str"",result[0],result[0]));
    leftTailPValueLabel.setText(String.format(Locale.ENGLISH,""String_Node_Str"",result[1]));
    rightTailPValueLabel.setText(String.format(Locale.ENGLISH,""String_Node_Str"",result[2]));
    visited=true;
    columnHeaderProvider.setClassifier(classifier1);
    rowHeaderProvider.setClassifier(classifier2);
    buildTable(contingencyTableGroup);
    table.refresh();
    getShell().layout(true,true);
    getShell().pack();
    getWizard().getContainer().updateButtons();
  }
}","@Override public void pageChanged(PageChangedEvent event){
  if (event.getSelectedPage() == this) {
    FishersExactTestWizard wizard=(FishersExactTestWizard)getWizard();
    DataCellInfo info1=wizard.getInfo1();
    DataCellInfo info2=wizard.getInfo2();
    IDataClassifier classifier1=wizard.getCell1Classifier();
    IDataClassifier classifier2=wizard.getCell2Classifier();
    IDMappingManager mappingManager=IDMappingManagerRegistry.get().getIDMappingManager(info1.columnPerspective.getIdType());
    IIDTypeMapper<Object,Object> mapper=mappingManager.getIDTypeMapper(info1.columnPerspective.getIdType(),info2.columnPerspective.getIdType());
    contingencyTable=new int[2][2];
    for (    int cell1ColumnID : info1.columnPerspective.getVirtualArray()) {
      int index1=getContingencyIndex(info1.dataDomain,info1.columnPerspective.getIdType(),cell1ColumnID,info1.rowIDType,info1.rowID,classifier1);
      if (index1 == -1)       continue;
      Set<Object> cell2ColumnIDs=mapper.apply(cell1ColumnID);
      if (cell2ColumnIDs != null && !cell2ColumnIDs.isEmpty()) {
        Integer cell2ColumnID=(Integer)cell2ColumnIDs.iterator().next();
        if (info2.columnPerspective.getVirtualArray().contains(cell2ColumnID)) {
          int index2=getContingencyIndex(info2.dataDomain,info2.columnPerspective.getIdType(),cell2ColumnID,info2.rowIDType,info2.rowID,classifier2);
          if (index2 == -1)           continue;
          contingencyTable[index1][index2]++;
        }
      }
    }
    result=FishersExactTest.fishersExactTest(contingencyTable[0][0],contingencyTable[0][1],contingencyTable[1][0],contingencyTable[1][1]);
    twoSidedPValueLabel.setText(String.format(Locale.ENGLISH,""String_Node_Str"",result[0]));
    leftTailPValueLabel.setText(String.format(Locale.ENGLISH,""String_Node_Str"",result[1]));
    rightTailPValueLabel.setText(String.format(Locale.ENGLISH,""String_Node_Str"",result[2]));
    visited=true;
    columnHeaderProvider.setClassifier(classifier1);
    rowHeaderProvider.setClassifier(classifier2);
    buildTable(contingencyTableGroup);
    table.refresh();
    getShell().layout(true,true);
    getShell().pack();
    getWizard().getContainer().updateButtons();
  }
}",0.9957062146892656
56696,"private int getContingencyIndex(ATableBasedDataDomain dataDomain,IDType columnIDType,int columnID,IDType rowIDType,int rowID,IDataClassifier classifier){
  Object value=dataDomain.getRaw(columnIDType,columnID,rowIDType,rowID);
  List<SimpleCategory> classes=classifier.getDataClasses();
  SimpleCategory c=classifier.apply(value);
  if (c == null)   return -1;
  return classes.indexOf(c);
}","private int getContingencyIndex(ATableBasedDataDomain dataDomain,IDType columnIDType,int columnID,IDType rowIDType,int rowID,IDataClassifier classifier){
  List<SimpleCategory> classes=classifier.getDataClasses();
  SimpleCategory c=getCategory(dataDomain,columnIDType,columnID,rowIDType,rowID,classifier);
  if (c == null)   return -1;
  return classes.indexOf(c);
}",0.7810026385224275
56697,"@Override public void createControl(Composite parent){
  parentComposite=new Composite(parent,SWT.NONE);
  parentComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  parentComposite.setLayout(new GridLayout(1,false));
  contingencyTableGroup=new Group(parentComposite,SWT.SHADOW_ETCHED_IN);
  contingencyTableGroup.setText(""String_Node_Str"");
  contingencyTableGroup.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  contingencyTableGroup.setLayout(new GridLayout(1,false));
  buildTable(contingencyTableGroup);
  Group pValuesGroup=new Group(parentComposite,SWT.SHADOW_ETCHED_IN);
  pValuesGroup.setText(""String_Node_Str"");
  pValuesGroup.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  pValuesGroup.setLayout(new GridLayout(1,false));
  twoSidedPValueLabel=createLabel(pValuesGroup,""String_Node_Str"");
  leftTailPValueLabel=createLabel(pValuesGroup,""String_Node_Str"");
  rightTailPValueLabel=createLabel(pValuesGroup,""String_Node_Str"");
  setControl(parentComposite);
}","@Override public void createControl(Composite parent){
  parentComposite=new Composite(parent,SWT.NONE);
  parentComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  parentComposite.setLayout(new GridLayout(1,false));
  contingencyTableGroup=new Group(parentComposite,SWT.SHADOW_ETCHED_IN);
  contingencyTableGroup.setText(""String_Node_Str"");
  contingencyTableGroup.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  contingencyTableGroup.setLayout(new GridLayout(1,false));
  buildTable(contingencyTableGroup);
  Group pValuesGroup=new Group(parentComposite,SWT.SHADOW_ETCHED_IN);
  pValuesGroup.setText(""String_Node_Str"");
  pValuesGroup.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  pValuesGroup.setLayout(new GridLayout(1,false));
  twoSidedPValueLabel=createLabel(pValuesGroup,""String_Node_Str"");
  leftTailPValueLabel=createLabel(pValuesGroup,""String_Node_Str"");
  rightTailPValueLabel=createLabel(pValuesGroup,""String_Node_Str"");
  Button exportButton=new Button(pValuesGroup,SWT.PUSH);
  exportButton.setText(""String_Node_Str"");
  exportButton.setLayoutData(new GridData());
  exportButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      FileDialog fileDialog=new FileDialog(new Shell(),SWT.SAVE);
      fileDialog.setText(""String_Node_Str"");
      String[] filterExt={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      fileDialog.setFilterExtensions(filterExt);
      fileDialog.setFileName(""String_Node_Str"" + new SimpleDateFormat(""String_Node_Str"").format(new Date()) + ""String_Node_Str"");
      String fileName=fileDialog.open();
      if (fileName != null) {
        exportResults(fileName);
      }
    }
  }
);
  setControl(parentComposite);
}",0.7247936849659131
56698,"/** 
 * @param parent
 * @param style
 * @param categoryColors Colors used for categories. Must contain at least 2 colors.
 */
public NumericalClassificationWidget(Composite parent,int style,List<Color> categoryColors){
  super(parent,style,categoryColors);
  classifier=new NumericalDataClassifier(0,categoryColors.get(0),categoryColors.get(1),Character.toString((char)0x2264) + ""String_Node_Str"" + 0,""String_Node_Str"" + 0);
  GridLayout layout=new GridLayout(2,false);
  setLayout(layout);
  setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  categoryComposite=new Composite(this,SWT.NONE);
  categoryComposite.setLayout(new GridLayout(2,false));
  categoryComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  classLabels=new ArrayList<>(classifier.getDataClasses().size());
  for (  SimpleCategory category : classifier.getDataClasses()) {
    CLabel preview=new CLabel(categoryComposite,SWT.BORDER);
    GridData gridData=new GridData(SWT.LEFT,SWT.TOP,false,false);
    gridData.widthHint=25;
    gridData.heightHint=25;
    preview.setLayoutData(gridData);
    org.eclipse.swt.graphics.Color c=category.color.getSWTColor(Display.getCurrent());
    preview.setBackground(c);
    preview.update();
    colorRegistry.add(c);
    Text l=new Text(categoryComposite,SWT.BORDER);
    gridData=new GridData(SWT.FILL,SWT.TOP,true,false);
    gridData.widthHint=220;
    l.setLayoutData(gridData);
    l.setText(category.name);
    l.setEditable(false);
    l.addModifyListener(new ModifyListener(){
      @Override public void modifyText(      ModifyEvent e){
        if (useCustomCategoryNamesButton.getSelection()) {
          updateClassifier();
        }
      }
    }
);
    classLabels.add(l);
  }
  useCustomCategoryNamesButton=new Button(categoryComposite,SWT.CHECK);
  useCustomCategoryNamesButton.setText(""String_Node_Str"");
  useCustomCategoryNamesButton.setLayoutData(new GridData(SWT.LEFT,SWT.TOP,false,false,2,1));
  useCustomCategoryNamesButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      for (      Text t : classLabels) {
        t.setEditable(useCustomCategoryNamesButton.getSelection());
      }
    }
  }
);
  Composite scaleComposite=new Composite(this,SWT.NONE);
  GridLayout gl=new GridLayout(1,false);
  gl.marginHeight=0;
  gl.marginWidth=0;
  scaleComposite.setLayout(gl);
  scaleComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  maxLabel=new Label(scaleComposite,SWT.NONE);
  maxLabel.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  maxLabel.setText(""String_Node_Str"");
  thresholdScale=new Scale(scaleComposite,SWT.VERTICAL);
  GridData gd=new GridData(SWT.CENTER,SWT.FILL,false,true);
  gd.heightHint=120;
  thresholdScale.setLayoutData(gd);
  thresholdScale.setMinimum(THRESHOLD_SCALE_MIN);
  thresholdScale.setMaximum(THRESHOLD_SCALE_MAX);
  thresholdScale.setPageIncrement(10);
  thresholdScale.setOrientation(SWT.RIGHT_TO_LEFT);
  thresholdScale.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      float value=(float)mappingFunction.apply(thresholdScale.getMaximum() - thresholdScale.getSelection() + thresholdScale.getMinimum());
      thresholdText.setText(""String_Node_Str"" + value);
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  minLabel=new Label(scaleComposite,SWT.NONE);
  minLabel.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  minLabel.setText(""String_Node_Str"");
  Label thresholdLabel=new Label(this,SWT.NONE);
  thresholdLabel.setLayoutData(new GridData(SWT.RIGHT,SWT.TOP,true,false));
  thresholdLabel.setText(""String_Node_Str"");
  thresholdText=new Text(this,SWT.BORDER);
  thresholdText.setText(""String_Node_Str"");
  gd=new GridData(SWT.FILL,SWT.TOP,true,false);
  gd.widthHint=100;
  thresholdText.setLayoutData(gd);
  thresholdText.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent e){
      updateClassifier();
    }
  }
);
}","/** 
 * @param parent
 * @param style
 * @param categoryColors Colors used for categories. Must contain at least 2 colors.
 */
public NumericalClassificationWidget(Composite parent,int style,List<Color> categoryColors){
  super(parent,style,categoryColors);
  classifier=new NumericalDataClassifier(0,categoryColors.get(0),categoryColors.get(1),Character.toString((char)0x2264) + ""String_Node_Str"" + 0,""String_Node_Str"" + 0);
  GridLayout layout=new GridLayout(2,false);
  setLayout(layout);
  setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  Label descLabel=new Label(this,SWT.NONE);
  descLabel.setText(""String_Node_Str"");
  descLabel.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true,2,1));
  categoryComposite=new Composite(this,SWT.NONE);
  categoryComposite.setLayout(new GridLayout(2,false));
  categoryComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  classLabels=new ArrayList<>(classifier.getDataClasses().size());
  for (  SimpleCategory category : classifier.getDataClasses()) {
    CLabel preview=new CLabel(categoryComposite,SWT.BORDER);
    GridData gridData=new GridData(SWT.LEFT,SWT.TOP,false,false);
    gridData.widthHint=25;
    gridData.heightHint=25;
    preview.setLayoutData(gridData);
    org.eclipse.swt.graphics.Color c=category.color.getSWTColor(Display.getCurrent());
    preview.setBackground(c);
    preview.update();
    colorRegistry.add(c);
    Text l=new Text(categoryComposite,SWT.BORDER);
    gridData=new GridData(SWT.FILL,SWT.TOP,true,false);
    gridData.widthHint=220;
    l.setLayoutData(gridData);
    l.setText(category.name);
    l.setEditable(false);
    l.addModifyListener(new ModifyListener(){
      @Override public void modifyText(      ModifyEvent e){
        if (useCustomCategoryNamesButton.getSelection()) {
          updateClassifier();
        }
      }
    }
);
    classLabels.add(l);
  }
  useCustomCategoryNamesButton=new Button(categoryComposite,SWT.CHECK);
  useCustomCategoryNamesButton.setText(""String_Node_Str"");
  useCustomCategoryNamesButton.setLayoutData(new GridData(SWT.LEFT,SWT.TOP,false,false,2,1));
  useCustomCategoryNamesButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      for (      Text t : classLabels) {
        t.setEditable(useCustomCategoryNamesButton.getSelection());
      }
    }
  }
);
  Composite scaleComposite=new Composite(this,SWT.NONE);
  GridLayout gl=new GridLayout(1,false);
  gl.marginHeight=0;
  gl.marginWidth=0;
  scaleComposite.setLayout(gl);
  scaleComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  maxLabel=new Label(scaleComposite,SWT.NONE);
  maxLabel.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  maxLabel.setText(""String_Node_Str"");
  thresholdScale=new Scale(scaleComposite,SWT.VERTICAL);
  GridData gd=new GridData(SWT.CENTER,SWT.FILL,false,true);
  gd.heightHint=120;
  thresholdScale.setLayoutData(gd);
  thresholdScale.setMinimum(THRESHOLD_SCALE_MIN);
  thresholdScale.setMaximum(THRESHOLD_SCALE_MAX);
  thresholdScale.setPageIncrement(10);
  thresholdScale.setOrientation(SWT.RIGHT_TO_LEFT);
  thresholdScale.addSelectionListener(new SelectionListener(){
    @Override public void widgetSelected(    SelectionEvent e){
      float value=(float)mappingFunction.apply(thresholdScale.getMaximum() - thresholdScale.getSelection() + thresholdScale.getMinimum());
      thresholdText.setText(""String_Node_Str"" + value);
    }
    @Override public void widgetDefaultSelected(    SelectionEvent e){
    }
  }
);
  minLabel=new Label(scaleComposite,SWT.NONE);
  minLabel.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  minLabel.setText(""String_Node_Str"");
  Label thresholdLabel=new Label(this,SWT.NONE);
  thresholdLabel.setLayoutData(new GridData(SWT.RIGHT,SWT.TOP,true,false));
  thresholdLabel.setText(""String_Node_Str"");
  thresholdText=new Text(this,SWT.BORDER);
  thresholdText.setText(""String_Node_Str"");
  gd=new GridData(SWT.FILL,SWT.TOP,true,false);
  gd.widthHint=100;
  thresholdText.setLayoutData(gd);
  thresholdText.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent e){
      updateClassifier();
    }
  }
);
}",0.9809454896285577
56699,"@Override public void pageChanged(PageChangedEvent event){
  if (event.getSelectedPage() == getNextPage()) {
    WilcoxonRankSumTestWizard wizard=(WilcoxonRankSumTestWizard)getWizard();
    wizard.setSourceInfo(info);
    IDataClassifier classifier=classificationWidget.getClassifier();
    wizard.setSourceClassifier(classifier);
    wizard.setDerivedIDClassifier(WilcoxonUtil.createDerivedClassifier(classifier,info));
  }
 else   if (event.getSelectedPage() == this) {
    UpdateDataCellSelectionValidatorEvent e=new UpdateDataCellSelectionValidatorEvent(CellSelectionValidators.nonEmptyCellValidator());
    EventPublisher.trigger(e);
  }
}","@Override public void pageChanged(PageChangedEvent event){
  if (event.getSelectedPage() == getNextPage()) {
    WilcoxonRankSumTestWizard wizard=(WilcoxonRankSumTestWizard)getWizard();
    wizard.setSourceInfo(info);
    IDataClassifier classifier=classificationWidget.getClassifier();
    wizard.setSourceClassifier(classifier);
  }
 else   if (event.getSelectedPage() == this) {
    UpdateDataCellSelectionValidatorEvent e=new UpdateDataCellSelectionValidatorEvent(CellSelectionValidators.nonEmptyCellValidator());
    EventPublisher.trigger(e);
  }
}",0.9248747913188649
56700,"@Override public void pageChanged(PageChangedEvent event){
  WilcoxonRankSumTestWizard wizard=(WilcoxonRankSumTestWizard)getWizard();
  if (event.getSelectedPage() == this) {
    if (info != null) {
      if (!CellSelectionValidators.overlappingSamplesValidator(wizard.getSourceInfo()).apply(info)) {
        info=null;
        classificationGroup.setVisible(false);
        dataCellInfoWidget.updateInfo(null);
        getWizard().getContainer().updateButtons();
        EventPublisher.trigger(new ShowOverlayEvent(null,null,getWizard().getStartingPage() == this));
      }
    }
    @SuppressWarnings(""String_Node_Str"") Predicate<DataCellInfo> validator=Predicates.and(CellSelectionValidators.nonEmptyCellValidator(),CellSelectionValidators.numericalValuesValidator(),CellSelectionValidators.overlappingSamplesValidator(wizard.getSourceInfo()));
    EventPublisher.trigger(new UpdateDataCellSelectionValidatorEvent(validator));
    if (classificationWidget != null) {
      classificationWidget.setClassifier(wizard.getDerivedIDClassifier());
      EventPublisher.trigger(new ShowOverlayEvent(info,classificationWidget.getClassifier().getOverlayProvider(),false));
    }
  }
 else   if (event.getSelectedPage() == getNextPage()) {
    wizard.setTargetInfo(info);
  }
}","@Override public void pageChanged(PageChangedEvent event){
  WilcoxonRankSumTestWizard wizard=(WilcoxonRankSumTestWizard)getWizard();
  if (event.getSelectedPage() == this) {
    if (info != null) {
      if (!CellSelectionValidators.overlappingSamplesValidator(wizard.getSourceInfo()).apply(info)) {
        info=null;
        classificationGroup.setVisible(false);
        dataCellInfoWidget.updateInfo(null);
        getWizard().getContainer().updateButtons();
        EventPublisher.trigger(new ShowOverlayEvent(null,null,getWizard().getStartingPage() == this));
      }
    }
    @SuppressWarnings(""String_Node_Str"") Predicate<DataCellInfo> validator=Predicates.and(CellSelectionValidators.nonEmptyCellValidator(),CellSelectionValidators.numericalValuesValidator(),CellSelectionValidators.overlappingSamplesValidator(wizard.getSourceInfo()));
    EventPublisher.trigger(new UpdateDataCellSelectionValidatorEvent(validator));
    if (classificationWidget != null && info != null) {
      SimpleIDClassifier derivedClassifier=WilcoxonUtil.createDerivedClassifier(wizard.getSourceClassifier(),wizard.getSourceInfo(),info);
      wizard.setDerivedIDClassifier(derivedClassifier);
      classificationWidget.setClassifier(derivedClassifier);
      EventPublisher.trigger(new ShowOverlayEvent(info,derivedClassifier.getOverlayProvider(),false));
    }
  }
 else   if (event.getSelectedPage() == getNextPage()) {
    wizard.setTargetInfo(info);
  }
}",0.8682855040470935
56701,"@Override protected void dataCellChanged(DataCellInfo info){
  Object description=info.dataDomain.getDataClassSpecificDescription(info.rowIDType,info.rowID,info.columnPerspective.getIdType(),info.columnPerspective.getVirtualArray().get(0));
  if (description != null && description instanceof CategoricalClassDescription) {
    CategoricalClassDescription<?> desc=(CategoricalClassDescription<?>)description;
    if (desc.getCategoryType() == ECategoryType.NOMINAL) {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
  classificationGroup.setVisible(true);
  if (classificationWidget == null) {
    classificationWidget=new DerivedClassificationWidget(classificationGroup);
    classificationGroup.getShell().layout(true,true);
    classificationGroup.getShell().pack(true);
    getWizard().getContainer().updateButtons();
    WilcoxonRankSumTestWizard wizard=(WilcoxonRankSumTestWizard)getWizard();
    classificationWidget.setClassifier(wizard.getDerivedIDClassifier());
  }
  EventPublisher.trigger(new ShowOverlayEvent(info,classificationWidget.getClassifier().getOverlayProvider(),false));
  getWizard().getContainer().updateButtons();
}","@Override protected void dataCellChanged(DataCellInfo info){
  Object description=info.dataDomain.getDataClassSpecificDescription(info.rowIDType,info.rowID,info.columnPerspective.getIdType(),info.columnPerspective.getVirtualArray().get(0));
  if (description != null && description instanceof CategoricalClassDescription) {
    CategoricalClassDescription<?> desc=(CategoricalClassDescription<?>)description;
    if (desc.getCategoryType() == ECategoryType.NOMINAL) {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
  classificationGroup.setVisible(true);
  WilcoxonRankSumTestWizard wizard=(WilcoxonRankSumTestWizard)getWizard();
  SimpleIDClassifier derivedClassifier=WilcoxonUtil.createDerivedClassifier(wizard.getSourceClassifier(),wizard.getSourceInfo(),info);
  wizard.setDerivedIDClassifier(derivedClassifier);
  if (classificationWidget == null) {
    classificationWidget=new DerivedClassificationWidget(classificationGroup);
    classificationGroup.getShell().layout(true,true);
    classificationGroup.getShell().pack(true);
    getWizard().getContainer().updateButtons();
  }
  classificationWidget.setClassifier(wizard.getDerivedIDClassifier());
  EventPublisher.trigger(new ShowOverlayEvent(info,classificationWidget.getClassifier().getOverlayProvider(),false));
  getWizard().getContainer().updateButtons();
}",0.8147560491868306
56702,"public void updateTable(int numberOfHeaderRows,List<RowColDesc> rowDescriptions,List<RowColDesc> columnDescriptions){
  boolean needsReconfiguration=rowDescriptions.size() != this.rowDescriptions.size() || columnDescriptions.size() != this.columnDescriptions.size();
  this.rowDescriptions.clear();
  this.columnDescriptions.clear();
  for (  RowColDesc r : rowDescriptions) {
    this.rowDescriptions.add(new RowColDescInternal(r));
  }
  for (  RowColDesc c : columnDescriptions) {
    this.columnDescriptions.add(new RowColDescInternal(c));
  }
  if (columnSelectionStatus != null && !columnSelectionStatus.isEmpty()) {
    for (    RowColDescInternal desc : this.columnDescriptions) {
      columnSelectionStatus.set(desc.index,true);
    }
  }
  this.numberOfHeaderRows=numberOfHeaderRows;
  if (needsReconfiguration)   table.configure();
  table.refresh();
}","public void updateTable(int numberOfHeaderRows,List<RowColDesc> rowDescriptions,List<RowColDesc> columnDescriptions){
  boolean needsReconfiguration=needsReconfiguration(rowDescriptions,columnDescriptions);
  this.extColumnDescriptions=columnDescriptions;
  this.extRowDescriptions=rowDescriptions;
  this.rowDescriptions.clear();
  this.columnDescriptions.clear();
  for (  RowColDesc r : rowDescriptions) {
    this.rowDescriptions.add(new RowColDescInternal(r));
  }
  for (  RowColDesc c : columnDescriptions) {
    this.columnDescriptions.add(new RowColDescInternal(c));
  }
  if (columnSelectionStatus != null && !columnSelectionStatus.isEmpty()) {
    for (    RowColDescInternal desc : this.columnDescriptions) {
      columnSelectionStatus.set(desc.index,true);
    }
  }
  this.numberOfHeaderRows=numberOfHeaderRows;
  if (needsReconfiguration)   table.configure();
  table.refresh();
}",0.4977272727272727
56703,"private void updateTable(){
  page.previewTable.updateTable(dataSetDescription.getNumberOfHeaderLines(),Lists.newArrayList(new RowColDesc(dataSetDescription.getRowOfColumnIDs(),Color.GREEN,rowIDTypeParsingRules)),Lists.newArrayList(new RowColDesc(dataSetDescription.getColumnOfRowIds(),Color.GREEN,columnIDTypeParsingRules)));
}","private void updateTable(){
  page.previewTable.updateTable(dataSetDescription.getNumberOfHeaderLines(),Lists.newArrayList(new RowColDesc(dataSetDescription.getRowOfColumnIDs(),Color.GREEN,columnIDTypeParsingRules)),Lists.newArrayList(new RowColDesc(dataSetDescription.getColumnOfRowIds(),Color.GREEN,rowIDTypeParsingRules)));
}",0.972560975609756
56704,"protected boolean checkIntegrity(){
  PathwayVertexRep prevVertex=null;
  for (  PathwayVertexRep v : this) {
    if (v == null || pathway != v.getPathway()) {
      return false;
    }
    if (prevVertex != null) {
      DefaultEdge edge1=pathway.getEdge(prevVertex,v);
      DefaultEdge edge2=pathway.getEdge(prevVertex,v);
      if (edge1 == null && edge2 == null)       return false;
    }
    prevVertex=v;
  }
  return true;
}","protected boolean checkIntegrity(){
  PathwayVertexRep prevVertex=null;
  for (  PathwayVertexRep v : this) {
    if (v == null || pathway != v.getPathway()) {
      return false;
    }
    if (prevVertex != null) {
      DefaultEdge edge1=pathway.getEdge(prevVertex,v);
      DefaultEdge edge2=pathway.getEdge(v,prevVertex);
      if (edge1 == null && edge2 == null)       return false;
    }
    prevVertex=v;
  }
  return true;
}",0.9745370370370372
56705,"@Override public boolean checkIntegrity(){
  if (path == null)   return false;
  boolean ok=path.checkIntegrity();
  if (!ok) {
    Logger.log(new Status(IStatus.ERROR,""String_Node_Str"",""String_Node_Str"" + path.toString()));
  }
  return path.checkIntegrity();
}","@Override public boolean checkIntegrity(){
  if (path == null)   return false;
  boolean ok=path.checkIntegrity();
  if (!ok) {
    Logger.log(new Status(IStatus.ERROR,""String_Node_Str"",""String_Node_Str"" + path.toString()));
  }
  return ok;
}",0.9544554455445544
56706,"@Override public void pageChanged(PageChangedEvent event){
  if (event.getSelectedPage() == this) {
    CalculateCorrelationWizard wizard=(CalculateCorrelationWizard)getWizard();
    DataCellInfo info1=wizard.getInfo1();
    DataCellInfo info2=wizard.getInfo2();
    IDataClassifier classifier1=wizard.getCell1Classifier();
    IDataClassifier classifier2=wizard.getCell2Classifier();
    IDMappingManager mappingManager=IDMappingManagerRegistry.get().getIDMappingManager(info1.columnPerspective.getIdType());
    IIDTypeMapper<Object,Object> mapper=mappingManager.getIDTypeMapper(info1.columnPerspective.getIdType(),info2.columnPerspective.getIdType());
    for (    int cell1ColumnID : info1.columnPerspective.getVirtualArray()) {
      int index1=getContingencyIndex(info1.dataDomain,info1.columnPerspective.getIdType(),cell1ColumnID,info1.rowIDType,info1.rowID,classifier1);
      if (index1 == -1)       continue;
      Set<Object> cell2ColumnIDs=mapper.apply(cell1ColumnID);
      if (cell2ColumnIDs != null && !cell2ColumnIDs.isEmpty()) {
        Integer cell2ColumnID=(Integer)cell2ColumnIDs.iterator().next();
        if (info2.columnPerspective.getVirtualArray().contains(cell2ColumnID)) {
          int index2=getContingencyIndex(info2.dataDomain,info2.columnPerspective.getIdType(),cell2ColumnID,info2.rowIDType,info2.rowID,classifier2);
          if (index2 == -1)           continue;
          contingencyTable[index1][index2]++;
        }
      }
    }
    double[] result=FishersExactTest.fishersExactTest(contingencyTable[0][0],contingencyTable[0][1],contingencyTable[1][0],contingencyTable[1][1]);
    matrixLabel.setText(""String_Node_Str"" + contingencyTable[0][0] + ""String_Node_Str""+ contingencyTable[0][1]+ ""String_Node_Str""+ contingencyTable[1][0]+ ""String_Node_Str""+ contingencyTable[1][1]);
    resultLabel.setText(""String_Node_Str"" + result[0] + ""String_Node_Str""+ result[1]+ ""String_Node_Str""+ result[2]);
    visited=true;
    getWizard().getContainer().updateButtons();
  }
}","@Override public void pageChanged(PageChangedEvent event){
  if (event.getSelectedPage() == this) {
    CalculateCorrelationWizard wizard=(CalculateCorrelationWizard)getWizard();
    DataCellInfo info1=wizard.getInfo1();
    DataCellInfo info2=wizard.getInfo2();
    IDataClassifier classifier1=wizard.getCell1Classifier();
    IDataClassifier classifier2=wizard.getCell2Classifier();
    IDMappingManager mappingManager=IDMappingManagerRegistry.get().getIDMappingManager(info1.columnPerspective.getIdType());
    IIDTypeMapper<Object,Object> mapper=mappingManager.getIDTypeMapper(info1.columnPerspective.getIdType(),info2.columnPerspective.getIdType());
    contingencyTable=new int[2][2];
    for (    int cell1ColumnID : info1.columnPerspective.getVirtualArray()) {
      int index1=getContingencyIndex(info1.dataDomain,info1.columnPerspective.getIdType(),cell1ColumnID,info1.rowIDType,info1.rowID,classifier1);
      if (index1 == -1)       continue;
      Set<Object> cell2ColumnIDs=mapper.apply(cell1ColumnID);
      if (cell2ColumnIDs != null && !cell2ColumnIDs.isEmpty()) {
        Integer cell2ColumnID=(Integer)cell2ColumnIDs.iterator().next();
        if (info2.columnPerspective.getVirtualArray().contains(cell2ColumnID)) {
          int index2=getContingencyIndex(info2.dataDomain,info2.columnPerspective.getIdType(),cell2ColumnID,info2.rowIDType,info2.rowID,classifier2);
          if (index2 == -1)           continue;
          contingencyTable[index1][index2]++;
        }
      }
    }
    double[] result=FishersExactTest.fishersExactTest(contingencyTable[0][0],contingencyTable[0][1],contingencyTable[1][0],contingencyTable[1][1]);
    matrixLabel.setText(""String_Node_Str"" + contingencyTable[0][0] + ""String_Node_Str""+ contingencyTable[0][1]+ ""String_Node_Str""+ contingencyTable[1][0]+ ""String_Node_Str""+ contingencyTable[1][1]);
    resultLabel.setText(""String_Node_Str"" + result[0] + ""String_Node_Str""+ result[1]+ ""String_Node_Str""+ result[2]);
    visited=true;
    getWizard().getContainer().updateButtons();
  }
}",0.9910935180603662
56707,"protected void doRender(GLGraphics g,float w,float h,boolean pick){
  if (!enabled) {
    if (pick)     renderPickContent(g,w,h);
 else     content.render(g);
    return;
  }
  final boolean doHor=needHor();
  final boolean doVer=needVer();
  final GL2 gl=g.gl;
  if (doVer || doHor) {
    gl.glPushAttrib(GL2.GL_ENABLE_BIT);
  }
  if (doHor) {
    g.move(0,h - scrollBarWidth);
    g.pushName(horizontal.pickingId);
    if (pick)     horizontal.scrollBar.renderPick(g,doVer ? w - scrollBarWidth : w,scrollBarWidth,this);
 else     horizontal.scrollBar.render(g,doVer ? w - scrollBarWidth : w,scrollBarWidth,this);
    g.popName();
    g.move(0,-h + scrollBarWidth);
  }
  if (doVer) {
    g.move(w - scrollBarWidth,0);
    g.pushName(vertical.pickingId);
    if (pick)     vertical.scrollBar.renderPick(g,scrollBarWidth,doHor ? h - scrollBarWidth : h,this);
 else     vertical.scrollBar.render(g,scrollBarWidth,doHor ? h - scrollBarWidth : h,this);
    g.popName();
    g.move(-w + scrollBarWidth,0);
  }
  if (doHor) {
    double[] clipPlane1=new double[]{1.0,0.0,0.0,0};
    double[] clipPlane3=new double[]{-1.0,0.0,0.0,doVer ? w - scrollBarWidth : w};
    gl.glClipPlane(GL2ES1.GL_CLIP_PLANE0,clipPlane1,0);
    gl.glClipPlane(GL2ES1.GL_CLIP_PLANE1,clipPlane3,0);
    gl.glEnable(GL2ES1.GL_CLIP_PLANE0);
    gl.glEnable(GL2ES1.GL_CLIP_PLANE1);
  }
  if (doVer) {
    double[] clipPlane2=new double[]{0.0,1.0,0.0,0};
    double[] clipPlane4=new double[]{0.0,-1.0,0.0,doHor ? h - scrollBarWidth : h};
    gl.glClipPlane(GL2ES1.GL_CLIP_PLANE2,clipPlane2,0);
    gl.glClipPlane(GL2ES1.GL_CLIP_PLANE3,clipPlane4,0);
    gl.glEnable(GL2ES1.GL_CLIP_PLANE2);
    gl.glEnable(GL2ES1.GL_CLIP_PLANE3);
  }
  gl.glEnable(GL.GL_SCISSOR_TEST);
  IGLCanvas canvas=findCanvas();
  int height=canvas.toRawPixel(canvas.getDIPHeight());
  final Vec2f abs=getAbsoluteLocation();
  int locx=canvas.toRawPixel(abs.x());
  int locy=canvas.toRawPixel(abs.y());
  if (horizontal == null)   locx=0;
  if (vertical == null)   locy=0;
  int pixelW=canvas.toRawPixel(w);
  int pixelH=canvas.toRawPixel(h);
  gl.glScissor(locx,height - locy - pixelH + (doHor ? canvas.toRawPixel(scrollBarWidth) : 0),pixelW - (doVer ? canvas.toRawPixel(scrollBarWidth) : 0),pixelH - (doHor ? canvas.toRawPixel(scrollBarWidth) : 0));
  if (pick)   renderPickContent(g,w,h);
 else   content.render(g);
  gl.glDisable(GL.GL_SCISSOR_TEST);
  if (doVer || doHor) {
    gl.glPopAttrib();
  }
}","protected void doRender(GLGraphics g,float w,float h,boolean pick){
  if (!enabled) {
    if (pick)     renderPickContent(g,w,h);
 else     content.render(g);
    return;
  }
  final boolean doHor=needHor();
  final boolean doVer=needVer();
  final GL2 gl=g.gl;
  if (doVer || doHor) {
    gl.glPushAttrib(GL2.GL_ENABLE_BIT);
  }
  if (doHor) {
    g.move(0,h - scrollBarWidth);
    g.pushName(horizontal.pickingId);
    if (pick)     horizontal.scrollBar.renderPick(g,doVer ? w - scrollBarWidth : w,scrollBarWidth,this);
 else     horizontal.scrollBar.render(g,doVer ? w - scrollBarWidth : w,scrollBarWidth,this);
    g.popName();
    g.move(0,-h + scrollBarWidth);
  }
  if (doVer) {
    g.move(w - scrollBarWidth,0);
    g.pushName(vertical.pickingId);
    if (pick)     vertical.scrollBar.renderPick(g,scrollBarWidth,doHor ? h - scrollBarWidth : h,this);
 else     vertical.scrollBar.render(g,scrollBarWidth,doHor ? h - scrollBarWidth : h,this);
    g.popName();
    g.move(-w + scrollBarWidth,0);
  }
  if (doHor) {
    double[] clipPlane1=new double[]{1.0,0.0,0.0,0};
    double[] clipPlane3=new double[]{-1.0,0.0,0.0,doVer ? w - scrollBarWidth : w};
    gl.glClipPlane(GL2ES1.GL_CLIP_PLANE0,clipPlane1,0);
    gl.glClipPlane(GL2ES1.GL_CLIP_PLANE1,clipPlane3,0);
    gl.glEnable(GL2ES1.GL_CLIP_PLANE0);
    gl.glEnable(GL2ES1.GL_CLIP_PLANE1);
  }
  if (doVer) {
    double[] clipPlane2=new double[]{0.0,1.0,0.0,0};
    double[] clipPlane4=new double[]{0.0,-1.0,0.0,doHor ? h - scrollBarWidth : h};
    gl.glClipPlane(GL2ES1.GL_CLIP_PLANE2,clipPlane2,0);
    gl.glClipPlane(GL2ES1.GL_CLIP_PLANE3,clipPlane4,0);
    gl.glEnable(GL2ES1.GL_CLIP_PLANE2);
    gl.glEnable(GL2ES1.GL_CLIP_PLANE3);
  }
  gl.glEnable(GL.GL_SCISSOR_TEST);
  IGLCanvas canvas=findCanvas();
  int canvasW=canvas.toRawPixel(canvas.getDIPWidth());
  int canvasH=canvas.toRawPixel(canvas.getDIPHeight());
  final Vec2f abs=getAbsoluteLocation();
  int locx=canvas.toRawPixel(abs.x());
  int locy=canvas.toRawPixel(abs.y());
  int pixelW=canvas.toRawPixel(w);
  int pixelH=canvas.toRawPixel(h);
  if (horizontal == null) {
    locx=0;
    pixelW=canvasW;
  }
  if (vertical == null) {
    locy=0;
    pixelH=canvasH;
  }
  gl.glScissor(locx,canvasH - locy - pixelH + (doHor ? canvas.toRawPixel(scrollBarWidth) : 0),pixelW - (doVer ? canvas.toRawPixel(scrollBarWidth) : 0),pixelH - (doHor ? canvas.toRawPixel(scrollBarWidth) : 0));
  if (pick)   renderPickContent(g,w,h);
 else   content.render(g);
  gl.glDisable(GL.GL_SCISSOR_TEST);
  if (doVer || doHor) {
    gl.glPopAttrib();
  }
}",0.9434339396362182
56708,"@Override public double apply(final IDoubleSizedIterable a,final IDoubleSizedIterable b){
  final IDoubleSizedIterator a_it=a.iterator();
  final IDoubleSizedIterator b_it=a.iterator();
  double acc=0;
  while (a_it.hasNext() && b_it.hasNext()) {
    final double d=Math.abs(a_it.nextPrimitive() - b_it.nextPrimitive());
    if (!isNaN(d) && d > acc)     acc=d;
  }
  return acc;
}","@Override public double apply(final IDoubleSizedIterable a,final IDoubleSizedIterable b){
  final IDoubleSizedIterator a_it=a.iterator();
  final IDoubleSizedIterator b_it=b.iterator();
  double acc=0;
  while (a_it.hasNext() && b_it.hasNext()) {
    final double d=Math.abs(a_it.nextPrimitive() - b_it.nextPrimitive());
    if (!isNaN(d) && d > acc)     acc=d;
  }
  return acc;
}",0.9973753280839897
56709,"@Override public double apply(final IDoubleSizedIterable a,final IDoubleSizedIterable b){
  final IDoubleSizedIterator a_it=a.iterator();
  final IDoubleSizedIterator b_it=a.iterator();
  double acc=0;
  while (a_it.hasNext() && b_it.hasNext()) {
    double d=a_it.nextPrimitive() - b_it.nextPrimitive();
    if (!isNaN(d))     acc+=d * d;
  }
  return Math.sqrt(acc);
}","@Override public double apply(final IDoubleSizedIterable a,final IDoubleSizedIterable b){
  final IDoubleSizedIterator a_it=a.iterator();
  final IDoubleSizedIterator b_it=b.iterator();
  double acc=0;
  while (a_it.hasNext() && b_it.hasNext()) {
    double d=a_it.nextPrimitive() - b_it.nextPrimitive();
    if (!isNaN(d))     acc+=d * d;
  }
  return Math.sqrt(acc);
}",0.9972972972972972
56710,"@Override public double apply(final IDoubleSizedIterable a,final IDoubleSizedIterable b){
  final IDoubleSizedIterator a_it=a.iterator();
  final IDoubleSizedIterator b_it=a.iterator();
  double acc=0;
  while (a_it.hasNext() && b_it.hasNext()) {
    double a_d=a_it.nextPrimitive();
    double b_d=b_it.nextPrimitive();
    if (!isNaN(a_d) && !isNaN(b_d))     acc+=Math.abs(a_d - b_d);
  }
  return acc;
}","@Override public double apply(final IDoubleSizedIterable a,final IDoubleSizedIterable b){
  final IDoubleSizedIterator a_it=a.iterator();
  final IDoubleSizedIterator b_it=b.iterator();
  double acc=0;
  while (a_it.hasNext() && b_it.hasNext()) {
    double a_d=a_it.nextPrimitive();
    double b_d=b_it.nextPrimitive();
    if (!isNaN(a_d) && !isNaN(b_d))     acc+=Math.abs(a_d - b_d);
  }
  return acc;
}",0.9975369458128078
56711,"@Override public double apply(final IDoubleSizedIterable a,final IDoubleSizedIterable b){
  final double a_mean=mean(a.iterator());
  final double b_mean=mean(b.iterator());
  final IDoubleSizedIterator a_it=a.iterator();
  final IDoubleSizedIterator b_it=a.iterator();
  int n=0;
  double sum_sq_x=0;
  double sum_sq_y=0;
  double sum_coproduct=0;
  while (a_it.hasNext() && b_it.hasNext()) {
    double a_d=a_it.nextPrimitive() - a_mean;
    double b_d=b_it.nextPrimitive() - b_mean;
    if (!isNaN(a_d) && !isNaN(b_d)) {
      sum_sq_x+=a_d * a_d;
      sum_sq_y+=b_d * b_d;
      sum_coproduct+=a_d * b_d;
      n++;
    }
  }
  if (n == 0)   return 0;
  final double pop_sd_x=Math.sqrt(sum_sq_x / n);
  final double pop_sd_y=Math.sqrt(sum_sq_y / n);
  final double cov_x_y=sum_coproduct / n;
  final double correlation=cov_x_y / (pop_sd_x * pop_sd_y);
  return 1 - correlation;
}","@Override public double apply(final IDoubleSizedIterable a,final IDoubleSizedIterable b){
  final double a_mean=mean(a.iterator());
  final double b_mean=mean(b.iterator());
  final IDoubleSizedIterator a_it=a.iterator();
  final IDoubleSizedIterator b_it=b.iterator();
  int n=0;
  double sum_sq_x=0;
  double sum_sq_y=0;
  double sum_coproduct=0;
  while (a_it.hasNext() && b_it.hasNext()) {
    double a_d=a_it.nextPrimitive() - a_mean;
    double b_d=b_it.nextPrimitive() - b_mean;
    if (!isNaN(a_d) && !isNaN(b_d)) {
      sum_sq_x+=a_d * a_d;
      sum_sq_y+=b_d * b_d;
      sum_coproduct+=a_d * b_d;
      n++;
    }
  }
  if (n == 0)   return 0;
  final double pop_sd_x=Math.sqrt(sum_sq_x / n);
  final double pop_sd_y=Math.sqrt(sum_sq_y / n);
  final double cov_x_y=sum_coproduct / n;
  final double correlation=cov_x_y / (pop_sd_x * pop_sd_y);
  return 1 - correlation;
}",0.998868778280543
56712,"public void addTitleElement(GLElement element,boolean left){
  int index=left ? titleBar.indexOf(titleBar.spacingElement) : titleBar.indexOf(titleBar.spacingElement) + 1;
  titleBar.add(index,element);
}","public void addTitleElement(GLElement element,boolean left){
  int index=left ? titleBar.indexOf(titleBar.captionElement) : titleBar.indexOf(titleBar.captionElement) + 1;
  titleBar.add(index,element);
}",0.7635467980295566
56713,"public GLTitleBar(ILabeled labelProvider){
  super();
  this.labelProvider=labelProvider;
  setSize(Float.NaN,TITLE_BAR_HEIGHT);
  setLayout(new GLSizeRestrictiveFlowLayout(true,2,new GLPadding(3,2)));
  setRenderer(GLRenderers.drawText(labelProvider.getLabel(),VAlign.LEFT,new GLPadding(2,0,0,4)));
  spacingElement=new GLElement();
  add(spacingElement);
  closeButton=new GLButton(EButtonMode.BUTTON);
  closeButton.setSize(16,16);
  closeButton.setTooltip(""String_Node_Str"");
  closeButton.setRenderer(GLRenderers.fillImage(""String_Node_Str""));
  add(closeButton);
}","public GLTitleBar(ILabeled labelProvider){
  super();
  this.labelProvider=labelProvider;
  setSize(Float.NaN,TITLE_BAR_HEIGHT);
  setLayout(new GLSizeRestrictiveFlowLayout(true,2,new GLPadding(3,2,3,1)));
  captionElement=new GLElement(GLRenderers.drawText(labelProvider.getLabel(),VAlign.LEFT,new GLPadding(2,0,0,3)));
  add(captionElement);
  closeButton=new GLButton(EButtonMode.BUTTON);
  closeButton.setSize(16,16);
  closeButton.setTooltip(""String_Node_Str"");
  closeButton.setRenderer(GLRenderers.fillImage(""String_Node_Str""));
  add(closeButton);
}",0.8873114463176575
56714,"public void clearTitleElements(){
  for (  GLElement element : titleBar) {
    if (element != titleBar.spacingElement && element != titleBar.closeButton) {
      titleBar.remove(element);
    }
  }
}","public void clearTitleElements(){
  for (  GLElement element : titleBar) {
    if (element != titleBar.captionElement && element != titleBar.closeButton) {
      titleBar.remove(element);
    }
  }
}",0.9798994974874372
56715,"@Override public void configureUiBindings(UiBindingRegistry uiBindingRegistry){
  uiBindingRegistry.registerDoubleClickBinding(new CellPainterMouseEventMatcher(GridRegion.BODY,MouseEventMatcher.LEFT_BUTTON,colorCellPainter),new ChangeColorAction());
  if (areRowsMoveable) {
    IMouseAction moveUp=new IMouseAction(){
      @Override public void run(      NatTable natTable,      MouseEvent event){
        int rowIndex=natTable.getRowPositionByY(event.y) - 1;
        if (rowIndex > 0) {
          swapRows(rowIndex,rowIndex - 1);
          update();
          selectRow(rowIndex - 1);
        }
      }
    }
;
    IMouseAction moveDown=new IMouseAction(){
      @Override public void run(      NatTable natTable,      MouseEvent event){
        int rowIndex=natTable.getRowPositionByY(event.y) - 1;
        if (rowIndex != -1 && rowIndex < getRowCount() - 1) {
          swapRows(rowIndex,rowIndex + 1);
          update();
          selectRow(rowIndex + 1);
        }
      }
    }
;
    uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,upPainter),moveUp);
    uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,downPainter),moveDown);
    uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,upImagePainter),moveUp);
    uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,downImagePainter),moveDown);
  }
}","@Override public void configureUiBindings(UiBindingRegistry uiBindingRegistry){
  uiBindingRegistry.registerDoubleClickBinding(new CellPainterMouseEventMatcher(GridRegion.BODY,MouseEventMatcher.LEFT_BUTTON,colorCellPainter),new ChangeColorAction());
  if (areRowsMoveable) {
    IMouseAction moveUp=new IMouseAction(){
      @Override public void run(      NatTable natTable,      MouseEvent event){
        int rowIndex=natTable.getRowIndexByPosition(natTable.getRowPositionByY(event.y));
        if (rowIndex > 0) {
          swapRows(rowIndex,rowIndex - 1);
          update();
          selectRow(rowIndex - 1);
        }
      }
    }
;
    IMouseAction moveDown=new IMouseAction(){
      @Override public void run(      NatTable natTable,      MouseEvent event){
        int rowIndex=natTable.getRowIndexByPosition(natTable.getRowPositionByY(event.y));
        if (rowIndex != -1 && rowIndex < getRowCount() - 1) {
          swapRows(rowIndex,rowIndex + 1);
          update();
          selectRow(rowIndex + 1);
        }
      }
    }
;
    uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,upPainter),moveUp);
    uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,downPainter),moveDown);
    uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,upImagePainter),moveUp);
    uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,downImagePainter),moveDown);
  }
}",0.9785202863961814
56716,"@Override public void run(NatTable natTable,MouseEvent event){
  int rowIndex=natTable.getRowPositionByY(event.y) - 1;
  if (rowIndex != -1 && rowIndex < getRowCount() - 1) {
    swapRows(rowIndex,rowIndex + 1);
    update();
    selectRow(rowIndex + 1);
  }
}","@Override public void run(NatTable natTable,MouseEvent event){
  int rowIndex=natTable.getRowIndexByPosition(natTable.getRowPositionByY(event.y));
  if (rowIndex != -1 && rowIndex < getRowCount() - 1) {
    swapRows(rowIndex,rowIndex + 1);
    update();
    selectRow(rowIndex + 1);
  }
}",0.9343065693430656
56717,"private void buildTable(MatrixBasedBodyDataProvider bodyDataProvider,ColumnHeaderDataProvider columnDataProvider,LineNumberRowHeaderDataProvider rowDataProvider,final boolean areRowsMoveable){
  final DataLayer bodyDataLayer=new DataLayer(bodyDataProvider,120,36);
  bodyDataLayer.addLayerListener(this);
  selectionLayer=new SelectionLayer(bodyDataLayer);
  selectionLayer.addLayerListener(this);
  ViewportLayer bodyLayer=new ViewportLayer(selectionLayer);
  final DataLayer columnDataLayer=new DataLayer(columnDataProvider,120,25);
  ColumnHeaderLayer columnHeaderLayer=new ColumnHeaderLayer(columnDataLayer,bodyLayer,selectionLayer);
  DataLayer rowDataLayer=new DataLayer(rowDataProvider,80,36);
  RowHeaderLayer rowHeaderLayer=new RowHeaderLayer(rowDataLayer,bodyLayer,selectionLayer);
  DefaultCornerDataProvider cornerDataProvider=new DefaultCornerDataProvider(columnDataProvider,rowDataProvider);
  CornerLayer cornerLayer=new CornerLayer(new DataLayer(cornerDataProvider),rowHeaderLayer,columnHeaderLayer);
  GridLayer gridLayer=new GridLayer(bodyLayer,columnHeaderLayer,rowHeaderLayer,cornerLayer);
  if (table == null) {
    table=new NatTable(parent,gridLayer,false);
  }
 else {
    table.setLayer(gridLayer);
  }
  table.setLayoutData(layoutData);
  NatTableUtil.applyDefaultNatTableStyling(table);
  ColumnOverrideLabelAccumulator acc=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  bodyDataLayer.setConfigLabelAccumulator(acc);
  acc.registerColumnOverrides(0,NON_EDITABLE);
  acc.registerColumnOverrides(1,NON_EDITABLE);
  acc.registerColumnOverrides(2,EDITABLE);
  acc.registerColumnOverrides(3,""String_Node_Str"");
  final ColorCellPainter colorCellPainter=new ColorCellPainter();
  final ICellPainter upImagePainter=new ImagePainter(GeneralManager.get().getResourceLoader().getImage(parent.getDisplay(),""String_Node_Str""));
  final ICellPainter downImagePainter=new ImagePainter(GeneralManager.get().getResourceLoader().getImage(parent.getDisplay(),""String_Node_Str""));
  final ICellPainter upPainter=new BeveledBorderDecorator(upImagePainter);
  final ICellPainter downPainter=new BeveledBorderDecorator(downImagePainter);
  final ICellPainter rowHeaderPainter=new CellPainterDecorator(new TextPainter(),CellEdgeEnum.LEFT,new CellPainterDecorator(upPainter,CellEdgeEnum.BOTTOM,downPainter));
  table.addConfiguration(new AbstractRegistryConfiguration(){
    @Override public void configureRegistry(    IConfigRegistry configRegistry){
      configRegistry.registerConfigAttribute(EditConfigAttributes.CELL_EDITABLE_RULE,IEditableRule.ALWAYS_EDITABLE,DisplayMode.EDIT,EDITABLE);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,colorCellPainter,DisplayMode.NORMAL,""String_Node_Str"");
      if (areRowsMoveable) {
        configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,rowHeaderPainter,DisplayMode.NORMAL,GridRegion.ROW_HEADER);
      }
 else {
        configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new TextPainter(),DisplayMode.NORMAL,GridRegion.ROW_HEADER);
      }
      Style cellStyle=new Style();
      cellStyle.setAttributeValue(CellStyleAttributes.FOREGROUND_COLOR,GUIHelper.COLOR_WIDGET_NORMAL_SHADOW);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_STYLE,cellStyle,DisplayMode.NORMAL,NON_EDITABLE);
    }
    @Override public void configureUiBindings(    UiBindingRegistry uiBindingRegistry){
      uiBindingRegistry.registerDoubleClickBinding(new CellPainterMouseEventMatcher(GridRegion.BODY,MouseEventMatcher.LEFT_BUTTON,colorCellPainter),new ChangeColorAction());
      if (areRowsMoveable) {
        IMouseAction moveUp=new IMouseAction(){
          @Override public void run(          NatTable natTable,          MouseEvent event){
            int rowIndex=natTable.getRowPositionByY(event.y) - 1;
            if (rowIndex > 0) {
              swapRows(rowIndex,rowIndex - 1);
              update();
              selectRow(rowIndex - 1);
            }
          }
        }
;
        IMouseAction moveDown=new IMouseAction(){
          @Override public void run(          NatTable natTable,          MouseEvent event){
            int rowIndex=natTable.getRowPositionByY(event.y) - 1;
            if (rowIndex != -1 && rowIndex < getRowCount() - 1) {
              swapRows(rowIndex,rowIndex + 1);
              update();
              selectRow(rowIndex + 1);
            }
          }
        }
;
        uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,upPainter),moveUp);
        uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,downPainter),moveDown);
        uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,upImagePainter),moveUp);
        uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,downImagePainter),moveDown);
      }
    }
  }
);
  table.addDisposeListener(this);
  table.configure();
}","private void buildTable(MatrixBasedBodyDataProvider bodyDataProvider,ColumnHeaderDataProvider columnDataProvider,LineNumberRowHeaderDataProvider rowDataProvider,final boolean areRowsMoveable){
  final DataLayer bodyDataLayer=new DataLayer(bodyDataProvider,120,36);
  bodyDataLayer.addLayerListener(this);
  selectionLayer=new SelectionLayer(bodyDataLayer);
  selectionLayer.addLayerListener(this);
  ViewportLayer bodyLayer=new ViewportLayer(selectionLayer);
  final DataLayer columnDataLayer=new DataLayer(columnDataProvider,120,25);
  ColumnHeaderLayer columnHeaderLayer=new ColumnHeaderLayer(columnDataLayer,bodyLayer,selectionLayer);
  DataLayer rowDataLayer=new DataLayer(rowDataProvider,80,36);
  RowHeaderLayer rowHeaderLayer=new RowHeaderLayer(rowDataLayer,bodyLayer,selectionLayer);
  DefaultCornerDataProvider cornerDataProvider=new DefaultCornerDataProvider(columnDataProvider,rowDataProvider);
  CornerLayer cornerLayer=new CornerLayer(new DataLayer(cornerDataProvider),rowHeaderLayer,columnHeaderLayer);
  GridLayer gridLayer=new GridLayer(bodyLayer,columnHeaderLayer,rowHeaderLayer,cornerLayer);
  if (table == null) {
    table=new NatTable(parent,gridLayer,false);
  }
 else {
    table.setLayer(gridLayer);
  }
  table.setLayoutData(layoutData);
  NatTableUtil.applyDefaultNatTableStyling(table);
  ColumnOverrideLabelAccumulator acc=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  bodyDataLayer.setConfigLabelAccumulator(acc);
  acc.registerColumnOverrides(0,NON_EDITABLE);
  acc.registerColumnOverrides(1,NON_EDITABLE);
  acc.registerColumnOverrides(2,EDITABLE);
  acc.registerColumnOverrides(3,""String_Node_Str"");
  final ColorCellPainter colorCellPainter=new ColorCellPainter();
  final ICellPainter upImagePainter=new ImagePainter(GeneralManager.get().getResourceLoader().getImage(parent.getDisplay(),""String_Node_Str""));
  final ICellPainter downImagePainter=new ImagePainter(GeneralManager.get().getResourceLoader().getImage(parent.getDisplay(),""String_Node_Str""));
  final ICellPainter upPainter=new BeveledBorderDecorator(upImagePainter);
  final ICellPainter downPainter=new BeveledBorderDecorator(downImagePainter);
  final ICellPainter rowHeaderPainter=new CellPainterDecorator(new TextPainter(),CellEdgeEnum.LEFT,new CellPainterDecorator(upPainter,CellEdgeEnum.BOTTOM,downPainter));
  table.addConfiguration(new AbstractRegistryConfiguration(){
    @Override public void configureRegistry(    IConfigRegistry configRegistry){
      configRegistry.registerConfigAttribute(EditConfigAttributes.CELL_EDITABLE_RULE,IEditableRule.ALWAYS_EDITABLE,DisplayMode.EDIT,EDITABLE);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,colorCellPainter,DisplayMode.NORMAL,""String_Node_Str"");
      if (areRowsMoveable) {
        configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,rowHeaderPainter,DisplayMode.NORMAL,GridRegion.ROW_HEADER);
      }
 else {
        configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new TextPainter(),DisplayMode.NORMAL,GridRegion.ROW_HEADER);
      }
      Style cellStyle=new Style();
      cellStyle.setAttributeValue(CellStyleAttributes.FOREGROUND_COLOR,GUIHelper.COLOR_WIDGET_NORMAL_SHADOW);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_STYLE,cellStyle,DisplayMode.NORMAL,NON_EDITABLE);
    }
    @Override public void configureUiBindings(    UiBindingRegistry uiBindingRegistry){
      uiBindingRegistry.registerDoubleClickBinding(new CellPainterMouseEventMatcher(GridRegion.BODY,MouseEventMatcher.LEFT_BUTTON,colorCellPainter),new ChangeColorAction());
      if (areRowsMoveable) {
        IMouseAction moveUp=new IMouseAction(){
          @Override public void run(          NatTable natTable,          MouseEvent event){
            int rowIndex=natTable.getRowIndexByPosition(natTable.getRowPositionByY(event.y));
            if (rowIndex > 0) {
              swapRows(rowIndex,rowIndex - 1);
              update();
              selectRow(rowIndex - 1);
            }
          }
        }
;
        IMouseAction moveDown=new IMouseAction(){
          @Override public void run(          NatTable natTable,          MouseEvent event){
            int rowIndex=natTable.getRowIndexByPosition(natTable.getRowPositionByY(event.y));
            if (rowIndex != -1 && rowIndex < getRowCount() - 1) {
              swapRows(rowIndex,rowIndex + 1);
              update();
              selectRow(rowIndex + 1);
            }
          }
        }
;
        uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,upPainter),moveUp);
        uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,downPainter),moveDown);
        uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,upImagePainter),moveUp);
        uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.ROW_HEADER,MouseEventMatcher.LEFT_BUTTON,downImagePainter),moveDown);
      }
    }
  }
);
  table.addDisposeListener(this);
  table.configure();
}",0.9900440359946392
56718,"/** 
 */
public MyValueElement(){
  IDoubleList l=new ArrayDoubleList(new double[0]);
  content=new ListBoxAndWhiskersElement(l,EDetailLevel.LOW,EDimension.DIMENSION,false,false,d.getLabel(),Color.LIGHT_GRAY);
}","/** 
 */
public MyValueElement(){
  IDoubleList l=new ArrayDoubleList(new double[0]);
  content=new ListBoxAndWhiskersElement(l,EDetailLevel.LOW,EDimension.DIMENSION,false,false,d.getLabel(),Color.LIGHT_GRAY,GLPadding.ZERO);
}",0.965675057208238
56719,"@Override protected void renderImpl(GLGraphics g,float w,float h){
  SelectionManager manager=selections == null || selections.isEmpty() ? null : selections.get(0);
  int n=list.size();
  float o=dim.opposite().select(w,h) * (0.5f - ITEM_AXIS_WIDTH / 2f);
  if (dim.isHorizontal()) {
    g.color(Color.BLACK).drawLine(0,h * 0.5f,h,h * 0.5f);
  }
 else {
    g.color(Color.BLACK).drawLine(w * 0.5f,0,w * 0.5f,h);
  }
  for (int i=0; i < n; ++i) {
    double v=normalize.apply(list.getPrimitive(i));
    if (Double.isNaN(v))     v=nanReplacement;
    if (Double.isNaN(v))     continue;
    SelectionType t=data == null || manager == null ? null : manager.getHighestSelectionType(data.get(i));
    if (t == null) {
      g.color(0,0,0,0.5f);
    }
 else {
      final Color c=t.getColor();
      g.color(c.r,c.g,c.b,0.5f);
    }
    if (invertOrder)     v=1 - v;
    if (dim.isHorizontal()) {
      g.drawLine(w * (float)v,o,w * (float)v,h - o);
    }
 else {
      g.drawLine(o,h * (float)v,w - o,h * (float)v);
    }
  }
  if (isRenderMarkers()) {
    renderMarkers(g,w,h);
  }
  if (selectStart != Float.NaN && selectEnd != Float.NaN) {
    renderSelection(g,w,h);
  }
  super.renderImpl(g,w,h);
}","@Override protected void renderImpl(GLGraphics g,float w,float h){
  SelectionManager manager=selections == null || selections.isEmpty() ? null : selections.get(0);
  int n=list.size();
  float o=dim.opposite().select(w,h) * (0.5f - ITEM_AXIS_WIDTH / 2f);
  if (dim.isHorizontal()) {
    g.color(Color.BLACK).drawLine(0,h * 0.5f,w,h * 0.5f);
  }
 else {
    g.color(Color.BLACK).drawLine(w * 0.5f,0,w * 0.5f,h);
  }
  for (int i=0; i < n; ++i) {
    double v=normalize.apply(list.getPrimitive(i));
    if (Double.isNaN(v))     v=nanReplacement;
    if (Double.isNaN(v))     continue;
    SelectionType t=data == null || manager == null ? null : manager.getHighestSelectionType(data.get(i));
    if (t == null) {
      g.color(0,0,0,0.5f);
    }
 else {
      final Color c=t.getColor();
      g.color(c.r,c.g,c.b,0.5f);
    }
    if (invertOrder)     v=1 - v;
    if (dim.isHorizontal()) {
      g.drawLine(w * (float)v,o,w * (float)v,h - o);
    }
 else {
      g.drawLine(o,h * (float)v,w - o,h * (float)v);
    }
  }
  if (isRenderMarkers()) {
    renderMarkers(g,w,h);
  }
  if (selectStart != Float.NaN && selectEnd != Float.NaN) {
    renderSelection(g,w,h);
  }
  super.renderImpl(g,w,h);
}",0.9991645781119464
56720,"public Map<Integer,Float> toSignal2Noise(IIDTypeMapper<Integer,Integer> dim2primary){
  LinkedHashMap<Integer,Float> r=new LinkedHashMap<>();
  List<Entry<Integer,Float>> entrySet=new ArrayList<>(correlation.entrySet());
  Collections.sort(entrySet,new Comparator<Entry<Integer,Float>>(){
    @Override public int compare(    Entry<Integer,Float> o1,    Entry<Integer,Float> o2){
      return -Float.compare(o1.getValue(),o2.getValue());
    }
  }
);
  for (  Entry<Integer,Float> ri : entrySet) {
    Set<Integer> keys=dim2primary.apply(ri.getKey());
    if (keys == null) {
      continue;
    }
    for (    Integer key : keys)     r.put(key,ri.getValue());
  }
  return r;
}","public Map<Integer,Float> toSignal2Noise(IIDTypeMapper<Integer,Integer> dim2primary){
  LinkedHashMap<Integer,Float> r=new LinkedHashMap<>();
  List<Entry<Integer,Float>> entrySet=new ArrayList<>(correlation.entrySet());
  Collections.sort(entrySet,new Comparator<Entry<Integer,Float>>(){
    @Override public int compare(    Entry<Integer,Float> o1,    Entry<Integer,Float> o2){
      return -Float.compare(o1.getValue(),o2.getValue());
    }
  }
);
  for (  Entry<Integer,Float> ri : entrySet) {
    final Integer id=ri.getKey();
    Set<Integer> keys=dim2primary.apply(id);
    if (keys == null) {
      continue;
    }
    for (    Integer key : keys) {
      r.put(key,ri.getValue());
    }
  }
  return r;
}",0.9446441409058232
56721,"public void flush(int col){
  double m1=aTimesP / n1;
  double s1=aSquaredTimesP / n1 - m1 * m1;
  s1=sqrt(abs((n1 / (n1 - 1)) * s1));
  double m2=bTimesP / n2;
  double s2=bsquaredsum / n2 - m2 * m2;
  s2=sqrt(abs((n2 / (n2 - 1)) * s2));
  s1=(0.2 * abs(m1) < s1) ? s1 : 0.2 * abs(m1);
  s1=(s1 == 0.f) ? 0.2 : s1;
  s2=(0.2 * abs(m2) < s2) ? s2 : 0.2 * abs(m2);
  s2=(s2 == 0.f) ? 0.2 : s2;
  double s=s1 + s2;
  double m=m1 - m2;
  float s2n=(float)(m / s);
  correlation.put(col,s2n);
  aTimesP=aSquaredTimesP=n1=0;
  bTimesP=bsquaredsum=n2=0;
}","public void flush(int col){
  double m1=aTimesP / n1;
  double s1=aSquaredTimesP / n1 - m1 * m1;
  s1=sqrt(abs((n1 / (n1 - 1)) * s1));
  double m2=bTimesP / n2;
  double s2=bsquaredsum / n2 - m2 * m2;
  s2=sqrt(abs((n2 / (n2 - 1)) * s2));
  s2=(0.2 * abs(m2) < s2) ? s2 : 0.2 * abs(m2);
  s2=(s2 == 0.f) ? 0.2 : s2;
  s1=(0.2 * abs(m1) < s1) ? s1 : 0.2 * abs(m1);
  s1=(s1 == 0.f) ? 0.2 : s1;
  double s=s1 + s2;
  double m=m1 - m2;
  float s2n=(float)(m / s);
  correlation.put(col,s2n);
  aTimesP=aSquaredTimesP=n1=0;
  bTimesP=bsquaredsum=n2=0;
}",0.8816029143897997
56722,"private double enrichmentScore(Map<Integer,Float> correlation,Set<Integer> geneS){
  final int N=correlation.size();
  final int N_h=geneS.size();
  if (N_h == 0)   return Float.NaN;
  float N_R=0;
  int intersection=0;
  for (  Integer g : geneS)   if (correlation.containsKey(g)) {
    N_R+=Math.abs(powP(correlation.get(g)));
    intersection++;
  }
  if (intersection == 0)   return Float.NaN;
  final double norm_tag=1 / N_R;
  final double norm_no_tag=1. / (N - N_h);
  double p_hit=0;
  double p_miss=0;
  double es_max=Double.NEGATIVE_INFINITY;
  double es_min=Double.POSITIVE_INFINITY;
  for (  Integer r : correlation.keySet()) {
    if (geneS.contains(r))     p_hit+=Math.abs(powP(correlation.get(r))) * norm_tag;
 else     p_miss+=norm_no_tag;
    double esi=p_hit - p_miss;
    if (esi > es_max)     es_max=esi;
    if (esi < es_min)     es_min=esi;
  }
  if (es_max > -es_min)   return es_max;
 else   return es_min;
}","private double enrichmentScore(Map<Integer,Float> correlation,Set<Integer> geneS){
  final int N=correlation.size();
  if (geneS.isEmpty())   return Float.NaN;
  float N_R=0;
  int intersection=0;
  for (  Integer g : geneS)   if (correlation.containsKey(g)) {
    N_R+=Math.abs(powP(correlation.get(g)));
    intersection++;
  }
  if (intersection == 0)   return Float.NaN;
  final int N_h=intersection;
  final double norm_tag=1 / N_R;
  final double norm_no_tag=1. / (N - N_h);
  double p_hit=0;
  double p_miss=0;
  double es_max=Double.NEGATIVE_INFINITY;
  double es_min=Double.POSITIVE_INFINITY;
  for (  Integer r : correlation.keySet()) {
    if (geneS.contains(r))     p_hit+=Math.abs(powP(correlation.get(r))) * norm_tag;
 else     p_miss+=norm_no_tag;
    double esi=p_hit - p_miss;
    if (esi > es_max)     es_max=esi;
    if (esi < es_min)     es_min=esi;
  }
  if (es_max > -es_min)   return es_max;
 else   return es_min;
}",0.957776590058792
56723,"@Override protected void set(String value){
  setValue(Float.parseFloat(value));
}","@Override protected void set(String value){
  EventPublisher.trigger(new SetValueEvent(value).to(GLSlider.this));
}",0.6802030456852792
56724,"@Override protected void set(String value){
  setValue(model.parse(value));
}","@Override protected void set(String value){
  EventPublisher.trigger(new SetValueEvent(value).to(GLSpinner.this));
}",0.6839378238341969
56725,"@Override public void removeDropTarget(IDropGLTarget dropTarget){
  this.dropTargets.remove(dropTarget);
  if (activeDropTarget == dropTarget) {
    activeDropTarget=null;
  }
}","@Override public void removeDropTarget(IDropGLTarget dropTarget){
  boolean had=this.dropTargets.remove(dropTarget);
  System.out.println(""String_Node_Str"" + had + ""String_Node_Str""+ dropTarget);
  if (activeDropTarget == dropTarget) {
    activeDropTarget=null;
  }
}",0.7910112359550562
56726,"@Override protected void render(GLGraphics g,float w,float h,ISpacingLayout spacing){
  final EDimension dim=getDimension();
  List<Integer> ids=data.getData(dim);
  for (int i=0; i < ids.size(); ++i) {
    final Integer id=ids.get(i);
    Double v=id2double.apply(id);
    if (v == null || Double.isNaN(v))     continue;
    float pos=spacing.getPosition(i);
    float size=spacing.getSize(i);
    Vec2f bar=value2bar.apply(v);
    g.color(id2color.apply(id));
    if (dim.isVertical()) {
      g.fillRect(bar.x() * w,pos,(bar.x() + bar.y()) * w,size);
    }
 else {
      g.fillRect(pos,bar.x() * w,size,(bar.x() + bar.y()) * w);
    }
  }
}","@Override protected void render(GLGraphics g,float w,float h,ISpacingLayout spacing){
  final EDimension dim=getDimension();
  List<Integer> ids=data.getData(dim);
  for (int i=0; i < ids.size(); ++i) {
    final Integer id=ids.get(i);
    Double v=id2double.apply(id);
    if (v == null || Double.isNaN(v))     continue;
    float pos=spacing.getPosition(i);
    float size=spacing.getSize(i);
    Vec2f bar=value2bar.apply(v);
    g.color(id2color.apply(id));
    if (dim.isVertical()) {
      g.fillRect(bar.x() * w,pos,(bar.x() + bar.y()) * w,size);
    }
 else {
      g.fillRect(pos,bar.x() * h,size,(bar.x() + bar.y()) * h);
    }
  }
}",0.9968895800933126
56727,"public void addMapping(){
  IDCategory category=IDCategory.getIDCategory(idCategory);
  if (category == null) {
    IDCategory.registerCategory(idCategory);
  }
  IDMappingParser.loadMapping(fileName,parsingStartLine,parsingStopLine,getOrCreateIDType(fromIDType,fromDataType),getOrCreateIDType(toIDType,toDataType),delimiter,category,isMultiMapping,createReverseMapping,resolveCodeMappingUsingCodeToId_LUT,getOrCreateIDType(codeResolvedFromIDType,codeResolvedFromDataType),getOrCreateIDType(codeResolvedToIDType,codeResolvedToDataType));
}","public void addMapping(){
  IDCategory category=IDCategory.registerCategoryIfAbsent(idCategory);
  IDMappingParser.loadMapping(fileName,parsingStartLine,parsingStopLine,getOrCreateIDType(fromIDType,fromDataType),getOrCreateIDType(toIDType,toDataType),delimiter,category,isMultiMapping,createReverseMapping,resolveCodeMappingUsingCodeToId_LUT,getOrCreateIDType(codeResolvedFromIDType,codeResolvedFromDataType),getOrCreateIDType(codeResolvedToIDType,codeResolvedToDataType));
}",0.8895463510848126
56728,"public ASingleElement(IHeatMapDataProvider data,EDetailLevel detailLevel,boolean blurNotSelected,EDimension dim){
  this.data=data;
  this.dim=dim;
  this.blurNotSelected=blurNotSelected;
  this.data.setCallback(this);
  detailLevel=Objects.firstNonNull(detailLevel,EDetailLevel.LOW);
  this.renderer=new DimensionRenderer(data,dim);
switch (detailLevel) {
case HIGH:
case MEDIUM:
    setVisibility(EVisibility.PICKABLE);
  break;
default :
setVisibility(EVisibility.VISIBLE);
break;
}
}","public ASingleElement(IHeatMapDataProvider data,EDetailLevel detailLevel,EDimension dim){
  this.data=data;
  this.dim=dim;
  this.data.setCallback(this);
  detailLevel=Objects.firstNonNull(detailLevel,EDetailLevel.LOW);
  this.renderer=new DimensionRenderer(data,dim);
switch (detailLevel) {
case HIGH:
case MEDIUM:
    setVisibility(EVisibility.PICKABLE);
  break;
default :
setVisibility(EVisibility.VISIBLE);
break;
}
}",0.912087912087912
56729,"@Override protected final void renderImpl(GLGraphics g,float w,float h){
  g.save();
  render(g,w,h,renderer.getSpacing());
  g.incZ();
  if (blurNotSelected) {
    renderBlurSelection(g,SelectionType.SELECTION,w,h);
    renderer.render(g,SelectionType.MOUSE_OVER,w,h);
  }
 else {
    renderer.render(g,SelectionType.SELECTION,w,h);
    renderer.render(g,SelectionType.MOUSE_OVER,w,h);
  }
  g.lineWidth(1);
  g.decZ();
  g.restore();
}","@Override protected final void renderImpl(GLGraphics g,float w,float h){
  g.save();
  render(g,w,h,renderer.getSpacing());
  g.incZ();
{
    renderer.renderSelectionRects(g,SelectionType.SELECTION,w,h,true);
    renderer.renderSelectionRects(g,SelectionType.MOUSE_OVER,w,h,true);
  }
  g.lineWidth(1);
  g.decZ();
  g.restore();
}",0.5677083333333334
56730,"@Override protected final void renderImpl(GLGraphics g,float w,float h){
  g.save();
switch (record.getLabel()) {
case LEFT:
    w-=textWidth;
  g.move(textWidth,0);
break;
case RIGHT:
w-=textWidth;
break;
default :
break;
}
switch (dimension.getLabel()) {
case LEFT:
h-=textWidth;
g.move(0,textWidth);
break;
case RIGHT:
h-=textWidth;
break;
default :
break;
}
if (record.getLabel().show()) {
final List<Integer> data=record.getData();
final ISpacingLayout spacing=record.getSpacing();
final EShowLabels label=record.getLabel();
for (int i=0; i < data.size(); ++i) {
Integer recordID=data.get(i);
float y=spacing.getPosition(i);
float fieldHeight=spacing.getSize(i);
float textHeight=Math.min(fieldHeight,MAX_TEXT_HEIGHT);
String text=getLabel(EDimension.RECORD,recordID);
if (label == EShowLabels.LEFT) g.drawText(text,-textWidth,y + (fieldHeight - textHeight) * 0.5f,textWidth - TEXT_OFFSET,textHeight,VAlign.RIGHT);
 else g.drawText(text,w + TEXT_OFFSET,y + (fieldHeight - textHeight) * 0.5f,textWidth - TEXT_OFFSET,textHeight,VAlign.LEFT);
}
}
if (dimension.getLabel().show()) {
final List<Integer> data=dimension.getData();
final ISpacingLayout spacing=dimension.getSpacing();
final EShowLabels label=dimension.getLabel();
g.save();
g.gl.glRotatef(-90,0,0,1);
for (int i=0; i < data.size(); ++i) {
Integer dimensionID=data.get(i);
String l=getLabel(EDimension.DIMENSION,dimensionID);
float x=spacing.getPosition(i);
float fieldWidth=spacing.getSize(i);
float textHeight=Math.min(fieldWidth,MAX_TEXT_HEIGHT);
if (textHeight < 5) continue;
if (label == EShowLabels.LEFT) g.drawText(l,TEXT_OFFSET,x + (fieldWidth - textHeight) * 0.5f,textWidth - TEXT_OFFSET,textHeight,VAlign.LEFT);
 else g.drawText(l,-h - textWidth,x + (fieldWidth - textHeight) * 0.5f,textWidth - TEXT_OFFSET,textHeight,VAlign.RIGHT);
}
g.restore();
}
renderAddons(g,w,h);
renderer.render(g,w,h,record.getSpacing(),dimension.getSpacing());
g.incZ();
if (blurNotSelected) {
renderBlurSelection(g,SelectionType.SELECTION,w,h);
record.render(g,SelectionType.MOUSE_OVER,w,h);
dimension.render(g,SelectionType.MOUSE_OVER,w,h);
}
 else {
record.render(g,SelectionType.SELECTION,w,h);
dimension.render(g,SelectionType.SELECTION,w,h);
record.render(g,SelectionType.MOUSE_OVER,w,h);
dimension.render(g,SelectionType.MOUSE_OVER,w,h);
}
g.lineWidth(1);
g.decZ();
g.restore();
}","@Override protected final void renderImpl(GLGraphics g,float w,float h){
  g.save();
switch (record.getLabel()) {
case LEFT:
    w-=textWidth;
  g.move(textWidth,0);
break;
case RIGHT:
w-=textWidth;
break;
default :
break;
}
switch (dimension.getLabel()) {
case LEFT:
h-=textWidth;
g.move(0,textWidth);
break;
case RIGHT:
h-=textWidth;
break;
default :
break;
}
if (record.getLabel().show()) {
final List<Integer> data=record.getData();
final ISpacingLayout spacing=record.getSpacing();
final EShowLabels label=record.getLabel();
for (int i=0; i < data.size(); ++i) {
Integer recordID=data.get(i);
float y=spacing.getPosition(i);
float fieldHeight=spacing.getSize(i);
float textHeight=Math.min(fieldHeight,MAX_TEXT_HEIGHT);
String text=getLabel(EDimension.RECORD,recordID);
if (label == EShowLabels.LEFT) g.drawText(text,-textWidth,y + (fieldHeight - textHeight) * 0.5f,textWidth - TEXT_OFFSET,textHeight,VAlign.RIGHT);
 else g.drawText(text,w + TEXT_OFFSET,y + (fieldHeight - textHeight) * 0.5f,textWidth - TEXT_OFFSET,textHeight,VAlign.LEFT);
}
}
if (dimension.getLabel().show()) {
final List<Integer> data=dimension.getData();
final ISpacingLayout spacing=dimension.getSpacing();
final EShowLabels label=dimension.getLabel();
g.save();
g.gl.glRotatef(-90,0,0,1);
for (int i=0; i < data.size(); ++i) {
Integer dimensionID=data.get(i);
String l=getLabel(EDimension.DIMENSION,dimensionID);
float x=spacing.getPosition(i);
float fieldWidth=spacing.getSize(i);
float textHeight=Math.min(fieldWidth,MAX_TEXT_HEIGHT);
if (textHeight < 5) continue;
if (label == EShowLabels.LEFT) g.drawText(l,TEXT_OFFSET,x + (fieldWidth - textHeight) * 0.5f,textWidth - TEXT_OFFSET,textHeight,VAlign.LEFT);
 else g.drawText(l,-h - textWidth,x + (fieldWidth - textHeight) * 0.5f,textWidth - TEXT_OFFSET,textHeight,VAlign.RIGHT);
}
g.restore();
}
renderAddons(g,w,h);
renderer.render(g,w,h,record.getSpacing(),dimension.getSpacing());
g.incZ();
if (blurNotSelected) {
renderBlurSelection(g,SelectionType.SELECTION,w,h);
record.renderSelectionRects(g,SelectionType.MOUSE_OVER,w,h,true);
dimension.renderSelectionRects(g,SelectionType.MOUSE_OVER,w,h,true);
}
 else {
record.renderSelectionRects(g,SelectionType.SELECTION,w,h,false);
dimension.renderSelectionRects(g,SelectionType.SELECTION,w,h,false);
record.renderSelectionRects(g,SelectionType.MOUSE_OVER,w,h,false);
dimension.renderSelectionRects(g,SelectionType.MOUSE_OVER,w,h,false);
}
g.lineWidth(1);
g.decZ();
g.restore();
}",0.9687108886107636
56731,"public SingleBarPlotElement(IHeatMapDataProvider data,EDetailLevel detailLevel,boolean blurNotSelected,EDimension dim,Function<? super Integer,Double> id2double,Function<? super Double,Vec2f> value2bar,Function<? super Integer,Color> id2color){
  super(data,detailLevel,blurNotSelected,dim);
  this.id2double=id2double;
  this.value2bar=value2bar;
  this.id2color=id2color;
}","public SingleBarPlotElement(IHeatMapDataProvider data,EDetailLevel detailLevel,EDimension dim,Function<? super Integer,Double> id2double,Function<? super Double,Vec2f> value2bar,Function<? super Integer,Color> id2color){
  super(data,detailLevel,dim);
  this.id2double=id2double;
  this.value2bar=value2bar;
  this.id2color=id2color;
}",0.943661971830986
56732,"public SingleHeatMapPlotElement(IHeatMapDataProvider data,EDetailLevel detailLevel,boolean blurNotSelected,EDimension dim,Function<? super Integer,Color> id2color){
  super(data,detailLevel,blurNotSelected,dim);
  this.id2color=id2color;
  this.hRenderer=new HeatMapRenderer(detailLevel,true,this);
}","public SingleHeatMapPlotElement(IHeatMapDataProvider data,EDetailLevel detailLevel,EDimension dim,Function<? super Integer,Color> id2color){
  super(data,detailLevel,dim);
  this.id2color=id2color;
  this.hRenderer=new HeatMapRenderer(detailLevel,true,this);
}",0.9285714285714286
56733,"private void renderSelectionRects(GLGraphics g,float w,float h,List<Integer> indices,SelectionType type,final boolean isDimension){
  g.color(type.getColor());
  g.lineWidth(3);
  int lastIndex=-1;
  float x=0;
  float wi=0;
  for (  int index : indices) {
    if (index != (lastIndex + 1)) {
      if (isDimension)       g.drawRect(x,0,wi,h);
 else       g.drawRect(0,x,w,wi);
      x=spacing.getPosition(index);
      wi=0;
    }
    wi+=spacing.getSize(index);
    lastIndex=index;
  }
  if (wi > 0)   if (isDimension)   g.drawRect(x,0,wi,h);
 else   g.drawRect(0,x,w,wi);
}","private void renderSelectionRects(GLGraphics g,float w,float h,List<Integer> indices,SelectionType type,final boolean isDimension,boolean fill){
  g.color(type.getColor());
  if (!fill)   g.lineWidth(3);
  int lastIndex=-1;
  float x=0;
  float wi=0;
  for (  int index : indices) {
    if (index != (lastIndex + 1)) {
      if (isDimension)       renderRect(fill,g,x,0,wi,h);
 else       renderRect(fill,g,0,x,w,wi);
      x=spacing.getPosition(index);
      wi=0;
    }
    wi+=spacing.getSize(index);
    lastIndex=index;
  }
  if (wi > 0)   if (isDimension)   renderRect(fill,g,x,0,wi,h);
 else   renderRect(fill,g,0,x,w,wi);
}",0.5860927152317881
56734,"@SuppressWarnings(""String_Node_Str"") @Override public GLElement create(GLElementFactoryContext context){
  EDetailLevel detailLevel=context.get(EDetailLevel.class,EDetailLevel.LOW);
  boolean blurNotSelected=context.is(""String_Node_Str"");
  IHeatMapDataProvider data;
  EDimension dim;
  Function<? super Integer,Double> id2double;
  Function<? super Double,Vec2f> value2bar;
  Function<? super Integer,Color> id2color;
  if (hasTablePerspective(context)) {
    final TablePerspectiveDataProvider d=new TablePerspectiveDataProvider(context.getData());
    data=d;
    dim=EDimension.get(context.getData().getNrRecords() == 1);
    final Integer id=d.getData(dim.opposite()).get(0);
    final Function2<Integer,Integer,Double> getter=dim.isDimension() ? d : Functions2.swap(d);
    id2double=new Function<Integer,Double>(){
      @Override public Double apply(      Integer input){
        return getter.apply(input,id);
      }
    }
;
  }
 else {
    dim=context.get(EDimension.class,EDimension.RECORD);
    IDType idType=context.get(IDType.class,null);
    List<Integer> list=context.get(List.class,null);
    DimensionData d=new DimensionData(list,Functions.constant(""String_Node_Str""),Collections.<Group>emptyList(),idType);
    data=new ListDataProvider(dim.select(null,d),dim.select(d,null));
    id2double=context.get(""String_Node_Str"",Function.class,null);
  }
  id2color=context.get(""String_Node_Str"",Function.class,Functions.constant(context.get(""String_Node_Str"",Color.class,Color.BLACK)));
  value2bar=extractValue2Bar(context);
  return new SingleBarPlotElement(data,detailLevel,blurNotSelected,dim,id2double,value2bar,id2color);
}","@SuppressWarnings(""String_Node_Str"") @Override public GLElement create(GLElementFactoryContext context){
  EDetailLevel detailLevel=context.get(EDetailLevel.class,EDetailLevel.LOW);
  IHeatMapDataProvider data;
  EDimension dim;
  Function<? super Integer,Double> id2double;
  Function<? super Double,Vec2f> value2bar;
  Function<? super Integer,Color> id2color;
  if (hasTablePerspective(context)) {
    final TablePerspectiveDataProvider d=new TablePerspectiveDataProvider(context.getData());
    data=d;
    dim=EDimension.get(context.getData().getNrRecords() == 1);
    final Integer id=d.getData(dim.opposite()).get(0);
    final Function2<Integer,Integer,Double> getter=dim.isDimension() ? d : Functions2.swap(d);
    id2double=new Function<Integer,Double>(){
      @Override public Double apply(      Integer input){
        return getter.apply(input,id);
      }
    }
;
  }
 else {
    dim=context.get(EDimension.class,EDimension.RECORD);
    IDType idType=context.get(IDType.class,null);
    List<Integer> list=context.get(List.class,null);
    DimensionData d=new DimensionData(list,Functions.constant(""String_Node_Str""),Collections.<Group>emptyList(),idType);
    data=new ListDataProvider(dim.select(null,d),dim.select(d,null));
    id2double=context.get(""String_Node_Str"",Function.class,null);
  }
  id2color=context.get(""String_Node_Str"",Function.class,Functions.constant(context.get(""String_Node_Str"",Color.class,Color.BLACK)));
  value2bar=extractValue2Bar(context);
  return new SingleBarPlotElement(data,detailLevel,dim,id2double,value2bar,id2color);
}",0.977293934681182
56735,"@SuppressWarnings(""String_Node_Str"") @Override public GLElement create(GLElementFactoryContext context){
  EDetailLevel detailLevel=context.get(EDetailLevel.class,EDetailLevel.LOW);
  boolean blurNotSelected=context.is(""String_Node_Str"");
  IHeatMapDataProvider data;
  EDimension dim;
  Function<? super Integer,Color> id2color;
  if (hasTablePerspective(context)) {
    final TablePerspectiveDataProvider d=new TablePerspectiveDataProvider(context.getData());
    data=d;
    dim=EDimension.get(context.getData().getNrRecords() == 1);
    final Integer id=d.getData(dim.opposite()).get(0);
    BasicBlockColorer c=new BasicBlockColorer(d.getDataDomain());
    final Function2<Integer,Integer,Color> getter=dim.isDimension() ? c : Functions2.swap(c);
    id2color=new Function<Integer,Color>(){
      @Override public Color apply(      Integer input){
        return getter.apply(input,id);
      }
    }
;
  }
 else {
    dim=context.get(EDimension.class,EDimension.RECORD);
    IDType idType=context.get(IDType.class,null);
    List<Integer> list=context.get(List.class,null);
    DimensionData d=new DimensionData(list,Functions.constant(""String_Node_Str""),Collections.<Group>emptyList(),idType);
    data=new ListDataProvider(dim.select(null,d),dim.select(d,null));
    id2color=context.get(""String_Node_Str"",Function.class,null);
  }
  return new SingleHeatMapPlotElement(data,detailLevel,blurNotSelected,dim,id2color);
}","@SuppressWarnings(""String_Node_Str"") @Override public GLElement create(GLElementFactoryContext context){
  EDetailLevel detailLevel=context.get(EDetailLevel.class,EDetailLevel.LOW);
  IHeatMapDataProvider data;
  EDimension dim;
  Function<? super Integer,Color> id2color;
  if (hasTablePerspective(context)) {
    final TablePerspectiveDataProvider d=new TablePerspectiveDataProvider(context.getData());
    data=d;
    dim=EDimension.get(context.getData().getNrRecords() == 1);
    final Integer id=d.getData(dim.opposite()).get(0);
    BasicBlockColorer c=new BasicBlockColorer(d.getDataDomain());
    final Function2<Integer,Integer,Color> getter=dim.isDimension() ? c : Functions2.swap(c);
    id2color=new Function<Integer,Color>(){
      @Override public Color apply(      Integer input){
        return getter.apply(input,id);
      }
    }
;
  }
 else {
    dim=context.get(EDimension.class,EDimension.RECORD);
    IDType idType=context.get(IDType.class,null);
    List<Integer> list=context.get(List.class,null);
    DimensionData d=new DimensionData(list,Functions.constant(""String_Node_Str""),Collections.<Group>emptyList(),idType);
    data=new ListDataProvider(dim.select(null,d),dim.select(d,null));
    id2color=context.get(""String_Node_Str"",Function.class,null);
  }
  return new SingleHeatMapPlotElement(data,detailLevel,dim,id2color);
}",0.9737504494786048
56736,Color getColor();,"/** 
 * return the color of this object
 * @return
 */
Color getColor();",0.3820224719101123
56737,"@Override public void dragStart(DragSourceEvent event){
  DragEvent e=new DragEvent(toPoint(event.x,event.y,false));
  for (  IDragGLSource source : dragSources) {
    IDragInfo info=source.startSWTDrag(e);
    if (info != null) {
      activeShared=active=new DnDItem(info,source,true);
      active.setMousePos(e.getMousePos());
      EventPublisher.trigger(new DragItemEvent(readOnly(active),active.source,false).to(MouseLayer.this));
      return;
    }
  }
  event.doit=false;
}","@Override public void dragStart(DragSourceEvent event){
  DragEvent e=new DragEvent(toPoint(event.x,event.y,false));
  for (  IDragGLSource source : dragSources) {
    IDragInfo info=source.startSWTDrag(e);
    if (info != null) {
      active=new DnDItem(info,source,true);
      activeShared=new DnDItem(info,null,false);
      active.setMousePos(e.getMousePos());
      EventPublisher.trigger(new DragItemEvent(readOnly(active),active.source,false).to(MouseLayer.this));
      return;
    }
  }
  event.doit=false;
}",0.9301397205588824
56738,"@Override public Vec2f getMinSize(){
  return new Vec2f(130,size() * (20) + 4);
}","@Override public Vec2f getMinSize(){
  return new Vec2f(130,visibleSize() * (20) + 4);
}",0.9585798816568049
56739,"@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  float y=2;
  w-=4;
  for (  IGLLayoutElement child : children) {
    child.setBounds(2,y,w,18);
    y+=20;
  }
}","@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  float y=2;
  w-=4;
  for (  IGLLayoutElement child : children) {
    child.setBounds(2,y,w,18);
    y+=20;
  }
  relayoutParent();
}",0.9534883720930232
56740,"@Override public final ALayoutRenderer createRemoteView(AGLView remoteRenderingView,List<TablePerspective> tablePerspectives,String embeddingEventSpace){
  GLElement elem=create(tablePerspectives);
  if (elem == null)   return null;
  return new LayoutRendererAdapter(remoteRenderingView,ResourceLocators.DATA_CLASSLOADER,elem,embeddingEventSpace);
}","@Override public final ALayoutRenderer createRemoteView(AGLView remoteRenderingView,List<TablePerspective> tablePerspectives,String embeddingEventSpace){
  GLElement elem=create(remoteRenderingView,tablePerspectives,embeddingEventSpace);
  if (elem == null)   return null;
  return new LayoutRendererAdapter(remoteRenderingView,ResourceLocators.DATA_CLASSLOADER,elem,embeddingEventSpace);
}",0.945945945945946
56741,protected abstract GLElement create(List<TablePerspective> tablePerspectives);,"protected abstract GLElement create(AGLView remoteRenderingView,List<TablePerspective> tablePerspectives,String embeddingEventSpace);",0.7393364928909952
56742,"protected void renderAdapter(GLGraphics g,float w,float h){
  float windowHeight=view.getViewFrustum().getHeight();
  Vec2f loc=getAbsoluteLocation();
  if (viewFrustum.getRight() != w || viewFrustum.getTop() != (windowHeight - loc.y())) {
    viewFrustum.setLeft(loc.x());
    viewFrustum.setBottom(windowHeight - loc.y() - h);
    viewFrustum.setRight(loc.x() + w);
    viewFrustum.setTop(windowHeight - loc.y());
    layout.updateLayout();
  }
  g.save();
  final GL2 gl=g.gl;
  gl.glTranslatef(0,h,g.z());
  gl.glScalef(1,-1,1);
  g.checkError();
  layout.render(gl);
  g.checkError();
  g.restore();
}","protected void renderAdapter(GLGraphics g,float w,float h){
  float windowHeight=view.getViewFrustum().getHeight();
  Vec2f loc=getAbsoluteLocation();
  if (Float.compare(viewFrustum.getLeft(),loc.x() + 140) != 0 || Float.compare(viewFrustum.getBottom(),windowHeight - loc.y() - h) != 0 || Float.compare(viewFrustum.getRight(),loc.x() + w) != 0 || Float.compare(viewFrustum.getTop(),windowHeight - loc.y()) != 0) {
    viewFrustum.setLeft(loc.x());
    viewFrustum.setBottom(windowHeight - loc.y() - h);
    viewFrustum.setRight(loc.x() + w);
    viewFrustum.setTop(windowHeight - loc.y());
    layout.updateLayout();
  }
  g.save();
  final GL2 gl=g.gl;
  gl.glTranslatef(0,h,g.z());
  gl.glScalef(1,-1,1);
  g.checkError();
  layout.render(gl);
  g.checkError();
  g.restore();
}",0.8132660418168709
56743,"@Override protected void renderContent(GL2 gl){
  final PixelGLConverter pixelGLConverter=view.getPixelGLConverter();
  float w=pixelGLConverter.getPixelWidthForGLWidth(x);
  float h=pixelGLConverter.getPixelHeightForGLHeight(y);
  gl.glPushMatrix();
  gl.glTranslatef(0,y,0);
  gl.glScalef(x / w,-y / h,1);
  float hh=view.getParentGLCanvas().getDIPHeight();
  this.location=pixelGLConverter.getCurrentPixelPos(gl);
  this.location.setY(hh - this.location.y());
  if (dirty) {
    root.setBounds(0,0,w,h);
    dirty=false;
  }
  final boolean isPickingRun=GLGraphics.isPickingPass(gl);
  int deltaTimeMs=0;
  if (!isPickingRun) {
    deltaTimeMs=local.getDeltaTimeMs();
  }
  GLGraphics g=new GLGraphics(gl,local,true,deltaTimeMs);
  g.checkError(""String_Node_Str"");
  if (isPickingRun) {
    root.renderPick(g);
  }
 else {
    root.layout(deltaTimeMs);
    root.render(g);
  }
  g.checkError(""String_Node_Str"");
  gl.glPopMatrix();
}","@Override protected void renderContent(GL2 gl){
  final PixelGLConverter pixelGLConverter=view.getPixelGLConverter();
  float w=pixelGLConverter.getPixelWidthForGLWidth(x);
  float h=pixelGLConverter.getPixelHeightForGLHeight(y);
  gl.glPushMatrix();
  gl.glTranslatef(0,y,0);
  gl.glScalef(x / w,-y / h,1);
  float hh=view.getParentGLCanvas().getDIPHeight();
  this.location=pixelGLConverter.getCurrentPixelPos(gl);
  this.location.setY(hh - this.location.y());
  if (dirty) {
    root.setBounds(0,0,w,h);
    root.relayout();
    dirty=false;
  }
  final boolean isPickingRun=GLGraphics.isPickingPass(gl);
  int deltaTimeMs=0;
  if (!isPickingRun) {
    deltaTimeMs=local.getDeltaTimeMs();
  }
  GLGraphics g=new GLGraphics(gl,local,true,deltaTimeMs);
  g.checkError(""String_Node_Str"");
  if (isPickingRun) {
    root.renderPick(g);
  }
 else {
    root.layout(deltaTimeMs);
    root.render(g);
  }
  g.checkError(""String_Node_Str"");
  gl.glPopMatrix();
}",0.9889064976228208
56744,"private boolean addPortalHighlightRenderer(PathwayVertexRep vertexRep,PathwayMultiFormInfo info){
  PathwayGraph pathway=PathwayManager.get().getPathwayByTitle(vertexRep.getName(),EPathwayDatabaseType.KEGG);
  boolean wasHighlighted=false;
  if (pathway != null) {
    PathwayMultiFormInfo windowInfo=getPathwayMultiFormInfo(pathway);
    if (windowInfo != null) {
      PortalHighlightRenderer renderer=new PortalHighlightRenderer(getPortalLocation(vertexRep,info).getFirst(),(GLPathwayWindow)windowInfo.window);
      augmentation.add(renderer);
      wasHighlighted=true;
    }
  }
  return wasHighlighted;
}","private boolean addPortalHighlightRenderer(PathwayVertexRep vertexRep,PathwayMultiFormInfo info){
  PathwayGraph pathway=PathwayManager.get().getPathwayByTitle(vertexRep.getName(),EPathwayDatabaseType.KEGG);
  boolean wasHighlighted=false;
  if (pathway != null) {
    PathwayMultiFormInfo windowInfo=getPathwayMultiFormInfo(pathway);
    if (windowInfo != null) {
      PortalHighlightRenderer renderer=new PortalHighlightRenderer(info,getPortalLocation(vertexRep,info).getFirst(),(GLPathwayWindow)windowInfo.window);
      augmentation.add(renderer);
      wasHighlighted=true;
    }
  }
  return wasHighlighted;
}",0.9959250203748982
56745,"private void highlightPathwayNodePortals(PathwayMultiFormInfo info){
  if (info.getCurrentEmbeddingID() == EEmbeddingID.PATHWAY_LEVEL1) {
    for (    PathwayVertexRep vertexRep : info.pathway.vertexSet()) {
      if (vertexRep.getType() == EPathwayVertexType.map) {
        PathwayGraph pathway=PathwayManager.get().getPathwayByTitle(vertexRep.getName(),EPathwayDatabaseType.KEGG);
        PathwayMultiFormInfo target=getPathwayMultiFormInfo(pathway);
        if (target != null) {
          PortalHighlightRenderer renderer=new PortalHighlightRenderer(getPortalLocation(vertexRep,info).getFirst(),(GLPathwayWindow)target.window);
          augmentation.add(renderer);
        }
      }
    }
  }
}","private void highlightPathwayNodePortals(PathwayMultiFormInfo info){
  if (info.getCurrentEmbeddingID() == EEmbeddingID.PATHWAY_LEVEL1) {
    for (    PathwayVertexRep vertexRep : info.pathway.vertexSet()) {
      if (vertexRep.getType() == EPathwayVertexType.map) {
        PathwayGraph pathway=PathwayManager.get().getPathwayByTitle(vertexRep.getName(),EPathwayDatabaseType.KEGG);
        PathwayMultiFormInfo target=getPathwayMultiFormInfo(pathway);
        if (target != null) {
          PortalHighlightRenderer renderer=new PortalHighlightRenderer(info,getPortalLocation(vertexRep,info).getFirst(),(GLPathwayWindow)target.window);
          augmentation.add(renderer);
        }
      }
    }
  }
}",0.9964362081254454
56746,"@Override public float getMinHeight(){
  return info.multiFormRenderer.getMinHeightPixels() + 20;
}","@Override public float getMinHeight(){
  PathwayMultiFormInfo pInfo=(PathwayMultiFormInfo)info;
  return pInfo.getCurrentPathwayRepresentation().getMinHeight() + 20;
}",0.5789473684210527
56747,"@Override protected void renderImpl(GLGraphics g,float w,float h){
  g.incZ(0.5f);
  g.color(PortalRenderStyle.CONTEXT_PORTAL_COLOR).lineWidth(2).drawRoundedRect(location.x() + 1,location.y() + 1,location.width() + 1,location.height() + 1,location.height() / 5.0f);
  g.lineWidth(1);
  g.incZ(-0.5f);
}","@Override protected void renderImpl(GLGraphics g,float w,float h){
  if (info.window.isZoomed())   return;
  g.incZ(0.5f);
  g.color(PortalRenderStyle.CONTEXT_PORTAL_COLOR).lineWidth(2).drawRoundedRect(location.x() + 1,location.y() + 1,location.width() + 1,location.height() + 1,location.height() / 5.0f);
  g.lineWidth(1);
  g.incZ(-0.5f);
}",0.937888198757764
56748,"@Override protected void renderPickImpl(GLGraphics g,float w,float h){
  g.incZ(0.5f);
  g.fillRect(location.x() + 1,location.y() + 1,location.width() + 1,location.height() + 1);
  g.lineWidth(1);
  g.incZ(-0.5f);
}","@Override protected void renderPickImpl(GLGraphics g,float w,float h){
  if (info.window.isZoomed())   return;
  g.incZ(0.5f);
  g.fillRect(location.x() + 1,location.y() + 1,location.width() + 1,location.height() + 1);
  g.lineWidth(1);
  g.incZ(-0.5f);
}",0.9148936170212766
56749,"/** 
 */
public PortalHighlightRenderer(Rect location,GLPathwayWindow window){
  this.location=location;
  this.window=window;
}","/** 
 */
public PortalHighlightRenderer(PathwayMultiFormInfo info,Rect location,GLPathwayWindow window){
  this.location=location;
  this.window=window;
  this.info=info;
}",0.8533333333333334
56750,"@Override public float getMinWidth(){
  if (minWidth < 0)   return minWidth;
  if (pathway == null)   return 120;
  return pathway.getWidth() * 0.8f;
}","@Override public float getMinWidth(){
  if (minWidth > 0)   return minWidth;
  if (pathway == null)   return 120;
  return pathway.getWidth() * 0.8f;
}",0.9933774834437086
56751,"@Override public float getMinHeight(){
  if (minHeight < 0)   return minHeight;
  if (pathway == null)   return 120;
  return pathway.getHeight() * 0.8f;
}","@Override public float getMinHeight(){
  if (minHeight > 0)   return minHeight;
  if (pathway == null)   return 120;
  return pathway.getHeight() * 0.8f;
}",0.9935483870967742
56752,"/** 
 * finds a parent in the hierarchy that is of the specific instance
 * @param satisfies
 * @return
 */
protected final <T>T findParent(Class<T> isInstanceOf){
  IGLElementParent act=parent;
  while (act != null && !(isInstanceOf.isInstance(act))) {
    act=parent.getParent();
  }
  return isInstanceOf.cast(act);
}","/** 
 * finds a parent in the hierarchy that is of the specific instance
 * @param satisfies
 * @return
 */
protected final <T>T findParent(Class<T> isInstanceOf){
  IGLElementParent act=parent;
  while (act != null && !(isInstanceOf.isInstance(act))) {
    act=act.getParent();
  }
  return isInstanceOf.cast(act);
}",0.989010989010989
56753,"/** 
 * Returns the 3-component color for the given table cell. This works independent of the data type. FIXME: inhomogeneous numerical is not implemented
 * @param dimensionID
 * @param recordID
 * @return
 */
public float[] getColor(Integer dimensionID,Integer recordID){
  if (isDataHomogeneous()) {
    return getColorMapper().getColor(getNormalizedValue(dimensionID,recordID));
  }
 else {
    if (EDataClass.CATEGORICAL.equals(getDataClass(dimensionID,recordID))) {
      CategoricalClassDescription<?> specific=(CategoricalClassDescription<?>)getDataClassSpecificDescription(dimensionID,recordID);
      Object category=getRaw(dimensionID,recordID);
      return specific.getCategoryProperty(category).getColor().getRGBA();
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
}","/** 
 * Returns the 3-component color for the given table cell. This works independent of the data type. FIXME: inhomogeneous numerical is not implemented
 * @param dimensionID
 * @param recordID
 * @return
 */
public float[] getColor(Integer dimensionID,Integer recordID){
  if (isDataHomogeneous()) {
    return getColorMapper().getColor(getNormalizedValue(dimensionID,recordID));
  }
 else {
    if (EDataClass.CATEGORICAL.equals(getDataClass(dimensionID,recordID))) {
      CategoricalClassDescription<?> specific=(CategoricalClassDescription<?>)getDataClassSpecificDescription(dimensionID,recordID);
      Object category=getRaw(dimensionID,recordID);
      if (category == null)       return Color.NOT_A_NUMBER_COLOR.getRGBA();
      CategoryProperty<?> p=specific.getCategoryProperty(category);
      if (p == null)       return Color.NOT_A_NUMBER_COLOR.getRGBA();
      return specific.getCategoryProperty(category).getColor().getRGBA();
    }
 else {
      Float v=getNormalizedValue(dimensionID,recordID);
      if (v == null || v.isNaN())       return Color.NOT_A_NUMBER_COLOR.getRGBA();
      return new Color(v.floatValue()).getRGBA();
    }
  }
}",0.7122593718338399
56754,"@Override public boolean doLayout(List<? extends IGLLayoutElement> children,float w,float h,IGLLayoutElement parent,int deltaTimeMs){
  for (  IGLLayoutElement child : children) {
    child.setBounds(defaultValue(child.getSetX(),0),defaultValue(child.getSetY(),0),defaultValue(child.getSetWidth(),w),defaultValue(child.getSetHeight(),h));
  }
  return false;
}","@Override public boolean doLayout(List<? extends IGLLayoutElement> children,float w,float h,IGLLayoutElement parent,int deltaTimeMs){
  for (  IGLLayoutElement child : children) {
    child.setBounds(defaultValue2(child.getSetX(),0),defaultValue2(child.getSetY(),0),defaultValue(child.getSetWidth(),w),defaultValue(child.getSetHeight(),h));
  }
  return false;
}",0.997229916897507
56755,"public GLPathwayView(IGLCanvas glCanvas){
  super(glCanvas,VIEW_TYPE,VIEW_NAME);
  pathwayElement=new PathwayElement(eventSpace);
  pathwayElement.setPathwayRepresentation(new PathwayTextureRepresentation(PathwayManager.get().getPathwayByTitle(""String_Node_Str"",EPathwayDatabaseType.KEGG)));
  PathwayDataMappingHandler pathwayMappingHandler=new PathwayDataMappingHandler();
  pathwayMappingHandler.setEventSpace(eventSpace);
  AverageColorMappingAugmentation colorMappingAugmentation=new AverageColorMappingAugmentation(pathwayElement.getPathwayRepresentation(),pathwayElement.getMappingHandler());
  pathwayElement.addBackgroundAugmentation(colorMappingAugmentation);
  pathwayElement.addBackgroundAugmentation(new MultiMappingIndicatorAugmentation(pathwayElement.getPathwayRepresentation()));
  pathwayElement.addForegroundAugmentation(new BubbleSetPathAugmentation(pathwayElement.getPathwayRepresentation()));
  pathwayElement.addForegroundAugmentation(new StdDevBarAugmentation(pathwayElement.getPathwayRepresentation(),pathwayElement.getMappingHandler()));
  pathwayElement.addForegroundAugmentation(new HighVarianceIndicatorAugmentation(pathwayElement.getPathwayRepresentation(),pathwayElement.getMappingHandler()));
  pathwayElement.addForegroundAugmentation(new StdDevBarConsideringVertexHighlightAugmentation(pathwayElement));
}","public GLPathwayView(IGLCanvas glCanvas){
  super(glCanvas,VIEW_TYPE,VIEW_NAME);
  pathwayElement=new PathwayElement(eventSpace);
  pathwayElement.setPathwayRepresentation(new PathwayTextureRepresentation(PathwayManager.get().getPathwayByTitle(""String_Node_Str"",EPathwayDatabaseType.KEGG)));
  PathwayDataMappingHandler pathwayMappingHandler=new PathwayDataMappingHandler();
  pathwayMappingHandler.setEventSpace(eventSpace);
  AverageColorMappingAugmentation colorMappingAugmentation=new AverageColorMappingAugmentation(pathwayElement.getPathwayRepresentation(),pathwayElement.getMappingHandler());
  pathwayElement.addBackgroundAugmentation(colorMappingAugmentation);
  pathwayElement.addBackgroundAugmentation(new MultiMappingIndicatorAugmentation(pathwayElement.getPathwayRepresentation()));
  pathwayElement.addForegroundAugmentation(new BubbleSetPathAugmentation(pathwayElement.getPathwayRepresentation(),canvas));
  pathwayElement.addForegroundAugmentation(new StdDevBarAugmentation(pathwayElement.getPathwayRepresentation(),pathwayElement.getMappingHandler()));
  pathwayElement.addForegroundAugmentation(new HighVarianceIndicatorAugmentation(pathwayElement.getPathwayRepresentation(),pathwayElement.getMappingHandler()));
  pathwayElement.addForegroundAugmentation(new StdDevBarConsideringVertexHighlightAugmentation(pathwayElement));
}",0.9973909802459932
56756,"public BubbleSetPathAugmentation(IPathwayRepresentation pathwayRepresentation){
  this.pathwayRepresentation=pathwayRepresentation;
  this.pathHandler=new PathwayPathHandler(pathwayRepresentation);
  pathHandler.addPathUpdateListener(this);
  setOutline=new BubbleSet(100,20,3,10.0,7.0,0.5,2.5,15.0,8);
  ((BubbleSet)setOutline).useVirtualEdges(false);
  shaper=new BSplineShapeGenerator(setOutline);
  bubblesetCanvas=new CanvasComponent(shaper);
  bubblesetCanvas.setDefaultView();
}","public BubbleSetPathAugmentation(IPathwayRepresentation pathwayRepresentation,IGLCanvas canvas){
  this.pathwayRepresentation=pathwayRepresentation;
  this.pathHandler=new PathwayPathHandler(pathwayRepresentation,canvas);
  pathHandler.addPathUpdateListener(this);
  setOutline=new BubbleSet(100,20,3,10.0,7.0,0.5,2.5,15.0,8);
  ((BubbleSet)setOutline).useVirtualEdges(false);
  shaper=new BSplineShapeGenerator(setOutline);
  bubblesetCanvas=new CanvasComponent(shaper);
  bubblesetCanvas.setDefaultView();
}",0.9758551307847082
56757,"public PathwayPathHandler(IPathwayRepresentation pathwayRepresentation){
  this.pathwayRepresentation=pathwayRepresentation;
  pathwayRepresentation.addVertexRepSelectionListener(this);
}","public PathwayPathHandler(IPathwayRepresentation pathwayRepresentation,IGLCanvas canvas){
  this.pathwayRepresentation=pathwayRepresentation;
  this.canvas=canvas;
  pathwayRepresentation.addVertexRepSelectionListener(this);
  keyListener=GLThreadListenerWrapper.wrap(new IGLKeyListener(){
    @Override public void keyReleased(    IKeyEvent e){
      isControlDown=e.isControlDown();
      isShiftDown=e.isShiftDown();
      isAltDown=e.isAltDown();
    }
    @Override public void keyPressed(    IKeyEvent e){
      isControlDown=e.isControlDown();
      isShiftDown=e.isShiftDown();
      isAltDown=e.isAltDown();
    }
  }
);
  canvas.addKeyListener(keyListener);
}",0.4369158878504673
56758,"protected void addToPath(PathSegment segment){
  if (selectedPath.isEmpty()) {
    selectedPath.add(segment);
  }
 else {
    PathSegment lastSegment=selectedPath.get(selectedPath.size() - 1);
    if (lastSegment.getPathway() == pathwayRepresentation.getPathway()) {
      PathwayVertexRep lastVertex=lastSegment.get(lastSegment.size() - 1);
      if (lastVertex == segment.get(0)) {
        lastSegment.remove(lastSegment.size() - 1);
        lastSegment.addAll(segment);
      }
    }
 else {
      selectedPath.add(segment);
    }
  }
  notifyListeners();
}","protected void addToPath(PathSegment segment){
  if (segment == null || segment.isEmpty())   return;
  if (selectedPath.isEmpty()) {
    selectedPath.add(segment);
  }
 else {
    PathSegment lastSegment=selectedPath.get(selectedPath.size() - 1);
    if (lastSegment.getPathway() == pathwayRepresentation.getPathway()) {
      int index=lastSegment.lastIndexOf(segment.get(0));
      if (index >= 0) {
        int numElementsToRemove=lastSegment.size() - index;
        for (int i=1; i <= numElementsToRemove; i++) {
          lastSegment.remove(lastSegment.size() - 1);
        }
        lastSegment.addAll(segment);
      }
 else {
        selectedPath.add(segment);
      }
    }
 else {
      selectedPath.add(segment);
    }
  }
  StringBuilder b=new StringBuilder(""String_Node_Str"");
  for (  PathSegment s : selectedPath) {
    b.append(""String_Node_Str"");
    for (    PathwayVertexRep v : s) {
      b.append(v.getShortName() + ""String_Node_Str"");
    }
    b.append(""String_Node_Str"");
  }
  b.append(""String_Node_Str"");
  System.out.println(b);
  notifyListeners();
}",0.2039072039072039
56759,"protected void selectPath(PathwayVertexRep from,PathwayVertexRep to){
  if (from == to) {
    addToPath(new PathSegment(Arrays.asList(from)));
  }
 else {
    KShortestPaths<PathwayVertexRep,DefaultEdge> pathAlgo=new KShortestPaths<PathwayVertexRep,DefaultEdge>(pathwayRepresentation.getPathway(),from,MAX_ALTERNATIVE_PATHS);
    List<GraphPath<PathwayVertexRep,DefaultEdge>> paths=pathAlgo.getPaths(to);
    if (paths != null && !paths.isEmpty()) {
      addToPath(new PathSegment(paths.get(0)));
    }
  }
}","protected void selectPath(PathwayVertexRep from,PathwayVertexRep to){
  List<PathSegment> paths=calcPaths(from,to);
  if (!paths.isEmpty()) {
    addToPath(paths.get(0));
  }
}",0.4846715328467153
56760,"@Override public void onSelect(PathwayVertexRep vertexRep,Pick pick){
  if (!isPathSelectionMode || (vertexRep.getType() != EPathwayVertexType.gene && vertexRep.getType() != EPathwayVertexType.compound && vertexRep.getType() != EPathwayVertexType.group))   return;
switch (pick.getPickingMode()) {
case MOUSE_OVER:
    if (startVertexRep != null) {
      selectPath(startVertexRep,vertexRep);
    }
  break;
case CLICKED:
if (startVertexRep == null) {
  startVertexRep=vertexRep;
  selectedPath.clear();
  selectPath(startVertexRep,vertexRep);
}
 else {
  selectPath(startVertexRep,vertexRep);
  startVertexRep=null;
}
break;
default :
break;
}
}","@Override public void onSelect(PathwayVertexRep vertexRep,Pick pick){
  if (!isPathSelectionMode || (vertexRep.getType() != EPathwayVertexType.gene && vertexRep.getType() != EPathwayVertexType.compound && vertexRep.getType() != EPathwayVertexType.group))   return;
  vertexRep=getSelectableVertexRepForPath(vertexRep);
switch (pick.getPickingMode()) {
case MOUSE_OVER:
    if (startVertexRep != null) {
      selectPath(startVertexRep,vertexRep);
    }
 else     if (isShiftDown && !selectedPath.isEmpty()) {
      PathwayVertexRep v=selectedPath.getLast().getLast();
      List<PathSegment> paths=calcPaths(v,vertexRep);
      if (!paths.isEmpty() && v != vertexRep) {
        startVertexRep=v;
        addToPath(paths.get(0));
      }
    }
  break;
case CLICKED:
boolean isVertexEquivalentToLastVertexInPath=isVertexEquivalentToLastVertexOfPath(vertexRep);
if (isVertexEquivalentToLastVertexInPath && selectedPath.getLast().size() == 1) {
selectedPath.remove(selectedPath.size() - 1);
}
if (isShiftDown) {
handleShiftClick(vertexRep);
}
 else {
handleClick(vertexRep,isVertexEquivalentToLastVertexInPath);
}
break;
default :
break;
}
}",0.4932735426008968
56761,"@Override public void init(GLAutoDrawable drawable){
  super.init(drawable);
  IDBrowserElement r=(IDBrowserElement)getRoot();
  this.tableKeyListener=GLThreadListenerWrapper.wrap(new RankTableKeyListener(r.getTable()));
  this.canvas.addKeyListener(tableKeyListener);
  RankTableUIMouseKeyListener tableUIListener=new RankTableUIMouseKeyListener(r.getBody());
  this.tableKeyListener2=GLThreadListenerWrapper.wrap((IGLKeyListener)tableUIListener);
  this.tableMouseListener=GLThreadListenerWrapper.wrap((IGLMouseListener)tableUIListener);
  this.canvas.addKeyListener(eventListeners.register(this.tableKeyListener2));
  this.canvas.addMouseListener(eventListeners.register(this.tableMouseListener));
}","@Override public void init(GLAutoDrawable drawable){
  super.init(drawable);
  IDBrowserElement r=(IDBrowserElement)getRoot();
  this.tableKeyListener=GLThreadListenerWrapper.wrap(new RankTableKeyListener(r.getTable(),r.getBody()));
  this.canvas.addKeyListener(eventListeners.register(tableKeyListener));
}",0.535183349851338
56762,"@Override public void dispose(GLAutoDrawable drawable){
  canvas.removeKeyListener(tableKeyListener);
  canvas.removeKeyListener(tableKeyListener2);
  canvas.removeMouseListener(tableMouseListener);
  super.dispose(drawable);
}","@Override public void dispose(GLAutoDrawable drawable){
  canvas.removeKeyListener(tableKeyListener);
  super.dispose(drawable);
}",0.7282913165266106
56763,"/** 
 * @param in
 * @param l
 * @return
 * @throws IOException
 */
private static String readChars(ObjectInputStream in,int l) throws IOException {
  char[] r=new char[l];
  for (int i=0; i < l; ++l)   r[i]=in.readChar();
  return new String(r);
}","/** 
 * @param in
 * @param l
 * @return
 * @throws IOException
 */
private static String readChars(ObjectInputStream in,int l) throws IOException {
  char[] r=new char[l];
  for (int i=0; i < l; ++i)   r[i]=in.readChar();
  return new String(r);
}",0.995967741935484
56764,"@Override public void drop(DropTargetEvent event){
  event.detail=acceptDetail;
  IDnDItem item=toItem(event);
  if (validateDropTarget(event,item)) {
    if (event.detail == DND.DROP_DEFAULT)     event.detail=fromType(activeDropTarget.defaultSWTDnDType(item));
    EventPublisher.trigger(new DropItemEvent(readOnly(item),activeDropTarget,true).to(MouseLayer.this));
    activeDropTarget=null;
  }
}","@Override public void drop(DropTargetEvent event){
  event.detail=acceptDetail;
  IDnDItem item=toItem(event);
  if (validateDropTarget(event,item)) {
    if (event.detail == DND.DROP_DEFAULT)     event.detail=fromType(activeDropTarget.defaultSWTDnDType(item));
    EventPublisher.trigger(new DropItemEvent(readOnly(item),activeDropTarget,true).to(MouseLayer.this));
    activeDropTarget=null;
  }
  if (active != null && active.source == null)   active=null;
}",0.927906976744186
56765,"@ListenTo private void onDropEnterLeaveItemEvent(DropEnterLeaveItemEvent event){
  IDnDItem item=event.getItem();
  if (event.isEntering()) {
    if (!showhideInfo(item.getInfo(),EVisibility.VISIBLE)) {
      addInfo(item instanceof DNDItem ? ((DNDItem)item).source : null,item);
    }
  }
 else {
    removeInfo(item.getInfo());
  }
}","@ListenTo(sendToMe=true) private void onDropEnterLeaveItemEvent(DropEnterLeaveItemEvent event){
  IDnDItem item=event.getItem();
  if (event.isEntering()) {
    if (!showhideInfo(item.getInfo(),EVisibility.VISIBLE)) {
      addInfo(item instanceof DNDItem ? ((DNDItem)item).source : null,item);
    }
  }
 else {
    removeInfo(item.getInfo());
  }
}",0.978102189781022
56766,"@Override public <T>T getLayoutDataAs(Class<T> clazz,Supplier<T> default_){
  if (clazz.isAssignableFrom(Vec2f.class))   return clazz.cast(getMinSize());
  if (clazz.isInstance(getTablePerspective()))   return clazz.cast(getTablePerspective());
  if (clazz.isInstance(getDataDomain()))   return clazz.cast(getDataDomain());
  return super.getLayoutDataAs(clazz,default_);
}","@Override public <T>T getLayoutDataAs(Class<T> clazz,Supplier<? extends T> default_){
  if (clazz.isAssignableFrom(Vec2f.class))   return clazz.cast(getMinSize());
  if (clazz.isInstance(getTablePerspective()))   return clazz.cast(getTablePerspective());
  if (clazz.isInstance(getDataDomain()))   return clazz.cast(getDataDomain());
  return super.getLayoutDataAs(clazz,default_);
}",0.9867724867724867
56767,"@Override public void display(GL2 gl){
  clearWindowStubSets();
  if (windowToSetActive != null) {
    windowToSetActive.setActive(true);
    windowToSetActive=null;
  }
  boolean updateAugmentation=false;
  if (isLayoutDirty)   updateAugmentation=true;
  final boolean isPickingRun=GLGraphics.isPickingPass(gl);
  if (!isPickingRun) {
    if (!contextMenuItemsToShow.isEmpty()) {
      for (      AContextMenuItem item : contextMenuItemsToShow) {
        getContextMenuCreator().add(item);
      }
      contextMenuItemsToShow.clear();
    }
  }
  super.display(gl);
  if (wasContextChanged) {
    vertexSelectionManager.removeFromType(SelectionType.SELECTION,currentContextVertexRep.getID());
    vertexSelectionManager.addToType(SelectionType.SELECTION,currentContextVertexRep.getID());
    vertexSelectionManager.triggerSelectionUpdateEvent();
  }
  if (wasPathwayAdded) {
    EnablePathSelectionEvent event=new EnablePathSelectionEvent(isPathSelectionMode);
    event.setEventSpace(pathEventSpace);
    eventPublisher.triggerEvent(event);
    if (currentContextVertexRep != null) {
      ShowNodeContextEvent e=new ShowNodeContextEvent(currentContextVertexRep);
      e.setEventSpace(pathEventSpace);
      e.setSender(this);
      eventPublisher.triggerEvent(e);
    }
    PathwayMappingEvent pathwayMappingEvent=new PathwayMappingEvent(dataMappingState.getPathwayMappedTablePerspective());
    event.setEventSpace(pathEventSpace);
    EventPublisher.trigger(pathwayMappingEvent);
    EventPublisher.trigger(new SampleMappingModeEvent(sampleMappingMode));
    wasPathwayAdded=false;
  }
  if (updateAugmentation) {
    updateAugmentation();
  }
  dndController.handleDragging(gl,glMouseListener);
}","@Override public void display(GL2 gl){
  clearWindowStubSets();
  if (windowToSetActive != null) {
    windowToSetActive.setActive(true);
    windowToSetActive=null;
  }
  boolean updateAugmentation=false;
  if (isLayoutDirty)   updateAugmentation=true;
  final boolean isPickingRun=GLGraphics.isPickingPass(gl);
  if (!isPickingRun) {
    if (!contextMenuItemsToShow.isEmpty()) {
      for (      AContextMenuItem item : contextMenuItemsToShow) {
        getContextMenuCreator().add(item);
      }
      contextMenuItemsToShow.clear();
    }
  }
  super.display(gl);
  if (wasContextChanged) {
    vertexSelectionManager.removeFromType(SelectionType.SELECTION,currentContextVertexRep.getID());
    vertexSelectionManager.addToType(SelectionType.SELECTION,currentContextVertexRep.getID());
    vertexSelectionManager.triggerSelectionUpdateEvent();
  }
  if (wasPathwayAdded) {
    EnablePathSelectionEvent event=new EnablePathSelectionEvent(isPathSelectionMode);
    event.setEventSpace(pathEventSpace);
    eventPublisher.triggerEvent(event);
    PathwayMappingEvent pathwayMappingEvent=new PathwayMappingEvent(dataMappingState.getPathwayMappedTablePerspective());
    event.setEventSpace(pathEventSpace);
    EventPublisher.trigger(pathwayMappingEvent);
    EventPublisher.trigger(new SampleMappingModeEvent(sampleMappingMode));
    if (currentContextVertexRep != null) {
      ShowNodeContextEvent e=new ShowNodeContextEvent(currentContextVertexRep);
      e.setEventSpace(pathEventSpace);
      e.setSender(this);
      eventPublisher.triggerEvent(e);
    }
    wasPathwayAdded=false;
  }
  if (updateAugmentation) {
    updateAugmentation();
  }
  dndController.handleDragging(gl,glMouseListener);
}",0.8315727699530516
56768,"protected void updateScrollBars(float w,float h){
  vScrollBarSize=(h / renderer.getMinHeightPixels()) * h;
  if (vScrollBarSize < h) {
    if (vScrollBarPosition < 0) {
      vScrollBarPosition=0;
    }
    if (vScrollBarPosition + vScrollBarSize > h) {
      vScrollBarPosition=h - vScrollBarSize;
    }
  }
  hScrollBarSize=(w / renderer.getMinWidthPixels()) * w;
  if (hScrollBarSize < w) {
    if (hScrollBarPosition < 0) {
      hScrollBarPosition=0;
    }
    if (hScrollBarPosition + hScrollBarSize > w) {
      hScrollBarPosition=w - hScrollBarSize;
    }
  }
}","protected void updateScrollBars(float w,float h){
  vScrollBarSize=(h / renderer.getMinHeightPixels()) * h;
  if (vScrollBarSize < h) {
    if (vScrollBarPosition < 0) {
      vScrollBarPosition=0;
    }
    if (vScrollBarPosition + vScrollBarSize > h) {
      vScrollBarPosition=h - vScrollBarSize;
    }
  }
 else {
    vScrollBarPosition=0;
  }
  hScrollBarSize=(w / renderer.getMinWidthPixels()) * w;
  if (hScrollBarSize < w) {
    if (hScrollBarPosition < 0) {
      hScrollBarPosition=0;
    }
    if (hScrollBarPosition + hScrollBarSize > w) {
      hScrollBarPosition=w - hScrollBarSize;
    }
  }
 else {
    hScrollBarPosition=0;
  }
}",0.9358552631578948
56769,"private void createLayout(LayoutManager layoutManager,boolean isHighlightLayout){
  Row baseRow=new Row(""String_Node_Str"");
  layoutManager.setBaseElementLayout(baseRow);
  if ((contextualTablePerspectives == null || contextualTablePerspectives.isEmpty()) && (geneTablePerspectives == null || geneTablePerspectives.isEmpty()))   return;
  ElementLayout xSpacing=new ElementLayout();
  xSpacing.setPixelSizeX(SPACING_PIXEL_WIDTH);
  float[] color;
  Column dataSetColumn=new Column(""String_Node_Str"");
  dataSetColumn.setBottomUp(false);
  baseRow.append(dataSetColumn);
  Column captionColumn=new Column(""String_Node_Str"");
  captionColumn.setBottomUp(false);
  captionColumn.setPixelSizeX(CAPTION_COLUMN_PIXEL_WIDTH);
  Row buttonRow=new Row(""String_Node_Str"");
  buttonRow.setPixelSizeY(50);
  buttonRow.append(createButton(EPickingType.FIT_TO_VIEW_WIDTH_BUTTON.name(),0,""String_Node_Str""));
  buttonRow.append(xSpacing);
  buttonRow.append(createButton(EPickingType.CENTER_LINE_ALIGNMENT_BUTTON.name(),0,""String_Node_Str""));
  captionColumn.append(buttonRow);
  baseRow.append(captionColumn);
  int nodeCount=0;
  float previousNodePosition=viewFrustum.getHeight() + yOffset - parentView.getPixelGLConverter().getGLHeightForPixelHeight(50);
  int previousNrDavids=0;
  ArrayList<ArrayList<ElementLayout>> rowListForContextTablePerspectives=new ArrayList<ArrayList<ElementLayout>>();
  List<Integer> contextRowIDs=new ArrayList<>();
  if (contextualTablePerspectives != null && !contextualTablePerspectives.isEmpty()) {
    int bottomYSpacing=10;
    for (int count=0; count < contextualTablePerspectives.get(0).size(); count++) {
      rowListForContextTablePerspectives.add(new ArrayList<ElementLayout>());
    }
    int numContextRows=0;
    for (    List<TablePerspective> resolvedContextPerspectives : contextualTablePerspectives) {
      TablePerspective contextTPerspective=resolvedContextPerspectives.get(0);
      IDType contextRowIDType=contextTPerspective.getDataDomain().getOppositeIDType(sampleIDType);
      VirtualArray va=contextTPerspective.getPerspective(contextRowIDType).getVirtualArray();
      for (      Integer rowID : va) {
        contextRowIDs.add(rowID);
        if (numContextRows % 2 == 0)         color=EVEN_BACKGROUND_COLOR;
 else         color=ODD_BACKGROUND_COLOR;
        Row row=new Row(""String_Node_Str"" + numContextRows);
        row.setAbsoluteSizeY(rowHeight);
        dataSetColumn.append(row);
        for (int tablePerspectiveCount=0; tablePerspectiveCount < contextualTablePerspectives.get(0).size(); tablePerspectiveCount++) {
          ElementLayout tablePerspectiveLayout=new ElementLayout(""String_Node_Str"" + tablePerspectiveCount + ""String_Node_Str""+ numContextRows);
          if (!isHighlightLayout) {
            tablePerspectiveLayout.addBackgroundRenderer(new RowBackgroundRenderer(color));
          }
          row.append(tablePerspectiveLayout);
          rowListForContextTablePerspectives.get(tablePerspectiveCount).add(tablePerspectiveLayout);
          if (tablePerspectiveCount != contextualTablePerspectives.size() - 1) {
            row.append(xSpacing);
          }
        }
        ElementLayout rowCaption=new ElementLayout(""String_Node_Str"");
        rowCaption.setAbsoluteSizeY(rowHeight);
        if (isHighlightLayout) {
          if (va.size() == 1) {
            rowCaption.setRenderer(new RowCaptionRenderer(contextRowIDType,rowID,parentView,this,color,contextTPerspective.getPerspective(contextRowIDType).getLabel()));
          }
 else {
            rowCaption.setRenderer(new RowCaptionRenderer(contextRowIDType,rowID,parentView,this,color));
          }
        }
        captionColumn.append(rowCaption);
        numContextRows++;
      }
    }
    PathSizeConfiguration newConfig=new PathSizeConfiguration.Builder(parentView.getPathRenderer().getSizeConfig()).pathStartSpacing(parentView.getPixelGLConverter().getPixelHeightForGLHeight(rowHeight) * numContextRows + defaultSpacing + bottomYSpacing).build();
    parentView.getPathRenderer().setSizeConfig(newConfig);
    previousNodePosition=0;
    ElementLayout spacing=new ElementLayout();
    spacing.setPixelSizeY(bottomYSpacing);
    dataSetColumn.append(spacing);
    captionColumn.append(spacing);
  }
  ArrayList<ArrayList<ElementLayout>> rowListForTablePerspectives=new ArrayList<ArrayList<ElementLayout>>(geneTablePerspectives.size());
  for (int count=0; count < geneTablePerspectives.size(); count++) {
    rowListForTablePerspectives.add(new ArrayList<ElementLayout>(linearizedNodes.size() * 2));
  }
  IDType davidIDType=IDType.getIDType(""String_Node_Str"");
  ArrayList<Integer> davidIDs=new ArrayList<Integer>(linearizedNodes.size() * 2);
  ArrayList<ALinearizableNode> resolvedNodes=new ArrayList<ALinearizableNode>();
  for (  ALinearizableNode node : linearizedNodes) {
    if (node instanceof ComplexNode) {
      List<ALinearizableNode> embeddedNodes=((ComplexNode)node).getNodes();
      resolvedNodes.addAll(embeddedNodes);
    }
 else     resolvedNodes.add(node);
  }
  for (  ALinearizableNode node : resolvedNodes) {
    if (node.getMappedDavidIDs().size() == 0)     continue;
    List<Integer> subDavidIDs=node.getMappedDavidIDs();
    int currentNrDavids=subDavidIDs.size();
    davidIDs.addAll(subDavidIDs);
    float currentNodePositionY=node.getPosition().y();
    float deviation;
    if (node.getParentNode() != null) {
      currentNodePositionY=node.getParentNode().getPosition().y();
      currentNrDavids=node.getParentNode().getMappedDavidIDs().size();
    }
    float previousLowerHeight=previousNodePosition - rowHeight * (previousNrDavids) / 2;
    float currentUpperHeight=(currentNodePositionY + rowHeight * (currentNrDavids) / 2);
    deviation=previousLowerHeight - currentUpperHeight;
    if (previousNodePosition > 0 && deviation > 0) {
      ElementLayout spacing=new ElementLayout(""String_Node_Str"");
      spacing.setFrameColor(0,0,1,0.8f);
      spacing.setAbsoluteSizeY(deviation);
      dataSetColumn.append(spacing);
      captionColumn.append(spacing);
    }
    previousNodePosition=currentNodePositionY;
    previousNrDavids=currentNrDavids;
    if (nodeCount % 2 == 0)     color=EVEN_BACKGROUND_COLOR;
 else     color=ODD_BACKGROUND_COLOR;
    RelationshipRenderer relationShipRenderer=null;
    if (!isHighlightLayout) {
      relationShipRenderer=new RelationshipRenderer(color,parentView);
      relationShipRenderers.add(relationShipRenderer);
      float x=node.getPosition().x() + parentView.getPixelGLConverter().getGLWidthForPixelWidth(node.getWidthPixels()) / 2;
      float height=parentView.getPixelGLConverter().getGLHeightForPixelHeight(node.getHeightPixels());
      relationShipRenderer.topLeft[0]=x - xOffset;
      relationShipRenderer.topLeft[1]=node.getPosition().y() + height / 2 - yOffset;
      relationShipRenderer.bottomLeft[0]=x - xOffset;
      relationShipRenderer.bottomLeft[1]=node.getPosition().y() - height / 2 - yOffset;
    }
    nodeCount++;
    int idCount=0;
    for (    Integer davidID : subDavidIDs) {
      Row row=new Row(""String_Node_Str"" + davidID);
      row.setAbsoluteSizeY(rowHeight);
      dataSetColumn.append(row);
      for (int tablePerspectiveCount=0; tablePerspectiveCount < geneTablePerspectives.size(); tablePerspectiveCount++) {
        ElementLayout tablePerspectiveLayout=new ElementLayout(""String_Node_Str"" + tablePerspectiveCount + ""String_Node_Str""+ idCount);
        if (!isHighlightLayout) {
          tablePerspectiveLayout.addBackgroundRenderer(new RowBackgroundRenderer(color));
        }
        row.append(tablePerspectiveLayout);
        rowListForTablePerspectives.get(tablePerspectiveCount).add(tablePerspectiveLayout);
        if (tablePerspectiveCount != geneTablePerspectives.size() - 1) {
          row.append(xSpacing);
        }
      }
      ElementLayout rowCaption=new ElementLayout();
      rowCaption.setAbsoluteSizeY(rowHeight);
      if (isHighlightLayout) {
        RowCaptionRenderer captionRenderer=new RowCaptionRenderer(davidIDType,davidID,parentView,this,color);
        rowCaption.setRenderer(captionRenderer);
      }
      captionColumn.append(rowCaption);
      if (!isHighlightLayout) {
        if (relationShipRenderer == null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
 else {
          if (idCount == 0)           relationShipRenderer.topRightLayout=row;
          if (idCount == subDavidIDs.size() - 1)           relationShipRenderer.bottomRightLayout=row;
        }
      }
      idCount++;
    }
  }
  ElementLayout ySpacing=new ElementLayout();
  ySpacing.setPixelSizeY(5);
  dataSetColumn.append(ySpacing);
  Row topCaptionRow=new Row(""String_Node_Str"");
  topCaptionRow.setPixelSizeY(50);
  dataSetColumn.add(0,topCaptionRow);
  Row bottomCaptionRow=new Row(""String_Node_Str"");
  bottomCaptionRow.setPixelSizeY(50);
  dataSetColumn.append(bottomCaptionRow);
  for (int tablePerspectiveCount=0; tablePerspectiveCount < geneTablePerspectives.size(); tablePerspectiveCount++) {
    if (contextualTablePerspectives != null && contextualTablePerspectives.size() > 0) {
      for (      List<TablePerspective> resolvedContextTablePerspectives : contextualTablePerspectives) {
        TablePerspective contextTablePerspective=resolvedContextTablePerspectives.get(tablePerspectiveCount);
        prepareData(contextTablePerspective,rowListForContextTablePerspectives.get(tablePerspectiveCount),null,null,contextTablePerspective.getDataDomain().getOppositeIDType(sampleIDType),contextRowIDs,isHighlightLayout,geneTablePerspectives.get(tablePerspectiveCount));
      }
    }
    ColumnCaptionLayout topCaptionLayout=new ColumnCaptionLayout(parentView,this);
    topCaptionRow.append(topCaptionLayout);
    ColumnCaptionLayout bottomCaptionLayout=new ColumnCaptionLayout(parentView,this);
    bottomCaptionRow.append(bottomCaptionLayout);
    if (tablePerspectiveCount != geneTablePerspectives.size() - 1) {
      bottomCaptionRow.append(xSpacing);
      topCaptionRow.append(xSpacing);
    }
    prepareData(geneTablePerspectives.get(tablePerspectiveCount),rowListForTablePerspectives.get(tablePerspectiveCount),topCaptionLayout,bottomCaptionLayout,davidIDType,davidIDs,isHighlightLayout,null);
  }
  calcMinWidthPixels();
  PixelGLConverter pixelGLConverter=parentView.getPixelGLConverter();
  float minWidth=pixelGLConverter.getGLWidthForPixelWidth(minWidthPixels);
  if (!parentView.isFitWidthToScreen() && viewFrustum.getWidth() < minWidth) {
    viewFrustum.setRight(minWidth);
  }
}","private void createLayout(LayoutManager layoutManager,boolean isHighlightLayout){
  Row baseRow=new Row(""String_Node_Str"");
  layoutManager.setBaseElementLayout(baseRow);
  if ((contextualTablePerspectives == null || contextualTablePerspectives.isEmpty()) && (geneTablePerspectives == null || geneTablePerspectives.isEmpty()))   return;
  ElementLayout xSpacing=new ElementLayout();
  xSpacing.setPixelSizeX(SPACING_PIXEL_WIDTH);
  float[] color;
  Column dataSetColumn=new Column(""String_Node_Str"");
  dataSetColumn.setBottomUp(false);
  baseRow.append(dataSetColumn);
  Column captionColumn=new Column(""String_Node_Str"");
  captionColumn.setBottomUp(false);
  captionColumn.setPixelSizeX(CAPTION_COLUMN_PIXEL_WIDTH);
  Row buttonRow=new Row(""String_Node_Str"");
  buttonRow.setPixelSizeY(50);
  buttonRow.append(createButton(EPickingType.FIT_TO_VIEW_WIDTH_BUTTON.name(),0,""String_Node_Str""));
  buttonRow.append(xSpacing);
  buttonRow.append(createButton(EPickingType.CENTER_LINE_ALIGNMENT_BUTTON.name(),0,""String_Node_Str""));
  captionColumn.append(buttonRow);
  baseRow.append(captionColumn);
  int nodeCount=0;
  float previousNodePosition=viewFrustum.getHeight() + yOffset - parentView.getPixelGLConverter().getGLHeightForPixelHeight(50);
  int previousNrDavids=0;
  Map<TablePerspective,List<ElementLayout>> rowsForContextTablePerspectives=new HashMap<>();
  Map<TablePerspective,List<Integer>> contextRowIDs=new HashMap<>();
  if (contextualTablePerspectives != null && !contextualTablePerspectives.isEmpty()) {
    int bottomYSpacing=10;
    int numContextRows=0;
    for (int tpRowIndex=0; tpRowIndex < contextualTablePerspectives.size(); tpRowIndex++) {
      List<TablePerspective> resolvedContextPerspectives=contextualTablePerspectives.get(tpRowIndex);
      TablePerspective contextTPerspective=resolvedContextPerspectives.get(0);
      IDType contextRowIDType=contextTPerspective.getDataDomain().getOppositeIDType(sampleIDType);
      VirtualArray va=contextTPerspective.getPerspective(contextRowIDType).getVirtualArray();
      List<Integer> ids=new ArrayList<>();
      for (      TablePerspective tp : resolvedContextPerspectives) {
        contextRowIDs.put(tp,ids);
      }
      for (      Integer rowID : va) {
        ids.add(rowID);
        if (numContextRows % 2 == 0)         color=EVEN_BACKGROUND_COLOR;
 else         color=ODD_BACKGROUND_COLOR;
        Row row=new Row(""String_Node_Str"" + numContextRows);
        row.setAbsoluteSizeY(rowHeight);
        dataSetColumn.append(row);
        for (int tablePerspectiveCount=0; tablePerspectiveCount < contextualTablePerspectives.get(0).size(); tablePerspectiveCount++) {
          ElementLayout tablePerspectiveLayout=new ElementLayout(""String_Node_Str"" + tablePerspectiveCount + ""String_Node_Str""+ numContextRows);
          if (!isHighlightLayout) {
            tablePerspectiveLayout.addBackgroundRenderer(new RowBackgroundRenderer(color));
          }
          row.append(tablePerspectiveLayout);
          TablePerspective tp=contextualTablePerspectives.get(tpRowIndex).get(tablePerspectiveCount);
          List<ElementLayout> layouts=rowsForContextTablePerspectives.get(tp);
          if (layouts == null) {
            layouts=new ArrayList<>();
            rowsForContextTablePerspectives.put(tp,layouts);
          }
          layouts.add(tablePerspectiveLayout);
          if (tablePerspectiveCount != contextualTablePerspectives.size() - 1) {
            row.append(xSpacing);
          }
        }
        ElementLayout rowCaption=new ElementLayout(""String_Node_Str"");
        rowCaption.setAbsoluteSizeY(rowHeight);
        if (isHighlightLayout) {
          if (va.size() == 1) {
            rowCaption.setRenderer(new RowCaptionRenderer(contextRowIDType,rowID,parentView,this,color,contextTPerspective.getPerspective(contextRowIDType).getLabel()));
          }
 else {
            rowCaption.setRenderer(new RowCaptionRenderer(contextRowIDType,rowID,parentView,this,color));
          }
        }
        captionColumn.append(rowCaption);
        numContextRows++;
      }
    }
    PathSizeConfiguration newConfig=new PathSizeConfiguration.Builder(parentView.getPathRenderer().getSizeConfig()).pathStartSpacing(parentView.getPixelGLConverter().getPixelHeightForGLHeight(rowHeight) * numContextRows + defaultSpacing + bottomYSpacing).build();
    parentView.getPathRenderer().setSizeConfig(newConfig);
    previousNodePosition=0;
    ElementLayout spacing=new ElementLayout();
    spacing.setPixelSizeY(bottomYSpacing);
    dataSetColumn.append(spacing);
    captionColumn.append(spacing);
  }
  ArrayList<ArrayList<ElementLayout>> rowListForTablePerspectives=new ArrayList<ArrayList<ElementLayout>>(geneTablePerspectives.size());
  for (int count=0; count < geneTablePerspectives.size(); count++) {
    rowListForTablePerspectives.add(new ArrayList<ElementLayout>(linearizedNodes.size() * 2));
  }
  IDType davidIDType=IDType.getIDType(""String_Node_Str"");
  ArrayList<Integer> davidIDs=new ArrayList<Integer>(linearizedNodes.size() * 2);
  ArrayList<ALinearizableNode> resolvedNodes=new ArrayList<ALinearizableNode>();
  for (  ALinearizableNode node : linearizedNodes) {
    if (node instanceof ComplexNode) {
      List<ALinearizableNode> embeddedNodes=((ComplexNode)node).getNodes();
      resolvedNodes.addAll(embeddedNodes);
    }
 else     resolvedNodes.add(node);
  }
  for (  ALinearizableNode node : resolvedNodes) {
    if (node.getMappedDavidIDs().size() == 0)     continue;
    List<Integer> subDavidIDs=node.getMappedDavidIDs();
    int currentNrDavids=subDavidIDs.size();
    davidIDs.addAll(subDavidIDs);
    float currentNodePositionY=node.getPosition().y();
    float deviation;
    if (node.getParentNode() != null) {
      currentNodePositionY=node.getParentNode().getPosition().y();
      currentNrDavids=node.getParentNode().getMappedDavidIDs().size();
    }
    float previousLowerHeight=previousNodePosition - rowHeight * (previousNrDavids) / 2;
    float currentUpperHeight=(currentNodePositionY + rowHeight * (currentNrDavids) / 2);
    deviation=previousLowerHeight - currentUpperHeight;
    if (previousNodePosition > 0 && deviation > 0) {
      ElementLayout spacing=new ElementLayout(""String_Node_Str"");
      spacing.setFrameColor(0,0,1,0.8f);
      spacing.setAbsoluteSizeY(deviation);
      dataSetColumn.append(spacing);
      captionColumn.append(spacing);
    }
    previousNodePosition=currentNodePositionY;
    previousNrDavids=currentNrDavids;
    if (nodeCount % 2 == 0)     color=EVEN_BACKGROUND_COLOR;
 else     color=ODD_BACKGROUND_COLOR;
    RelationshipRenderer relationShipRenderer=null;
    if (!isHighlightLayout) {
      relationShipRenderer=new RelationshipRenderer(color,parentView);
      relationShipRenderers.add(relationShipRenderer);
      float x=node.getPosition().x() + parentView.getPixelGLConverter().getGLWidthForPixelWidth(node.getWidthPixels()) / 2;
      float height=parentView.getPixelGLConverter().getGLHeightForPixelHeight(node.getHeightPixels());
      relationShipRenderer.topLeft[0]=x - xOffset;
      relationShipRenderer.topLeft[1]=node.getPosition().y() + height / 2 - yOffset;
      relationShipRenderer.bottomLeft[0]=x - xOffset;
      relationShipRenderer.bottomLeft[1]=node.getPosition().y() - height / 2 - yOffset;
    }
    nodeCount++;
    int idCount=0;
    for (    Integer davidID : subDavidIDs) {
      Row row=new Row(""String_Node_Str"" + davidID);
      row.setAbsoluteSizeY(rowHeight);
      dataSetColumn.append(row);
      for (int tablePerspectiveCount=0; tablePerspectiveCount < geneTablePerspectives.size(); tablePerspectiveCount++) {
        ElementLayout tablePerspectiveLayout=new ElementLayout(""String_Node_Str"" + tablePerspectiveCount + ""String_Node_Str""+ idCount);
        if (!isHighlightLayout) {
          tablePerspectiveLayout.addBackgroundRenderer(new RowBackgroundRenderer(color));
        }
        row.append(tablePerspectiveLayout);
        rowListForTablePerspectives.get(tablePerspectiveCount).add(tablePerspectiveLayout);
        if (tablePerspectiveCount != geneTablePerspectives.size() - 1) {
          row.append(xSpacing);
        }
      }
      ElementLayout rowCaption=new ElementLayout();
      rowCaption.setAbsoluteSizeY(rowHeight);
      if (isHighlightLayout) {
        RowCaptionRenderer captionRenderer=new RowCaptionRenderer(davidIDType,davidID,parentView,this,color);
        rowCaption.setRenderer(captionRenderer);
      }
      captionColumn.append(rowCaption);
      if (!isHighlightLayout) {
        if (relationShipRenderer == null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
 else {
          if (idCount == 0)           relationShipRenderer.topRightLayout=row;
          if (idCount == subDavidIDs.size() - 1)           relationShipRenderer.bottomRightLayout=row;
        }
      }
      idCount++;
    }
  }
  ElementLayout ySpacing=new ElementLayout();
  ySpacing.setPixelSizeY(5);
  dataSetColumn.append(ySpacing);
  Row topCaptionRow=new Row(""String_Node_Str"");
  topCaptionRow.setPixelSizeY(50);
  dataSetColumn.add(0,topCaptionRow);
  Row bottomCaptionRow=new Row(""String_Node_Str"");
  bottomCaptionRow.setPixelSizeY(50);
  dataSetColumn.append(bottomCaptionRow);
  for (int tablePerspectiveCount=0; tablePerspectiveCount < geneTablePerspectives.size(); tablePerspectiveCount++) {
    if (contextualTablePerspectives != null && contextualTablePerspectives.size() > 0) {
      for (      List<TablePerspective> resolvedContextTablePerspectives : contextualTablePerspectives) {
        TablePerspective contextTablePerspective=resolvedContextTablePerspectives.get(tablePerspectiveCount);
        prepareData(contextTablePerspective,rowsForContextTablePerspectives.get(contextTablePerspective),null,null,contextTablePerspective.getDataDomain().getOppositeIDType(sampleIDType),contextRowIDs.get(contextTablePerspective),isHighlightLayout,geneTablePerspectives.get(tablePerspectiveCount));
      }
    }
    ColumnCaptionLayout topCaptionLayout=new ColumnCaptionLayout(parentView,this);
    topCaptionRow.append(topCaptionLayout);
    ColumnCaptionLayout bottomCaptionLayout=new ColumnCaptionLayout(parentView,this);
    bottomCaptionRow.append(bottomCaptionLayout);
    if (tablePerspectiveCount != geneTablePerspectives.size() - 1) {
      bottomCaptionRow.append(xSpacing);
      topCaptionRow.append(xSpacing);
    }
    prepareData(geneTablePerspectives.get(tablePerspectiveCount),rowListForTablePerspectives.get(tablePerspectiveCount),topCaptionLayout,bottomCaptionLayout,davidIDType,davidIDs,isHighlightLayout,null);
  }
  calcMinWidthPixels();
  PixelGLConverter pixelGLConverter=parentView.getPixelGLConverter();
  float minWidth=pixelGLConverter.getGLWidthForPixelWidth(minWidthPixels);
  if (!parentView.isFitWidthToScreen() && viewFrustum.getWidth() < minWidth) {
    viewFrustum.setRight(minWidth);
  }
}",0.9527640071087832
56770,"private DataSetDescription setUpClusteredMatrixData(EDataSetType type,IDSpecification rowIDSpecification,IDSpecification columnIDSpecification,Pair<TCGAFileInfo,Boolean> pair){
  if (pair == null || pair.getFirst() == null)   return null;
  TCGAFileInfo fileInfo=pair.getFirst();
  final File matrixFile=fileInfo.getFile();
  final boolean loadFullGenes=pair.getSecond();
  MetaDataElement metaData=new MetaDataElement();
  DataSetDescription dataSet=new DataSetDescription(ECreateDefaultProperties.NUMERICAL);
  dataSet.setDataSetName(dataSetName);
  dataSet.setColor(dataSetType.getColor());
  dataSet.setDataSourcePath(matrixFile.getPath());
  dataSet.setMetaData(metaData);
  MetaDataElement dataset=new MetaDataElement(""String_Node_Str"");
  metaData.addElement(dataset);
  addDataSourceMetaData(dataset,fileInfo);
  dataset.addAttribute(""String_Node_Str"",new Boolean(loadFullGenes).toString());
  if (!loadFullGenes) {
    dataSet.setNumberOfHeaderLines(3);
    dataSet.getDataDescription().getNumericalProperties().setDataCenter(0d);
  }
 else {
    dataSet.setNumberOfHeaderLines(2);
    dataSet.setRowOfColumnIDs(0);
  }
  ParsingRule parsingRule=new ParsingRule();
  parsingRule.setFromColumn(2);
  parsingRule.setParseUntilEnd(true);
  parsingRule.setColumnDescripton(new ColumnDescription());
  dataSet.addParsingRule(parsingRule);
  dataSet.setTransposeMatrix(true);
  dataSet.setRowIDSpecification(rowIDSpecification);
  dataSet.setColumnIDSpecification(columnIDSpecification);
  MetaDataElement columnGroupings=new MetaDataElement(""String_Node_Str"" + columnIDSpecification.getIdCategory() + ""String_Node_Str"");
  TCGAFileInfo cnmfGroupingFile=fileFinder.findCNMFGroupingFile(type);
  if (cnmfGroupingFile != null) {
    GroupingParseSpecification grouping=new GroupingParseSpecification(cnmfGroupingFile.getFile().getPath());
    grouping.setContainsColumnIDs(false);
    grouping.setRowIDSpecification(columnIDSpecification);
    grouping.setGroupingName(""String_Node_Str"");
    dataSet.addColumnGroupingSpecification(grouping);
    MetaDataElement cnmfClustering=new MetaDataElement(""String_Node_Str"");
    addDataSourceMetaData(cnmfClustering,cnmfGroupingFile);
    columnGroupings.addElement(cnmfClustering);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  TCGAFileInfo hierarchicalGroupingFile=fileFinder.findHiearchicalGrouping(type);
  if (hierarchicalGroupingFile != null) {
    GroupingParseSpecification grouping=new GroupingParseSpecification(hierarchicalGroupingFile.getFile().getPath());
    grouping.setContainsColumnIDs(false);
    grouping.setRowIDSpecification(columnIDSpecification);
    grouping.setGroupingName(""String_Node_Str"");
    dataSet.addColumnGroupingSpecification(grouping);
    MetaDataElement hierarchicalClustering=new MetaDataElement(""String_Node_Str"");
    addDataSourceMetaData(hierarchicalClustering,hierarchicalGroupingFile);
    columnGroupings.addElement(hierarchicalClustering);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  if (!columnGroupings.getElements().isEmpty()) {
    metaData.addElement(columnGroupings);
  }
  DataProcessingDescription dataProcessingDescription=new DataProcessingDescription();
  dataSet.setDataProcessingDescription(dataProcessingDescription);
  MetaDataElement rowGroupings=new MetaDataElement(""String_Node_Str"" + rowIDSpecification.getIdCategory() + ""String_Node_Str"");
  ClusterConfiguration clusterConfiguration=new ClusterConfiguration();
  clusterConfiguration.setDistanceMeasure(EDistanceMeasure.EUCLIDEAN_DISTANCE);
switch (settings.getCluster()) {
case NONE:
    break;
case AFFINITY:
  AffinityClusterConfiguration affinityAlgo=new AffinityClusterConfiguration();
Integer clusterFactor=9;
affinityAlgo.setClusterFactor(clusterFactor);
affinityAlgo.setCacheVectors(true);
clusterConfiguration.setClusterAlgorithmConfiguration(affinityAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
MetaDataElement affinityCluster=new MetaDataElement(""String_Node_Str"");
affinityCluster.addAttribute(""String_Node_Str"",clusterFactor.toString());
rowGroupings.addElement(affinityCluster);
break;
case KMEANS:
KMeansClusterConfiguration kMeansAlgo=new KMeansClusterConfiguration();
Integer numClusters=5;
kMeansAlgo.setNumberOfClusters(numClusters);
kMeansAlgo.setCacheVectors(true);
clusterConfiguration.setClusterAlgorithmConfiguration(kMeansAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
MetaDataElement kmeansCluster=new MetaDataElement(""String_Node_Str"");
kmeansCluster.addAttribute(""String_Node_Str"",numClusters.toString());
rowGroupings.addElement(kmeansCluster);
break;
case TREE:
TreeClusterConfiguration treeAlgo=new TreeClusterConfiguration();
ETreeClustererAlgo algo=ETreeClustererAlgo.AVERAGE_LINKAGE;
treeAlgo.setTreeClustererAlgo(algo);
clusterConfiguration.setClusterAlgorithmConfiguration(treeAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
MetaDataElement treeCluster=new MetaDataElement(""String_Node_Str"");
treeCluster.addAttribute(""String_Node_Str"",algo.getName());
rowGroupings.addElement(treeCluster);
break;
default :
log.log(Level.ALL,""String_Node_Str"" + settings.getCluster());
break;
}
if (!rowGroupings.getElements().isEmpty()) {
metaData.addElement(rowGroupings);
}
if (loadFullGenes) {
NumericalProperties numProp=dataSet.getDataDescription().getNumericalProperties();
numProp.setzScoreNormalization(NumericalProperties.ZSCORE_ROWS);
Float stdDevFactor=4f;
numProp.setClipToStdDevFactor(stdDevFactor);
Integer numRowsInSample=1500;
dataProcessingDescription.setNrRowsInSample(numRowsInSample);
MetaDataElement processing=new MetaDataElement(""String_Node_Str"");
processing.addElement(new MetaDataElement(""String_Node_Str"" + rowIDSpecification.getIdCategory()));
processing.addElement(new MetaDataElement(""String_Node_Str"" + stdDevFactor.toString() + ""String_Node_Str""));
processing.addElement(new MetaDataElement(""String_Node_Str"" + rowIDSpecification.getIdCategory() + ""String_Node_Str""+ numRowsInSample.toString()+ ""String_Node_Str""));
metaData.addElement(processing);
dataProcessingDescription.setNrRowsInSample(1500);
numProp.setImputeDescription(new KNNImputeDescription());
processing.addElement(new MetaDataElement(""String_Node_Str""));
}
return dataSet;
}","private DataSetDescription setUpClusteredMatrixData(EDataSetType type,IDSpecification rowIDSpecification,IDSpecification columnIDSpecification,Pair<TCGAFileInfo,Boolean> pair){
  if (pair == null || pair.getFirst() == null)   return null;
  TCGAFileInfo fileInfo=pair.getFirst();
  final File matrixFile=fileInfo.getFile();
  final boolean loadFullGenes=pair.getSecond();
  MetaDataElement metaData=new MetaDataElement();
  DataSetDescription dataSet=new DataSetDescription(ECreateDefaultProperties.NUMERICAL);
  dataSet.setDataSetName(dataSetName);
  dataSet.setColor(dataSetType.getColor());
  dataSet.setDataSourcePath(matrixFile.getPath());
  dataSet.setMetaData(metaData);
  MetaDataElement dataset=new MetaDataElement(""String_Node_Str"");
  metaData.addElement(dataset);
  addDataSourceMetaData(dataset,fileInfo);
  dataset.addAttribute(""String_Node_Str"",new Boolean(loadFullGenes).toString());
  ParsingRule parsingRule=new ParsingRule();
  parsingRule.setParseUntilEnd(true);
  parsingRule.setColumnDescripton(new ColumnDescription());
  if (!loadFullGenes) {
    parsingRule.setFromColumn(2);
    dataSet.setNumberOfHeaderLines(3);
    dataSet.getDataDescription().getNumericalProperties().setDataCenter(0d);
  }
 else {
    parsingRule.setFromColumn(1);
    dataSet.setNumberOfHeaderLines(1);
    dataSet.setRowOfColumnIDs(0);
  }
  dataSet.addParsingRule(parsingRule);
  dataSet.setTransposeMatrix(true);
  dataSet.setRowIDSpecification(rowIDSpecification);
  dataSet.setColumnIDSpecification(columnIDSpecification);
  MetaDataElement columnGroupings=new MetaDataElement(""String_Node_Str"" + columnIDSpecification.getIdCategory() + ""String_Node_Str"");
  TCGAFileInfo cnmfGroupingFile=fileFinder.findCNMFGroupingFile(type);
  if (cnmfGroupingFile != null) {
    GroupingParseSpecification grouping=new GroupingParseSpecification(cnmfGroupingFile.getFile().getPath());
    grouping.setContainsColumnIDs(false);
    grouping.setRowIDSpecification(columnIDSpecification);
    grouping.setGroupingName(""String_Node_Str"");
    dataSet.addColumnGroupingSpecification(grouping);
    MetaDataElement cnmfClustering=new MetaDataElement(""String_Node_Str"");
    addDataSourceMetaData(cnmfClustering,cnmfGroupingFile);
    columnGroupings.addElement(cnmfClustering);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  TCGAFileInfo hierarchicalGroupingFile=fileFinder.findHiearchicalGrouping(type);
  if (hierarchicalGroupingFile != null) {
    GroupingParseSpecification grouping=new GroupingParseSpecification(hierarchicalGroupingFile.getFile().getPath());
    grouping.setContainsColumnIDs(false);
    grouping.setRowIDSpecification(columnIDSpecification);
    grouping.setGroupingName(""String_Node_Str"");
    dataSet.addColumnGroupingSpecification(grouping);
    MetaDataElement hierarchicalClustering=new MetaDataElement(""String_Node_Str"");
    addDataSourceMetaData(hierarchicalClustering,hierarchicalGroupingFile);
    columnGroupings.addElement(hierarchicalClustering);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  if (!columnGroupings.getElements().isEmpty()) {
    metaData.addElement(columnGroupings);
  }
  DataProcessingDescription dataProcessingDescription=new DataProcessingDescription();
  dataSet.setDataProcessingDescription(dataProcessingDescription);
  MetaDataElement rowGroupings=new MetaDataElement(""String_Node_Str"" + rowIDSpecification.getIdCategory() + ""String_Node_Str"");
  ClusterConfiguration clusterConfiguration=new ClusterConfiguration();
  clusterConfiguration.setDistanceMeasure(EDistanceMeasure.EUCLIDEAN_DISTANCE);
switch (settings.getCluster()) {
case NONE:
    break;
case AFFINITY:
  AffinityClusterConfiguration affinityAlgo=new AffinityClusterConfiguration();
Integer clusterFactor=9;
affinityAlgo.setClusterFactor(clusterFactor);
affinityAlgo.setCacheVectors(true);
clusterConfiguration.setClusterAlgorithmConfiguration(affinityAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
MetaDataElement affinityCluster=new MetaDataElement(""String_Node_Str"");
affinityCluster.addAttribute(""String_Node_Str"",clusterFactor.toString());
rowGroupings.addElement(affinityCluster);
break;
case KMEANS:
KMeansClusterConfiguration kMeansAlgo=new KMeansClusterConfiguration();
Integer numClusters=5;
kMeansAlgo.setNumberOfClusters(numClusters);
kMeansAlgo.setCacheVectors(true);
clusterConfiguration.setClusterAlgorithmConfiguration(kMeansAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
MetaDataElement kmeansCluster=new MetaDataElement(""String_Node_Str"");
kmeansCluster.addAttribute(""String_Node_Str"",numClusters.toString());
rowGroupings.addElement(kmeansCluster);
break;
case TREE:
TreeClusterConfiguration treeAlgo=new TreeClusterConfiguration();
ETreeClustererAlgo algo=ETreeClustererAlgo.AVERAGE_LINKAGE;
treeAlgo.setTreeClustererAlgo(algo);
clusterConfiguration.setClusterAlgorithmConfiguration(treeAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
MetaDataElement treeCluster=new MetaDataElement(""String_Node_Str"");
treeCluster.addAttribute(""String_Node_Str"",algo.getName());
rowGroupings.addElement(treeCluster);
break;
default :
log.log(Level.ALL,""String_Node_Str"" + settings.getCluster());
break;
}
if (!rowGroupings.getElements().isEmpty()) {
metaData.addElement(rowGroupings);
}
if (loadFullGenes) {
NumericalProperties numProp=dataSet.getDataDescription().getNumericalProperties();
numProp.setzScoreNormalization(NumericalProperties.ZSCORE_ROWS);
Float stdDevFactor=4f;
numProp.setClipToStdDevFactor(stdDevFactor);
Integer numRowsInSample=1500;
dataProcessingDescription.setNrRowsInSample(numRowsInSample);
MetaDataElement processing=new MetaDataElement(""String_Node_Str"");
processing.addElement(new MetaDataElement(""String_Node_Str"" + rowIDSpecification.getIdCategory()));
processing.addElement(new MetaDataElement(""String_Node_Str"" + stdDevFactor.toString() + ""String_Node_Str""));
processing.addElement(new MetaDataElement(""String_Node_Str"" + rowIDSpecification.getIdCategory() + ""String_Node_Str""+ numRowsInSample.toString()+ ""String_Node_Str""));
metaData.addElement(processing);
dataProcessingDescription.setNrRowsInSample(1500);
numProp.setImputeDescription(new KNNImputeDescription());
processing.addElement(new MetaDataElement(""String_Node_Str""));
}
return dataSet;
}",0.969279493269992
56771,"@Override protected ADataDomainQuery createFor(IDataDomain dd){
  return new InhomogenousDataDomainQuery((ATableBasedDataDomain)dd,Sets.immutableEnumSet(EDataClass.NATURAL_NUMBER,EDataClass.REAL_NUMBER));
}","protected ADataDomainQuery createFor(IDataDomain dd){
  return new InhomogenousDataDomainQuery((ATableBasedDataDomain)dd,Sets.immutableEnumSet(EDataClass.NATURAL_NUMBER,EDataClass.REAL_NUMBER));
}",0.9751243781094528
56772,"@Override public boolean filterBoundView(IDataDomain dataDomain){
  return true;
}","@Override public boolean filterBoundView(ADataDomainQuery query){
  return true;
}",0.8658536585365854
56773,"@Override public void render(GL2 gl,float x,float y,List<SelectionType> selectionTypes){
  if (average == null)   return;
  colorCalculator.setBaseColor(MappedDataRenderer.SUMMARY_BAR_COLOR);
  List<List<SelectionType>> selectionLists=new ArrayList<List<SelectionType>>();
  selectionLists.add(selectionTypes);
  colorCalculator.calculateColors(Algorithms.mergeListsToUniqueList(selectionLists));
  float[] topBarColor=colorCalculator.getPrimaryColor().getRGBA();
  float[] bottomBarColor=colorCalculator.getSecondaryColor().getRGBA();
  gl.glPushName(contentRenderer.parentView.getPickingManager().getPickingID(contentRenderer.parentView.getID(),EPickingType.SAMPLE_GROUP_RENDERER.name(),rendererID));
  gl.glBegin(GL2GL3.GL_QUADS);
  gl.glColor4fv(bottomBarColor,0);
  gl.glVertex3f(0,y / 3,z);
  gl.glColor3f(bottomBarColor[0] * 0.9f,bottomBarColor[1] * 0.9f,bottomBarColor[2] * 0.9f);
  gl.glVertex3d(average.getArithmeticMean() * x,y / 3,z);
  gl.glColor3f(topBarColor[0] * 0.9f,topBarColor[1] * 0.9f,topBarColor[2] * 0.9f);
  gl.glVertex3d(average.getArithmeticMean() * x,y / 3 * 2,z);
  gl.glColor4fv(topBarColor,0);
  gl.glVertex3f(0,y / 3 * 2,z);
  gl.glEnd();
  gl.glColor3f(0,0,0);
  gl.glLineWidth(0.5f);
  gl.glBegin(GL.GL_LINE_STRIP);
  gl.glVertex3f(0,y / 3,z);
  gl.glVertex3d(average.getArithmeticMean() * x,y / 3,z);
  gl.glVertex3d(average.getArithmeticMean() * x,y / 3 * 2,z);
  gl.glVertex3f(0,y / 3 * 2,z);
  gl.glEnd();
  float lineZ=z + 0.01f;
  gl.glColor3f(0,0,0);
  gl.glLineWidth(0.8f);
  float xMinusDeviation=(float)(average.getArithmeticMean() - average.getStandardDeviation()) * x;
  float xPlusDeviation=(float)(average.getArithmeticMean() + average.getStandardDeviation()) * x;
  float lineTailHeight=contentRenderer.parentView.getPixelGLConverter().getGLHeightForPixelHeight(3);
  gl.glBegin(GL.GL_LINES);
  gl.glVertex3f(xMinusDeviation,y / 2,lineZ);
  gl.glVertex3f(xPlusDeviation,y / 2,lineZ);
  gl.glLineWidth(0.6f);
  gl.glVertex3f(xPlusDeviation,y / 2 - lineTailHeight,lineZ);
  gl.glVertex3f(xPlusDeviation,y / 2 + lineTailHeight,lineZ);
  gl.glVertex3f(xMinusDeviation,y / 2 - lineTailHeight,lineZ);
  gl.glVertex3f(xMinusDeviation,y / 2 + lineTailHeight,lineZ);
  gl.glEnd();
  gl.glPopName();
}","@Override public void render(GL2 gl,float x,float y,List<SelectionType> selectionTypes){
  if (average == null)   return;
  colorCalculator.setBaseColor(MappedDataRenderer.SUMMARY_BAR_COLOR);
  List<List<SelectionType>> selectionLists=new ArrayList<List<SelectionType>>();
  selectionLists.add(selectionTypes);
  colorCalculator.calculateColors(Algorithms.mergeListsToUniqueList(selectionLists));
  float[] topBarColor=colorCalculator.getPrimaryColor().getRGBA();
  float[] bottomBarColor=colorCalculator.getSecondaryColor().getRGBA();
  gl.glPushName(contentRenderer.parentView.getPickingManager().getPickingID(contentRenderer.parentView.getID(),EPickingType.SAMPLE_GROUP_RENDERER.name(),rendererID));
  gl.glBegin(GL2GL3.GL_QUADS);
  gl.glColor4fv(bottomBarColor,0);
  gl.glVertex3f(0,y / 3,z);
  gl.glColor3f(bottomBarColor[0] * 0.9f,bottomBarColor[1] * 0.9f,bottomBarColor[2] * 0.9f);
  gl.glVertex3d(average.getArithmeticMean() * x,y / 3,z);
  gl.glColor3f(topBarColor[0] * 0.9f,topBarColor[1] * 0.9f,topBarColor[2] * 0.9f);
  gl.glVertex3d(average.getArithmeticMean() * x,y / 3 * 2,z);
  gl.glColor4fv(topBarColor,0);
  gl.glVertex3f(0,y / 3 * 2,z);
  gl.glEnd();
  gl.glColor3f(0,0,0);
  gl.glLineWidth(0.5f);
  gl.glBegin(GL.GL_LINE_STRIP);
  gl.glVertex3f(0,y / 3,z);
  gl.glVertex3d(average.getArithmeticMean() * x,y / 3,z);
  gl.glVertex3d(average.getArithmeticMean() * x,y / 3 * 2,z);
  gl.glVertex3f(0,y / 3 * 2,z);
  gl.glEnd();
  float lineZ=z + 0.01f;
  gl.glColor3f(0,0,0);
  gl.glLineWidth(0.8f);
  float xMinusDeviation=(float)(average.getArithmeticMean() - average.getStandardDeviation()) * x;
  float xPlusDeviation=(float)(average.getArithmeticMean() + average.getStandardDeviation()) * x;
  float lineTailHeight=contentRenderer.parentView.getPixelGLConverter().getGLHeightForPixelHeight(3);
  gl.glBegin(GL.GL_LINES);
  gl.glVertex3f(xMinusDeviation,y / 2,lineZ);
  gl.glVertex3f(xPlusDeviation,y / 2,lineZ);
  gl.glVertex3f(xPlusDeviation,y / 2 - lineTailHeight,lineZ);
  gl.glVertex3f(xPlusDeviation,y / 2 + lineTailHeight,lineZ);
  gl.glVertex3f(xMinusDeviation,y / 2 - lineTailHeight,lineZ);
  gl.glVertex3f(xMinusDeviation,y / 2 + lineTailHeight,lineZ);
  gl.glEnd();
  gl.glPopName();
}",0.994611585092052
56774,"private void overlayBubbleSets(GL2 gl){
  if (isBubbleTextureDirty) {
    this.bubbleSet.clear();
    this.alternativeBubbleSet.clear();
    this.bubbleSet.setPathwayGraph(pathway);
    this.alternativeBubbleSet.setPathwayGraph(pathway);
    boolean renderAlternatives=false;
    for (    PathwayPath pathSegment : pathSegments) {
      if (pathSegment.getPathway() == pathway) {
        renderAlternatives=true;
        continue;
      }
    }
    if (!renderAlternatives) {
      allPathsList.clear();
    }
    for (    Pair<List<GraphPath<PathwayVertexRep,DefaultEdge>>,Integer> pathsPair : allPathsList) {
      List<GraphPath<PathwayVertexRep,DefaultEdge>> paths=pathsPair.getFirst();
      this.alternativeBubbleSet.addAllPaths(paths,pathsPair.getSecond());
    }
    this.bubbleSet.addPathSegements(pathSegments);
    this.bubbleSet.addPathSegements(pathSegments);
    if (this.highlightVertices) {
      ((BubbleSet)(bubbleSet.getBubbleSetGLRenderer().setOutline)).setParameter(100,20,3,10.0,7.0,0.5,2.5,15.0,8);
    }
 else {
      ((BubbleSet)(bubbleSet.getBubbleSetGLRenderer().setOutline)).setParameter(10,10,3,10.0,20.0,20.5,15.5,5.0,5);
    }
    this.bubbleSet.getBubbleSetGLRenderer().setSize(pathway.getWidth(),pathway.getHeight());
    this.bubbleSet.getBubbleSetGLRenderer().update(gl,null,0);
    alternativeBubbleSet.getBubbleSetGLRenderer().setSize(pathway.getWidth(),pathway.getHeight());
    alternativeBubbleSet.getBubbleSetGLRenderer().update(gl,null,0);
    isBubbleTextureDirty=false;
  }
  gl.glPushName(ViewManager.get().getPickingManager().getPickingID(uniqueID,EPickingType.PATHWAY_TEXTURE_SELECTION.name(),0));
  this.alternativeBubbleSet.getBubbleSetGLRenderer().render(gl,pixelGLConverter.getGLWidthForPixelWidth(pathway.getWidth()),pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight()),0.25f);
  if (this.highlightVertices) {
    this.bubbleSet.getBubbleSetGLRenderer().render(gl,pixelGLConverter.getGLWidthForPixelWidth(pathway.getWidth()),pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight()));
  }
 else {
    this.bubbleSet.getBubbleSetGLRenderer().render(gl,pixelGLConverter.getGLWidthForPixelWidth(pathway.getWidth()),pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight()),1.0f);
  }
  gl.glPopName();
}","private void overlayBubbleSets(GL2 gl){
  if (isBubbleTextureDirty) {
    this.bubbleSet.clear();
    this.alternativeBubbleSet.clear();
    this.bubbleSet.setPathwayGraph(pathway);
    this.alternativeBubbleSet.setPathwayGraph(pathway);
    boolean renderAlternatives=false;
    for (    PathwayPath pathSegment : pathSegments) {
      if (pathSegment.getPathway() == pathway) {
        renderAlternatives=true;
        continue;
      }
    }
    if (!renderAlternatives) {
      allPathsList.clear();
    }
    for (    Pair<List<GraphPath<PathwayVertexRep,DefaultEdge>>,Integer> pathsPair : allPathsList) {
      List<GraphPath<PathwayVertexRep,DefaultEdge>> paths=pathsPair.getFirst();
      this.alternativeBubbleSet.addAllPaths(paths,pathsPair.getSecond());
    }
    this.bubbleSet.addPathSegements(pathSegments);
    if (this.highlightVertices) {
      ((BubbleSet)(bubbleSet.getBubbleSetGLRenderer().setOutline)).setParameter(100,20,3,10.0,7.0,0.5,2.5,15.0,8);
    }
 else {
      ((BubbleSet)(bubbleSet.getBubbleSetGLRenderer().setOutline)).setParameter(10,10,3,10.0,20.0,20.5,15.5,5.0,5);
    }
    this.bubbleSet.getBubbleSetGLRenderer().setSize(pathway.getWidth(),pathway.getHeight());
    this.bubbleSet.getBubbleSetGLRenderer().update(gl,null,0);
    alternativeBubbleSet.getBubbleSetGLRenderer().setSize(pathway.getWidth(),pathway.getHeight());
    alternativeBubbleSet.getBubbleSetGLRenderer().update(gl,null,0);
    isBubbleTextureDirty=false;
  }
  gl.glPushName(ViewManager.get().getPickingManager().getPickingID(uniqueID,EPickingType.PATHWAY_TEXTURE_SELECTION.name(),0));
  this.alternativeBubbleSet.getBubbleSetGLRenderer().render(gl,pixelGLConverter.getGLWidthForPixelWidth(pathway.getWidth()),pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight()),0.25f);
  if (this.highlightVertices) {
    this.bubbleSet.getBubbleSetGLRenderer().render(gl,pixelGLConverter.getGLWidthForPixelWidth(pathway.getWidth()),pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight()));
  }
 else {
    this.bubbleSet.getBubbleSetGLRenderer().render(gl,pixelGLConverter.getGLWidthForPixelWidth(pathway.getWidth()),pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight()),1.0f);
  }
  gl.glPopName();
}",0.988664147588353
56775,"private void selectNextPath(boolean inc){
  if (this.allPathsList.size() < 1)   return;
  List<GraphPath<PathwayVertexRep,DefaultEdge>> paths=this.allPathsList.get(this.allPathsList.size() - 1).getFirst();
  if (paths.size() > 1) {
    if (inc)     selectedPathID++;
 else     selectedPathID--;
    if (selectedPathID < 0)     selectedPathID=0;
    if (selectedPathID > paths.size() - 1)     selectedPathID=paths.size() - 1;
    if (allPaths.size() > 0) {
      selectedPath=paths.get(selectedPathID);
      if (selectedPath.getEdgeList().size() > 0 && !isShiftKeyDown) {
        PathwayVertexRep startPrevVertex=selectedPath.getStartVertex();
        PathwayVertexRep endPrevVertex=selectedPath.getEndVertex();
        List<DefaultEdge> edgePrevList=selectedPath.getEdgeList();
        previousSelectedPath=new GraphPathImpl<PathwayVertexRep,DefaultEdge>(pathway,startPrevVertex,endPrevVertex,edgePrevList,0);
      }
    }
  }
 else {
    selectedPathID=0;
  }
  this.allPathsList.get(this.allPathsList.size() - 1).setSecond(selectedPathID);
  isBubbleTextureDirty=true;
  setDisplayListDirty();
  triggerPathUpdate();
}","private void selectNextPath(boolean inc){
  if (this.allPathsList.size() < 1)   return;
  List<GraphPath<PathwayVertexRep,DefaultEdge>> paths=this.allPathsList.get(this.allPathsList.size() - 1).getFirst();
  if (paths.size() > 1) {
    if (inc)     selectedPathID++;
 else     selectedPathID--;
    if (selectedPathID < 0)     selectedPathID=paths.size() - 1;
    if (selectedPathID > paths.size() - 1)     selectedPathID=0;
    if (allPaths.size() > 0) {
      selectedPath=paths.get(selectedPathID);
      if (selectedPath.getEdgeList().size() > 0 && !isShiftKeyDown) {
        PathwayVertexRep startPrevVertex=selectedPath.getStartVertex();
        PathwayVertexRep endPrevVertex=selectedPath.getEndVertex();
        List<DefaultEdge> edgePrevList=selectedPath.getEdgeList();
        previousSelectedPath=new GraphPathImpl<PathwayVertexRep,DefaultEdge>(pathway,startPrevVertex,endPrevVertex,edgePrevList,0);
      }
    }
  }
 else {
    selectedPathID=0;
  }
  this.allPathsList.get(this.allPathsList.size() - 1).setSecond(selectedPathID);
  isBubbleTextureDirty=true;
  setDisplayListDirty();
  triggerPathUpdate();
}",0.928698752228164
56776,"@Override public boolean performFinish(){
  ChooseProjectTypePage page=getChosenProjectTypePage();
  Pair<String,IStartupAddon> addon=page.getSelectedAddon();
  if (page.isPageComplete() && addon.getSecond().validate()) {
    MyPreferences.setLastChosenProjectMode(addon.getFirst());
    MyPreferences.flush();
    setResult(addon.getSecond().create());
    return true;
  }
  return false;
}","@Override public boolean performFinish(){
  ChooseProjectTypePage page=getChosenProjectTypePage();
  Pair<String,IStartupAddon> addon=page.getSelectedAddon();
  if (page.isPageComplete()) {
    MyPreferences.setLastChosenProjectMode(addon.getFirst());
    MyPreferences.flush();
    setResult(addon.getSecond().create());
    return true;
  }
  return false;
}",0.9574468085106383
56777,"@Override public void createControl(Composite parent){
  Composite composite=new Composite(parent,SWT.NONE);
  composite.setLayout(new GridLayout(1,false));
  this.tabFolder=new TabFolder(composite,SWT.BORDER);
  GridData gridData=new GridData(GridData.FILL_BOTH);
  gridData.widthHint=WIDTH;
  tabFolder.setLayoutData(gridData);
  String previous=MyPreferences.getLastChosenProjectMode();
  for (  Map.Entry<String,IStartupAddon> addon : addons.entrySet()) {
    Composite tabContent=addon.getValue().create(tabFolder,this);
    if (tabContent == null)     continue;
    tabContent.pack();
    TabItem item=new TabItem(tabFolder,SWT.NONE);
    item.setText(addon.getKey());
    item.setControl(tabContent);
    item.setData(Pair.make(addon.getKey(),addon.getValue()));
    if (Objects.equals(previous,addon.getKey()))     tabFolder.setSelection(item);
  }
  tabFolder.pack();
  this.setControl(composite);
  composite.pack();
}","@Override public void createControl(Composite parent){
  Composite composite=new Composite(parent,SWT.NONE);
  composite.setLayout(new GridLayout(1,false));
  this.tabFolder=new TabFolder(composite,SWT.BORDER);
  GridData gridData=new GridData(GridData.FILL_BOTH);
  gridData.widthHint=WIDTH;
  tabFolder.setLayoutData(gridData);
  tabFolder.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      setPageComplete(true);
      updateButtons();
    }
  }
);
  String previous=MyPreferences.getLastChosenProjectMode();
  for (  Map.Entry<String,IStartupAddon> addon : addons.entrySet()) {
    Composite tabContent=addon.getValue().create(tabFolder,this,this);
    if (tabContent == null)     continue;
    tabContent.pack();
    TabItem item=new TabItem(tabFolder,SWT.NONE);
    item.setText(addon.getKey());
    item.setControl(tabContent);
    item.setData(Pair.make(addon.getKey(),addon.getValue()));
    if (Objects.equals(previous,addon.getKey()))     tabFolder.setSelection(item);
  }
  tabFolder.pack();
  this.setControl(composite);
  composite.pack();
}",0.9066927210552028
56778,"private Button createSample(String url,String name,String description,Composite g,SelectionListener l,boolean first){
  try {
    URL u=new URL(url);
    Button button=new Button(g,SWT.RADIO);
    button.setText(name);
    FontUtil.makeBold(button);
    button.setData(u);
    button.addSelectionListener(l);
    GridData gd=new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING);
    gd.verticalIndent=first ? 0 : 20;
    button.setLayoutData(gd);
    if (url.equals(MyPreferences.getLastChosenSampleProject())) {
      button.setSelection(true);
      selectedChoice=u;
    }
    Link desc=new Link(g,SWT.WRAP);
    desc.setText(description);
    desc.addSelectionListener(BrowserUtils.LINK_LISTENER);
    gd=new GridData(GridData.FILL_HORIZONTAL);
    desc.setLayoutData(gd);
    return button;
  }
 catch (  MalformedURLException e) {
    System.err.println(""String_Node_Str"" + url);
    return null;
  }
}","private Button createSample(String url,String name,String description,Composite g,SelectionListener l,boolean first,Listener listener){
  try {
    URL u=new URL(url);
    Button button=new Button(g,SWT.RADIO);
    button.setText(name);
    FontUtil.makeBold(button);
    button.setData(u);
    button.addSelectionListener(l);
    button.addListener(SWT.Selection,listener);
    GridData gd=new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING);
    gd.verticalIndent=first ? 0 : 20;
    button.setLayoutData(gd);
    if (url.equals(MyPreferences.getLastChosenSampleProject())) {
      button.setSelection(true);
      selectedChoice=u;
    }
    Link desc=new Link(g,SWT.WRAP);
    desc.setText(description);
    desc.addSelectionListener(BrowserUtils.LINK_LISTENER);
    gd=new GridData(GridData.FILL_HORIZONTAL);
    desc.setLayoutData(gd);
    return button;
  }
 catch (  MalformedURLException e) {
    System.err.println(""String_Node_Str"" + url);
    return null;
  }
}",0.964818763326226
56779,"private TreeViewer createSelectionTree(final SashForm form,final WizardPage page){
  final TreeViewer v=new TreeViewer(form,SWT.VIRTUAL | SWT.BORDER);
  v.setLabelProvider(new LabelProvider());
  v.setContentProvider(new MyContentProvider(v));
  v.setUseHashlookup(true);
  v.addSelectionChangedListener(new ISelectionChangedListener(){
    @Override public void selectionChanged(    SelectionChangedEvent event){
      IStructuredSelection s=(IStructuredSelection)event.getSelection();
      Object f=s.getFirstElement();
      if (f instanceof TumorProject) {
        selectedChoice=((TumorProject)f).getProject();
        page.setPageComplete(true);
      }
 else {
        selectedChoice=null;
        page.setPageComplete(false);
      }
      if (f instanceof TumorProject) {
        updateDetailInfo((TumorProject)f);
        form.setMaximizedControl(null);
      }
 else       if (f instanceof RunOverview) {
        updateDetailInfo((RunOverview)f);
        clearDetailInfo();
        form.setMaximizedControl(v.getControl());
      }
 else {
        clearDetailInfo();
        form.setMaximizedControl(v.getControl());
      }
    }
  }
);
  return v;
}","private TreeViewer createSelectionTree(final SashForm form,final WizardPage page,final Listener listener){
  final TreeViewer v=new TreeViewer(form,SWT.VIRTUAL | SWT.BORDER);
  v.setLabelProvider(new LabelProvider());
  v.setContentProvider(new MyContentProvider(v));
  v.setUseHashlookup(true);
  v.addSelectionChangedListener(new ISelectionChangedListener(){
    @Override public void selectionChanged(    SelectionChangedEvent event){
      IStructuredSelection s=(IStructuredSelection)event.getSelection();
      Object f=s.getFirstElement();
      if (f instanceof TumorProject) {
        selectedChoice=((TumorProject)f).getProject();
        page.setPageComplete(true);
      }
 else {
        selectedChoice=null;
        page.setPageComplete(false);
      }
      if (f instanceof TumorProject) {
        updateDetailInfo((TumorProject)f);
        form.setMaximizedControl(null);
      }
 else       if (f instanceof RunOverview) {
        updateDetailInfo((RunOverview)f);
        clearDetailInfo();
        form.setMaximizedControl(v.getControl());
      }
 else {
        clearDetailInfo();
        form.setMaximizedControl(v.getControl());
      }
      listener.handleEvent(null);
    }
  }
);
  return v;
}",0.9756711409395972
56780,"@Override public void selectionChanged(SelectionChangedEvent event){
  IStructuredSelection s=(IStructuredSelection)event.getSelection();
  Object f=s.getFirstElement();
  if (f instanceof TumorProject) {
    selectedChoice=((TumorProject)f).getProject();
    page.setPageComplete(true);
  }
 else {
    selectedChoice=null;
    page.setPageComplete(false);
  }
  if (f instanceof TumorProject) {
    updateDetailInfo((TumorProject)f);
    form.setMaximizedControl(null);
  }
 else   if (f instanceof RunOverview) {
    updateDetailInfo((RunOverview)f);
    clearDetailInfo();
    form.setMaximizedControl(v.getControl());
  }
 else {
    clearDetailInfo();
    form.setMaximizedControl(v.getControl());
  }
}","@Override public void selectionChanged(SelectionChangedEvent event){
  IStructuredSelection s=(IStructuredSelection)event.getSelection();
  Object f=s.getFirstElement();
  if (f instanceof TumorProject) {
    selectedChoice=((TumorProject)f).getProject();
    page.setPageComplete(true);
  }
 else {
    selectedChoice=null;
    page.setPageComplete(false);
  }
  if (f instanceof TumorProject) {
    updateDetailInfo((TumorProject)f);
    form.setMaximizedControl(null);
  }
 else   if (f instanceof RunOverview) {
    updateDetailInfo((RunOverview)f);
    clearDetailInfo();
    form.setMaximizedControl(v.getControl());
  }
 else {
    clearDetailInfo();
    form.setMaximizedControl(v.getControl());
  }
  listener.handleEvent(null);
}",0.9792817679558012
56781,"@Override public void onRowClick(RankTableModel table,PickingMode pickingMode,AScoreRow row,boolean isSelected){
}","@Override public void onRowClick(RankTableModel table,PickingMode pickingMode,AScoreRow row,boolean isSelected,IGLElementContext context){
}",0.8976377952755905
56782,"@Override protected void parseFile(BufferedReader reader) throws IOException {
  SubMonitor monitor=GeneralManager.get().createSubProgressMonitor();
  monitor.beginTask(""String_Node_Str"" + dataSetDescription.getDataSetName(),calculateNumberOfLinesInFile());
  initializTables();
  for (int countHeaderLines=0; countHeaderLines < dataSetDescription.getNumberOfHeaderLines(); countHeaderLines++) {
    reader.readLine();
  }
  monitor.worked(dataSetDescription.getNumberOfHeaderLines());
  List<ColumnDescription> parsingPattern=dataSetDescription.getOrCreateParsingPattern();
  int lineCounter=0;
  StringBuilder numberParsingErrorMessage=new StringBuilder(""String_Node_Str"").append(dataSetDescription.getDataSetName()).append(""String_Node_Str"").append(filePath).append(""String_Node_Str"");
  final int numberParsingErrorMessageEmpty=numberParsingErrorMessage.length();
  IDSpecification rowIDSpecification=dataSetDescription.getRowIDSpecification();
  IDCategory rowIDCategory=IDCategory.getIDCategory(rowIDSpecification.getIdCategory());
  IDType fromIDType=IDType.getIDType(rowIDSpecification.getIdType());
  IDType toIDType;
  if (dataDomain.isColumnDimension())   toIDType=dataDomain.getRecordIDType();
 else   toIDType=dataDomain.getDimensionIDType();
  IDMappingManager rowIDMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(rowIDCategory);
  int columnOfRowIDs=dataSetDescription.getColumnOfRowIds();
  MappingType mappingType=rowIDMappingManager.createMap(fromIDType,toIDType,false,true);
  IDTypeParsingRules parsingRules=null;
  if (rowIDSpecification.getIdTypeParsingRules() != null)   parsingRules=rowIDSpecification.getIdTypeParsingRules();
 else   if (toIDType.getIdTypeParsingRules() != null)   parsingRules=fromIDType.getIdTypeParsingRules();
  String line;
  DataDescription dataDescription=dataSetDescription.getDataDescription();
  int naCounter=0;
  while ((line=reader.readLine()) != null) {
    String splitLine[]=line.split(dataSetDescription.getDelimiter(),-1);
    String id=splitLine[columnOfRowIDs];
    id=convertID(id,parsingRules);
    rowIDMappingManager.addMapping(mappingType,id,lineCounter);
    for (int count=0; count < parsingPattern.size(); count++) {
      ColumnDescription columnDescription=parsingPattern.get(count);
      if (columnDescription.getDataDescription() != null) {
        dataDescription=columnDescription.getDataDescription();
      }
      String cellContent=splitLine[columnDescription.getColumn()];
      try {
switch (dataDescription.getRawDataType()) {
case FLOAT:
          float floatValue;
        FloatContainer targetColumn=(FloatContainer)targetRawContainer.get(count);
      try {
        if (""String_Node_Str"".equals(cellContent)) {
          naCounter++;
          targetColumn.addUnknown();
          break;
        }
        floatValue=Float.parseFloat(cellContent);
        targetColumn.add(floatValue);
      }
 catch (      NumberFormatException nfe) {
        numberParsingErrorMessage.append(""String_Node_Str"").append(columnDescription.getColumn()).append(""String_Node_Str"").append(lineCounter + dataSetDescription.getNumberOfHeaderLines()).append(""String_Node_Str"").append(cellContent).append(""String_Node_Str"");
        targetColumn.addUnknown();
      }
    break;
case INTEGER:
  Integer intValue;
@SuppressWarnings(""String_Node_Str"") IContainer<Integer> targetIntColumn=(IContainer<Integer>)targetRawContainer.get(count);
try {
if (""String_Node_Str"".equals(cellContent)) {
  naCounter++;
  targetIntColumn.addUnknown();
  break;
}
intValue=Integer.parseInt(cellContent);
targetIntColumn.add(intValue);
}
 catch (NumberFormatException nfe) {
numberParsingErrorMessage.append(""String_Node_Str"").append(columnDescription.getColumn()).append(""String_Node_Str"").append(lineCounter + dataSetDescription.getNumberOfHeaderLines()).append(""String_Node_Str"").append(cellContent).append(""String_Node_Str"");
targetIntColumn.addUnknown();
}
break;
case STRING:
String stringValue=cellContent.trim();
@SuppressWarnings(""String_Node_Str"") IContainer<String> targetStringColumn=(IContainer<String>)targetRawContainer.get(count);
if (stringValue.length() == 0) {
targetStringColumn.addUnknown();
}
 else {
targetStringColumn.add(stringValue);
}
break;
default :
throw new IllegalStateException(""String_Node_Str"" + dataDescription.getRawDataType());
}
}
 catch (IndexOutOfBoundsException ioobe) {
Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"" + lineCounter + ""String_Node_Str""+ count,ioobe));
}
}
if (lineCounter % 100 == 0) {
monitor.worked(100);
}
lineCounter++;
}
if (naCounter > 0) {
numberParsingErrorMessage.append(""String_Node_Str"").append(naCounter);
}
if (numberParsingErrorMessage.length() > numberParsingErrorMessageEmpty) {
Logger.log(new Status(IStatus.ERROR,this.toString(),numberParsingErrorMessage.toString()));
}
monitor.done();
}","@Override protected void parseFile(BufferedReader reader) throws IOException {
  SubMonitor monitor=GeneralManager.get().createSubProgressMonitor();
  monitor.beginTask(""String_Node_Str"" + dataSetDescription.getDataSetName(),calculateNumberOfLinesInFile());
  initializTables();
  for (int countHeaderLines=0; countHeaderLines < dataSetDescription.getNumberOfHeaderLines(); countHeaderLines++) {
    reader.readLine();
  }
  monitor.worked(dataSetDescription.getNumberOfHeaderLines());
  List<ColumnDescription> parsingPattern=dataSetDescription.getOrCreateParsingPattern();
  int lineCounter=0;
  StringBuilder numberParsingErrorMessage=new StringBuilder(""String_Node_Str"").append(dataSetDescription.getDataSetName()).append(""String_Node_Str"").append(filePath).append(""String_Node_Str"");
  final int numberParsingErrorMessageEmpty=numberParsingErrorMessage.length();
  IDSpecification rowIDSpecification=dataSetDescription.getRowIDSpecification();
  IDCategory rowIDCategory=IDCategory.getIDCategory(rowIDSpecification.getIdCategory());
  IDType fromIDType=IDType.getIDType(rowIDSpecification.getIdType());
  IDType toIDType;
  if (dataDomain.isColumnDimension())   toIDType=dataDomain.getRecordIDType();
 else   toIDType=dataDomain.getDimensionIDType();
  IDMappingManager rowIDMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(rowIDCategory);
  int columnOfRowIDs=dataSetDescription.getColumnOfRowIds();
  MappingType mappingType=rowIDMappingManager.createMap(fromIDType,toIDType,false,true);
  IDTypeParsingRules parsingRules=null;
  if (rowIDSpecification.getIdTypeParsingRules() != null)   parsingRules=rowIDSpecification.getIdTypeParsingRules();
 else   if (toIDType.getIdTypeParsingRules() != null)   parsingRules=fromIDType.getIdTypeParsingRules();
  String line;
  DataDescription dataDescription=dataSetDescription.getDataDescription();
  int naCounter=0;
  while ((line=reader.readLine()) != null) {
    String splitLine[]=line.split(dataSetDescription.getDelimiter(),-1);
    String id=splitLine[columnOfRowIDs];
    id=convertID(id,parsingRules);
    rowIDMappingManager.addMapping(mappingType,id,lineCounter);
    for (int count=0; count < parsingPattern.size(); count++) {
      ColumnDescription columnDescription=parsingPattern.get(count);
      if (columnDescription.getDataDescription() != null) {
        dataDescription=columnDescription.getDataDescription();
      }
      int columnIndex=columnDescription.getColumn();
      String cellContent=null;
      if (columnIndex >= splitLine.length) {
        cellContent=""String_Node_Str"";
        Logger.log(new Status(IStatus.WARNING,this.toString(),""String_Node_Str"" + lineCounter + ""String_Node_Str""));
      }
 else {
        cellContent=splitLine[columnIndex];
      }
      try {
switch (dataDescription.getRawDataType()) {
case FLOAT:
          float floatValue;
        FloatContainer targetColumn=(FloatContainer)targetRawContainer.get(count);
      try {
        if (""String_Node_Str"".equals(cellContent)) {
          naCounter++;
          targetColumn.addUnknown();
          break;
        }
        floatValue=Float.parseFloat(cellContent);
        targetColumn.add(floatValue);
      }
 catch (      NumberFormatException nfe) {
        numberParsingErrorMessage.append(""String_Node_Str"").append(columnDescription.getColumn()).append(""String_Node_Str"").append(lineCounter + dataSetDescription.getNumberOfHeaderLines()).append(""String_Node_Str"").append(cellContent).append(""String_Node_Str"");
        targetColumn.addUnknown();
      }
    break;
case INTEGER:
  Integer intValue;
@SuppressWarnings(""String_Node_Str"") IContainer<Integer> targetIntColumn=(IContainer<Integer>)targetRawContainer.get(count);
try {
if (""String_Node_Str"".equals(cellContent)) {
  naCounter++;
  targetIntColumn.addUnknown();
  break;
}
intValue=Integer.parseInt(cellContent);
targetIntColumn.add(intValue);
}
 catch (NumberFormatException nfe) {
numberParsingErrorMessage.append(""String_Node_Str"").append(columnDescription.getColumn()).append(""String_Node_Str"").append(lineCounter + dataSetDescription.getNumberOfHeaderLines()).append(""String_Node_Str"").append(cellContent).append(""String_Node_Str"");
targetIntColumn.addUnknown();
}
break;
case STRING:
String stringValue=cellContent.trim();
@SuppressWarnings(""String_Node_Str"") IContainer<String> targetStringColumn=(IContainer<String>)targetRawContainer.get(count);
if (stringValue.length() == 0) {
targetStringColumn.addUnknown();
}
 else {
targetStringColumn.add(stringValue);
}
break;
default :
throw new IllegalStateException(""String_Node_Str"" + dataDescription.getRawDataType());
}
}
 catch (IndexOutOfBoundsException ioobe) {
Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"" + lineCounter + ""String_Node_Str""+ count,ioobe));
}
}
if (lineCounter % 100 == 0) {
monitor.worked(100);
}
lineCounter++;
}
if (naCounter > 0) {
numberParsingErrorMessage.append(""String_Node_Str"").append(naCounter);
}
if (numberParsingErrorMessage.length() > numberParsingErrorMessageEmpty) {
Logger.log(new Status(IStatus.ERROR,this.toString(),numberParsingErrorMessage.toString()));
}
monitor.done();
}",0.9631484077708792
56783,"@Override public void update(){
  dataDomains=representedView.getDataDomains();
  recalculateNodeSize();
}","@Override public void update(){
  dataDomains=new HashSet<>(representedView.getDataDomains());
  recalculateNodeSize();
}",0.933920704845815
56784,"@Override protected Point2D getPosition(){
  return node.getBottomObjectAnchorPoints(this).getFirst();
}","@Override protected Point2D getPosition(){
  return node.getBottomObjectAnchorPoints(tablePerspective != null ? tablePerspective : this).getFirst();
}",0.8188976377952756
56785,"/** 
 * Exports the dataset identified through the perspectives to the file specified.
 * @param dataDomain
 * @param fileName
 * @param recordPerspective
 * @param dimensionPerspective
 * @param targetRecordIDType the id type to be used in the file. If this is null the  {@link IDCategory#getHumanReadableIDType()}will be used.
 * @param targetDimensionIDType same as targetRecordIDType for dimensions
 * @param includeClusterInfo true if you want to add information about the clustering to the file, else false
 * @return true if export was successful, else false.
 */
public static boolean export(ATableBasedDataDomain dataDomain,String fileName,Perspective recordPerspective,Perspective dimensionPerspective,IDType targetRecordIDType,IDType targetDimensionIDType,boolean includeClusterInfo){
  if (targetRecordIDType == null)   targetRecordIDType=dataDomain.getRecordIDCategory().getHumanReadableIDType();
  if (targetDimensionIDType == null)   targetDimensionIDType=dataDomain.getDimensionIDCategory().getHumanReadableIDType();
  IDType rowTargetIDType;
  IDType rowSourceIDType;
  IDType colTargetIDType;
  IDType colSourceIDType;
  VirtualArray rowVA;
  VirtualArray colVA;
  if (dataDomain.isColumnDimension()) {
    rowVA=recordPerspective.getVirtualArray();
    colVA=dimensionPerspective.getVirtualArray();
    rowTargetIDType=targetRecordIDType;
    colTargetIDType=targetDimensionIDType;
    rowSourceIDType=dataDomain.getRecordIDType();
    colSourceIDType=dataDomain.getDimensionIDType();
  }
 else {
    rowVA=dimensionPerspective.getVirtualArray();
    colVA=recordPerspective.getVirtualArray();
    rowTargetIDType=targetDimensionIDType;
    colTargetIDType=targetRecordIDType;
    rowSourceIDType=dataDomain.getDimensionIDType();
    colSourceIDType=dataDomain.getRecordIDType();
  }
  if (rowVA == null || colVA == null)   throw new IllegalArgumentException(""String_Node_Str"");
  IDMappingManager rowIDMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(rowSourceIDType);
  IDMappingManager colIDMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(colSourceIDType);
  try {
    PrintWriter out=new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
    out.print(""String_Node_Str"");
    for (    Integer colID : colVA) {
      Set<Object> colTargetIDs=colIDMappingManager.getIDAsSet(colSourceIDType,colTargetIDType,colID);
      String id=""String_Node_Str"";
      for (      Object colTargetID : colTargetIDs) {
        id=colTargetID.toString();
        break;
      }
      out.print(id + ""String_Node_Str"");
    }
    if (includeClusterInfo && rowVA.getGroupList() != null)     out.print(""String_Node_Str"");
    out.println();
    int cnt=-1;
    int cluster=0;
    int example=0;
    int offset=0;
    String id;
    for (    Integer rowID : rowVA) {
      Set<Object> rowTargetIDs=rowIDMappingManager.getIDAsSet(rowSourceIDType,rowTargetIDType,rowID);
      id=""String_Node_Str"";
      for (      Object rowTargetID : rowTargetIDs) {
        id=rowTargetID.toString();
        break;
      }
      out.print(id + ""String_Node_Str"");
      for (      Integer colID : colVA) {
        if (dataDomain.isColumnDimension()) {
          out.print(dataDomain.getTable().getRawAsString(colID,rowID));
        }
 else {
          out.print(dataDomain.getTable().getRawAsString(rowID,colID));
        }
        out.print(""String_Node_Str"");
      }
      if (includeClusterInfo) {
        if (rowVA.getGroupList() != null) {
          if (cnt == rowVA.getGroupList().get(cluster).getSize() - 1) {
            offset=offset + rowVA.getGroupList().get(cluster).getSize();
            cluster++;
            cnt=0;
          }
 else {
            cnt++;
          }
          example=rowVA.getGroupList().get(cluster).getRepresentativeElementIndex();
          out.print(cluster + ""String_Node_Str"" + example+ ""String_Node_Str"");
        }
      }
      out.println();
    }
    if (!includeClusterInfo) {
      out.close();
      return true;
    }
    if (colVA.getGroupList() != null) {
      String clusterNr=""String_Node_Str"";
      String clusterRep=""String_Node_Str"";
      cluster=0;
      cnt=-1;
      for (      @SuppressWarnings(""String_Node_Str"") Integer colIndex : colVA) {
        if (cnt == colVA.getGroupList().get(cluster).getSize() - 1) {
          offset=offset + colVA.getGroupList().get(cluster).getSize();
          cluster++;
          cnt=0;
        }
 else {
          cnt++;
        }
        example=colVA.getGroupList().get(cluster).getRepresentativeElementIndex();
        clusterNr+=cluster + ""String_Node_Str"";
        clusterRep+=example + ""String_Node_Str"";
      }
      clusterNr+=""String_Node_Str"";
      clusterRep+=""String_Node_Str"";
      out.print(clusterNr);
      out.print(clusterRep);
    }
    out.close();
  }
 catch (  IOException e) {
    Logger.log(new Status(IStatus.ERROR,""String_Node_Str"",""String_Node_Str"",e));
    return false;
  }
  return true;
}","/** 
 * Exports the dataset identified through the perspectives to the file specified.
 * @param dataDomain
 * @param fileName
 * @param recordPerspective
 * @param dimensionPerspective
 * @param targetRecordIDType the id type to be used in the file. If this is null the  {@link IDCategory#getHumanReadableIDType()}will be used.
 * @param targetDimensionIDType same as targetRecordIDType for dimensions
 * @param includeRecordClusterInfo true if you want to add information about the clustering of records to the file, else false
 * @param includeDimensionClusterInfo true if you want to add information about the clustering of dimensions to the file, else false
 * @return true if export was successful, else false.
 */
public static boolean export(ATableBasedDataDomain dataDomain,String fileName,Perspective recordPerspective,Perspective dimensionPerspective,IDType targetRecordIDType,IDType targetDimensionIDType,boolean includeRecordClusterInfo,boolean includeDimensionClusterInfo){
  if (targetRecordIDType == null)   targetRecordIDType=dataDomain.getRecordIDCategory().getHumanReadableIDType();
  if (targetDimensionIDType == null)   targetDimensionIDType=dataDomain.getDimensionIDCategory().getHumanReadableIDType();
  IDType rowTargetIDType;
  IDType rowSourceIDType;
  IDType colTargetIDType;
  IDType colSourceIDType;
  VirtualArray rowVA;
  VirtualArray colVA;
  rowVA=recordPerspective.getVirtualArray();
  colVA=dimensionPerspective.getVirtualArray();
  rowTargetIDType=targetRecordIDType;
  colTargetIDType=targetDimensionIDType;
  rowSourceIDType=dataDomain.getRecordIDType();
  colSourceIDType=dataDomain.getDimensionIDType();
  if (rowVA == null || colVA == null)   throw new IllegalArgumentException(""String_Node_Str"");
  IDMappingManager rowIDMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(rowSourceIDType);
  IDMappingManager colIDMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(colSourceIDType);
  try {
    PrintWriter out=new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
    int cnt=-1;
    int cluster=0;
    int example=0;
    int offset=0;
    if (includeDimensionClusterInfo && colVA.getGroupList() != null) {
      String clusterNr=""String_Node_Str"" + (includeRecordClusterInfo ? ""String_Node_Str"" : ""String_Node_Str"");
      String clusterRep=""String_Node_Str"" + (includeRecordClusterInfo ? ""String_Node_Str"" : ""String_Node_Str"");
      cluster=0;
      cnt=-1;
      for (      @SuppressWarnings(""String_Node_Str"") Integer colIndex : colVA) {
        if (cnt == colVA.getGroupList().get(cluster).getSize() - 1) {
          offset=offset + colVA.getGroupList().get(cluster).getSize();
          cluster++;
          cnt=0;
        }
 else {
          cnt++;
        }
        example=colVA.getGroupList().get(cluster).getRepresentativeElementIndex();
        clusterNr+=cluster + ""String_Node_Str"";
        clusterRep+=example + ""String_Node_Str"";
      }
      clusterNr+=""String_Node_Str"";
      clusterRep+=""String_Node_Str"";
      out.print(clusterNr);
      out.print(clusterRep);
    }
    if (includeRecordClusterInfo && rowVA.getGroupList() != null)     out.print(""String_Node_Str"");
    out.print(""String_Node_Str"");
    for (    Integer colID : colVA) {
      Set<Object> colTargetIDs=colIDMappingManager.getIDAsSet(colSourceIDType,colTargetIDType,colID);
      String id=""String_Node_Str"";
      for (      Object colTargetID : colTargetIDs) {
        id=colTargetID.toString();
        break;
      }
      out.print(id + ""String_Node_Str"");
    }
    out.println();
    cnt=-1;
    cluster=0;
    example=0;
    offset=0;
    String id;
    for (    Integer rowID : rowVA) {
      if (includeRecordClusterInfo) {
        if (rowVA.getGroupList() != null) {
          if (cnt == rowVA.getGroupList().get(cluster).getSize() - 1) {
            offset=offset + rowVA.getGroupList().get(cluster).getSize();
            cluster++;
            cnt=0;
          }
 else {
            cnt++;
          }
          example=rowVA.getGroupList().get(cluster).getRepresentativeElementIndex();
          out.print(cluster + ""String_Node_Str"" + example+ ""String_Node_Str"");
        }
      }
      Set<Object> rowTargetIDs=rowIDMappingManager.getIDAsSet(rowSourceIDType,rowTargetIDType,rowID);
      id=""String_Node_Str"";
      for (      Object rowTargetID : rowTargetIDs) {
        id=rowTargetID.toString();
        break;
      }
      out.print(id + ""String_Node_Str"");
      for (      Integer colID : colVA) {
        out.print(dataDomain.getTable().getRawAsString(colID,rowID));
        out.print(""String_Node_Str"");
      }
      out.println();
    }
    out.close();
  }
 catch (  IOException e) {
    Logger.log(new Status(IStatus.ERROR,""String_Node_Str"",""String_Node_Str"",e));
    return false;
  }
  return true;
}",0.5165522189197499
56786,"@Override protected void okPressed(){
  TableUtils.export(dataChooserComposite.getDataDomain(),sFileName,dataChooserComposite.getRecordPerspective(),dataChooserComposite.getDimensionPerspective(),null,null,false);
  super.okPressed();
}","@Override protected void okPressed(){
  TableUtils.export(dataChooserComposite.getDataDomain(),sFileName,dataChooserComposite.getRecordPerspective(),dataChooserComposite.getDimensionPerspective(),null,null,false,false);
  super.okPressed();
}",0.98744769874477
56787,"@Override public void run(){
  FileDialog fileDialog=new FileDialog(new Shell(),SWT.SAVE);
  fileDialog.setText(""String_Node_Str"");
  String[] filterExt={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  fileDialog.setFilterExtensions(filterExt);
  fileDialog.setFileName(""String_Node_Str"" + new SimpleDateFormat(""String_Node_Str"").format(new Date()) + ""String_Node_Str"");
  String fileName=fileDialog.open();
  if (fileName != null) {
    if (exportIdentifiersOnly) {
      Perspective dimensionPerspective=new Perspective();
      dimensionPerspective.setVirtualArray(new VirtualArray(dataDomain.getDimensionIDType()));
      TableUtils.export(dataDomain,fileName,tablePerspective.getRecordPerspective(),dimensionPerspective,null,null,false);
    }
 else {
      TableUtils.export(dataDomain,fileName,tablePerspective.getRecordPerspective(),tablePerspective.getDimensionPerspective(),null,null,false);
    }
  }
}","@Override public void run(){
  FileDialog fileDialog=new FileDialog(new Shell(),SWT.SAVE);
  fileDialog.setText(""String_Node_Str"");
  String[] filterExt={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  fileDialog.setFilterExtensions(filterExt);
  fileDialog.setFileName(""String_Node_Str"" + new SimpleDateFormat(""String_Node_Str"").format(new Date()) + ""String_Node_Str"");
  String fileName=fileDialog.open();
  if (fileName != null) {
    if (exportIdentifiersOnly) {
      Perspective dimensionPerspective=new Perspective();
      dimensionPerspective.setVirtualArray(new VirtualArray(dataDomain.getDimensionIDType()));
      TableUtils.export(dataDomain,fileName,tablePerspective.getRecordPerspective(),dimensionPerspective,null,null,isHeaderBrick,false);
    }
 else {
      TableUtils.export(dataDomain,fileName,tablePerspective.getRecordPerspective(),tablePerspective.getDimensionPerspective(),null,null,isHeaderBrick,false);
    }
  }
}",0.985058697972252
56788,"public void exportData(final boolean exportIdentifiersOnly){
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      FileDialog fileDialog=new FileDialog(new Shell(),SWT.SAVE);
      fileDialog.setText(""String_Node_Str"");
      String[] filterExt={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      fileDialog.setFilterExtensions(filterExt);
      fileDialog.setFileName(""String_Node_Str"" + new SimpleDateFormat(""String_Node_Str"").format(new Date()) + ""String_Node_Str"");
      String fileName=fileDialog.open();
      if (fileName != null) {
        if (exportIdentifiersOnly) {
          Perspective dimensionPerspective=new Perspective();
          dimensionPerspective.setVirtualArray(new VirtualArray(dataDomain.getDimensionIDType()));
          TableUtils.export(dataDomain,fileName,tablePerspective.getRecordPerspective(),dimensionPerspective,null,null,false);
        }
 else {
          TableUtils.export(dataDomain,fileName,tablePerspective.getRecordPerspective(),tablePerspective.getDimensionPerspective(),null,null,false);
        }
      }
    }
  }
);
}","public void exportData(final boolean exportIdentifiersOnly){
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      FileDialog fileDialog=new FileDialog(new Shell(),SWT.SAVE);
      fileDialog.setText(""String_Node_Str"");
      String[] filterExt={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      fileDialog.setFilterExtensions(filterExt);
      fileDialog.setFileName(""String_Node_Str"" + new SimpleDateFormat(""String_Node_Str"").format(new Date()) + ""String_Node_Str"");
      String fileName=fileDialog.open();
      if (fileName != null) {
        if (exportIdentifiersOnly) {
          Perspective dimensionPerspective=new Perspective();
          dimensionPerspective.setVirtualArray(new VirtualArray(dataDomain.getDimensionIDType()));
          TableUtils.export(dataDomain,fileName,tablePerspective.getRecordPerspective(),dimensionPerspective,null,null,isHeaderBrick,false);
        }
 else {
          TableUtils.export(dataDomain,fileName,tablePerspective.getRecordPerspective(),tablePerspective.getDimensionPerspective(),null,null,isHeaderBrick,false);
        }
      }
    }
  }
);
}",0.9875444839857652
56789,"@Override public void nodesCreated(){
  for (  ALinearizableNode node : renderer.pathNodes) {
    node.addPickingListener(new PathSelectionPickingListener(node));
  }
}","@Override public void nodesCreated(){
  for (  ALinearizableNode node : renderer.pathNodes) {
    node.addPickingListener(new PathSelectionPickingListener(node));
    if (selectedPathStartNode != null && node.getVertexReps().containsAll(selectedPathStartNode.getVertexReps())) {
      selectedPathStartNode=node;
    }
  }
}",0.6829268292682927
56790,"@Override public boolean isPathChangePermitted(List<List<PathwayVertexRep>> newPath){
  if (renderer != contextualPathsRenderer.getSelectedPathRenderer())   return true;
  if (PathUtil.isPathShown(newPath,selectedPathSegments,renderer.pathway))   return true;
  return false;
}","@Override public boolean isPathChangePermitted(List<List<PathwayVertexRep>> newPath){
  Set<PathwayVertexRep> commonVertices=PathUtil.getCommonVertices(selectedPathSegments,renderer.pathSegments);
  if (commonVertices.isEmpty())   return true;
  List<PathwayVertexRep> newPathFlat=PathUtil.flattenSegments(newPath);
  if (newPathFlat.containsAll(commonVertices))   return true;
  return false;
}",0.4107142857142857
56791,"@Override protected void renderContent(GL2 gl){
  TablePerspective mappedPerspective=pathRenderer.getMappedPerspective();
  List<Integer> ids=node.getMappedDavidIDs();
  if (ids == null || ids.isEmpty())   return;
  float onePxlWidth=view.getPixelGLConverter().getGLWidthForPixelWidth(1);
  float onePxlHeight=view.getPixelGLConverter().getGLHeightForPixelHeight(1);
  float z=1f;
  if (mappedPerspective != null) {
    Average average=null;
    if (pathRenderer.getSampleMappingMode() == ESampleMappingMode.ALL) {
      average=mappedPerspective.getContainerStatistics().getAverage(idType,ids.get(0));
    }
 else {
      Set<Integer> selectedSamples=pathRenderer.getSampleSelectionManager().getElements(SelectionType.SELECTION);
      List<Integer> selectedSamplesArray=new ArrayList<Integer>();
      selectedSamplesArray.addAll(selectedSamples);
      if (!selectedSamplesArray.isEmpty()) {
        VirtualArray selectedSamplesVA=new VirtualArray(pathRenderer.getSampleSelectionManager().getIDType(),selectedSamplesArray);
        GroupList groupList=new GroupList();
        groupList.append(new Group(selectedSamplesVA.size()));
        selectedSamplesVA.setGroupList(groupList);
        average=TablePerspectiveStatistics.calculateAverage(selectedSamplesVA,mappedPerspective.getDataDomain(),idType,ids);
      }
    }
    if (average != null) {
      setColor(mappedPerspective.getDataDomain().getTable().getColorMapper().getColor((float)average.getArithmeticMean()));
      float yStart=-1 * onePxlHeight;
      float yEnd=-5 * onePxlHeight;
      gl.glColor3f(1,1,1);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x,yEnd,z);
      gl.glVertex3f(x,yStart,z);
      gl.glEnd();
      gl.glColor3fv(mappedPerspective.getDataDomain().getColor().getRGB(),0);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x * (float)average.getStandardDeviation() * 2,yEnd,z);
      gl.glVertex3f(x * (float)average.getStandardDeviation() * 2,yStart,z);
      gl.glEnd();
      gl.glColor3f(0,0,0);
      gl.glBegin(GL.GL_LINE_LOOP);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x,yEnd,z);
      gl.glVertex3f(x,yStart,z);
      gl.glEnd();
      gl.glColor3fv(mappedPerspective.getDataDomain().getColor().getRGB(),0);
    }
 else {
      setColor(new float[]{1,1,1,1});
    }
  }
 else {
    setColor(new float[]{1,1,1,1});
  }
  Pair<TablePerspective,Average> highestAverage=null;
  Average average;
  for (  TablePerspective tablePerspective : pathRenderer.getTablePerspectives()) {
    average=tablePerspective.getContainerStatistics().getAverage(idType,ids.get(0));
    if (average == null)     continue;
    if (average.getStandardDeviation() > 0.2f) {
      if (highestAverage == null || average.getStandardDeviation() > highestAverage.getSecond().getStandardDeviation()) {
        highestAverage=new Pair<>(tablePerspective,average);
      }
    }
  }
  if (highestAverage != null) {
    gl.glColor3fv(highestAverage.getFirst().getDataDomain().getColor().darker().getRGB(),0);
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(x + 4 * onePxlWidth,3 * onePxlHeight,z);
    gl.glVertex3f(x + 8 * onePxlWidth,3 * onePxlHeight,z);
    gl.glVertex3f(x + 10 * onePxlWidth,y + 2 * onePxlHeight,z);
    gl.glVertex3f(x + 2 * onePxlWidth,y + 2 * onePxlHeight,z);
    gl.glEnd();
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(x + 3 * onePxlWidth,1 * onePxlHeight,z);
    gl.glVertex3f(x + 9 * onePxlWidth,1 * onePxlHeight,z);
    gl.glVertex3f(x + 9 * onePxlWidth,-3 * onePxlHeight,z);
    gl.glVertex3f(x + 3 * onePxlWidth,-3 * onePxlHeight,z);
    gl.glEnd();
  }
  super.renderContent(gl);
}","@Override protected void renderContent(GL2 gl){
  TablePerspective mappedPerspective=pathRenderer.getMappedPerspective();
  List<Integer> ids=node.getMappedDavidIDs();
  if (ids == null || ids.isEmpty())   return;
  float onePxlWidth=view.getPixelGLConverter().getGLWidthForPixelWidth(1);
  float onePxlHeight=view.getPixelGLConverter().getGLHeightForPixelHeight(1);
  float z=1f;
  if (mappedPerspective != null) {
    Average average=null;
    if (pathRenderer.getSampleMappingMode() == ESampleMappingMode.ALL) {
      average=mappedPerspective.getContainerStatistics().getAverage(idType,ids.get(0));
    }
 else {
      Set<Integer> selectedSamples=pathRenderer.getSampleSelectionManager().getElements(SelectionType.SELECTION);
      List<Integer> selectedSamplesArray=new ArrayList<Integer>();
      selectedSamplesArray.addAll(selectedSamples);
      if (!selectedSamplesArray.isEmpty()) {
        VirtualArray selectedSamplesVA=new VirtualArray(pathRenderer.getSampleSelectionManager().getIDType(),selectedSamplesArray);
        GroupList groupList=new GroupList();
        groupList.append(new Group(selectedSamplesVA.size()));
        selectedSamplesVA.setGroupList(groupList);
        average=TablePerspectiveStatistics.calculateAverage(selectedSamplesVA,mappedPerspective.getDataDomain(),idType,ids);
        if (Double.isNaN(average.getArithmeticMean()))         average=null;
      }
    }
    if (average != null) {
      setColor(mappedPerspective.getDataDomain().getTable().getColorMapper().getColor((float)average.getArithmeticMean()));
      float yStart=-1 * onePxlHeight;
      float yEnd=-5 * onePxlHeight;
      gl.glColor3f(1,1,1);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x,yEnd,z);
      gl.glVertex3f(x,yStart,z);
      gl.glEnd();
      gl.glColor3fv(mappedPerspective.getDataDomain().getColor().getRGB(),0);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x * (float)average.getStandardDeviation() * 2,yEnd,z);
      gl.glVertex3f(x * (float)average.getStandardDeviation() * 2,yStart,z);
      gl.glEnd();
      gl.glColor3f(0,0,0);
      gl.glBegin(GL.GL_LINE_LOOP);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x,yEnd,z);
      gl.glVertex3f(x,yStart,z);
      gl.glEnd();
      gl.glColor3fv(mappedPerspective.getDataDomain().getColor().getRGB(),0);
    }
 else {
      setColor(new float[]{1,1,1,1});
    }
  }
 else {
    setColor(new float[]{1,1,1,1});
  }
  Pair<TablePerspective,Average> highestAverage=null;
  Average average;
  for (  TablePerspective tablePerspective : pathRenderer.getTablePerspectives()) {
    average=tablePerspective.getContainerStatistics().getAverage(idType,ids.get(0));
    if (average == null)     continue;
    if (average.getStandardDeviation() > 0.2f) {
      if (highestAverage == null || average.getStandardDeviation() > highestAverage.getSecond().getStandardDeviation()) {
        highestAverage=new Pair<>(tablePerspective,average);
      }
    }
  }
  if (highestAverage != null) {
    gl.glColor3fv(highestAverage.getFirst().getDataDomain().getColor().darker().getRGB(),0);
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(x + 4 * onePxlWidth,3 * onePxlHeight,z);
    gl.glVertex3f(x + 8 * onePxlWidth,3 * onePxlHeight,z);
    gl.glVertex3f(x + 10 * onePxlWidth,y + 2 * onePxlHeight,z);
    gl.glVertex3f(x + 2 * onePxlWidth,y + 2 * onePxlHeight,z);
    gl.glEnd();
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(x + 3 * onePxlWidth,1 * onePxlHeight,z);
    gl.glVertex3f(x + 9 * onePxlWidth,1 * onePxlHeight,z);
    gl.glVertex3f(x + 9 * onePxlWidth,-3 * onePxlHeight,z);
    gl.glVertex3f(x + 3 * onePxlWidth,-3 * onePxlHeight,z);
    gl.glEnd();
  }
  super.renderContent(gl);
}",0.9898804047838088
56792,"/** 
 * Calculates the average value of the selected samples (taken from   {@link #selectedSamplesVA}) selectedSamplesVA. FIXME: doesn't consider multi-mappings atm.
 * @param vertexRep
 * @return
 */
private Average getExpressionAverage(TablePerspective tablePerspective,PathwayVertexRep vertexRep){
  if (selectedSamplesVA != null && selectedSamplesVA.size() == 0)   return null;
  List<Integer> mappedDavidIds=pathwayItemManager.getDavidIDsByPathwayVertexRep(vertexRep);
  final IDType david=IDType.getIDType(EGeneIDTypes.DAVID.name());
  Average average=null;
  if (selectedSamplesVA == null) {
    average=tablePerspective.getContainerStatistics().getAverage(david,mappedDavidIds);
  }
 else {
    average=TablePerspectiveStatistics.calculateAverage(selectedSamplesVA,tablePerspective.getDataDomain(),david,mappedDavidIds);
  }
  return average;
}","/** 
 * Calculates the average value of the selected samples (taken from   {@link #selectedSamplesVA}) selectedSamplesVA. FIXME: doesn't consider multi-mappings atm.
 * @param vertexRep
 * @return
 */
private Average getExpressionAverage(TablePerspective tablePerspective,PathwayVertexRep vertexRep){
  if (selectedSamplesVA != null && selectedSamplesVA.size() == 0)   return null;
  List<Integer> mappedDavidIds=pathwayItemManager.getDavidIDsByPathwayVertexRep(vertexRep);
  final IDType david=IDType.getIDType(EGeneIDTypes.DAVID.name());
  Average average=null;
  if (selectedSamplesVA == null) {
    average=tablePerspective.getContainerStatistics().getAverage(david,mappedDavidIds);
  }
 else {
    average=TablePerspectiveStatistics.calculateAverage(selectedSamplesVA,tablePerspective.getDataDomain(),david,mappedDavidIds);
    if (Double.isNaN(average.getArithmeticMean()))     return null;
  }
  return average;
}",0.9616252821670428
56793,"private void renderGeneNode(GL2 gl,PathwayVertexRep vertexRep){
  float[] nodeColor;
  float width=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
  float height=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
  gl.glLineWidth(1);
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glColorMask(false,false,false,false);
  gl.glDisable(GL.GL_DEPTH_TEST);
  gl.glDisable(GL.GL_BLEND);
  gl.glStencilFunc(GL.GL_GREATER,1,0xff);
  gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
  renderQuad(gl,width,height);
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glColorMask(true,true,true,true);
  gl.glEnable(GL.GL_DEPTH_TEST);
  gl.glEnable(GL.GL_BLEND);
  if (mappingPerspective != null) {
    Average average=getExpressionAverage(mappingPerspective,vertexRep);
    if (average != null) {
      nodeColor=mappingPerspective.getDataDomain().getTable().getColorMapper().getColor((float)average.getArithmeticMean());
    }
 else {
      nodeColor=null;
    }
    if (average != null && nodeColor != null) {
      gl.glColor4f(nodeColor[0],nodeColor[1],nodeColor[2],0.8f);
      if (glPathwayView.getDetailLevel() == EDetailLevel.HIGH) {
        gl.glEnable(GL.GL_STENCIL_TEST);
        gl.glDisable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_BLEND);
        gl.glStencilFunc(GL.GL_GREATER,2,0xff);
        gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
        renderQuad(gl,width,height);
        gl.glEnable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_STENCIL_TEST);
        Float stdDev=pixelGLConverter.getGLWidthForPixelWidth(PathwayRenderStyle.ENZYME_NODE_PIXEL_WIDTH) * (float)average.getStandardDeviation() * 2.0f;
        if (!stdDev.isNaN() && this.glPathwayView.isShowStdDevBars()) {
          renderStdDevBar(gl,width,height,stdDev);
        }
        gl.glPushMatrix();
        gl.glTranslatef(0,-(2f * thirdOfstdDevBarHeight - onePxlHeight),0);
        if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
          nodeColor=SelectionType.SELECTION.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilFunc(GL.GL_GREATER,2,0xff);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
 else         if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
          nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilFunc(GL.GL_GREATER,2,0xff);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
        gl.glPopMatrix();
      }
 else {
        float dsMean=0.5f;
        float scaleConstant=20;
        if (mappingPerspective.getDataDomain().getTable() instanceof NumericalTable) {
          NumericalTable table=(NumericalTable)mappingPerspective.getDataDomain().getTable();
          dsMean=(float)table.getDatasetStatistics().getMean();
          dsMean=(float)table.getNormalizedForRaw(table.getDefaultDataTransformation(),dsMean);
        }
        float deviation=1 + Math.abs(dsMean - (float)average.getArithmeticMean()) * scaleConstant;
        if (deviation > 4)         deviation=4;
        renderQuad(gl,width * deviation,height * deviation);
        gl.glEnable(GL.GL_STENCIL_TEST);
        gl.glColorMask(false,false,false,false);
        gl.glDisable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_BLEND);
        gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
        gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
        renderQuad(gl,width * deviation,height * deviation);
        gl.glDisable(GL.GL_STENCIL_TEST);
        gl.glColorMask(true,true,true,true);
        gl.glEnable(GL.GL_DEPTH_TEST);
        gl.glEnable(GL.GL_BLEND);
        if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
          nodeColor=SelectionType.SELECTION.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderQuad(gl,width * deviation,height * deviation);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
          gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
          renderQuad(gl,width * deviation,height * deviation);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
 else         if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
          nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderQuad(gl,width * deviation,height * deviation);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
          gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
          renderQuad(gl,width * deviation,height * deviation);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
      }
    }
 else {
      renderNonMappingGlyph(gl,width,height);
      if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
        nodeColor=SelectionType.SELECTION.getColor().getRGBA();
        gl.glColor4fv(nodeColor,0);
        renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
        maskFramedEnzymeNode(gl,width,height);
      }
 else       if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
        nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
        gl.glColor4fv(nodeColor,0);
        renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
        maskFramedEnzymeNode(gl,width,height);
      }
    }
  }
 else {
    nodeColor=null;
    if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
      nodeColor=SelectionType.SELECTION.getColor().getRGBA();
      maskFramedEnzymeNode(gl,width,height);
    }
 else     if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
      nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
      maskFramedEnzymeNode(gl,width,height);
    }
 else     if (vertexSelectionManager.checkStatus(SelectionType.NORMAL,vertexRep.getID())) {
      nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR.getRGBA();
    }
    if (nodeColor != null) {
      gl.glColor4fv(nodeColor,0);
      renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
      gl.glCallList(framedEnzymeNodeDisplayListId);
    }
    if (!vertexSelectionManager.checkStatus(SelectionType.DESELECTED,vertexRep.getID())) {
      gl.glColor4f(0,0,0,0);
      renderQuad(gl,width,height);
    }
  }
  if (glPathwayView.getDetailLevel() == EDetailLevel.HIGH) {
    renderExclamationMark(gl,vertexRep,width,height);
    renderMultiMappingGlyph(gl,width,height,vertexRep);
  }
}","private void renderGeneNode(GL2 gl,PathwayVertexRep vertexRep){
  float[] nodeColor;
  float width=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
  float height=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
  gl.glLineWidth(1);
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glColorMask(false,false,false,false);
  gl.glDisable(GL.GL_DEPTH_TEST);
  gl.glDisable(GL.GL_BLEND);
  gl.glStencilFunc(GL.GL_GREATER,1,0xff);
  gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
  renderQuad(gl,width,height);
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glColorMask(true,true,true,true);
  gl.glEnable(GL.GL_DEPTH_TEST);
  gl.glEnable(GL.GL_BLEND);
  if (mappingPerspective != null) {
    Average average=getExpressionAverage(mappingPerspective,vertexRep);
    if (average != null) {
      nodeColor=mappingPerspective.getDataDomain().getTable().getColorMapper().getColor((float)average.getArithmeticMean());
    }
 else {
      nodeColor=null;
    }
    if (average != null && nodeColor != null) {
      gl.glColor4f(nodeColor[0],nodeColor[1],nodeColor[2],0.8f);
      if (glPathwayView.getDetailLevel() == EDetailLevel.HIGH) {
        gl.glEnable(GL.GL_STENCIL_TEST);
        gl.glDisable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_BLEND);
        gl.glStencilFunc(GL.GL_GREATER,2,0xff);
        gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
        renderQuad(gl,width,height);
        gl.glEnable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_STENCIL_TEST);
        Float stdDev=pixelGLConverter.getGLWidthForPixelWidth(PathwayRenderStyle.ENZYME_NODE_PIXEL_WIDTH) * (float)average.getStandardDeviation() * 2.0f;
        if (!stdDev.isNaN() && this.glPathwayView.isShowStdDevBars()) {
          renderStdDevBar(gl,width,height,stdDev);
        }
 else {
          int i=0;
        }
        gl.glPushMatrix();
        gl.glTranslatef(0,-(2f * thirdOfstdDevBarHeight - onePxlHeight),0);
        if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
          nodeColor=SelectionType.SELECTION.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilFunc(GL.GL_GREATER,2,0xff);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
 else         if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
          nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilFunc(GL.GL_GREATER,2,0xff);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
        gl.glPopMatrix();
      }
 else {
        float dsMean=0.5f;
        float scaleConstant=20;
        if (mappingPerspective.getDataDomain().getTable() instanceof NumericalTable) {
          NumericalTable table=(NumericalTable)mappingPerspective.getDataDomain().getTable();
          dsMean=(float)table.getDatasetStatistics().getMean();
          dsMean=(float)table.getNormalizedForRaw(table.getDefaultDataTransformation(),dsMean);
        }
        float deviation=1 + Math.abs(dsMean - (float)average.getArithmeticMean()) * scaleConstant;
        if (deviation > 4)         deviation=4;
        renderQuad(gl,width * deviation,height * deviation);
        gl.glEnable(GL.GL_STENCIL_TEST);
        gl.glColorMask(false,false,false,false);
        gl.glDisable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_BLEND);
        gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
        gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
        renderQuad(gl,width * deviation,height * deviation);
        gl.glDisable(GL.GL_STENCIL_TEST);
        gl.glColorMask(true,true,true,true);
        gl.glEnable(GL.GL_DEPTH_TEST);
        gl.glEnable(GL.GL_BLEND);
        if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
          nodeColor=SelectionType.SELECTION.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderQuad(gl,width * deviation,height * deviation);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
          gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
          renderQuad(gl,width * deviation,height * deviation);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
 else         if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
          nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderQuad(gl,width * deviation,height * deviation);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
          gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
          renderQuad(gl,width * deviation,height * deviation);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
      }
    }
 else {
      renderNonMappingGlyph(gl,width,height);
      if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
        nodeColor=SelectionType.SELECTION.getColor().getRGBA();
        gl.glColor4fv(nodeColor,0);
        renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
        maskFramedEnzymeNode(gl,width,height);
      }
 else       if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
        nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
        gl.glColor4fv(nodeColor,0);
        renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
        maskFramedEnzymeNode(gl,width,height);
      }
    }
  }
 else {
    nodeColor=null;
    if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
      nodeColor=SelectionType.SELECTION.getColor().getRGBA();
      maskFramedEnzymeNode(gl,width,height);
    }
 else     if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
      nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
      maskFramedEnzymeNode(gl,width,height);
    }
 else     if (vertexSelectionManager.checkStatus(SelectionType.NORMAL,vertexRep.getID())) {
      nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR.getRGBA();
    }
    if (nodeColor != null) {
      gl.glColor4fv(nodeColor,0);
      renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
      gl.glCallList(framedEnzymeNodeDisplayListId);
    }
    if (!vertexSelectionManager.checkStatus(SelectionType.DESELECTED,vertexRep.getID())) {
      gl.glColor4f(0,0,0,0);
      renderQuad(gl,width,height);
    }
  }
  if (glPathwayView.getDetailLevel() == EDetailLevel.HIGH) {
    renderExclamationMark(gl,vertexRep,width,height);
    renderMultiMappingGlyph(gl,width,height,vertexRep);
  }
}",0.9977568960290998
56794,"private void loadExternalScores(ScoreParseSpecification spec,Collection<ATableBasedDataDomain> dataDomains){
  IDType targetIDType=null;
  for (  ATableBasedDataDomain dataDomain : dataDomains) {
    if (dataDomain.getLabel().contains(""String_Node_Str"")) {
      targetIDType=dataDomain.getDimensionIDType();
      break;
    }
  }
  if (targetIDType == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  ExternalIDTypeScoreParser parser=new ExternalIDTypeScoreParser(spec,targetIDType);
  Collection<ISerializeableScore> scores=parser.call();
  final Scores s=Scores.get();
  for (  ISerializeableScore score : scores) {
    s.addPersistentScoreIfAbsent(score);
  }
}","private void loadExternalScores(ScoreParseSpecification spec,Collection<ATableBasedDataDomain> dataDomains){
  ATableBasedDataDomain target=null;
  for (  ATableBasedDataDomain dataDomain : dataDomains) {
    if (dataDomain.getLabel().contains(""String_Node_Str"")) {
      target=dataDomain;
      break;
    }
  }
  if (target == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  ExternalIDTypeScoreParser parser=new ExternalIDTypeScoreParser(spec,target.getDimensionIDType(),target);
  Collection<ISerializeableScore> scores=parser.call();
  final Scores s=Scores.get();
  for (  ISerializeableScore score : scores) {
    s.addPersistentScoreIfAbsent(score);
  }
}",0.4656934306569343
56795,"@Override public void cleanup(GLElementContainer lineUp){
  lineUp.remove(0);
  lineUp.remove(lineUp.size() - 2);
  final GLElementContainer body=(GLElementContainer)lineUp.get(0);
  GLElementContainer c=(GLElementContainer)body.get(1);
  lineUp.add(0,((GLElementContainer)c.get(0)).get(1));
  lineUp.add(1,c.get(1));
  lineUp.remove(2);
}","@Override public void cleanup(GLElementContainer lineUp){
  lineUp.remove(0);
  lineUp.remove(lineUp.size() - 2);
  final GLElementContainer body=(GLElementContainer)lineUp.get(0);
  if (!(body.get(1) instanceof GLElementContainer))   return;
  GLElementContainer c=(GLElementContainer)body.get(1);
  lineUp.add(0,((GLElementContainer)c.get(0)).get(1));
  lineUp.add(1,c.get(1));
  lineUp.remove(2);
}",0.9162162162162162
56796,"@Override public void render(GL2 gl){
  Vec3f nodePos=node.getPosition();
  float nodeHeight=node.getHeight();
  float nodeWidth=node.getWidth();
  float size=pixelGLConverter.getGLHeightForGLWidth(GLYPH_SIZE);
  gl.glColor4f(0.3f,0.3f,0.3f,1f);
  gl.glBegin(GL.GL_TRIANGLES);
  gl.glVertex3f(nodePos.x() - nodeWidth / 2.0f,nodePos.y() + nodeHeight / 2.0f,nodePos.z() + 0.1f);
  gl.glVertex3f(nodePos.x() - (nodeWidth / 2.0f) + size,nodePos.y() + nodeHeight / 2.0f,nodePos.z() + 0.1f);
  gl.glVertex3f(nodePos.x() - nodeWidth / 2.0f,nodePos.y() + nodeHeight / 2.0f - size,nodePos.z() + 0.1f);
  gl.glEnd();
}","@Override public void render(GL2 gl){
  Vec3f nodePos=node.getPosition();
  float nodeHeight=node.getHeight();
  float nodeWidth=node.getWidth();
  float size=pixelGLConverter.getGLHeightForPixelHeight(GLYPH_SIZE);
  gl.glColor4f(0.3f,0.3f,0.3f,1f);
  gl.glBegin(GL.GL_TRIANGLES);
  gl.glVertex3f(nodePos.x() - nodeWidth / 2.0f,nodePos.y() + nodeHeight / 2.0f,nodePos.z() + 0.1f);
  gl.glVertex3f(nodePos.x() - (nodeWidth / 2.0f) + size,nodePos.y() + nodeHeight / 2.0f,nodePos.z() + 0.1f);
  gl.glVertex3f(nodePos.x() - nodeWidth / 2.0f,nodePos.y() + nodeHeight / 2.0f - size,nodePos.z() + 0.1f);
  gl.glEnd();
}",0.9852459016393442
56797,"@Override public void display(GL2 gl){
  boolean hasAnyThing=false;
  for (  IStratomeXAddIn addin : addins)   hasAnyThing=hasAnyThing || !addin.isEmpty();
  if ((tablePerspectives == null || tablePerspectives.isEmpty()) && !hasAnyThing) {
    if (isDisplayListDirty) {
      gl.glNewList(displayListIndex,GL2.GL_COMPILE);
      List<String> emptyStrings=new ArrayList<>();
      for (      IStratomeXAddIn addin : addins)       emptyStrings.addAll(addin.addEmptyStrings());
      if (emptyStrings.isEmpty())       emptyStrings.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      renderEmptyViewText(gl,emptyStrings.toArray(new String[0]));
      gl.glEndList();
      isDisplayListDirty=false;
    }
    gl.glCallList(displayListIndex);
  }
 else {
    if (!uninitializedSubViews.isEmpty()) {
      while (uninitializedSubViews.peek() != null) {
        uninitializedSubViews.poll().initRemote(gl,this,glMouseListener);
      }
      initLayouts();
    }
    for (    BrickColumn group : brickColumnManager.getBrickColumns()) {
      group.processEvents();
    }
    handleHorizontalColumnMove(gl);
    if (isLayoutDirty) {
      isLayoutDirty=false;
      layoutManager.updateLayout();
      float minWidth=pixelGLConverter.getGLWidthForPixelWidth(BRICK_COLUMN_SPACING_MIN_PIXEL_WIDTH);
      for (      ElementLayout layout : centerRowLayout) {
        if (!(layout.getRenderer() instanceof BrickColumnSpacingRenderer))         continue;
        if (resizeNecessary)         break;
        if (layout.getSizeScaledX() < minWidth - 0.01f) {
          resizeNecessary=true;
          break;
        }
      }
      updateConnectionLinesBetweenColumns();
    }
    if (resizeNecessary) {
      resizeNecessary=false;
    }
    for (    BrickColumn column : brickColumnManager.getBrickColumns()) {
      column.display(gl);
    }
    if (isConnectionLinesDirty) {
      performConnectionLinesUpdate();
    }
    layoutManager.render(gl);
    dragAndDropController.handleDragging(gl,glMouseListener);
  }
  if (addTablePerspectiveParameters != null) {
    addTablePerspectives(addTablePerspectiveParameters.newTablePerspectives,addTablePerspectiveParameters.brickConfigurer,addTablePerspectiveParameters.sourceColumn,addTablePerspectiveParameters.addRight);
    addTablePerspectiveParameters=null;
  }
}","@Override public void display(GL2 gl){
  boolean hasAnyThing=false;
  for (  IStratomeXAddIn addin : addins)   hasAnyThing=hasAnyThing || !addin.isEmpty();
  if ((tablePerspectives == null || tablePerspectives.isEmpty()) && !hasAnyThing) {
    if (isDisplayListDirty) {
      gl.glNewList(displayListIndex,GL2.GL_COMPILE);
      List<String> emptyStrings=new ArrayList<>();
      for (      IStratomeXAddIn addin : addins) {
        addin.renderOptionTrigger(gl,0,getArchTopY(),getViewFrustum().getWidth(),getArchBottomY() - getArchTopY(),0);
        emptyStrings.addAll(addin.addEmptyStrings());
      }
      if (emptyStrings.isEmpty())       emptyStrings.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      renderEmptyViewText(gl,emptyStrings.toArray(new String[0]));
      gl.glEndList();
      isDisplayListDirty=false;
    }
    gl.glCallList(displayListIndex);
  }
 else {
    if (!uninitializedSubViews.isEmpty()) {
      while (uninitializedSubViews.peek() != null) {
        uninitializedSubViews.poll().initRemote(gl,this,glMouseListener);
      }
      initLayouts();
    }
    for (    BrickColumn group : brickColumnManager.getBrickColumns()) {
      group.processEvents();
    }
    handleHorizontalColumnMove(gl);
    if (isLayoutDirty) {
      isLayoutDirty=false;
      layoutManager.updateLayout();
      float minWidth=pixelGLConverter.getGLWidthForPixelWidth(BRICK_COLUMN_SPACING_MIN_PIXEL_WIDTH);
      for (      ElementLayout layout : centerRowLayout) {
        if (!(layout.getRenderer() instanceof BrickColumnSpacingRenderer))         continue;
        if (resizeNecessary)         break;
        if (layout.getSizeScaledX() < minWidth - 0.01f) {
          resizeNecessary=true;
          break;
        }
      }
      updateConnectionLinesBetweenColumns();
    }
    if (resizeNecessary) {
      resizeNecessary=false;
    }
    for (    BrickColumn column : brickColumnManager.getBrickColumns()) {
      column.display(gl);
    }
    if (isConnectionLinesDirty) {
      performConnectionLinesUpdate();
    }
    layoutManager.render(gl);
    dragAndDropController.handleDragging(gl,glMouseListener);
  }
  if (addTablePerspectiveParameters != null) {
    addTablePerspectives(addTablePerspectiveParameters.newTablePerspectives,addTablePerspectiveParameters.brickConfigurer,addTablePerspectiveParameters.sourceColumn,addTablePerspectiveParameters.addRight);
    addTablePerspectiveParameters=null;
  }
}",0.9728940783986656
56798,"@Override public double apply(double in){
{
    Double r=EStandardMappings.apply(code,in,this);
    if (r != null)     return JavaScriptFunctions.clamp01(r.doubleValue());
  }
  try {
    Bindings bindings=engine.createBindings();
    bindings.put(""String_Node_Str"",in);
    addBindings(bindings);
    CompiledScript c=compileScript();
    if (c == null)     return Double.NaN;
    Object r=compileScript().eval(bindings);
    if (r instanceof Number)     return ((Number)r).doubleValue();
  }
 catch (  MappedValueException e) {
    return e.getValue();
  }
catch (  ScriptException e) {
    log.warn(""String_Node_Str"" + fullCode(code),e);
  }
  return Double.NaN;
}","@Override public double apply(double in){
{
    filter.use(getActMin(),getActMax());
    Double r=EStandardMappings.apply(code,in,this);
    if (r != null)     return JavaScriptFunctions.clamp01(r.doubleValue());
  }
  try {
    Bindings bindings=engine.createBindings();
    bindings.put(""String_Node_Str"",in);
    addBindings(bindings);
    CompiledScript c=compileScript();
    if (c == null)     return Double.NaN;
    Object r=compileScript().eval(bindings);
    if (r instanceof Number)     return ((Number)r).doubleValue();
  }
 catch (  MappedValueException e) {
    return e.getValue();
  }
catch (  ScriptException e) {
    log.warn(""String_Node_Str"" + fullCode(code),e);
  }
  return Double.NaN;
}",0.970181818181818
56799,"public void render(GLGraphics g){
  texture.bind(g.gl);
  g.gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_S,GL.GL_CLAMP_TO_EDGE);
  g.gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_T,GL.GL_CLAMP_TO_EDGE);
  g.gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_NEAREST);
  g.gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_NEAREST);
  g.fillImage(texture,tile.x,tile.y,tile.width,tile.height);
}","public void render(GLGraphics g){
  texture.bind(g.gl);
  if (g.gl.isExtensionAvailable(""String_Node_Str"")) {
    g.gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_S,GL.GL_CLAMP_TO_EDGE);
    g.gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_T,GL.GL_CLAMP_TO_EDGE);
  }
  g.gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_NEAREST);
  g.gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_NEAREST);
  g.fillImage(texture,tile.x,tile.y,tile.width,tile.height);
}",0.9350104821802936
56800,"public boolean filterRaw(double raw){
  return raw >= raw_min || raw <= raw_max;
}","public boolean filterRaw(double raw){
  return raw >= raw_min && raw <= raw_max;
}",0.975609756097561
56801,"public boolean filterNormalized(double n){
  return n >= normalized_min || n <= normalized_max;
}","public boolean filterNormalized(double n){
  return n >= normalized_min && n <= normalized_max;
}",0.979381443298969
56802,"@Override protected void renderImpl(GLGraphics g,float w,float h){
  super.renderImpl(g,w,h);
  if (isSelected())   g.color(model.getDataDomain().getColor()).fillRect(2,2,14,14);
  g.fillImage(getStandardIcon(""String_Node_Str"",false),0,0,18,18);
  float tw=Math.min(g.text.getTextWidth(getLabel(),14),w - 18 - 18);
  g.drawText(getLabel(),18,1,w - 18 - 18,14);
  if (model.isFilteringPossible())   g.fillImage(hasFilter ? ICON_FILTER : ICON_FILTER_DISABLED,18 + tw + 2,2,12,12);
}","@Override protected void renderImpl(GLGraphics g,float w,float h){
  super.renderImpl(g,w,h);
  if (isSelected())   g.color(model.getDataDomain().getColor()).fillRect(2,2,14,14);
  g.fillImage(EButtonIcon.CHECKBOX.get(false),0,0,18,18);
  float tw=Math.min(g.text.getTextWidth(getLabel(),14),w - 18 - 18);
  g.drawText(getLabel(),18,1,w - 18 - 18,14);
  if (model.isFilteringPossible())   g.fillImage(hasFilter ? ICON_FILTER : ICON_FILTER_DISABLED,18 + tw + 2,2,12,12);
}",0.9379600420609884
56803,"/** 
 * explodes the given composite model into its components, i.e children
 */
@Override public void explode(ACompositeRankColumnModel model){
  int index=this.columns.indexOf(model);
  List<ARankColumnModel> children=model.getChildren();
  for (  ARankColumnModel child : children) {
    child.init(this);
    child.setWidth(100);
  }
  this.columns.set(index,children.get(0));
  propertySupport.fireIndexedPropertyChange(PROP_COLUMNS,index,model,children.get(0));
  if (children.size() > 1) {
    this.columns.addAll(index + 1,children.subList(1,children.size()));
    propertySupport.fireIndexedPropertyChange(PROP_COLUMNS,index + 1,null,children.subList(1,children.size()));
  }
  findCorrespondingRanker(index).checkOrderChanges(model,children.get(0));
}","/** 
 * explodes the given composite model into its components, i.e children
 */
@Override public void explode(ACompositeRankColumnModel model){
  int index=this.columns.indexOf(model);
  List<ARankColumnModel> children=model.getChildren();
  float w=model instanceof ICompressColumnMixin ? 100 : model.getWidth();
  for (  ARankColumnModel child : children) {
    child.init(this);
    child.setWidth(w);
  }
  this.columns.set(index,children.get(0));
  propertySupport.fireIndexedPropertyChange(PROP_COLUMNS,index,model,children.get(0));
  if (children.size() > 1) {
    this.columns.addAll(index + 1,children.subList(1,children.size()));
    propertySupport.fireIndexedPropertyChange(PROP_COLUMNS,index + 1,null,children.subList(1,children.size()));
  }
  findCorrespondingRanker(index).checkOrderChanges(model,children.get(0));
}",0.8582183186951067
56804,"public static double linear(double start,double end,double in,double startTo,double endTo){
  boolean special=start > 0;
  start=0;
  if (Double.isNaN(in))   return in;
  if (in < start)   return Double.NaN;
  if (in > end)   return Double.NaN;
  double v=(in - start) / (end - start);
  double r=startTo + v * (endTo - startTo);
  if (special)   System.out.println(in + ""String_Node_Str"" + r);
  return clamp01(r);
}","public static double linear(double start,double end,double in,double startTo,double endTo){
  if (Double.isNaN(in))   return in;
  if (in < start)   return Double.NaN;
  if (in > end)   return Double.NaN;
  double v=(in - start) / (end - start);
  double r=startTo + v * (endTo - startTo);
  return clamp01(r);
}",0.8559670781893004
56805,"@Override public double apply(double in){
  if (Double.isNaN(in))   return in;
  if (!isDefinedMapping)   return super.apply(in);
  if (mapping.size() < 2) {
    double[] m0=getMappedMin();
    double[] m1=getMappedMax();
    return JavaScriptFunctions.linear(m0[0],m1[0],in,m0[1],m1[1]);
  }
  if (mapping.containsKey(in))   return mapping.get(in);
  Double first=mapping.firstKey();
  Double last=mapping.lastKey();
  if (in < first || in > last)   return Double.NaN;
  if (mapping.size() == 2) {
    return JavaScriptFunctions.linear(first,last,in,mapping.get(first),mapping.get(last));
  }
 else {
    SortedMap<Double,Double> before=mapping.headMap(in);
    if (before.isEmpty())     return Double.NaN;
    Double start=before.lastKey();
    Double startTo=before.get(start);
    SortedMap<Double,Double> after=mapping.tailMap(in);
    if (after.isEmpty())     return Double.NaN;
    Double end=after.firstKey();
    Double endTo=after.get(end);
    return JavaScriptFunctions.linear(start,end,in,startTo,endTo);
  }
}","@Override public double apply(double in){
  if (Double.isNaN(in))   return in;
  if (!isDefinedMapping)   return super.apply(in);
  if (mapping.size() < 2) {
    double[] m0=getMappedMin();
    double[] m1=getMappedMax();
    return JavaScriptFunctions.linear(m0[0],m1[0],in,m0[1],m1[1]);
  }
  if (mapping.containsKey(in))   return mapping.get(in);
  Double first=mapping.firstKey();
  Double last=mapping.lastKey();
  if (in < first || in > last)   return Double.NaN;
  if (mapping.size() == 2) {
    return JavaScriptFunctions.linear(first,last,in,mapping.get(first),mapping.get(last));
  }
 else {
    SortedMap<Double,Double> before=mapping.headMap(in);
    if (before.isEmpty())     return Double.NaN;
    Double start=before.lastKey();
    Double startTo=before.get(start);
    SortedMap<Double,Double> after=mapping.tailMap(in);
    if (after.isEmpty())     return Double.NaN;
    Double end=after.firstKey();
    Double endTo=after.get(end);
    double v=JavaScriptFunctions.linear(start,end,in,startTo,endTo);
    return v;
  }
}",0.98545101842871
56806,"private List<Integer> sampleMostVariableDimensions(int sampleSize,List<Integer> recordIDs,List<Integer> dimensionIDs){
  if (dimensionIDs.size() <= sampleSize)   return dimensionIDs;
  List<Pair<Double,Integer>> allDimVar=new ArrayList<Pair<Double,Integer>>();
  for (  Integer dimID : dimensionIDs) {
    double[] allDimsPerRecordArray=new double[recordIDs.size()];
    for (int i=0; i < recordIDs.size(); i++) {
      allDimsPerRecordArray[i]=getRaw(dimID,recordIDs.get(i));
    }
    AdvancedDoubleStatistics stats=AdvancedDoubleStatistics.of(allDimsPerRecordArray);
    if (stats.getNaNs() < stats.getN() * NAN_THRESHOLD) {
      allDimVar.add(new Pair<Double,Integer>(stats.getMedianAbsoluteDeviation(),dimID));
    }
  }
  Collections.sort(allDimVar,Collections.reverseOrder(Pair.<Double>compareFirst()));
  allDimVar=allDimVar.subList(0,sampleSize);
  List<Integer> sampledDimensionIDs=new ArrayList<>();
  for (  Pair<Double,Integer> recordVar : allDimVar) {
    sampledDimensionIDs.add(recordVar.getSecond());
  }
  return sampledDimensionIDs;
}","private List<Integer> sampleMostVariableDimensions(int sampleSize,List<Integer> recordIDs,List<Integer> dimensionIDs){
  if (dimensionIDs.size() <= sampleSize)   return dimensionIDs;
  List<Pair<Double,Integer>> allDimVar=new ArrayList<Pair<Double,Integer>>();
  for (  Integer dimID : dimensionIDs) {
    double[] allDimsPerRecordArray=new double[recordIDs.size()];
    for (int i=0; i < recordIDs.size(); i++) {
      allDimsPerRecordArray[i]=(Float)getRaw(dimID,recordIDs.get(i));
    }
    AdvancedDoubleStatistics stats=AdvancedDoubleStatistics.of(allDimsPerRecordArray);
    if (stats.getNaNs() < stats.getN() * NAN_THRESHOLD) {
      allDimVar.add(new Pair<Double,Integer>(stats.getMedianAbsoluteDeviation(),dimID));
    }
  }
  Collections.sort(allDimVar,Collections.reverseOrder(Pair.<Double>compareFirst()));
  allDimVar=allDimVar.subList(0,sampleSize);
  List<Integer> sampledDimensionIDs=new ArrayList<>();
  for (  Pair<Double,Integer> recordVar : allDimVar) {
    sampledDimensionIDs.add(recordVar.getSecond());
  }
  return sampledDimensionIDs;
}",0.9966903073286052
56807,"/** 
 * Normalize all columns in the tablet, based on values of all dimensions. For a numerical dimension, this would mean, that global minima and maxima are retrieved instead of local ones (as is done with normalize()) Operates with the raw data as basis by default, however when a logarithmized representation is in the dimension this is used. Make sure that all dimensions are logarithmized.
 */
@Override protected void normalize(){
  if (numericalProperties != null && numericalProperties.getImputeDescription() != null)   performImputation(numericalProperties.getImputeDescription());
  datasetStatistics=computeTableStats();
  if (numericalProperties != null && NumericalProperties.ZSCORE_ROWS.equals(numericalProperties.getzScoreNormalization())) {
    DoubleStatistics.Builder postStats=DoubleStatistics.builder();
    for (int rowCount=0; rowCount < getNrRows(); rowCount++) {
      DoubleStatistics stats=computeRowStats(rowCount);
      for (      AColumn<?,?> column : columns) {
        @SuppressWarnings(""String_Node_Str"") NumericalColumn<?,Float> nColumn=(NumericalColumn<?,Float>)column;
        double zScore=((nColumn.getRaw(rowCount)) - stats.getMean()) / stats.getSd();
        nColumn.setRaw(rowCount,(float)zScore);
        postStats.add(zScore);
      }
    }
    datasetStatistics=postStats.build();
  }
 else   if (numericalProperties != null && NumericalProperties.ZSCORE_COLUMNS.equals(numericalProperties.getzScoreNormalization())) {
    DoubleStatistics.Builder postStats=DoubleStatistics.builder();
    for (    AColumn<?,?> column : columns) {
      @SuppressWarnings(""String_Node_Str"") NumericalColumn<?,Float> nColumn=(NumericalColumn<?,Float>)column;
      DoubleStatistics stats=computeColumnStats(nColumn);
      for (int rowCount=0; rowCount < getNrRows(); rowCount++) {
        double zScore=((nColumn.getRaw(rowCount)) - stats.getMean()) / stats.getSd();
        nColumn.setRaw(rowCount,(float)zScore);
        postStats.add(zScore);
      }
    }
    datasetStatistics=postStats.build();
  }
  if (numericalProperties != null && numericalProperties.getClipToStdDevFactor() != null) {
    float nrDevs=numericalProperties.getClipToStdDevFactor();
    setMax(datasetStatistics.getMean() + nrDevs * datasetStatistics.getSd());
    setMin(datasetStatistics.getMean() - nrDevs * datasetStatistics.getSd());
    if (dataCenter == null) {
      if (min < 0 && max > 0)       dataCenter=0d;
    }
  }
  for (  AColumn<?,?> column : columns) {
    NumericalColumn<?,?> nColumn=(NumericalColumn<?,?>)column;
    nColumn.setExternalMin(getMin());
    nColumn.setExternalMax(getMax());
    nColumn.normalize();
    nColumn.log2();
    nColumn.log10();
  }
  ColorMapper mapper=getColorMapper();
  ColorMarkerPoint point=mapper.getMarkerPoints().get(0);
  double raw=datasetStatistics.getMean() - 3 * datasetStatistics.getSd();
  float normalized=(float)getNormalizedForRaw(defaultDataTransformation,raw);
  if (normalized < 0)   normalized=0;
  point.setRightSpread(normalized);
  point=mapper.getMarkerPoints().get(mapper.getMarkerPoints().size() - 1);
  raw=datasetStatistics.getMean() + 3 * datasetStatistics.getSd();
  normalized=(float)getNormalizedForRaw(defaultDataTransformation,raw);
  float distance=1 - normalized;
  if (distance < 0)   distance=0;
  point.setLeftSpread(distance);
  mapper.update();
}","/** 
 * Normalize all columns in the tablet, based on values of all dimensions. For a numerical dimension, this would mean, that global minima and maxima are retrieved instead of local ones (as is done with normalize()) Operates with the raw data as basis by default, however when a logarithmized representation is in the dimension this is used. Make sure that all dimensions are logarithmized.
 */
@Override protected void normalize(){
  if (numericalProperties != null && numericalProperties.getImputeDescription() != null)   performImputation(numericalProperties.getImputeDescription());
  if (numericalProperties != null && NumericalProperties.ZSCORE_ROWS.equals(numericalProperties.getzScoreNormalization())) {
    DoubleStatistics.Builder postStats=DoubleStatistics.builder();
    for (int rowCount=0; rowCount < getNrRows(); rowCount++) {
      DoubleStatistics stats=computeRowStats(rowCount);
      for (      AColumn<?,?> column : columns) {
        @SuppressWarnings(""String_Node_Str"") NumericalColumn<?,Float> nColumn=(NumericalColumn<?,Float>)column;
        double zScore=((nColumn.getRaw(rowCount)) - stats.getMean()) / stats.getSd();
        nColumn.setRaw(rowCount,(float)zScore);
        postStats.add(zScore);
      }
    }
    datasetStatistics=postStats.build();
  }
 else   if (numericalProperties != null && NumericalProperties.ZSCORE_COLUMNS.equals(numericalProperties.getzScoreNormalization())) {
    DoubleStatistics.Builder postStats=DoubleStatistics.builder();
    for (    AColumn<?,?> column : columns) {
      @SuppressWarnings(""String_Node_Str"") NumericalColumn<?,Float> nColumn=(NumericalColumn<?,Float>)column;
      DoubleStatistics stats=computeColumnStats(nColumn);
      for (int rowCount=0; rowCount < getNrRows(); rowCount++) {
        double zScore=((nColumn.getRaw(rowCount)) - stats.getMean()) / stats.getSd();
        nColumn.setRaw(rowCount,(float)zScore);
        postStats.add(zScore);
      }
    }
    datasetStatistics=postStats.build();
  }
 else {
    datasetStatistics=computeTableStats();
  }
  if (numericalProperties != null && numericalProperties.getClipToStdDevFactor() != null) {
    float nrDevs=numericalProperties.getClipToStdDevFactor();
    setMax(datasetStatistics.getMean() + nrDevs * datasetStatistics.getSd());
    setMin(datasetStatistics.getMean() - nrDevs * datasetStatistics.getSd());
    if (dataCenter == null) {
      if (min < 0 && max > 0)       dataCenter=0d;
    }
  }
  for (  AColumn<?,?> column : columns) {
    NumericalColumn<?,?> nColumn=(NumericalColumn<?,?>)column;
    nColumn.setExternalMin(getMin());
    nColumn.setExternalMax(getMax());
    nColumn.normalize();
    nColumn.log2();
    nColumn.log10();
  }
  ColorMapper mapper=getColorMapper();
  ColorMarkerPoint point=mapper.getMarkerPoints().get(0);
  double raw=datasetStatistics.getMean() - 3 * datasetStatistics.getSd();
  float normalized=(float)getNormalizedForRaw(defaultDataTransformation,raw);
  if (normalized < 0)   normalized=0;
  point.setRightSpread(normalized);
  point=mapper.getMarkerPoints().get(mapper.getMarkerPoints().size() - 1);
  raw=datasetStatistics.getMean() + 3 * datasetStatistics.getSd();
  normalized=(float)getNormalizedForRaw(defaultDataTransformation,raw);
  float distance=1 - normalized;
  if (distance < 0)   distance=0;
  point.setLeftSpread(distance);
  mapper.update();
}",0.9856673633920572
56808,"@Override protected PerspectiveInitializationData cluster(){
  int r=0;
  Stopwatch w=new Stopwatch().start();
  r=determineSimilarities();
  System.out.println(""String_Node_Str"" + w);
  w.stop().reset();
  if (r < 0) {
    progress(100);
    return null;
  }
  TreeClusterConfiguration tConfig=(TreeClusterConfiguration)config.getClusterAlgorithmConfiguration();
  Node[] result;
  w.start();
switch (tConfig.getTreeClustererAlgo()) {
case COMPLETE_LINKAGE:
    result=pmlcluster();
  System.out.println(""String_Node_Str"" + w);
break;
case AVERAGE_LINKAGE:
result=palcluster();
System.out.println(""String_Node_Str"" + w);
break;
case SINGLE_LINKAGE:
result=pslcluster();
System.out.println(""String_Node_Str"" + w);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + tConfig.getTreeClustererAlgo());
}
w.reset().start();
PerspectiveInitializationData p=convert(result);
System.out.println(""String_Node_Str"" + w);
return p;
}","@Override protected PerspectiveInitializationData cluster(){
  int r=0;
  Stopwatch w=new Stopwatch().start();
  r=determineSimilarities();
  System.out.println(""String_Node_Str"" + w);
  w.stop().reset();
  if (r < 0) {
    progress(100);
    return null;
  }
  TreeClusterConfiguration tConfig=(TreeClusterConfiguration)config.getClusterAlgorithmConfiguration();
  Node[] result;
  w.start();
switch (tConfig.getTreeClustererAlgo()) {
case COMPLETE_LINKAGE:
    result=pmlcluster();
  System.out.println(""String_Node_Str"" + w);
break;
case AVERAGE_LINKAGE:
result=palcluster();
System.out.println(""String_Node_Str"" + w);
break;
case SINGLE_LINKAGE:
result=pslcluster();
System.out.println(""String_Node_Str"" + w);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + tConfig.getTreeClustererAlgo());
}
if (result == null) return null;
w.reset().start();
PerspectiveInitializationData p=convert(result);
System.out.println(""String_Node_Str"" + w);
return p;
}",0.9827496079456352
56809,"public boolean isSampleGenes(){
  return !fullGenes || Boolean.parseBoolean(sampleGenes);
}","public boolean isSampleGenes(){
  return Boolean.parseBoolean(sampleGenes) && !fullGenes;
}",0.8461538461538461
56810,"/** 
 * @param in
 * @return
 */
protected static EDataClass getSingleColumnDataClass(TablePerspective in){
  if (in.getDimensionPerspective().getVirtualArray().size() > 1)   return null;
  int dimensionId=in.getDimensionPerspective().getVirtualArray().get(0);
  int recordId=in.getRecordPerspective().getVirtualArray().get(0);
  return in.getDataDomain().getTable().getDataClass(dimensionId,recordId);
}","/** 
 * @param in
 * @return
 */
protected static EDataClass getSingleColumnDataClass(TablePerspective in){
  if (in.getDimensionPerspective().getVirtualArray().size() != 1)   return null;
  int dimensionId=in.getDimensionPerspective().getVirtualArray().get(0);
  int recordId=in.getRecordPerspective().getVirtualArray().get(0);
  return in.getDataDomain().getTable().getDataClass(dimensionId,recordId);
}",0.9962917181705808
56811,"@Override public void display(GL2 gl){
  if ((tablePerspectives == null || tablePerspectives.isEmpty()) && tourguide.isEmpty()) {
    if (isDisplayListDirty) {
      gl.glNewList(displayListIndex,GL2.GL_COMPILE);
      tourguide.renderStartButton(gl,0,getArchTopY(),getViewFrustum().getWidth(),getArchBottomY() - getArchTopY(),0);
      if (tourguide.hasTourGuide()) {
        renderEmptyViewText(gl,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
      }
 else {
        renderEmptyViewText(gl,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
      }
      gl.glEndList();
      isDisplayListDirty=false;
    }
    gl.glCallList(displayListIndex);
  }
 else {
    if (!uninitializedSubViews.isEmpty()) {
      while (uninitializedSubViews.peek() != null) {
        uninitializedSubViews.poll().initRemote(gl,this,glMouseListener);
      }
      initLayouts();
    }
    for (    BrickColumn group : brickColumnManager.getBrickColumns()) {
      group.processEvents();
    }
    handleHorizontalColumnMove(gl);
    if (isLayoutDirty) {
      isLayoutDirty=false;
      layoutManager.updateLayout();
      float minWidth=pixelGLConverter.getGLWidthForPixelWidth(BRICK_COLUMN_SPACING_MIN_PIXEL_WIDTH);
      for (      ElementLayout layout : centerRowLayout) {
        if (!(layout.getRenderer() instanceof BrickColumnSpacingRenderer))         continue;
        if (resizeNecessary)         break;
        if (layout.getSizeScaledX() < minWidth - 0.01f) {
          resizeNecessary=true;
          break;
        }
      }
    }
    if (resizeNecessary) {
      resizeNecessary=false;
    }
    for (    BrickColumn column : brickColumnManager.getBrickColumns()) {
      column.display(gl);
    }
    if (isConnectionLinesDirty) {
      performConnectionLinesUpdate();
    }
    layoutManager.render(gl);
    dragAndDropController.handleDragging(gl,glMouseListener);
  }
  if (addTablePerspectiveParameters != null) {
    addTablePerspectives(addTablePerspectiveParameters.newTablePerspectives,addTablePerspectiveParameters.brickConfigurer,addTablePerspectiveParameters.sourceColumn,addTablePerspectiveParameters.addRight);
    addTablePerspectiveParameters=null;
  }
}","@Override public void display(GL2 gl){
  if ((tablePerspectives == null || tablePerspectives.isEmpty()) && tourguide.isEmpty()) {
    if (isDisplayListDirty) {
      gl.glNewList(displayListIndex,GL2.GL_COMPILE);
      tourguide.renderStartButton(gl,0,getArchTopY(),getViewFrustum().getWidth(),getArchBottomY() - getArchTopY(),0);
      if (tourguide.hasTourGuide()) {
        renderEmptyViewText(gl,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
      }
 else {
        renderEmptyViewText(gl,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
      }
      gl.glEndList();
      isDisplayListDirty=false;
    }
    gl.glCallList(displayListIndex);
  }
 else {
    if (!uninitializedSubViews.isEmpty()) {
      while (uninitializedSubViews.peek() != null) {
        uninitializedSubViews.poll().initRemote(gl,this,glMouseListener);
      }
      initLayouts();
    }
    for (    BrickColumn group : brickColumnManager.getBrickColumns()) {
      group.processEvents();
    }
    handleHorizontalColumnMove(gl);
    if (isLayoutDirty) {
      isLayoutDirty=false;
      layoutManager.updateLayout();
      float minWidth=pixelGLConverter.getGLWidthForPixelWidth(BRICK_COLUMN_SPACING_MIN_PIXEL_WIDTH);
      for (      ElementLayout layout : centerRowLayout) {
        if (!(layout.getRenderer() instanceof BrickColumnSpacingRenderer))         continue;
        if (resizeNecessary)         break;
        if (layout.getSizeScaledX() < minWidth - 0.01f) {
          resizeNecessary=true;
          break;
        }
      }
      updateConnectionLinesBetweenColumns();
    }
    if (resizeNecessary) {
      resizeNecessary=false;
    }
    for (    BrickColumn column : brickColumnManager.getBrickColumns()) {
      column.display(gl);
    }
    if (isConnectionLinesDirty) {
      performConnectionLinesUpdate();
    }
    layoutManager.render(gl);
    dragAndDropController.handleDragging(gl,glMouseListener);
  }
  if (addTablePerspectiveParameters != null) {
    addTablePerspectives(addTablePerspectiveParameters.newTablePerspectives,addTablePerspectiveParameters.brickConfigurer,addTablePerspectiveParameters.sourceColumn,addTablePerspectiveParameters.addRight);
    addTablePerspectiveParameters=null;
  }
}",0.9900815516861362
56812,"protected void distributeBricksUniformly(){
  float totalUsedHeightByBricks=0;
  for (  GLBrick brick : clusterBricks) {
    totalUsedHeightByBricks+=pixelGLConverter.getGLHeightForPixelHeight(brick.getWrappingLayout().getPixelSizeY());
  }
  float heightForSpacings=clusterBrickColumn.getSizeScaledY() - totalUsedHeightByBricks;
  int brickSpacing=Math.max(pixelGLConverter.getPixelHeightForGLHeight(heightForSpacings / (clusterBricks.size() + 1)),BETWEEN_BRICKS_SPACING);
  if (heightForSpacings <= 0)   return;
  for (int i=0; i < clusterBrickColumn.size(); i++) {
    ElementLayout layout=clusterBrickColumn.get(i);
    if (layout.toString().equals(""String_Node_Str"")) {
      layout.setPixelSizeY(brickSpacing);
    }
  }
}","protected void distributeBricksUniformly(){
  float totalUsedHeightByBricks=0;
  for (  GLBrick brick : clusterBricks) {
    totalUsedHeightByBricks+=pixelGLConverter.getGLHeightForPixelHeight(brick.getWrappingLayout().getPixelSizeY());
  }
  float heightForSpacings=clusterBrickColumn.getSizeScaledY() - totalUsedHeightByBricks;
  int brickSpacing=Math.max(pixelGLConverter.getPixelHeightForGLHeight(heightForSpacings / (clusterBricks.size() + 1)),BETWEEN_BRICKS_SPACING);
  if (heightForSpacings <= 0)   return;
  for (int i=0; i < clusterBrickColumn.size(); i++) {
    ElementLayout layout=clusterBrickColumn.get(i);
    if (layout.toString().equals(""String_Node_Str"")) {
      layout.setPixelSizeY(brickSpacing);
    }
  }
  stratomex.setLayoutDirty();
  stratomex.updateConnectionLinesBetweenColumns();
}",0.9472999349381912
56813,"/** 
 * Check whether we had a picking hit somewhere during the previous run
 * @param gl
 */
protected final void checkForHits(final GL2 gl){
  contextMenuCreator.clear();
  Set<String> hitTypes=pickingManager.getHitTypes(uniqueID);
  if (hitTypes == null)   return;
  for (  String pickingType : hitTypes) {
    ArrayList<Pick> alHits=null;
    alHits=pickingManager.getHits(uniqueID,pickingType);
    if (alHits != null && alHits.size() != 0) {
      for (int iCount=0; iCount < alHits.size(); iCount++) {
        Pick tempPick=alHits.get(iCount);
        int pickedObjectID=tempPick.getObjectID();
        if (pickedObjectID == -1) {
          continue;
        }
        PickingMode ePickingMode=tempPick.getPickingMode();
        handlePicking(pickingType,ePickingMode,pickedObjectID,tempPick);
        try {
          PickingType type=PickingType.valueOf(pickingType);
          try {
            handlePickingEvents(type,ePickingMode,pickedObjectID,tempPick);
          }
 catch (          Exception e) {
            Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"",e));
          }
        }
 catch (        IllegalArgumentException e) {
        }
      }
      pickingManager.flushHits(uniqueID,pickingType);
    }
  }
  if (contextMenuCreator.hasMenuItems())   contextMenuCreator.open(this);
}","/** 
 * Check whether we had a picking hit somewhere during the previous run
 * @param gl
 */
protected final void checkForHits(final GL2 gl){
  contextMenuCreator.clear();
  Set<String> hTs=pickingManager.getHitTypes(uniqueID);
  if (hTs == null)   return;
  Set<String> hitTypes=new HashSet<String>(hTs);
  for (  String pickingType : hitTypes) {
    ArrayList<Pick> alHits=null;
    alHits=pickingManager.getHits(uniqueID,pickingType);
    if (alHits != null && alHits.size() != 0) {
      for (int iCount=0; iCount < alHits.size(); iCount++) {
        Pick tempPick=alHits.get(iCount);
        int pickedObjectID=tempPick.getObjectID();
        if (pickedObjectID == -1) {
          continue;
        }
        PickingMode ePickingMode=tempPick.getPickingMode();
        handlePicking(pickingType,ePickingMode,pickedObjectID,tempPick);
        try {
          PickingType type=PickingType.valueOf(pickingType);
          try {
            handlePickingEvents(type,ePickingMode,pickedObjectID,tempPick);
          }
 catch (          Exception e) {
            Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"",e));
          }
        }
 catch (        IllegalArgumentException e) {
        }
      }
      pickingManager.flushHits(uniqueID,pickingType);
    }
  }
  if (contextMenuCreator.hasMenuItems())   contextMenuCreator.open(this);
}",0.9639271104499814
56814,"/** 
 * This method has to be called in every display step. It is responsible for the ray tracing which does the actual picking. It needs the ID of the calling view and a gl context. It calls the display() method of the calling view, therefore only elements rendered in the display() can be picked.
 * @param glView a reference to the calling view
 * @param gl the GL2 context
 */
public void handlePicking(final AGLView glView,final GL2 gl){
  if (enablePicking == false)   return;
  GLMouseListener glMouseListener=glView.getGLMouseListener();
  PickingMode ePickingMode=PickingMode.CLICKED;
  if (glMouseListener.wasMouseDoubleClicked()) {
    ePickingMode=PickingMode.DOUBLE_CLICKED;
  }
 else   if (glMouseListener.wasMouseDragged()) {
    ePickingMode=PickingMode.DRAGGED;
  }
 else   if (glMouseListener.wasLeftMouseButtonPressed()) {
    ePickingMode=PickingMode.CLICKED;
  }
 else   if (glMouseListener.wasRightMouseButtonPressed()) {
    ePickingMode=PickingMode.RIGHT_CLICKED;
  }
 else   if (glMouseListener.wasMouseMoved()) {
    hashViewIDToIsMouseOverPickingEvent.put(glView.getID(),true);
    ePickingMode=PickingMode.MOUSE_OVER;
  }
 else   if (hashViewIDToIsMouseOverPickingEvent.get(glView.getID()) != null && hashViewIDToIsMouseOverPickingEvent.get(glView.getID()) == true) {
    return;
  }
 else {
    return;
  }
  Point pickRealPoint=glMouseListener.getRAWPickedPoint();
  if (pickRealPoint == null)   return;
  hashViewIDToIsMouseOverPickingEvent.put(glView.getID(),false);
  int PICKING_BUFSIZE=1024;
  int iArPickingBuffer[]=new int[PICKING_BUFSIZE];
  IntBuffer pickingBuffer=Buffers.newDirectIntBuffer(PICKING_BUFSIZE);
  int iHitCount=-1;
  int viewport[]=new int[4];
  gl.glGetIntegerv(GL.GL_VIEWPORT,viewport,0);
  gl.glSelectBuffer(PICKING_BUFSIZE,pickingBuffer);
  gl.glRenderMode(GL2.GL_SELECT);
  gl.glInitNames();
  gl.glMatrixMode(GLMatrixFunc.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  GLU glu=new GLU();
  glu.gluPickMatrix(pickRealPoint.x,(viewport[3] - pickRealPoint.y),5.0,5.0,viewport,0);
  float fAspectRatio=(float)(viewport[3] - viewport[1]) / (float)(viewport[2] - viewport[0]);
  ViewFrustum viewFrustum=glView.getViewFrustum();
  viewFrustum.setProjectionMatrix(gl,fAspectRatio);
  Vec2f pickDIPPoint=glMouseListener.getDIPPickedPoint();
  gl.glMatrixMode(GLMatrixFunc.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  glView.display(gl);
  gl.glPopMatrix();
  gl.glMatrixMode(GLMatrixFunc.GL_PROJECTION);
  gl.glPopMatrix();
  gl.glMatrixMode(GLMatrixFunc.GL_MODELVIEW);
  iHitCount=gl.glRenderMode(GL2.GL_RENDER);
  pickingBuffer.get(iArPickingBuffer);
  ArrayList<Integer> iAlPickedObjectId=processHits(iHitCount,iArPickingBuffer);
  IGLCanvas parentCanvas=glView.getParentGLCanvas();
  if (iAlPickedObjectId.size() > 0) {
    processPicks(iAlPickedObjectId,ePickingMode,pickDIPPoint,glMouseListener.getDIPPickedPointDragStart());
    Set<Integer> processedViews=new HashSet<Integer>();
    for (    int pickingID : iAlPickedObjectId) {
      Pair<Integer,String> pickAssociatedValues=hashPickingIDToViewID.get(pickingID);
      int pickedViewID=pickAssociatedValues.getFirst();
      for (      int viewID : hashViewIDToPreviousViewSpecificHitListContainer.keySet()) {
        if (viewID != pickedViewID && !processedViews.contains(viewID)) {
          AGLView currentView=GeneralManager.get().getViewManager().getGLView(viewID);
          if (currentView != null && currentView.getParentGLCanvas() == parentCanvas) {
            ViewSpecificHitListContainer previousHitContainer=hashViewIDToPreviousViewSpecificHitListContainer.get(viewID);
            if (previousHitContainer != null) {
              for (              String pickingType : previousHitContainer.getPickingTypes()) {
                for (                Pick previousPick : previousHitContainer.getPicksForPickingType(pickingType)) {
                  if (!(glView.getViewType().equals(""String_Node_Str"")) || (!pickingType.equals(pickAssociatedValues.getSecond()) && previousPick.getObjectID() != getPickedObjectIDFromPickingID(pickedViewID,pickAssociatedValues.getSecond(),pickingID))) {
                    ViewSpecificHitListContainer hitContainer=hashViewIDToViewSpecificHitListContainer.get(viewID);
                    if (hitContainer == null) {
                      hitContainer=new ViewSpecificHitListContainer();
                      hashViewIDToViewSpecificHitListContainer.put(viewID,hitContainer);
                    }
                    Pick pick=new Pick(previousPick.getObjectID(),PickingMode.MOUSE_OUT,pickDIPPoint,glMouseListener.getDIPPickedPointDragStart(),fMinimumZValue);
                    hitContainer.addPicksForPickingType(pickingType,pick,true);
                    processedViews.add(viewID);
                  }
                }
              }
            }
            hashViewIDToPreviousViewSpecificHitListContainer.put(viewID,new ViewSpecificHitListContainer());
          }
        }
      }
    }
  }
 else {
    Set<Integer> remoteRenderedViewIDs=new HashSet<Integer>();
    for (    int viewID : hashViewIDToPreviousViewSpecificHitListContainer.keySet()) {
      AGLView currentView=GeneralManager.get().getViewManager().getGLView(viewID);
      if (currentView != null && currentView.getParentGLCanvas() == parentCanvas) {
        remoteRenderedViewIDs.add(viewID);
      }
    }
    addMouseOutForPicksOfSpecifiedViews(remoteRenderedViewIDs,glMouseListener,pickDIPPoint);
  }
}","/** 
 * This method has to be called in every display step. It is responsible for the ray tracing which does the actual picking. It needs the ID of the calling view and a gl context. It calls the display() method of the calling view, therefore only elements rendered in the display() can be picked.
 * @param glView a reference to the calling view
 * @param gl the GL2 context
 */
public void handlePicking(final AGLView glView,final GL2 gl){
  if (enablePicking == false)   return;
  GLMouseListener glMouseListener=glView.getGLMouseListener();
  PickingMode ePickingMode=PickingMode.CLICKED;
  if (glMouseListener.wasMouseDoubleClicked()) {
    ePickingMode=PickingMode.DOUBLE_CLICKED;
  }
 else   if (glMouseListener.wasMouseDragged()) {
    ePickingMode=PickingMode.DRAGGED;
  }
 else   if (glMouseListener.wasLeftMouseButtonPressed()) {
    ePickingMode=PickingMode.CLICKED;
  }
 else   if (glMouseListener.wasRightMouseButtonPressed()) {
    ePickingMode=PickingMode.RIGHT_CLICKED;
  }
 else   if (glMouseListener.wasMouseMoved()) {
    hashViewIDToIsMouseOverPickingEvent.put(glView.getID(),true);
    ePickingMode=PickingMode.MOUSE_OVER;
  }
 else   if (hashViewIDToIsMouseOverPickingEvent.get(glView.getID()) != null && hashViewIDToIsMouseOverPickingEvent.get(glView.getID()) == true) {
    return;
  }
 else {
    return;
  }
  Point pickRealPoint=glMouseListener.getRAWPickedPoint();
  if (pickRealPoint == null)   return;
  hashViewIDToIsMouseOverPickingEvent.put(glView.getID(),false);
  int PICKING_BUFSIZE=1024;
  int iArPickingBuffer[]=new int[PICKING_BUFSIZE];
  IntBuffer pickingBuffer=Buffers.newDirectIntBuffer(PICKING_BUFSIZE);
  int iHitCount=-1;
  int viewport[]=new int[4];
  gl.glGetIntegerv(GL.GL_VIEWPORT,viewport,0);
  gl.glSelectBuffer(PICKING_BUFSIZE,pickingBuffer);
  gl.glRenderMode(GL2.GL_SELECT);
  gl.glInitNames();
  gl.glMatrixMode(GLMatrixFunc.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  GLU glu=new GLU();
  glu.gluPickMatrix(pickRealPoint.x,(viewport[3] - pickRealPoint.y),5.0,5.0,viewport,0);
  float fAspectRatio=(float)(viewport[3] - viewport[1]) / (float)(viewport[2] - viewport[0]);
  ViewFrustum viewFrustum=glView.getViewFrustum();
  viewFrustum.setProjectionMatrix(gl,fAspectRatio);
  Vec2f pickDIPPoint=glMouseListener.getDIPPickedPoint();
  gl.glMatrixMode(GLMatrixFunc.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  glView.display(gl);
  gl.glPopMatrix();
  gl.glMatrixMode(GLMatrixFunc.GL_PROJECTION);
  gl.glPopMatrix();
  gl.glMatrixMode(GLMatrixFunc.GL_MODELVIEW);
  iHitCount=gl.glRenderMode(GL2.GL_RENDER);
  pickingBuffer.get(iArPickingBuffer);
  ArrayList<Integer> iAlPickedObjectId=processHits(iHitCount,iArPickingBuffer);
  IGLCanvas parentCanvas=glView.getParentGLCanvas();
  if (iAlPickedObjectId.size() > 0) {
    processPicks(iAlPickedObjectId,ePickingMode,pickDIPPoint,glMouseListener.getDIPPickedPointDragStart());
    Set<Integer> processedViews=new HashSet<Integer>();
    List<Integer> currentPickedObjectIDs=new ArrayList<>(iAlPickedObjectId);
    for (    int pickingID : iAlPickedObjectId) {
      Pair<Integer,String> pickAssociatedValues=hashPickingIDToViewID.get(pickingID);
      int pickedViewID=pickAssociatedValues.getFirst();
      for (      int viewID : hashViewIDToPreviousViewSpecificHitListContainer.keySet()) {
        if (viewID != pickedViewID && !processedViews.contains(viewID)) {
          AGLView currentView=GeneralManager.get().getViewManager().getGLView(viewID);
          if (currentView != null && currentView.getParentGLCanvas() == parentCanvas) {
            ViewSpecificHitListContainer previousHitContainer=hashViewIDToPreviousViewSpecificHitListContainer.get(viewID);
            if (previousHitContainer != null) {
              for (              String pickingType : previousHitContainer.getPickingTypes()) {
                for (                Pick previousPick : previousHitContainer.getPicksForPickingType(pickingType)) {
                  ViewSpecificHitListContainer hitContainer=hashViewIDToViewSpecificHitListContainer.get(viewID);
                  if (hitContainer == null) {
                    hitContainer=new ViewSpecificHitListContainer();
                    hashViewIDToViewSpecificHitListContainer.put(viewID,hitContainer);
                  }
                  boolean picksExist=false;
                  for (                  String pT : hitContainer.getPickingTypes()) {
                    if (hitContainer.getPicksForPickingType(pT).size() > 0) {
                      picksExist=true;
                      break;
                    }
                  }
                  if (!picksExist && !currentPickedObjectIDs.contains(getPickingID(viewID,pickingType,previousPick.getObjectID()))) {
                    Pick pick=new Pick(previousPick.getObjectID(),PickingMode.MOUSE_OUT,pickDIPPoint,glMouseListener.getDIPPickedPointDragStart(),fMinimumZValue);
                    hitContainer.addPicksForPickingType(pickingType,pick,true);
                    processedViews.add(viewID);
                    hashViewIDToPreviousViewSpecificHitListContainer.put(viewID,new ViewSpecificHitListContainer());
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 else {
    Set<Integer> remoteRenderedViewIDs=new HashSet<Integer>();
    for (    int viewID : hashViewIDToPreviousViewSpecificHitListContainer.keySet()) {
      AGLView currentView=GeneralManager.get().getViewManager().getGLView(viewID);
      if (currentView != null && currentView.getParentGLCanvas() == parentCanvas) {
        remoteRenderedViewIDs.add(viewID);
      }
    }
    addMouseOutForPicksOfSpecifiedViews(remoteRenderedViewIDs,glMouseListener,pickDIPPoint);
  }
}",0.7319376391982183
56815,"@Override public void init(GL2 gl){
  baseDisplayListIndex=gl.glGenLists(1);
  layoutManager=new LayoutManager(viewFrustum,pixelGLConverter);
  layoutManager.setUseDisplayLists(true);
  setBrickLayoutTemplate(brickLayoutConfiguration);
  int rendererID=multiFormRenderer.getActiveRendererID();
  if (rendererID == -1) {
    multiFormRenderer.setActive(multiFormRenderer.getDefaultRendererID());
  }
  updateBrickSizeAccordingToRenderer(multiFormRenderer.getActiveRendererID());
  brickColumn.updateLayout();
  isInitialized=true;
}","@Override public void init(GL2 gl){
  layoutManager=new LayoutManager(viewFrustum,pixelGLConverter);
  layoutManager.setUseDisplayLists(true);
  setBrickLayoutTemplate(brickLayoutConfiguration);
  int rendererID=multiFormRenderer.getActiveRendererID();
  if (rendererID == -1) {
    multiFormRenderer.setActive(multiFormRenderer.getDefaultRendererID());
  }
  updateBrickSizeAccordingToRenderer(multiFormRenderer.getActiveRendererID());
  brickColumn.updateLayout();
  isInitialized=true;
}",0.9598432908912832
56816,"@Override public void display(GL2 gl){
  checkForHits(gl);
  processEvents();
  handleBrickResize(gl);
  if (isBaseDisplayListDirty)   buildBaseDisplayList(gl);
  GLStratomex stratomex=getBrickColumn().getStratomexView();
  gl.glPushName(stratomex.getPickingManager().getPickingID(stratomex.getID(),EPickingType.BRICK.name(),getID()));
  gl.glPushName(stratomex.getPickingManager().getPickingID(stratomex.getID(),EPickingType.BRICK_PENETRATING.name(),getID()));
  gl.glColor4f(1.0f,0.0f,0.0f,0.5f);
  gl.glTranslatef(0,0,0.1f);
  gl.glBegin(GL2.GL_QUADS);
  float zpos=0f;
  gl.glVertex3f(0,0,zpos);
  gl.glVertex3f(wrappingLayout.getSizeScaledX(),0,zpos);
  gl.glVertex3f(wrappingLayout.getSizeScaledX(),wrappingLayout.getSizeScaledY(),zpos);
  gl.glVertex3f(0,wrappingLayout.getSizeScaledY(),zpos);
  gl.glEnd();
  gl.glPopName();
  gl.glPopName();
  if (brickColumn.getDetailLevel() != EDetailLevel.LOW || isHeaderBrick)   layoutManager.render(gl);
  gl.glCallList(baseDisplayListIndex);
  gl.glTranslatef(0,0,-0.1f);
}","@Override public void display(GL2 gl){
  checkForHits(gl);
  processEvents();
  handleBrickResize(gl);
  GLStratomex stratomex=getBrickColumn().getStratomexView();
  gl.glPushName(stratomex.getPickingManager().getPickingID(stratomex.getID(),EPickingType.BRICK_PENETRATING.name(),getID()));
  gl.glPushName(stratomex.getPickingManager().getPickingID(stratomex.getID(),EPickingType.BRICK.name(),getID()));
  gl.glColor4f(1.0f,0.0f,0.0f,0.5f);
  gl.glTranslatef(0,0,0.1f);
  gl.glBegin(GL2.GL_QUADS);
  float zpos=0f;
  gl.glVertex3f(0,0,zpos);
  gl.glVertex3f(wrappingLayout.getSizeScaledX(),0,zpos);
  gl.glVertex3f(wrappingLayout.getSizeScaledX(),wrappingLayout.getSizeScaledY(),zpos);
  gl.glVertex3f(0,wrappingLayout.getSizeScaledY(),zpos);
  gl.glEnd();
  gl.glPopName();
  if (brickColumn.getDetailLevel() != EDetailLevel.LOW || isHeaderBrick)   layoutManager.render(gl);
  gl.glPopName();
  gl.glTranslatef(0,0,-0.1f);
}",0.7919876733436055
56817,"public AddAttachedLayoutRenderer(BrickColumn view,TourguideAdapter tourguide,boolean left){
  this.view=view;
  this.id=view.getID();
  this.tourguide=tourguide;
  this.left=left;
  view.getStratomexView().addTypePickingListener(this,EPickingType.BRICK.name());
}","public AddAttachedLayoutRenderer(BrickColumn view,TourguideAdapter tourguide,boolean left){
  this.view=view;
  this.id=view.getID();
  this.tourguide=tourguide;
  this.left=left;
  view.getStratomexView().addTypePickingListener(this,EPickingType.BRICK_PENETRATING.name());
}",0.9776951672862454
56818,"@Override public IFloatIterator iterator(){
  return new Itr();
}","@Override public IFloatIterator iterator(){
  if (isEmpty())   return Utils.EMPTY;
  if (this.dim.size() == 1)   return new SingleItr(this.rec,this.dim.get(0));
  if (this.rec.size() == 1)   return new SingleItr(this.rec.get(0),this.dim);
  return new Itr();
}",0.4
56819,"@Override public boolean hasNext(){
  return recItr.hasNext() && dimItr != null && dimItr.hasNext();
}","@Override public boolean hasNext(){
  return recItr.hasNext() || (dimItr != null && dimItr.hasNext());
}",0.970873786407767
56820,"/** 
 * <p> Returns the ColorMapper for this dataset. Warning: this only works properly for homogeneous numerical datasets. </p> <p> Use   {@link Table#getColor(Integer,Integer)} instead if you want access to a cell's color - which works for alldata types. </p> TODO: move this to Table and provide separate interfaces for homogeneous and inhomogeneous datasets.
 * @return the colorMapper, see {@link #colorMapper}
 */
public ColorMapper getColorMapper(){
  if (colorMapper == null) {
    if (this instanceof NumericalTable && ((NumericalTable)this).getDataCenter() != null) {
      colorMapper=ColorMapper.createDefaultThreeColorMapper();
    }
 else     if (this instanceof CategoricalTable<?>) {
      colorMapper=((CategoricalTable<?>)this).createColorMapper();
    }
 else {
      colorMapper=ColorMapper.createDefaultTwoColorMapper();
    }
  }
  colorMapper.update();
  return colorMapper;
}","/** 
 * <p> Returns the ColorMapper for this dataset. Warning: this only works properly for homogeneous numerical datasets. </p> <p> Use   {@link Table#getColor(Integer,Integer)} instead if you want access to a cell's color - which works for alldata types. </p> TODO: move this to Table and provide separate interfaces for homogeneous and inhomogeneous datasets.
 * @return the colorMapper, see {@link #colorMapper}
 */
public ColorMapper getColorMapper(){
  if (colorMapper == null) {
    if (this instanceof NumericalTable && ((NumericalTable)this).getDataCenter() != null) {
      colorMapper=ColorMapper.createDefaultThreeColorMapper();
    }
 else     if (this instanceof CategoricalTable<?>) {
      colorMapper=((CategoricalTable<?>)this).createColorMapper();
    }
 else {
      colorMapper=ColorMapper.createDefaultTwoColorMapper();
    }
  }
  return colorMapper;
}",0.9661781285231116
56821,"/** 
 * <p> Converts a   {@link Perspective} with an IDType that is not the {@link #recordIDType} or the{@link #dimensionIDType}, but is of the same   {@link IDCategory} as one of the two to a new Perspective with thelocal  {@link IDType}. </p> <p> Grouping, and naming is preserved, sample elements and trees are not. </p>
 */
public Perspective convertForeignPerspective(Perspective foreignPerspective){
  foreignPerspective.setCrossDatasetID(foreignPerspective.getPerspectiveID());
  IDType localIDType=getPrimaryIDType(foreignPerspective.getIdType());
  IDMappingManager idMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(localIDType);
  if (foreignPerspective.getIdType() == localIDType)   return foreignPerspective;
  VirtualArray foreignVA=foreignPerspective.getVirtualArray();
  GroupList groupList=foreignVA.getGroupList();
  PerspectiveInitializationData data=new PerspectiveInitializationData();
  ArrayList<Integer> indices=new ArrayList<Integer>(foreignVA.size());
  ArrayList<Integer> groupSizes=new ArrayList<Integer>(groupList.size());
  ArrayList<Integer> sampleElements=new ArrayList<Integer>(groupList.size());
  ArrayList<String> groupNames=new ArrayList<String>(groupList.size());
  for (  Group foreignGroup : groupList) {
    groupSizes.add(0);
    sampleElements.add(0);
    groupNames.add(foreignGroup.getLabel());
  }
  int count=0;
  int unmapped=0;
  IIDTypeMapper<Integer,Integer> mapper=idMappingManager.getIDTypeMapper(foreignVA.getIdType(),localIDType);
  for (  Integer foreignVAID : foreignVA) {
    Set<Integer> localVAIDS=mapper.apply(foreignVAID);
    if (localVAIDS == null) {
      unmapped++;
      continue;
    }
    for (    Integer localVAID : localVAIDS) {
      if (localVAID == null) {
        unmapped++;
        continue;
      }
      indices.add(localVAID);
      int groupIndex=groupList.getGroupOfVAIndex(foreignVA.indexOf(foreignVAID)).getGroupIndex();
      groupSizes.set(groupIndex,groupSizes.get(groupIndex) + 1);
      sampleElements.set(groupIndex,count);
      count++;
    }
  }
  if (unmapped > 0) {
    Logger.log(new Status(IStatus.INFO,this.toString(),""String_Node_Str"" + unmapped + ""String_Node_Str""+ foreignPerspective+ ""String_Node_Str""+ foreignPerspective.getVirtualArray().size()+ ""String_Node_Str""));
  }
  data.setData(indices,groupSizes,sampleElements,groupNames);
  Perspective localPerspective=new Perspective(this,localIDType);
  localPerspective.setUnmappedElements(unmapped);
  localPerspective.setCrossDatasetID(foreignPerspective.getCrossDatasetID());
  localPerspective.setIDType(localIDType);
  localPerspective.init(data);
  localPerspective.setLabel(foreignPerspective.getLabel(),foreignPerspective.isLabelDefault());
  return localPerspective;
}","/** 
 * <p> Converts a   {@link Perspective} with an IDType that is not the {@link #recordIDType} or the{@link #dimensionIDType}, but is of the same   {@link IDCategory} as one of the two to a new Perspective with thelocal  {@link IDType}. </p> <p> Grouping, and naming is preserved, sample elements and trees are not. </p>
 */
public Perspective convertForeignPerspective(Perspective foreignPerspective){
  foreignPerspective.setCrossDatasetID(foreignPerspective.getPerspectiveID());
  IDType localIDType=getPrimaryIDType(foreignPerspective.getIdType());
  if (foreignPerspective.getIdType() == localIDType)   return foreignPerspective;
  IDMappingManager idMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(localIDType);
  VirtualArray foreignVA=foreignPerspective.getVirtualArray();
  GroupList groupList=foreignVA.getGroupList();
  PerspectiveInitializationData data=new PerspectiveInitializationData();
  ArrayList<Integer> indices=new ArrayList<Integer>(foreignVA.size());
  ArrayList<Integer> groupSizes=new ArrayList<Integer>(groupList.size());
  ArrayList<Integer> sampleElements=new ArrayList<Integer>(groupList.size());
  ArrayList<String> groupNames=new ArrayList<String>(groupList.size());
  for (  Group foreignGroup : groupList) {
    groupSizes.add(0);
    sampleElements.add(0);
    groupNames.add(foreignGroup.getLabel());
  }
  int count=0;
  int unmapped=0;
  IIDTypeMapper<Integer,Integer> mapper=idMappingManager.getIDTypeMapper(foreignVA.getIdType(),localIDType);
  for (  Integer foreignVAID : foreignVA) {
    Set<Integer> localVAIDS=mapper.apply(foreignVAID);
    if (localVAIDS == null) {
      unmapped++;
      continue;
    }
    for (    Integer localVAID : localVAIDS) {
      if (localVAID == null) {
        unmapped++;
        continue;
      }
      indices.add(localVAID);
      int groupIndex=groupList.getGroupOfVAIndex(foreignVA.indexOf(foreignVAID)).getGroupIndex();
      groupSizes.set(groupIndex,groupSizes.get(groupIndex) + 1);
      sampleElements.set(groupIndex,count);
      count++;
    }
  }
  if (unmapped > 0) {
    Logger.log(new Status(IStatus.INFO,this.toString(),""String_Node_Str"" + unmapped + ""String_Node_Str""+ foreignPerspective+ ""String_Node_Str""+ foreignPerspective.getVirtualArray().size()+ ""String_Node_Str""));
  }
  data.setData(indices,groupSizes,sampleElements,groupNames);
  Perspective localPerspective=new Perspective(this,localIDType);
  localPerspective.setUnmappedElements(unmapped);
  localPerspective.setCrossDatasetID(foreignPerspective.getCrossDatasetID());
  localPerspective.setIDType(localIDType);
  localPerspective.init(data);
  localPerspective.setLabel(foreignPerspective.getLabel(),foreignPerspective.isLabelDefault());
  return localPerspective;
}",0.963245997088792
56822,"private void setup(GLElement child){
  IGLElementParent ex=child.getParent();
  boolean doInit=ex == null;
  if (ex == this) {
    children.remove(child);
  }
 else   if (ex != null) {
    doInit=ex.moved(child);
  }
  child.setParent(this);
  if (doInit && context != null)   child.init(context);
}","private void setup(GLElement child){
  IGLElementParent ex=child.getParent();
  boolean doInit=ex == null;
  if (ex == this) {
    children.remove(child);
  }
 else   if (ex != null) {
    doInit=!ex.moved(child);
  }
  child.setParent(this);
  if (doInit && context != null)   child.init(context);
}",0.998330550918197
56823,"private void setup(GLElement child){
  IGLElementParent ex=child.getParent();
  boolean doInit=ex == null;
  if (ex == this) {
    children.remove(child);
  }
 else   if (ex != null) {
    doInit=ex.moved(child);
  }
  GLElementAccessor.setParent(child,this);
  if (doInit && context != null)   GLElementAccessor.init(child,context);
}","private void setup(GLElement child){
  IGLElementParent ex=child.getParent();
  boolean doInit=ex == null;
  if (ex == this) {
    children.remove(child);
  }
 else   if (ex != null) {
    doInit=!ex.moved(child);
  }
  GLElementAccessor.setParent(child,this);
  if (doInit && context != null)   GLElementAccessor.init(child,context);
}",0.9985096870342772
56824,"private void fireTablePerspectiveChanged(){
  EventPublisher.trigger(new TablePerspectivesChangedEvent(this).from(this));
}","protected final void fireTablePerspectiveChanged(){
  EventPublisher.trigger(new TablePerspectivesChangedEvent(this).from(this));
}",0.9448818897637796
56825,"@Override public void handleForeignSelectionUpdate(String dataDomainType,SelectionDelta delta){
  if (delta.getIDType() == dimensionIDType) {
    SelectionUpdateEvent resendEvent=new SelectionUpdateEvent();
    resendEvent.setEventSpace(this.dataDomainID);
    SelectionDelta convertedDelta=new SelectionDelta(delta.getIDType());
    for (    SelectionDeltaItem item : delta) {
      SelectionDeltaItem convertedItem=new SelectionDeltaItem();
      convertedItem.setSelectionType(item.getSelectionType());
      Integer converteID=convertClinicalExperimentToGeneticExperiment(item.getID());
      if (converteID == null)       continue;
      convertedItem.setID(converteID);
      convertedItem.setConnectionIDs(item.getConnectionIDs());
      convertedItem.setRemove(item.isRemove());
      convertedDelta.add(convertedItem);
    }
    resendEvent.setSelectionDelta(convertedDelta);
    eventPublisher.triggerEvent(resendEvent);
  }
 else   return;
}","@Override public void handleForeignSelectionUpdate(String dataDomainType,SelectionDelta delta){
  if (dimensionIDType.equals(delta.getIDType())) {
    SelectionUpdateEvent resendEvent=new SelectionUpdateEvent();
    resendEvent.setEventSpace(this.dataDomainID);
    SelectionDelta convertedDelta=new SelectionDelta(delta.getIDType());
    for (    SelectionDeltaItem item : delta) {
      SelectionDeltaItem convertedItem=new SelectionDeltaItem();
      convertedItem.setSelectionType(item.getSelectionType());
      Integer converteID=convertClinicalExperimentToGeneticExperiment(item.getID());
      if (converteID == null)       continue;
      convertedItem.setID(converteID);
      convertedItem.setConnectionIDs(item.getConnectionIDs());
      convertedItem.setRemove(item.isRemove());
      convertedDelta.add(convertedItem);
    }
    resendEvent.setSelectionDelta(convertedDelta);
    eventPublisher.triggerEvent(resendEvent);
  }
 else   return;
}",0.9732844421162912
56826,"@Override public void handleForeignSelectionCommand(String dataDomainType,IDCategory idCategory,SelectionCommand selectionCommand){
  if (dataDomainType == CLINICAL_DATADOMAIN_TYPE && idCategory == dimensionIDCategory) {
    SelectionCommandEvent newCommandEvent=new SelectionCommandEvent();
    newCommandEvent.setSelectionCommand(selectionCommand);
    newCommandEvent.setIDCategory(idCategory);
    newCommandEvent.setEventSpace(dataDomainType);
    eventPublisher.triggerEvent(newCommandEvent);
  }
}","@Override public void handleForeignSelectionCommand(String dataDomainType,IDCategory idCategory,SelectionCommand selectionCommand){
  if (CLINICAL_DATADOMAIN_TYPE.equals(dataDomainType) && dimensionIDCategory.equals(idCategory)) {
    SelectionCommandEvent newCommandEvent=new SelectionCommandEvent();
    newCommandEvent.setSelectionCommand(selectionCommand);
    newCommandEvent.setIDCategory(idCategory);
    newCommandEvent.setEventSpace(dataDomainType);
    eventPublisher.triggerEvent(newCommandEvent);
  }
}",0.9273084479371316
56827,"@Override public void keyPressed(KeyEvent event){
switch (event.keyCode) {
case SWT.CR:
{
      if (searchButton.isEnabled())       search(searchText.getText(),caseSensitive.getSelection(),regexSearch.getSelection());
      break;
    }
}
}","@Override public void keyPressed(KeyEvent event){
switch (event.keyCode) {
case SWT.CR:
    if (searchButton.isEnabled())     search(searchText.getText(),caseSensitive.getSelection(),regexSearch.getSelection());
  break;
default :
break;
}
}",0.9313929313929314
56828,"private void createSearchGroup(Composite composite){
  Group group=new Group(composite,SWT.SHADOW_ETCHED_IN);
  group.setLayout(new RowLayout(SWT.VERTICAL));
  group.setText(""String_Node_Str"");
  Composite row=new Composite(group,SWT.NONE);
  row.setLayout(new RowLayout());
  searchText=new Text(row,SWT.BORDER | SWT.SINGLE);
  searchText.setLayoutData(new RowData(550,20));
  searchText.addFocusListener(new FocusAdapter(){
    @Override public void focusGained(    FocusEvent e){
      e.display.asyncExec(new Runnable(){
        @Override public void run(){
          searchText.selectAll();
        }
      }
);
    }
  }
);
  final Button searchButton=new Button(row,SWT.PUSH);
  searchButton.setText(""String_Node_Str"");
  searchButton.setEnabled(false);
  final ControlDecoration dec=new ControlDecoration(searchText,SWT.TOP | SWT.LEFT);
  dec.setImage(PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_DEC_FIELD_WARNING));
  dec.setShowOnlyOnFocus(true);
  dec.setDescriptionText(""String_Node_Str"");
  dec.hide();
  this.nothingFound=new ControlDecoration(searchText,SWT.TOP | SWT.LEFT);
  nothingFound.setImage(PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_DEC_FIELD_ERROR));
  nothingFound.setShowOnlyOnFocus(false);
  nothingFound.setDescriptionText(""String_Node_Str"");
  nothingFound.hide();
  searchText.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent e){
      if (searchText.getText().length() >= 3) {
        dec.hide();
        searchButton.setEnabled(true);
      }
 else {
        dec.show();
        dec.showHoverText(""String_Node_Str"");
        searchButton.setEnabled(false);
      }
    }
  }
);
  searchButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      search(searchText.getText(),caseSensitive.getSelection(),regexSearch.getSelection());
    }
  }
);
  searchText.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent event){
switch (event.keyCode) {
case SWT.CR:
{
          if (searchButton.isEnabled())           search(searchText.getText(),caseSensitive.getSelection(),regexSearch.getSelection());
          break;
        }
    }
  }
}
);
row=new Composite(group,SWT.NONE);
row.setLayout(new RowLayout());
caseSensitive=new Button(row,SWT.CHECK);
caseSensitive.setText(""String_Node_Str"");
regexSearch=new Button(row,SWT.CHECK);
regexSearch.setText(""String_Node_Str"");
}","private void createSearchGroup(Composite composite){
  Group group=new Group(composite,SWT.SHADOW_ETCHED_IN);
  group.setLayout(new RowLayout(SWT.VERTICAL));
  group.setText(""String_Node_Str"");
  Composite row=new Composite(group,SWT.NONE);
  row.setLayout(new RowLayout());
  searchText=new Text(row,SWT.BORDER | SWT.SINGLE);
  searchText.setLayoutData(new RowData(550,20));
  searchText.addFocusListener(new FocusAdapter(){
    @Override public void focusGained(    FocusEvent e){
      e.display.asyncExec(new Runnable(){
        @Override public void run(){
          searchText.selectAll();
        }
      }
);
    }
  }
);
  final Button searchButton=new Button(row,SWT.PUSH);
  searchButton.setText(""String_Node_Str"");
  searchButton.setEnabled(false);
  final ControlDecoration dec=new ControlDecoration(searchText,SWT.TOP | SWT.LEFT);
  dec.setImage(PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_DEC_FIELD_WARNING));
  dec.setShowOnlyOnFocus(true);
  dec.setDescriptionText(""String_Node_Str"");
  dec.hide();
  this.nothingFound=new ControlDecoration(searchText,SWT.TOP | SWT.LEFT);
  nothingFound.setImage(PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_DEC_FIELD_ERROR));
  nothingFound.setShowOnlyOnFocus(false);
  nothingFound.setDescriptionText(""String_Node_Str"");
  nothingFound.hide();
  searchText.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent e){
      if (searchText.getText().length() >= 3) {
        dec.hide();
        searchButton.setEnabled(true);
      }
 else {
        dec.show();
        dec.showHoverText(""String_Node_Str"");
        searchButton.setEnabled(false);
      }
    }
  }
);
  searchButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      search(searchText.getText(),caseSensitive.getSelection(),regexSearch.getSelection());
    }
  }
);
  searchText.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent event){
switch (event.keyCode) {
case SWT.CR:
        if (searchButton.isEnabled())         search(searchText.getText(),caseSensitive.getSelection(),regexSearch.getSelection());
      break;
default :
    break;
}
}
}
);
row=new Composite(group,SWT.NONE);
row.setLayout(new RowLayout());
caseSensitive=new Button(row,SWT.CHECK);
caseSensitive.setText(""String_Node_Str"");
regexSearch=new Button(row,SWT.CHECK);
regexSearch.setText(""String_Node_Str"");
}",0.9905565601768134
56829,"@Override public int compare(IRow o1,IRow o2){
  applyPrimitive(o1);
  applyPrimitive(o2);
  CacheRow r1=getCacheRow(o1);
  CacheRow r2=getCacheRow(o2);
  if (codeOrder.equalsIgnoreCase(DEFAULT_ORDER_CODE)) {
    return -Float.compare(r1.value,r2.value);
  }
 else   return runOrderScript(r1,r2);
}","@Override public int compare(IRow o1,IRow o2){
  applyPrimitive(o1);
  applyPrimitive(o2);
  CacheRow r1=getCacheRow(o1);
  CacheRow r2=getCacheRow(o2);
  if (codeOrder.equalsIgnoreCase(DEFAULT_ORDER_CODE)) {
    return Float.compare(r2.value,r1.value);
  }
 else   return runOrderScript(r1,r2);
}",0.9915966386554622
56830,"public CacheRow(float[] values,String[] raws,boolean[] inferred){
  this.raws=raws;
  this.values=values;
  this.inferred=inferred;
}","public CacheRow(float[] values){
  this.values=values;
}",0.5925925925925926
56831,"private CacheRow getCacheRow(IRow row){
  if (cacheMulti.containsKey(row.getIndex()))   return ((CacheRow)cacheMulti.get(row.getIndex()));
  float[] s=new float[this.size()];
  String[] raws=new String[s.length];
  boolean[] inferred=new boolean[s.length];
  for (int i=0; i < s.length; ++i) {
    ARankColumnModel child=get(i);
    if (child instanceof IFloatRankableColumnMixin) {
      s[i]=((IFloatRankableColumnMixin)child).applyPrimitive(row);
      inferred[i]=((IFloatRankableColumnMixin)child).isValueInferred(row);
    }
 else {
      s[i]=Float.NaN;
      inferred[i]=false;
    }
    raws[i]=get(i).getValue(row);
  }
  CacheRow cacheRow=new CacheRow(s,raws,inferred);
  cacheMulti.put(row.getIndex(),cacheRow);
  return cacheRow;
}","private CacheRow getCacheRow(IRow row){
  if (cacheMulti.containsKey(row.getIndex()))   return ((CacheRow)cacheMulti.get(row.getIndex()));
  float[] s=new float[this.size()];
  for (int i=0; i < s.length; ++i) {
    ARankColumnModel child=get(i);
    if (child instanceof IFloatRankableColumnMixin) {
      s[i]=((IFloatRankableColumnMixin)child).applyPrimitive(row);
    }
 else {
      s[i]=Float.NaN;
    }
  }
  CacheRow cacheRow=new CacheRow(s);
  cacheMulti.put(row.getIndex(),cacheRow);
  return cacheRow;
}",0.6518282988871225
56832,"@Override public int compare(ARankColumnModel o1,ARankColumnModel o2){
  return -Float.compare((float)o1.getParentData(),(float)o2.getParentData());
}","@Override public int compare(ARankColumnModel o1,ARankColumnModel o2){
  return Float.compare((float)o2.getParentData(),(float)o1.getParentData());
}",0.822742474916388
56833,"/** 
 * sorts the children decreasing by their weight
 */
public void sortByWeights(){
  cacheMulti.clear();
  sortBy(new Comparator<ARankColumnModel>(){
    @Override public int compare(    ARankColumnModel o1,    ARankColumnModel o2){
      return -Float.compare((float)o1.getParentData(),(float)o2.getParentData());
    }
  }
);
}","/** 
 * sorts the children decreasing by their weight
 */
public void sortByWeights(){
  cacheMulti.clear();
  sortBy(new Comparator<ARankColumnModel>(){
    @Override public int compare(    ARankColumnModel o1,    ARankColumnModel o2){
      return Float.compare((float)o2.getParentData(),(float)o1.getParentData());
    }
  }
);
}",0.9203007518796992
56834,"/** 
 * Calculates a normalized value based on min and max.
 * @param raw the raw value
 * @return a value between 0 and 1
 */
public double getNormalizedForRaw(String dataTransformation,double raw){
  double result;
  if (dataTransformation == org.caleydo.core.data.collection.table.Table.Transformation.LINEAR) {
    result=raw;
  }
 else   if (dataTransformation == Transformation.LOG2) {
    result=Math.log(raw) / Math.log(2);
  }
 else   if (dataTransformation == Transformation.LOG10) {
    result=Math.log10(raw);
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + dataTransformation);
  }
  result=(result - getMin()) / (getMax() - getMin());
  return result;
}","/** 
 * Calculates a normalized value based on min and max.
 * @param raw the raw value
 * @return a value between 0 and 1
 */
public double getNormalizedForRaw(String dataTransformation,double raw){
  double result;
switch (dataTransformation) {
case org.caleydo.core.data.collection.table.Table.Transformation.LINEAR:
    result=raw;
  break;
case Transformation.LOG2:
result=Math.log(raw) / Math.log(2);
break;
case Transformation.LOG10:
result=Math.log10(raw);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + dataTransformation);
}
result=(result - getMin()) / (getMax() - getMin());
return result;
}",0.8353658536585366
56835,"/** 
 * @return
 */
private static Version readVersion(){
  if (Activator.version != null)   return Activator.version;
  Properties p=new Properties();
  try {
    p.load(GeneralManager.class.getResourceAsStream(""String_Node_Str""));
  }
 catch (  IOException e) {
    Logger.log(new Status(IStatus.ERROR,""String_Node_Str"",""String_Node_Str""));
  }
  String v=p.getProperty(""String_Node_Str"",""String_Node_Str"");
  return Version.parseVersion(v);
}","/** 
 * @return
 */
private static Version readVersion(){
  if (Activator.version != null)   return Activator.version;
  Properties p=new Properties();
  try (InputStream in=GeneralManager.class.getResourceAsStream(""String_Node_Str"")){
    if (in != null)     p.load(in);
  }
 catch (  IOException e) {
    Logger.log(new Status(IStatus.ERROR,""String_Node_Str"",""String_Node_Str""));
  }
  String v=p.getProperty(""String_Node_Str"",""String_Node_Str"");
  return Version.parseVersion(v);
}",0.8159311087190527
56836,"private DataSetDescription setUpClusteredMatrixData(EDataSetType type,IDSpecification rowIDSpecification,IDSpecification columnIDSpecification,Pair<File,Boolean> pair){
  if (pair == null || pair.getFirst() == null)   return null;
  final File matrixFile=pair.getFirst();
  final boolean loadFullGenes=pair.getSecond();
  DataSetDescription dataSet=new DataSetDescription(ECreateDefaultProperties.NUMERICAL);
  dataSet.setDataSetName(dataSetName);
  dataSet.setColor(dataSetType.getColor());
  dataSet.setDataSourcePath(matrixFile.getPath());
  if (!loadFullGenes) {
    dataSet.setNumberOfHeaderLines(3);
    dataSet.getDataDescription().getNumericalProperties().setDataCenter(0d);
  }
 else {
    dataSet.setNumberOfHeaderLines(2);
    dataSet.setRowOfColumnIDs(0);
  }
  ParsingRule parsingRule=new ParsingRule();
  parsingRule.setFromColumn(2);
  parsingRule.setParseUntilEnd(true);
  parsingRule.setColumnDescripton(new ColumnDescription());
  dataSet.addParsingRule(parsingRule);
  dataSet.setTransposeMatrix(true);
  dataSet.setRowIDSpecification(rowIDSpecification);
  dataSet.setColumnIDSpecification(columnIDSpecification);
  File cnmfGroupingFile=fileFinder.findCNMFGroupingFile(type);
  if (cnmfGroupingFile != null) {
    GroupingParseSpecification grouping=new GroupingParseSpecification(cnmfGroupingFile.getPath());
    grouping.setContainsColumnIDs(false);
    grouping.setRowIDSpecification(columnIDSpecification);
    grouping.setGroupingName(""String_Node_Str"");
    dataSet.addColumnGroupingSpecification(grouping);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  File hierarchicalGroupingFile=fileFinder.findHiearchicalGrouping(type);
  if (hierarchicalGroupingFile != null) {
    GroupingParseSpecification grouping=new GroupingParseSpecification(hierarchicalGroupingFile.getPath());
    grouping.setContainsColumnIDs(false);
    grouping.setRowIDSpecification(columnIDSpecification);
    grouping.setGroupingName(""String_Node_Str"");
    dataSet.addColumnGroupingSpecification(grouping);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  DataProcessingDescription dataProcessingDescription=new DataProcessingDescription();
  dataSet.setDataProcessingDescription(dataProcessingDescription);
  ClusterConfiguration clusterConfiguration=new ClusterConfiguration();
  clusterConfiguration.setDistanceMeasure(EDistanceMeasure.EUCLIDEAN_DISTANCE);
switch (settings.getCluster()) {
case NONE:
    break;
case AFFINITY:
  AffinityClusterConfiguration affinityAlgo=new AffinityClusterConfiguration();
affinityAlgo.setClusterFactor(9);
affinityAlgo.setCacheVectors(true);
clusterConfiguration.setClusterAlgorithmConfiguration(affinityAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
break;
case KMEANS:
KMeansClusterConfiguration kMeansAlgo=new KMeansClusterConfiguration();
kMeansAlgo.setNumberOfClusters(5);
kMeansAlgo.setCacheVectors(true);
clusterConfiguration.setClusterAlgorithmConfiguration(kMeansAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
break;
case TREE:
TreeClusterConfiguration treeAlgo=new TreeClusterConfiguration();
treeAlgo.setTreeClustererAlgo(ETreeClustererAlgo.AVERAGE_LINKAGE);
clusterConfiguration.setClusterAlgorithmConfiguration(treeAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
break;
default :
log.log(Level.ALL,""String_Node_Str"" + settings.getCluster());
}
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
if (loadFullGenes) {
NumericalProperties numProp=dataSet.getDataDescription().getNumericalProperties();
numProp.setzScoreNormalization(NumericalProperties.ZSCORE_ROWS);
numProp.setClipToStdDevFactor(4f);
dataProcessingDescription.setNrRowsInSample(1500);
}
return dataSet;
}","private DataSetDescription setUpClusteredMatrixData(EDataSetType type,IDSpecification rowIDSpecification,IDSpecification columnIDSpecification,Pair<File,Boolean> pair){
  if (pair == null || pair.getFirst() == null)   return null;
  final File matrixFile=pair.getFirst();
  final boolean loadFullGenes=pair.getSecond();
  DataSetDescription dataSet=new DataSetDescription(ECreateDefaultProperties.NUMERICAL);
  dataSet.setDataSetName(dataSetName);
  dataSet.setColor(dataSetType.getColor());
  dataSet.setDataSourcePath(matrixFile.getPath());
  if (!loadFullGenes) {
    dataSet.setNumberOfHeaderLines(3);
    dataSet.getDataDescription().getNumericalProperties().setDataCenter(0d);
  }
 else {
    dataSet.setNumberOfHeaderLines(2);
    dataSet.setRowOfColumnIDs(0);
  }
  ParsingRule parsingRule=new ParsingRule();
  parsingRule.setFromColumn(2);
  parsingRule.setParseUntilEnd(true);
  parsingRule.setColumnDescripton(new ColumnDescription());
  dataSet.addParsingRule(parsingRule);
  dataSet.setTransposeMatrix(true);
  dataSet.setRowIDSpecification(rowIDSpecification);
  dataSet.setColumnIDSpecification(columnIDSpecification);
  File cnmfGroupingFile=fileFinder.findCNMFGroupingFile(type);
  if (cnmfGroupingFile != null) {
    GroupingParseSpecification grouping=new GroupingParseSpecification(cnmfGroupingFile.getPath());
    grouping.setContainsColumnIDs(false);
    grouping.setRowIDSpecification(columnIDSpecification);
    grouping.setGroupingName(""String_Node_Str"");
    dataSet.addColumnGroupingSpecification(grouping);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  File hierarchicalGroupingFile=fileFinder.findHiearchicalGrouping(type);
  if (hierarchicalGroupingFile != null) {
    GroupingParseSpecification grouping=new GroupingParseSpecification(hierarchicalGroupingFile.getPath());
    grouping.setContainsColumnIDs(false);
    grouping.setRowIDSpecification(columnIDSpecification);
    grouping.setGroupingName(""String_Node_Str"");
    dataSet.addColumnGroupingSpecification(grouping);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  DataProcessingDescription dataProcessingDescription=new DataProcessingDescription();
  dataSet.setDataProcessingDescription(dataProcessingDescription);
  ClusterConfiguration clusterConfiguration=new ClusterConfiguration();
  clusterConfiguration.setDistanceMeasure(EDistanceMeasure.EUCLIDEAN_DISTANCE);
switch (settings.getCluster()) {
case NONE:
    break;
case AFFINITY:
  AffinityClusterConfiguration affinityAlgo=new AffinityClusterConfiguration();
affinityAlgo.setClusterFactor(9);
affinityAlgo.setCacheVectors(true);
clusterConfiguration.setClusterAlgorithmConfiguration(affinityAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
break;
case KMEANS:
KMeansClusterConfiguration kMeansAlgo=new KMeansClusterConfiguration();
kMeansAlgo.setNumberOfClusters(5);
kMeansAlgo.setCacheVectors(true);
clusterConfiguration.setClusterAlgorithmConfiguration(kMeansAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
break;
case TREE:
TreeClusterConfiguration treeAlgo=new TreeClusterConfiguration();
treeAlgo.setTreeClustererAlgo(ETreeClustererAlgo.AVERAGE_LINKAGE);
clusterConfiguration.setClusterAlgorithmConfiguration(treeAlgo);
dataProcessingDescription.addRowClusterConfiguration(clusterConfiguration);
break;
default :
log.log(Level.ALL,""String_Node_Str"" + settings.getCluster());
break;
}
if (loadFullGenes) {
NumericalProperties numProp=dataSet.getDataDescription().getNumericalProperties();
numProp.setzScoreNormalization(NumericalProperties.ZSCORE_ROWS);
numProp.setClipToStdDevFactor(4f);
dataProcessingDescription.setNrRowsInSample(1500);
}
return dataSet;
}",0.9889170783816263
56837,"@Override protected void init(IGLElementContext context){
  super.init(context);
  leftSpreadPickingIds=new PickingPool(context,new IPickingListener(){
    @Override public void pick(    Pick pick){
      onLinePicked(pick,getDataDomain(),true);
    }
  }
);
  rightSpreadPickingIds=new PickingPool(context,new IPickingListener(){
    @Override public void pick(    Pick pick){
      onLinePicked(pick,getDataDomain(),false);
    }
  }
);
  int points=getDataDomain().getTable().getColorMapper().getMarkerPoints().size();
  leftSpreadPickingIds.ensure(0,points);
  rightSpreadPickingIds.ensure(0,points);
}","@Override protected void init(IGLElementContext context){
  super.init(context);
  final IPickingListener leftToolTip=context.getSWTLayer().createTooltip(new IPickingLabelProvider(){
    @Override public String getLabel(    Pick pick){
      return HistogramElement.this.getLabel(pick,true);
    }
  }
);
  leftSpreadPickingIds=new PickingPool(context,new IPickingListener(){
    @Override public void pick(    Pick pick){
      leftToolTip.pick(pick);
      onLinePicked(pick,true);
    }
  }
);
  final IPickingListener rightToolTip=context.getSWTLayer().createTooltip(new IPickingLabelProvider(){
    @Override public String getLabel(    Pick pick){
      return HistogramElement.this.getLabel(pick,false);
    }
  }
);
  rightSpreadPickingIds=new PickingPool(context,new IPickingListener(){
    @Override public void pick(    Pick pick){
      rightToolTip.pick(pick);
      onLinePicked(pick,false);
    }
  }
);
  int points=getDataDomain().getTable().getColorMapper().getMarkerPoints().size();
  leftSpreadPickingIds.ensure(0,points);
  rightSpreadPickingIds.ensure(0,points);
}",0.5819041986989947
56838,"private void onLinePicked(Pick pick,ATableBasedDataDomain dataDomain,boolean isLeftSpread){
switch (pick.getPickingMode()) {
case MOUSE_RELEASED:
    EventPublisher.trigger(new UpdateColorMappingEvent().from(this));
  break;
case MOUSE_OVER:
hoveredSpread=pick.getObjectID();
hoveredLeft=isLeftSpread;
repaint();
break;
case MOUSE_OUT:
hoveredSpread=-1;
hoveredLeft=isLeftSpread;
repaint();
break;
case CLICKED:
pick.setDoDragging(true);
break;
case DRAGGED:
List<ColorMarkerPoint> markers=dataDomain.getTable().getColorMapper().getMarkerPoints();
final int selected=pick.getObjectID();
ColorMarkerPoint point=markers.get(selected);
final float dv=pick.getDx() / (getSize().x() - getPadding() * 2);
if (dv == 0) break;
float v=dv;
if (isLeftSpread) {
v=-v + point.getLeftSpread();
if (v < 0.01f) v=0.01f;
if (selected > 0) {
ColorMarkerPoint prev=markers.get(selected - 1);
float maxv=(prev.getMappingValue() + prev.getRightSpread() + 0.01f);
v=Math.min(v,point.getMappingValue() - maxv);
}
if (v != point.getLeftSpread()) {
point.setLeftSpread(v);
updateMapping(dataDomain);
}
}
 else {
v+=point.getRightSpread();
if (v < 0.01f) v=0.01f;
if (selected < markers.size() - 1) {
ColorMarkerPoint next=markers.get(selected + 1);
v=Math.min(v,-point.getMappingValue() + (next.getMappingValue() - next.getLeftSpread() - 0.01f));
}
if (v != point.getRightSpread()) {
point.setRightSpread(v);
updateMapping(dataDomain);
}
}
break;
default :
break;
}
}","final void onLinePicked(Pick pick,boolean isLeftSpread){
  ATableBasedDataDomain dataDomain=getDataDomain();
switch (pick.getPickingMode()) {
case MOUSE_RELEASED:
    EventPublisher.trigger(new UpdateColorMappingEvent().from(this));
  break;
case MOUSE_OVER:
hoveredSpread=pick.getObjectID();
hoveredLeft=isLeftSpread;
repaint();
break;
case MOUSE_OUT:
hoveredSpread=-1;
hoveredLeft=isLeftSpread;
repaint();
break;
case CLICKED:
pick.setDoDragging(true);
break;
case DRAGGED:
List<ColorMarkerPoint> markers=dataDomain.getTable().getColorMapper().getMarkerPoints();
final int selected=pick.getObjectID();
ColorMarkerPoint point=markers.get(selected);
final float dv=pick.getDx() / (getSize().x() - getPadding() * 2);
if (dv == 0) break;
float v=dv;
if (isLeftSpread) {
v=-v + point.getLeftSpread();
if (v < 0.01f) v=0.01f;
if (selected > 0) {
ColorMarkerPoint prev=markers.get(selected - 1);
float maxv=(prev.getMappingValue() + prev.getRightSpread() + 0.01f);
v=Math.min(v,point.getMappingValue() - maxv);
}
if (v != point.getLeftSpread()) {
point.setLeftSpread(v);
updateMapping(dataDomain);
}
}
 else {
v+=point.getRightSpread();
if (v < 0.01f) v=0.01f;
if (selected < markers.size() - 1) {
ColorMarkerPoint next=markers.get(selected + 1);
v=Math.min(v,-point.getMappingValue() + (next.getMappingValue() - next.getLeftSpread() - 0.01f));
}
if (v != point.getRightSpread()) {
point.setRightSpread(v);
updateMapping(dataDomain);
}
}
break;
default :
break;
}
}",0.973475714777816
56839,"/** 
 * @param showColorMapper setter, see  {@link showColorMapper}
 */
public void setShowColorMapper(boolean showColorMapper){
  this.showColorMapper=showColorMapper;
}","/** 
 * @param showColorMapper setter, see  {@link showColorMapper}
 */
public HistogramElement setShowColorMapper(boolean showColorMapper){
  this.showColorMapper=showColorMapper;
  repaintAll();
  return this;
}",0.8668407310704961
56840,"@Override public void pick(Pick pick){
  onLinePicked(pick,getDataDomain(),false);
}","@Override public void pick(Pick pick){
  rightToolTip.pick(pick);
  onLinePicked(pick,false);
}",0.7597765363128491
56841,"/** 
 * Render the color bars for selecting the color mapping
 * @param gl
 */
private void renderColorMapper(GLGraphics g,float w,float h,ColorMapper mapper){
  final float padding=getPadding();
  w=w - 2 * padding;
  h=h - 2 * padding;
  g.save();
  g.move(padding,padding);
  List<ColorMarkerPoint> markerPoints=mapper.getMarkerPoints();
  for (int i=0; i < markerPoints.size(); ++i) {
    ColorMarkerPoint markerPoint=markerPoints.get(i);
    Color color=markerPoint.getColor();
    g.color(color.r,color.g,color.b,0.3f);
    final float v=markerPoint.getMappingValue();
    if (markerPoint.hasLeftSpread()) {
      float spread=markerPoint.getLeftSpread();
      float from=(v - spread) * w;
      float to=v * w;
      g.fillRect(from,0,to - from,h);
      g.color(SPREAD_LINE_COLOR);
      g.incZ();
      if (hoveredLeft && hoveredSpread == i) {
        g.lineWidth(3.f);
      }
      g.drawLine(from,0,from,h);
      if (hoveredLeft && hoveredSpread == i) {
        g.lineWidth(1);
      }
      g.decZ();
    }
    if (markerPoint.hasRightSpread()) {
      float spread=markerPoint.getRightSpread();
      float from=v * w;
      float to=(v + spread) * w;
      g.fillRect(from,0,to - from,h);
      g.color(SPREAD_LINE_COLOR);
      g.incZ();
      if (!hoveredLeft && hoveredSpread == i) {
        g.lineWidth(3.f);
      }
      g.drawLine(to,0,to,h);
      if (!hoveredLeft && hoveredSpread == i) {
        g.lineWidth(1);
      }
      g.decZ();
    }
  }
  g.restore();
}","/** 
 * Render the color bars for selecting the color mapping
 * @param gl
 */
private void renderColorMapper(GLGraphics g,float w,float h,ColorMapper mapper){
  final float padding=getPadding();
  w=w - 2 * padding;
  h=h - 2 * padding;
  g.save();
  g.move(padding,padding);
  float lineHeight=this.showMarkerLabels ? h + padding - 1 : h;
  List<ColorMarkerPoint> markerPoints=mapper.getMarkerPoints();
  for (int i=0; i < markerPoints.size(); ++i) {
    ColorMarkerPoint markerPoint=markerPoints.get(i);
    Color color=markerPoint.getColor();
    g.color(color.r,color.g,color.b,0.3f);
    final float v=markerPoint.getMappingValue();
    if (markerPoint.hasLeftSpread()) {
      float spread=markerPoint.getLeftSpread();
      float from=(v - spread) * w;
      float to=v * w;
      g.fillRect(from,0,to - from,h);
      g.color(SPREAD_LINE_COLOR);
      g.incZ();
      if (hoveredLeft && hoveredSpread == i) {
        g.lineWidth(3.f);
      }
      g.drawLine(from,0,from,lineHeight);
      if (hoveredLeft && hoveredSpread == i) {
        g.lineWidth(1);
      }
      g.decZ();
      if (spread > HistogramRenderStyle.SPREAD_CAPTION_THRESHOLD)       renderCaption(g,v - spread,w,h);
    }
    if (markerPoint.hasRightSpread()) {
      float spread=markerPoint.getRightSpread();
      float from=v * w;
      float to=(v + spread) * w;
      g.fillRect(from,0,to - from,h);
      g.color(SPREAD_LINE_COLOR);
      g.incZ();
      if (!hoveredLeft && hoveredSpread == i) {
        g.lineWidth(3.f);
      }
      g.drawLine(to,0,to,lineHeight);
      if (!hoveredLeft && hoveredSpread == i) {
        g.lineWidth(1);
      }
      g.decZ();
      if (spread > HistogramRenderStyle.SPREAD_CAPTION_THRESHOLD)       renderCaption(g,v + spread,w,h);
    }
    renderCaption(g,v,w,h);
  }
  g.restore();
}",0.9017586416009704
56842,"@Override public GLElement create(GLElementFactoryContext context){
  TablePerspective data=context.getData();
  EDetailLevel detailLevel=context.get(EDetailLevel.class,EDetailLevel.LOW);
  HistogramElement elem=new HistogramElement(data,detailLevel);
  elem.setShowColorMapper(context.is(""String_Node_Str""));
  return elem;
}","@Override public GLElement create(GLElementFactoryContext context){
  TablePerspective data=context.getData();
  EDetailLevel detailLevel=context.get(EDetailLevel.class,EDetailLevel.LOW);
  HistogramElement elem=new HistogramElement(data,detailLevel);
  elem.setShowColorMapper(context.is(""String_Node_Str""));
  elem.setShowMarkerLabels(context.is(""String_Node_Str""));
  return elem;
}",0.9170182841068916
56843,"private RunOverview[] createModel(File file){
  Gson gson=new Gson();
  RunOverview[] fromJson;
  try (Reader r=new FileReader(file)){
    fromJson=gson.fromJson(r,RunOverview[].class);
    Arrays.sort(fromJson,Collections.reverseOrder());
    return fromJson;
  }
 catch (  JsonSyntaxException|JsonIOException|IOException e) {
    log.error(""String_Node_Str"" + file.getAbsolutePath(),e);
    return new RunOverview[0];
  }
}","private RunOverview[] createModel(File file){
  Gson gson=new Gson();
  RunOverview[] fromJson;
  try (Reader r=Files.newReader(file,Charset.defaultCharset())){
    fromJson=gson.fromJson(r,RunOverview[].class);
    Arrays.sort(fromJson,Collections.reverseOrder());
    return fromJson;
  }
 catch (  JsonSyntaxException|JsonIOException|IOException e) {
    log.error(""String_Node_Str"" + file.getAbsolutePath(),e);
    return new RunOverview[0];
  }
}",0.9360730593607306
56844,"public boolean resolve(Gson gson,String prefix) throws JsonSyntaxException, JsonIOException, IOException {
  if (data != null)   return true;
  File file=RemoteFile.of(new URL(prefix + json)).getOrLoad(true,new NullProgressMonitor());
  if (file == null)   return false;
  try (Reader r=new FileReader(file)){
    JsonElement parse=new JsonParser().parse(r);
    this.data=gson.fromJson(parse,Run.class);
  }
   Collections.sort(this.data.details);
  return true;
}","public boolean resolve(Gson gson,String prefix) throws JsonSyntaxException, JsonIOException, IOException {
  if (data != null)   return true;
  File file=RemoteFile.of(new URL(prefix + json)).getOrLoad(true,new NullProgressMonitor());
  if (file == null)   return false;
  try (Reader r=Files.newBufferedReader(file.toPath(),Charset.defaultCharset())){
    JsonElement parse=new JsonParser().parse(r);
    this.data=gson.fromJson(parse,Run.class);
  }
   Collections.sort(this.data.details);
  return true;
}",0.9455292908530318
56845,"@ListenTo private void onSelectionCommand(SelectionCommandEvent event){
  IDCategory idCategory=event.getIdCategory();
  SelectionCommand cmd=event.getSelectionCommand();
  for (  SelectionManager selectionManager : selectionManagers) {
    final IDType sidType=selectionManager.getIDType();
    if ((idCategory == null || idCategory.isOfCategory(sidType)) && !(event.getSender() == selectionManager)) {
      selectionManager.executeSelectionCommand(cmd);
      callback.onSelectionUpdate(selectionManager);
    }
  }
}","@ListenTo private void onSelectionCommand(SelectionCommandEvent event){
  if (event.getSender() == this)   return;
  IDCategory idCategory=event.getIdCategory();
  SelectionCommand cmd=event.getSelectionCommand();
  for (  SelectionManager selectionManager : selectionManagers) {
    final IDType sidType=selectionManager.getIDType();
    if ((idCategory == null || idCategory.isOfCategory(sidType)) && (event.getSender() != selectionManager)) {
      selectionManager.executeSelectionCommand(cmd);
      callback.onSelectionUpdate(selectionManager);
    }
  }
}",0.9242144177449167
56846,"@Override protected void parseFile(BufferedReader reader) throws IOException {
  SubMonitor monitor=GeneralManager.get().createSubProgressMonitor();
  monitor.beginTask(""String_Node_Str"" + targetIDType,numberOfLinesInFile + 20);
  IDSpecification idSpecification=groupingSpecifications.getRowIDSpecification();
  IDType sourceIDType=IDType.getIDType(idSpecification.getIdType());
  IDTypeParsingRules parsingRules=null;
  if (idSpecification.getIdTypeParsingRules() != null)   parsingRules=idSpecification.getIdTypeParsingRules();
 else   if (sourceIDType.getIdTypeParsingRules() != null)   parsingRules=sourceIDType.getIdTypeParsingRules();
  if (!sourceIDType.getIDCategory().equals(targetIDType.getIDCategory()))   throw new IllegalArgumentException(""String_Node_Str"" + sourceIDType + ""String_Node_Str""+ targetIDType);
  IDMappingManager idMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(sourceIDType.getIDCategory());
  if (groupingSpecifications.getDataSourcePath() == null) {
    Logger.log(new Status(IStatus.INFO,this.toString(),""String_Node_Str""));
    monitor.done();
    return;
  }
  try {
    String[] headerCells=null;
    if (groupingSpecifications.isContainsColumnIDs()) {
      reader=loader.getResource(groupingSpecifications.getDataSourcePath());
      String headerLine=""String_Node_Str"";
      int rowOfColumnIDs=(groupingSpecifications.getRowOfColumnIDs() != null) ? groupingSpecifications.getRowOfColumnIDs() : groupingSpecifications.getNumberOfHeaderLines() - 1;
      for (int countToHeader=0; countToHeader <= rowOfColumnIDs; countToHeader++) {
        headerLine=reader.readLine();
      }
      headerCells=headerLine.split(groupingSpecifications.getDelimiter(),-1);
      reader.close();
    }
    reader=loader.getResource(groupingSpecifications.getDataSourcePath());
    for (int headerLineCounter=0; headerLineCounter < groupingSpecifications.getNumberOfHeaderLines(); headerLineCounter++) {
      reader.readLine();
    }
    ArrayList<Integer> columnsToRead=groupingSpecifications.getColumns();
    String firstDataLine=null;
    if (columnsToRead == null || headerCells == null) {
      firstDataLine=reader.readLine();
      String[] data=firstDataLine.split(groupingSpecifications.getDelimiter());
      if (columnsToRead == null) {
        columnsToRead=new ArrayList<Integer>(data.length);
        for (int columnCount=1; columnCount < data.length; columnCount++) {
          columnsToRead.add(columnCount);
        }
      }
      if (headerCells == null) {
        headerCells=new String[data.length];
        for (int columnCount=0; columnCount < data.length; columnCount++) {
          headerCells[columnCount]=DEFAULT_GROUP_NAME;
        }
      }
    }
    ArrayList<ArrayList<Pair<String,ArrayList<Integer>>>> listOfGroupLists=new ArrayList<ArrayList<Pair<String,ArrayList<Integer>>>>(columnsToRead.size());
    ArrayList<String> listOfGroupNames=new ArrayList<String>(columnsToRead.size());
    ArrayList<Pair<String,ArrayList<Integer>>> currentGroupList;
    for (    Integer columnNumber : columnsToRead) {
      currentGroupList=new ArrayList<Pair<String,ArrayList<Integer>>>();
      listOfGroupLists.add(currentGroupList);
      listOfGroupNames.add(headerCells[columnNumber]);
    }
    int lineCounter=0;
    while (true) {
      String line=null;
      if (firstDataLine == null) {
        line=reader.readLine();
      }
 else {
        line=firstDataLine;
        firstDataLine=null;
      }
      if (line == null)       break;
      lineCounter++;
      if (lineCounter % 100 == 0)       monitor.worked(100);
      String[] columns=line.split(groupingSpecifications.getDelimiter());
      String originalID=columns[groupingSpecifications.getColumnOfRowIds()];
      originalID=convertID(originalID,parsingRules);
      Integer mappedID=idMappingManager.getID(sourceIDType,targetIDType,originalID);
      if (mappedID == null) {
        Logger.log(new Status(IStatus.WARNING,this.toString(),""String_Node_Str"" + originalID));
        continue;
      }
      int groupListCounter=0;
      for (      Integer columnID : columnsToRead) {
        currentGroupList=listOfGroupLists.get(groupListCounter);
        ArrayList<Integer> group=null;
        for (        Pair<String,ArrayList<Integer>> groupPair : currentGroupList) {
          if (groupPair.getFirst().equals(columns[columnID]))           group=groupPair.getSecond();
        }
        if (group == null) {
          group=new ArrayList<Integer>();
          currentGroupList.add(new Pair<String,ArrayList<Integer>>(columns[columnID],group));
        }
        group.add(mappedID);
        groupListCounter++;
      }
    }
    monitor.setWorkRemaining(20);
    perspectiveInitializationDatas=new ArrayList<PerspectiveInitializationData>();
    for (int groupListCount=0; groupListCount < listOfGroupLists.size(); groupListCount++) {
      ArrayList<Pair<String,ArrayList<Integer>>> groupList=listOfGroupLists.get(groupListCount);
      ArrayList<Integer> sortedIDs=new ArrayList<Integer>();
      ArrayList<Integer> clusterSizes=new ArrayList<Integer>(groupList.size());
      ArrayList<Integer> sampleElements=new ArrayList<Integer>(groupList.size());
      ArrayList<String> clusterNames=new ArrayList<String>(groupList.size());
      int sampleIndex=0;
      for (      Pair<String,ArrayList<Integer>> groupPair : groupList) {
        ArrayList<Integer> group=groupPair.getSecond();
        sortedIDs.addAll(group);
        clusterSizes.add(group.size());
        clusterNames.add(groupPair.getFirst());
        sampleElements.add(sampleIndex);
        sampleIndex+=group.size();
      }
      PerspectiveInitializationData data=new PerspectiveInitializationData();
      data.setData(sortedIDs,clusterSizes,sampleElements,clusterNames);
      String groupLabel=listOfGroupNames.get(groupListCount);
      if (groupLabel.equals(DEFAULT_GROUP_NAME)) {
        if (groupingSpecifications.getGroupingNames() != null) {
          groupLabel=clusterSizes.size() + ""String_Node_Str"" + groupingSpecifications.getGroupingNames().get(groupListCount);
        }
 else         if (groupingSpecifications.getGroupingName() != null) {
          groupLabel=clusterSizes + groupingSpecifications.getGroupingName();
        }
 else {
          groupLabel=clusterSizes.size() + ""String_Node_Str"";
        }
      }
      data.setLabel(groupLabel);
      perspectiveInitializationDatas.add(data);
    }
  }
 catch (  IOException ioException) {
    throw new IllegalStateException(""String_Node_Str"" + groupingSpecifications.getDataSourcePath());
  }
 finally {
    monitor.done();
    reader.close();
  }
}","@Override protected void parseFile(BufferedReader reader) throws IOException {
  SubMonitor monitor=GeneralManager.get().createSubProgressMonitor();
  monitor.beginTask(""String_Node_Str"" + targetIDType,numberOfLinesInFile + 20);
  IDSpecification idSpecification=groupingSpecifications.getRowIDSpecification();
  IDType sourceIDType=IDType.getIDType(idSpecification.getIdType());
  IDTypeParsingRules parsingRules=null;
  if (idSpecification.getIdTypeParsingRules() != null)   parsingRules=idSpecification.getIdTypeParsingRules();
 else   if (sourceIDType.getIdTypeParsingRules() != null)   parsingRules=sourceIDType.getIdTypeParsingRules();
  if (!sourceIDType.getIDCategory().equals(targetIDType.getIDCategory()))   throw new IllegalArgumentException(""String_Node_Str"" + sourceIDType + ""String_Node_Str""+ targetIDType);
  IDMappingManager idMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(sourceIDType.getIDCategory());
  if (groupingSpecifications.getDataSourcePath() == null) {
    Logger.log(new Status(IStatus.INFO,this.toString(),""String_Node_Str""));
    monitor.done();
    return;
  }
  try {
    String[] headerCells=null;
    if (groupingSpecifications.isContainsColumnIDs()) {
      reader=loader.getResource(groupingSpecifications.getDataSourcePath());
      String headerLine=""String_Node_Str"";
      int rowOfColumnIDs=(groupingSpecifications.getRowOfColumnIDs() != null) ? groupingSpecifications.getRowOfColumnIDs() : groupingSpecifications.getNumberOfHeaderLines() - 1;
      for (int countToHeader=0; countToHeader <= rowOfColumnIDs; countToHeader++) {
        headerLine=reader.readLine();
      }
      headerCells=headerLine.split(groupingSpecifications.getDelimiter(),-1);
      reader.close();
    }
    reader=loader.getResource(groupingSpecifications.getDataSourcePath());
    for (int headerLineCounter=0; headerLineCounter < groupingSpecifications.getNumberOfHeaderLines(); headerLineCounter++) {
      reader.readLine();
    }
    ArrayList<Integer> columnsToRead=groupingSpecifications.getColumns();
    String firstDataLine=null;
    if (columnsToRead == null || headerCells == null) {
      firstDataLine=reader.readLine();
      String[] data=firstDataLine.split(groupingSpecifications.getDelimiter());
      if (columnsToRead == null) {
        columnsToRead=new ArrayList<Integer>(data.length);
        for (int columnCount=1; columnCount < data.length; columnCount++) {
          columnsToRead.add(columnCount);
        }
      }
      if (headerCells == null) {
        headerCells=new String[data.length];
        for (int columnCount=0; columnCount < data.length; columnCount++) {
          headerCells[columnCount]=DEFAULT_GROUP_NAME;
        }
      }
    }
    ArrayList<ArrayList<Pair<String,ArrayList<Integer>>>> listOfGroupLists=new ArrayList<ArrayList<Pair<String,ArrayList<Integer>>>>(columnsToRead.size());
    ArrayList<String> listOfGroupNames=new ArrayList<String>(columnsToRead.size());
    ArrayList<Pair<String,ArrayList<Integer>>> currentGroupList;
    for (    Integer columnNumber : columnsToRead) {
      currentGroupList=new ArrayList<Pair<String,ArrayList<Integer>>>();
      listOfGroupLists.add(currentGroupList);
      listOfGroupNames.add(headerCells[columnNumber]);
    }
    int lineCounter=0;
    while (true) {
      String line=null;
      if (firstDataLine == null) {
        line=reader.readLine();
      }
 else {
        line=firstDataLine;
        firstDataLine=null;
      }
      if (line == null)       break;
      lineCounter++;
      if (lineCounter % 100 == 0)       monitor.worked(100);
      String[] columns=line.split(groupingSpecifications.getDelimiter());
      String originalID=columns[groupingSpecifications.getColumnOfRowIds()];
      originalID=convertID(originalID,parsingRules);
      Integer mappedID=idMappingManager.getID(sourceIDType,targetIDType,originalID);
      if (mappedID == null) {
        Logger.log(new Status(IStatus.WARNING,this.toString(),""String_Node_Str"" + originalID));
        continue;
      }
      int groupListCounter=0;
      for (      Integer columnID : columnsToRead) {
        currentGroupList=listOfGroupLists.get(groupListCounter);
        ArrayList<Integer> group=null;
        for (        Pair<String,ArrayList<Integer>> groupPair : currentGroupList) {
          if (groupPair.getFirst().equals(columns[columnID]))           group=groupPair.getSecond();
        }
        if (group == null) {
          group=new ArrayList<Integer>();
          currentGroupList.add(new Pair<String,ArrayList<Integer>>(columns[columnID],group));
        }
        group.add(mappedID);
        groupListCounter++;
      }
    }
    monitor.setWorkRemaining(20);
    perspectiveInitializationDatas=new ArrayList<PerspectiveInitializationData>();
    for (int groupListCount=0; groupListCount < listOfGroupLists.size(); groupListCount++) {
      ArrayList<Pair<String,ArrayList<Integer>>> groupList=listOfGroupLists.get(groupListCount);
      ArrayList<Integer> sortedIDs=new ArrayList<Integer>();
      ArrayList<Integer> clusterSizes=new ArrayList<Integer>(groupList.size());
      ArrayList<Integer> sampleElements=new ArrayList<Integer>(groupList.size());
      ArrayList<String> clusterNames=new ArrayList<String>(groupList.size());
      int sampleIndex=0;
      for (      Pair<String,ArrayList<Integer>> groupPair : groupList) {
        ArrayList<Integer> group=groupPair.getSecond();
        sortedIDs.addAll(group);
        clusterSizes.add(group.size());
        clusterNames.add(groupPair.getFirst());
        sampleElements.add(sampleIndex);
        sampleIndex+=group.size();
      }
      PerspectiveInitializationData data=new PerspectiveInitializationData();
      data.setData(sortedIDs,clusterSizes,sampleElements,clusterNames);
      String groupLabel=listOfGroupNames.get(groupListCount);
      if (groupLabel.equals(DEFAULT_GROUP_NAME)) {
        if (groupingSpecifications.getGroupingNames() != null) {
          groupLabel=clusterSizes.size() + ""String_Node_Str"" + groupingSpecifications.getGroupingNames().get(groupListCount);
        }
 else         if (groupingSpecifications.getGroupingName() != null) {
          groupLabel=clusterSizes.size() + groupingSpecifications.getGroupingName();
        }
 else {
          groupLabel=clusterSizes.size() + ""String_Node_Str"";
        }
      }
      data.setLabel(groupLabel);
      perspectiveInitializationDatas.add(data);
    }
  }
 catch (  IOException ioException) {
    throw new IllegalStateException(""String_Node_Str"" + groupingSpecifications.getDataSourcePath());
  }
 finally {
    monitor.done();
    reader.close();
  }
}",0.9994718177016524
56847,"@Override public synchronized boolean create(){
  if (!super.create())   return false;
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      ((Shell)parentComposite).setText(TITLE);
      GridData gridData=new GridData();
      gridData.grabExcessHorizontalSpace=true;
      gridData.horizontalAlignment=GridData.FILL;
      Composite infoComposite=new Composite(parentComposite,SWT.NULL);
      infoComposite.setLayoutData(gridData);
      infoComposite.setLayout(new GridLayout(4,false));
      Label pValueLabel=new Label(infoComposite,SWT.NONE);
      pValueLabel.setText(""String_Node_Str"");
      final Text pValueInputField=new Text(infoComposite,SWT.SINGLE);
      final Slider pValueSlider=new Slider(infoComposite,SWT.HORIZONTAL);
      if (pValue == -1) {
        pValueMax=histogram.getMax();
        pValue=pValueMax;
      }
      gridData=new GridData();
      gridData.grabExcessHorizontalSpace=true;
      gridData.horizontalAlignment=GridData.FILL;
      pValueSlider.setLayoutData(gridData);
      pValueSlider.setSelection((int)(pValue * 10000));
      pValueInputField.setEditable(true);
      pValueInputField.setText(Float.toString(pValue));
      pValueInputField.addKeyListener(new KeyAdapter(){
        @Override public void keyPressed(        KeyEvent e){
          String enteredValue=pValueInputField.getText();
          pValue=new Float(enteredValue);
          pValueSlider.setSelection((int)(pValue * 10000));
          isDirty=true;
        }
      }
);
      pValueSlider.setMinimum(0);
      pValueSlider.setMaximum((int)(pValueMax * 10000));
      pValueSlider.setIncrement(1);
      pValueSlider.setPageIncrement(5);
      pValueSlider.setSelection((int)(pValue * 10000));
      pValueSlider.addMouseListener(new MouseAdapter(){
        @Override public void mouseUp(        MouseEvent e){
          pValue=pValueSlider.getSelection() / 10000.00f;
          pValueInputField.setText(Float.toString(pValue));
          isDirty=true;
          parentComposite.pack();
          parentComposite.layout();
        }
      }
);
      final Button applyFilterButton=new Button(infoComposite,SWT.PUSH);
      applyFilterButton.setText(""String_Node_Str"");
      applyFilterButton.addSelectionListener(new SelectionAdapter(){
        @Override public void widgetSelected(        SelectionEvent e){
          applyFilter();
        }
      }
);
      Composite histoComposite=new Composite(parentComposite,SWT.NULL);
      histoComposite.setLayout(new FillLayout(SWT.VERTICAL));
      gridData=new GridData();
      gridData.heightHint=300;
      gridData.widthHint=500;
      histoComposite.setLayoutData(gridData);
      RcpGLHistogramView histogramView=new RcpGLHistogramView();
      histogramView.setDataDomain(dataDomain);
      histogramView.createDefaultSerializedView();
      histogramView.createPartControl(histoComposite);
      ((GLHistogram)(histogramView.getGLView())).setHistogram(histogram);
      GeneralManager.get().getViewManager().registerGLCanvasToAnimator(histogramView.getGLCanvas());
    }
  }
);
  addOKCancel();
  return true;
}","@Override public synchronized boolean create(){
  if (!super.create())   return false;
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      ((Shell)parentComposite).setText(TITLE);
      GridData gridData=new GridData();
      gridData.grabExcessHorizontalSpace=true;
      gridData.horizontalAlignment=GridData.FILL;
      Composite infoComposite=new Composite(parentComposite,SWT.NULL);
      infoComposite.setLayoutData(gridData);
      infoComposite.setLayout(new GridLayout(4,false));
      Label pValueLabel=new Label(infoComposite,SWT.NONE);
      pValueLabel.setText(""String_Node_Str"");
      final Text pValueInputField=new Text(infoComposite,SWT.SINGLE);
      final Slider pValueSlider=new Slider(infoComposite,SWT.HORIZONTAL);
      if (pValue == -1) {
        pValueMax=0;
        pValue=pValueMax;
      }
      gridData=new GridData();
      gridData.grabExcessHorizontalSpace=true;
      gridData.horizontalAlignment=GridData.FILL;
      pValueSlider.setLayoutData(gridData);
      pValueSlider.setSelection((int)(pValue * 10000));
      pValueInputField.setEditable(true);
      pValueInputField.setText(Float.toString(pValue));
      pValueInputField.addKeyListener(new KeyAdapter(){
        @Override public void keyPressed(        KeyEvent e){
          String enteredValue=pValueInputField.getText();
          pValue=new Float(enteredValue);
          pValueSlider.setSelection((int)(pValue * 10000));
          isDirty=true;
        }
      }
);
      pValueSlider.setMinimum(0);
      pValueSlider.setMaximum((int)(pValueMax * 10000));
      pValueSlider.setIncrement(1);
      pValueSlider.setPageIncrement(5);
      pValueSlider.setSelection((int)(pValue * 10000));
      pValueSlider.addMouseListener(new MouseAdapter(){
        @Override public void mouseUp(        MouseEvent e){
          pValue=pValueSlider.getSelection() / 10000.00f;
          pValueInputField.setText(Float.toString(pValue));
          isDirty=true;
          parentComposite.pack();
          parentComposite.layout();
        }
      }
);
      final Button applyFilterButton=new Button(infoComposite,SWT.PUSH);
      applyFilterButton.setText(""String_Node_Str"");
      applyFilterButton.addSelectionListener(new SelectionAdapter(){
        @Override public void widgetSelected(        SelectionEvent e){
          applyFilter();
        }
      }
);
      Composite histoComposite=new Composite(parentComposite,SWT.NULL);
      histoComposite.setLayout(new FillLayout(SWT.VERTICAL));
      gridData=new GridData();
      gridData.heightHint=300;
      gridData.widthHint=500;
      histoComposite.setLayoutData(gridData);
      RcpGLHistogramView histogramView=new RcpGLHistogramView();
      histogramView.setDataDomain(dataDomain);
      histogramView.createDefaultSerializedView();
      histogramView.createPartControl(histoComposite);
      ((GLHistogram)(histogramView.getGLView())).setHistogram(histogram);
      GeneralManager.get().getViewManager().registerGLCanvasToAnimator(histogramView.getGLCanvas());
    }
  }
);
  addOKCancel();
  return true;
}",0.996943863599807
56848,"@Override public void run(){
  ((Shell)parentComposite).setText(TITLE);
  GridData gridData=new GridData();
  gridData.grabExcessHorizontalSpace=true;
  gridData.horizontalAlignment=GridData.FILL;
  Composite infoComposite=new Composite(parentComposite,SWT.NULL);
  infoComposite.setLayoutData(gridData);
  infoComposite.setLayout(new GridLayout(4,false));
  Label pValueLabel=new Label(infoComposite,SWT.NONE);
  pValueLabel.setText(""String_Node_Str"");
  final Text pValueInputField=new Text(infoComposite,SWT.SINGLE);
  final Slider pValueSlider=new Slider(infoComposite,SWT.HORIZONTAL);
  if (pValue == -1) {
    pValueMax=histogram.getMax();
    pValue=pValueMax;
  }
  gridData=new GridData();
  gridData.grabExcessHorizontalSpace=true;
  gridData.horizontalAlignment=GridData.FILL;
  pValueSlider.setLayoutData(gridData);
  pValueSlider.setSelection((int)(pValue * 10000));
  pValueInputField.setEditable(true);
  pValueInputField.setText(Float.toString(pValue));
  pValueInputField.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      String enteredValue=pValueInputField.getText();
      pValue=new Float(enteredValue);
      pValueSlider.setSelection((int)(pValue * 10000));
      isDirty=true;
    }
  }
);
  pValueSlider.setMinimum(0);
  pValueSlider.setMaximum((int)(pValueMax * 10000));
  pValueSlider.setIncrement(1);
  pValueSlider.setPageIncrement(5);
  pValueSlider.setSelection((int)(pValue * 10000));
  pValueSlider.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent e){
      pValue=pValueSlider.getSelection() / 10000.00f;
      pValueInputField.setText(Float.toString(pValue));
      isDirty=true;
      parentComposite.pack();
      parentComposite.layout();
    }
  }
);
  final Button applyFilterButton=new Button(infoComposite,SWT.PUSH);
  applyFilterButton.setText(""String_Node_Str"");
  applyFilterButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      applyFilter();
    }
  }
);
  Composite histoComposite=new Composite(parentComposite,SWT.NULL);
  histoComposite.setLayout(new FillLayout(SWT.VERTICAL));
  gridData=new GridData();
  gridData.heightHint=300;
  gridData.widthHint=500;
  histoComposite.setLayoutData(gridData);
  RcpGLHistogramView histogramView=new RcpGLHistogramView();
  histogramView.setDataDomain(dataDomain);
  histogramView.createDefaultSerializedView();
  histogramView.createPartControl(histoComposite);
  ((GLHistogram)(histogramView.getGLView())).setHistogram(histogram);
  GeneralManager.get().getViewManager().registerGLCanvasToAnimator(histogramView.getGLCanvas());
}","@Override public void run(){
  ((Shell)parentComposite).setText(TITLE);
  GridData gridData=new GridData();
  gridData.grabExcessHorizontalSpace=true;
  gridData.horizontalAlignment=GridData.FILL;
  Composite infoComposite=new Composite(parentComposite,SWT.NULL);
  infoComposite.setLayoutData(gridData);
  infoComposite.setLayout(new GridLayout(4,false));
  Label pValueLabel=new Label(infoComposite,SWT.NONE);
  pValueLabel.setText(""String_Node_Str"");
  final Text pValueInputField=new Text(infoComposite,SWT.SINGLE);
  final Slider pValueSlider=new Slider(infoComposite,SWT.HORIZONTAL);
  if (pValue == -1) {
    pValueMax=0;
    pValue=pValueMax;
  }
  gridData=new GridData();
  gridData.grabExcessHorizontalSpace=true;
  gridData.horizontalAlignment=GridData.FILL;
  pValueSlider.setLayoutData(gridData);
  pValueSlider.setSelection((int)(pValue * 10000));
  pValueInputField.setEditable(true);
  pValueInputField.setText(Float.toString(pValue));
  pValueInputField.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      String enteredValue=pValueInputField.getText();
      pValue=new Float(enteredValue);
      pValueSlider.setSelection((int)(pValue * 10000));
      isDirty=true;
    }
  }
);
  pValueSlider.setMinimum(0);
  pValueSlider.setMaximum((int)(pValueMax * 10000));
  pValueSlider.setIncrement(1);
  pValueSlider.setPageIncrement(5);
  pValueSlider.setSelection((int)(pValue * 10000));
  pValueSlider.addMouseListener(new MouseAdapter(){
    @Override public void mouseUp(    MouseEvent e){
      pValue=pValueSlider.getSelection() / 10000.00f;
      pValueInputField.setText(Float.toString(pValue));
      isDirty=true;
      parentComposite.pack();
      parentComposite.layout();
    }
  }
);
  final Button applyFilterButton=new Button(infoComposite,SWT.PUSH);
  applyFilterButton.setText(""String_Node_Str"");
  applyFilterButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      applyFilter();
    }
  }
);
  Composite histoComposite=new Composite(parentComposite,SWT.NULL);
  histoComposite.setLayout(new FillLayout(SWT.VERTICAL));
  gridData=new GridData();
  gridData.heightHint=300;
  gridData.widthHint=500;
  histoComposite.setLayoutData(gridData);
  RcpGLHistogramView histogramView=new RcpGLHistogramView();
  histogramView.setDataDomain(dataDomain);
  histogramView.createDefaultSerializedView();
  histogramView.createPartControl(histoComposite);
  ((GLHistogram)(histogramView.getGLView())).setHistogram(histogram);
  GeneralManager.get().getViewManager().registerGLCanvasToAnimator(histogramView.getGLCanvas());
}",0.9964278999811996
56849,"@Override protected void onMouseWheel(Pick pick){
  setValue(unmapValue(mapValue(value) + ((IMouseEvent)(pick)).getWheelRotation() * wheelInc));
  repaintAll();
}","@Override protected void onMouseWheel(Pick pick){
  setValue(unmapValue(mapValue(getSize().x()) + ((IMouseEvent)(pick)).getWheelRotation() * wheelInc));
  repaintAll();
}",0.9518072289156626
56850,"/** 
 * returns a list a element suppliers that can be created using the given parameters
 * @param context the context with all the parameters set
 * @param callerId the id of the caller (for including excluding)
 * @param filter a additional filter to include / exclude from the caller side
 * @return
 */
public static ImmutableList<GLElementSupplier> getExtensions(GLElementFactoryContext context,String callerId,Predicate<? super String> filter){
  ImmutableList.Builder<GLElementSupplier> builder=ImmutableList.builder();
  for (  ElementExtension elem : extensions) {
    if (!filter.apply(elem.getId()) || !elem.canCreate(callerId,context))     continue;
    builder.add(new GLElementSupplier(elem,context));
  }
  return builder.build();
}","/** 
 * returns a list a element suppliers that can be created using the given parameters
 * @param context the context with all the parameters set
 * @param callerId the id of the caller (for including excluding)
 * @param filter a additional filter to include / exclude from the caller side
 * @return
 */
public static ImmutableList<GLElementSupplier> getExtensions(GLElementFactoryContext context,String callerId,Predicate<? super String> filter){
  ImmutableList.Builder<GLElementSupplier> builder=ImmutableList.builder();
  for (  ElementExtension elem : extensions) {
    if ((filter != null && !filter.apply(elem.getId())) || !elem.canCreate(callerId,context))     continue;
    builder.add(new GLElementSupplier(elem,context));
  }
  return builder.build();
}",0.9868073878627968
56851,"@Override protected void renderPickImpl(GLGraphics g,float w,float h){
  super.renderPickImpl(g,w,h);
  GLElement selected=getSelected();
  if (selected != null)   selected.renderPick(g);
}","@Override protected void renderPickImpl(GLGraphics g,float w,float h){
  super.renderPickImpl(g,w,h);
  GLElement selected=getActiveElement();
  if (selected != null)   selected.renderPick(g);
}",0.9660574412532638
56852,"/** 
 * @param children
 * @param instances
 * @param active
 */
public GLElementFactorySwitcher(List<GLElementSupplier> children,ELazyiness lazy){
  this.children=children;
  this.instances=new GLElement[children.size()];
  this.lazy=lazy;
  if (lazy != ELazyiness.DESTROY) {
    for (int i=0; i < instances.length; ++i) {
      instances[i]=children.get(i).get();
      setup(instances[i]);
      instances[i].setLayoutData(children.get(i));
    }
  }
}","/** 
 * @param children
 * @param instances
 * @param active
 */
public GLElementFactorySwitcher(List<GLElementSupplier> children,ELazyiness lazy){
  this.children=children;
  this.instances=new GLElement[children.size()];
  this.lazy=lazy;
  if (lazy != ELazyiness.DESTROY) {
    for (int i=0; i < instances.length; ++i) {
      instances[i]=children.get(i).get();
      setup(instances[i]);
      instances[i].setLayoutData(children.get(i));
    }
  }
  setActive(instances.length == 0 ? -1 : 0);
}",0.9528795811518324
56853,"@Override public void layout(int deltaTimeMs){
  super.layout(deltaTimeMs);
  if (lazy == ELazyiness.NONE) {
    for (    GLElement instance : instances) {
      instance.layout(deltaTimeMs);
    }
  }
 else {
    GLElement selected=getSelected();
    if (selected != null)     selected.layout(deltaTimeMs);
  }
}","@Override public void layout(int deltaTimeMs){
  super.layout(deltaTimeMs);
  if (lazy == ELazyiness.NONE) {
    for (    GLElement instance : instances) {
      instance.layout(deltaTimeMs);
    }
  }
 else {
    GLElement selected=getActiveElement();
    if (selected != null)     selected.layout(deltaTimeMs);
  }
}",0.9667194928684628
56854,"@Override protected void renderImpl(GLGraphics g,float w,float h){
  super.renderImpl(g,w,h);
  GLElement selected=getSelected();
  if (selected != null)   selected.render(g);
}","@Override protected void renderImpl(GLGraphics g,float w,float h){
  super.renderImpl(g,w,h);
  GLElement selected=getActiveElement();
  if (selected != null)   selected.render(g);
}",0.9637883008356546
56855,"@Override protected final void layoutImpl(){
  super.layoutImpl();
  Vec2f size=getSize();
  if (lazy == ELazyiness.NONE) {
    for (    GLElement instance : instances) {
      GLElementAccessor.asLayoutElement(instance).setBounds(0,0,size.x(),size.y());
    }
  }
 else {
    GLElement selected=getSelected();
    if (selected != null)     GLElementAccessor.asLayoutElement(selected).setBounds(0,0,size.x(),size.y());
  }
}","@Override protected final void layoutImpl(){
  super.layoutImpl();
  Vec2f size=getSize();
  if (lazy == ELazyiness.NONE) {
    for (    GLElement instance : instances) {
      GLElementAccessor.asLayoutElement(instance).setBounds(0,0,size.x(),size.y());
    }
  }
 else {
    GLElement selected=getActiveElement();
    if (selected != null)     GLElementAccessor.asLayoutElement(selected).setBounds(0,0,size.x(),size.y());
  }
}",0.9753810082063306
56856,"@Override public void repaintPick(){
  super.repaintPick();
  GLElement s=getSelected();
  if (s != null)   GLElementAccessor.repaintPickDown(s);
}","@Override public void repaintPick(){
  super.repaintPick();
  GLElement s=getActiveElement();
  if (s != null)   GLElementAccessor.repaintPickDown(s);
}",0.9565217391304348
56857,"/** 
 * @param active setter, see  {@link active}
 */
public void setActive(int active){
  if (this.active == active)   return;
  int old=this.active;
  int new_=active;
  GLElement oldv=getSelected();
switch (lazy) {
case NONE:
    break;
case DESTROY:
  if (context != null && oldv != null)   GLElementAccessor.takeDown(oldv);
instances[old]=null;
if (new_ >= 0) {
instances[new_]=children.get(new_).get();
instances[new_].setLayoutData(children.get(new_));
if (context != null) setup(instances[new_]);
}
break;
case UNINITIALIZE:
if (context != null) {
if (oldv != null) GLElementAccessor.takeDown(oldv);
if (new_ >= 0) setup(instances[new_]);
}
break;
}
this.active=active;
fireActiveChanged(active);
relayout();
}","/** 
 * @param active setter, see  {@link active}
 */
public void setActive(int active){
  if (this.active == active)   return;
  int old=this.active;
  int new_=active;
  GLElement oldv=getActiveElement();
switch (lazy) {
case NONE:
    break;
case DESTROY:
  if (context != null && oldv != null)   GLElementAccessor.takeDown(oldv);
if (old >= 0) instances[old]=null;
if (new_ >= 0) {
instances[new_]=children.get(new_).get();
instances[new_].setLayoutData(children.get(new_));
setup(instances[new_]);
}
break;
case UNINITIALIZE:
if (context != null) {
if (oldv != null) GLElementAccessor.takeDown(oldv);
if (new_ >= 0) setup(instances[new_]);
}
break;
}
this.active=active;
fireActiveChanged(active);
relayout();
}",0.9609483960948396
56858,"@Override public void repaint(){
  super.repaint();
  GLElement s=getSelected();
  if (s != null) {
    GLElementAccessor.repaintDown(s);
  }
}","@Override public void repaint(){
  super.repaint();
  GLElement s=getActiveElement();
  if (s != null) {
    GLElementAccessor.repaintDown(s);
  }
}",0.9553264604810996
56859,"@Override public <T>T getLayoutDataAs(Class<T> clazz,T default_){
  GLElement s=getSelected();
  if (s != null) {
    T v=s.getLayoutDataAs(clazz,null);
    if (v != null)     return v;
  }
  return super.getLayoutDataAs(clazz,default_);
}","@Override public <T>T getLayoutDataAs(Class<T> clazz,T default_){
  GLElement s=getActiveElement();
  if (s != null) {
    T v=s.getLayoutDataAs(clazz,null);
    if (v != null)     return v;
  }
  return super.getLayoutDataAs(clazz,default_);
}",0.9565217391304348
56860,"@Override protected final GLElementDecorator createRoot(){
  return new GLElementDecorator();
}","@Override protected final GLElementDecorator createRoot(){
  GLElementDecorator g=new GLElementDecorator();
  g.setContent(createContent());
  return g;
}",0.7389558232931727
56861,"@Override public Color darker(){
  List<Color> set=getSet();
  if (index >= set.size())   return super.darker();
  return set.get(index + 1);
}","@Override public Color darker(){
  List<Color> set=getSet();
  if (index >= set.size() - 1)   return super.darker();
  return set.get(index + 1);
}",0.986206896551724
56862,"/** 
 * shortcut for setting if a named boolean argument is set
 * @param key
 * @return
 */
public boolean is(String key){
  Boolean r=get(key,Boolean.class,Boolean.FALSE);
  return r == null ? false : r.booleanValue();
}","public boolean is(String key,boolean default_){
  Boolean r=get(key,Boolean.class,default_);
  return r == null ? false : r.booleanValue();
}",0.6446280991735537
56863,"public float getFloat(String key){
  Float r=get(key,Float.class,Float.NaN);
  return r == null ? Float.NaN : r.floatValue();
}","public float getFloat(String key,float default_){
  Float r=get(key,Float.class,default_);
  return r == null ? default_ : r.floatValue();
}",0.846441947565543
56864,"public int getInt(String key){
  Integer r=get(key,Integer.class,Integer.valueOf(-1));
  return r == null ? -1 : r.intValue();
}","public int getInt(String key,int default_){
  Integer r=get(key,Integer.class,Integer.valueOf(default_));
  return r == null ? default_ : r.intValue();
}",0.8825622775800712
56865,"@Override protected void renderImpl(GLGraphics g,float w,float h){
  float padding=getPadding();
  ATableBasedDataDomain dataDomain=getDataDomain();
  g.save();
  g.move(padding,padding);
  Histogram hist=getTablePerspective().getContainerStatistics().getHistogram();
  renderHist(g,hist,w - padding * 2,h - padding * 2,dataDomain.getTable().getColorMapper());
  if (hist instanceof CategoricalHistogram)   showColorMapper=false;
  g.restore();
  if (showColorMapper)   renderColorMapper(g,w,h,dataDomain.getTable().getColorMapper());
}","@Override protected void renderImpl(GLGraphics g,float w,float h){
  if (renderBackground)   g.color(Color.WHITE).fillRect(0,0,w,h);
  float padding=getPadding();
  ATableBasedDataDomain dataDomain=getDataDomain();
  g.save();
  g.move(padding,padding);
  Histogram hist=getTablePerspective().getContainerStatistics().getHistogram();
  renderHist(g,hist,w - padding * 2,h - padding * 2,dataDomain.getTable().getColorMapper());
  if (hist instanceof CategoricalHistogram)   showColorMapper=false;
  g.restore();
  if (showColorMapper)   renderColorMapper(g,w,h,dataDomain.getTable().getColorMapper());
}",0.9420035149384886
56866,"@Override public GLElement create(GLElementFactoryContext context){
  TablePerspective data=context.getData();
  EDetailLevel detailLevel=context.get(EDetailLevel.class,EDetailLevel.LOW);
  HistogramElement elem=new HistogramElement(data,detailLevel);
  elem.setShowColorMapper(context.is(""String_Node_Str""));
  return elem;
}","@Override public GLElement create(GLElementFactoryContext context){
  TablePerspective data=context.getData();
  EDetailLevel detailLevel=context.get(EDetailLevel.class,EDetailLevel.LOW);
  HistogramElement elem=new HistogramElement(data,detailLevel);
  elem.setShowColorMapper(context.is(""String_Node_Str""));
  elem.setRenderBackground(context.is(""String_Node_Str"",true));
  return elem;
}",0.9022346368715084
56867,"/** 
 * @param children
 * @param instances
 * @param active
 */
public GLElementFactorySwitcher(List<GLElementSupplier> children,ELazyiness lazy){
  this.children=children;
  this.instances=new GLElement[children.size()];
  this.lazy=lazy;
  if (lazy != ELazyiness.DESTROY) {
    for (int i=0; i < instances.length; ++i) {
      instances[i]=children.get(i).get();
      instances[i].setLayoutData(children.get(i));
    }
  }
}","/** 
 * @param children
 * @param instances
 * @param active
 */
public GLElementFactorySwitcher(List<GLElementSupplier> children,ELazyiness lazy){
  this.children=children;
  this.instances=new GLElement[children.size()];
  this.lazy=lazy;
  if (lazy != ELazyiness.DESTROY) {
    for (int i=0; i < instances.length; ++i) {
      instances[i]=children.get(i).get();
      setup(instances[i]);
      instances[i].setLayoutData(children.get(i));
    }
  }
}",0.9694224235560588
56868,"@Override protected void onMouseOut(Pick pick){
  createSelection(mixin.getDimensionSelectionManager(),SelectionType.MOUSE_OVER,-1);
  createSelection(mixin.getRecordSelectionManager(),SelectionType.MOUSE_OVER,-1);
}","@Override protected void onMouseOut(Pick pick){
  createSelection(mixin.getDimensionSelectionManager(),SelectionType.MOUSE_OVER,-1);
  createSelection(mixin.getRecordSelectionManager(),SelectionType.MOUSE_OVER,-1);
  repaint();
}",0.9707865168539326
56869,"/** 
 * @return
 */
private boolean isVisible(){
  if (!visible)   return false;
  Display d=Display.getCurrent();
  final Composite p=canvas.asComposite();
  boolean v;
  try {
    v=DisplayUtils.syncExec(d,new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return !p.isDisposed() && p.isVisible();
      }
    }
);
  }
 catch (  Exception e) {
    v=true;
  }
  return v;
}","/** 
 * @return
 */
private boolean isVisible(){
  if (!visible)   return false;
  Display d=Display.getDefault();
  final Composite p=canvas.asComposite();
  boolean v;
  try {
    v=DisplayUtils.syncExec(d,new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return !p.isDisposed() && p.isVisible();
      }
    }
);
  }
 catch (  Exception e) {
    v=true;
  }
  return v;
}",0.9855072463768116
56870,"@Override public final void addTablePerspectives(List<TablePerspective> newTablePerspectives){
  this.tablePerspectives.addAll(newTablePerspectives);
  updateTablePerspectives(newTablePerspectives,NONE);
}","@Override public final void addTablePerspectives(List<TablePerspective> newTablePerspectives){
  newTablePerspectives.removeAll(this.tablePerspectives);
  if (newTablePerspectives.isEmpty())   return;
  this.tablePerspectives.addAll(newTablePerspectives);
  updateTablePerspectives(newTablePerspectives,NONE);
}",0.7945736434108527
56871,"@ListenTo private void onAddTablePerspective(AddTablePerspectivesEvent event){
  List<TablePerspective> validTablePerspectives=getDataSupportDefinition().filter(event.getTablePerspectives());
  if (validTablePerspectives.isEmpty()) {
    fireTablePerspectiveChanged();
  }
 else {
    addTablePerspectives(validTablePerspectives);
  }
}","@ListenTo private void onAddTablePerspective(AddTablePerspectivesEvent event){
  List<TablePerspective> validTablePerspectives=getDataSupportDefinition().filter(event.getTablePerspectives());
  validTablePerspectives.removeAll(tablePerspectives);
  if (validTablePerspectives.isEmpty()) {
    fireTablePerspectiveChanged();
  }
 else {
    addTablePerspectives(validTablePerspectives);
  }
}",0.9243466299862448
56872,"@Override public final void setTablePerspective(TablePerspective tablePerspective){
  this.tablePerspective=tablePerspective;
  fireTablePerspectiveChanged();
  GLElementDecorator root=getRootDecorator();
  if (root != null) {
    applyTablePerspective(root,tablePerspective);
  }
}","@Override public final void setTablePerspective(TablePerspective tablePerspective){
  if (Objects.equal(this.tablePerspective,tablePerspective))   return;
  this.tablePerspective=tablePerspective;
  fireTablePerspectiveChanged();
  GLElementDecorator root=getRootDecorator();
  if (root != null) {
    applyTablePerspective(root,tablePerspective);
  }
}",0.8881889763779528
56873,"@ListenTo(sendToMe=true) private void onRemoveTablePerspective(RemoveTablePerspectiveEvent event){
  if (tablePerspective == event.getTablePerspective())   setTablePerspective(null);
}","@ListenTo(sendToMe=true) private void onRemoveTablePerspective(RemoveTablePerspectiveEvent event){
  if (Objects.equal(tablePerspective,event.getTablePerspective()))   setTablePerspective(null);
}",0.9473684210526316
56874,"protected final void fillToolBar(){
  addToolBarContent(getViewSite().getActionBars().getToolBarManager());
}","protected final void fillToolBar(){
  IViewSite s=getViewSite();
  if (s == null)   return;
  addToolBarContent(getViewSite().getActionBars().getToolBarManager());
}",0.7956204379562044
56875,"/** 
 * Check whether the view is visible. If not, it should not be rendered. Note that events should be processed anyway.
 * @return true if it is visible
 */
protected boolean isVisible(){
  return isVisible && parentGLCanvas.isVisible();
}","/** 
 * Check whether the view is visible. If not, it should not be rendered. Note that events should be processed anyway.
 * @return true if it is visible
 */
protected boolean isVisible(){
  if (!isVisible)   return false;
  if (!parentGLCanvas.isVisible())   return false;
  return true;
}",0.8651685393258427
56876,"AWTGLCanvas(GLCanvas canvas,Composite composite){
  super(canvas);
  this.canvas=canvas;
  this.composite=composite;
}","AWTGLCanvas(GLCanvas canvas,Composite composite){
  super(canvas);
  this.canvas=canvas;
  this.composite=composite;
  init(composite);
}",0.9254901960784314
56877,"NEWTGLCanvas(GLWindow window,NewtCanvasSWT canvas){
  super(window);
  this.canvas=window;
  this.composite=canvas;
}","NEWTGLCanvas(GLWindow window,NewtCanvasSWT canvas){
  super(window);
  this.canvas=window;
  this.composite=canvas;
  init(canvas);
}",0.936
56878,"SWTGLCanvas(final GLCanvas canvas){
  super(canvas);
  this.canvas=canvas;
  Composite c=canvas;
  while (c != null) {
    c.addListener(SWT.Show,showHide);
    c.addListener(SWT.Hide,showHide);
    c=c.getParent();
  }
  this.canvas.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent e){
      Composite c=canvas;
      while (c != null) {
        c.removeListener(SWT.Show,showHide);
        c.removeListener(SWT.Hide,showHide);
        c=c.getParent();
      }
    }
  }
);
}","SWTGLCanvas(final GLCanvas canvas){
  super(canvas);
  this.canvas=canvas;
  init(canvas);
}",0.2875605815831987
56879,"@Override public void init(IViewSite site) throws PartInitException {
  super.init(site);
  this.mode=EDataDomainQueryMode.valueOfSafe(site.getSecondaryId());
  this.setPartName(this.mode.getLabel() + ""String_Node_Str"");
  site.getPage().addPartListener(stratomexListener);
}","@Override public void init(IViewSite site) throws PartInitException {
  super.init(site);
  this.mode=EDataDomainQueryMode.valueOfSafe(site.getSecondaryId());
  site.getPage().addPartListener(stratomexListener);
}",0.8729508196721312
56880,"@Override public void createDefaultSerializedView(){
  serializedView=new SerializedTourGuideView();
  determineDataConfiguration(serializedView,false);
}","@Override public void createDefaultSerializedView(){
  serializedView=new SerializedTourGuideView();
  serializedView.setLabelDefault(false);
  serializedView.setViewLabel(this.mode.getLabel() + ""String_Node_Str"");
  determineDataConfiguration(serializedView,false);
}",0.7061611374407583
56881,"@Override public void beginMovement(Object oldBackingStore,Object newBackingStore){
  if (inBeginEndPair) {
    flush();
    GL2 gl=GLContext.getCurrentGL().getGL2();
    gl.glPopClientAttrib();
    if (getUseVertexArrays() && is15Available(gl)) {
      try {
        gl.glBindBuffer(GL.GL_ARRAY_BUFFER,0);
      }
 catch (      Exception e) {
        isExtensionAvailable_GL_VERSION_1_5=false;
      }
    }
    if (isOrthoMode) {
      ((TextureRenderer)oldBackingStore).endOrthoRendering();
    }
 else {
      ((TextureRenderer)oldBackingStore).end3DRendering();
    }
  }
  TextureRenderer newRenderer=(TextureRenderer)newBackingStore;
  g=newRenderer.createGraphics();
}","@Override public void beginMovement(Object oldBackingStore,Object newBackingStore){
  if (inBeginEndPair) {
    flush();
    GL2 gl=GLContext.getCurrentGL().getGL2();
    if (getUseVertexArrays() && is15Available(gl)) {
      try {
        gl.glBindBuffer(GL.GL_ARRAY_BUFFER,0);
      }
 catch (      Exception e) {
        isExtensionAvailable_GL_VERSION_1_5=false;
      }
    }
    if (isOrthoMode) {
      ((TextureRenderer)oldBackingStore).endOrthoRendering();
    }
 else {
      ((TextureRenderer)oldBackingStore).end3DRendering();
    }
  }
  TextureRenderer newRenderer=(TextureRenderer)newBackingStore;
  g=newRenderer.createGraphics();
}",0.9788519637462236
56882,"@Override public void endMovement(Object oldBackingStore,Object newBackingStore){
  g.dispose();
  TextureRenderer newRenderer=(TextureRenderer)newBackingStore;
  newRenderer.markDirty(0,0,newRenderer.getWidth(),newRenderer.getHeight());
  if (inBeginEndPair) {
    if (isOrthoMode) {
      ((TextureRenderer)newBackingStore).beginOrthoRendering(beginRenderingWidth,beginRenderingHeight,beginRenderingDepthTestDisabled);
    }
 else {
      ((TextureRenderer)newBackingStore).begin3DRendering();
    }
    GL2 gl=GLContext.getCurrentGL().getGL2();
    gl.glPushClientAttrib((int)GL2.GL_ALL_CLIENT_ATTRIB_BITS);
    if (haveCachedColor) {
      if (cachedColor == null) {
        ((TextureRenderer)newBackingStore).setColor(cachedR,cachedG,cachedB,cachedA);
      }
 else {
        ((TextureRenderer)newBackingStore).setColor(cachedColor.getAWTColor());
      }
    }
  }
 else {
    needToResetColor=true;
  }
}","@Override public void endMovement(Object oldBackingStore,Object newBackingStore){
  g.dispose();
  TextureRenderer newRenderer=(TextureRenderer)newBackingStore;
  newRenderer.markDirty(0,0,newRenderer.getWidth(),newRenderer.getHeight());
  if (inBeginEndPair) {
    if (isOrthoMode) {
      ((TextureRenderer)newBackingStore).beginOrthoRendering(beginRenderingWidth,beginRenderingHeight,beginRenderingDepthTestDisabled);
    }
 else {
      ((TextureRenderer)newBackingStore).begin3DRendering();
    }
    GL2 gl=GLContext.getCurrentGL().getGL2();
    if (haveCachedColor) {
      if (cachedColor == null) {
        ((TextureRenderer)newBackingStore).setColor(cachedR,cachedG,cachedB,cachedA);
      }
 else {
        ((TextureRenderer)newBackingStore).setColor(cachedColor.getAWTColor());
      }
    }
  }
 else {
    needToResetColor=true;
  }
}",0.9641841955656624
56883,"/** 
 * Convert method. TODO: only DAVID_2_EXPRESSION_INDEX is supported ATM
 * @param < T > the type of the delta, an implementation of  {@link IDelta}
 * @param idMappingManager the id mapping manager that should be used for the conversion
 * @param targetType the target type of the id conversion
 * @param delta the src delta containing the src type
 * @return the new delta, which can be longer than the original
 */
@SuppressWarnings(""String_Node_Str"") public static <T extends IDelta>T convertDelta(IDMappingManager idMappingManager,IDType targetType,T delta){
  T newDelta=null;
  if (delta instanceof SelectionDelta) {
    newDelta=(T)new SelectionDelta(targetType);
  }
 else   if (delta instanceof VirtualArrayDelta) {
    VirtualArrayDelta vaDelta=(VirtualArrayDelta)delta;
    VirtualArrayDelta newVADelta=new VirtualArrayDelta();
    newVADelta.setIDType(targetType);
    newVADelta.setPerspectiveID(vaDelta.getPerspectiveID());
    newDelta=(T)newVADelta;
  }
 else   throw new IllegalStateException(""String_Node_Str"");
  for (  Object tempItem : delta) {
    IDeltaItem item=(IDeltaItem)tempItem;
    Set<Integer> tableIDs=idMappingManager.getIDAsSet(delta.getIDType(),targetType,item.getID());
    if (tableIDs == null) {
      continue;
    }
    for (    Integer id : tableIDs) {
      IDeltaItem clonedItem=item.clone();
      clonedItem.setID(id);
      newDelta.add(clonedItem);
    }
  }
  return newDelta;
}","/** 
 * Convert method. TODO: only DAVID_2_EXPRESSION_INDEX is supported ATM
 * @param < T > the type of the delta, an implementation of  {@link IDelta}
 * @param idMappingManager the id mapping manager that should be used for the conversion
 * @param targetType the target type of the id conversion
 * @param delta the src delta containing the src type
 * @return the new delta, which can be longer than the original
 */
@SuppressWarnings(""String_Node_Str"") public static <T extends IDelta>T convertDelta(IDMappingManager idMappingManager,IDType targetType,T delta){
  T newDelta=null;
  if (delta instanceof SelectionDelta) {
    newDelta=(T)new SelectionDelta(targetType);
  }
 else   if (delta instanceof VirtualArrayDelta) {
    VirtualArrayDelta vaDelta=(VirtualArrayDelta)delta;
    VirtualArrayDelta newVADelta=new VirtualArrayDelta();
    newVADelta.setIDType(targetType);
    newVADelta.setPerspectiveID(vaDelta.getPerspectiveID());
    newDelta=(T)newVADelta;
  }
 else   throw new IllegalStateException(""String_Node_Str"");
  IIDTypeMapper<Integer,Integer> idTypeMapper=idMappingManager.getIDTypeMapper(delta.getIDType(),targetType);
  if (idTypeMapper == null)   return newDelta;
  for (  Object tempItem : delta) {
    IDeltaItem item=(IDeltaItem)tempItem;
    Set<Integer> tableIDs=idTypeMapper.apply(item.getID());
    if (tableIDs == null) {
      continue;
    }
    for (    Integer id : tableIDs) {
      IDeltaItem clonedItem=item.clone();
      clonedItem.setID(id);
      newDelta.add(clonedItem);
    }
  }
  return newDelta;
}",0.9278765514927876
56884,"@Override public void dispose(){
  super.dispose();
  ((TableView)view).dispose();
  GeneralManager.get().getViewManager().unregisterRCPView(this,view);
  view=null;
}","@Override public void dispose(){
  ((TableView)view).dispose();
  GeneralManager.get().getViewManager().unregisterRCPView(this,view);
  super.dispose();
  view=null;
}",0.8862275449101796
56885,"private double enrichmentScore(Map<Integer,Float> correlation,Set<Integer> geneS){
  final int N=correlation.size();
  final int N_h=geneS.size();
  if (N_h == 0)   return Float.NaN;
  float N_R=0;
  for (  Integer g : geneS)   if (correlation.containsKey(g))   N_R+=Math.abs(Math.pow(correlation.get(g),p));
  final double norm_tag=1 / N_R;
  final double norm_no_tag=1. / (N - N_h);
  double p_hit=0;
  double p_miss=0;
  double es_max=Double.NEGATIVE_INFINITY;
  double es_min=Double.POSITIVE_INFINITY;
  for (  Integer r : correlation.keySet()) {
    if (geneS.contains(r))     p_hit+=Math.abs(Math.pow(correlation.get(r),p)) * norm_tag;
 else     p_miss+=norm_no_tag;
    double esi=p_hit - p_miss;
    if (esi > es_max)     es_max=esi;
    if (esi < es_min)     es_min=esi;
  }
  if (es_max > -es_min)   return es_max;
 else   return es_min;
}","private double enrichmentScore(Map<Integer,Float> correlation,Set<Integer> geneS){
  final int N=correlation.size();
  final int N_h=geneS.size();
  if (N_h == 0)   return Float.NaN;
  float N_R=0;
  int intersection=0;
  for (  Integer g : geneS)   if (correlation.containsKey(g)) {
    N_R+=Math.abs(Math.pow(correlation.get(g),p));
    intersection++;
  }
  if (intersection == 0)   return Float.NaN;
  final double norm_tag=1 / N_R;
  final double norm_no_tag=1. / (N - N_h);
  double p_hit=0;
  double p_miss=0;
  double es_max=Double.NEGATIVE_INFINITY;
  double es_min=Double.POSITIVE_INFINITY;
  for (  Integer r : correlation.keySet()) {
    if (geneS.contains(r))     p_hit+=Math.abs(Math.pow(correlation.get(r),p)) * norm_tag;
 else     p_miss+=norm_no_tag;
    double esi=p_hit - p_miss;
    if (esi > es_max)     es_max=esi;
    if (esi < es_min)     es_min=esi;
  }
  if (es_max > -es_min)   return es_max;
 else   return es_min;
}",0.947016174010039
56886,"@Override public void init(IProgressMonitor monitor){
  if (!foldChanges.isEmpty())   return;
  final Set<Integer> inA=new HashSet<>(perspective.getVirtualArray().getIDsOfGroup(group.getGroupIndex()));
  ATableBasedDataDomain dataDomain=(ATableBasedDataDomain)perspective.getDataDomain();
  Table table=dataDomain.getTable();
  List<Integer> rows=perspective.getVirtualArray().getIDs();
  List<Integer> cols=table.getDefaultDimensionPerspective().getVirtualArray().getIDs();
  Stopwatch w=new Stopwatch().start();
  float sum=0;
  float squaredSum=0;
  for (  Integer col : cols) {
    float asum=0;
    int acount=0;
    float bsum=0;
    int bcount=0;
    for (    Integer row : rows) {
      Float v=table.getNormalizedValue(col,row);
      if (v == null || v.isNaN() || v.isInfinite())       continue;
      if (inA.contains(row)) {
        asum+=v;
        acount++;
      }
 else {
        bsum+=v;
        bcount++;
      }
    }
    if (monitor.isCanceled()) {
      foldChanges.clear();
      return;
    }
    float foldChange=Statistics.foldChange((asum / acount),(bsum / bcount));
    Set<Integer> davids=dim2primary.apply(col);
    sum+=foldChange * davids.size();
    squaredSum+=(foldChange * foldChange) * davids.size();
    for (    Integer david : davids)     foldChanges.put(david,foldChange);
  }
  foldChangesMean=sum / foldChanges.size();
  foldChangesSD=(float)Math.sqrt(squaredSum / foldChanges.size() - foldChangesMean * foldChangesMean);
  System.out.println(w);
}","@Override public void init(IProgressMonitor monitor){
  if (!foldChanges.isEmpty())   return;
  final Set<Integer> inA=new HashSet<>(perspective.getVirtualArray().getIDsOfGroup(group.getGroupIndex()));
  ATableBasedDataDomain dataDomain=(ATableBasedDataDomain)perspective.getDataDomain();
  Table table=dataDomain.getTable();
  List<Integer> rows=perspective.getVirtualArray().getIDs();
  List<Integer> cols=table.getDefaultDimensionPerspective().getVirtualArray().getIDs();
  Stopwatch w=new Stopwatch().start();
  float sum=0;
  float squaredSum=0;
  for (  Integer col : cols) {
    float asum=0;
    int acount=0;
    float bsum=0;
    int bcount=0;
    for (    Integer row : rows) {
      Float v=table.getNormalizedValue(col,row);
      if (v == null || v.isNaN() || v.isInfinite())       continue;
      if (inA.contains(row)) {
        asum+=v;
        acount++;
      }
 else {
        bsum+=v;
        bcount++;
      }
    }
    if (monitor.isCanceled()) {
      foldChanges.clear();
      return;
    }
    float foldChange=Statistics.foldChange((asum / acount),(bsum / bcount));
    Set<Integer> davids=dim2primary.apply(col);
    if (davids == null)     continue;
    sum+=foldChange * davids.size();
    squaredSum+=(foldChange * foldChange) * davids.size();
    for (    Integer david : davids)     foldChanges.put(david,foldChange);
  }
  foldChangesMean=sum / foldChanges.size();
  foldChangesSD=(float)Math.sqrt(squaredSum / foldChanges.size() - foldChangesMean * foldChangesMean);
  System.out.println(w);
}",0.9874088800530152
56887,"/** 
 * Changing the workspace location in order to be able to store and restore the workbench state (also in combination with serialized projects).
 */
private static void changeWorkspaceLocation(){
  final Location instanceLoc=Platform.getInstanceLocation();
  String workspacePath=""String_Node_Str"" + GeneralManager.CALEYDO_HOME_PATH;
  try {
    URL workspaceURL=new URL(workspacePath);
    instanceLoc.set(workspaceURL,false);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + workspacePath);
  }
}","/** 
 * Changing the workspace location in order to be able to store and restore the workbench state (also in combination with serialized projects).
 */
private static void changeWorkspaceLocation(){
  final Location instanceLoc=Platform.getInstanceLocation();
  File workspacePath=new File(GeneralManager.CALEYDO_HOME_PATH);
  try {
    URL workspaceURL=workspacePath.toURI().toURL();
    instanceLoc.set(workspaceURL,false);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + workspacePath);
  }
}",0.9186602870813396
56888,"@Override protected void renderContent(GL2 gl){
  TablePerspective mappedPerspective=pathRenderer.getMappedPerspective();
  List<Integer> ids=node.getMappedDavidIDs();
  if (ids == null || ids.isEmpty())   return;
  float onePxlWidth=view.getPixelGLConverter().getGLWidthForPixelWidth(1);
  float onePxlHeight=view.getPixelGLConverter().getGLHeightForPixelHeight(1);
  float z=1f;
  if (mappedPerspective != null) {
    Average average=mappedPerspective.getContainerStatistics().getAverage(idType,ids.get(0));
    if (average != null) {
      setColor(mappedPerspective.getDataDomain().getTable().getColorMapper().getColor((float)average.getArithmeticMean()));
      float yStart=-1 * onePxlHeight;
      float yEnd=-5 * onePxlHeight;
      gl.glColor3f(1,1,1);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x,yEnd,z);
      gl.glVertex3f(x,yStart,z);
      gl.glEnd();
      gl.glColor3fv(mappedPerspective.getDataDomain().getColor().getRGB(),0);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x * (float)average.getStandardDeviation() * 2,yEnd,z);
      gl.glVertex3f(x * (float)average.getStandardDeviation() * 2,yStart,z);
      gl.glEnd();
      gl.glColor3f(0,0,0);
      gl.glBegin(GL.GL_LINE_LOOP);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x,yEnd,z);
      gl.glVertex3f(x,yStart,z);
      gl.glEnd();
      gl.glColor3fv(mappedPerspective.getDataDomain().getColor().getRGB(),0);
    }
 else {
      setColor(new float[]{1,1,1,1});
    }
  }
 else {
    setColor(new float[]{1,1,1,1});
  }
  Pair<TablePerspective,Average> highestAverage=null;
  Average average;
  for (  TablePerspective tablePerspective : pathRenderer.getTablePerspectives()) {
    average=tablePerspective.getContainerStatistics().getAverage(idType,ids.get(0));
    if (average == null)     continue;
    if (average.getStandardDeviation() > 0.1) {
      if (highestAverage == null || average.getStandardDeviation() > highestAverage.getSecond().getStandardDeviation()) {
        highestAverage=new Pair<>(tablePerspective,average);
      }
    }
  }
  super.renderContent(gl);
}","@Override protected void renderContent(GL2 gl){
  TablePerspective mappedPerspective=pathRenderer.getMappedPerspective();
  List<Integer> ids=node.getMappedDavidIDs();
  if (ids == null || ids.isEmpty())   return;
  float onePxlWidth=view.getPixelGLConverter().getGLWidthForPixelWidth(1);
  float onePxlHeight=view.getPixelGLConverter().getGLHeightForPixelHeight(1);
  float z=1f;
  if (mappedPerspective != null) {
    Average average=mappedPerspective.getContainerStatistics().getAverage(idType,ids.get(0));
    if (average != null) {
      setColor(mappedPerspective.getDataDomain().getTable().getColorMapper().getColor((float)average.getArithmeticMean()));
      float yStart=-1 * onePxlHeight;
      float yEnd=-5 * onePxlHeight;
      gl.glColor3f(1,1,1);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x,yEnd,z);
      gl.glVertex3f(x,yStart,z);
      gl.glEnd();
      gl.glColor3fv(mappedPerspective.getDataDomain().getColor().getRGB(),0);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x * (float)average.getStandardDeviation() * 2,yEnd,z);
      gl.glVertex3f(x * (float)average.getStandardDeviation() * 2,yStart,z);
      gl.glEnd();
      gl.glColor3f(0,0,0);
      gl.glBegin(GL.GL_LINE_LOOP);
      gl.glVertex3f(0,yStart,z);
      gl.glVertex3f(0,yEnd,z);
      gl.glVertex3f(x,yEnd,z);
      gl.glVertex3f(x,yStart,z);
      gl.glEnd();
      gl.glColor3fv(mappedPerspective.getDataDomain().getColor().getRGB(),0);
    }
 else {
      setColor(new float[]{1,1,1,1});
    }
  }
 else {
    setColor(new float[]{1,1,1,1});
  }
  Pair<TablePerspective,Average> highestAverage=null;
  Average average;
  for (  TablePerspective tablePerspective : pathRenderer.getTablePerspectives()) {
    average=tablePerspective.getContainerStatistics().getAverage(idType,ids.get(0));
    if (average == null)     continue;
    if (average.getStandardDeviation() > 0.1) {
      if (highestAverage == null || average.getStandardDeviation() > highestAverage.getSecond().getStandardDeviation()) {
        highestAverage=new Pair<>(tablePerspective,average);
      }
    }
  }
  if (highestAverage != null) {
    gl.glColor3fv(highestAverage.getFirst().getDataDomain().getColor().getRGB(),0);
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(x + 4 * onePxlWidth,3 * onePxlHeight,z);
    gl.glVertex3f(x + 8 * onePxlWidth,3 * onePxlHeight,z);
    gl.glVertex3f(x + 10 * onePxlWidth,y + 2 * onePxlHeight,z);
    gl.glVertex3f(x + 2 * onePxlWidth,y + 2 * onePxlHeight,z);
    gl.glEnd();
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(x + 3 * onePxlWidth,1 * onePxlHeight,z);
    gl.glVertex3f(x + 9 * onePxlWidth,1 * onePxlHeight,z);
    gl.glVertex3f(x + 9 * onePxlWidth,-3 * onePxlHeight,z);
    gl.glVertex3f(x + 3 * onePxlWidth,-3 * onePxlHeight,z);
    gl.glEnd();
  }
  super.renderContent(gl);
}",0.8566467296932279
56889,"private void renderPathway(final GL2 gl,final PathwayGraph pathway){
  if (!initShader) {
    initShader=true;
    try {
      initShaders(gl);
    }
 catch (    IOException|GLException e) {
      e.printStackTrace();
    }
  }
  gl.glPushMatrix();
  gl.glTranslatef(vecTranslation.x(),vecTranslation.y(),vecTranslation.z());
  gl.glScalef(vecScaling.x(),vecScaling.y(),vecScaling.z());
  float textureOffset=0.0f;
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
  }
  float pathwayHeight=pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight());
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glClearStencil(0);
  gl.glClear(GL.GL_STENCIL_BUFFER_BIT);
  textureOffset+=PathwayRenderStyle.Z_OFFSET;
  gl.glTranslatef(0,pathwayHeight,textureOffset);
  augmentationRenderer.renderPathway(gl,pathway,false);
  gl.glTranslatef(0,-pathwayHeight,-textureOffset);
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    textureOffset+=PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDisable(GL.GL_DEPTH_TEST);
    gl.glStencilFunc(GL.GL_GREATER,2,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glPushName(generalManager.getViewManager().getPickingManager().getPickingID(uniqueID,EPickingType.PATHWAY_TEXTURE_SELECTION.name(),0));
    if (shaderProgramTextOverlay > 0) {
      gl.glUseProgram(shaderProgramTextOverlay);
      gl.glUniform1i(gl.glGetUniformLocation(shaderProgramTextOverlay,""String_Node_Str""),0);
      gl.glUniform1i(gl.glGetUniformLocation(shaderProgramTextOverlay,""String_Node_Str""),this.pathway.getType().ordinal());
    }
    pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
    if (shaderProgramTextOverlay > 0)     gl.glUseProgram(0);
    gl.glPopName();
    gl.glStencilFunc(GL.GL_GREATER,1,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    textureOffset-=2f * PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    overlayContextBubbleSets(gl);
    overlayBubbleSets(gl);
    gl.glEnable(GL.GL_DEPTH_TEST);
    gl.glDisable(GL.GL_STENCIL_TEST);
  }
  gl.glScalef(1 / vecScaling.x(),1 / vecScaling.y(),1 / vecScaling.z());
  gl.glTranslatef(-vecTranslation.x(),-vecTranslation.y(),-vecTranslation.z());
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glPopMatrix();
}","private void renderPathway(final GL2 gl,final PathwayGraph pathway){
  if (!initShader) {
    initShader=true;
    try {
      initShaders(gl);
    }
 catch (    IOException|GLException e) {
      e.printStackTrace();
    }
  }
  gl.glEnable(GL.GL_BLEND);
  gl.glBlendFunc(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA);
  gl.glPushMatrix();
  gl.glTranslatef(vecTranslation.x(),vecTranslation.y(),vecTranslation.z());
  gl.glScalef(vecScaling.x(),vecScaling.y(),vecScaling.z());
  float textureOffset=0.0f;
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
  }
  float pathwayHeight=pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight());
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glClearStencil(0);
  gl.glClear(GL.GL_STENCIL_BUFFER_BIT);
  textureOffset+=PathwayRenderStyle.Z_OFFSET;
  gl.glTranslatef(0,pathwayHeight,textureOffset);
  augmentationRenderer.renderPathway(gl,pathway,false);
  gl.glTranslatef(0,-pathwayHeight,-textureOffset);
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    textureOffset+=PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDisable(GL.GL_DEPTH_TEST);
    gl.glStencilFunc(GL.GL_GREATER,2,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glPushName(generalManager.getViewManager().getPickingManager().getPickingID(uniqueID,EPickingType.PATHWAY_TEXTURE_SELECTION.name(),0));
    if (shaderProgramTextOverlay > 0) {
      gl.glUseProgram(shaderProgramTextOverlay);
      gl.glUniform1i(gl.glGetUniformLocation(shaderProgramTextOverlay,""String_Node_Str""),0);
      gl.glUniform1i(gl.glGetUniformLocation(shaderProgramTextOverlay,""String_Node_Str""),this.pathway.getType().ordinal());
    }
    pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
    if (shaderProgramTextOverlay > 0)     gl.glUseProgram(0);
    gl.glPopName();
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDisable(GL.GL_DEPTH_TEST);
    gl.glStencilFunc(GL.GL_GREATER,1,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    textureOffset-=2f * PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    overlayContextBubbleSets(gl);
    overlayBubbleSets(gl);
    gl.glEnable(GL.GL_DEPTH_TEST);
    gl.glDisable(GL.GL_STENCIL_TEST);
  }
  gl.glScalef(1 / vecScaling.x(),1 / vecScaling.y(),1 / vecScaling.z());
  gl.glTranslatef(-vecTranslation.x(),-vecTranslation.y(),-vecTranslation.z());
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glPopMatrix();
}",0.9505703422053232
56890,"@ListenTo public void onMapTablePerspective(PathwayMappingEvent event){
  if (event.getReceiver() != this)   return;
  augmentationRenderer.setMappingPerspective(event.getTablePerspective());
  setDisplayListDirty();
}","@ListenTo public void onMapTablePerspective(PathwayMappingEvent event){
  if (event.getReceiver() != this && event.getEventSpace() != pathwayPathEventSpace)   return;
  augmentationRenderer.setMappingPerspective(event.getTablePerspective());
  setDisplayListDirty();
}",0.897119341563786
56891,"private void renderGeneNode(GL2 gl,PathwayVertexRep vertexRep){
  float[] nodeColor;
  float width=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
  float height=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
  gl.glLineWidth(1);
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glColorMask(false,false,false,false);
  gl.glDisable(GL.GL_DEPTH_TEST);
  gl.glDisable(GL.GL_BLEND);
  gl.glStencilFunc(GL.GL_GREATER,1,0xff);
  gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
  renderQuad(gl,width,height);
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glColorMask(true,true,true,true);
  gl.glEnable(GL.GL_DEPTH_TEST);
  gl.glEnable(GL.GL_BLEND);
  if (mappingPerspective != null) {
    Average average=getExpressionAverage(mappingPerspective,vertexRep);
    if (average != null) {
      nodeColor=mappingPerspective.getDataDomain().getTable().getColorMapper().getColor((float)average.getArithmeticMean());
    }
 else {
      nodeColor=null;
    }
    if (average != null && nodeColor != null) {
      gl.glColor4f(nodeColor[0],nodeColor[1],nodeColor[2],0.8f);
      if (glPathwayView.getDetailLevel() == EDetailLevel.HIGH) {
        gl.glEnable(GL.GL_STENCIL_TEST);
        gl.glDisable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_BLEND);
        gl.glStencilFunc(GL.GL_GREATER,2,0xff);
        gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
        renderQuad(gl,width,height);
        gl.glEnable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_STENCIL_TEST);
        Float stdDev=pixelGLConverter.getGLWidthForPixelWidth(PathwayRenderStyle.ENZYME_NODE_PIXEL_WIDTH) * (float)average.getStandardDeviation() * 2.0f;
        if (!stdDev.isNaN()) {
          renderStdDevBar(gl,width,height,stdDev);
        }
        gl.glPushMatrix();
        gl.glTranslatef(0,-(2f * thirdOfstdDevBarHeight - onePxlHeight),0);
        if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
          nodeColor=SelectionType.SELECTION.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilFunc(GL.GL_GREATER,2,0xff);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
 else         if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
          nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilFunc(GL.GL_GREATER,2,0xff);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
        gl.glPopMatrix();
      }
 else {
        renderQuad(gl,width * 3,height * 3);
        gl.glEnable(GL.GL_STENCIL_TEST);
        gl.glColorMask(false,false,false,false);
        gl.glDisable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_BLEND);
        gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
        gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
        renderQuad(gl,width * 3,height * 3);
        gl.glDisable(GL.GL_STENCIL_TEST);
        gl.glColorMask(true,true,true,true);
        gl.glEnable(GL.GL_DEPTH_TEST);
        gl.glEnable(GL.GL_BLEND);
        if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
          nodeColor=SelectionType.SELECTION.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderQuad(gl,width * 3,height * 3);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
          gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
          renderQuad(gl,width * 3,height * 3);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
 else         if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
          nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderQuad(gl,width * 3,height * 3);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
          gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
          renderQuad(gl,width * 3,height * 3);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
      }
    }
 else {
      gl.glColor4f(0,0,0,0);
      renderQuad(gl,width,height);
      nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR.getRGBA();
      gl.glColor4f(nodeColor[0],nodeColor[1],nodeColor[2],0.7f);
      float boxWidth=pixelGLConverter.getGLWidthForPixelWidth(PathwayRenderStyle.COMPOUND_NODE_PIXEL_WIDTH);
      float boxHeight=pixelGLConverter.getGLHeightForPixelHeight(PathwayRenderStyle.COMPOUND_NODE_PIXEL_HEIGHT);
      float y=height;
      gl.glDisable(GL.GL_DEPTH_TEST);
      gl.glBegin(GL2.GL_QUADS);
      gl.glNormal3f(0.0f,0.0f,1.0f);
      gl.glVertex3f(0,boxHeight,PathwayRenderStyle.Z_OFFSET);
      gl.glVertex3f(boxWidth,boxHeight,PathwayRenderStyle.Z_OFFSET);
      gl.glVertex3f(boxWidth,0,PathwayRenderStyle.Z_OFFSET);
      gl.glVertex3f(0,0,PathwayRenderStyle.Z_OFFSET);
      gl.glEnd();
      gl.glEnable(GL.GL_DEPTH_TEST);
      if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
        nodeColor=SelectionType.SELECTION.getColor().getRGBA();
        gl.glColor4fv(nodeColor,0);
        renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
        maskFramedEnzymeNode(gl,width,height);
      }
 else       if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
        nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
        gl.glColor4fv(nodeColor,0);
        renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
        maskFramedEnzymeNode(gl,width,height);
      }
    }
  }
 else {
    if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
      nodeColor=SelectionType.SELECTION.getColor().getRGBA();
      maskFramedEnzymeNode(gl,width,height);
    }
 else     if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
      nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
      maskFramedEnzymeNode(gl,width,height);
    }
 else     if (vertexSelectionManager.checkStatus(SelectionType.NORMAL,vertexRep.getID())) {
      nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR.getRGBA();
    }
 else {
      nodeColor=new float[]{0,0,0,0};
    }
    gl.glColor4fv(nodeColor,0);
    renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
    gl.glCallList(framedEnzymeNodeDisplayListId);
    if (!vertexSelectionManager.checkStatus(SelectionType.DESELECTED,vertexRep.getID())) {
      gl.glColor4f(0,0,0,0);
      renderQuad(gl,width,height);
    }
  }
}","private void renderGeneNode(GL2 gl,PathwayVertexRep vertexRep){
  float[] nodeColor;
  float width=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
  float height=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
  gl.glLineWidth(1);
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glColorMask(false,false,false,false);
  gl.glDisable(GL.GL_DEPTH_TEST);
  gl.glDisable(GL.GL_BLEND);
  gl.glStencilFunc(GL.GL_GREATER,1,0xff);
  gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
  renderQuad(gl,width,height);
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glColorMask(true,true,true,true);
  gl.glEnable(GL.GL_DEPTH_TEST);
  gl.glEnable(GL.GL_BLEND);
  if (mappingPerspective != null) {
    Average average=getExpressionAverage(mappingPerspective,vertexRep);
    if (average != null) {
      nodeColor=mappingPerspective.getDataDomain().getTable().getColorMapper().getColor((float)average.getArithmeticMean());
    }
 else {
      nodeColor=null;
    }
    if (average != null && nodeColor != null) {
      gl.glColor4f(nodeColor[0],nodeColor[1],nodeColor[2],0.8f);
      if (glPathwayView.getDetailLevel() == EDetailLevel.HIGH) {
        gl.glEnable(GL.GL_STENCIL_TEST);
        gl.glDisable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_BLEND);
        gl.glStencilFunc(GL.GL_GREATER,2,0xff);
        gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
        renderQuad(gl,width,height);
        gl.glEnable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_STENCIL_TEST);
        Float stdDev=pixelGLConverter.getGLWidthForPixelWidth(PathwayRenderStyle.ENZYME_NODE_PIXEL_WIDTH) * (float)average.getStandardDeviation() * 2.0f;
        if (!stdDev.isNaN()) {
          renderStdDevBar(gl,width,height,stdDev);
        }
        gl.glPushMatrix();
        gl.glTranslatef(0,-(2f * thirdOfstdDevBarHeight - onePxlHeight),0);
        if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
          nodeColor=SelectionType.SELECTION.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilFunc(GL.GL_GREATER,2,0xff);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
 else         if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
          nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilFunc(GL.GL_GREATER,2,0xff);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
          renderFrame(gl,width + onePxlWidth,height + (2f * thirdOfstdDevBarHeight) - onePxlHeight);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
        gl.glPopMatrix();
      }
 else {
        renderQuad(gl,width * 3,height * 3);
        gl.glEnable(GL.GL_STENCIL_TEST);
        gl.glColorMask(false,false,false,false);
        gl.glDisable(GL.GL_DEPTH_TEST);
        gl.glDisable(GL.GL_BLEND);
        gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
        gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
        renderQuad(gl,width * 3,height * 3);
        gl.glDisable(GL.GL_STENCIL_TEST);
        gl.glColorMask(true,true,true,true);
        gl.glEnable(GL.GL_DEPTH_TEST);
        gl.glEnable(GL.GL_BLEND);
        if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
          nodeColor=SelectionType.SELECTION.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderQuad(gl,width * 3,height * 3);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
          gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
          renderQuad(gl,width * 3,height * 3);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
 else         if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
          nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
          gl.glColor4fv(nodeColor,0);
          renderQuad(gl,width * 3,height * 3);
          gl.glEnable(GL.GL_STENCIL_TEST);
          gl.glColorMask(false,false,false,false);
          gl.glDisable(GL.GL_DEPTH_TEST);
          gl.glDisable(GL.GL_BLEND);
          gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
          gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
          renderQuad(gl,width * 3,height * 3);
          gl.glDisable(GL.GL_STENCIL_TEST);
          gl.glColorMask(true,true,true,true);
          gl.glEnable(GL.GL_DEPTH_TEST);
          gl.glEnable(GL.GL_BLEND);
        }
      }
    }
 else {
      gl.glColor4f(1,1,1,1);
      renderQuad(gl,width,height);
      nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR.getRGBA();
      gl.glColor4f(nodeColor[0],nodeColor[1],nodeColor[2],0.7f);
      float boxWidth=pixelGLConverter.getGLWidthForPixelWidth(PathwayRenderStyle.COMPOUND_NODE_PIXEL_WIDTH);
      float boxHeight=pixelGLConverter.getGLHeightForPixelHeight(PathwayRenderStyle.COMPOUND_NODE_PIXEL_HEIGHT);
      float y=height;
      gl.glDisable(GL.GL_DEPTH_TEST);
      gl.glBegin(GL2.GL_QUADS);
      gl.glNormal3f(0.0f,0.0f,1.0f);
      gl.glVertex3f(0,boxHeight,PathwayRenderStyle.Z_OFFSET);
      gl.glVertex3f(boxWidth,boxHeight,PathwayRenderStyle.Z_OFFSET);
      gl.glVertex3f(boxWidth,0,PathwayRenderStyle.Z_OFFSET);
      gl.glVertex3f(0,0,PathwayRenderStyle.Z_OFFSET);
      gl.glEnd();
      gl.glEnable(GL.GL_DEPTH_TEST);
      if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
        nodeColor=SelectionType.SELECTION.getColor().getRGBA();
        gl.glColor4fv(nodeColor,0);
        renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
        maskFramedEnzymeNode(gl,width,height);
      }
 else       if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
        nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
        gl.glColor4fv(nodeColor,0);
        renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
        maskFramedEnzymeNode(gl,width,height);
      }
    }
  }
 else {
    if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
      nodeColor=SelectionType.SELECTION.getColor().getRGBA();
      maskFramedEnzymeNode(gl,width,height);
    }
 else     if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
      nodeColor=SelectionType.MOUSE_OVER.getColor().getRGBA();
      maskFramedEnzymeNode(gl,width,height);
    }
 else     if (vertexSelectionManager.checkStatus(SelectionType.NORMAL,vertexRep.getID())) {
      nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR.getRGBA();
    }
 else {
      nodeColor=new float[]{0,0,0,0};
    }
    gl.glColor4fv(nodeColor,0);
    renderFrame(gl,width + onePxlWidth,height + thirdOfstdDevBarHeight);
    gl.glCallList(framedEnzymeNodeDisplayListId);
    if (!vertexSelectionManager.checkStatus(SelectionType.DESELECTED,vertexRep.getID())) {
      gl.glColor4f(0,0,0,0);
      renderQuad(gl,width,height);
    }
  }
  Pair<TablePerspective,Average> highestAverage=null;
  Average average;
  for (  TablePerspective tablePerspective : glPathwayView.getTablePerspectives()) {
    average=getExpressionAverage(tablePerspective,vertexRep);
    if (average == null)     continue;
    if (average.getStandardDeviation() > 0.1) {
      if (highestAverage == null || average.getStandardDeviation() > highestAverage.getSecond().getStandardDeviation()) {
        highestAverage=new Pair<>(tablePerspective,average);
      }
    }
  }
  if (highestAverage != null) {
    gl.glColor3fv(highestAverage.getFirst().getDataDomain().getColor().getRGB(),0);
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(width,height,PathwayRenderStyle.Z_OFFSET);
    gl.glVertex3f(width - 5 * onePxlWidth,height,PathwayRenderStyle.Z_OFFSET);
    gl.glVertex3f(width - 4 * onePxlWidth,height - 10,PathwayRenderStyle.Z_OFFSET);
    gl.glVertex3f(width - 1 * onePxlWidth,height - 10,PathwayRenderStyle.Z_OFFSET);
    gl.glEnd();
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(width,0 + 5,PathwayRenderStyle.Z_OFFSET);
    gl.glVertex3f(width - 5 * onePxlWidth,0 + 5,PathwayRenderStyle.Z_OFFSET);
    gl.glVertex3f(width - 5 * onePxlWidth,0,PathwayRenderStyle.Z_OFFSET);
    gl.glVertex3f(width,0,PathwayRenderStyle.Z_OFFSET);
    gl.glEnd();
  }
}",0.925340909090909
56892,"private void renderVertex(final GL2 gl,PathwayVertexRep vertexRep){
  Color tmpNodeColor=null;
  gl.glPushName(glPathwayView.getPickingManager().getPickingID(glPathwayView.getID(),EPickingType.PATHWAY_ELEMENT_SELECTION.name(),vertexRep.getID()));
  float canvasXPos=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getCenterX());
  float canvasYPos=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getCenterY());
  float vertexHeight=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
  canvasYPos+=vertexHeight;
  gl.glTranslatef(canvasXPos,-canvasYPos,0);
  EPathwayVertexType vertexType=vertexRep.getType();
switch (vertexType) {
case map:
    if (vertexRep.getName().contains(""String_Node_Str"")) {
      gl.glTranslatef(-canvasXPos,canvasYPos,0);
      gl.glPopName();
      return;
    }
  float nodeWidth=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
float nodeHeight=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_REPLACE,GL.GL_REPLACE,GL.GL_REPLACE);
renderQuad(gl,nodeWidth,nodeHeight);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
renderFrame(gl,nodeWidth,nodeHeight);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
tmpNodeColor=Color.TRANSPARENT;
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderQuad(gl,nodeWidth,nodeHeight);
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
tmpNodeColor=SelectionType.SELECTION.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
tmpNodeColor=SelectionType.MOUSE_OVER.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
break;
case compound:
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,1,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(compoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
EventBasedSelectionManager metabolicSelectionManager=glPathwayView.getMetaboliteSelectionManager();
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID()) || metabolicSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getName().hashCode())) {
tmpNodeColor=SelectionType.SELECTION.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID()) || metabolicSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getName().hashCode())) {
tmpNodeColor=SelectionType.MOUSE_OVER.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
}
tmpNodeColor=PathwayRenderStyle.COMPOUND_NODE_COLOR;
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(compoundNodeDisplayListId);
break;
case group:
break;
case gene:
case enzyme:
case other:
if (isVisible) renderGeneNode(gl,vertexRep);
 else {
float width=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
float height=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_GREATER,1,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
gl.glCallList(enzymeNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
Color nodeColor;
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
nodeColor=SelectionType.SELECTION.getColor();
maskFramedEnzymeNode(gl,width,height);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
nodeColor=SelectionType.MOUSE_OVER.getColor();
maskFramedEnzymeNode(gl,width,height);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.NORMAL,vertexRep.getID())) {
nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR;
}
 else {
nodeColor=Color.TRANSPARENT;
}
gl.glColor4fv(nodeColor.getRGBA(),0);
gl.glCallList(framedEnzymeNodeDisplayListId);
if (!vertexSelectionManager.checkStatus(SelectionType.DESELECTED,vertexRep.getID())) {
gl.glColor4f(0,0,0,0);
gl.glCallList(enzymeNodeDisplayListId);
}
}
break;
default :
break;
}
gl.glTranslatef(-canvasXPos,canvasYPos,0);
gl.glPopName();
}","private void renderVertex(final GL2 gl,PathwayVertexRep vertexRep){
  Color tmpNodeColor=null;
  gl.glPushName(glPathwayView.getPickingManager().getPickingID(glPathwayView.getID(),EPickingType.PATHWAY_ELEMENT_SELECTION.name(),vertexRep.getID()));
  float canvasXPos=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getCenterX());
  float canvasYPos=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getCenterY());
  float vertexHeight=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
  canvasYPos+=vertexHeight;
  gl.glTranslatef(canvasXPos,-canvasYPos,0);
  EPathwayVertexType vertexType=vertexRep.getType();
switch (vertexType) {
case map:
    if (vertexRep.getName().contains(""String_Node_Str"")) {
      gl.glTranslatef(-canvasXPos,canvasYPos,0);
      gl.glPopName();
      return;
    }
  float nodeWidth=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
float nodeHeight=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
tmpNodeColor=Color.TRANSPARENT;
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderQuad(gl,nodeWidth,nodeHeight);
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_REPLACE,GL.GL_REPLACE,GL.GL_REPLACE);
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
tmpNodeColor=SelectionType.SELECTION.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
tmpNodeColor=SelectionType.MOUSE_OVER.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
tmpNodeColor=SelectionType.SELECTION.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
tmpNodeColor=SelectionType.MOUSE_OVER.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
break;
case compound:
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,1,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(compoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
EventBasedSelectionManager metabolicSelectionManager=glPathwayView.getMetaboliteSelectionManager();
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID()) || metabolicSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getName().hashCode())) {
tmpNodeColor=SelectionType.SELECTION.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID()) || metabolicSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getName().hashCode())) {
tmpNodeColor=SelectionType.MOUSE_OVER.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
}
tmpNodeColor=PathwayRenderStyle.COMPOUND_NODE_COLOR;
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(compoundNodeDisplayListId);
break;
case group:
break;
case gene:
case enzyme:
case other:
if (isVisible) renderGeneNode(gl,vertexRep);
 else {
float width=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
float height=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_GREATER,1,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
gl.glCallList(enzymeNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
Color nodeColor;
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
nodeColor=SelectionType.SELECTION.getColor();
maskFramedEnzymeNode(gl,width,height);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
nodeColor=SelectionType.MOUSE_OVER.getColor();
maskFramedEnzymeNode(gl,width,height);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.NORMAL,vertexRep.getID())) {
nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR;
}
 else {
nodeColor=Color.TRANSPARENT;
}
gl.glColor4fv(nodeColor.getRGBA(),0);
gl.glCallList(framedEnzymeNodeDisplayListId);
if (!vertexSelectionManager.checkStatus(SelectionType.DESELECTED,vertexRep.getID())) {
gl.glColor4f(0,0,0,0);
gl.glCallList(enzymeNodeDisplayListId);
}
}
break;
default :
break;
}
gl.glTranslatef(-canvasXPos,canvasYPos,0);
gl.glPopName();
}",0.9293034566614556
56893,"@Override public void mouseMoved(IMouseEvent mouseEvent){
  Point mousePosition=mouseEvent.getRAWPoint();
  if (pathwayRow.getVisibility() != EVisibility.NONE) {
    for (    PathwayMultiFormInfo info : pathwayInfos) {
      if (setWindowActive(mousePosition,info.window))       return;
    }
  }
  if (pathInfo != null && pathInfo.window != null && setWindowActive(mousePosition,pathInfo.window))   return;
  if (setWindowActive(mousePosition,rankingWindow))   return;
  if (setWindowActive(mousePosition,dataMappingWindow))   return;
}","@Override public void mouseMoved(IMouseEvent mouseEvent){
  Vec2f mousePosition=mouseEvent.getDIPPoint();
  if (pathwayRow.getVisibility() != EVisibility.NONE) {
    for (    PathwayMultiFormInfo info : pathwayInfos) {
      if (setWindowActive(mousePosition,info.window))       return;
    }
  }
  if (pathInfo != null && pathInfo.window != null && setWindowActive(mousePosition,pathInfo.window))   return;
  if (setWindowActive(mousePosition,rankingWindow))   return;
  if (setWindowActive(mousePosition,dataMappingWindow))   return;
}",0.9851024208566108
56894,"private boolean setWindowActive(Point mousePosition,GLWindow window){
  Vec2f location=window.getAbsoluteLocation();
  Vec2f size=window.getSize();
  if ((mousePosition.x >= location.x() && mousePosition.x <= location.x() + size.x()) && (mousePosition.y >= location.y() && mousePosition.y <= location.y() + size.y())) {
    windowToSetActive=window;
    return true;
  }
  return false;
}","private boolean setWindowActive(Vec2f mousePosition,GLWindow window){
  Vec2f location=window.getAbsoluteLocation();
  Vec2f size=window.getSize();
  if ((mousePosition.x() >= location.x() && mousePosition.x() <= location.x() + size.x()) && (mousePosition.y() >= location.y() && mousePosition.y() <= location.y() + size.y())) {
    windowToSetActive=window;
    return true;
  }
  return false;
}",0.9770408163265306
56895,"protected void registerListeners(){
  parentGLCanvas.addMouseListener(new IGLMouseListener(){
    @Override public void mouseWheelMoved(    IMouseEvent mouseEvent){
    }
    @Override public void mouseReleased(    IMouseEvent mouseEvent){
    }
    @Override public void mousePressed(    IMouseEvent mouseEvent){
    }
    @Override public void mouseMoved(    IMouseEvent mouseEvent){
      Point mousePosition=mouseEvent.getRAWPoint();
      if (pathwayRow.getVisibility() != EVisibility.NONE) {
        for (        PathwayMultiFormInfo info : pathwayInfos) {
          if (setWindowActive(mousePosition,info.window))           return;
        }
      }
      if (pathInfo != null && pathInfo.window != null && setWindowActive(mousePosition,pathInfo.window))       return;
      if (setWindowActive(mousePosition,rankingWindow))       return;
      if (setWindowActive(mousePosition,dataMappingWindow))       return;
    }
    private boolean setWindowActive(    Point mousePosition,    GLWindow window){
      Vec2f location=window.getAbsoluteLocation();
      Vec2f size=window.getSize();
      if ((mousePosition.x >= location.x() && mousePosition.x <= location.x() + size.x()) && (mousePosition.y >= location.y() && mousePosition.y <= location.y() + size.y())) {
        windowToSetActive=window;
        return true;
      }
      return false;
    }
    @Override public void mouseExited(    IMouseEvent mouseEvent){
    }
    @Override public void mouseEntered(    IMouseEvent mouseEvent){
    }
    @Override public void mouseDragged(    IMouseEvent mouseEvent){
    }
    @Override public void mouseClicked(    IMouseEvent mouseEvent){
    }
  }
);
  parentGLCanvas.addKeyListener(new IGLKeyListener(){
    @Override public void keyPressed(    IKeyEvent e){
      update(e);
      isControlKeyPressed=e.isControlDown();
    }
    @Override public void keyReleased(    IKeyEvent e){
      isControlKeyPressed=e.isControlDown();
    }
    private void update(    IKeyEvent e){
      boolean isPPressed=e.isKeyDown('p');
      if (isPPressed) {
        ShowPortalsEvent event=new ShowPortalsEvent(!showPortalsButton.isChecked());
        showPortalsButton.setChecked(!showPortalsButton.isChecked());
        event.setEventSpace(pathEventSpace);
        EventPublisher.INSTANCE.triggerEvent(event);
      }
      boolean iswPressed=e.isKeyDown('w');
      if (iswPressed) {
        if (showSrcWindowLinks)         showSrcWindowLinks=false;
 else         showSrcWindowLinks=true;
      }
    }
  }
);
}","protected void registerListeners(){
  parentGLCanvas.addMouseListener(new IGLMouseListener(){
    @Override public void mouseWheelMoved(    IMouseEvent mouseEvent){
    }
    @Override public void mouseReleased(    IMouseEvent mouseEvent){
    }
    @Override public void mousePressed(    IMouseEvent mouseEvent){
    }
    @Override public void mouseMoved(    IMouseEvent mouseEvent){
      Vec2f mousePosition=mouseEvent.getDIPPoint();
      if (pathwayRow.getVisibility() != EVisibility.NONE) {
        for (        PathwayMultiFormInfo info : pathwayInfos) {
          if (setWindowActive(mousePosition,info.window))           return;
        }
      }
      if (pathInfo != null && pathInfo.window != null && setWindowActive(mousePosition,pathInfo.window))       return;
      if (setWindowActive(mousePosition,rankingWindow))       return;
      if (setWindowActive(mousePosition,dataMappingWindow))       return;
    }
    private boolean setWindowActive(    Vec2f mousePosition,    GLWindow window){
      Vec2f location=window.getAbsoluteLocation();
      Vec2f size=window.getSize();
      if ((mousePosition.x() >= location.x() && mousePosition.x() <= location.x() + size.x()) && (mousePosition.y() >= location.y() && mousePosition.y() <= location.y() + size.y())) {
        windowToSetActive=window;
        return true;
      }
      return false;
    }
    @Override public void mouseExited(    IMouseEvent mouseEvent){
    }
    @Override public void mouseEntered(    IMouseEvent mouseEvent){
    }
    @Override public void mouseDragged(    IMouseEvent mouseEvent){
    }
    @Override public void mouseClicked(    IMouseEvent mouseEvent){
    }
  }
);
  parentGLCanvas.addKeyListener(new IGLKeyListener(){
    @Override public void keyPressed(    IKeyEvent e){
      update(e);
      isControlKeyPressed=e.isControlDown();
    }
    @Override public void keyReleased(    IKeyEvent e){
      isControlKeyPressed=e.isControlDown();
    }
    private void update(    IKeyEvent e){
      boolean isPPressed=e.isKeyDown('p');
      if (isPPressed) {
        ShowPortalsEvent event=new ShowPortalsEvent(!showPortalsButton.isChecked());
        showPortalsButton.setChecked(!showPortalsButton.isChecked());
        event.setEventSpace(pathEventSpace);
        EventPublisher.INSTANCE.triggerEvent(event);
      }
      boolean iswPressed=e.isKeyDown('w');
      if (iswPressed) {
        if (showSrcWindowLinks)         showSrcWindowLinks=false;
 else         showSrcWindowLinks=true;
      }
    }
  }
);
}",0.9932351770791882
56896,"@Override public String getLabel(Pick pick){
  if (hovered < 0)   return null;
  IState current=stateMachine.getCurrent();
  List<ITransition> transitions=stateMachine.getTransitions(current);
  ITransition transition=transitions.get(pick.getObjectID());
  return transition.getDisabledReason();
}","@Override public String getLabel(Pick pick){
  if (pick.getObjectID() < 0)   return null;
  IState current=stateMachine.getCurrent();
  List<ITransition> transitions=stateMachine.getTransitions(current);
  ITransition transition=transitions.get(pick.getObjectID());
  return transition.getDisabledReason();
}",0.9586776859504132
56897,"/** 
 * Reacts on the elements of the entry tag. An example entry tag looks like this: <entry id=""1"" name=""ec:1.8.4.1"" type=""enzyme"" reaction=""rn:R01292"" link=""http://www.genome.jp/dbget-bin/www_bget?enzyme+1.8.4.1"">
 */
protected void handleEntryTag(){
  int entryId=0;
  String name=""String_Node_Str"";
  String type=""String_Node_Str"";
  String externalLink=""String_Node_Str"";
  currentReactionName=null;
  for (int attributeIndex=0; attributeIndex < attributes.getLength(); attributeIndex++) {
    attributeName=attributes.getLocalName(attributeIndex);
    if (""String_Node_Str"".equals(attributeName)) {
      attributeName=attributes.getQName(attributeIndex);
    }
    if (attributeName.equals(""String_Node_Str"")) {
      entryId=Integer.valueOf(attributes.getValue(attributeIndex)).intValue();
    }
 else     if (attributeName.equals(""String_Node_Str"")) {
      name=attributes.getValue(attributeIndex);
    }
 else     if (attributeName.equals(""String_Node_Str"")) {
      type=attributes.getValue(attributeIndex);
    }
 else     if (attributeName.equals(""String_Node_Str"")) {
      externalLink=attributes.getValue(attributeIndex);
    }
 else     if (attributeName.equals(""String_Node_Str"")) {
      currentReactionName=attributes.getValue(attributeIndex);
    }
  }
  currentEntryId=entryId;
  currentVertices.clear();
  if (type.equals(""String_Node_Str"")) {
    StringTokenizer tokenText=new StringTokenizer(name,""String_Node_Str"");
    Set<Integer> davidIDs=null;
    String vertexName=""String_Node_Str"";
    Set<Integer> mappingDavidIDs=new HashSet<Integer>();
    while (tokenText.hasMoreTokens()) {
      vertexName=tokenText.nextToken();
      String entrezID=vertexName.substring(4);
      if (entrezID.isEmpty()) {
        continue;
      }
      IDMappingManager genomeIdManager=((PathwayDataDomain)DataDomainManager.get().getDataDomainByType(PathwayDataDomain.DATA_DOMAIN_TYPE)).getGeneIDMappingManager();
      davidIDs=genomeIdManager.getIDAsSet(IDType.getIDType(""String_Node_Str""),IDType.getIDType(""String_Node_Str""),Integer.valueOf(entrezID));
      if (davidIDs == null) {
        Logger.log(new Status(IStatus.INFO,this.toString(),""String_Node_Str"" + entrezID));
        continue;
      }
      mappingDavidIDs.addAll(davidIDs);
    }
    currentVertices.addAll(pathwayItemManager.createGeneVertex(vertexName,type,externalLink,mappingDavidIDs));
  }
 else {
    PathwayVertex currentVertex=pathwayItemManager.createVertex(name,type,externalLink);
    currentVertices.add(currentVertex);
  }
}","/** 
 * Reacts on the elements of the entry tag. An example entry tag looks like this: <entry id=""1"" name=""ec:1.8.4.1"" type=""enzyme"" reaction=""rn:R01292"" link=""http://www.genome.jp/dbget-bin/www_bget?enzyme+1.8.4.1"">
 */
protected void handleEntryTag(){
  int entryId=0;
  String name=""String_Node_Str"";
  String type=""String_Node_Str"";
  String externalLink=""String_Node_Str"";
  currentReactionName=null;
  for (int attributeIndex=0; attributeIndex < attributes.getLength(); attributeIndex++) {
    attributeName=attributes.getLocalName(attributeIndex);
    if (""String_Node_Str"".equals(attributeName)) {
      attributeName=attributes.getQName(attributeIndex);
    }
    if (attributeName.equals(""String_Node_Str"")) {
      entryId=Integer.valueOf(attributes.getValue(attributeIndex)).intValue();
    }
 else     if (attributeName.equals(""String_Node_Str"")) {
      name=attributes.getValue(attributeIndex);
    }
 else     if (attributeName.equals(""String_Node_Str"")) {
      type=attributes.getValue(attributeIndex);
    }
 else     if (attributeName.equals(""String_Node_Str"")) {
      externalLink=attributes.getValue(attributeIndex);
    }
 else     if (attributeName.equals(""String_Node_Str"")) {
      currentReactionName=attributes.getValue(attributeIndex);
    }
  }
  currentEntryId=entryId;
  currentVertices.clear();
  if (type.equals(""String_Node_Str"")) {
    StringTokenizer tokenText=new StringTokenizer(name,""String_Node_Str"");
    Set<Integer> davidIDs=null;
    String vertexName=""String_Node_Str"";
    Set<Integer> mappingDavidIDs=new HashSet<Integer>();
    while (tokenText.hasMoreTokens()) {
      vertexName=tokenText.nextToken();
      String entrezID=vertexName.substring(4);
      if (entrezID.isEmpty()) {
        continue;
      }
      IDMappingManager genomeIdManager=((PathwayDataDomain)DataDomainManager.get().getDataDomainByType(PathwayDataDomain.DATA_DOMAIN_TYPE)).getGeneIDMappingManager();
      try {
        davidIDs=genomeIdManager.getIDAsSet(IDType.getIDType(""String_Node_Str""),IDType.getIDType(""String_Node_Str""),Integer.valueOf(entrezID));
      }
 catch (      NumberFormatException e) {
        Logger.log(new Status(IStatus.INFO,this.toString(),""String_Node_Str"" + entrezID));
        continue;
      }
      if (davidIDs == null) {
        Logger.log(new Status(IStatus.INFO,this.toString(),""String_Node_Str"" + entrezID));
        continue;
      }
      mappingDavidIDs.addAll(davidIDs);
    }
    currentVertices.addAll(pathwayItemManager.createGeneVertex(vertexName,type,externalLink,mappingDavidIDs));
  }
 else {
    PathwayVertex currentVertex=pathwayItemManager.createVertex(name,type,externalLink);
    currentVertices.add(currentVertex);
  }
}",0.9578220858895704
56898,"/** 
 * <p> Initializes the Description as nominal with automatic qualitative colors. Sorts categories based on the comparable implementation of CategoryType. </p> <p> The number of categories auto initialization can handle is limited to the number of qualitative colors available. Typically this is around 10. More doesn't make sense. </p>
 * @param unsortedCategories
 */
public void autoInitialize(Collection<CATEGORY_TYPE> unsortedCategories){
  List<CATEGORY_TYPE> categories=new ArrayList<>(unsortedCategories);
  Collections.sort(categories);
  ColorBrewer cb=categoryType == ECategoryType.NOMINAL ? DEFAULT_QUALITATIVE_COLOR_SCHEME : DEFAULT_SEQUENTIAL_COLOR_SCHEME;
  Color default_=Color.NEUTRAL_GREY;
  for (int i=0; i < categories.size(); i++) {
    addCategoryProperty(new CategoryProperty<>(categories.get(i),default_));
  }
  if (this.size() > cb.getSizes().last()) {
    Logger.create(CategoricalClassDescription.class).error(""String_Node_Str"",unsortedCategories,cb.getSizes().last());
  }
 else {
    CategoryProperty<CATEGORY_TYPE> unknown=getUnknownCategory();
    applyColorScheme(cb,unknown == null ? null : unknown.getCategory(),false);
  }
}","/** 
 * <p> Initializes the Description as nominal with automatic qualitative colors. Sorts categories based on the comparable implementation of CategoryType. </p> <p> The number of categories auto initialization can handle is limited to the number of qualitative colors available. Typically this is around 10. More doesn't make sense. </p>
 * @param unsortedCategories
 */
public void autoInitialize(Collection<CATEGORY_TYPE> unsortedCategories){
  List<CATEGORY_TYPE> categories=new ArrayList<>(unsortedCategories);
  Collections.sort(categories);
  ColorBrewer cb=categoryType == ECategoryType.NOMINAL ? DEFAULT_QUALITATIVE_COLOR_SCHEME : DEFAULT_SEQUENTIAL_COLOR_SCHEME;
  Color default_=new Color(200,200,200);
  for (int i=0; i < categories.size(); i++) {
    addCategoryProperty(new CategoryProperty<>(categories.get(i),default_));
  }
  if (this.size() > cb.getSizes().last()) {
    Logger.create(CategoricalClassDescription.class).error(""String_Node_Str"",unsortedCategories,cb.getSizes().last());
  }
 else {
    CategoryProperty<CATEGORY_TYPE> unknown=getUnknownCategory();
    applyColorScheme(cb,unknown == null ? null : unknown.getCategory(),false);
  }
}",0.9828473413379074
56899,"@Override public void onRowClick(RankTableModel table,PickingMode pickingMode,IRow row,boolean isSelected){
  if (!isSelected && pickingMode == PickingMode.CLICKED) {
    table.setSelectedRow(row);
  }
 else   if ((isSelected && pickingMode == PickingMode.CLICKED) || (pickingMode == PickingMode.DOUBLE_CLICKED && !stratomex.isWizardVisible())) {
    updatePreview(null,(AScoreRow)row);
  }
}","@Override public void onRowClick(RankTableModel table,PickingMode pickingMode,IRow row,boolean isSelected){
  if (!isSelected && pickingMode == PickingMode.CLICKED) {
    table.setSelectedRow(row);
  }
 else   if ((isSelected && pickingMode == PickingMode.CLICKED && stratomex.isWizardVisible()) || (pickingMode == PickingMode.DOUBLE_CLICKED && !stratomex.isWizardVisible())) {
    updatePreview(null,(AScoreRow)row);
  }
}",0.9619631901840492
56900,"public void updateMinWindowSize(boolean waitForMinSizeApplication){
  int minWidth=graphLayout.getMinWidthPixels() + 2 * BOUNDS_SPACING_PIXELS;
  int minHeight=graphLayout.getMinHeightPixels() + 2 * BOUNDS_SPACING_PIXELS;
  if (minWidth > minViewWidthPixels + 2 || minWidth < minViewWidthPixels - 2 || minHeight > minViewHeightPixels + 2 || minHeight < minViewHeightPixels - 2) {
    minViewWidthPixels=minWidth;
    minViewHeightPixels=minHeight;
    this.waitForMinSizeApplication=waitForMinSizeApplication;
    isMinSizeApplied=false;
    EventPublisher eventPublisher=GeneralManager.get().getEventPublisher();
    SetMinViewSizeEvent event=new SetMinViewSizeEvent(this);
    event.setMinViewSize(minViewWidthPixels,minViewHeightPixels);
    eventPublisher.triggerEvent(event);
  }
}","public void updateMinWindowSize(boolean waitForMinSizeApplication){
  int minWidth=graphLayout.getMinWidthPixels() + 2 * BOUNDS_SPACING_PIXELS;
  int minHeight=graphLayout.getMinHeightPixels() + 2 * BOUNDS_SPACING_PIXELS;
  if (minWidth > minViewWidthPixels + 2 || minWidth < minViewWidthPixels - 2 || minHeight > minViewHeightPixels + 2 || minHeight < minViewHeightPixels - 2) {
    minViewWidthPixels=minWidth;
    minViewHeightPixels=minHeight;
    this.waitForMinSizeApplication=waitForMinSizeApplication;
    isMinSizeApplied=false;
    SetMinViewSizeEvent event=new SetMinViewSizeEvent(this);
    event.setMinViewSize(minViewWidthPixels,minViewHeightPixels);
    EventPublisher.trigger(event);
  }
}",0.7619047619047619
56901,"@Override public void reshape(GLAutoDrawable drawable,int x,int y,int width,int height){
  super.reshape(drawable,x,y,width,height);
  if (!waitForMinSizeApplication && isRendered) {
    Rectangle2D drawingArea=calculateGraphDrawingArea();
    graphLayout.applyIncrementalLayout(drawingArea);
  }
}","@Override public void reshape(GLAutoDrawable drawable,int x,int y,int width,int height){
  super.reshape(drawable,x,y,width,height);
  if (!waitForMinSizeApplication && isRendered) {
    Rectangle2D drawingArea=calculateGraphDrawingArea();
    graphLayout.applyIncrementalLayout(drawingArea);
    SetMinViewSizeEvent event=new SetMinViewSizeEvent(this);
    event.setMinViewSize(minViewWidthPixels,minViewHeightPixels);
    EventPublisher.trigger(event);
  }
}",0.7862796833773087
56902,"@Override public void reshape(GLAutoDrawable drawable,int x,int y,int width,int height){
  super.reshape(drawable,x,y,width,height);
  setLayoutDirty();
}","@Override public void reshape(GLAutoDrawable drawable,int x,int y,int width,int height){
  super.reshape(drawable,x,y,width,height);
  setLayoutDirty();
  if (minWidth > 0 && minHeight > 0)   setMinViewSize(minWidth,minHeight);
}",0.804177545691906
56903,"private void renderPathway(final GL2 gl,final PathwayGraph pathway){
  if (!initShader) {
    try {
      initShaders(gl);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  gl.glPushMatrix();
  gl.glTranslatef(vecTranslation.x(),vecTranslation.y(),vecTranslation.z());
  gl.glScalef(vecScaling.x(),vecScaling.y(),vecScaling.z());
  float textureOffset=0.0f;
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
  }
  float pathwayHeight=pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight());
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glClearStencil(0);
  gl.glClear(GL.GL_STENCIL_BUFFER_BIT);
  textureOffset+=PathwayRenderStyle.Z_OFFSET;
  gl.glTranslatef(0,pathwayHeight,textureOffset);
  augmentationRenderer.renderPathway(gl,pathway,false);
  gl.glTranslatef(0,-pathwayHeight,-textureOffset);
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    textureOffset+=PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDisable(GL.GL_DEPTH_TEST);
    gl.glStencilFunc(GL.GL_GREATER,2,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glPushName(generalManager.getViewManager().getPickingManager().getPickingID(uniqueID,EPickingType.PATHWAY_TEXTURE_SELECTION.name(),0));
    if (pathway.getType() == EPathwayDatabaseType.WIKIPATHWAYS) {
      gl.glUseProgram(shaderProgramTextOverlay);
      int pathwayTex=gl.glGetUniformLocation(shaderProgramTextOverlay,""String_Node_Str"");
      gl.glUniform1i(pathwayTex,0);
      pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
      gl.glUseProgram(0);
    }
 else {
      pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
    }
    gl.glPopName();
    gl.glStencilFunc(GL.GL_GREATER,1,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    textureOffset-=2f * PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    overlayContextBubbleSets(gl);
    overlayBubbleSets(gl);
    gl.glEnable(GL.GL_DEPTH_TEST);
    gl.glDisable(GL.GL_STENCIL_TEST);
  }
  gl.glScalef(1 / vecScaling.x(),1 / vecScaling.y(),1 / vecScaling.z());
  gl.glTranslatef(-vecTranslation.x(),-vecTranslation.y(),-vecTranslation.z());
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glPopMatrix();
}","private void renderPathway(final GL2 gl,final PathwayGraph pathway){
  if (!initShader) {
    initShader=true;
    try {
      initShaders(gl);
    }
 catch (    IOException|GLException e) {
      e.printStackTrace();
    }
  }
  gl.glPushMatrix();
  gl.glTranslatef(vecTranslation.x(),vecTranslation.y(),vecTranslation.z());
  gl.glScalef(vecScaling.x(),vecScaling.y(),vecScaling.z());
  float textureOffset=0.0f;
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
  }
  float pathwayHeight=pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight());
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glClearStencil(0);
  gl.glClear(GL.GL_STENCIL_BUFFER_BIT);
  textureOffset+=PathwayRenderStyle.Z_OFFSET;
  gl.glTranslatef(0,pathwayHeight,textureOffset);
  augmentationRenderer.renderPathway(gl,pathway,false);
  gl.glTranslatef(0,-pathwayHeight,-textureOffset);
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    textureOffset+=PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDisable(GL.GL_DEPTH_TEST);
    gl.glStencilFunc(GL.GL_GREATER,2,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glPushName(generalManager.getViewManager().getPickingManager().getPickingID(uniqueID,EPickingType.PATHWAY_TEXTURE_SELECTION.name(),0));
    if (pathway.getType() == EPathwayDatabaseType.WIKIPATHWAYS) {
      gl.glUseProgram(shaderProgramTextOverlay);
      int pathwayTex=gl.glGetUniformLocation(shaderProgramTextOverlay,""String_Node_Str"");
      gl.glUniform1i(pathwayTex,0);
      pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
      gl.glUseProgram(0);
    }
 else {
      pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
    }
    gl.glPopName();
    gl.glStencilFunc(GL.GL_GREATER,1,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    textureOffset-=2f * PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    overlayContextBubbleSets(gl);
    overlayBubbleSets(gl);
    gl.glEnable(GL.GL_DEPTH_TEST);
    gl.glDisable(GL.GL_STENCIL_TEST);
  }
  gl.glScalef(1 / vecScaling.x(),1 / vecScaling.y(),1 / vecScaling.z());
  gl.glTranslatef(-vecTranslation.x(),-vecTranslation.y(),-vecTranslation.z());
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glPopMatrix();
}",0.9932529135146186
56904,"@Override public void run(){
  minSizeComposite.setMinSize(pathway.getWidth(),pathway.getHeight());
}","@Override public void run(){
  int w=glCanvas.toRawPixel(pathway.getWidth());
  int h=glCanvas.toRawPixel(pathway.getHeight());
  minSizeComposite.setMinSize(w,h);
}",0.4812030075187969
56905,"@Override public void addPathwayView(int pathwayID,String dataDomainID){
  if (view == null)   return;
  ((GLPathway)view).setPathway(pathwayID);
  final PathwayGraph pathway=PathwayManager.get().getItem(pathwayID);
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      minSizeComposite.setMinSize(pathway.getWidth(),pathway.getHeight());
    }
  }
);
}","@Override public void addPathwayView(int pathwayID,String dataDomainID){
  if (view == null)   return;
  ((GLPathway)view).setPathway(pathwayID);
  final PathwayGraph pathway=PathwayManager.get().getItem(pathwayID);
  Display.getDefault().asyncExec(new Runnable(){
    @Override public void run(){
      int w=glCanvas.toRawPixel(pathway.getWidth());
      int h=glCanvas.toRawPixel(pathway.getHeight());
      minSizeComposite.setMinSize(w,h);
    }
  }
);
}",0.8274231678486997
56906,"public Vec2f getDIPPickedPoint(){
  return this.pickedPoint;
}","public Vec2f getDIPPickedPoint(){
  return new Vec2f(this.pickedPoint);
}",0.9185185185185184
56907,"protected OpenViewHandler(){
  super(GLKaplanMeier.VIEW_TYPE);
}","public OpenViewHandler(){
  super(GLKaplanMeier.VIEW_TYPE);
}",0.912
56908,"@Override public void run(){
  DataImportWizard dataImportWizard=createDataImportWizard();
  HelpButtonWizardDialog dialog=new HelpButtonWizardDialog(Display.getCurrent().getActiveShell(),dataImportWizard);
  dialog.open();
  return;
}","@Override public void run(){
  DataImportWizard dataImportWizard=createDataImportWizard();
  HelpButtonWizardDialog dialog=new HelpButtonWizardDialog(Display.getCurrent().getActiveShell(),dataImportWizard);
  dialog.open();
}",0.9782608695652174
56909,"/** 
 * @param startups
 * @param display
 * @return
 */
private IStartupProcedure selectStartupProcedure(Map<String,IStartupAddon> startups,Display display){
  for (  IStartupAddon startup : startups.values()) {
    if (startup.init())     return startup.create();
  }
  Shell shell=new Shell(display);
  shell.moveAbove(null);
  CaleydoProjectWizard wizardImpl=new CaleydoProjectWizard(startups);
  WizardDialog wizard=new WizardDialog(shell,wizardImpl);
  wizard.setMinimumPageSize(750,500);
  shell.forceActive();
  boolean ok=wizard.open() == Window.CANCEL;
  if (!shell.isDisposed())   shell.dispose();
  return ok ? wizardImpl.getResult() : null;
}","/** 
 * @param startups
 * @param display
 * @return
 */
private IStartupProcedure selectStartupProcedure(Map<String,IStartupAddon> startups,Display display){
  for (  IStartupAddon startup : startups.values()) {
    if (startup.init())     return startup.create();
  }
  Shell shell=new Shell(display);
  shell.moveAbove(null);
  CaleydoProjectWizard wizardImpl=new CaleydoProjectWizard(startups);
  WizardDialog wizard=new WizardDialog(shell,wizardImpl);
  wizard.setMinimumPageSize(750,500);
  shell.forceActive();
  boolean ok=wizard.open() == Window.OK;
  if (!shell.isDisposed())   shell.dispose();
  return ok ? wizardImpl.getResult() : null;
}",0.993874425727412
56910,"@Override public void removeGLEventListener(GLEventListener listener){
  glEventListeners.remove(listener);
}","@Override public void removeGLEventListener(GLEventListener listener){
  canvas.removeGLEventListener(listener);
}",0.8878923766816144
56911,"@Override public void addGLEventListener(GLEventListener listener){
  glEventListeners.add(listener);
}","@Override public void addGLEventListener(GLEventListener listener){
  canvas.addGLEventListener(listener);
}",0.909952606635071
56912,"SWTGLCanvas(GLCanvas canvas){
  this.canvas=canvas;
  canvas.addDisposeListener(new DisposeListener(){
    @Override public void widgetDisposed(    DisposeEvent e){
      if (PlatformUI.getWorkbench() != null && !PlatformUI.getWorkbench().isClosing()) {
        fireDispose(SWTGLCanvas.this.canvas);
        SWTGLCanvas.this.canvas.getContext().destroy();
        SWTGLCanvas.this.canvas.setRealized(false);
        listenerMapping.clear();
        glEventListeners.clear();
      }
    }
  }
);
  canvas.addGLEventListener(new GLEventListener(){
    int w=-1, h=-1;
    @Override public void reshape(    GLAutoDrawable drawable,    int x,    int y,    int width,    int height){
      this.w=width;
      this.h=height;
      fireReshape(drawable,x,y,width,height);
    }
    @Override public void init(    GLAutoDrawable drawable){
      this.w=drawable.getWidth();
      this.h=drawable.getHeight();
      fireInit(drawable);
    }
    @Override public void dispose(    GLAutoDrawable drawable){
      fireDispose(drawable);
    }
    @Override public void display(    GLAutoDrawable drawable){
      if (w != drawable.getWidth() || h != drawable.getHeight() && w != -1) {
        w=drawable.getWidth();
        h=drawable.getHeight();
        fireReshape(drawable,0,0,drawable.getWidth(),drawable.getHeight());
      }
      fireDisplay(drawable);
    }
  }
);
}","SWTGLCanvas(GLCanvas canvas){
  this.canvas=canvas;
}",0.0747004933051444
56913,"@Override protected void parseFile(BufferedReader reader) throws IOException {
  GeneralManager.get().getSplash().updateProgessLabel(""String_Node_Str"" + targetIDType);
  float progressBarFactor=100f / numberOfLinesInFile;
  IDSpecification idSpecification=groupingSpecifications.getRowIDSpecification();
  IDType sourceIDType=IDType.getIDType(idSpecification.getIdType());
  IDTypeParsingRules parsingRules=null;
  if (idSpecification.getIdTypeParsingRules() != null)   parsingRules=idSpecification.getIdTypeParsingRules();
 else   if (sourceIDType.getIdTypeParsingRules() != null)   parsingRules=sourceIDType.getIdTypeParsingRules();
  if (!sourceIDType.getIDCategory().equals(targetIDType.getIDCategory()))   throw new IllegalArgumentException(""String_Node_Str"" + sourceIDType + ""String_Node_Str""+ targetIDType);
  IDMappingManager idMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(sourceIDType.getIDCategory());
  if (groupingSpecifications.getDataSourcePath() == null) {
    Logger.log(new Status(IStatus.INFO,this.toString(),""String_Node_Str""));
    return;
  }
  try {
    String[] headerCells=null;
    if (groupingSpecifications.isContainsColumnIDs()) {
      reader=loader.getResource(groupingSpecifications.getDataSourcePath());
      String headerLine=""String_Node_Str"";
      int rowOfColumnIDs=(groupingSpecifications.getRowOfColumnIDs() != null) ? groupingSpecifications.getRowOfColumnIDs() : groupingSpecifications.getNumberOfHeaderLines() - 1;
      for (int countToHeader=0; countToHeader <= rowOfColumnIDs; countToHeader++) {
        headerLine=reader.readLine();
      }
      headerCells=headerLine.split(groupingSpecifications.getDelimiter(),-1);
      reader.close();
    }
    reader=loader.getResource(groupingSpecifications.getDataSourcePath());
    for (int headerLineCounter=0; headerLineCounter < groupingSpecifications.getNumberOfHeaderLines(); headerLineCounter++) {
      reader.readLine();
    }
    ArrayList<Integer> columnsToRead=groupingSpecifications.getColumns();
    String firstDataLine=null;
    if (columnsToRead == null || headerCells == null) {
      firstDataLine=reader.readLine();
      String[] data=firstDataLine.split(groupingSpecifications.getDelimiter());
      if (columnsToRead == null) {
        columnsToRead=new ArrayList<Integer>(data.length);
        for (int columnCount=1; columnCount < data.length; columnCount++) {
          columnsToRead.add(columnCount);
        }
      }
      if (headerCells == null) {
        headerCells=new String[data.length];
        for (int columnCount=0; columnCount < data.length; columnCount++) {
          headerCells[columnCount]=DEFAULT_GROUP_NAME;
        }
      }
    }
    ArrayList<ArrayList<Pair<String,ArrayList<Integer>>>> listOfGroupLists=new ArrayList<ArrayList<Pair<String,ArrayList<Integer>>>>(columnsToRead.size());
    ArrayList<String> listOfGroupNames=new ArrayList<String>(columnsToRead.size());
    ArrayList<Pair<String,ArrayList<Integer>>> currentGroupList;
    for (    Integer columnNumber : columnsToRead) {
      currentGroupList=new ArrayList<Pair<String,ArrayList<Integer>>>();
      listOfGroupLists.add(currentGroupList);
      listOfGroupNames.add(headerCells[columnNumber]);
    }
    int lineCounter=0;
    while (true) {
      String line=null;
      if (firstDataLine == null) {
        line=reader.readLine();
      }
 else {
        line=firstDataLine;
        firstDataLine=null;
      }
      if (line == null)       break;
      String[] columns=line.split(groupingSpecifications.getDelimiter());
      String originalID=columns[groupingSpecifications.getColumnOfRowIds()];
      originalID=convertID(originalID,parsingRules);
      Integer mappedID=idMappingManager.getID(sourceIDType,targetIDType,originalID);
      if (mappedID == null) {
        Logger.log(new Status(IStatus.WARNING,this.toString(),""String_Node_Str"" + originalID));
        continue;
      }
      int groupListCounter=0;
      for (      Integer columnID : columnsToRead) {
        currentGroupList=listOfGroupLists.get(groupListCounter);
        ArrayList<Integer> group=null;
        for (        Pair<String,ArrayList<Integer>> groupPair : currentGroupList) {
          if (groupPair.getFirst().equals(columns[columnID]))           group=groupPair.getSecond();
        }
        if (group == null) {
          group=new ArrayList<Integer>();
          currentGroupList.add(new Pair<String,ArrayList<Integer>>(columns[columnID],group));
        }
        group.add(mappedID);
        groupListCounter++;
      }
      lineCounter++;
      if (lineCounter % 100 == 0) {
        GeneralManager.get().getSplash().updateProgress((int)(progressBarFactor * lineCounter));
      }
    }
    perspectiveInitializationDatas=new ArrayList<PerspectiveInitializationData>();
    for (int groupListCount=0; groupListCount < listOfGroupLists.size(); groupListCount++) {
      ArrayList<Pair<String,ArrayList<Integer>>> groupList=listOfGroupLists.get(groupListCount);
      ArrayList<Integer> sortedIDs=new ArrayList<Integer>();
      ArrayList<Integer> clusterSizes=new ArrayList<Integer>(groupList.size());
      ArrayList<Integer> sampleElements=new ArrayList<Integer>(groupList.size());
      ArrayList<String> clusterNames=new ArrayList<String>(groupList.size());
      int sampleIndex=0;
      for (      Pair<String,ArrayList<Integer>> groupPair : groupList) {
        ArrayList<Integer> group=groupPair.getSecond();
        sortedIDs.addAll(group);
        clusterSizes.add(group.size());
        clusterNames.add(groupPair.getFirst());
        sampleElements.add(sampleIndex);
        sampleIndex+=group.size();
      }
      PerspectiveInitializationData data=new PerspectiveInitializationData();
      data.setData(sortedIDs,clusterSizes,sampleElements,clusterNames);
      String groupLabel=listOfGroupNames.get(groupListCount);
      if (groupLabel.equals(DEFAULT_GROUP_NAME)) {
        if (groupingSpecifications.getGroupingName() != null) {
          groupLabel=clusterSizes.size() + ""String_Node_Str"" + groupingSpecifications.getGroupingName();
        }
 else {
          groupLabel=clusterSizes.size() + ""String_Node_Str"";
        }
      }
      data.setLabel(groupLabel);
      perspectiveInitializationDatas.add(data);
    }
  }
 catch (  IOException ioException) {
    throw new IllegalStateException(""String_Node_Str"" + groupingSpecifications.getDataSourcePath());
  }
}","@Override protected void parseFile(BufferedReader reader) throws IOException {
  GeneralManager.get().updateProgressLabel(""String_Node_Str"" + targetIDType);
  float progressBarFactor=100f / numberOfLinesInFile;
  IDSpecification idSpecification=groupingSpecifications.getRowIDSpecification();
  IDType sourceIDType=IDType.getIDType(idSpecification.getIdType());
  IDTypeParsingRules parsingRules=null;
  if (idSpecification.getIdTypeParsingRules() != null)   parsingRules=idSpecification.getIdTypeParsingRules();
 else   if (sourceIDType.getIdTypeParsingRules() != null)   parsingRules=sourceIDType.getIdTypeParsingRules();
  if (!sourceIDType.getIDCategory().equals(targetIDType.getIDCategory()))   throw new IllegalArgumentException(""String_Node_Str"" + sourceIDType + ""String_Node_Str""+ targetIDType);
  IDMappingManager idMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(sourceIDType.getIDCategory());
  if (groupingSpecifications.getDataSourcePath() == null) {
    Logger.log(new Status(IStatus.INFO,this.toString(),""String_Node_Str""));
    return;
  }
  try {
    String[] headerCells=null;
    if (groupingSpecifications.isContainsColumnIDs()) {
      reader=loader.getResource(groupingSpecifications.getDataSourcePath());
      String headerLine=""String_Node_Str"";
      int rowOfColumnIDs=(groupingSpecifications.getRowOfColumnIDs() != null) ? groupingSpecifications.getRowOfColumnIDs() : groupingSpecifications.getNumberOfHeaderLines() - 1;
      for (int countToHeader=0; countToHeader <= rowOfColumnIDs; countToHeader++) {
        headerLine=reader.readLine();
      }
      headerCells=headerLine.split(groupingSpecifications.getDelimiter(),-1);
      reader.close();
    }
    reader=loader.getResource(groupingSpecifications.getDataSourcePath());
    for (int headerLineCounter=0; headerLineCounter < groupingSpecifications.getNumberOfHeaderLines(); headerLineCounter++) {
      reader.readLine();
    }
    ArrayList<Integer> columnsToRead=groupingSpecifications.getColumns();
    String firstDataLine=null;
    if (columnsToRead == null || headerCells == null) {
      firstDataLine=reader.readLine();
      String[] data=firstDataLine.split(groupingSpecifications.getDelimiter());
      if (columnsToRead == null) {
        columnsToRead=new ArrayList<Integer>(data.length);
        for (int columnCount=1; columnCount < data.length; columnCount++) {
          columnsToRead.add(columnCount);
        }
      }
      if (headerCells == null) {
        headerCells=new String[data.length];
        for (int columnCount=0; columnCount < data.length; columnCount++) {
          headerCells[columnCount]=DEFAULT_GROUP_NAME;
        }
      }
    }
    ArrayList<ArrayList<Pair<String,ArrayList<Integer>>>> listOfGroupLists=new ArrayList<ArrayList<Pair<String,ArrayList<Integer>>>>(columnsToRead.size());
    ArrayList<String> listOfGroupNames=new ArrayList<String>(columnsToRead.size());
    ArrayList<Pair<String,ArrayList<Integer>>> currentGroupList;
    for (    Integer columnNumber : columnsToRead) {
      currentGroupList=new ArrayList<Pair<String,ArrayList<Integer>>>();
      listOfGroupLists.add(currentGroupList);
      listOfGroupNames.add(headerCells[columnNumber]);
    }
    int lineCounter=0;
    while (true) {
      String line=null;
      if (firstDataLine == null) {
        line=reader.readLine();
      }
 else {
        line=firstDataLine;
        firstDataLine=null;
      }
      if (line == null)       break;
      String[] columns=line.split(groupingSpecifications.getDelimiter());
      String originalID=columns[groupingSpecifications.getColumnOfRowIds()];
      originalID=convertID(originalID,parsingRules);
      Integer mappedID=idMappingManager.getID(sourceIDType,targetIDType,originalID);
      if (mappedID == null) {
        Logger.log(new Status(IStatus.WARNING,this.toString(),""String_Node_Str"" + originalID));
        continue;
      }
      int groupListCounter=0;
      for (      Integer columnID : columnsToRead) {
        currentGroupList=listOfGroupLists.get(groupListCounter);
        ArrayList<Integer> group=null;
        for (        Pair<String,ArrayList<Integer>> groupPair : currentGroupList) {
          if (groupPair.getFirst().equals(columns[columnID]))           group=groupPair.getSecond();
        }
        if (group == null) {
          group=new ArrayList<Integer>();
          currentGroupList.add(new Pair<String,ArrayList<Integer>>(columns[columnID],group));
        }
        group.add(mappedID);
        groupListCounter++;
      }
      lineCounter++;
      if (lineCounter % 100 == 0) {
        GeneralManager.get().updateProgress((int)(progressBarFactor * lineCounter));
      }
    }
    perspectiveInitializationDatas=new ArrayList<PerspectiveInitializationData>();
    for (int groupListCount=0; groupListCount < listOfGroupLists.size(); groupListCount++) {
      ArrayList<Pair<String,ArrayList<Integer>>> groupList=listOfGroupLists.get(groupListCount);
      ArrayList<Integer> sortedIDs=new ArrayList<Integer>();
      ArrayList<Integer> clusterSizes=new ArrayList<Integer>(groupList.size());
      ArrayList<Integer> sampleElements=new ArrayList<Integer>(groupList.size());
      ArrayList<String> clusterNames=new ArrayList<String>(groupList.size());
      int sampleIndex=0;
      for (      Pair<String,ArrayList<Integer>> groupPair : groupList) {
        ArrayList<Integer> group=groupPair.getSecond();
        sortedIDs.addAll(group);
        clusterSizes.add(group.size());
        clusterNames.add(groupPair.getFirst());
        sampleElements.add(sampleIndex);
        sampleIndex+=group.size();
      }
      PerspectiveInitializationData data=new PerspectiveInitializationData();
      data.setData(sortedIDs,clusterSizes,sampleElements,clusterNames);
      String groupLabel=listOfGroupNames.get(groupListCount);
      if (groupLabel.equals(DEFAULT_GROUP_NAME)) {
        if (groupingSpecifications.getGroupingName() != null) {
          groupLabel=clusterSizes.size() + ""String_Node_Str"" + groupingSpecifications.getGroupingName();
        }
 else {
          groupLabel=clusterSizes.size() + ""String_Node_Str"";
        }
      }
      data.setLabel(groupLabel);
      perspectiveInitializationDatas.add(data);
    }
  }
 catch (  IOException ioException) {
    throw new IllegalStateException(""String_Node_Str"" + groupingSpecifications.getDataSourcePath());
  }
}",0.9980455007427096
56914,"@Override protected void parseFile(BufferedReader reader) throws IOException {
  GeneralManager.get().getSplash().updateProgessLabel(""String_Node_Str"" + mappingType);
  String line;
  int lineCounter=0;
  calculateNumberOfLinesInFile();
  float progressBarFactor=100f / numberOfLinesInFile;
  while ((line=reader.readLine()) != null && lineCounter <= stopParsingAtLine) {
    if (lineCounter <= startParsingAtLine) {
      lineCounter++;
      continue;
    }
    String[] textTokens=line.split(tokenSeparator);
    try {
      String fromID=convertID(textTokens[0],mappingType.getFromIDType().getIdTypeParsingRules());
      String toID=convertID(textTokens[1],mappingType.getToIDType().getIdTypeParsingRules());
      if (mappingType.getFromIDType().getDataType() == EDataType.INTEGER) {
        if (mappingType.getToIDType().getDataType() == EDataType.INTEGER) {
          idMappingManager.addMapping(mappingType,Integer.valueOf(fromID),Integer.valueOf(toID));
        }
 else         if (mappingType.getToIDType().getDataType() == EDataType.STRING) {
          idMappingManager.addMapping(mappingType,Integer.valueOf(fromID),toID.intern());
        }
 else         throw new IllegalStateException(""String_Node_Str"");
      }
 else       if (mappingType.getFromIDType().getDataType() == EDataType.STRING) {
        if (mappingType.getToIDType().getDataType() == EDataType.INTEGER) {
          idMappingManager.addMapping(mappingType,fromID.intern(),Integer.valueOf(toID));
        }
 else         if (mappingType.getToIDType().getDataType() == EDataType.STRING) {
          idMappingManager.addMapping(mappingType,fromID.intern(),toID.intern());
        }
 else         throw new IllegalStateException(""String_Node_Str"");
      }
 else       throw new IllegalStateException(""String_Node_Str"");
    }
 catch (    NumberFormatException nfe) {
      Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"" + mappingType,nfe));
    }
catch (    ArrayIndexOutOfBoundsException boundEx) {
      Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"" + mappingType,boundEx));
    }
    if (lineCounter % 100 == 0) {
      GeneralManager.get().getSplash().updateProgress((int)(progressBarFactor * lineCounter));
    }
    lineCounter++;
  }
}","@Override protected void parseFile(BufferedReader reader) throws IOException {
  GeneralManager.get().updateProgressLabel(""String_Node_Str"" + mappingType);
  String line;
  int lineCounter=0;
  calculateNumberOfLinesInFile();
  float progressBarFactor=100f / numberOfLinesInFile;
  while ((line=reader.readLine()) != null && lineCounter <= stopParsingAtLine) {
    if (lineCounter <= startParsingAtLine) {
      lineCounter++;
      continue;
    }
    String[] textTokens=line.split(tokenSeparator);
    try {
      String fromID=convertID(textTokens[0],mappingType.getFromIDType().getIdTypeParsingRules());
      String toID=convertID(textTokens[1],mappingType.getToIDType().getIdTypeParsingRules());
      if (mappingType.getFromIDType().getDataType() == EDataType.INTEGER) {
        if (mappingType.getToIDType().getDataType() == EDataType.INTEGER) {
          idMappingManager.addMapping(mappingType,Integer.valueOf(fromID),Integer.valueOf(toID));
        }
 else         if (mappingType.getToIDType().getDataType() == EDataType.STRING) {
          idMappingManager.addMapping(mappingType,Integer.valueOf(fromID),toID.intern());
        }
 else         throw new IllegalStateException(""String_Node_Str"");
      }
 else       if (mappingType.getFromIDType().getDataType() == EDataType.STRING) {
        if (mappingType.getToIDType().getDataType() == EDataType.INTEGER) {
          idMappingManager.addMapping(mappingType,fromID.intern(),Integer.valueOf(toID));
        }
 else         if (mappingType.getToIDType().getDataType() == EDataType.STRING) {
          idMappingManager.addMapping(mappingType,fromID.intern(),toID.intern());
        }
 else         throw new IllegalStateException(""String_Node_Str"");
      }
 else       throw new IllegalStateException(""String_Node_Str"");
    }
 catch (    NumberFormatException nfe) {
      Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"" + mappingType,nfe));
    }
catch (    ArrayIndexOutOfBoundsException boundEx) {
      Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"" + mappingType,boundEx));
    }
    if (lineCounter % 100 == 0) {
      GeneralManager.get().updateProgress((int)(progressBarFactor * lineCounter));
    }
    lineCounter++;
  }
}",0.9944555333776892
56915,"@Override protected void parseFile(BufferedReader reader) throws IOException {
  initializTables();
  GeneralManager.get().getSplash().updateProgessLabel(""String_Node_Str"" + dataSetDescription.getDataSetName());
  float progressBarFactor=100f / numberOfLinesInFile;
  for (int countHeaderLines=0; countHeaderLines < dataSetDescription.getNumberOfHeaderLines(); countHeaderLines++) {
    reader.readLine();
  }
  List<ColumnDescription> parsingPattern=dataSetDescription.getOrCreateParsingPattern();
  int lineCounter=0;
  String numberParsingErrorMessage=""String_Node_Str"" + dataSetDescription.getDataSetName() + ""String_Node_Str""+ filePath+ ""String_Node_Str"";
  boolean parsingErrorOccured=false;
  IDSpecification rowIDSpecification=dataSetDescription.getRowIDSpecification();
  IDCategory rowIDCategory=IDCategory.getIDCategory(rowIDSpecification.getIdCategory());
  IDType fromIDType=IDType.getIDType(rowIDSpecification.getIdType());
  IDType toIDType;
  if (dataDomain.isColumnDimension())   toIDType=dataDomain.getRecordIDType();
 else   toIDType=dataDomain.getDimensionIDType();
  IDMappingManager rowIDMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(rowIDCategory);
  int columnOfRowIDs=dataSetDescription.getColumnOfRowIds();
  MappingType mappingType=rowIDMappingManager.createMap(fromIDType,toIDType,false,true);
  IDTypeParsingRules parsingRules=null;
  if (rowIDSpecification.getIdTypeParsingRules() != null)   parsingRules=rowIDSpecification.getIdTypeParsingRules();
 else   if (toIDType.getIdTypeParsingRules() != null)   parsingRules=fromIDType.getIdTypeParsingRules();
  String line;
  DataDescription dataDescription=dataSetDescription.getDataDescription();
  while ((line=reader.readLine()) != null) {
    String splitLine[]=line.split(dataSetDescription.getDelimiter());
    String id=splitLine[columnOfRowIDs];
    id=convertID(id,parsingRules);
    rowIDMappingManager.addMapping(mappingType,id,lineCounter);
    for (int count=0; count < parsingPattern.size(); count++) {
      ColumnDescription columnDescription=parsingPattern.get(count);
      if (columnDescription.getDataDescription() != null) {
        dataDescription=columnDescription.getDataDescription();
      }
      String cellContent=splitLine[columnDescription.getColumn()];
      try {
switch (dataDescription.getRawDataType()) {
case FLOAT:
          float floatValue;
        FloatContainer targetColumn=(FloatContainer)targetRawContainer.get(count);
      try {
        floatValue=Float.parseFloat(cellContent);
        targetColumn.add(floatValue);
      }
 catch (      NumberFormatException nfe) {
        parsingErrorOccured=true;
        numberParsingErrorMessage+=""String_Node_Str"" + (columnDescription.getColumn()) + ""String_Node_Str""+ (lineCounter + dataSetDescription.getNumberOfHeaderLines())+ ""String_Node_Str""+ cellContent+ ""String_Node_Str"";
        targetColumn.addUnknown();
      }
    break;
case INTEGER:
  Integer intValue;
@SuppressWarnings(""String_Node_Str"") IContainer<Integer> targetIntColumn=(IContainer<Integer>)targetRawContainer.get(count);
try {
intValue=Integer.parseInt(cellContent);
targetIntColumn.add(intValue);
}
 catch (NumberFormatException nfe) {
parsingErrorOccured=true;
numberParsingErrorMessage+=""String_Node_Str"" + (columnDescription.getColumn()) + ""String_Node_Str""+ (lineCounter + dataSetDescription.getNumberOfHeaderLines())+ ""String_Node_Str""+ cellContent+ ""String_Node_Str"";
targetIntColumn.addUnknown();
}
break;
case STRING:
String stringValue=cellContent.trim();
@SuppressWarnings(""String_Node_Str"") IContainer<String> targetStringColumn=(IContainer<String>)targetRawContainer.get(count);
if (stringValue.length() == 0) {
targetStringColumn.addUnknown();
parsingErrorOccured=true;
}
 else {
targetStringColumn.add(stringValue);
}
break;
default :
throw new IllegalStateException(""String_Node_Str"" + dataDescription.getRawDataType());
}
}
 catch (IndexOutOfBoundsException ioobe) {
Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"" + lineCounter + ""String_Node_Str""+ count,ioobe));
}
}
if (lineCounter % 100 == 0) {
GeneralManager.get().getSplash().updateProgress((int)(progressBarFactor * lineCounter));
}
lineCounter++;
}
if (parsingErrorOccured) {
Logger.log(new Status(IStatus.ERROR,this.toString(),numberParsingErrorMessage));
}
}","@Override protected void parseFile(BufferedReader reader) throws IOException {
  initializTables();
  GeneralManager.get().updateProgressLabel(""String_Node_Str"" + dataSetDescription.getDataSetName());
  float progressBarFactor=100f / numberOfLinesInFile;
  for (int countHeaderLines=0; countHeaderLines < dataSetDescription.getNumberOfHeaderLines(); countHeaderLines++) {
    reader.readLine();
  }
  List<ColumnDescription> parsingPattern=dataSetDescription.getOrCreateParsingPattern();
  int lineCounter=0;
  String numberParsingErrorMessage=""String_Node_Str"" + dataSetDescription.getDataSetName() + ""String_Node_Str""+ filePath+ ""String_Node_Str"";
  boolean parsingErrorOccured=false;
  IDSpecification rowIDSpecification=dataSetDescription.getRowIDSpecification();
  IDCategory rowIDCategory=IDCategory.getIDCategory(rowIDSpecification.getIdCategory());
  IDType fromIDType=IDType.getIDType(rowIDSpecification.getIdType());
  IDType toIDType;
  if (dataDomain.isColumnDimension())   toIDType=dataDomain.getRecordIDType();
 else   toIDType=dataDomain.getDimensionIDType();
  IDMappingManager rowIDMappingManager=IDMappingManagerRegistry.get().getIDMappingManager(rowIDCategory);
  int columnOfRowIDs=dataSetDescription.getColumnOfRowIds();
  MappingType mappingType=rowIDMappingManager.createMap(fromIDType,toIDType,false,true);
  IDTypeParsingRules parsingRules=null;
  if (rowIDSpecification.getIdTypeParsingRules() != null)   parsingRules=rowIDSpecification.getIdTypeParsingRules();
 else   if (toIDType.getIdTypeParsingRules() != null)   parsingRules=fromIDType.getIdTypeParsingRules();
  String line;
  DataDescription dataDescription=dataSetDescription.getDataDescription();
  while ((line=reader.readLine()) != null) {
    String splitLine[]=line.split(dataSetDescription.getDelimiter());
    String id=splitLine[columnOfRowIDs];
    id=convertID(id,parsingRules);
    rowIDMappingManager.addMapping(mappingType,id,lineCounter);
    for (int count=0; count < parsingPattern.size(); count++) {
      ColumnDescription columnDescription=parsingPattern.get(count);
      if (columnDescription.getDataDescription() != null) {
        dataDescription=columnDescription.getDataDescription();
      }
      String cellContent=splitLine[columnDescription.getColumn()];
      try {
switch (dataDescription.getRawDataType()) {
case FLOAT:
          float floatValue;
        FloatContainer targetColumn=(FloatContainer)targetRawContainer.get(count);
      try {
        floatValue=Float.parseFloat(cellContent);
        targetColumn.add(floatValue);
      }
 catch (      NumberFormatException nfe) {
        parsingErrorOccured=true;
        numberParsingErrorMessage+=""String_Node_Str"" + (columnDescription.getColumn()) + ""String_Node_Str""+ (lineCounter + dataSetDescription.getNumberOfHeaderLines())+ ""String_Node_Str""+ cellContent+ ""String_Node_Str"";
        targetColumn.addUnknown();
      }
    break;
case INTEGER:
  Integer intValue;
@SuppressWarnings(""String_Node_Str"") IContainer<Integer> targetIntColumn=(IContainer<Integer>)targetRawContainer.get(count);
try {
intValue=Integer.parseInt(cellContent);
targetIntColumn.add(intValue);
}
 catch (NumberFormatException nfe) {
parsingErrorOccured=true;
numberParsingErrorMessage+=""String_Node_Str"" + (columnDescription.getColumn()) + ""String_Node_Str""+ (lineCounter + dataSetDescription.getNumberOfHeaderLines())+ ""String_Node_Str""+ cellContent+ ""String_Node_Str"";
targetIntColumn.addUnknown();
}
break;
case STRING:
String stringValue=cellContent.trim();
@SuppressWarnings(""String_Node_Str"") IContainer<String> targetStringColumn=(IContainer<String>)targetRawContainer.get(count);
if (stringValue.length() == 0) {
targetStringColumn.addUnknown();
parsingErrorOccured=true;
}
 else {
targetStringColumn.add(stringValue);
}
break;
default :
throw new IllegalStateException(""String_Node_Str"" + dataDescription.getRawDataType());
}
}
 catch (IndexOutOfBoundsException ioobe) {
Logger.log(new Status(IStatus.ERROR,this.toString(),""String_Node_Str"" + lineCounter + ""String_Node_Str""+ count,ioobe));
}
}
if (lineCounter % 100 == 0) {
GeneralManager.get().updateProgress((int)(progressBarFactor * lineCounter));
}
lineCounter++;
}
if (parsingErrorOccured) {
Logger.log(new Status(IStatus.ERROR,this.toString(),numberParsingErrorMessage));
}
}",0.9970947123765252
56916,"private static SerializationData loadData(String dirName) throws IOException, JAXBException {
  SerializationManager serializationManager=GeneralManager.get().getSerializationManager();
  Unmarshaller unmarshaller=serializationManager.getProjectContext().createUnmarshaller();
  File metaData=new File(dirName,METADATA_FILE);
  if (metaData.exists()) {
    ProjectMetaData m=(ProjectMetaData)unmarshaller.unmarshal(metaData);
    GeneralManager.get().setMetaData(m);
  }
  DataDomainList dataDomainList;
  for (  ISerializationAddon addon : serializationManager.getAddons()) {
    addon.deserialize(dirName,unmarshaller);
  }
  dataDomainList=(DataDomainList)unmarshaller.unmarshal(GeneralManager.get().getResourceLoader().getResource(dirName + ProjectManager.DATA_DOMAIN_FILE));
  SerializationData serializationData=new SerializationData();
  for (  ADataDomain dataDomain : dataDomainList.getDataDomains()) {
    DataSetDescription dataSetDescription=dataDomain.getDataSetDescription();
    if (dataDomain.getDataDomainType().equals(""String_Node_Str""))     DataDomainManager.get().initalizeDataDomain(""String_Node_Str"");
    IDTypeInitializer.initIDs(dataSetDescription);
    dataDomain.init();
    DataDomainManager.get().register(dataDomain);
    Thread thread=new Thread(dataDomain,dataDomain.getDataDomainID());
    thread.start();
    if (dataDomain instanceof ATableBasedDataDomain) {
      String extendedDirName=dirName + dataDomain.getDataDomainID() + ""String_Node_Str"";
      dataDomain.getDataSetDescription().setDataSourcePath(extendedDirName + ProjectManager.DATA_TABLE_FILE);
      DataDomainSerializationData dataInitializationData=new DataDomainSerializationData();
      dataInitializationData.setDataDomain((ATableBasedDataDomain)dataDomain);
      HashMap<String,Perspective> recordPerspectives=new HashMap<String,Perspective>();
      GeneralManager.get().getSplash().updateProgessLabel(""String_Node_Str"" + dataDomain.getLabel());
      Set<String> recordPerspectiveIDs=((ATableBasedDataDomain)dataDomain).getRecordPerspectiveIDs();
      Set<String> dimensionPerspectiveIDs=((ATableBasedDataDomain)dataDomain).getDimensionPerspectiveIDs();
      int nrPerspectives=recordPerspectiveIDs.size() + dimensionPerspectiveIDs.size();
      float progressBarFactor=100f / nrPerspectives;
      int perspectiveCount=0;
      for (      String recordPerspectiveID : recordPerspectiveIDs) {
        Perspective recordPerspective=(Perspective)unmarshaller.unmarshal(GeneralManager.get().getResourceLoader().getResource(extendedDirName + recordPerspectiveID + ""String_Node_Str""));
        recordPerspective.setDataDomain((ATableBasedDataDomain)dataDomain);
        recordPerspective.setIDType(((ATableBasedDataDomain)dataDomain).getRecordIDType());
        recordPerspectives.put(recordPerspectiveID,recordPerspective);
        ClusterTree tree=loadTree(extendedDirName + recordPerspectiveID + ""String_Node_Str"",((ATableBasedDataDomain)dataDomain).getRecordIDType());
        if (tree != null)         recordPerspective.setTree(tree);
        GeneralManager.get().getSplash().updateProgress((int)(progressBarFactor * perspectiveCount));
        perspectiveCount++;
      }
      dataInitializationData.setRecordPerspectiveMap(recordPerspectives);
      HashMap<String,Perspective> dimensionPerspectives=new HashMap<String,Perspective>();
      for (      String dimensionPerspectiveID : dimensionPerspectiveIDs) {
        Perspective dimensionPerspective=(Perspective)unmarshaller.unmarshal(GeneralManager.get().getResourceLoader().getResource(extendedDirName + dimensionPerspectiveID + ""String_Node_Str""));
        dimensionPerspective.setDataDomain((ATableBasedDataDomain)dataDomain);
        dimensionPerspective.setIDType(((ATableBasedDataDomain)dataDomain).getDimensionIDType());
        dimensionPerspectives.put(dimensionPerspectiveID,dimensionPerspective);
        ClusterTree tree=loadTree(extendedDirName + dimensionPerspectiveID + ""String_Node_Str"",((ATableBasedDataDomain)dataDomain).getDimensionIDType());
        dimensionPerspective.setTree(tree);
        GeneralManager.get().getSplash().updateProgress((int)(progressBarFactor * perspectiveCount));
        perspectiveCount++;
      }
      dataInitializationData.setDimensionPerspectiveMap(dimensionPerspectives);
      serializationData.addDataDomainSerializationData(dataInitializationData);
    }
  }
  for (  ISerializationAddon addon : serializationManager.getAddons()) {
    addon.deserialize(dirName,unmarshaller,serializationData);
  }
  return serializationData;
}","private static SerializationData loadData(String dirName) throws IOException, JAXBException {
  SerializationManager serializationManager=GeneralManager.get().getSerializationManager();
  Unmarshaller unmarshaller=serializationManager.getProjectContext().createUnmarshaller();
  File metaData=new File(dirName,METADATA_FILE);
  if (metaData.exists()) {
    ProjectMetaData m=(ProjectMetaData)unmarshaller.unmarshal(metaData);
    GeneralManager.get().setMetaData(m);
  }
  DataDomainList dataDomainList;
  for (  ISerializationAddon addon : serializationManager.getAddons()) {
    addon.deserialize(dirName,unmarshaller);
  }
  dataDomainList=(DataDomainList)unmarshaller.unmarshal(GeneralManager.get().getResourceLoader().getResource(dirName + ProjectManager.DATA_DOMAIN_FILE));
  SerializationData serializationData=new SerializationData();
  for (  ADataDomain dataDomain : dataDomainList.getDataDomains()) {
    DataSetDescription dataSetDescription=dataDomain.getDataSetDescription();
    if (dataDomain.getDataDomainType().equals(""String_Node_Str""))     DataDomainManager.get().initalizeDataDomain(""String_Node_Str"");
    IDTypeInitializer.initIDs(dataSetDescription);
    dataDomain.init();
    DataDomainManager.get().register(dataDomain);
    Thread thread=new Thread(dataDomain,dataDomain.getDataDomainID());
    thread.start();
    if (dataDomain instanceof ATableBasedDataDomain) {
      String extendedDirName=dirName + dataDomain.getDataDomainID() + ""String_Node_Str"";
      dataDomain.getDataSetDescription().setDataSourcePath(extendedDirName + ProjectManager.DATA_TABLE_FILE);
      DataDomainSerializationData dataInitializationData=new DataDomainSerializationData();
      dataInitializationData.setDataDomain((ATableBasedDataDomain)dataDomain);
      HashMap<String,Perspective> recordPerspectives=new HashMap<String,Perspective>();
      GeneralManager.get().updateProgressLabel(""String_Node_Str"" + dataDomain.getLabel());
      Set<String> recordPerspectiveIDs=((ATableBasedDataDomain)dataDomain).getRecordPerspectiveIDs();
      Set<String> dimensionPerspectiveIDs=((ATableBasedDataDomain)dataDomain).getDimensionPerspectiveIDs();
      int nrPerspectives=recordPerspectiveIDs.size() + dimensionPerspectiveIDs.size();
      float progressBarFactor=100f / nrPerspectives;
      int perspectiveCount=0;
      for (      String recordPerspectiveID : recordPerspectiveIDs) {
        Perspective recordPerspective=(Perspective)unmarshaller.unmarshal(GeneralManager.get().getResourceLoader().getResource(extendedDirName + recordPerspectiveID + ""String_Node_Str""));
        recordPerspective.setDataDomain((ATableBasedDataDomain)dataDomain);
        recordPerspective.setIDType(((ATableBasedDataDomain)dataDomain).getRecordIDType());
        recordPerspectives.put(recordPerspectiveID,recordPerspective);
        ClusterTree tree=loadTree(extendedDirName + recordPerspectiveID + ""String_Node_Str"",((ATableBasedDataDomain)dataDomain).getRecordIDType());
        if (tree != null)         recordPerspective.setTree(tree);
        GeneralManager.get().updateProgress((int)(progressBarFactor * perspectiveCount));
        perspectiveCount++;
      }
      dataInitializationData.setRecordPerspectiveMap(recordPerspectives);
      HashMap<String,Perspective> dimensionPerspectives=new HashMap<String,Perspective>();
      for (      String dimensionPerspectiveID : dimensionPerspectiveIDs) {
        Perspective dimensionPerspective=(Perspective)unmarshaller.unmarshal(GeneralManager.get().getResourceLoader().getResource(extendedDirName + dimensionPerspectiveID + ""String_Node_Str""));
        dimensionPerspective.setDataDomain((ATableBasedDataDomain)dataDomain);
        dimensionPerspective.setIDType(((ATableBasedDataDomain)dataDomain).getDimensionIDType());
        dimensionPerspectives.put(dimensionPerspectiveID,dimensionPerspective);
        ClusterTree tree=loadTree(extendedDirName + dimensionPerspectiveID + ""String_Node_Str"",((ATableBasedDataDomain)dataDomain).getDimensionIDType());
        dimensionPerspective.setTree(tree);
        GeneralManager.get().updateProgress((int)(progressBarFactor * perspectiveCount));
        perspectiveCount++;
      }
      dataInitializationData.setDimensionPerspectiveMap(dimensionPerspectives);
      serializationData.addDataDomainSerializationData(dataInitializationData);
    }
  }
  for (  ISerializationAddon addon : serializationManager.getAddons()) {
    addon.deserialize(dirName,unmarshaller,serializationData);
  }
  return serializationData;
}",0.9959192676739824
56917,"@Override public void init(Shell splash){
  super.init(splash);
  createUI();
}","@Override public void init(Shell splash){
  super.init(splash);
  createUI();
  splash.layout(true);
}",0.8729281767955801
56918,"private void createUI(){
  Shell splash=getSplash();
  progressBar=new ProgressBar(splash,SWT.NONE);
  progressBar.setBounds(20,200,progressLabelX,progressLabelY);
  splash.setBackgroundMode(SWT.INHERIT_DEFAULT);
  progressLabelX=splash.getSize().x - 40;
  progressLabelY=25;
  final Display display=splash.getDisplay();
  gc=new GC(splash);
  gc.setFont(new Font(display,""String_Node_Str"",10,SWT.NONE));
  gc.setForeground(display.getSystemColor(SWT.COLOR_WHITE));
  updateProgessLabel(""String_Node_Str"");
  gc.drawString(""String_Node_Str"" + GeneralManager.VERSION,336,185,true);
  GeneralManager.get().setSplash(this);
  splash.setText(""String_Node_Str"");
}","private void createUI(){
  Shell splash=getSplash();
  progressBar=new ProgressBar(splash,SWT.NONE);
  progressBar.setBounds(20,200,progressLabelX,progressLabelY);
  splash.setBackgroundMode(SWT.INHERIT_DEFAULT);
  progressLabelX=splash.getSize().x - 40;
  progressLabelY=25;
  final Display display=splash.getDisplay();
  gc=new GC(splash);
  gc.setFont(new Font(display,""String_Node_Str"",10,SWT.NONE));
  gc.setForeground(display.getSystemColor(SWT.COLOR_WHITE));
  updateProgressLabel(""String_Node_Str"");
  gc.drawString(""String_Node_Str"" + GeneralManager.VERSION,336,185,true);
  GeneralManager.get().setSplash(this);
  splash.setText(""String_Node_Str"");
}",0.9992418498862776
56919,"/** 
 * Returns the 3-component color for the given table cell. This works independent of the data type. FIXME: inhomogeneous numerical is not implemented
 * @param dimensionID
 * @param recordID
 * @return
 */
public float[] getColor(Integer dimensionID,Integer recordID){
  if (isDataHomogeneous()) {
    return colorMapper.getColor(getNormalizedValue(dimensionID,recordID));
  }
 else {
    if (EDataClass.CATEGORICAL.equals(getDataClass(dimensionID,recordID))) {
      CategoricalClassDescription<?> specific=(CategoricalClassDescription<?>)getDataClassSpecificDescription(dimensionID,recordID);
      Object category=getRaw(dimensionID,recordID);
      return specific.getCategoryProperty(category).getColor().getRGBA();
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
}","/** 
 * Returns the 3-component color for the given table cell. This works independent of the data type. FIXME: inhomogeneous numerical is not implemented
 * @param dimensionID
 * @param recordID
 * @return
 */
public float[] getColor(Integer dimensionID,Integer recordID){
  if (isDataHomogeneous()) {
    return getColorMapper().getColor(getNormalizedValue(dimensionID,recordID));
  }
 else {
    if (EDataClass.CATEGORICAL.equals(getDataClass(dimensionID,recordID))) {
      CategoricalClassDescription<?> specific=(CategoricalClassDescription<?>)getDataClassSpecificDescription(dimensionID,recordID);
      Object category=getRaw(dimensionID,recordID);
      return specific.getCategoryProperty(category).getColor().getRGBA();
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
}",0.9956869993838572
56920,"@Override public void addUnknown(){
  add(unknownCategoryType);
  if (categoricalClassDescription != null && categoricalClassDescription.getUnknownCategory() == null) {
    categoricalClassDescription.setUnknownCategory(new CategoryProperty<CATEGORY_TYPE>(unknownCategoryType,""String_Node_Str"",Color.NOT_A_NUMBER_COLOR));
  }
}","@Override public void addUnknown(){
  add(unknownCategoryType);
}",0.3316326530612244
56921,"/** 
 * Render the histogram itself
 * @param gl
 */
private void renderHistogram(GL2 gl){
  if (histogram == null) {
    if (dataDomain != null && tablePerspective != null) {
      histogram=tablePerspective.getContainerStatistics().getHistogram();
    }
 else     if (dataDomain != null) {
      TablePerspective defaultTablePerspective=dataDomain.getDefaultTablePerspective();
      histogram=defaultTablePerspective.getContainerStatistics().getHistogram();
    }
 else {
      return;
    }
  }
  float spacing=(viewFrustum.getWidth() - 2 * sideSpacing) / histogram.size();
  float continuousColorDistance=1.0f / histogram.size();
  float fOneHeightValue=(viewFrustum.getHeight() - 2 * sideSpacing) / histogram.getLargestValue();
  int iCount=0;
  for (int bucketCount=0; bucketCount < histogram.size(); bucketCount++) {
    Integer iValue=histogram.get(bucketCount);
    if (useColor) {
      float[] color;
      if (dataDomain.getTable() instanceof CategoricalTable<?>) {
        CategoricalTable<?> cTable=(CategoricalTable<?>)dataDomain.getTable();
        color=cTable.getCategoryDescriptions().getCategoryProperties().get(bucketCount).getColor().getRGBA();
      }
 else {
        color=dataDomain.getColorMapper().getColor(continuousColorDistance * iCount + continuousColorDistance / 2);
      }
      gl.glColor3fv(color,0);
    }
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(spacing * iCount + sideSpacing,sideSpacing,0);
    gl.glVertex3f(spacing * iCount + sideSpacing,sideSpacing + iValue * fOneHeightValue,0);
    gl.glVertex3f(spacing * (iCount + 1) + sideSpacing,sideSpacing + iValue * fOneHeightValue,0);
    gl.glVertex3f(spacing * (iCount + 1) + sideSpacing,sideSpacing,0);
    gl.glEnd();
    gl.glLineWidth(0.3f);
    gl.glColor3fv(Color.DARK_GRAY.getRGBA(),0);
    gl.glBegin(GL.GL_LINE_LOOP);
    gl.glVertex3f(spacing * iCount + sideSpacing,sideSpacing,0);
    gl.glVertex3f(spacing * iCount + sideSpacing,sideSpacing + iValue * fOneHeightValue,0);
    gl.glVertex3f(spacing * (iCount + 1) + sideSpacing,sideSpacing + iValue * fOneHeightValue,0);
    gl.glVertex3f(spacing * (iCount + 1) + sideSpacing,sideSpacing,0);
    gl.glEnd();
    iCount++;
  }
}","/** 
 * Render the histogram itself
 * @param gl
 */
private void renderHistogram(GL2 gl){
  if (histogram == null) {
    if (dataDomain != null && tablePerspective != null) {
      histogram=tablePerspective.getContainerStatistics().getHistogram();
    }
 else     if (dataDomain != null) {
      TablePerspective defaultTablePerspective=dataDomain.getDefaultTablePerspective();
      histogram=defaultTablePerspective.getContainerStatistics().getHistogram();
    }
 else {
      return;
    }
  }
  float spacing=(viewFrustum.getWidth() - 2 * sideSpacing) / histogram.size();
  float continuousColorDistance=1.0f / histogram.size();
  float fOneHeightValue=(viewFrustum.getHeight() - 2 * sideSpacing) / histogram.getLargestValue();
  int iCount=0;
  for (int bucketCount=0; bucketCount < histogram.size(); bucketCount++) {
    Integer iValue=histogram.get(bucketCount);
    if (useColor) {
      float[] color;
      if (dataDomain.getTable() instanceof CategoricalTable<?>) {
        CategoricalTable<?> cTable=(CategoricalTable<?>)dataDomain.getTable();
        color=cTable.getCategoryDescriptions().getCategoryProperties().get(bucketCount).getColor().getRGBA();
      }
 else       if (!dataDomain.getTable().isDataHomogeneous() && tablePerspective != null) {
        CategoricalClassDescription<?> specific=(CategoricalClassDescription<?>)dataDomain.getTable().getDataClassSpecificDescription(tablePerspective.getDimensionPerspective().getVirtualArray().get(0),tablePerspective.getRecordPerspective().getVirtualArray().get(0));
        color=specific.getCategoryProperties().get(bucketCount).getColor().getRGBA();
      }
 else {
        color=dataDomain.getColorMapper().getColor(continuousColorDistance * iCount + continuousColorDistance / 2);
      }
      gl.glColor3fv(color,0);
    }
    gl.glBegin(GL2.GL_POLYGON);
    gl.glVertex3f(spacing * iCount + sideSpacing,sideSpacing,0);
    gl.glVertex3f(spacing * iCount + sideSpacing,sideSpacing + iValue * fOneHeightValue,0);
    gl.glVertex3f(spacing * (iCount + 1) + sideSpacing,sideSpacing + iValue * fOneHeightValue,0);
    gl.glVertex3f(spacing * (iCount + 1) + sideSpacing,sideSpacing,0);
    gl.glEnd();
    gl.glLineWidth(0.3f);
    gl.glColor3fv(Color.DARK_GRAY.getRGBA(),0);
    gl.glBegin(GL.GL_LINE_LOOP);
    gl.glVertex3f(spacing * iCount + sideSpacing,sideSpacing,0);
    gl.glVertex3f(spacing * iCount + sideSpacing,sideSpacing + iValue * fOneHeightValue,0);
    gl.glVertex3f(spacing * (iCount + 1) + sideSpacing,sideSpacing + iValue * fOneHeightValue,0);
    gl.glVertex3f(spacing * (iCount + 1) + sideSpacing,sideSpacing,0);
    gl.glEnd();
    iCount++;
  }
}",0.9061139896373056
56922,"@Override public AGLView createRemoteView(AGLView remoteRenderingView,List<TablePerspective> tablePerspectives,String embeddingEventSpace){
  GLHistogram histogramView=(GLHistogram)GeneralManager.get().getViewManager().createGLView(GLHistogram.class,remoteRenderingView.getParentGLCanvas(),remoteRenderingView.getParentComposite(),new ViewFrustum(CameraProjectionMode.ORTHOGRAPHIC,0,1,0,1,-1,1));
  histogramView.setRemoteRenderingGLView((IGLRemoteRenderingView)remoteRenderingView);
  TablePerspective tablePerspective=null;
  if (tablePerspectives.size() > 0) {
    tablePerspective=tablePerspectives.get(0);
    ATableBasedDataDomain dataDomain=tablePerspective.getDataDomain();
    Histogram histogram=null;
    histogram=tablePerspective.getContainerStatistics().getHistogram();
    histogramView.setDataDomain(dataDomain);
    histogramView.setHistogram(histogram);
  }
  histogramView.initialize();
  histogramView.setDetailLevel(EDetailLevel.LOW);
  return histogramView;
}","@Override public AGLView createRemoteView(AGLView remoteRenderingView,List<TablePerspective> tablePerspectives,String embeddingEventSpace){
  GLHistogram histogramView=(GLHistogram)GeneralManager.get().getViewManager().createGLView(GLHistogram.class,remoteRenderingView.getParentGLCanvas(),remoteRenderingView.getParentComposite(),new ViewFrustum(CameraProjectionMode.ORTHOGRAPHIC,0,1,0,1,-1,1));
  histogramView.setRemoteRenderingGLView((IGLRemoteRenderingView)remoteRenderingView);
  TablePerspective tablePerspective=null;
  if (tablePerspectives.size() > 0) {
    tablePerspective=tablePerspectives.get(0);
    ATableBasedDataDomain dataDomain=tablePerspective.getDataDomain();
    Histogram histogram=null;
    histogram=tablePerspective.getContainerStatistics().getHistogram();
    histogramView.setDataDomain(dataDomain);
    histogramView.setHistogram(histogram);
    histogramView.setTablePerspective(tablePerspective);
  }
  histogramView.initialize();
  histogramView.setDetailLevel(EDetailLevel.LOW);
  return histogramView;
}",0.9717682020802376
56923,"public void addButton(GLButton b){
  this.add(b.setSize(RenderStyle.BUTTON_WIDTH,-1));
}","public GLButton addButton(GLButton b){
  this.add(b.setSize(RenderStyle.BUTTON_WIDTH,-1));
  return b;
}",0.8854166666666666
56924,"@Override protected void init(ARankColumnModel model){
  super.init(model);
  model.addPropertyChangeListener(PROP_WIDTH,listener);
  float oldWidth=size() == 1 ? (getSpaces() - RenderStyle.COLUMN_SPACE) : width;
  super.setWidth(oldWidth + model.getWidth() + RenderStyle.COLUMN_SPACE);
}","@Override protected void init(ARankColumnModel model){
  super.init(model);
  model.addPropertyChangeListener(PROP_WIDTH,listener);
  model.addPropertyChangeListener(IFilterColumnMixin.PROP_FILTER,listener);
  model.addPropertyChangeListener(IMappedColumnMixin.PROP_MAPPING,listener);
  float oldWidth=size() == 1 ? (getSpaces() - RenderStyle.COLUMN_SPACE) : width;
  super.setWidth(oldWidth + model.getWidth() + RenderStyle.COLUMN_SPACE);
}",0.7901234567901234
56925,"@Override protected void takeDown(ARankColumnModel model){
  super.takeDown(model);
  model.removePropertyChangeListener(PROP_WIDTH,listener);
  super.setWidth(width - model.getWidth() - RenderStyle.COLUMN_SPACE);
}","@Override protected void takeDown(ARankColumnModel model){
  super.takeDown(model);
  model.removePropertyChangeListener(PROP_WIDTH,listener);
  model.removePropertyChangeListener(IFilterColumnMixin.PROP_FILTER,listener);
  model.removePropertyChangeListener(IMappedColumnMixin.PROP_MAPPING,listener);
  super.setWidth(width - model.getWidth() - RenderStyle.COLUMN_SPACE);
}",0.7300509337860781
56926,"@Override public void propertyChange(PropertyChangeEvent evt){
switch (evt.getPropertyName()) {
case PROP_WIDTH:
    onWeightChanged((ARankColumnModel)evt.getSource(),(float)evt.getOldValue(),(float)evt.getNewValue());
  break;
}
}","@Override public void propertyChange(PropertyChangeEvent evt){
switch (evt.getPropertyName()) {
case PROP_WIDTH:
    onWeightChanged((ARankColumnModel)evt.getSource(),(float)evt.getOldValue(),(float)evt.getNewValue());
  break;
case IFilterColumnMixin.PROP_FILTER:
case IMappedColumnMixin.PROP_MAPPING:
propertySupport.firePropertyChange(evt);
break;
}
}",0.7897435897435897
56927,"/** 
 * @return
 */
private IColumnRenderInfo findRenderInfo(){
  IGLElementParent p=getParent();
  while (!(p instanceof IColumnRenderInfo) && p != null)   p=p.getParent();
  return (IColumnRenderInfo)p;
}","/** 
 * @return
 */
private IColumnRenderInfo findRenderInfo(){
  IGLElementParent p=summary.getParent();
  while (!(p instanceof IColumnRenderInfo) && p != null)   p=p.getParent();
  return (IColumnRenderInfo)p;
}",0.9809523809523808
56928,"@Override public boolean apply(TablePerspective tablePerspective){
  return true;
}","@Override public boolean apply(TablePerspective tablePerspective){
  return PathwayOracle.canBeUnderlying(tablePerspective);
}",0.784688995215311
56929,"@Override public int compare(IRow o1,IRow o2){
  applyPrimitive(o1);
  applyPrimitive(o2);
  CacheRow r1=getCacheRow(o1);
  CacheRow r2=getCacheRow(o2);
  if (codeOrder.equalsIgnoreCase(DEFAULT_ORDER_CODE)) {
    return Float.compare(r1.value,r2.value);
  }
 else   return runOrderScript(r1,r2);
}","@Override public int compare(IRow o1,IRow o2){
  applyPrimitive(o1);
  applyPrimitive(o2);
  CacheRow r1=getCacheRow(o1);
  CacheRow r2=getCacheRow(o2);
  if (codeOrder.equalsIgnoreCase(DEFAULT_ORDER_CODE)) {
    return -Float.compare(r1.value,r2.value);
  }
 else   return runOrderScript(r1,r2);
}",0.9983193277310924
56930,"@Override protected void renderImpl(GLGraphics g,float w,float h){
  final boolean isCompressed=(model instanceof ICompressColumnMixin && ((ICompressColumnMixin)model).isCompressed());
  if (!isCompressed) {
    g.decZ().decZ();
    g.lineWidth(RenderStyle.COLOR_STACKED_BORDER_WIDTH);
    g.color(RenderStyle.COLOR_STACKED_BORDER);
    g.drawRect(RenderStyle.GROUP_COLUMN_PADDING - 1,0,w - RenderStyle.GROUP_COLUMN_PADDING + 1,h);
    g.lineWidth(1);
    g.incZ().incZ();
  }
  renderBaseImpl(g,w,h);
  if (model instanceof IRankableColumnMixin && !isCompressed) {
    g.incZ();
    config.renderIsOrderByGlyph(g,w,h,model.getMyRanker().getOrderBy() == model);
    g.decZ();
  }
}","@Override protected void renderImpl(GLGraphics g,float w,float h){
  final boolean isCompressed=(model instanceof ICompressColumnMixin && ((ICompressColumnMixin)model).isCompressed());
  if (!isCompressed) {
    g.decZ().decZ();
    g.move(-1,0);
    config.renderHeaderBackground(g,w + 1,h,LABEL_HEIGHT,model);
    g.move(+1,0);
    g.lineWidth(RenderStyle.COLOR_STACKED_BORDER_WIDTH);
    g.color(RenderStyle.COLOR_STACKED_BORDER);
    g.drawRect(-1,0,w + 1,h);
    g.lineWidth(1);
    g.incZ().incZ();
  }
  renderBaseImpl(g,w,h);
  if (model instanceof IRankableColumnMixin && !isCompressed) {
    g.incZ();
    config.renderIsOrderByGlyph(g,w,h,model.getMyRanker().getOrderBy() == model);
    g.decZ();
  }
}",0.8780487804878049
56931,"public static CategoricalPercentageRankColumnModel create(final Object category,final CategoricalTable<?> table){
  final CategoryProperty<?> property=table.getCategoryDescriptions().getCategoryProperty(category);
  String catName=property.getCategoryName();
  IFloatFunction<IRow> data=new AFloatFunction<IRow>(){
    @Override public float applyPrimitive(    IRow in){
      if (!(in instanceof CategoricalPerspectiveRow))       return Float.NaN;
      CategoricalPerspectiveRow r=(CategoricalPerspectiveRow)in;
      if (r.getDataDomain() != table.getDataDomain())       return Float.NaN;
      int have=table.getNumberOfMatches(category,r.getCategoryIDType(),r.getDimensionID());
      return have;
    }
  }
;
  Color col=property.getColor();
  Color bgColor=col.brighter().brighter();
  return new CategoricalPercentageRankColumnModel(data,catName,col,bgColor,table.getDataDomain(),table.depth());
}","public static CategoricalPercentageRankColumnModel create(final Object category,final CategoricalTable<?> table){
  final CategoryProperty<?> property=table.getCategoryDescriptions().getCategoryProperty(category);
  String catName=property.getCategoryName();
  IFloatFunction<IRow> data=new AFloatFunction<IRow>(){
    @Override public float applyPrimitive(    IRow in){
      if (!(in instanceof CategoricalPerspectiveRow))       return Float.NaN;
      CategoricalPerspectiveRow r=(CategoricalPerspectiveRow)in;
      if (r.getDataDomain() != table.getDataDomain())       return Float.NaN;
      int have=table.getNumberOfMatches(category,r.getCategoryIDType(),r.getDimensionID());
      return have;
    }
  }
;
  Color col=property.getColor();
  Color bgColor=col.brighter();
  return new CategoricalPercentageRankColumnModel(data,catName,col,bgColor,table.getDataDomain(),table.depth());
}",0.8727070594774875
56932,"protected void renderBackground(GLGraphics g,float w,float h){
  config.renderHeaderBackground(g,w,h,LABEL_HEIGHT,model);
  renderOrderGlyph(g,w,h);
  if (isCollapsed)   return;
  boolean small=isSmallHeader(h);
  if (hasTitle && !(armDropColum && small)) {
    g.move(2,2);
    model.getHeaderRenderer().render(g,w - 6,LABEL_HEIGHT - 6,this);
    g.move(-2,-2);
  }
  if (headerHovered) {
    g.drawRect(0,0,w,h);
  }
  if (this.armDropColum) {
    g.incZ(0.6f);
    if (small) {
      g.drawText(armDropHint,2,2,w - 6,LABEL_HEIGHT - 6,VAlign.CENTER,ETextStyle.BOLD);
    }
 else {
      float hi=Math.min(h - 4,18);
      g.drawText(armDropHint,2,2 + (h - hi) * .5f,w - 4,hi,VAlign.CENTER,ETextStyle.BOLD);
    }
    g.incZ(-0.6f);
  }
}","protected void renderBackground(GLGraphics g,float w,float h){
  config.renderHeaderBackground(g,w,h,LABEL_HEIGHT,model);
  renderOrderGlyph(g,w,h);
  if (isCollapsed)   return;
  boolean small=isSmallHeader(h);
  if (hasTitle && !(armDropColum && small)) {
    g.move(2,2);
    model.getHeaderRenderer().render(g,w - 6,LABEL_HEIGHT - 7,this);
    g.move(-2,-2);
  }
  if (headerHovered) {
    g.drawRect(0,0,w,h);
  }
  if (this.armDropColum) {
    g.incZ(0.6f);
    if (small) {
      g.drawText(armDropHint,2,2,w - 6,LABEL_HEIGHT - 6,VAlign.CENTER,ETextStyle.BOLD);
    }
 else {
      float hi=Math.min(h - 4,18);
      g.drawText(armDropHint,2,2 + (h - hi) * .5f,w - 4,hi,VAlign.CENTER,ETextStyle.BOLD);
    }
    g.incZ(-0.6f);
  }
}",0.9986468200270636
56933,"@Override protected void renderImpl(GLGraphics g,float w,float h){
  final boolean isCompressed=(model instanceof ICompressColumnMixin && ((ICompressColumnMixin)model).isCompressed());
  if (!isCompressed) {
    g.decZ().decZ();
    g.move(RenderStyle.GROUP_COLUMN_PADDING - 1,0);
    config.renderHeaderBackground(g,w - RenderStyle.GROUP_COLUMN_PADDING + 1,h,LABEL_HEIGHT,model);
    g.move(-RenderStyle.GROUP_COLUMN_PADDING + 1,0);
    g.lineWidth(RenderStyle.COLOR_STACKED_BORDER_WIDTH);
    g.color(RenderStyle.COLOR_STACKED_BORDER);
    g.drawRect(RenderStyle.GROUP_COLUMN_PADDING - 1,0,w - RenderStyle.GROUP_COLUMN_PADDING + 1,h);
    g.lineWidth(1);
    g.incZ().incZ();
  }
  renderBaseImpl(g,w,h);
  if (model instanceof IRankableColumnMixin && !isCompressed) {
    g.incZ();
    config.renderIsOrderByGlyph(g,w,h,model.getMyRanker().getOrderBy() == model);
    g.decZ();
  }
}","@Override protected void renderImpl(GLGraphics g,float w,float h){
  final boolean isCompressed=(model instanceof ICompressColumnMixin && ((ICompressColumnMixin)model).isCompressed());
  if (!isCompressed) {
    g.decZ().decZ();
    g.lineWidth(RenderStyle.COLOR_STACKED_BORDER_WIDTH);
    g.color(RenderStyle.COLOR_STACKED_BORDER);
    g.drawRect(RenderStyle.GROUP_COLUMN_PADDING - 1,0,w - RenderStyle.GROUP_COLUMN_PADDING + 1,h);
    g.lineWidth(1);
    g.incZ().incZ();
  }
  renderBaseImpl(g,w,h);
  if (model instanceof IRankableColumnMixin && !isCompressed) {
    g.incZ();
    config.renderIsOrderByGlyph(g,w,h,model.getMyRanker().getOrderBy() == model);
    g.decZ();
  }
}",0.7262284620293554
56934,"@Override public float getTopPadding(boolean smallHeader){
  return LABEL_HEIGHT;
}","@Override public float getTopPadding(boolean smallHeader){
  return LABEL_HEIGHT + 2;
}",0.976470588235294
56935,"/** 
 * @param strat
 * @param group
 * @param createGSEA
 * @return
 */
public static MultiScore createScore(TablePerspective strat,Group group,boolean createGSEA){
  AGSEAAlgorithm algorithm;
  if (createGSEA)   algorithm=new GSEAAlgorithm(strat.getRecordPerspective(),group,1.0f);
 else   algorithm=new PGSEAAlgorithm(strat.getRecordPerspective(),group);
  String label=String.format(""String_Node_Str"",strat.getRecordPerspective().getLabel());
  IScore gsea=new GeneSetScore(""String_Node_Str"" + label,algorithm,false);
  IScore pValue=new GeneSetScore(""String_Node_Str"" + label,algorithm.asPValue(),true);
  MultiScore s=new MultiScore(gsea.getLabel(),color,bgColor,1);
  s.add(gsea);
  s.add(pValue);
  return s;
}","/** 
 * @param strat
 * @param group
 * @param createGSEA
 * @return
 */
public static MultiScore createScore(TablePerspective strat,Group group,boolean createGSEA){
  AGSEAAlgorithm algorithm;
  if (createGSEA)   algorithm=new GSEAAlgorithm(strat.getRecordPerspective(),group,1.0f);
 else   algorithm=new PGSEAAlgorithm(strat.getRecordPerspective(),group);
  String label=String.format(""String_Node_Str"",strat.getRecordPerspective().getLabel());
  IScore gsea=new GeneSetScore(""String_Node_Str"",algorithm,false);
  IScore pValue=new GeneSetScore(""String_Node_Str"",algorithm.asPValue(),true);
  MultiScore s=new MultiScore(label,color,bgColor,1);
  s.add(gsea);
  s.add(pValue);
  return s;
}",0.9801418439716312
56936,"@Override protected List<AScoreRow> getAll(){
  ATableBasedDataDomain d=(ATableBasedDataDomain)dataDomain;
  List<AScoreRow> r=new ArrayList<>();
  this.snapshot=new HashSet<>(d.getDimensionPerspectiveIDs());
  for (  String dimPerspectiveID : d.getDimensionPerspectiveIDs()) {
    Perspective p=d.getTable().getDimensionPerspective(dimPerspectiveID);
    if (p.isDefault() || p.isPrivate())     continue;
    Integer dimensionID=p.getVirtualArray().get(0);
    if (dataClass != d.getTable().getDataClass(dimensionID,0))     continue;
    r.add(new InhomogenousPerspectiveRow(p,this));
  }
  return r;
}","@Override protected List<AScoreRow> getAll(){
  ATableBasedDataDomain d=(ATableBasedDataDomain)dataDomain;
  List<AScoreRow> r=new ArrayList<>();
  this.snapshot=new HashSet<>(d.getDimensionPerspectiveIDs());
  for (  String dimPerspectiveID : d.getDimensionPerspectiveIDs()) {
    Perspective p=d.getTable().getDimensionPerspective(dimPerspectiveID);
    if (p.isDefault() || p.isPrivate())     continue;
    Integer dimensionID=p.getVirtualArray().get(0);
    if (dataClass != d.getTable().getDataClass(dimensionID,0))     continue;
    r.add(new InhomogenousPerspectiveRow(asTablePerspective(p),this));
  }
  return r;
}",0.9820554649265906
56937,"@Override public List<AScoreRow> onDataDomainUpdated(){
  if (!isInitialized())   return null;
  ATableBasedDataDomain d=getDataDomain();
  Set<String> current=new TreeSet<>(d.getDimensionPerspectiveIDs());
  if (snapshot.equals(d.getDimensionPerspectiveIDs()))   return null;
  BitSet blackList=new BitSet();
{
    int i=0;
    for (    AScoreRow row : data) {
      InhomogenousPerspectiveRow r=(InhomogenousPerspectiveRow)row;
      Perspective perspective=r.getStratification();
      blackList.set(i++,!current.remove(perspective.getPerspectiveID()));
    }
  }
  for (int i=blackList.nextSetBit(0); i >= 0; i=blackList.nextSetBit(i + 1)) {
    data.set(i,null);
  }
  List<AScoreRow> added=new ArrayList<>(1);
  for (  String dimPerspectiveID : current) {
    Perspective p=d.getTable().getDimensionPerspective(dimPerspectiveID);
    if (p.isDefault() || p.isPrivate())     continue;
    added.add(new InhomogenousPerspectiveRow(p,this));
  }
  updateFilter();
  snapshot=new TreeSet<>(d.getDimensionPerspectiveIDs());
  return added;
}","@Override public List<AScoreRow> onDataDomainUpdated(){
  if (!isInitialized())   return null;
  ATableBasedDataDomain d=getDataDomain();
  Set<String> current=new TreeSet<>(d.getDimensionPerspectiveIDs());
  if (snapshot.equals(d.getDimensionPerspectiveIDs()))   return null;
  BitSet blackList=new BitSet();
{
    int i=0;
    for (    AScoreRow row : data) {
      InhomogenousPerspectiveRow r=(InhomogenousPerspectiveRow)row;
      Perspective perspective=r.getStratification();
      blackList.set(i++,!current.remove(perspective.getPerspectiveID()));
    }
  }
  for (int i=blackList.nextSetBit(0); i >= 0; i=blackList.nextSetBit(i + 1)) {
    data.set(i,null);
  }
  List<AScoreRow> added=new ArrayList<>(1);
  for (  String dimPerspectiveID : current) {
    Perspective p=d.getTable().getDimensionPerspective(dimPerspectiveID);
    if (p.isDefault() || p.isPrivate())     continue;
    added.add(new InhomogenousPerspectiveRow(asTablePerspective(p),this));
  }
  updateFilter();
  snapshot=new TreeSet<>(d.getDimensionPerspectiveIDs());
  return added;
}",0.9895437262357416
56938,"/** 
 * @return the stratification, see {@link #stratification}
 */
public Perspective getStratification(){
  return clinical;
}","/** 
 * @return the stratification, see {@link #stratification}
 */
public Perspective getStratification(){
  return clinical.getRecordPerspective();
}",0.9175627240143368
56939,"@Override public VirtualArray getVirtualArray(){
  return clinical.getVirtualArray();
}","@Override public VirtualArray getVirtualArray(){
  return clinical.getRecordPerspective().getVirtualArray();
}",0.883248730964467
56940,"@Override public TablePerspective asTablePerspective(){
  return query.asTablePerspective(clinical);
}","@Override public TablePerspective asTablePerspective(){
  return clinical;
}",0.8539325842696629
56941,"public InhomogenousPerspectiveRow(Perspective clinical,InhomogenousDataDomainQuery query){
  this.clinical=clinical;
  this.query=query;
}","public InhomogenousPerspectiveRow(TablePerspective clinical,InhomogenousDataDomainQuery query){
  this.clinical=clinical;
  this.query=query;
}",0.98220640569395
56942,"@Override public boolean is(TablePerspective tablePerspective){
  return clinical.equals(tablePerspective.getDimensionPerspective());
}","@Override public boolean is(TablePerspective tablePerspective){
  return clinical.equals(tablePerspective);
}",0.8934426229508197
56943,"@Override public String getPersistentID(){
  return clinical.getPerspectiveID();
}","@Override public String getPersistentID(){
  return clinical.getTablePerspectiveKey();
}",0.9411764705882352
56944,"private void renderPathway(final GL2 gl,final PathwayGraph pathway){
  if (!initShader) {
    try {
      initShaders(gl);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  gl.glPushMatrix();
  gl.glTranslatef(vecTranslation.x(),vecTranslation.y(),vecTranslation.z());
  gl.glScalef(vecScaling.x(),vecScaling.y(),vecScaling.z());
  float textureOffset=0.0f;
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
  }
  float pathwayHeight=pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight());
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glClearStencil(0);
  gl.glClear(GL.GL_STENCIL_BUFFER_BIT);
  textureOffset+=PathwayRenderStyle.Z_OFFSET;
  gl.glTranslatef(0,pathwayHeight,textureOffset);
  if (!this.highlightVertices)   augmentationRenderer.setVisible(false);
  augmentationRenderer.renderPathway(gl,pathway,false);
  gl.glTranslatef(0,-pathwayHeight,-textureOffset);
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    textureOffset+=PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDisable(GL.GL_DEPTH_TEST);
    gl.glStencilFunc(GL.GL_GREATER,2,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glPushName(generalManager.getViewManager().getPickingManager().getPickingID(uniqueID,EPickingType.PATHWAY_TEXTURE_SELECTION.name(),0));
    pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
    gl.glPopName();
    gl.glStencilFunc(GL.GL_GREATER,1,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    textureOffset-=2f * PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    overlayContextBubbleSets(gl);
    overlayBubbleSets(gl);
    gl.glEnable(GL.GL_DEPTH_TEST);
    gl.glDisable(GL.GL_STENCIL_TEST);
  }
  gl.glScalef(1 / vecScaling.x(),1 / vecScaling.y(),1 / vecScaling.z());
  gl.glTranslatef(-vecTranslation.x(),-vecTranslation.y(),-vecTranslation.z());
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glPopMatrix();
}","private void renderPathway(final GL2 gl,final PathwayGraph pathway){
  if (!initShader) {
    try {
      initShaders(gl);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  gl.glPushMatrix();
  gl.glTranslatef(vecTranslation.x(),vecTranslation.y(),vecTranslation.z());
  gl.glScalef(vecScaling.x(),vecScaling.y(),vecScaling.z());
  float textureOffset=0.0f;
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
  }
  float pathwayHeight=pixelGLConverter.getGLHeightForPixelHeight(pathway.getHeight());
  gl.glEnable(GL.GL_STENCIL_TEST);
  gl.glClearStencil(0);
  gl.glClear(GL.GL_STENCIL_BUFFER_BIT);
  textureOffset+=PathwayRenderStyle.Z_OFFSET;
  gl.glTranslatef(0,pathwayHeight,textureOffset);
  augmentationRenderer.renderPathway(gl,pathway,false);
  gl.glTranslatef(0,-pathwayHeight,-textureOffset);
  if (enablePathwayTexture) {
    float fPathwayTransparency=1.0f;
    textureOffset+=PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    gl.glEnable(GL.GL_STENCIL_TEST);
    gl.glDisable(GL.GL_DEPTH_TEST);
    gl.glStencilFunc(GL.GL_GREATER,2,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    gl.glPushName(generalManager.getViewManager().getPickingManager().getPickingID(uniqueID,EPickingType.PATHWAY_TEXTURE_SELECTION.name(),0));
    pathwayTextureManager.renderPathway(gl,this,pathway,fPathwayTransparency,false);
    gl.glPopName();
    gl.glStencilFunc(GL.GL_GREATER,1,0xff);
    gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_KEEP);
    textureOffset-=2f * PathwayRenderStyle.Z_OFFSET;
    gl.glTranslatef(0.0f,0.0f,textureOffset);
    overlayContextBubbleSets(gl);
    overlayBubbleSets(gl);
    gl.glEnable(GL.GL_DEPTH_TEST);
    gl.glDisable(GL.GL_STENCIL_TEST);
  }
  gl.glScalef(1 / vecScaling.x(),1 / vecScaling.y(),1 / vecScaling.z());
  gl.glTranslatef(-vecTranslation.x(),-vecTranslation.y(),-vecTranslation.z());
  gl.glDisable(GL.GL_STENCIL_TEST);
  gl.glPopMatrix();
}",0.9825317061497966
56945,"private void renderVertex(final GL2 gl,PathwayVertexRep vertexRep){
  Color tmpNodeColor=null;
  gl.glPushName(glPathwayView.getPickingManager().getPickingID(glPathwayView.getID(),EPickingType.PATHWAY_ELEMENT_SELECTION.name(),vertexRep.getID()));
  float canvasXPos=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getCenterX());
  float canvasYPos=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getCenterY());
  float vertexHeight=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
  canvasYPos+=vertexHeight;
  gl.glTranslatef(canvasXPos,-canvasYPos,0);
  EPathwayVertexType vertexType=vertexRep.getType();
switch (vertexType) {
case map:
    if (vertexRep.getName().contains(""String_Node_Str"")) {
      gl.glTranslatef(-canvasXPos,canvasYPos,0);
      gl.glPopName();
      return;
    }
  float nodeWidth=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
float nodeHeight=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_REPLACE,GL.GL_REPLACE,GL.GL_REPLACE);
renderQuad(gl,nodeWidth,nodeHeight);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
renderFrame(gl,nodeWidth,nodeHeight);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
tmpNodeColor=Color.TRANSPARENT;
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderQuad(gl,nodeWidth,nodeHeight);
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
tmpNodeColor=SelectionType.SELECTION.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
tmpNodeColor=SelectionType.MOUSE_OVER.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
break;
case compound:
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,1,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(compoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
EventBasedSelectionManager metabolicSelectionManager=glPathwayView.getMetaboliteSelectionManager();
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID()) || metabolicSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getName().hashCode())) {
tmpNodeColor=SelectionType.SELECTION.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID()) || metabolicSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getName().hashCode())) {
tmpNodeColor=SelectionType.MOUSE_OVER.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
}
tmpNodeColor=PathwayRenderStyle.COMPOUND_NODE_COLOR;
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(compoundNodeDisplayListId);
break;
case group:
break;
case gene:
case enzyme:
case other:
if (isVisible) renderGeneNode(gl,vertexRep);
 else {
float width=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
float height=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_GREATER,1,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
gl.glCallList(enzymeNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
Color nodeColor;
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
nodeColor=SelectionType.SELECTION.getColor();
maskFramedEnzymeNode(gl,width,height);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
nodeColor=SelectionType.MOUSE_OVER.getColor();
maskFramedEnzymeNode(gl,width,height);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.NORMAL,vertexRep.getID())) {
nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR;
}
 else {
nodeColor=Color.BLACK;
}
gl.glColor4fv(nodeColor.getRGBA(),0);
gl.glCallList(framedEnzymeNodeDisplayListId);
if (!vertexSelectionManager.checkStatus(SelectionType.DESELECTED,vertexRep.getID())) {
gl.glColor4f(0,0,0,0);
gl.glCallList(enzymeNodeDisplayListId);
}
}
break;
default :
break;
}
gl.glTranslatef(-canvasXPos,canvasYPos,0);
gl.glPopName();
}","private void renderVertex(final GL2 gl,PathwayVertexRep vertexRep){
  Color tmpNodeColor=null;
  gl.glPushName(glPathwayView.getPickingManager().getPickingID(glPathwayView.getID(),EPickingType.PATHWAY_ELEMENT_SELECTION.name(),vertexRep.getID()));
  float canvasXPos=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getCenterX());
  float canvasYPos=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getCenterY());
  float vertexHeight=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
  canvasYPos+=vertexHeight;
  gl.glTranslatef(canvasXPos,-canvasYPos,0);
  EPathwayVertexType vertexType=vertexRep.getType();
switch (vertexType) {
case map:
    if (vertexRep.getName().contains(""String_Node_Str"")) {
      gl.glTranslatef(-canvasXPos,canvasYPos,0);
      gl.glPopName();
      return;
    }
  float nodeWidth=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
float nodeHeight=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_REPLACE,GL.GL_REPLACE,GL.GL_REPLACE);
renderQuad(gl,nodeWidth,nodeHeight);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
renderFrame(gl,nodeWidth,nodeHeight);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
tmpNodeColor=Color.TRANSPARENT;
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderQuad(gl,nodeWidth,nodeHeight);
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
tmpNodeColor=SelectionType.SELECTION.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
tmpNodeColor=SelectionType.MOUSE_OVER.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
renderFrame(gl,nodeWidth,nodeHeight);
}
break;
case compound:
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,1,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(compoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
EventBasedSelectionManager metabolicSelectionManager=glPathwayView.getMetaboliteSelectionManager();
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID()) || metabolicSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getName().hashCode())) {
tmpNodeColor=SelectionType.SELECTION.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID()) || metabolicSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getName().hashCode())) {
tmpNodeColor=SelectionType.MOUSE_OVER.getColor();
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_ALWAYS,2,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_KEEP,GL.GL_REPLACE);
gl.glCallList(framedCompoundNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
}
tmpNodeColor=PathwayRenderStyle.COMPOUND_NODE_COLOR;
gl.glColor4fv(tmpNodeColor.getRGBA(),0);
gl.glCallList(compoundNodeDisplayListId);
break;
case group:
break;
case gene:
case enzyme:
case other:
if (isVisible) renderGeneNode(gl,vertexRep);
 else {
float width=pixelGLConverter.getGLWidthForPixelWidth(vertexRep.getWidth());
float height=pixelGLConverter.getGLHeightForPixelHeight(vertexRep.getHeight());
gl.glEnable(GL.GL_STENCIL_TEST);
gl.glColorMask(false,false,false,false);
gl.glDisable(GL.GL_DEPTH_TEST);
gl.glDisable(GL.GL_BLEND);
gl.glStencilFunc(GL.GL_GREATER,1,0xff);
gl.glStencilOp(GL.GL_KEEP,GL.GL_REPLACE,GL.GL_REPLACE);
gl.glCallList(enzymeNodeDisplayListId);
gl.glDisable(GL.GL_STENCIL_TEST);
gl.glColorMask(true,true,true,true);
gl.glEnable(GL.GL_DEPTH_TEST);
gl.glEnable(GL.GL_BLEND);
Color nodeColor;
if (vertexSelectionManager.checkStatus(SelectionType.SELECTION,vertexRep.getID())) {
nodeColor=SelectionType.SELECTION.getColor();
maskFramedEnzymeNode(gl,width,height);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.MOUSE_OVER,vertexRep.getID())) {
nodeColor=SelectionType.MOUSE_OVER.getColor();
maskFramedEnzymeNode(gl,width,height);
}
 else if (vertexSelectionManager.checkStatus(SelectionType.NORMAL,vertexRep.getID())) {
nodeColor=PathwayRenderStyle.ENZYME_NODE_COLOR;
}
 else {
nodeColor=Color.TRANSPARENT;
}
gl.glColor4fv(nodeColor.getRGBA(),0);
gl.glCallList(framedEnzymeNodeDisplayListId);
if (!vertexSelectionManager.checkStatus(SelectionType.DESELECTED,vertexRep.getID())) {
gl.glColor4f(0,0,0,0);
gl.glCallList(enzymeNodeDisplayListId);
}
}
break;
default :
break;
}
gl.glTranslatef(-canvasXPos,canvasYPos,0);
gl.glPopName();
}",0.9987482117310444
56946,"@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  IGLLayoutElement hist=children.get(HIST);
  final boolean smallHeader=isSmallHeader(h);
  if (smallHeader)   hist.hide();
 else   hist.setBounds(1,hasTitle ? LABEL_HEIGHT : 0,w - 2,h - (hasTitle ? LABEL_HEIGHT : 0));
  if (config.isInteractive()) {
    IGLLayoutElement weight=children.get(DRAG_WEIGHT);
    weight.setBounds(w,hasTitle && !smallHeader ? LABEL_HEIGHT : 0,(isHovered && config.canChangeWeights()) ? 8 : 0,h - (hasTitle && !smallHeader ? LABEL_HEIGHT : 0));
{
      IGLLayoutElement buttons=children.get(BUTTONS);
      float minWidth=(buttons.asElement() instanceof ButtonBar) ? ((ButtonBar)buttons.asElement()).getMinWidth() : 0;
      System.out.println(""String_Node_Str"" + isHovered);
      boolean showButtonBar=isHovered && !isWeightDragging;
      float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
        yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
      break;
case OVER_LABEL:
    yb=0;
  break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=showButtonBar ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
float hb=showButtonBar ? RenderStyle.BUTTON_WIDTH : 0;
if ((w - 4) < minWidth) {
float missing=minWidth - (w - 4);
buttons.setBounds(-missing * 0.5f,yb,minWidth,hb);
}
 else {
buttons.setBounds(2,yb,w - 4,hb);
}
}
{
IGLLayoutElement uncollapse=children.get(UNCOLLAPSE);
float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
break;
case OVER_LABEL:
yb=0;
break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=isHovered ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
uncollapse.setBounds((w - RenderStyle.BUTTON_WIDTH) * .5f,yb,RenderStyle.BUTTON_WIDTH,isHovered ? RenderStyle.BUTTON_WIDTH : 0);
}
for (IGLLayoutElement r : children.subList(firstColumn(),children.size())) r.setBounds(defaultValue(r.getSetX(),0),defaultValue(r.getSetY(),h),defaultValue(r.getSetWidth(),w),defaultValue(r.getSetHeight(),HIST_HEIGHT));
}
}","@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  IGLLayoutElement hist=children.get(HIST);
  final boolean smallHeader=isSmallHeader(h);
  if (smallHeader)   hist.hide();
 else   hist.setBounds(1,hasTitle ? LABEL_HEIGHT : 0,w - 2,h - (hasTitle ? LABEL_HEIGHT : 0));
  if (config.isInteractive()) {
    IGLLayoutElement weight=children.get(DRAG_WEIGHT);
    weight.setBounds(w,hasTitle && !smallHeader ? LABEL_HEIGHT : 0,(isHovered && config.canChangeWeights()) ? 8 : 0,h - (hasTitle && !smallHeader ? LABEL_HEIGHT : 0));
{
      IGLLayoutElement buttons=children.get(BUTTONS);
      float minWidth=(buttons.asElement() instanceof ButtonBar) ? ((ButtonBar)buttons.asElement()).getMinWidth() : 0;
      boolean showButtonBar=isHovered && !isWeightDragging;
      float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
        yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
      break;
case OVER_LABEL:
    yb=0;
  break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=showButtonBar ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
float hb=showButtonBar ? RenderStyle.BUTTON_WIDTH : 0;
if ((w - 4) < minWidth) {
float missing=minWidth - (w - 4);
buttons.setBounds(-missing * 0.5f,yb,minWidth,hb);
}
 else {
buttons.setBounds(2,yb,w - 4,hb);
}
}
{
IGLLayoutElement uncollapse=children.get(UNCOLLAPSE);
float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
break;
case OVER_LABEL:
yb=0;
break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=isHovered ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
uncollapse.setBounds((w - RenderStyle.BUTTON_WIDTH) * .5f,yb,RenderStyle.BUTTON_WIDTH,isHovered ? RenderStyle.BUTTON_WIDTH : 0);
}
for (IGLLayoutElement r : children.subList(firstColumn(),children.size())) r.setBounds(defaultValue(r.getSetX(),0),defaultValue(r.getSetY(),h),defaultValue(r.getSetWidth(),w),defaultValue(r.getSetHeight(),HIST_HEIGHT));
}
}",0.9866416686196392
56947,"@Override protected void createSpecificFilterUI(Composite composite){
  Composite buttonComposite=new Composite(composite,SWT.RIGHT);
  GridData data=new GridData(SWT.LEFT,SWT.TOP,false,false);
  data.horizontalSpan=2;
  buttonComposite.setLayoutData(data);
  GridLayout layout=new GridLayout(3,false);
  layout.marginHeight=0;
  layout.marginWidth=0;
  layout.verticalSpacing=0;
{
    Label label=new Label(buttonComposite,SWT.WRAP);
    label.setText(""String_Node_Str"");
    data=new GridData(SWT.LEFT,SWT.TOP,false,false);
    data.horizontalSpan=2;
    label.setLayoutData(data);
    label.setFont(composite.getFont());
    Button selectButton=new Button(buttonComposite,SWT.PUSH);
    selectButton.setText(""String_Node_Str"");
    SelectionListener listener=new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        Object[] viewerElements=ArrayContentProvider.getInstance().getElements(metaData.keySet());
        fViewer.setCheckedElements(viewerElements);
      }
    }
;
    selectButton.addSelectionListener(listener);
    Button deselectButton=new Button(buttonComposite,SWT.PUSH);
    selectButton.setText(""String_Node_Str"");
    listener=new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        fViewer.setCheckedElements(new Object[0]);
      }
    }
;
    deselectButton.addSelectionListener(listener);
  }
  CheckboxTreeViewer treeViewer=createTreeViewer(composite);
  treeViewer.setCheckedElements(selection.toArray());
  data=new GridData(GridData.FILL_BOTH);
  data.widthHint=getCharWith(composite,60);
  data.heightHint=getCharHeight(composite) * 10;
  data.horizontalSpan=2;
  Tree treeWidget=treeViewer.getTree();
  treeWidget.setLayoutData(data);
  treeWidget.setFont(composite.getFont());
  createApplyGlobally(composite);
  addOKButton(composite,true);
}","@Override protected void createSpecificFilterUI(Composite composite){
  Composite buttonComposite=new Composite(composite,SWT.NONE);
  GridData data=new GridData(SWT.FILL,SWT.TOP,true,false);
  data.horizontalSpan=2;
  buttonComposite.setLayoutData(data);
  GridLayout layout=new GridLayout(3,false);
  layout.marginHeight=0;
  layout.marginWidth=0;
  layout.verticalSpacing=0;
  buttonComposite.setLayout(layout);
{
    Label label=new Label(buttonComposite,SWT.WRAP);
    label.setText(""String_Node_Str"");
    data=new GridData(SWT.LEFT,SWT.CENTER,true,false);
    data.horizontalSpan=1;
    label.setLayoutData(data);
    label.setFont(composite.getFont());
    Button selectButton=new Button(buttonComposite,SWT.PUSH);
    selectButton.setText(""String_Node_Str"");
    SelectionListener listener=new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        Object[] viewerElements=ArrayContentProvider.getInstance().getElements(metaData.keySet());
        fViewer.setCheckedElements(viewerElements);
      }
    }
;
    selectButton.setLayoutData(new GridData(SWT.RIGHT,SWT.TOP,false,false));
    selectButton.addSelectionListener(listener);
    Button deselectButton=new Button(buttonComposite,SWT.PUSH);
    deselectButton.setText(""String_Node_Str"");
    listener=new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        fViewer.setCheckedElements(new Object[0]);
      }
    }
;
    deselectButton.setLayoutData(new GridData(SWT.RIGHT,SWT.TOP,false,false));
    deselectButton.addSelectionListener(listener);
  }
  buttonComposite.pack();
  CheckboxTreeViewer treeViewer=createTreeViewer(composite);
  treeViewer.setCheckedElements(selection.toArray());
  data=new GridData(GridData.FILL_BOTH);
  data.widthHint=getCharWith(composite,60);
  data.heightHint=getCharHeight(composite) * 10;
  data.horizontalSpan=2;
  Tree treeWidget=treeViewer.getTree();
  treeWidget.setLayoutData(data);
  treeWidget.setFont(composite.getFont());
  createApplyGlobally(composite);
  addOKButton(composite,true);
}",0.3638206232581707
56948,"/** 
 * Initialize the color mapping
 * @param markerPoints the marker points
 */
private void setUpMapping(){
  Collections.sort(markerPoints);
  List<ColorMarkerPoint> finalMarkerPoints=considerSpread();
  float srcValue, destValue;
  for (int count=0; count < finalMarkerPoints.size() - 1; count++) {
    srcValue=finalMarkerPoints.get(count).getMappingValue();
    destValue=finalMarkerPoints.get(count + 1).getMappingValue();
    if (destValue < srcValue)     throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    Color srcColor=finalMarkerPoints.get(count).getColor();
    Color destColor=finalMarkerPoints.get(count + 1).getColor();
    int srcIndex=(int)(srcValue * (COLOR_DEPTH - 1));
    int destIndex=(int)(destValue * (COLOR_DEPTH - 1));
    int colorRange=destIndex - srcIndex;
    for (int innerCount=0; innerCount <= colorRange; innerCount++) {
      Color fColor=colorList.get(srcIndex + innerCount);
      float divisor=(float)colorRange / (float)innerCount;
      fColor.r=srcColor.r + (destColor.r - srcColor.r) / divisor;
      fColor.g=srcColor.g + (destColor.g - srcColor.g) / divisor;
      fColor.b=srcColor.b + (destColor.b - srcColor.b) / divisor;
    }
  }
}","/** 
 * Initialize the color mapping
 * @param markerPoints the marker points
 */
private void setUpMapping(){
  Collections.sort(markerPoints);
  List<ColorMarkerPoint> finalMarkerPoints=considerSpread();
  float srcValue, destValue;
  for (int count=0; count < finalMarkerPoints.size() - 1; count++) {
    srcValue=finalMarkerPoints.get(count).getMappingValue();
    destValue=finalMarkerPoints.get(count + 1).getMappingValue();
    if (destValue < srcValue)     throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    Color srcColor=finalMarkerPoints.get(count).getColor();
    Color destColor=finalMarkerPoints.get(count + 1).getColor();
    int srcIndex=(int)(srcValue * (COLOR_DEPTH - 1));
    int destIndex=(int)(destValue * (COLOR_DEPTH - 1));
    int colorRange=destIndex - srcIndex;
    for (int innerCount=0; innerCount <= colorRange; innerCount++) {
      Color fColor=colorList.get(srcIndex + innerCount);
      float divisor=(float)colorRange / (float)innerCount;
      fColor.r=srcColor.r + (destColor.r - srcColor.r) / divisor;
      fColor.g=srcColor.g + (destColor.g - srcColor.g) / divisor;
      fColor.b=srcColor.b + (destColor.b - srcColor.b) / divisor;
      fColor.a=srcColor.a + (destColor.a - srcColor.a) / divisor;
    }
  }
}",0.9734513274336284
56949,"/** 
 * if we pick an brick
 * @param pick
 */
protected void onBrickPick(Pick pick){
  if (pick.getPickingMode() != PickingMode.CLICKED || selectionMode == null || wizard == null)   return;
  GLBrick brick=findBick(pick.getObjectID());
  if (brick == null)   return;
  boolean isHeader=brick.isHeaderBrick();
  if (isHeader != (selectionMode == ESelectionMode.STRATIFICATION))   return;
  if (this.selectionCurrent == brick)   return;
  selectBrick(brick);
}","/** 
 * if we pick an brick
 * @param pick
 */
protected void onBrickPick(Pick pick){
  if (pick.getPickingMode() != PickingMode.CLICKED || selectionMode == null || wizard == null)   return;
  GLBrick brick=findBick(pick.getObjectID());
  if (brick == null)   return;
  boolean isHeader=brick.isHeaderBrick();
  if (isHeader != (selectionMode == ESelectionMode.STRATIFICATION))   return;
  if (this.selectionCurrent == brick)   return;
  if (this.wizardPreviews.contains(brick.getBrickColumn()))   return;
  selectBrick(brick);
}",0.9190283400809716
56950,"@Override public void addScoreToTourGuide(EDataDomainQueryMode mode,IScore... scores){
  RcpGLTourGuideView tourGuide=OpenViewHandler.showTourGuide(mode);
  GLTourGuideView receiver=tourGuide.getView();
  AddScoreColumnEvent event=new AddScoreColumnEvent(scores);
  event.to(receiver).from(this);
  receiver.onAddColumn(event);
}","@Override public void addScoreToTourGuide(EDataDomainQueryMode mode,IScore... scores){
  RcpGLTourGuideView tourGuide=OpenViewHandler.showTourGuide(mode);
  GLTourGuideView receiver=tourGuide.getView();
  AddScoreColumnEvent event=new AddScoreColumnEvent(scores);
  event.to(receiver).from(this);
  receiver.onRemoveLeadingScoreColumns(new RemoveLeadingScoreColumnsEvent());
  receiver.onAddColumn(event);
}",0.8940217391304348
56951,"@ListenTo private void onRemoveLeadingScoreColumns(RemoveLeadingScoreColumnsEvent event){
  List<ARankColumnModel> columns=this.table.getColumns();
  boolean hasOne=false;
  Collection<ARankColumnModel> toremove=new ArrayList<>();
  for (  ARankColumnModel col : columns) {
    if (col instanceof ScoreRankColumnModel || col instanceof StackedRankColumnModel || col instanceof MaxRankColumnModel) {
      hasOne=true;
      toremove.add(col);
    }
 else     if (hasOne)     break;
  }
  for (  ARankColumnModel col : toremove) {
    table.remove(col);
  }
}","@ListenTo public void onRemoveLeadingScoreColumns(RemoveLeadingScoreColumnsEvent event){
  List<ARankColumnModel> columns=this.table.getColumns();
  boolean hasOne=false;
  Collection<ARankColumnModel> toremove=new ArrayList<>();
  for (  ARankColumnModel col : columns) {
    if (col instanceof ScoreRankColumnModel || col instanceof StackedRankColumnModel || col instanceof MaxRankColumnModel) {
      hasOne=true;
      toremove.add(col);
    }
 else     if (hasOne)     break;
  }
  for (  ARankColumnModel col : toremove) {
    table.remove(col);
  }
}",0.990134529147982
56952,"public ColumnPoolUI(RankTableModel table,IRankTableUIConfig config){
  this.table=table;
  this.config=RankTableUIConfigs.nonInteractive(config);
  this.isSmallHeader=config.isSmallHeaderByDefault();
  table.addPropertyChangeListener(RankTableModel.PROP_POOL,listener);
  setLayout(this);
  setSize(-1,LABEL_HEIGHT + HIST_HEIGHT + 10);
  this.add(new PaperBasket(table).setSize(LABEL_HEIGHT + HIST_HEIGHT,-1));
{
    GLButton toggleSmallHeader=new GLButton(GLButton.EButtonMode.CHECKBOX);
    toggleSmallHeader.setSelected(isSmallHeader);
    toggleSmallHeader.setCallback(new GLButton.ISelectionCallback(){
      @Override public void onSelectionChanged(      GLButton button,      boolean selected){
        setSmallHeader(selected);
      }
    }
);
    toggleSmallHeader.setTooltip(""String_Node_Str"");
    toggleSmallHeader.setRenderer(GLRenderers.fillImage(RenderStyle.ICON_SMALL_HEADER_ON));
    toggleSmallHeader.setSelectedRenderer(GLRenderers.fillImage(RenderStyle.ICON_SMALL_HEADER_OFF));
    this.add(toggleSmallHeader);
  }
  for (  ARankColumnModel hidden : table.getPool()) {
    add(wrap(hidden));
  }
}","public ColumnPoolUI(RankTableModel table,IRankTableUIConfig config){
  this.table=table;
  this.config=RankTableUIConfigs.nonInteractive(config);
  this.isSmallHeader=config.isSmallHeaderByDefault();
  table.addPropertyChangeListener(RankTableModel.PROP_POOL,listener);
  setLayout(this);
  setSize(-1,LABEL_HEIGHT + HIST_HEIGHT);
  this.add(new PaperBasket(table).setSize(LABEL_HEIGHT + HIST_HEIGHT,-1));
{
    GLButton toggleSmallHeader=new GLButton(GLButton.EButtonMode.CHECKBOX);
    toggleSmallHeader.setSelected(isSmallHeader);
    toggleSmallHeader.setCallback(new GLButton.ISelectionCallback(){
      @Override public void onSelectionChanged(      GLButton button,      boolean selected){
        setSmallHeader(selected);
      }
    }
);
    toggleSmallHeader.setTooltip(""String_Node_Str"");
    toggleSmallHeader.setRenderer(GLRenderers.fillImage(RenderStyle.ICON_SMALL_HEADER_ON));
    toggleSmallHeader.setSelectedRenderer(GLRenderers.fillImage(RenderStyle.ICON_SMALL_HEADER_OFF));
    this.add(toggleSmallHeader);
  }
  for (  ARankColumnModel hidden : table.getPool()) {
    add(wrap(hidden));
  }
}",0.9977588525324966
56953,"public SimpleRankTableStatsElement(RankTableModel table){
  this.table=table;
  setSize(150,12);
}","public SimpleRankTableStatsElement(RankTableModel table){
  this.table=table;
  setSize(180,12);
}",0.9897959183673468
56954,"/** 
 * @param isCompact setter, see  {@link isCompact}
 */
public void setSmallHeader(boolean isCompact){
  if (this.isSmallHeader == isCompact)   return;
  this.isSmallHeader=isCompact;
  relayout();
  setSize(-1,((!isSmallHeader ? HIST_HEIGHT : 0) + LABEL_HEIGHT) * 1 + thickOffset);
  relayoutParent();
}","/** 
 * @param isCompact setter, see  {@link isCompact}
 */
public void setSmallHeader(boolean isCompact){
  if (this.isSmallHeader == isCompact)   return;
  this.isSmallHeader=isCompact;
  relayout();
  setHasThick(max(this,0));
  relayoutParent();
}",0.8372093023255814
56955,"private static boolean isSmallHeader(float h){
  return h < (LABEL_HEIGHT + HIST_HEIGHT);
}","private static boolean isSmallHeader(float h){
  return h < (LABEL_HEIGHT + HIST_HEIGHT * 0.5f);
}",0.9629629629629628
56956,"private float max(Iterable<?> its,float max){
  boolean smallHeader=isSmallHeader();
  for (  IThickHeader h : Iterables.filter(its,IThickHeader.class))   max=Math.max(h.getTopPadding(smallHeader),max);
  return max;
}","protected final float max(Iterable<?> its,float max){
  boolean smallHeader=isSmallHeader();
  for (  IThickHeader h : Iterables.filter(its,IThickHeader.class))   max=Math.max(h.getTopPadding(smallHeader),max);
  return max;
}",0.9594594594594594
56957,"@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  IGLLayoutElement hist=children.get(HIST);
  final boolean smallHeader=isSmallHeader(h);
  if (smallHeader)   hist.hide();
 else   hist.setBounds(1,hasTitle ? LABEL_HEIGHT : 0,w - 2,h - (hasTitle ? LABEL_HEIGHT : 0));
  if (config.isInteractive()) {
    IGLLayoutElement weight=children.get(DRAG_WEIGHT);
    weight.setBounds(w,hasTitle && !smallHeader ? LABEL_HEIGHT : 0,(isHovered && config.canChangeWeights()) ? 8 : 0,h - (hasTitle && !smallHeader ? LABEL_HEIGHT : 0));
{
      IGLLayoutElement buttons=children.get(BUTTONS);
      float minWidth=(buttons.asElement() instanceof ButtonBar) ? ((ButtonBar)buttons.asElement()).getMinWidth() : 0;
      boolean showButtonBar=isHovered && !isWeightDragging;
      float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
        yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
      break;
case OVER_LABEL:
    yb=0;
  break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=showButtonBar ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
float hb=showButtonBar ? RenderStyle.BUTTON_WIDTH : 0;
if ((w - 4) < minWidth) {
float missing=minWidth - (w - 4);
buttons.setBounds(-missing * 0.5f,yb,minWidth,hb);
}
 else {
buttons.setBounds(2,yb,w - 4,hb);
}
}
{
IGLLayoutElement uncollapse=children.get(UNCOLLAPSE);
float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
break;
case OVER_LABEL:
yb=0;
break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=isHovered ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
uncollapse.setBounds((w - RenderStyle.BUTTON_WIDTH) * .5f,yb,RenderStyle.BUTTON_WIDTH,isHovered ? RenderStyle.BUTTON_WIDTH : 0);
}
for (IGLLayoutElement r : children.subList(FIRST_CUSTOM,children.size())) r.setBounds(defaultValue(r.getSetX(),0),defaultValue(r.getSetY(),h),defaultValue(r.getSetWidth(),w),defaultValue(r.getSetHeight(),HIST_HEIGHT));
}
}","@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  IGLLayoutElement hist=children.get(HIST);
  final boolean smallHeader=isSmallHeader(h);
  if (smallHeader)   hist.hide();
 else   hist.setBounds(1,hasTitle ? LABEL_HEIGHT : 0,w - 2,h - (hasTitle ? LABEL_HEIGHT : 0));
  if (config.isInteractive()) {
    IGLLayoutElement weight=children.get(DRAG_WEIGHT);
    weight.setBounds(w,hasTitle && !smallHeader ? LABEL_HEIGHT : 0,(isHovered && config.canChangeWeights()) ? 8 : 0,h - (hasTitle && !smallHeader ? LABEL_HEIGHT : 0));
{
      IGLLayoutElement buttons=children.get(BUTTONS);
      float minWidth=(buttons.asElement() instanceof ButtonBar) ? ((ButtonBar)buttons.asElement()).getMinWidth() : 0;
      boolean showButtonBar=isHovered && !isWeightDragging;
      float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
        yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
      break;
case OVER_LABEL:
    yb=0;
  break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=showButtonBar ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
float hb=showButtonBar ? RenderStyle.BUTTON_WIDTH : 0;
if ((w - 4) < minWidth) {
float missing=minWidth - (w - 4);
buttons.setBounds(-missing * 0.5f,yb,minWidth,hb);
}
 else {
buttons.setBounds(2,yb,w - 4,hb);
}
}
{
IGLLayoutElement uncollapse=children.get(UNCOLLAPSE);
float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
break;
case OVER_LABEL:
yb=0;
break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=isHovered ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
uncollapse.setBounds((w - RenderStyle.BUTTON_WIDTH) * .5f,yb,RenderStyle.BUTTON_WIDTH,isHovered ? RenderStyle.BUTTON_WIDTH : 0);
}
for (IGLLayoutElement r : children.subList(firstColumn(),children.size())) r.setBounds(defaultValue(r.getSetX(),0),defaultValue(r.getSetY(),h),defaultValue(r.getSetWidth(),w),defaultValue(r.getSetHeight(),HIST_HEIGHT));
}
}",0.9441672606319792
56958,"public static GLElement createHeader(ARankColumnModel model,IRankTableUIConfig config,boolean allowComplex){
  if (allowComplex && model instanceof StackedRankColumnModel)   return new StackedColumnHeaderUI((StackedRankColumnModel)model,config);
  if (allowComplex && (model instanceof NestedRankColumnModel || (model instanceof GroupRankColumnModel)))   return new SimpleColumnHeaderUI((ACompositeRankColumnModel)model,config);
  if (model instanceof OrderColumn)   return new OrderColumnHeaderUI(model,config);
  if (allowComplex && (model instanceof MaxRankColumnModel || model instanceof ScriptedRankColumnModel))   return new VerticalColumnHeaderUI((ACompositeRankColumnModel)model,config);
  return new ColumnHeaderUI(model,config);
}","public static GLElement createHeader(ARankColumnModel model,IRankTableUIConfig config,boolean allowComplex){
  if (allowComplex && model instanceof StackedRankColumnModel)   return new StackedColumnHeaderUI((StackedRankColumnModel)model,config);
  if (allowComplex && (model instanceof NestedRankColumnModel || (model instanceof GroupRankColumnModel)))   return new SimpleColumnHeaderUI((ACompositeRankColumnModel)model,config);
  if (model instanceof OrderColumn)   return new OrderColumnHeaderUI(model,config);
  if (model instanceof MaxRankColumnModel || model instanceof ScriptedRankColumnModel)   return new VerticalColumnHeaderUI((ACompositeRankColumnModel)model,config);
  return new ColumnHeaderUI(model,config);
}",0.987688098495212
56959,"@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  super.doLayout(children,w,h);
  List<? extends IGLLayoutElement> childs=children.subList(FIRST_CUSTOM,children.size());
  if (headerHovered)   childrenHovered=true;
  if (childrenHovered && !this.isCollapsed()) {
    float y=h;
    for (    IGLLayoutElement child : childs) {
      child.setBounds(0,y,w,h);
      y+=h;
    }
  }
 else {
    for (    IGLLayoutElement child : childs)     child.setBounds(0,h,w,0);
  }
}","@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  super.doLayout(children,w,h);
  List<? extends IGLLayoutElement> childs=children.subList(firstColumn(),children.size());
  if (headerHovered)   childrenHovered=true;
  boolean showChildren=childrenHovered && !this.isCollapsed();
  if (isDownAlignment()) {
    if (showChildren) {
      float y=h;
      for (      IGLLayoutElement child : childs) {
        child.setBounds(0,y,w,h);
        y+=h;
      }
    }
 else {
      for (      IGLLayoutElement child : childs)       child.setBounds(0,h,w,0);
    }
  }
 else {
    if (showChildren) {
      float x=w;
      for (      IGLLayoutElement child : childs) {
        child.setBounds(x,0,w,h);
        x+=w;
      }
    }
 else {
      for (      IGLLayoutElement child : childs)       child.setBounds(w,0,0,h);
    }
  }
}",0.7057971014492753
56960,"@SuppressWarnings(""String_Node_Str"") protected void onChildrenChanged(IndexedPropertyChangeEvent evt){
  int index=evt.getIndex();
  if (evt.getOldValue() instanceof Integer) {
    int movedFrom=(Integer)evt.getOldValue();
    add(index + FIRST_CUSTOM,get(movedFrom + FIRST_CUSTOM));
  }
 else   if (evt.getOldValue() == null) {
    Collection<GLElement> news=null;
    if (evt.getNewValue() instanceof ARankColumnModel) {
      news=Collections.singleton(wrap((ARankColumnModel)evt.getNewValue()));
    }
 else {
      news=new ArrayList<>();
      for (      ARankColumnModel c : (Collection<ARankColumnModel>)evt.getNewValue())       news.add(wrap(c));
    }
    for (    GLElement new_ : news)     add(index++ + FIRST_CUSTOM,new_);
  }
 else   if (evt.getNewValue() == null) {
    takeDown(get(index + FIRST_CUSTOM).getLayoutDataAs(ARankColumnModel.class,null));
    remove(index + FIRST_CUSTOM);
  }
 else {
    takeDown(get(index + FIRST_CUSTOM).getLayoutDataAs(ARankColumnModel.class,null));
    set(index + FIRST_CUSTOM,wrap((ARankColumnModel)evt.getNewValue()));
  }
}","@SuppressWarnings(""String_Node_Str"") protected void onChildrenChanged(IndexedPropertyChangeEvent evt){
  int index=evt.getIndex();
  final int firstColumn=firstColumn();
  if (evt.getOldValue() instanceof Integer) {
    int movedFrom=(Integer)evt.getOldValue();
    add(index + firstColumn,get(movedFrom + firstColumn));
  }
 else   if (evt.getOldValue() == null) {
    Collection<GLElement> news=null;
    if (evt.getNewValue() instanceof ARankColumnModel) {
      news=Collections.singleton(wrap((ARankColumnModel)evt.getNewValue()));
    }
 else {
      news=new ArrayList<>();
      for (      ARankColumnModel c : (Collection<ARankColumnModel>)evt.getNewValue())       news.add(wrap(c));
    }
    for (    GLElement new_ : news)     add(index++ + firstColumn,new_);
  }
 else   if (evt.getNewValue() == null) {
    takeDown(get(index + firstColumn).getLayoutDataAs(ARankColumnModel.class,null));
    remove(index + firstColumn);
  }
 else {
    takeDown(get(index + firstColumn).getLayoutDataAs(ARankColumnModel.class,null));
    set(index + firstColumn,wrap((ARankColumnModel)evt.getNewValue()));
  }
}",0.8993595608417201
56961,"/** 
 * sorts the current data
 */
void order(){
  if (!dirtyOrder)   return;
  dirtyOrder=false;
  order=null;
  int[] deltas=null;
  boolean anyDelta=false;
  orderBy=findFirstRankable();
  exaequoOffsets.clear();
  final List<IRow> data=getTable().getData();
  if (orderBy == null) {
    List<IRow> targetOrderItems=new ArrayList<>(data.size());
    for (int i=0; i < data.size(); ++i) {
      if (!filter.get(i))       continue;
      targetOrderItems.add(data.get(i));
    }
    int[] newOrder=new int[targetOrderItems.size()];
    deltas=new int[newOrder.length];
    IntIntHashMap newRanks=new IntIntHashMap(newOrder.length);
    newRanks.setKeyNotFoundValue(-1);
    for (int i=0; i < newOrder.length; ++i) {
      IRow r=targetOrderItems.get(i);
      final int ri=r.getIndex();
      newOrder[i]=ri;
      exaequoOffsets.put(i,-i);
      if (ranks.get(ri) < 0) {
        anyDelta=true;
        deltas[i]=Integer.MIN_VALUE;
      }
 else {
        int delta=i - ranks.get(ri);
        deltas[i]=delta;
        anyDelta=anyDelta || delta != 0;
      }
      newRanks.put(ri,i);
    }
    order=newOrder;
    ranks=newRanks;
  }
 else   if (orderBy instanceof IFloatRankableColumnMixin) {
    IFloatRankableColumnMixin orderByF=(IFloatRankableColumnMixin)orderBy;
    List<IntFloat> targetOrderItems=new ArrayList<>(data.size());
    for (int i=0; i < data.size(); ++i) {
      if (filter.get(i)) {
        targetOrderItems.add(new IntFloat(i,orderByF.applyPrimitive(data.get(i))));
      }
    }
    Collections.sort(targetOrderItems);
    int[] newOrder=new int[targetOrderItems.size()];
    deltas=new int[newOrder.length];
    IntIntHashMap newRanks=new IntIntHashMap(newOrder.length);
    newRanks.setKeyNotFoundValue(-1);
    int offset=0;
    float last=Float.NaN;
    for (int i=0; i < targetOrderItems.size(); ++i) {
      IntFloat pair=targetOrderItems.get(i);
      final int ri=pair.id;
      newOrder[i]=pair.id;
      if (last == pair.value) {
        offset++;
        exaequoOffsets.put(i,offset);
      }
 else {
        offset=0;
      }
      if (ranks.get(ri) < 0) {
        anyDelta=true;
        deltas[i]=Integer.MIN_VALUE;
      }
 else {
        int delta=i - ranks.get(ri);
        deltas[i]=delta;
        anyDelta=anyDelta || delta != 0;
      }
      newRanks.put(ri,i);
      last=pair.value;
    }
    order=newOrder;
    ranks=newRanks;
  }
 else {
    List<IRow> targetOrderItems=new ArrayList<>(data.size());
    for (int i=0; i < data.size(); ++i) {
      if (filter.get(i)) {
        targetOrderItems.add(data.get(i));
      }
    }
    Collections.sort(targetOrderItems,orderBy);
    int[] newOrder=new int[targetOrderItems.size()];
    deltas=new int[newOrder.length];
    IntIntHashMap newRanks=new IntIntHashMap(newOrder.length);
    newRanks.setKeyNotFoundValue(-1);
    int offset=0;
    IRow last=null;
    for (int i=0; i < targetOrderItems.size(); ++i) {
      IRow pair=targetOrderItems.get(i);
      final int ri=pair.getIndex();
      newOrder[i]=pair.getIndex();
      if (last != null && orderBy.compare(last,pair) == 0) {
        offset++;
        exaequoOffsets.put(i,offset);
      }
 else {
        offset=0;
      }
      if (ranks.get(ri) < 0) {
        anyDelta=true;
        deltas[i]=Integer.MIN_VALUE;
      }
 else {
        int delta=i - ranks.get(ri);
        deltas[i]=delta;
        anyDelta=anyDelta || delta != 0;
      }
      newRanks.put(ri,i);
      last=pair;
    }
    order=newOrder;
    ranks=newRanks;
  }
  if (anyDelta)   propertySupport.firePropertyChange(PROP_ORDER,deltas,order);
}","/** 
 * sorts the current data
 */
void order(){
  if (!dirtyOrder)   return;
  dirtyOrder=false;
  order=null;
  int[] deltas=null;
  boolean anyDelta=false;
  orderBy=findFirstRankable();
  exaequoOffsets.clear();
  final List<IRow> data=getTable().getData();
  if (orderBy == null) {
    List<IRow> targetOrderItems=new ArrayList<>(data.size());
    for (int i=0; i < data.size(); ++i) {
      if (!filter.get(i))       continue;
      targetOrderItems.add(data.get(i));
    }
    int[] newOrder=new int[targetOrderItems.size()];
    deltas=new int[newOrder.length];
    IntIntHashMap newRanks=new IntIntHashMap(newOrder.length);
    newRanks.setKeyNotFoundValue(-1);
    for (int i=0; i < newOrder.length; ++i) {
      IRow r=targetOrderItems.get(i);
      final int ri=r.getIndex();
      newOrder[i]=ri;
      exaequoOffsets.put(i,-i);
      if (ranks.get(ri) < 0) {
        anyDelta=true;
        deltas[i]=Integer.MIN_VALUE;
      }
 else {
        int delta=i - ranks.get(ri);
        deltas[i]=delta;
        anyDelta=anyDelta || delta != 0;
      }
      newRanks.put(ri,i);
    }
    order=newOrder;
    ranks=newRanks;
  }
 else   if (orderBy instanceof IFloatRankableColumnMixin && !(orderBy instanceof NestedRankColumnModel)) {
    IFloatRankableColumnMixin orderByF=(IFloatRankableColumnMixin)orderBy;
    List<IntFloat> targetOrderItems=new ArrayList<>(data.size());
    for (int i=0; i < data.size(); ++i) {
      if (filter.get(i)) {
        targetOrderItems.add(new IntFloat(i,orderByF.applyPrimitive(data.get(i))));
      }
    }
    Collections.sort(targetOrderItems);
    int[] newOrder=new int[targetOrderItems.size()];
    deltas=new int[newOrder.length];
    IntIntHashMap newRanks=new IntIntHashMap(newOrder.length);
    newRanks.setKeyNotFoundValue(-1);
    int offset=0;
    float last=Float.NaN;
    for (int i=0; i < targetOrderItems.size(); ++i) {
      IntFloat pair=targetOrderItems.get(i);
      final int ri=pair.id;
      newOrder[i]=pair.id;
      if (last == pair.value) {
        offset++;
        exaequoOffsets.put(i,offset);
      }
 else {
        offset=0;
      }
      if (ranks.get(ri) < 0) {
        anyDelta=true;
        deltas[i]=Integer.MIN_VALUE;
      }
 else {
        int delta=i - ranks.get(ri);
        deltas[i]=delta;
        anyDelta=anyDelta || delta != 0;
      }
      newRanks.put(ri,i);
      last=pair.value;
    }
    order=newOrder;
    ranks=newRanks;
  }
 else {
    List<IRow> targetOrderItems=new ArrayList<>(data.size());
    for (int i=0; i < data.size(); ++i) {
      if (filter.get(i)) {
        targetOrderItems.add(data.get(i));
      }
    }
    Collections.sort(targetOrderItems,orderBy);
    int[] newOrder=new int[targetOrderItems.size()];
    deltas=new int[newOrder.length];
    IntIntHashMap newRanks=new IntIntHashMap(newOrder.length);
    newRanks.setKeyNotFoundValue(-1);
    int offset=0;
    IRow last=null;
    for (int i=0; i < targetOrderItems.size(); ++i) {
      IRow pair=targetOrderItems.get(i);
      final int ri=pair.getIndex();
      newOrder[i]=pair.getIndex();
      if (last != null && orderBy.compare(last,pair) == 0) {
        offset++;
        exaequoOffsets.put(i,offset);
      }
 else {
        offset=0;
      }
      if (ranks.get(ri) < 0) {
        anyDelta=true;
        deltas[i]=Integer.MIN_VALUE;
      }
 else {
        int delta=i - ranks.get(ri);
        deltas[i]=delta;
        anyDelta=anyDelta || delta != 0;
      }
      newRanks.put(ri,i);
      last=pair;
    }
    order=newOrder;
    ranks=newRanks;
  }
  if (anyDelta)   propertySupport.firePropertyChange(PROP_ORDER,deltas,order);
}",0.9934585942936672
56962,"@Override public int compare(IRow o1,IRow o2){
  final int size=children.size();
  MultiFloat f1=getSplittedValue(o1);
  MultiFloat f2=getSplittedValue(o2);
  for (int i=0; i < size; ++i) {
    float a=f1.values[i];
    float b=f2.values[i];
    int c=Float.compare(a,b);
    if (c != 0)     return c;
  }
  return 0;
}","@Override public int compare(IRow o1,IRow o2){
  final int size=children.size();
  MultiFloat f1=getSplittedValue(o1);
  MultiFloat f2=getSplittedValue(o2);
  for (int i=0; i < size; ++i) {
    float a=f1.values[i];
    float b=f2.values[i];
    int c=Float.compare(a,b);
    if (c != 0)     return -c;
  }
  return 0;
}",0.9984350547730828
56963,"@Override public String getTooltip(){
  StringBuilder b=new StringBuilder();
  int total=table.getDataMask() != null ? table.getDataMask().cardinality() : table.getDataSize();
  int filtered=table.getMyRanker(null).getFilter().cardinality();
  b.append(filtered).append(""String_Node_Str"").append(total).append(String.format(""String_Node_Str"",((float)filtered) / total));
  return b.toString();
}","@Override public String getTooltip(){
  StringBuilder b=new StringBuilder();
  int total=table.getDataMask() != null ? table.getDataMask().cardinality() : table.getDataSize();
  int filtered=table.getMyRanker(null).getFilter().cardinality();
  b.append(filtered).append(""String_Node_Str"").append(total).append(String.format(""String_Node_Str"",(filtered * 100.f) / total));
  return b.toString();
}",0.9608091024020228
56964,"private void createGroupingGroup(Composite parent,String groupLabel,final boolean isColumnGrouping){
  Group groupingsGroup=new Group(parent,SWT.SHADOW_ETCHED_IN);
  groupingsGroup.setText(groupLabel);
  groupingsGroup.setLayout(new GridLayout(2,false));
  groupingsGroup.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  Composite buttonComposite=new Composite(groupingsGroup,SWT.NONE);
  buttonComposite.setLayout(new GridLayout(1,false));
  buttonComposite.setLayoutData(new GridData(SWT.RIGHT,SWT.TOP,false,false));
  Button addGroupingButton=new Button(buttonComposite,SWT.PUSH);
  addGroupingButton.setText(""String_Node_Str"");
  addGroupingButton.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  Button editGroupingButton=new Button(buttonComposite,SWT.PUSH);
  editGroupingButton.setText(""String_Node_Str"");
  editGroupingButton.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  Button removeGroupingButton=new Button(buttonComposite,SWT.PUSH);
  removeGroupingButton.setText(""String_Node_Str"");
  removeGroupingButton.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  if (isColumnGrouping) {
    columnGroupingsList=new List(groupingsGroup,SWT.SINGLE);
    columnGroupingsList.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
    columnGroupingsList.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.columnGroupingsListSelected();
      }
    }
);
    addColumnGroupingButton=addGroupingButton;
    addColumnGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.addColumnGroupingButtonSelected();
      }
    }
);
    editColumnGroupingButton=editGroupingButton;
    editColumnGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.editColumnGroupingButtonSelected();
      }
    }
);
    removeColumnGroupingButton=removeGroupingButton;
    removeColumnGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.removeColumnGroupingButtonSelected();
      }
    }
);
  }
 else {
    rowGroupingsList=new List(groupingsGroup,SWT.SINGLE);
    rowGroupingsList.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
    rowGroupingsList.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.rowGroupingsListSelected();
      }
    }
);
    addRowGroupingButton=addGroupingButton;
    addRowGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.addRowGroupingButtonSelected();
      }
    }
);
    editRowGroupingButton=editGroupingButton;
    editRowGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.editRowGroupingButtonSelected();
      }
    }
);
    removeRowGroupingButton=removeGroupingButton;
    removeRowGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.removeRowGroupingButtonSelected();
      }
    }
);
  }
}","private void createGroupingGroup(Composite parent,String groupLabel,final boolean isColumnGrouping){
  Group groupingsGroup=new Group(parent,SWT.SHADOW_ETCHED_IN);
  groupingsGroup.setText(groupLabel);
  groupingsGroup.setLayout(new GridLayout(2,false));
  groupingsGroup.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
  Composite buttonComposite=new Composite(groupingsGroup,SWT.NONE);
  buttonComposite.setLayout(new GridLayout(1,false));
  buttonComposite.setLayoutData(new GridData(SWT.RIGHT,SWT.TOP,false,false));
  Button addGroupingButton=new Button(buttonComposite,SWT.PUSH);
  addGroupingButton.setText(""String_Node_Str"");
  addGroupingButton.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  Button editGroupingButton=new Button(buttonComposite,SWT.PUSH);
  editGroupingButton.setText(""String_Node_Str"");
  editGroupingButton.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  Button removeGroupingButton=new Button(buttonComposite,SWT.PUSH);
  removeGroupingButton.setText(""String_Node_Str"");
  removeGroupingButton.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  if (isColumnGrouping) {
    columnGroupingsList=new List(groupingsGroup,SWT.SINGLE);
    columnGroupingsList.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
    columnGroupingsList.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.columnGroupingsListSelected();
      }
    }
);
    addColumnGroupingButton=addGroupingButton;
    addColumnGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.addColumnGroupingButtonSelected();
      }
    }
);
    editColumnGroupingButton=editGroupingButton;
    editColumnGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.editColumnGroupingButtonSelected();
      }
    }
);
    removeColumnGroupingButton=removeGroupingButton;
    removeColumnGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.removeColumnGroupingButtonSelected();
      }
    }
);
  }
 else {
    rowGroupingsList=new List(groupingsGroup,SWT.SINGLE);
    rowGroupingsList.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
    rowGroupingsList.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.rowGroupingsListSelected();
      }
    }
);
    addRowGroupingButton=addGroupingButton;
    addRowGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.addRowGroupingButtonSelected();
      }
    }
);
    editRowGroupingButton=editGroupingButton;
    editRowGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.editRowGroupingButtonSelected();
      }
    }
);
    removeRowGroupingButton=removeGroupingButton;
    removeRowGroupingButton.addSelectionListener(new SelectionAdapter(){
      @Override public void widgetSelected(      SelectionEvent e){
        mediator.removeRowGroupingButtonSelected();
      }
    }
);
  }
  if (isColumnGrouping) {
    columnGroupingsGroup=groupingsGroup;
  }
 else {
    rowGroupingsGroup=groupingsGroup;
  }
}",0.9824306664730652
56965,"public void pageActivated(){
  String columnIDCategoryString=dataSetDescription.getColumnIDSpecification().getIdCategory();
  columnIDCategory=IDCategory.getIDCategory(columnIDCategoryString);
  String rowIDCategoryString=dataSetDescription.getRowIDSpecification().getIdCategory();
  rowIDCategory=IDCategory.getIDCategory(rowIDCategoryString);
  if (dataSetDescription.getColumnGroupingSpecifications() != null) {
    columnGroupingSpecifications=dataSetDescription.getColumnGroupingSpecifications();
    page.columnGroupingsList.removeAll();
    for (    GroupingParseSpecification groupingParseSpecification : columnGroupingSpecifications) {
      page.columnGroupingsList.add(groupingParseSpecification.getGroupingName());
    }
  }
 else {
    dataSetDescription.setColumnGroupingSpecifications(columnGroupingSpecifications);
  }
  if (dataSetDescription.getRowGroupingSpecifications() != null) {
    rowGroupingSpecifications=dataSetDescription.getRowGroupingSpecifications();
    page.rowGroupingsList.removeAll();
    for (    GroupingParseSpecification groupingParseSpecification : rowGroupingSpecifications) {
      page.rowGroupingsList.add(groupingParseSpecification.getGroupingName());
    }
  }
 else {
    dataSetDescription.setRowGroupingSpecifications(rowGroupingSpecifications);
  }
  guiCreated();
}","public void pageActivated(){
  if (dataSetDescription.getColumnIDSpecification() == null) {
    enableColumnGrouping(false);
    page.columnGroupingsList.removeAll();
    columnGroupingSpecifications.clear();
  }
 else {
    String columnIDCategoryString=dataSetDescription.getColumnIDSpecification().getIdCategory();
    columnIDCategory=IDCategory.getIDCategory(columnIDCategoryString);
    enableColumnGrouping(true);
  }
  String rowIDCategoryString=dataSetDescription.getRowIDSpecification().getIdCategory();
  rowIDCategory=IDCategory.getIDCategory(rowIDCategoryString);
  if (dataSetDescription.getColumnGroupingSpecifications() != null) {
    columnGroupingSpecifications=dataSetDescription.getColumnGroupingSpecifications();
    page.columnGroupingsList.removeAll();
    for (    GroupingParseSpecification groupingParseSpecification : columnGroupingSpecifications) {
      page.columnGroupingsList.add(groupingParseSpecification.getGroupingName());
    }
  }
 else {
    dataSetDescription.setColumnGroupingSpecifications(columnGroupingSpecifications);
  }
  if (dataSetDescription.getRowGroupingSpecifications() != null) {
    rowGroupingSpecifications=dataSetDescription.getRowGroupingSpecifications();
    page.rowGroupingsList.removeAll();
    for (    GroupingParseSpecification groupingParseSpecification : rowGroupingSpecifications) {
      page.rowGroupingsList.add(groupingParseSpecification.getGroupingName());
    }
  }
 else {
    dataSetDescription.setRowGroupingSpecifications(rowGroupingSpecifications);
  }
  guiCreated();
}",0.9135285913528592
56966,"@Override public boolean canFinish(){
  if (!visitedPages.contains(dataSetTypePage) || chosenDataTypePage == null)   return false;
  return super.canFinish();
}","@Override public boolean canFinish(){
  if (chosenDataTypePage == null)   return false;
  return super.canFinish();
}",0.8447653429602888
56967,"@Override public void pageActivated(){
}","@Override public void pageActivated(){
  getWizard().setChosenDataTypePage(null);
  getWizard().getContainer().updateButtons();
}",0.4733727810650887
56968,"/** 
 * Reads the min and max values (if set) from the dialog
 */
public void fillDataSetDescription(){
  IDSpecification rowIDSpecification=new IDSpecification();
  IDType rowIDType=IDType.getIDType(page.rowIDCombo.getItem(page.rowIDCombo.getSelectionIndex()));
  rowIDSpecification.setIdType(rowIDType.getTypeName());
  if (rowIDType.getIDCategory().getCategoryName().equals(""String_Node_Str""))   rowIDSpecification.setIDTypeGene(true);
  rowIDSpecification.setIdCategory(rowIDType.getIDCategory().getCategoryName());
  rowIDSpecification.setIdTypeParsingRules(rowIDTypeParsingRules);
  if (!page.inhomogeneousDatasetButton.getSelection()) {
    IDSpecification columnIDSpecification=new IDSpecification();
    IDType columnIDType=IDType.getIDType(page.columnIDCombo.getItem(page.columnIDCombo.getSelectionIndex()));
    columnIDSpecification.setIdType(columnIDType.getTypeName());
    if (columnIDType.getIDCategory().getCategoryName().equals(""String_Node_Str""))     columnIDSpecification.setIDTypeGene(true);
    columnIDSpecification.setIdCategory(columnIDType.getIDCategory().getCategoryName());
    columnIDSpecification.setIdTypeParsingRules(columnIDTypeParsingRules);
    dataSetDescription.setColumnIDSpecification(columnIDSpecification);
  }
  dataSetDescription.setRowIDSpecification(rowIDSpecification);
  dataSetDescription.setDataSetName(page.label.getText());
  dataSetDescription.setDataSourcePath(page.loadFile.getFileName());
  List<List<String>> matrix=parser.getDataMatrix();
  List<List<String>> filteredMatrix=new ArrayList<>(matrix.size());
  List<Integer> selectedColumns=page.previewTable.getSelectedColumns();
  DataImportWizard wizard=page.getWizard();
  List<String> columnOfRowIDs=new ArrayList<>(matrix.size() - dataSetDescription.getNumberOfHeaderLines());
  for (int i=0; i < matrix.size(); i++) {
    boolean isRowOfColumnID=false;
    if (i == dataSetDescription.getRowOfColumnIDs()) {
      isRowOfColumnID=true;
    }
 else     if (i < dataSetDescription.getNumberOfHeaderLines())     continue;
    List<String> row=matrix.get(i);
    List<String> filteredRow=filterRowByIndices(row,selectedColumns);
    if (isRowOfColumnID) {
      List<String> convertedFilteredRow=new ArrayList<>(filteredRow.size());
      for (      String id : filteredRow) {
        convertedFilteredRow.add(ATextParser.convertID(id,columnIDTypeParsingRules));
      }
      wizard.setFilteredRowOfColumnIDs(convertedFilteredRow);
    }
 else {
      filteredMatrix.add(filteredRow);
      columnOfRowIDs.add(ATextParser.convertID(row.get(dataSetDescription.getColumnOfRowIds()),rowIDTypeParsingRules));
    }
  }
  wizard.setFilteredDataMatrix(filteredMatrix);
  wizard.setSelectedColumns(selectedColumns);
  wizard.setColumnOfRowIDs(columnOfRowIDs);
  if (page.inhomogeneousDatasetButton.getSelection()) {
    if (datasetChanged || dataSetDescription.getDataDescription() != null) {
      page.getWizard().getInhomogeneousDataPropertiesPage().setInitColumnDescriptions(true);
      dataSetDescription.setDataDescription(null);
    }
  }
  datasetChanged=false;
}","/** 
 * Reads the min and max values (if set) from the dialog
 */
public void fillDataSetDescription(){
  IDSpecification rowIDSpecification=new IDSpecification();
  IDType rowIDType=IDType.getIDType(page.rowIDCombo.getItem(page.rowIDCombo.getSelectionIndex()));
  rowIDSpecification.setIdType(rowIDType.getTypeName());
  if (rowIDType.getIDCategory().getCategoryName().equals(""String_Node_Str""))   rowIDSpecification.setIDTypeGene(true);
  rowIDSpecification.setIdCategory(rowIDType.getIDCategory().getCategoryName());
  rowIDSpecification.setIdTypeParsingRules(rowIDTypeParsingRules);
  if (!page.inhomogeneousDatasetButton.getSelection()) {
    IDSpecification columnIDSpecification=new IDSpecification();
    IDType columnIDType=IDType.getIDType(page.columnIDCombo.getItem(page.columnIDCombo.getSelectionIndex()));
    columnIDSpecification.setIdType(columnIDType.getTypeName());
    if (columnIDType.getIDCategory().getCategoryName().equals(""String_Node_Str""))     columnIDSpecification.setIDTypeGene(true);
    columnIDSpecification.setIdCategory(columnIDType.getIDCategory().getCategoryName());
    columnIDSpecification.setIdTypeParsingRules(columnIDTypeParsingRules);
    dataSetDescription.setColumnIDSpecification(columnIDSpecification);
  }
 else {
    dataSetDescription.setColumnIDSpecification(null);
  }
  dataSetDescription.setRowIDSpecification(rowIDSpecification);
  dataSetDescription.setDataSetName(page.label.getText());
  dataSetDescription.setDataSourcePath(page.loadFile.getFileName());
  List<List<String>> matrix=parser.getDataMatrix();
  List<List<String>> filteredMatrix=new ArrayList<>(matrix.size());
  List<Integer> selectedColumns=page.previewTable.getSelectedColumns();
  DataImportWizard wizard=page.getWizard();
  List<String> columnOfRowIDs=new ArrayList<>(matrix.size() - dataSetDescription.getNumberOfHeaderLines());
  for (int i=0; i < matrix.size(); i++) {
    boolean isRowOfColumnID=false;
    if (i == dataSetDescription.getRowOfColumnIDs()) {
      isRowOfColumnID=true;
    }
 else     if (i < dataSetDescription.getNumberOfHeaderLines())     continue;
    List<String> row=matrix.get(i);
    List<String> filteredRow=filterRowByIndices(row,selectedColumns);
    if (isRowOfColumnID) {
      List<String> convertedFilteredRow=new ArrayList<>(filteredRow.size());
      for (      String id : filteredRow) {
        convertedFilteredRow.add(ATextParser.convertID(id,columnIDTypeParsingRules));
      }
      wizard.setFilteredRowOfColumnIDs(convertedFilteredRow);
    }
 else {
      filteredMatrix.add(filteredRow);
      columnOfRowIDs.add(ATextParser.convertID(row.get(dataSetDescription.getColumnOfRowIds()),rowIDTypeParsingRules));
    }
  }
  wizard.setFilteredDataMatrix(filteredMatrix);
  wizard.setSelectedColumns(selectedColumns);
  wizard.setColumnOfRowIDs(columnOfRowIDs);
  if (page.inhomogeneousDatasetButton.getSelection()) {
    if (datasetChanged || dataSetDescription.getDataDescription() != null) {
      page.getWizard().getInhomogeneousDataPropertiesPage().setInitColumnDescriptions(true);
      dataSetDescription.setDataDescription(null);
    }
  }
  datasetChanged=false;
}",0.989223097957214
56969,"@Override public GLElement createSummary(boolean interactive){
  return null;
}","@Override public GLElement createSummary(boolean interactive){
  return new GLElement();
}",0.9112426035502958
56970,"@Override public ValueElement createValue(){
  return null;
}","@Override public ValueElement createValue(){
  return new ValueElement();
}",0.8823529411764706
56971,"private void invalidVisibleScores(){
  Deque<ARankColumnModel> cols=new LinkedList<>(table.getColumns());
  while (!cols.isEmpty()) {
    ARankColumnModel model=cols.pollFirst();
    if (model instanceof ScoreRankColumnModel) {
      ((ScoreRankColumnModel)model).dirty();
    }
 else     if (model instanceof StackedRankColumnModel) {
      cols.addAll(((StackedRankColumnModel)model).getChildren());
    }
 else     if (model instanceof MaxCompositeRankColumnModel) {
      MaxCompositeRankColumnModel max=(MaxCompositeRankColumnModel)model;
      cols.addAll(max.getChildren());
    }
  }
}","private void invalidVisibleScores(){
  Deque<ARankColumnModel> cols=new LinkedList<>(table.getColumns());
  while (!cols.isEmpty()) {
    ARankColumnModel model=cols.pollFirst();
    if (model instanceof ScoreRankColumnModel) {
      ((ScoreRankColumnModel)model).dirty();
    }
 else     if (model instanceof StackedRankColumnModel) {
      cols.addAll(((StackedRankColumnModel)model).getChildren());
    }
 else     if (model instanceof MaxRankColumnModel) {
      MaxRankColumnModel max=(MaxRankColumnModel)model;
      cols.addAll(max.getChildren());
    }
  }
}",0.9767040552200172
56972,"/** 
 * @return
 */
private Collection<IScore> getVisibleScores(AScoreRow row){
  Collection<IScore> r=new ArrayList<>();
  Deque<ARankColumnModel> cols=new LinkedList<>(table.getColumns());
  while (!cols.isEmpty()) {
    ARankColumnModel model=cols.pollFirst();
    if (model instanceof ScoreRankColumnModel) {
      r.add(((ScoreRankColumnModel)model).getScore());
    }
 else     if (model instanceof StackedRankColumnModel) {
      cols.addAll(((StackedRankColumnModel)model).getChildren());
    }
 else     if (model instanceof MaxCompositeRankColumnModel) {
      MaxCompositeRankColumnModel max=(MaxCompositeRankColumnModel)model;
      if (row != null) {
        int repr=max.getSplittedValue(row).getRepr();
        cols.add(max.get(repr));
      }
 else {
        cols.addAll(max.getChildren());
      }
    }
  }
  for (Iterator<IScore> it=r.iterator(); it.hasNext(); ) {
    if (!it.next().supports(mode))     it.remove();
  }
  return r;
}","/** 
 * @return
 */
private Collection<IScore> getVisibleScores(AScoreRow row){
  Collection<IScore> r=new ArrayList<>();
  Deque<ARankColumnModel> cols=new LinkedList<>(table.getColumns());
  while (!cols.isEmpty()) {
    ARankColumnModel model=cols.pollFirst();
    if (model instanceof ScoreRankColumnModel) {
      r.add(((ScoreRankColumnModel)model).getScore());
    }
 else     if (model instanceof StackedRankColumnModel) {
      cols.addAll(((StackedRankColumnModel)model).getChildren());
    }
 else     if (model instanceof MaxRankColumnModel) {
      MaxRankColumnModel max=(MaxRankColumnModel)model;
      if (row != null) {
        int repr=max.getSplittedValue(row).getRepr();
        cols.add(max.get(repr));
      }
 else {
        cols.addAll(max.getChildren());
      }
    }
  }
  for (Iterator<IScore> it=r.iterator(); it.hasNext(); ) {
    if (!it.next().supports(mode))     it.remove();
  }
  return r;
}",0.9856306546035124
56973,"@ListenTo private void onRemoveLeadingScoreColumns(RemoveLeadingScoreColumnsEvent event){
  List<ARankColumnModel> columns=this.table.getColumns();
  boolean hasOne=false;
  Collection<ARankColumnModel> toremove=new ArrayList<>();
  for (  ARankColumnModel col : columns) {
    if (col instanceof ScoreRankColumnModel || col instanceof StackedRankColumnModel || col instanceof MaxCompositeRankColumnModel) {
      hasOne=true;
      toremove.add(col);
    }
 else     if (hasOne)     break;
  }
  for (  ARankColumnModel col : toremove) {
    table.remove(col);
  }
}","@ListenTo private void onRemoveLeadingScoreColumns(RemoveLeadingScoreColumnsEvent event){
  List<ARankColumnModel> columns=this.table.getColumns();
  boolean hasOne=false;
  Collection<ARankColumnModel> toremove=new ArrayList<>();
  for (  ARankColumnModel col : columns) {
    if (col instanceof ScoreRankColumnModel || col instanceof StackedRankColumnModel || col instanceof MaxRankColumnModel) {
      hasOne=true;
      toremove.add(col);
    }
 else     if (hasOne)     break;
  }
  for (  ARankColumnModel col : toremove) {
    table.remove(col);
  }
}",0.992
56974,"private void buildTable(MatrixBasedBodyDataProvider bodyDataProvider,final ColumnHeaderDataProvider columnDataProvider,LineNumberRowHeaderDataProvider rowDataProvider){
  if (table != null) {
    this.table.dispose();
    this.table=null;
  }
  final DataLayer bodyDataLayer=new DataLayer(bodyDataProvider);
  SelectionLayer selectionLayer=new SelectionLayer(bodyDataLayer);
  ViewportLayer bodyLayer=new ViewportLayer(selectionLayer);
  final DataLayer columnDataLayer=new DataLayer(columnDataProvider,120,25);
  ColumnHeaderLayer columnHeaderLayer=new ColumnHeaderLayer(columnDataLayer,bodyLayer,selectionLayer);
  DataLayer rowDataLayer=new DataLayer(rowDataProvider,50,20);
  RowHeaderLayer rowHeaderLayer=new RowHeaderLayer(rowDataLayer,bodyLayer,selectionLayer);
  DefaultCornerDataProvider cornerDataProvider=new DefaultCornerDataProvider(columnDataProvider,rowDataProvider);
  CornerLayer cornerLayer=new CornerLayer(new DataLayer(cornerDataProvider),rowHeaderLayer,columnHeaderLayer);
  GridLayer gridLayer=new GridLayer(bodyLayer,columnHeaderLayer,rowHeaderLayer,cornerLayer);
  table=new NatTable(parent,gridLayer,false);
  GridData gridData=new GridData(SWT.FILL,SWT.FILL,true,true,2,2);
  gridData.heightHint=400;
  gridData.widthHint=800;
  table.setLayoutData(gridData);
  IConfigLabelAccumulator cellLabelAccumulator=new IConfigLabelAccumulator(){
    @Override public void accumulateConfigLabels(    LabelStack configLabels,    int columnPosition,    int rowPosition){
      if (columnPosition == idColumnIndex || rowPosition == idRowIndex) {
        configLabels.addLabel(ID_CELL);
      }
      if (rowPosition < numberOfHeaderRows) {
        configLabels.addLabel(HEADER_LINE_CELL);
      }
      if (columnPosition == idColumnIndex && rowPosition >= numberOfHeaderRows && rowPosition != idRowIndex) {
        configLabels.addLabel(ROW_ID);
      }
      if (rowPosition == idRowIndex && columnPosition != idColumnIndex) {
        configLabels.addLabel(COLUMN_ID);
      }
      if ((Boolean)columnDataProvider.getDataValue(columnPosition,0) == false) {
        configLabels.addLabel(DISABLED_CELL);
      }
    }
  }
;
  bodyDataLayer.setConfigLabelAccumulator(cellLabelAccumulator);
  table.addConfiguration(new DefaultNatTableStyleConfiguration());
  if (columnIDConverter == null)   columnIDConverter=new RegExIDConverter(null);
  if (rowIDConverter == null)   rowIDConverter=new RegExIDConverter(null);
  table.addConfiguration(new AbstractRegistryConfiguration(){
    @Override public void configureRegistry(    IConfigRegistry configRegistry){
      Style cellStyle=new Style();
      cellStyle.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,GUIHelper.COLOR_GREEN);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_STYLE,cellStyle,DisplayMode.NORMAL,ID_CELL);
      cellStyle=new Style();
      cellStyle.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,GUIHelper.COLOR_DARK_GRAY);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_STYLE,cellStyle,DisplayMode.NORMAL,HEADER_LINE_CELL);
      configRegistry.registerConfigAttribute(CellConfigAttributes.DISPLAY_CONVERTER,columnIDConverter,DisplayMode.NORMAL,COLUMN_ID);
      configRegistry.registerConfigAttribute(CellConfigAttributes.DISPLAY_CONVERTER,rowIDConverter,DisplayMode.NORMAL,ROW_ID);
      cellStyle=new Style();
      cellStyle.setAttributeValue(CellStyleAttributes.FOREGROUND_COLOR,GUIHelper.COLOR_WIDGET_NORMAL_SHADOW);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_STYLE,cellStyle,DisplayMode.NORMAL,DISABLED_CELL);
    }
  }
);
  final ColumnHeaderCheckBoxPainter columnHeaderCheckBoxPainter=new ColumnHeaderCheckBoxPainter(columnDataLayer);
  final ICellPainter columnHeaderPainter=new BeveledBorderDecorator(new CellPainterDecorator(new ColumnNumberCellPainter(),CellEdgeEnum.LEFT,columnHeaderCheckBoxPainter));
  table.addConfiguration(new AbstractRegistryConfiguration(){
    @Override public void configureRegistry(    IConfigRegistry configRegistry){
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,columnHeaderPainter,DisplayMode.NORMAL,GridRegion.COLUMN_HEADER);
    }
    @Override public void configureUiBindings(    UiBindingRegistry uiBindingRegistry){
      uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.COLUMN_HEADER,MouseEventMatcher.LEFT_BUTTON,columnHeaderCheckBoxPainter),new ColumnSelectionAction(columnHeaderCheckBoxPainter,columnDataLayer));
    }
  }
);
  table.configure();
}","private void buildTable(MatrixBasedBodyDataProvider bodyDataProvider,final ColumnHeaderDataProvider columnDataProvider,LineNumberRowHeaderDataProvider rowDataProvider){
  if (table != null) {
    this.table.dispose();
    this.table=null;
  }
  final DataLayer bodyDataLayer=new DataLayer(bodyDataProvider);
  SelectionLayer selectionLayer=new SelectionLayer(bodyDataLayer);
  ViewportLayer bodyLayer=new ViewportLayer(selectionLayer);
  final DataLayer columnDataLayer=new DataLayer(columnDataProvider,120,25);
  ColumnHeaderLayer columnHeaderLayer=new ColumnHeaderLayer(columnDataLayer,bodyLayer,selectionLayer);
  DataLayer rowDataLayer=new DataLayer(rowDataProvider,50,20);
  RowHeaderLayer rowHeaderLayer=new RowHeaderLayer(rowDataLayer,bodyLayer,selectionLayer);
  DefaultCornerDataProvider cornerDataProvider=new DefaultCornerDataProvider(columnDataProvider,rowDataProvider);
  CornerLayer cornerLayer=new CornerLayer(new DataLayer(cornerDataProvider),rowHeaderLayer,columnHeaderLayer);
  GridLayer gridLayer=new GridLayer(bodyLayer,columnHeaderLayer,rowHeaderLayer,cornerLayer);
  table=new NatTable(parent,gridLayer,false);
  GridData gridData=new GridData(SWT.FILL,SWT.FILL,true,true,2,1);
  table.setLayoutData(gridData);
  IConfigLabelAccumulator cellLabelAccumulator=new IConfigLabelAccumulator(){
    @Override public void accumulateConfigLabels(    LabelStack configLabels,    int columnPosition,    int rowPosition){
      if (columnPosition == idColumnIndex || rowPosition == idRowIndex) {
        configLabels.addLabel(ID_CELL);
      }
      if (rowPosition < numberOfHeaderRows) {
        configLabels.addLabel(HEADER_LINE_CELL);
      }
      if (columnPosition == idColumnIndex && rowPosition >= numberOfHeaderRows && rowPosition != idRowIndex) {
        configLabels.addLabel(ROW_ID);
      }
      if (rowPosition == idRowIndex && columnPosition != idColumnIndex) {
        configLabels.addLabel(COLUMN_ID);
      }
      if ((Boolean)columnDataProvider.getDataValue(columnPosition,0) == false) {
        configLabels.addLabel(DISABLED_CELL);
      }
    }
  }
;
  bodyDataLayer.setConfigLabelAccumulator(cellLabelAccumulator);
  table.addConfiguration(new DefaultNatTableStyleConfiguration());
  if (columnIDConverter == null)   columnIDConverter=new RegExIDConverter(null);
  if (rowIDConverter == null)   rowIDConverter=new RegExIDConverter(null);
  table.addConfiguration(new AbstractRegistryConfiguration(){
    @Override public void configureRegistry(    IConfigRegistry configRegistry){
      Style cellStyle=new Style();
      cellStyle.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,GUIHelper.COLOR_GREEN);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_STYLE,cellStyle,DisplayMode.NORMAL,ID_CELL);
      cellStyle=new Style();
      cellStyle.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,GUIHelper.COLOR_DARK_GRAY);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_STYLE,cellStyle,DisplayMode.NORMAL,HEADER_LINE_CELL);
      configRegistry.registerConfigAttribute(CellConfigAttributes.DISPLAY_CONVERTER,columnIDConverter,DisplayMode.NORMAL,COLUMN_ID);
      configRegistry.registerConfigAttribute(CellConfigAttributes.DISPLAY_CONVERTER,rowIDConverter,DisplayMode.NORMAL,ROW_ID);
      cellStyle=new Style();
      cellStyle.setAttributeValue(CellStyleAttributes.FOREGROUND_COLOR,GUIHelper.COLOR_WIDGET_NORMAL_SHADOW);
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_STYLE,cellStyle,DisplayMode.NORMAL,DISABLED_CELL);
    }
  }
);
  final ColumnHeaderCheckBoxPainter columnHeaderCheckBoxPainter=new ColumnHeaderCheckBoxPainter(columnDataLayer);
  final ICellPainter columnHeaderPainter=new BeveledBorderDecorator(new CellPainterDecorator(new ColumnNumberCellPainter(),CellEdgeEnum.LEFT,columnHeaderCheckBoxPainter));
  table.addConfiguration(new AbstractRegistryConfiguration(){
    @Override public void configureRegistry(    IConfigRegistry configRegistry){
      configRegistry.registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,columnHeaderPainter,DisplayMode.NORMAL,GridRegion.COLUMN_HEADER);
    }
    @Override public void configureUiBindings(    UiBindingRegistry uiBindingRegistry){
      uiBindingRegistry.registerFirstSingleClickBinding(new CellPainterMouseEventMatcher(GridRegion.COLUMN_HEADER,MouseEventMatcher.LEFT_BUTTON,columnHeaderCheckBoxPainter),new ColumnSelectionAction(columnHeaderCheckBoxPainter,columnDataLayer));
    }
  }
);
  table.configure();
}",0.9937037446150448
56975,"public PreviewTableWidget(Composite parent,IntegerCallback onColumnSelection){
  super(parent);
  this.onColumnSelection=onColumnSelection;
  List<List<String>> emptyMatrix=createEmptyDataMatrix(15,10);
  bodyDataProvider=new MatrixBasedBodyDataProvider(emptyMatrix,emptyMatrix.size());
  buildTable(bodyDataProvider,new ColumnHeaderDataProvider(10),new LineNumberRowHeaderDataProvider(emptyMatrix.size()));
}","public PreviewTableWidget(Composite parent,IntegerCallback onColumnSelection){
  super(parent);
  this.onColumnSelection=onColumnSelection;
  List<List<String>> emptyMatrix=createEmptyDataMatrix(15,10);
  bodyDataProvider=new MatrixBasedBodyDataProvider(emptyMatrix,10);
  columnHeaderDataProvider=new ColumnHeaderDataProvider(10);
  rowHeaderDataProvider=new LineNumberRowHeaderDataProvider(emptyMatrix.size());
  buildTable(bodyDataProvider,columnHeaderDataProvider,rowHeaderDataProvider);
}",0.7139689578713969
56976,"/** 
 * Creates the   {@link #previewTable} according to the {@link #dataMatrix}.
 */
@Override public void createTableFromMatrix(List<List<String>> dataMatrix,int numColumns){
  if (dataMatrix == null || dataMatrix.isEmpty())   return;
  columnSelectionStatus=new ArrayList<>(numColumns);
  for (int i=0; i < numColumns; i++) {
    columnSelectionStatus.add(true);
  }
  bodyDataProvider=new MatrixBasedBodyDataProvider(dataMatrix,numColumns);
  buildTable(bodyDataProvider,new ColumnHeaderDataProvider(numColumns),new LineNumberRowHeaderDataProvider(dataMatrix.size()));
}","/** 
 * Creates the   {@link #previewTable} according to the {@link #dataMatrix}.
 */
@Override public void createTableFromMatrix(List<List<String>> dataMatrix,int numColumns){
  if (dataMatrix == null || dataMatrix.isEmpty())   return;
  columnSelectionStatus=new ArrayList<>(numColumns);
  for (int i=0; i < numColumns; i++) {
    columnSelectionStatus.add(true);
  }
  bodyDataProvider.setDataMatrix(dataMatrix);
  bodyDataProvider.setNumColumns(numColumns);
  columnHeaderDataProvider.setNumColumns(numColumns);
  rowHeaderDataProvider.setNumRows(dataMatrix.size());
  table.refresh();
}",0.7914163090128755
56977,"@Override public void pageChanged(PageChangedEvent event){
  if (isActive && event.getSelectedPage() == getNextPage()) {
    fillDataSetDescription();
    getWizard().addVisitedPage(this);
  }
  if (event.getSelectedPage() == this) {
    isActive=true;
    pageActivated();
  }
 else {
    isActive=false;
  }
}","@Override public void pageChanged(PageChangedEvent event){
  if (isActive && event.getSelectedPage() == getNextPage()) {
    fillDataSetDescription();
    getWizard().addVisitedPage(this);
  }
  if (event.getSelectedPage() == this) {
    isActive=true;
    pageActivated();
    Point currentSize=parent.getSize();
    Point computedSize=parent.computeSize(SWT.DEFAULT,SWT.DEFAULT);
    Point minSize=null;
    if (currentSize.x >= computedSize.x && currentSize.y >= computedSize.y) {
      minSize=currentSize;
    }
 else     if (currentSize.x <= computedSize.x && currentSize.y <= computedSize.y) {
      minSize=computedSize;
    }
 else     if (currentSize.x >= computedSize.x && currentSize.y <= computedSize.y) {
      minSize=parent.computeSize(currentSize.x,SWT.DEFAULT);
    }
 else {
      minSize=parent.computeSize(SWT.DEFAULT,currentSize.y);
    }
    scrolledComposite.setMinSize(minSize);
  }
 else {
    isActive=false;
  }
}",0.4936102236421725
56978,"@Override protected Control createDialogArea(Composite parent){
  parentComposite=new Composite(parent,SWT.NONE);
  parentComposite.setLayout(new GridLayout(1,false));
  parentComposite.setLayoutData(new GridData(800,600));
  Group group=new Group(parentComposite,SWT.SHADOW_ETCHED_IN);
  group.setText(""String_Node_Str"");
  group.setLayout(new GridLayout(1,true));
  numericalDataButton=new Button(group,SWT.RADIO);
  numericalDataButton.setText(""String_Node_Str"");
  numericalDataButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      showNumericalDataWidgets();
    }
  }
);
  categoricalDataButton=new Button(group,SWT.RADIO);
  categoricalDataButton.setText(""String_Node_Str"");
  categoricalDataButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      showCategoricalDataWidgets();
    }
  }
);
  if (numericalProperties != null) {
    numericalDataButton.setSelection(true);
    showNumericalDataWidgets();
  }
 else {
    categoricalDataButton.setSelection(true);
    showCategoricalDataWidgets();
  }
  return parent;
}","@Override protected Control createDialogArea(Composite parent){
  parentComposite=new Composite(parent,SWT.NONE);
  parentComposite.setLayout(new GridLayout(1,false));
  parentComposite.setLayoutData(new GridData(800,800));
  Group group=new Group(parentComposite,SWT.SHADOW_ETCHED_IN);
  group.setText(""String_Node_Str"");
  group.setLayout(new GridLayout(1,true));
  numericalDataButton=new Button(group,SWT.RADIO);
  numericalDataButton.setText(""String_Node_Str"");
  numericalDataButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      showNumericalDataWidgets();
    }
  }
);
  categoricalDataButton=new Button(group,SWT.RADIO);
  categoricalDataButton.setText(""String_Node_Str"");
  categoricalDataButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      showCategoricalDataWidgets();
    }
  }
);
  if (numericalProperties != null) {
    numericalDataButton.setSelection(true);
    showNumericalDataWidgets();
  }
 else {
    categoricalDataButton.setSelection(true);
    showCategoricalDataWidgets();
  }
  return parent;
}",0.999137187230371
56979,"/** 
 * adds a snapshot of the given column including a separator and a rank column
 * @param model
 */
public void addSnapshot(ARankColumnModel model){
  add(new OrderColumn());
  for (  ARankColumnModel col : config.createAutoSnapshotColumns(this,model))   add(col);
  if (model != null)   add(model.clone());
}","/** 
 * adds a snapshot of the given column including a separator and a rank column
 * @param model
 */
public void addSnapshot(ARankColumnModel model){
  add(new OrderColumn());
  for (  ARankColumnModel col : config.createAutoSnapshotColumns(this,model))   add(col);
  if (model != null) {
    ARankColumnModel clone=model.clone();
    add(clone);
    if (clone instanceof IRankableColumnMixin)     ((IRankableColumnMixin)clone).orderByMe();
  }
}",0.8031496062992126
56980,"@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  IGLLayoutElement hist=children.get(HIST);
  final boolean smallHeader=isSmallHeader(h);
  if (smallHeader)   hist.hide();
 else   hist.setBounds(1,hasTitle ? LABEL_HEIGHT : 0,w - 2,h - (hasTitle ? LABEL_HEIGHT : 0));
  if (config.isInteractive()) {
    IGLLayoutElement weight=children.get(DRAG_WEIGHT);
    weight.setBounds(w,hasTitle && !smallHeader ? LABEL_HEIGHT : 0,(isHovered && config.canChangeWeights()) ? 8 : 0,h - (hasTitle && !smallHeader ? LABEL_HEIGHT : 0));
{
      IGLLayoutElement buttons=children.get(BUTTONS);
      float minWidth=(buttons.asElement() instanceof ButtonBar) ? ((ButtonBar)buttons.asElement()).getMinWidth() : 0;
      boolean showButtonBar=isHovered && !isWeightDragging;
      float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
        yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
      break;
case OVER_LABEL:
    yb=0;
  break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=showButtonBar ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
float hb=showButtonBar ? RenderStyle.BUTTON_WIDTH : 0;
if ((w - 4) < minWidth) {
float missing=minWidth - (w - 4);
buttons.setBounds(-missing * 0.5f,yb,minWidth,hb);
}
 else {
buttons.setBounds(2,yb,w - 4,hb);
}
}
IGLLayoutElement uncollapse=children.get(UNCOLLAPSE);
uncollapse.setBounds((w - RenderStyle.BUTTON_WIDTH) * .5f,2,RenderStyle.BUTTON_WIDTH,isHovered ? RenderStyle.BUTTON_WIDTH : 0);
for (IGLLayoutElement r : children.subList(FIRST_CUSTOM,children.size())) r.setBounds(defaultValue(r.getSetX(),0),defaultValue(r.getSetY(),h),defaultValue(r.getSetWidth(),w),defaultValue(r.getSetHeight(),HIST_HEIGHT));
}
}","@Override public void doLayout(List<? extends IGLLayoutElement> children,float w,float h){
  IGLLayoutElement hist=children.get(HIST);
  final boolean smallHeader=isSmallHeader(h);
  if (smallHeader)   hist.hide();
 else   hist.setBounds(1,hasTitle ? LABEL_HEIGHT : 0,w - 2,h - (hasTitle ? LABEL_HEIGHT : 0));
  if (config.isInteractive()) {
    IGLLayoutElement weight=children.get(DRAG_WEIGHT);
    weight.setBounds(w,hasTitle && !smallHeader ? LABEL_HEIGHT : 0,(isHovered && config.canChangeWeights()) ? 8 : 0,h - (hasTitle && !smallHeader ? LABEL_HEIGHT : 0));
{
      IGLLayoutElement buttons=children.get(BUTTONS);
      float minWidth=(buttons.asElement() instanceof ButtonBar) ? ((ButtonBar)buttons.asElement()).getMinWidth() : 0;
      boolean showButtonBar=isHovered && !isWeightDragging;
      float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
        yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
      break;
case OVER_LABEL:
    yb=0;
  break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=showButtonBar ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
float hb=showButtonBar ? RenderStyle.BUTTON_WIDTH : 0;
if ((w - 4) < minWidth) {
float missing=minWidth - (w - 4);
buttons.setBounds(-missing * 0.5f,yb,minWidth,hb);
}
 else {
buttons.setBounds(2,yb,w - 4,hb);
}
}
{
IGLLayoutElement uncollapse=children.get(UNCOLLAPSE);
float yb=0;
switch (config.getButtonBarPosition()) {
case AT_THE_BOTTOM:
yb=isHovered ? (h - 2 - RenderStyle.BUTTON_WIDTH) : h;
break;
case OVER_LABEL:
yb=0;
break;
case UNDER_LABEL:
yb=LABEL_HEIGHT;
break;
case ABOVE_LABEL:
yb=isHovered ? -RenderStyle.BUTTON_WIDTH : 0;
break;
case BELOW_HIST:
yb=isHovered ? h : h;
break;
}
uncollapse.setBounds((w - RenderStyle.BUTTON_WIDTH) * .5f,yb,RenderStyle.BUTTON_WIDTH,isHovered ? RenderStyle.BUTTON_WIDTH : 0);
}
for (IGLLayoutElement r : children.subList(FIRST_CUSTOM,children.size())) r.setBounds(defaultValue(r.getSetX(),0),defaultValue(r.getSetY(),h),defaultValue(r.getSetWidth(),w),defaultValue(r.getSetHeight(),HIST_HEIGHT));
}
}",0.898632963631674
56981,"protected void setFilter(Collection<CATEGORY_TYPE> filter,boolean isGlobalFilter){
  invalidAllFilter();
  Set<CATEGORY_TYPE> bak=new HashSet<>(this.selection);
  this.selection.clear();
  this.selection.addAll(filter);
  if (Sets.difference(bak,this.selection).isEmpty()) {
    setGlobalFilter(isGlobalFilter);
  }
 else {
    this.isGlobalFilter=isGlobalFilter;
    propertySupport.firePropertyChange(PROP_FILTER,bak,this.selection);
  }
}","protected void setFilter(Collection<CATEGORY_TYPE> filter,boolean isGlobalFilter){
  invalidAllFilter();
  Set<CATEGORY_TYPE> bak=new HashSet<>(this.selection);
  this.selection.clear();
  this.selection.addAll(filter);
  if (this.selection.equals(bak)) {
    setGlobalFilter(isGlobalFilter);
  }
 else {
    this.isGlobalFilter=isGlobalFilter;
    propertySupport.firePropertyChange(PROP_FILTER,bak,this.selection);
  }
}",0.929316338354577
56982,"protected void setFilter(Collection<CATEGORY_TYPE> filter,boolean isGlobalFilter){
  invalidAllFilter();
  Set<CATEGORY_TYPE> bak=new HashSet<>(this.selection);
  this.selection.clear();
  this.selection.addAll(filter);
  if (Sets.difference(bak,this.selection).isEmpty()) {
    setGlobalFilter(isGlobalFilter);
  }
 else {
    this.isGlobalFilter=isGlobalFilter;
    propertySupport.firePropertyChange(PROP_FILTER,bak,this.selection);
  }
}","protected void setFilter(Collection<CATEGORY_TYPE> filter,boolean isGlobalFilter){
  invalidAllFilter();
  Set<CATEGORY_TYPE> bak=new HashSet<>(this.selection);
  this.selection.clear();
  this.selection.addAll(filter);
  if (this.selection.equals(bak)) {
    setGlobalFilter(isGlobalFilter);
  }
 else {
    this.isGlobalFilter=isGlobalFilter;
    propertySupport.firePropertyChange(PROP_FILTER,bak,this.selection);
  }
}",0.929316338354577
56983,"/** 
 */
public NumericalDataPropertiesWidget(Composite parent,Listener listener){
  this.parent=parent;
  createScalingGroup(parent);
  createClippingGroup(parent,listener);
  createDataCenterGroup(parent,listener);
}","/** 
 */
public NumericalDataPropertiesWidget(Composite parent,Listener listener){
  this.parent=parent;
  createDataTypeGroup(parent);
  createScalingGroup(parent);
  createClippingGroup(parent,listener);
  createDataCenterGroup(parent,listener);
}",0.9336188436830836
56984,"private void createScalingGroup(Composite parent){
  scalingGroup=new Group(parent,SWT.SHADOW_ETCHED_IN);
  scalingGroup.setText(""String_Node_Str"");
  scalingGroup.setLayout(new GridLayout(2,false));
  scalingGroup.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  Label scalingExplanationLabel=new Label(scalingGroup,SWT.WRAP);
  scalingExplanationLabel.setText(""String_Node_Str"");
  GridData gridData=new GridData(SWT.FILL,SWT.FILL,true,true,2,1);
  gridData.widthHint=200;
  scalingExplanationLabel.setLayoutData(gridData);
  Label scalingMethodLabel=new Label(scalingGroup,SWT.NONE);
  scalingMethodLabel.setText(""String_Node_Str"");
  scalingCombo=new Combo(scalingGroup,SWT.DROP_DOWN | SWT.READ_ONLY);
  gridData=new GridData();
  gridData.widthHint=100;
  scalingCombo.setLayoutData(gridData);
  String[] scalingOptions={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  scalingCombo.setItems(scalingOptions);
  scalingCombo.setEnabled(true);
  scalingCombo.select(0);
}","private void createScalingGroup(Composite parent){
  scalingGroup=new Group(parent,SWT.SHADOW_ETCHED_IN);
  scalingGroup.setText(""String_Node_Str"");
  scalingGroup.setLayout(new GridLayout(2,false));
  scalingGroup.setLayoutData(new GridData(SWT.FILL,SWT.TOP,true,false));
  Label scalingExplanationLabel=new Label(scalingGroup,SWT.WRAP);
  scalingExplanationLabel.setText(""String_Node_Str"");
  GridData gridData=new GridData(SWT.FILL,SWT.FILL,true,true,2,1);
  gridData.widthHint=200;
  scalingExplanationLabel.setLayoutData(gridData);
  Label scalingMethodLabel=new Label(scalingGroup,SWT.NONE);
  scalingMethodLabel.setText(""String_Node_Str"");
  scalingCombo=new Combo(scalingGroup,SWT.DROP_DOWN | SWT.READ_ONLY);
  gridData=new GridData();
  gridData.widthHint=120;
  scalingCombo.setLayoutData(gridData);
  String[] scalingOptions={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  scalingCombo.setItems(scalingOptions);
  scalingCombo.setEnabled(true);
  scalingCombo.select(0);
}",0.9989939637826962
56985,"public void dispose(){
  dataCenterGroup.dispose();
  clippingGroup.dispose();
  scalingGroup.dispose();
}","public void dispose(){
  dataTypeGroup.dispose();
  dataCenterGroup.dispose();
  clippingGroup.dispose();
  scalingGroup.dispose();
}",0.8870292887029289
56986,"private void showCategoricalDataWidgets(){
  if (numericalDataPropertiesWidget != null) {
    numericalProperties=numericalDataPropertiesWidget.getNumericalProperties();
    numericalDataPropertiesWidget.dispose();
    parentComposite.layout(true);
    numericalDataPropertiesWidget=null;
  }
  if (categoricalDataPropertiesWidget == null) {
    categoricalDataPropertiesWidget=new CategoricalDataPropertiesWidget(parentComposite);
    if (categoricalClassDescription == null) {
      categoricalDataPropertiesWidget.updateCategories(datasetMatrix,columnIndex);
    }
 else {
      categoricalDataPropertiesWidget.updateCategories(datasetMatrix,columnIndex,categoricalClassDescription);
    }
    parentComposite.layout(true);
  }
}","private void showCategoricalDataWidgets(){
  if (numericalDataPropertiesWidget != null) {
    dataType=numericalDataPropertiesWidget.getDataType();
    numericalProperties=numericalDataPropertiesWidget.getNumericalProperties();
    numericalDataPropertiesWidget.dispose();
    parentComposite.layout(true);
    numericalDataPropertiesWidget=null;
  }
  if (categoricalDataPropertiesWidget == null) {
    categoricalDataPropertiesWidget=new CategoricalDataPropertiesWidget(parentComposite);
    if (categoricalClassDescription == null) {
      categoricalDataPropertiesWidget.updateCategories(datasetMatrix,columnIndex);
    }
 else {
      categoricalDataPropertiesWidget.updateCategories(datasetMatrix,columnIndex,categoricalClassDescription);
    }
    parentComposite.layout(true);
  }
}",0.961892247043364
56987,"private void showNumericalDataWidgets(){
  if (categoricalDataPropertiesWidget != null) {
    categoricalClassDescription=categoricalDataPropertiesWidget.getCategoricalClassDescription();
    categoricalDataPropertiesWidget.dispose();
    parentComposite.layout(true);
    categoricalDataPropertiesWidget=null;
  }
  if (numericalDataPropertiesWidget == null) {
    numericalDataButton.setSelection(true);
    numericalDataPropertiesWidget=new NumericalDataPropertiesWidget(parentComposite,this);
    if (numericalProperties != null) {
      numericalDataPropertiesWidget.updateNumericalProperties(numericalProperties);
    }
    parentComposite.layout(true);
  }
}","private void showNumericalDataWidgets(){
  if (categoricalDataPropertiesWidget != null) {
    categoricalClassDescription=categoricalDataPropertiesWidget.getCategoricalClassDescription();
    categoricalDataPropertiesWidget.dispose();
    parentComposite.layout(true);
    categoricalDataPropertiesWidget=null;
  }
  if (numericalDataPropertiesWidget == null) {
    numericalDataButton.setSelection(true);
    numericalDataPropertiesWidget=new NumericalDataPropertiesWidget(parentComposite,this);
    if (numericalProperties != null) {
      numericalDataPropertiesWidget.updateNumericalProperties(numericalProperties);
      numericalDataPropertiesWidget.setDataType(dataType);
    }
    parentComposite.layout(true);
  }
}",0.9575233981281498
56988,"@Override protected void okPressed(){
  if (numericalDataButton.getSelection()) {
    isNumericalData=true;
    numericalProperties=numericalDataPropertiesWidget.getNumericalProperties();
    categoricalClassDescription=null;
  }
 else {
    isNumericalData=false;
    categoricalClassDescription=categoricalDataPropertiesWidget.getCategoricalClassDescription();
    numericalProperties=null;
  }
  super.okPressed();
}","@Override protected void okPressed(){
  if (numericalDataButton.getSelection()) {
    isNumericalData=true;
    dataType=numericalDataPropertiesWidget.getDataType();
    numericalProperties=numericalDataPropertiesWidget.getNumericalProperties();
    categoricalClassDescription=null;
  }
 else {
    isNumericalData=false;
    categoricalClassDescription=categoricalDataPropertiesWidget.getCategoricalClassDescription();
    numericalProperties=null;
  }
  super.okPressed();
}",0.8928571428571429
56989,"@SuppressWarnings(""String_Node_Str"") private void defineColumnProperties(int columnIndex){
  List<ColumnDescription> columnDescriptions=dataSetDescription.getOrCreateParsingPattern();
  ColumnDescription columnDescription=columnDescriptions.get(columnIndex);
  DataImportWizard wizard=getWizard();
  ColumnDataPropertiesDialog dialog;
  if (columnDescription.getDataDescription().getCategoricalClassDescription() != null) {
    dialog=new ColumnDataPropertiesDialog(getShell(),(CategoricalClassDescription<String>)columnDescription.getDataDescription().getCategoricalClassDescription(),wizard.getFilteredDataMatrix(),columnIndex);
  }
 else {
    dialog=new ColumnDataPropertiesDialog(getShell(),columnDescription.getDataDescription().getNumericalProperties(),wizard.getFilteredDataMatrix(),columnIndex);
  }
  int status=dialog.open();
  if (status == Window.OK) {
    if (dialog.isNumericalData()) {
      NumericalProperties numericalProperties=dialog.getNumericalProperties();
      columnDescription.setDataDescription(new DataDescription(EDataClass.REAL_NUMBER,EDataType.FLOAT,numericalProperties));
    }
 else {
      CategoricalClassDescription<String> categoricalClassDescription=dialog.getCategoricalClassDescription();
      columnDescription.setDataDescription(new DataDescription(EDataClass.CATEGORICAL,EDataType.STRING,categoricalClassDescription));
    }
    table.update();
  }
}","@SuppressWarnings(""String_Node_Str"") private void defineColumnProperties(int columnIndex){
  List<ColumnDescription> columnDescriptions=dataSetDescription.getOrCreateParsingPattern();
  ColumnDescription columnDescription=columnDescriptions.get(columnIndex);
  DataImportWizard wizard=getWizard();
  ColumnDataPropertiesDialog dialog;
  if (columnDescription.getDataDescription().getCategoricalClassDescription() != null) {
    dialog=new ColumnDataPropertiesDialog(getShell(),(CategoricalClassDescription<String>)columnDescription.getDataDescription().getCategoricalClassDescription(),wizard.getFilteredDataMatrix(),columnIndex);
  }
 else {
    dialog=new ColumnDataPropertiesDialog(getShell(),columnDescription.getDataDescription().getNumericalProperties(),columnDescription.getDataDescription().getRawDataType(),wizard.getFilteredDataMatrix(),columnIndex);
  }
  int status=dialog.open();
  if (status == Window.OK) {
    if (dialog.isNumericalData()) {
      NumericalProperties numericalProperties=dialog.getNumericalProperties();
      EDataType dataType=dialog.getDataType();
      columnDescription.setDataDescription(new DataDescription(dataType == EDataType.FLOAT ? EDataClass.REAL_NUMBER : EDataClass.NATURAL_NUMBER,dataType,numericalProperties));
    }
 else {
      CategoricalClassDescription<String> categoricalClassDescription=dialog.getCategoricalClassDescription();
      columnDescription.setDataDescription(new DataDescription(EDataClass.CATEGORICAL,EDataType.STRING,categoricalClassDescription));
    }
    table.update();
  }
}",0.9422946367956552
56990,"@Override public void pageActivated(){
  if (initFromDataDescription) {
    numericalDataPropertiesWidget.updateNumericalProperties(dataSetDescription.getDataDescription().getNumericalProperties());
    initFromDataDescription=false;
  }
  getWizard().setChosenDataTypePage(this);
  getWizard().getContainer().updateButtons();
  dataTranspositionWidget.update();
}","@Override public void pageActivated(){
  if (initFromDataDescription) {
    numericalDataPropertiesWidget.updateNumericalProperties(dataSetDescription.getDataDescription().getNumericalProperties());
    numericalDataPropertiesWidget.setDataType(dataSetDescription.getDataDescription().getRawDataType());
    initFromDataDescription=false;
  }
  getWizard().setChosenDataTypePage(this);
  getWizard().getContainer().updateButtons();
  dataTranspositionWidget.update();
}",0.8739495798319328
56991,"@Override public void fillDataSetDescription(){
  DataDescription dataDescription=new DataDescription(EDataClass.REAL_NUMBER,EDataType.FLOAT,numericalDataPropertiesWidget.getNumericalProperties());
  dataSetDescription.setDataDescription(dataDescription);
  dataSetDescription.setTransposeMatrix(dataTranspositionWidget.isTransposition());
  ArrayList<ColumnDescription> inputPattern=new ArrayList<ColumnDescription>();
  DataImportWizard wizard=getWizard();
  for (  Integer selected : wizard.getSelectedColumns()) {
    int columnIndex=selected.intValue();
    if (columnIndex == dataSetDescription.getColumnOfRowIds())     continue;
    inputPattern.add(new ColumnDescription(columnIndex,dataDescription));
  }
  dataSetDescription.setParsingPattern(inputPattern);
}","@Override public void fillDataSetDescription(){
  EDataType dataType=numericalDataPropertiesWidget.getDataType();
  DataDescription dataDescription=new DataDescription(dataType == EDataType.FLOAT ? EDataClass.REAL_NUMBER : EDataClass.NATURAL_NUMBER,dataType,numericalDataPropertiesWidget.getNumericalProperties());
  dataSetDescription.setDataDescription(dataDescription);
  dataSetDescription.setTransposeMatrix(dataTranspositionWidget.isTransposition());
  ArrayList<ColumnDescription> inputPattern=new ArrayList<ColumnDescription>();
  DataImportWizard wizard=getWizard();
  for (  Integer selected : wizard.getSelectedColumns()) {
    int columnIndex=selected.intValue();
    if (columnIndex == dataSetDescription.getColumnOfRowIds())     continue;
    inputPattern.add(new ColumnDescription(columnIndex,dataDescription));
  }
  dataSetDescription.setParsingPattern(inputPattern);
}",0.8821752265861027
56992,"protected void onOpenFile(){
  FileDialog fileDialog=new FileDialog(new Shell());
  fileDialog.setText(""String_Node_Str"");
  String[] filterExt={""String_Node_Str"",""String_Node_Str""};
  fileDialog.setFilterExtensions(filterExt);
  String inputFileName=fileDialog.open().trim();
  if (inputFileName == null)   return;
  label.setText(inputFileName);
  callback.on(inputFileName);
}","protected void onOpenFile(){
  FileDialog fileDialog=new FileDialog(new Shell());
  fileDialog.setText(""String_Node_Str"");
  String[] filterExt={""String_Node_Str"",""String_Node_Str""};
  fileDialog.setFilterExtensions(filterExt);
  String inputFileName=fileDialog.open();
  if (inputFileName == null)   return;
  inputFileName=inputFileName.trim();
  label.setText(inputFileName);
  callback.on(inputFileName);
}",0.844106463878327
56993,"/** 
 * @param columns
 */
public void addTemplateColumns(List<Object> columns){
  if (wizardElement == null)   return;
  if (previewIndex < 0)   columns.add(0,wizardElement);
 else {
    int index=previewIndex - stratomex.getBrickColumnManager().getCenterColumnStartIndex();
    columns.add(index + 1,wizardElement);
  }
}","/** 
 * @param columns
 */
public void addTemplateColumns(List<Object> columns){
  if (wizardElement == null)   return;
  if (previewIndex < 0)   columns.add(0,wizardElement);
 else {
    int index=previewIndex - stratomex.getBrickColumnManager().getCenterColumnStartIndex();
    index=Math.min(index + 1,columns.size());
    columns.add(index,wizardElement);
  }
}",0.9040697674418604
56994,"@SuppressWarnings(""String_Node_Str"") @ListenTo(sendToMe=true) private void onExtraInitialScoreQueryReady(ExtraInitialScoreQueryReadyEvent event){
  getPopupLayer().hide(waiting);
  for (  Pair<ADataDomainQuery,List<AScoreRow>> pair : event.getExtras()) {
    ADataDomainQuery q=pair.getFirst();
    System.out.println(""String_Node_Str"" + q.getDataDomain().getLabel());
    int offset=table.getDataSize();
    table.addData(pair.getSecond());
    List<?> m=table.getDataModifiable();
    q.addData(offset,new CustomSubList<AScoreRow>((List<AScoreRow>)m,offset,m.size() - offset));
  }
  updateMask();
}","@SuppressWarnings(""String_Node_Str"") @ListenTo(sendToMe=true) private void onExtraInitialScoreQueryReady(ExtraInitialScoreQueryReadyEvent event){
  getPopupLayer().hide(waiting);
  for (  Pair<ADataDomainQuery,List<AScoreRow>> pair : event.getExtras()) {
    ADataDomainQuery q=pair.getFirst();
    System.out.println(""String_Node_Str"" + q.getDataDomain().getLabel());
    int offset=table.getDataSize();
    table.addData(pair.getSecond());
    List<?> m=table.getDataModifiable();
    q.addData(offset,new CustomSubList<AScoreRow>((List<AScoreRow>)m,offset,m.size() - offset));
  }
  invalidVisibleScores();
  updateMask();
}",0.978827361563518
56995,"@SuppressWarnings(""String_Node_Str"") @ListenTo(sendToMe=true) private void onInitialScoreQueryReady(InitialScoreQueryReadyEvent event){
  getPopupLayer().hide(waiting);
  int offset=table.getDataSize();
  ADataDomainQuery q=event.getNewQuery();
  System.out.println(""String_Node_Str"" + q.getDataDomain().getLabel());
  table.addData(q.getOrCreate());
  List<?> m=table.getDataModifiable();
  q.init(offset,new CustomSubList<AScoreRow>((List<AScoreRow>)m,offset,m.size() - offset));
  q.createSpecificColumns(table);
  updateMask();
}","@SuppressWarnings(""String_Node_Str"") @ListenTo(sendToMe=true) private void onInitialScoreQueryReady(InitialScoreQueryReadyEvent event){
  getPopupLayer().hide(waiting);
  int offset=table.getDataSize();
  ADataDomainQuery q=event.getNewQuery();
  System.out.println(""String_Node_Str"" + q.getDataDomain().getLabel());
  table.addData(q.getOrCreate());
  List<?> m=table.getDataModifiable();
  q.init(offset,new CustomSubList<AScoreRow>((List<AScoreRow>)m,offset,m.size() - offset));
  q.createSpecificColumns(table);
  invalidVisibleScores();
  updateMask();
}",0.9761904761904762
56996,"@ListenTo(sendToMe=true) private void onScoreQueryReady(ScoreQueryReadyEvent event){
  getPopupLayer().hide(waiting);
  if (event.getScores() != null) {
    addColumns(event.getScores(),event.isRemoveLeadingScoreColumns());
  }
 else {
    updateMask();
  }
}","@ListenTo(sendToMe=true) private void onScoreQueryReady(ScoreQueryReadyEvent event){
  getPopupLayer().hide(waiting);
  if (event.getScores() != null) {
    addColumns(event.getScores(),event.isRemoveLeadingScoreColumns());
  }
 else {
    invalidVisibleScores();
    updateMask();
  }
}",0.9487179487179488
56997,"@Override public void propertyChange(PropertyChangeEvent evt){
switch (evt.getPropertyName()) {
case RankTableModel.PROP_DATA:
    RankTableModel table=getTable();
  if (table != null) {
    @SuppressWarnings(""String_Node_Str"") Collection<IRow> news=(Collection<IRow>)evt.getNewValue();
    maskInvalid.set(table.getDataSize() - news.size(),table.getDataSize());
  }
break;
}
}","@Override public void propertyChange(PropertyChangeEvent evt){
switch (evt.getPropertyName()) {
case RankTableModel.PROP_DATA:
    RankTableModel table=getTable();
  if (table != null) {
    @SuppressWarnings(""String_Node_Str"") Collection<IRow> news=(Collection<IRow>)evt.getNewValue();
    maskInvalid.set(table.getDataSize() - news.size(),table.getDataSize());
  }
 else {
    System.err.println();
  }
break;
}
}",0.952020202020202
56998,"/** 
 * @return the table, see {@link #table}
 */
@Override public RankTableModel getTable(){
  return parent.getTable();
}","/** 
 * @return the table, see {@link #table}
 */
@Override public RankTableModel getTable(){
  return parent == null ? null : parent.getTable();
}",0.9111111111111112
56999,"@Override protected boolean filterEntry(IRow row){
  if (filterInferredPercentage >= 1)   return super.filterEntry(row);
  if (!super.filterEntry(row))   return false;
  boolean[] inferreds=isValueInferreds(row);
  boolean any=false;
  for (int i=0; i < inferreds.length; ++i) {
    if (inferreds[i]) {
      any=true;
    }
  }
  if (!any)   return true;
  float[] ws=getWeights();
  float inferPercentage=0;
  for (int i=0; i < inferreds.length; ++i) {
    if (inferreds[i])     inferPercentage+=ws[i];
  }
  return inferPercentage < filterInferredPercentage;
}","@Override protected boolean filterEntry(IRow row){
  if (filterInferredPercentage >= 1)   return super.filterEntry(row);
  if (!super.filterEntry(row)) {
    return false;
  }
  boolean[] inferreds=isValueInferreds(row);
  boolean any=false;
  for (int i=0; i < inferreds.length; ++i) {
    if (inferreds[i]) {
      any=true;
    }
  }
  if (!any)   return true;
  float[] ws=getWeights();
  float inferPercentage=0;
  for (int i=0; i < inferreds.length; ++i) {
    if (inferreds[i])     inferPercentage+=ws[i];
  }
  return inferPercentage < filterInferredPercentage;
}",0.9664902998236332
57000,"/** 
 * Reads the min and max values (if set) from the dialog
 */
public void fillDataSetDescription(){
  IDSpecification rowIDSpecification=new IDSpecification();
  IDType rowIDType=IDType.getIDType(page.rowIDCombo.getItem(page.rowIDCombo.getSelectionIndex()));
  rowIDSpecification.setIdType(rowIDType.getTypeName());
  if (rowIDType.getIDCategory().getCategoryName().equals(""String_Node_Str""))   rowIDSpecification.setIDTypeGene(true);
  rowIDSpecification.setIdCategory(rowIDType.getIDCategory().getCategoryName());
  if (rowIDTypeParsingRules != null) {
    rowIDSpecification.setIdTypeParsingRules(rowIDTypeParsingRules);
  }
 else   if (rowIDType.getTypeName().equalsIgnoreCase(""String_Node_Str"")) {
    IDTypeParsingRules parsingRules=new IDTypeParsingRules();
    parsingRules.setSubStringExpression(""String_Node_Str"");
    parsingRules.setDefault(true);
    rowIDSpecification.setIdTypeParsingRules(parsingRules);
  }
  IDSpecification columnIDSpecification=new IDSpecification();
  IDType columnIDType=IDType.getIDType(page.columnIDCombo.getItem(page.columnIDCombo.getSelectionIndex()));
  columnIDSpecification.setIdType(columnIDType.getTypeName());
  if (columnIDType.getIDCategory().getCategoryName().equals(""String_Node_Str""))   columnIDSpecification.setIDTypeGene(true);
  columnIDSpecification.setIdCategory(columnIDType.getIDCategory().getCategoryName());
  if (columnIDTypeParsingRules != null) {
    columnIDSpecification.setIdTypeParsingRules(columnIDTypeParsingRules);
  }
  dataSetDescription.setColumnIDSpecification(columnIDSpecification);
  dataSetDescription.setRowIDSpecification(rowIDSpecification);
  dataSetDescription.setDataSetName(page.label.getText());
  dataSetDescription.setDataSourcePath(page.loadFile.getFileName());
  List<List<String>> matrix=parser.getDataMatrix();
  List<List<String>> filteredMatrix=new ArrayList<>(matrix.size());
  List<Integer> selectedColumns=page.previewTable.getSelectedColumns();
  DataImportWizard wizard=page.getWizard();
  List<String> columnOfRowIDs=new ArrayList<>(matrix.size() - dataSetDescription.getNumberOfHeaderLines());
  for (int i=0; i < matrix.size(); i++) {
    boolean isRowOfColumnID=false;
    if (i == dataSetDescription.getRowOfColumnIDs()) {
      isRowOfColumnID=true;
    }
 else     if (i < dataSetDescription.getNumberOfHeaderLines())     continue;
    List<String> row=matrix.get(i);
    List<String> filteredRow=filterRowByIndices(row,selectedColumns);
    if (isRowOfColumnID) {
      wizard.setFilteredRowOfColumnIDs(filteredRow);
    }
 else {
      filteredMatrix.add(filteredRow);
      columnOfRowIDs.add(row.get(dataSetDescription.getColumnOfRowIds()));
    }
  }
  wizard.setFilteredDataMatrix(filteredMatrix);
  wizard.setSelectedColumns(selectedColumns);
  wizard.setColumnOfRowIDs(columnOfRowIDs);
}","/** 
 * Reads the min and max values (if set) from the dialog
 */
public void fillDataSetDescription(){
  IDSpecification rowIDSpecification=new IDSpecification();
  IDType rowIDType=IDType.getIDType(page.rowIDCombo.getItem(page.rowIDCombo.getSelectionIndex()));
  rowIDSpecification.setIdType(rowIDType.getTypeName());
  if (rowIDType.getIDCategory().getCategoryName().equals(""String_Node_Str""))   rowIDSpecification.setIDTypeGene(true);
  rowIDSpecification.setIdCategory(rowIDType.getIDCategory().getCategoryName());
  if (rowIDTypeParsingRules != null) {
    rowIDSpecification.setIdTypeParsingRules(rowIDTypeParsingRules);
  }
 else   if (rowIDType.getIdTypeParsingRules() != null) {
    rowIDSpecification.setIdTypeParsingRules(rowIDType.getIdTypeParsingRules());
  }
 else   if (rowIDType.getTypeName().equalsIgnoreCase(""String_Node_Str"")) {
    IDTypeParsingRules parsingRules=new IDTypeParsingRules();
    parsingRules.setSubStringExpression(""String_Node_Str"");
    parsingRules.setDefault(true);
    rowIDSpecification.setIdTypeParsingRules(parsingRules);
  }
  IDSpecification columnIDSpecification=new IDSpecification();
  IDType columnIDType=IDType.getIDType(page.columnIDCombo.getItem(page.columnIDCombo.getSelectionIndex()));
  columnIDSpecification.setIdType(columnIDType.getTypeName());
  if (columnIDType.getIDCategory().getCategoryName().equals(""String_Node_Str""))   columnIDSpecification.setIDTypeGene(true);
  columnIDSpecification.setIdCategory(columnIDType.getIDCategory().getCategoryName());
  if (columnIDTypeParsingRules != null) {
    columnIDSpecification.setIdTypeParsingRules(columnIDTypeParsingRules);
  }
 else   if (columnIDType.getIdTypeParsingRules() != null) {
    columnIDSpecification.setIdTypeParsingRules(columnIDType.getIdTypeParsingRules());
  }
  dataSetDescription.setColumnIDSpecification(columnIDSpecification);
  dataSetDescription.setRowIDSpecification(rowIDSpecification);
  dataSetDescription.setDataSetName(page.label.getText());
  dataSetDescription.setDataSourcePath(page.loadFile.getFileName());
  List<List<String>> matrix=parser.getDataMatrix();
  List<List<String>> filteredMatrix=new ArrayList<>(matrix.size());
  List<Integer> selectedColumns=page.previewTable.getSelectedColumns();
  DataImportWizard wizard=page.getWizard();
  List<String> columnOfRowIDs=new ArrayList<>(matrix.size() - dataSetDescription.getNumberOfHeaderLines());
  for (int i=0; i < matrix.size(); i++) {
    boolean isRowOfColumnID=false;
    if (i == dataSetDescription.getRowOfColumnIDs()) {
      isRowOfColumnID=true;
    }
 else     if (i < dataSetDescription.getNumberOfHeaderLines())     continue;
    List<String> row=matrix.get(i);
    List<String> filteredRow=filterRowByIndices(row,selectedColumns);
    if (isRowOfColumnID) {
      wizard.setFilteredRowOfColumnIDs(filteredRow);
    }
 else {
      filteredMatrix.add(filteredRow);
      columnOfRowIDs.add(row.get(dataSetDescription.getColumnOfRowIds()));
    }
  }
  wizard.setFilteredDataMatrix(filteredMatrix);
  wizard.setSelectedColumns(selectedColumns);
  wizard.setColumnOfRowIDs(columnOfRowIDs);
}",0.9503978330793972
