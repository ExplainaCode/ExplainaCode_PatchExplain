record_number,buggy_code,fixed_code,code_similarity
135001,"/** 
 * Suspend the notification of the incoming logs
 * @see LCEngine
 * @param suspended If true suspend the notification of new logs
 */
public void setSuspended(boolean suspended){
  acsSPS.setSupended(suspended);
}","/** 
 * Suspend the notification of the incoming logs
 * @see LCEngine
 * @param suspended If true suspend the notification of new logs
 */
public void setSuspended(boolean suspended){
  if (acsSPS != null) {
    acsSPS.setSupended(suspended);
  }
}",0.935897435897436
135002,"/** 
 * Logs the given <code>LogRecord</code>.  The record can be modified or dropped by the optional filters provided in   {@link #addLogRecordFilter(alma.acs.logging.AcsLogger.LogRecordFilter)}.  <p> Adding of context information: <ul> <li> If the LogRecord has a parameter that is a map which contains additional information  about the line of code, thread, etc., the log record will be taken as provided, and no context information will be added. This can be useful if <ul> <li> the log record was reconstructed from a remote error by the ACS error handling code (see <code>AcsJException</code>), or <li> if in very exceptional cases application code needs to manipulate such information by hand. </ul> <li> otherwise, context information is inferred, similar to   {@link LogRecord#inferCaller()}, but additionally including thread name and line of code. </ul>   Note that by overloading this method, we intercept all logging activities of the base class.
 * @see java.util.logging.Logger#log(java.util.logging.LogRecord)
 */
public void log(LogRecord record){
  int levelValue=getLevel().intValue();
  if (record.getLevel().intValue() < levelValue || levelValue == offValue) {
    return;
  }
  if (loggerName != null) {
    record.setLoggerName(loggerName);
  }
  LogParameterExtractor paramExtractor=new LogParameterExtractor(record);
  String threadName=paramExtractor.extractStringProperty(LogParameterExtractor.PARAM_THREAD_NAME,null);
  if (threadName == null) {
    Map<String,Object> logProperties=new HashMap<String,Object>();
    record.setParameters(new Object[]{logProperties});
    threadName=Thread.currentThread().getName();
    logProperties.put(LogParameterExtractor.PARAM_THREAD_NAME,threadName);
    StackTraceElement stack[]=(new Throwable()).getStackTrace();
    int ix=0;
    while (ix < stack.length) {
      StackTraceElement frame=stack[ix];
      String cname=frame.getClassName();
      if (!loggerClassNames.contains(cname)) {
        record.setSourceClassName(cname);
        record.setSourceMethodName(frame.getMethodName());
        int lineNumber=frame.getLineNumber();
        logProperties.put(LogParameterExtractor.PARAM_LINE,new Long(lineNumber));
        break;
      }
      ix++;
    }
  }
  super.log(record);
}","/** 
 * Logs the given <code>LogRecord</code>.  The record can be modified or dropped by the optional filters provided in   {@link #addLogRecordFilter(alma.acs.logging.AcsLogger.LogRecordFilter)}.  <p> Adding of context information: <ul> <li> If the LogRecord has a parameter that is a map which contains additional information  about the line of code, thread, etc., the log record will be taken as provided, and no context information will be added. This can be useful if <ul> <li> the log record was reconstructed from a remote error by the ACS error handling code (see <code>AcsJException</code>), or <li> if in very exceptional cases application code needs to manipulate such information by hand. </ul> <li> otherwise, context information is inferred, similar to   {@link LogRecord#inferCaller()}, but additionally including thread name and line of code. </ul>   Note that by overloading this method, we intercept all logging activities of the base class.
 * @see java.util.logging.Logger#log(java.util.logging.LogRecord)
 */
public void log(LogRecord record){
  Logger loggerWithLevel=this;
  while (loggerWithLevel.getLevel() == null) {
    loggerWithLevel=loggerWithLevel.getParent();
  }
  int levelValue=loggerWithLevel.getLevel().intValue();
  if (record.getLevel().intValue() < levelValue || levelValue == offValue) {
    return;
  }
  if (loggerName != null) {
    record.setLoggerName(loggerName);
  }
  LogParameterExtractor paramExtractor=new LogParameterExtractor(record);
  String threadName=paramExtractor.extractStringProperty(LogParameterExtractor.PARAM_THREAD_NAME,null);
  if (threadName == null) {
    Map<String,Object> logProperties=new HashMap<String,Object>();
    record.setParameters(new Object[]{logProperties});
    threadName=Thread.currentThread().getName();
    logProperties.put(LogParameterExtractor.PARAM_THREAD_NAME,threadName);
    StackTraceElement stack[]=(new Throwable()).getStackTrace();
    int ix=0;
    while (ix < stack.length) {
      StackTraceElement frame=stack[ix];
      String cname=frame.getClassName();
      if (!loggerClassNames.contains(cname)) {
        record.setSourceClassName(cname);
        record.setSourceMethodName(frame.getMethodName());
        int lineNumber=frame.getLineNumber();
        logProperties.put(LogParameterExtractor.PARAM_LINE,new Long(lineNumber));
        break;
      }
      ix++;
    }
  }
  super.log(record);
}",0.9663017814981756
135003,"public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
      getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}","public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getSaveFileMenuItem()) {
    getLCModel1().saveFile();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
      getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}",0.9966137566137566
135004,"public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
      getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}","public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getSaveFileMenuItem()) {
    getLCModel1().saveFile();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
      getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}",0.9966137566137566
135005,"public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
      getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}","public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getSaveFileMenuItem()) {
    getLCModel1().saveFile();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
      getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}",0.9966137566137566
135006,"/** 
 * Builds the menu bar
 */
private void setupMenuBar(){
  loggingClientJMenuBar=new javax.swing.JMenuBar();
  loggingClientJMenuBar.setName(""String_Node_Str"");
  fileMenu=new javax.swing.JMenu();
  fileMenu.setName(""String_Node_Str"");
  fileMenu.setText(""String_Node_Str"");
  fileMenu.addMenuListener(eventHandler);
  fileMenu.add(getConnectMenuItem());
  ImageIcon icon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  autoReconnectMI=new JCheckBoxMenuItem(""String_Node_Str"",icon,false);
  autoReconnectMI.addActionListener(eventHandler);
  fileMenu.add(autoReconnectMI);
  fileMenu.addSeparator();
  fileMenu.add(getLoadMenuItem());
  fileMenu.add(getLoadURLMenuItem());
  fileMenu.add(getLoadDBMenuItem());
  fileMenu.add(getSaveFileMenuItem());
  fileMenu.add(getClearAllMenuItem());
  fileMenu.addSeparator();
  fileMenu.add(getExitMenuItem());
  loggingClientJMenuBar.add(fileMenu);
  viewMenu=new javax.swing.JMenu();
  viewMenu.setName(""String_Node_Str"");
  viewMenu.setText(""String_Node_Str"");
  viewMenu.addMenuListener(eventHandler);
  viewToolbarMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewToolbarMI.addActionListener(eventHandler);
  viewMenu.add(viewToolbarMI);
  viewDetailedInfoMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewDetailedInfoMI.addActionListener(eventHandler);
  viewMenu.add(viewDetailedInfoMI);
  viewStatusAreaMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewStatusAreaMI.addActionListener(eventHandler);
  viewMenu.add(viewStatusAreaMI);
  viewMenu.addSeparator();
  viewMenu.add(getFieldsMenuItem());
  shortDateViewMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  shortDateViewMI.addActionListener(eventHandler);
  viewMenu.add(shortDateViewMI);
  viewMenu.addSeparator();
  viewMenu.add(setFiltersMenuItem());
  viewMenu.addSeparator();
  ImageIcon statIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  statisticsMenuItem=new JMenuItem(""String_Node_Str"",statIcon);
  statisticsMenuItem.addActionListener(eventHandler);
  viewMenu.add(statisticsMenuItem);
  viewErrorLogMI=new JMenuItem(""String_Node_Str"");
  viewErrorLogMI.addActionListener(eventHandler);
  viewMenu.add(viewErrorLogMI);
  loggingClientJMenuBar.add(viewMenu);
  searchMenu=new JMenu();
  searchMenu.setName(""String_Node_Str"");
  searchMenu.setText(""String_Node_Str"");
  searchMenu.addMenuListener(eventHandler);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchMenuItem=new JMenuItem(""String_Node_Str"",searchIcon);
  searchMenuItem.addActionListener(eventHandler);
  searchMenuItem.setAccelerator(KeyStroke.getKeyStroke('S',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchMenu.add(searchMenuItem);
  searchNextMenuItem=new JMenuItem(""String_Node_Str"");
  searchNextMenuItem.setAccelerator(KeyStroke.getKeyStroke('N',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchNextMenuItem.addActionListener(eventHandler);
  searchNextMenuItem.setEnabled(false);
  searchMenu.add(searchNextMenuItem);
  loggingClientJMenuBar.add(searchMenu);
  expertMenu=new JMenu();
  expertMenu.setName(""String_Node_Str"");
  expertMenu.setText(""String_Node_Str"");
  suspendMI=new JCheckBoxMenuItem(""String_Node_Str"",false);
  suspendMI.addActionListener(eventHandler);
  expertMenu.add(suspendMI);
  prefsMI=new JMenuItem(""String_Node_Str"");
  prefsMI.addActionListener(eventHandler);
  loggingClientJMenuBar.add(expertMenu);
}","/** 
 * Builds the menu bar
 */
private void setupMenuBar(){
  loggingClientJMenuBar=new javax.swing.JMenuBar();
  loggingClientJMenuBar.setName(""String_Node_Str"");
  fileMenu=new javax.swing.JMenu();
  fileMenu.setName(""String_Node_Str"");
  fileMenu.setText(""String_Node_Str"");
  fileMenu.addMenuListener(eventHandler);
  fileMenu.add(getConnectMenuItem());
  ImageIcon icon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  autoReconnectMI=new JCheckBoxMenuItem(""String_Node_Str"",icon,false);
  autoReconnectMI.addActionListener(eventHandler);
  fileMenu.add(autoReconnectMI);
  fileMenu.addSeparator();
  fileMenu.add(getLoadMenuItem());
  fileMenu.add(getLoadURLMenuItem());
  fileMenu.add(getLoadDBMenuItem());
  fileMenu.add(getSaveFileMenuItem());
  fileMenu.add(getClearAllMenuItem());
  fileMenu.addSeparator();
  fileMenu.add(getExitMenuItem());
  loggingClientJMenuBar.add(fileMenu);
  viewMenu=new javax.swing.JMenu();
  viewMenu.setName(""String_Node_Str"");
  viewMenu.setText(""String_Node_Str"");
  viewMenu.addMenuListener(eventHandler);
  viewToolbarMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewToolbarMI.addActionListener(eventHandler);
  viewMenu.add(viewToolbarMI);
  viewDetailedInfoMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewDetailedInfoMI.addActionListener(eventHandler);
  viewMenu.add(viewDetailedInfoMI);
  viewStatusAreaMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewStatusAreaMI.addActionListener(eventHandler);
  viewMenu.add(viewStatusAreaMI);
  viewMenu.addSeparator();
  viewMenu.add(getFieldsMenuItem());
  shortDateViewMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  shortDateViewMI.addActionListener(eventHandler);
  viewMenu.add(shortDateViewMI);
  viewMenu.addSeparator();
  viewMenu.add(setFiltersMenuItem());
  viewMenu.addSeparator();
  ImageIcon statIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  statisticsMenuItem=new JMenuItem(""String_Node_Str"",statIcon);
  statisticsMenuItem.addActionListener(eventHandler);
  viewMenu.add(statisticsMenuItem);
  viewErrorLogMI=new JMenuItem(""String_Node_Str"");
  viewErrorLogMI.addActionListener(eventHandler);
  viewMenu.add(viewErrorLogMI);
  loggingClientJMenuBar.add(viewMenu);
  searchMenu=new JMenu();
  searchMenu.setName(""String_Node_Str"");
  searchMenu.setText(""String_Node_Str"");
  searchMenu.addMenuListener(eventHandler);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchMenuItem=new JMenuItem(""String_Node_Str"",searchIcon);
  searchMenuItem.addActionListener(eventHandler);
  searchMenuItem.setAccelerator(KeyStroke.getKeyStroke('S',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchMenu.add(searchMenuItem);
  searchNextMenuItem=new JMenuItem(""String_Node_Str"");
  searchNextMenuItem.setAccelerator(KeyStroke.getKeyStroke('N',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchNextMenuItem.addActionListener(eventHandler);
  searchNextMenuItem.setEnabled(false);
  searchMenu.add(searchNextMenuItem);
  loggingClientJMenuBar.add(searchMenu);
  expertMenu=new JMenu();
  expertMenu.setName(""String_Node_Str"");
  expertMenu.setText(""String_Node_Str"");
  suspendMI=new JCheckBoxMenuItem(""String_Node_Str"",false);
  suspendMI.addActionListener(eventHandler);
  expertMenu.add(suspendMI);
  prefsMI=new JMenuItem(""String_Node_Str"");
  prefsMI.addActionListener(eventHandler);
  expertMenu.add(prefsMI);
  loggingClientJMenuBar.add(expertMenu);
}",0.9886379979864808
135007,"/** 
 * Build the object in online/offline mode 
 * @param initialConnectionStatus If true jlog connects to the ACS logging system
 */
private LoggingClient(){
  super();
  initialize();
  archive=new ArchiveConnectionManager(this);
}","/** 
 * Build the object in online/offline mode 
 * @param initialConnectionStatus If true jlog connects to the ACS logging system
 */
private LoggingClient(){
  super();
  initialize();
  getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
  getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
  archive=new ArchiveConnectionManager(this);
}",0.7748344370860927
135008,"/** 
 * Builds the toolbar
 */
private void setupToolBar(){
  toolBar=new JToolBar();
  toolBar.setFloatable(false);
  JPanel toolBarPanel=new JPanel();
  toolBarPanel.setLayout(new BorderLayout());
  JPanel userPanel=new JPanel();
  FlowLayout tbFlowL=new FlowLayout(FlowLayout.LEFT);
  tbFlowL.setHgap(10);
  userPanel.setLayout(tbFlowL);
  FlowLayout lyLevel=new FlowLayout();
  lyLevel.setHgap(2);
  JPanel tbLevelPanel=new JPanel(lyLevel);
  JLabel logLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(logLevelLbl);
  logLevelCB=new JComboBox(LogTypeHelper.getAllTypesDescriptions());
  LogTypeRenderer rendererCB=new LogTypeRenderer();
  logLevelCB.setSelectedIndex(DEFAULT_LOGLEVEL);
  getLCModel1().setLogLevel(DEFAULT_LOGLEVEL);
  logLevelCB.setEditable(false);
  logLevelCB.setMaximumRowCount(LogTypeHelper.getNumberOfTypes());
  logLevelCB.setRenderer(rendererCB);
  logLevelCB.addActionListener(eventHandler);
  tbLevelPanel.add(logLevelCB);
  JLabel discardLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(discardLevelLbl);
  LogTypeRenderer discardRendererCB=new LogTypeRenderer();
  String[] discardLevelStr=new String[LogTypeHelper.getAllTypesDescriptions().length + 1];
  discardLevelStr[0]=""String_Node_Str"";
  for (int t=0; t < LogTypeHelper.getAllTypesDescriptions().length; t++) {
    discardLevelStr[t + 1]=LogTypeHelper.getAllTypesDescriptions()[t];
  }
  discardLevelCB=new JComboBox(discardLevelStr);
  discardLevelCB.setMaximumRowCount(discardLevelStr.length);
  discardLevelCB.setSelectedIndex(DEFAULT_DISCARDLEVEL + 1);
  discardLevelCB.setEditable(false);
  discardLevelCB.setRenderer(discardRendererCB);
  discardLevelCB.addActionListener(eventHandler);
  tbLevelPanel.add(discardLevelCB);
  pauseIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  playIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  pauseB=new JButton(""String_Node_Str"",pauseIcon);
  pauseBtnPaused=false;
  pauseB.addActionListener(eventHandler);
  tbLevelPanel.add(pauseB);
  userPanel.add(tbLevelPanel);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchBtn=new JButton(""String_Node_Str"",searchIcon);
  userPanel.add(searchBtn);
  searchBtn.addActionListener(eventHandler);
  toolBarPanel.add(userPanel,BorderLayout.WEST);
  toolBar.add(toolBarPanel);
}","/** 
 * Builds the toolbar
 */
private void setupToolBar(){
  toolBar=new JToolBar();
  toolBar.setFloatable(false);
  JPanel toolBarPanel=new JPanel();
  toolBarPanel.setLayout(new BorderLayout());
  JPanel userPanel=new JPanel();
  FlowLayout tbFlowL=new FlowLayout(FlowLayout.LEFT);
  tbFlowL.setHgap(10);
  userPanel.setLayout(tbFlowL);
  FlowLayout lyLevel=new FlowLayout();
  lyLevel.setHgap(2);
  JPanel tbLevelPanel=new JPanel(lyLevel);
  JLabel logLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(logLevelLbl);
  logLevelCB=new JComboBox(LogTypeHelper.getAllTypesDescriptions());
  LogTypeRenderer rendererCB=new LogTypeRenderer();
  logLevelCB.setSelectedIndex(DEFAULT_LOGLEVEL);
  getLCModel1().setLogLevel(DEFAULT_LOGLEVEL);
  logLevelCB.setEditable(false);
  logLevelCB.setMaximumRowCount(LogTypeHelper.getNumberOfTypes());
  logLevelCB.setRenderer(rendererCB);
  logLevelCB.addActionListener(eventHandler);
  tbLevelPanel.add(logLevelCB);
  JLabel discardLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(discardLevelLbl);
  LogTypeRenderer discardRendererCB=new LogTypeRenderer();
  String[] discardLevelStr=new String[LogTypeHelper.getAllTypesDescriptions().length + 1];
  discardLevelStr[0]=""String_Node_Str"";
  for (int t=0; t < LogTypeHelper.getAllTypesDescriptions().length; t++) {
    discardLevelStr[t + 1]=LogTypeHelper.getAllTypesDescriptions()[t];
  }
  discardLevelCB=new JComboBox(discardLevelStr);
  discardLevelCB.setMaximumRowCount(discardLevelStr.length);
  discardLevelCB.setSelectedIndex(DEFAULT_DISCARDLEVEL + 1);
  discardLevelCB.setEditable(false);
  discardLevelCB.setRenderer(discardRendererCB);
  tbLevelPanel.add(discardLevelCB);
  pauseIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  playIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  pauseB=new JButton(""String_Node_Str"",pauseIcon);
  pauseBtnPaused=false;
  pauseB.addActionListener(eventHandler);
  tbLevelPanel.add(pauseB);
  userPanel.add(tbLevelPanel);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchBtn=new JButton(""String_Node_Str"",searchIcon);
  userPanel.add(searchBtn);
  searchBtn.addActionListener(eventHandler);
  toolBarPanel.add(userPanel,BorderLayout.WEST);
  toolBar.add(toolBarPanel);
}",0.9893344709897612
135009,"public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}","public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
      getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}",0.9724967769660507
135010,"/** 
 * Builds the menu bar
 */
private void setupMenuBar(){
  loggingClientJMenuBar=new javax.swing.JMenuBar();
  loggingClientJMenuBar.setName(""String_Node_Str"");
  fileMenu=new javax.swing.JMenu();
  fileMenu.setName(""String_Node_Str"");
  fileMenu.setText(""String_Node_Str"");
  fileMenu.addMenuListener(eventHandler);
  fileMenu.add(getConnectMenuItem());
  ImageIcon icon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  autoReconnectMI=new JCheckBoxMenuItem(""String_Node_Str"",icon,false);
  autoReconnectMI.addActionListener(eventHandler);
  fileMenu.add(autoReconnectMI);
  fileMenu.addSeparator();
  fileMenu.add(getLoadMenuItem());
  fileMenu.add(getLoadURLMenuItem());
  fileMenu.add(getLoadDBMenuItem());
  fileMenu.add(getSaveFileMenuItem());
  fileMenu.add(getClearAllMenuItem());
  fileMenu.addSeparator();
  fileMenu.add(getExitMenuItem());
  loggingClientJMenuBar.add(fileMenu);
  viewMenu=new javax.swing.JMenu();
  viewMenu.setName(""String_Node_Str"");
  viewMenu.setText(""String_Node_Str"");
  viewMenu.addMenuListener(eventHandler);
  viewToolbarMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewToolbarMI.addActionListener(eventHandler);
  viewMenu.add(viewToolbarMI);
  viewDetailedInfoMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewDetailedInfoMI.addActionListener(eventHandler);
  viewMenu.add(viewDetailedInfoMI);
  viewStatusAreaMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewStatusAreaMI.addActionListener(eventHandler);
  viewMenu.add(viewStatusAreaMI);
  viewMenu.addSeparator();
  viewMenu.add(getFieldsMenuItem());
  shortDateViewMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  shortDateViewMI.addActionListener(eventHandler);
  viewMenu.add(shortDateViewMI);
  viewMenu.addSeparator();
  viewMenu.add(setFiltersMenuItem());
  viewMenu.addSeparator();
  ImageIcon statIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  statisticsMenuItem=new JMenuItem(""String_Node_Str"",statIcon);
  statisticsMenuItem.addActionListener(eventHandler);
  viewMenu.add(statisticsMenuItem);
  viewErrorLogMI=new JMenuItem(""String_Node_Str"");
  viewErrorLogMI.addActionListener(eventHandler);
  viewMenu.add(viewErrorLogMI);
  loggingClientJMenuBar.add(viewMenu);
  searchMenu=new JMenu();
  searchMenu.setName(""String_Node_Str"");
  searchMenu.setText(""String_Node_Str"");
  searchMenu.addMenuListener(eventHandler);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchMenuItem=new JMenuItem(""String_Node_Str"",searchIcon);
  searchMenuItem.addActionListener(eventHandler);
  searchMenuItem.setAccelerator(KeyStroke.getKeyStroke('S',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchMenu.add(searchMenuItem);
  searchNextMenuItem=new JMenuItem(""String_Node_Str"");
  searchNextMenuItem.setAccelerator(KeyStroke.getKeyStroke('N',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchNextMenuItem.addActionListener(eventHandler);
  searchNextMenuItem.setEnabled(false);
  searchMenu.add(searchNextMenuItem);
  loggingClientJMenuBar.add(searchMenu);
  expertMenu=new JMenu();
  expertMenu.setName(""String_Node_Str"");
  expertMenu.setText(""String_Node_Str"");
  suspendMI=new JCheckBoxMenuItem(""String_Node_Str"",false);
  suspendMI.addActionListener(eventHandler);
  expertMenu.add(suspendMI);
  prefsMI=new JMenuItem(""String_Node_Str"");
  prefsMI.addActionListener(eventHandler);
  loggingClientJMenuBar.add(expertMenu);
}","/** 
 * Builds the menu bar
 */
private void setupMenuBar(){
  loggingClientJMenuBar=new javax.swing.JMenuBar();
  loggingClientJMenuBar.setName(""String_Node_Str"");
  fileMenu=new javax.swing.JMenu();
  fileMenu.setName(""String_Node_Str"");
  fileMenu.setText(""String_Node_Str"");
  fileMenu.addMenuListener(eventHandler);
  fileMenu.add(getConnectMenuItem());
  ImageIcon icon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  autoReconnectMI=new JCheckBoxMenuItem(""String_Node_Str"",icon,false);
  autoReconnectMI.addActionListener(eventHandler);
  fileMenu.add(autoReconnectMI);
  fileMenu.addSeparator();
  fileMenu.add(getLoadMenuItem());
  fileMenu.add(getLoadURLMenuItem());
  fileMenu.add(getLoadDBMenuItem());
  fileMenu.add(getSaveFileMenuItem());
  fileMenu.add(getClearAllMenuItem());
  fileMenu.addSeparator();
  fileMenu.add(getExitMenuItem());
  loggingClientJMenuBar.add(fileMenu);
  viewMenu=new javax.swing.JMenu();
  viewMenu.setName(""String_Node_Str"");
  viewMenu.setText(""String_Node_Str"");
  viewMenu.addMenuListener(eventHandler);
  viewToolbarMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewToolbarMI.addActionListener(eventHandler);
  viewMenu.add(viewToolbarMI);
  viewDetailedInfoMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewDetailedInfoMI.addActionListener(eventHandler);
  viewMenu.add(viewDetailedInfoMI);
  viewStatusAreaMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewStatusAreaMI.addActionListener(eventHandler);
  viewMenu.add(viewStatusAreaMI);
  viewMenu.addSeparator();
  viewMenu.add(getFieldsMenuItem());
  shortDateViewMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  shortDateViewMI.addActionListener(eventHandler);
  viewMenu.add(shortDateViewMI);
  viewMenu.addSeparator();
  viewMenu.add(setFiltersMenuItem());
  viewMenu.addSeparator();
  ImageIcon statIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  statisticsMenuItem=new JMenuItem(""String_Node_Str"",statIcon);
  statisticsMenuItem.addActionListener(eventHandler);
  viewMenu.add(statisticsMenuItem);
  viewErrorLogMI=new JMenuItem(""String_Node_Str"");
  viewErrorLogMI.addActionListener(eventHandler);
  viewMenu.add(viewErrorLogMI);
  loggingClientJMenuBar.add(viewMenu);
  searchMenu=new JMenu();
  searchMenu.setName(""String_Node_Str"");
  searchMenu.setText(""String_Node_Str"");
  searchMenu.addMenuListener(eventHandler);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchMenuItem=new JMenuItem(""String_Node_Str"",searchIcon);
  searchMenuItem.addActionListener(eventHandler);
  searchMenuItem.setAccelerator(KeyStroke.getKeyStroke('S',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchMenu.add(searchMenuItem);
  searchNextMenuItem=new JMenuItem(""String_Node_Str"");
  searchNextMenuItem.setAccelerator(KeyStroke.getKeyStroke('N',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchNextMenuItem.addActionListener(eventHandler);
  searchNextMenuItem.setEnabled(false);
  searchMenu.add(searchNextMenuItem);
  loggingClientJMenuBar.add(searchMenu);
  expertMenu=new JMenu();
  expertMenu.setName(""String_Node_Str"");
  expertMenu.setText(""String_Node_Str"");
  suspendMI=new JCheckBoxMenuItem(""String_Node_Str"",false);
  suspendMI.addActionListener(eventHandler);
  expertMenu.add(suspendMI);
  prefsMI=new JMenuItem(""String_Node_Str"");
  prefsMI.addActionListener(eventHandler);
  expertMenu.add(prefsMI);
  loggingClientJMenuBar.add(expertMenu);
}",0.9886379979864808
135011,"/** 
 * Build the object in online/offline mode 
 * @param initialConnectionStatus If true jlog connects to the ACS logging system
 */
private LoggingClient(){
  super();
  initialize();
  archive=new ArchiveConnectionManager(this);
}","/** 
 * Build the object in online/offline mode 
 * @param initialConnectionStatus If true jlog connects to the ACS logging system
 */
private LoggingClient(){
  super();
  initialize();
  getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
  getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
  archive=new ArchiveConnectionManager(this);
}",0.7748344370860927
135012,"/** 
 * Builds the toolbar
 */
private void setupToolBar(){
  toolBar=new JToolBar();
  toolBar.setFloatable(false);
  JPanel toolBarPanel=new JPanel();
  toolBarPanel.setLayout(new BorderLayout());
  JPanel userPanel=new JPanel();
  FlowLayout tbFlowL=new FlowLayout(FlowLayout.LEFT);
  tbFlowL.setHgap(10);
  userPanel.setLayout(tbFlowL);
  FlowLayout lyLevel=new FlowLayout();
  lyLevel.setHgap(2);
  JPanel tbLevelPanel=new JPanel(lyLevel);
  JLabel logLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(logLevelLbl);
  logLevelCB=new JComboBox(LogTypeHelper.getAllTypesDescriptions());
  LogTypeRenderer rendererCB=new LogTypeRenderer();
  logLevelCB.setSelectedIndex(DEFAULT_LOGLEVEL);
  getLCModel1().setLogLevel(DEFAULT_LOGLEVEL);
  logLevelCB.setEditable(false);
  logLevelCB.setMaximumRowCount(LogTypeHelper.getNumberOfTypes());
  logLevelCB.setRenderer(rendererCB);
  logLevelCB.addActionListener(eventHandler);
  tbLevelPanel.add(logLevelCB);
  JLabel discardLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(discardLevelLbl);
  LogTypeRenderer discardRendererCB=new LogTypeRenderer();
  String[] discardLevelStr=new String[LogTypeHelper.getAllTypesDescriptions().length + 1];
  discardLevelStr[0]=""String_Node_Str"";
  for (int t=0; t < LogTypeHelper.getAllTypesDescriptions().length; t++) {
    discardLevelStr[t + 1]=LogTypeHelper.getAllTypesDescriptions()[t];
  }
  discardLevelCB=new JComboBox(discardLevelStr);
  discardLevelCB.setMaximumRowCount(discardLevelStr.length);
  discardLevelCB.setSelectedIndex(DEFAULT_DISCARDLEVEL + 1);
  discardLevelCB.setEditable(false);
  discardLevelCB.setRenderer(discardRendererCB);
  discardLevelCB.addActionListener(eventHandler);
  tbLevelPanel.add(discardLevelCB);
  pauseIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  playIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  pauseB=new JButton(""String_Node_Str"",pauseIcon);
  pauseBtnPaused=false;
  pauseB.addActionListener(eventHandler);
  tbLevelPanel.add(pauseB);
  userPanel.add(tbLevelPanel);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchBtn=new JButton(""String_Node_Str"",searchIcon);
  userPanel.add(searchBtn);
  searchBtn.addActionListener(eventHandler);
  toolBarPanel.add(userPanel,BorderLayout.WEST);
  toolBar.add(toolBarPanel);
}","/** 
 * Builds the toolbar
 */
private void setupToolBar(){
  toolBar=new JToolBar();
  toolBar.setFloatable(false);
  JPanel toolBarPanel=new JPanel();
  toolBarPanel.setLayout(new BorderLayout());
  JPanel userPanel=new JPanel();
  FlowLayout tbFlowL=new FlowLayout(FlowLayout.LEFT);
  tbFlowL.setHgap(10);
  userPanel.setLayout(tbFlowL);
  FlowLayout lyLevel=new FlowLayout();
  lyLevel.setHgap(2);
  JPanel tbLevelPanel=new JPanel(lyLevel);
  JLabel logLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(logLevelLbl);
  logLevelCB=new JComboBox(LogTypeHelper.getAllTypesDescriptions());
  LogTypeRenderer rendererCB=new LogTypeRenderer();
  logLevelCB.setSelectedIndex(DEFAULT_LOGLEVEL);
  getLCModel1().setLogLevel(DEFAULT_LOGLEVEL);
  logLevelCB.setEditable(false);
  logLevelCB.setMaximumRowCount(LogTypeHelper.getNumberOfTypes());
  logLevelCB.setRenderer(rendererCB);
  logLevelCB.addActionListener(eventHandler);
  tbLevelPanel.add(logLevelCB);
  JLabel discardLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(discardLevelLbl);
  LogTypeRenderer discardRendererCB=new LogTypeRenderer();
  String[] discardLevelStr=new String[LogTypeHelper.getAllTypesDescriptions().length + 1];
  discardLevelStr[0]=""String_Node_Str"";
  for (int t=0; t < LogTypeHelper.getAllTypesDescriptions().length; t++) {
    discardLevelStr[t + 1]=LogTypeHelper.getAllTypesDescriptions()[t];
  }
  discardLevelCB=new JComboBox(discardLevelStr);
  discardLevelCB.setMaximumRowCount(discardLevelStr.length);
  discardLevelCB.setSelectedIndex(DEFAULT_DISCARDLEVEL + 1);
  discardLevelCB.setEditable(false);
  discardLevelCB.setRenderer(discardRendererCB);
  tbLevelPanel.add(discardLevelCB);
  pauseIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  playIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  pauseB=new JButton(""String_Node_Str"",pauseIcon);
  pauseBtnPaused=false;
  pauseB.addActionListener(eventHandler);
  tbLevelPanel.add(pauseB);
  userPanel.add(tbLevelPanel);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchBtn=new JButton(""String_Node_Str"",searchIcon);
  userPanel.add(searchBtn);
  searchBtn.addActionListener(eventHandler);
  toolBarPanel.add(userPanel,BorderLayout.WEST);
  toolBar.add(toolBarPanel);
}",0.9893344709897612
135013,"public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}","public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
      getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}",0.9724967769660507
135014,"/** 
 * Builds the menu bar
 */
private void setupMenuBar(){
  loggingClientJMenuBar=new javax.swing.JMenuBar();
  loggingClientJMenuBar.setName(""String_Node_Str"");
  fileMenu=new javax.swing.JMenu();
  fileMenu.setName(""String_Node_Str"");
  fileMenu.setText(""String_Node_Str"");
  fileMenu.addMenuListener(eventHandler);
  fileMenu.add(getConnectMenuItem());
  ImageIcon icon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  autoReconnectMI=new JCheckBoxMenuItem(""String_Node_Str"",icon,false);
  autoReconnectMI.addActionListener(eventHandler);
  fileMenu.add(autoReconnectMI);
  fileMenu.addSeparator();
  fileMenu.add(getLoadMenuItem());
  fileMenu.add(getLoadURLMenuItem());
  fileMenu.add(getLoadDBMenuItem());
  fileMenu.add(getSaveFileMenuItem());
  fileMenu.add(getClearAllMenuItem());
  fileMenu.addSeparator();
  fileMenu.add(getExitMenuItem());
  loggingClientJMenuBar.add(fileMenu);
  viewMenu=new javax.swing.JMenu();
  viewMenu.setName(""String_Node_Str"");
  viewMenu.setText(""String_Node_Str"");
  viewMenu.addMenuListener(eventHandler);
  viewToolbarMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewToolbarMI.addActionListener(eventHandler);
  viewMenu.add(viewToolbarMI);
  viewDetailedInfoMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewDetailedInfoMI.addActionListener(eventHandler);
  viewMenu.add(viewDetailedInfoMI);
  viewStatusAreaMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewStatusAreaMI.addActionListener(eventHandler);
  viewMenu.add(viewStatusAreaMI);
  viewMenu.addSeparator();
  viewMenu.add(getFieldsMenuItem());
  shortDateViewMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  shortDateViewMI.addActionListener(eventHandler);
  viewMenu.add(shortDateViewMI);
  viewMenu.addSeparator();
  viewMenu.add(setFiltersMenuItem());
  viewMenu.addSeparator();
  ImageIcon statIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  statisticsMenuItem=new JMenuItem(""String_Node_Str"",statIcon);
  statisticsMenuItem.addActionListener(eventHandler);
  viewMenu.add(statisticsMenuItem);
  viewErrorLogMI=new JMenuItem(""String_Node_Str"");
  viewErrorLogMI.addActionListener(eventHandler);
  viewMenu.add(viewErrorLogMI);
  loggingClientJMenuBar.add(viewMenu);
  searchMenu=new JMenu();
  searchMenu.setName(""String_Node_Str"");
  searchMenu.setText(""String_Node_Str"");
  searchMenu.addMenuListener(eventHandler);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchMenuItem=new JMenuItem(""String_Node_Str"",searchIcon);
  searchMenuItem.addActionListener(eventHandler);
  searchMenuItem.setAccelerator(KeyStroke.getKeyStroke('S',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchMenu.add(searchMenuItem);
  searchNextMenuItem=new JMenuItem(""String_Node_Str"");
  searchNextMenuItem.setAccelerator(KeyStroke.getKeyStroke('N',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchNextMenuItem.addActionListener(eventHandler);
  searchNextMenuItem.setEnabled(false);
  searchMenu.add(searchNextMenuItem);
  loggingClientJMenuBar.add(searchMenu);
  expertMenu=new JMenu();
  expertMenu.setName(""String_Node_Str"");
  expertMenu.setText(""String_Node_Str"");
  suspendMI=new JCheckBoxMenuItem(""String_Node_Str"",false);
  suspendMI.addActionListener(eventHandler);
  expertMenu.add(suspendMI);
  prefsMI=new JMenuItem(""String_Node_Str"");
  prefsMI.addActionListener(eventHandler);
  loggingClientJMenuBar.add(expertMenu);
}","/** 
 * Builds the menu bar
 */
private void setupMenuBar(){
  loggingClientJMenuBar=new javax.swing.JMenuBar();
  loggingClientJMenuBar.setName(""String_Node_Str"");
  fileMenu=new javax.swing.JMenu();
  fileMenu.setName(""String_Node_Str"");
  fileMenu.setText(""String_Node_Str"");
  fileMenu.addMenuListener(eventHandler);
  fileMenu.add(getConnectMenuItem());
  ImageIcon icon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  autoReconnectMI=new JCheckBoxMenuItem(""String_Node_Str"",icon,false);
  autoReconnectMI.addActionListener(eventHandler);
  fileMenu.add(autoReconnectMI);
  fileMenu.addSeparator();
  fileMenu.add(getLoadMenuItem());
  fileMenu.add(getLoadURLMenuItem());
  fileMenu.add(getLoadDBMenuItem());
  fileMenu.add(getSaveFileMenuItem());
  fileMenu.add(getClearAllMenuItem());
  fileMenu.addSeparator();
  fileMenu.add(getExitMenuItem());
  loggingClientJMenuBar.add(fileMenu);
  viewMenu=new javax.swing.JMenu();
  viewMenu.setName(""String_Node_Str"");
  viewMenu.setText(""String_Node_Str"");
  viewMenu.addMenuListener(eventHandler);
  viewToolbarMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewToolbarMI.addActionListener(eventHandler);
  viewMenu.add(viewToolbarMI);
  viewDetailedInfoMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewDetailedInfoMI.addActionListener(eventHandler);
  viewMenu.add(viewDetailedInfoMI);
  viewStatusAreaMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  viewStatusAreaMI.addActionListener(eventHandler);
  viewMenu.add(viewStatusAreaMI);
  viewMenu.addSeparator();
  viewMenu.add(getFieldsMenuItem());
  shortDateViewMI=new JCheckBoxMenuItem(""String_Node_Str"",true);
  shortDateViewMI.addActionListener(eventHandler);
  viewMenu.add(shortDateViewMI);
  viewMenu.addSeparator();
  viewMenu.add(setFiltersMenuItem());
  viewMenu.addSeparator();
  ImageIcon statIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  statisticsMenuItem=new JMenuItem(""String_Node_Str"",statIcon);
  statisticsMenuItem.addActionListener(eventHandler);
  viewMenu.add(statisticsMenuItem);
  viewErrorLogMI=new JMenuItem(""String_Node_Str"");
  viewErrorLogMI.addActionListener(eventHandler);
  viewMenu.add(viewErrorLogMI);
  loggingClientJMenuBar.add(viewMenu);
  searchMenu=new JMenu();
  searchMenu.setName(""String_Node_Str"");
  searchMenu.setText(""String_Node_Str"");
  searchMenu.addMenuListener(eventHandler);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchMenuItem=new JMenuItem(""String_Node_Str"",searchIcon);
  searchMenuItem.addActionListener(eventHandler);
  searchMenuItem.setAccelerator(KeyStroke.getKeyStroke('S',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchMenu.add(searchMenuItem);
  searchNextMenuItem=new JMenuItem(""String_Node_Str"");
  searchNextMenuItem.setAccelerator(KeyStroke.getKeyStroke('N',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  searchNextMenuItem.addActionListener(eventHandler);
  searchNextMenuItem.setEnabled(false);
  searchMenu.add(searchNextMenuItem);
  loggingClientJMenuBar.add(searchMenu);
  expertMenu=new JMenu();
  expertMenu.setName(""String_Node_Str"");
  expertMenu.setText(""String_Node_Str"");
  suspendMI=new JCheckBoxMenuItem(""String_Node_Str"",false);
  suspendMI.addActionListener(eventHandler);
  expertMenu.add(suspendMI);
  prefsMI=new JMenuItem(""String_Node_Str"");
  prefsMI.addActionListener(eventHandler);
  expertMenu.add(prefsMI);
  loggingClientJMenuBar.add(expertMenu);
}",0.9886379979864808
135015,"/** 
 * Build the object in online/offline mode 
 * @param initialConnectionStatus If true jlog connects to the ACS logging system
 */
private LoggingClient(){
  super();
  initialize();
  archive=new ArchiveConnectionManager(this);
}","/** 
 * Build the object in online/offline mode 
 * @param initialConnectionStatus If true jlog connects to the ACS logging system
 */
private LoggingClient(){
  super();
  initialize();
  getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
  getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
  archive=new ArchiveConnectionManager(this);
}",0.7748344370860927
135016,"/** 
 * Builds the toolbar
 */
private void setupToolBar(){
  toolBar=new JToolBar();
  toolBar.setFloatable(false);
  JPanel toolBarPanel=new JPanel();
  toolBarPanel.setLayout(new BorderLayout());
  JPanel userPanel=new JPanel();
  FlowLayout tbFlowL=new FlowLayout(FlowLayout.LEFT);
  tbFlowL.setHgap(10);
  userPanel.setLayout(tbFlowL);
  FlowLayout lyLevel=new FlowLayout();
  lyLevel.setHgap(2);
  JPanel tbLevelPanel=new JPanel(lyLevel);
  JLabel logLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(logLevelLbl);
  logLevelCB=new JComboBox(LogTypeHelper.getAllTypesDescriptions());
  LogTypeRenderer rendererCB=new LogTypeRenderer();
  logLevelCB.setSelectedIndex(DEFAULT_LOGLEVEL);
  getLCModel1().setLogLevel(DEFAULT_LOGLEVEL);
  logLevelCB.setEditable(false);
  logLevelCB.setMaximumRowCount(LogTypeHelper.getNumberOfTypes());
  logLevelCB.setRenderer(rendererCB);
  logLevelCB.addActionListener(eventHandler);
  tbLevelPanel.add(logLevelCB);
  JLabel discardLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(discardLevelLbl);
  LogTypeRenderer discardRendererCB=new LogTypeRenderer();
  String[] discardLevelStr=new String[LogTypeHelper.getAllTypesDescriptions().length + 1];
  discardLevelStr[0]=""String_Node_Str"";
  for (int t=0; t < LogTypeHelper.getAllTypesDescriptions().length; t++) {
    discardLevelStr[t + 1]=LogTypeHelper.getAllTypesDescriptions()[t];
  }
  discardLevelCB=new JComboBox(discardLevelStr);
  discardLevelCB.setMaximumRowCount(discardLevelStr.length);
  discardLevelCB.setSelectedIndex(DEFAULT_DISCARDLEVEL + 1);
  discardLevelCB.setEditable(false);
  discardLevelCB.setRenderer(discardRendererCB);
  discardLevelCB.addActionListener(eventHandler);
  tbLevelPanel.add(discardLevelCB);
  pauseIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  playIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  pauseB=new JButton(""String_Node_Str"",pauseIcon);
  pauseBtnPaused=false;
  pauseB.addActionListener(eventHandler);
  tbLevelPanel.add(pauseB);
  userPanel.add(tbLevelPanel);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchBtn=new JButton(""String_Node_Str"",searchIcon);
  userPanel.add(searchBtn);
  searchBtn.addActionListener(eventHandler);
  toolBarPanel.add(userPanel,BorderLayout.WEST);
  toolBar.add(toolBarPanel);
}","/** 
 * Builds the toolbar
 */
private void setupToolBar(){
  toolBar=new JToolBar();
  toolBar.setFloatable(false);
  JPanel toolBarPanel=new JPanel();
  toolBarPanel.setLayout(new BorderLayout());
  JPanel userPanel=new JPanel();
  FlowLayout tbFlowL=new FlowLayout(FlowLayout.LEFT);
  tbFlowL.setHgap(10);
  userPanel.setLayout(tbFlowL);
  FlowLayout lyLevel=new FlowLayout();
  lyLevel.setHgap(2);
  JPanel tbLevelPanel=new JPanel(lyLevel);
  JLabel logLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(logLevelLbl);
  logLevelCB=new JComboBox(LogTypeHelper.getAllTypesDescriptions());
  LogTypeRenderer rendererCB=new LogTypeRenderer();
  logLevelCB.setSelectedIndex(DEFAULT_LOGLEVEL);
  getLCModel1().setLogLevel(DEFAULT_LOGLEVEL);
  logLevelCB.setEditable(false);
  logLevelCB.setMaximumRowCount(LogTypeHelper.getNumberOfTypes());
  logLevelCB.setRenderer(rendererCB);
  logLevelCB.addActionListener(eventHandler);
  tbLevelPanel.add(logLevelCB);
  JLabel discardLevelLbl=new JLabel(""String_Node_Str"");
  tbLevelPanel.add(discardLevelLbl);
  LogTypeRenderer discardRendererCB=new LogTypeRenderer();
  String[] discardLevelStr=new String[LogTypeHelper.getAllTypesDescriptions().length + 1];
  discardLevelStr[0]=""String_Node_Str"";
  for (int t=0; t < LogTypeHelper.getAllTypesDescriptions().length; t++) {
    discardLevelStr[t + 1]=LogTypeHelper.getAllTypesDescriptions()[t];
  }
  discardLevelCB=new JComboBox(discardLevelStr);
  discardLevelCB.setMaximumRowCount(discardLevelStr.length);
  discardLevelCB.setSelectedIndex(DEFAULT_DISCARDLEVEL + 1);
  discardLevelCB.setEditable(false);
  discardLevelCB.setRenderer(discardRendererCB);
  tbLevelPanel.add(discardLevelCB);
  pauseIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  playIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  pauseB=new JButton(""String_Node_Str"",pauseIcon);
  pauseBtnPaused=false;
  pauseB.addActionListener(eventHandler);
  tbLevelPanel.add(pauseB);
  userPanel.add(tbLevelPanel);
  ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource(""String_Node_Str""));
  searchBtn=new JButton(""String_Node_Str"",searchIcon);
  userPanel.add(searchBtn);
  searchBtn.addActionListener(eventHandler);
  toolBarPanel.add(userPanel,BorderLayout.WEST);
  toolBar.add(toolBarPanel);
}",0.9893344709897612
135017,"public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}","public void actionPerformed(java.awt.event.ActionEvent e){
  if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
    if (connectMenuItem.getText().compareTo(""String_Node_Str"") == 0) {
      connect();
    }
 else {
      LoggingClient.this.autoReconnectMI.setState(false);
      LoggingClient.this.engine.enableAutoReconnection(false);
      disconnect();
    }
  }
 else   if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
    getLCModel1().loadFromFile(null);
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
    getLCModel1().loadFromURL();
  }
 else   if (e.getSource() == LoggingClient.this.getLoadDBMenuItem()) {
    QueryDlg dlg=new QueryDlg(archive,LoggingClient.this);
    dlg.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
    getLCModel1().clearAll();
  }
 else   if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
    connExit(e);
  }
 else   if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
    connFields(e);
  }
 else   if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
    editFilters(e);
  }
 else   if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
    loadFilters();
  }
 else   if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
    if (filterFileName != null)     if (filterFileName.length() > 0)     saveFilters(filterFileName);
  }
 else   if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
    saveAsFilters();
  }
 else   if (e.getSource() == LoggingClient.this.logLevelCB) {
    getLCModel1().setLogLevel(logLevelCB.getSelectedIndex());
    getLCModel1().invalidateVisibleLogs();
  }
 else   if (e.getSource() == LoggingClient.this.searchBtn || e.getSource() == searchMenuItem) {
    if (searchDialog == null) {
      searchDialog=new SearchDialog(LoggingClient.this);
    }
    searchDialog.setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.searchNextMenuItem) {
    if (searchDialog != null) {
      searchDialog.search();
    }
 else {
      searchNextMenuItem.setEnabled(false);
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewToolbarMI) {
    toolBar.setVisible(viewToolbarMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.statisticsMenuItem) {
    StatsDlg statsDlg=new StatsDlg(LoggingClient.this);
  }
 else   if (e.getSource() == viewErrorLogMI) {
    if (ErrorLogDialog.getErrorLogDlg(false) != null)     ErrorLogDialog.getErrorLogDlg(false).setVisible(true);
  }
 else   if (e.getSource() == LoggingClient.this.viewStatusAreaMI) {
    getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
    if (viewStatusAreaMI.getState()) {
      getJSplitPane1().setDividerLocation(getHeight() - 150);
    }
 else {
      getJSplitPane1().setDividerLocation(getHeight());
    }
  }
 else   if (e.getSource() == LoggingClient.this.viewDetailedInfoMI) {
    getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
    if (viewDetailedInfoMI.getState()) {
      int w=getLogTable().getWidth();
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w / 3);
    }
 else {
      getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
    }
  }
 else   if (e.getSource() == LoggingClient.this.autoReconnectMI) {
    if (LoggingClient.this.engine != null) {
      LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
    }
  }
 else   if (e.getSource() == LoggingClient.this.shortDateViewMI) {
    logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
  }
 else   if (e.getSource() == LoggingClient.this.pauseB) {
    pauseBtnPaused=!pauseBtnPaused;
    tableModel.scrollLock(pauseBtnPaused);
    if (pauseBtnPaused) {
      pauseB.setIcon(playIcon);
      pauseB.setText(""String_Node_Str"");
    }
 else {
      pauseB.setIcon(pauseIcon);
      pauseB.setText(""String_Node_Str"");
    }
  }
 else   if (e.getSource() == LoggingClient.this.suspendMI) {
    getEngine().setSupended(suspendMI.isSelected());
  }
 else   if (e.getSource() == LoggingClient.this.prefsMI) {
    ExpertPrefsDlg dlg=new ExpertPrefsDlg(LoggingClient.this,userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
    if (dlg.okPressed()) {
      userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
      userPreferences.setTimeFrame(dlg.getTimeFrame());
      getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
      getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
    }
  }
 else {
    System.err.println(""String_Node_Str"" + e);
  }
}",0.9724967769660507
135018,"public void componentsAvailable(List<ComponentDescriptor> comps){
  logger.info(""String_Node_Str"");
  if (sync != null) {
    sync.countDown();
  }
  allCompsAvailable.addAll(comps);
}","public synchronized void componentsAvailable(List<ComponentDescriptor> comps){
  logger.info(""String_Node_Str"");
  allCompsAvailable.addAll(comps);
  if (sync != null) {
    sync.countDown();
  }
}",0.7821522309711286
135019,"public void componentsUnavailable(List<String> compNames){
  logger.info(""String_Node_Str"");
  if (sync != null) {
    sync.countDown();
  }
  allCompNamesUnavailable.addAll(compNames);
}","public synchronized void componentsUnavailable(List<String> compNames){
  logger.info(""String_Node_Str"");
  allCompNamesUnavailable.addAll(compNames);
  if (sync != null) {
    sync.countDown();
  }
}",0.7338501291989664
135020,"/** 
 * Waits until <code>nCalls</code> notifications have been received since the call to <code>clearAndExpect(nCalls)</code>.
 */
public boolean awaitNotifications(long timeout,TimeUnit unit) throws InterruptedException {
  return sync.await(timeout,unit);
}","/** 
 * Waits until <code>nCalls</code> notifications have been received since the call to <code>clearAndExpect(nCalls)</code>.
 * @return true if the calls were received before the timeout (see {@link CountDownLatch#await(long,TimeUnit)}.
 */
public boolean awaitNotifications(long timeout,TimeUnit unit) throws InterruptedException {
  return sync.await(timeout,unit);
}",0.6930379746835443
135021,"public void clearAndExpect(int nCalls){
  allCompsAvailable.clear();
  allCompNamesUnavailable.clear();
  sync=new CountDownLatch(nCalls);
}","public synchronized void clearAndExpect(int nCalls){
  allCompsAvailable.clear();
  allCompNamesUnavailable.clear();
  sync=new CountDownLatch(nCalls);
}",0.955631399317406
135022,"/** 
 * Logout from MACI.
 * @param id Handle of the Client that is logging out
 */
public void logout(int id) throws NoPermissionEx {
  pendingRequests.increment();
  try {
    if (isDebug())     new MessageLogEntry(this,""String_Node_Str"",new java.lang.Object[]{new Integer(id)}).dispatch();
    manager.logout(id);
  }
 catch (  BadParametersException bpe) {
    BadParametersException hbpe=new BadParametersException(this,bpe.getMessage(),bpe);
    hbpe.caughtIn(this,""String_Node_Str"");
    reportException(hbpe);
    throw new BAD_PARAM(bpe.getMessage());
  }
catch (  NoPermissionException npe) {
    NoPermissionException hnpe=new NoPermissionException(this,npe.getMessage(),npe);
    hnpe.caughtIn(this,""String_Node_Str"");
    reportException(hnpe);
    AcsJNoPermissionEx ex=new AcsJNoPermissionEx();
    ex.setReason(npe.getMessage());
    throw ex.toNoPermissionEx();
  }
catch (  NoResourcesException nre) {
    NoResourcesException hnre=new NoResourcesException(this,nre.getMessage(),nre);
    hnre.caughtIn(this,""String_Node_Str"");
    reportException(hnre);
    throw new NO_RESOURCES(nre.getMessage());
  }
catch (  Throwable ex) {
    CoreException hce=new CoreException(this,ex.getMessage(),ex);
    hce.caughtIn(this,""String_Node_Str"");
    reportException(hce);
    throw new UNKNOWN(ex.getMessage());
  }
 finally {
    pendingRequests.decrement();
  }
}","/** 
 * Logout from MACI.
 * @param id Handle of the Client that is logging out
 */
public void logout(int id) throws NoPermissionEx {
  pendingRequests.increment();
  try {
    if (isDebug())     new MessageLogEntry(this,""String_Node_Str"",new java.lang.Object[]{new Integer(id)}).dispatch();
    manager.logout(id);
  }
 catch (  AcsJNoPermissionEx npe) {
    reportException(npe);
    AcsJNoPermissionEx ex=new AcsJNoPermissionEx(npe);
    ex.setReason(npe.getReason());
    throw ex.toNoPermissionEx();
  }
catch (  BadParametersException bpe) {
    BadParametersException hbpe=new BadParametersException(this,bpe.getMessage(),bpe);
    hbpe.caughtIn(this,""String_Node_Str"");
    reportException(hbpe);
    throw new BAD_PARAM(bpe.getMessage());
  }
catch (  NoResourcesException nre) {
    NoResourcesException hnre=new NoResourcesException(this,nre.getMessage(),nre);
    hnre.caughtIn(this,""String_Node_Str"");
    reportException(hnre);
    throw new NO_RESOURCES(nre.getMessage());
  }
catch (  Throwable ex) {
    CoreException hce=new CoreException(this,ex.getMessage(),ex);
    hce.caughtIn(this,""String_Node_Str"");
    reportException(hce);
    throw new UNKNOWN(ex.getMessage());
  }
 finally {
    pendingRequests.decrement();
  }
}",0.8068702290076336
135023,"/** 
 * Creates <code>m_componentPOA</code> as a child of the root POA. This POA will be the parent of the POAs for the individual components.  Uses <code>LifespanPolicyValue.PERSISTENT</code>.
 * @throws AcsJContainerServicesEx
 */
private void initPOAForComponents() throws AcsJContainerEx {
  if (m_componentPOA != null) {
    return;
  }
  try {
    m_compPolicies=new Policy[4];
    m_compPolicies[0]=m_rootPOA.create_id_assignment_policy(IdAssignmentPolicyValue.USER_ID);
    m_compPolicies[1]=m_rootPOA.create_lifespan_policy(LifespanPolicyValue.PERSISTENT);
    m_compPolicies[2]=m_rootPOA.create_servant_retention_policy(ServantRetentionPolicyValue.RETAIN);
    m_compPolicies[3]=m_rootPOA.create_request_processing_policy(RequestProcessingPolicyValue.USE_SERVANT_MANAGER);
    m_componentPOA=m_rootPOA.create_POA(""String_Node_Str"",sharedPoaManager,m_compPolicies);
    if (m_componentPOA != null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    m_logger.finest(""String_Node_Str"");
  }
 catch (  Throwable thr) {
    AcsJContainerEx ex=new AcsJContainerEx(thr);
    ex.setContextInfo(""String_Node_Str"");
    throw ex;
  }
}","/** 
 * Creates <code>m_componentPOA</code> as a child of the root POA. This POA will be the parent of the POAs for the individual components.  Uses <code>LifespanPolicyValue.PERSISTENT</code>.
 * @throws AcsJContainerServicesEx
 */
private void initPOAForComponents() throws AcsJContainerEx {
  if (m_componentPOA != null) {
    return;
  }
  try {
    m_compPolicies=new Policy[4];
    m_compPolicies[0]=m_rootPOA.create_id_assignment_policy(IdAssignmentPolicyValue.USER_ID);
    m_compPolicies[1]=m_rootPOA.create_lifespan_policy(LifespanPolicyValue.PERSISTENT);
    m_compPolicies[2]=m_rootPOA.create_servant_retention_policy(ServantRetentionPolicyValue.RETAIN);
    m_compPolicies[3]=m_rootPOA.create_request_processing_policy(RequestProcessingPolicyValue.USE_SERVANT_MANAGER);
    m_componentPOA=m_rootPOA.create_POA(""String_Node_Str"",sharedPoaManager,m_compPolicies);
    if (m_componentPOA == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    m_logger.finest(""String_Node_Str"");
  }
 catch (  Throwable thr) {
    AcsJContainerEx ex=new AcsJContainerEx(thr);
    ex.setContextInfo(""String_Node_Str"");
    throw ex;
  }
}",0.9991326973113616
135024,"private void initPOAForContainer() throws AcsJContainerEx {
  if (m_containerPOA != null) {
    return;
  }
  Policy[] contPolicies=null;
  try {
    contPolicies=new Policy[4];
    contPolicies[0]=m_rootPOA.create_id_assignment_policy(IdAssignmentPolicyValue.USER_ID);
    contPolicies[1]=m_rootPOA.create_lifespan_policy(LifespanPolicyValue.PERSISTENT);
    contPolicies[2]=m_rootPOA.create_request_processing_policy(RequestProcessingPolicyValue.USE_ACTIVE_OBJECT_MAP_ONLY);
    contPolicies[3]=m_rootPOA.create_servant_retention_policy(ServantRetentionPolicyValue.RETAIN);
    m_containerPOA=m_rootPOA.create_POA(""String_Node_Str"",sharedPoaManager,contPolicies);
    if (m_containerPOA != null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    m_logger.finest(""String_Node_Str"");
  }
 catch (  Throwable thr) {
    AcsJContainerEx ex=new AcsJContainerEx(thr);
    ex.setContextInfo(""String_Node_Str"");
    throw ex;
  }
 finally {
    if (contPolicies != null) {
      for (int polInd=0; polInd < contPolicies.length; polInd++) {
        contPolicies[polInd].destroy();
      }
    }
  }
}","private void initPOAForContainer() throws AcsJContainerEx {
  if (m_containerPOA != null) {
    return;
  }
  Policy[] contPolicies=null;
  try {
    contPolicies=new Policy[4];
    contPolicies[0]=m_rootPOA.create_id_assignment_policy(IdAssignmentPolicyValue.USER_ID);
    contPolicies[1]=m_rootPOA.create_lifespan_policy(LifespanPolicyValue.PERSISTENT);
    contPolicies[2]=m_rootPOA.create_request_processing_policy(RequestProcessingPolicyValue.USE_ACTIVE_OBJECT_MAP_ONLY);
    contPolicies[3]=m_rootPOA.create_servant_retention_policy(ServantRetentionPolicyValue.RETAIN);
    m_containerPOA=m_rootPOA.create_POA(""String_Node_Str"",sharedPoaManager,contPolicies);
    if (m_containerPOA == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    m_logger.finest(""String_Node_Str"");
  }
 catch (  Throwable thr) {
    AcsJContainerEx ex=new AcsJContainerEx(thr);
    ex.setContextInfo(""String_Node_Str"");
    throw ex;
  }
 finally {
    if (contPolicies != null) {
      for (int polInd=0; polInd < contPolicies.length; polInd++) {
        contPolicies[polInd].destroy();
      }
    }
  }
}",0.9991007194244604
135025,"public org.omg.CORBA.Object getComponent(String curl) throws NotConnectedToManagerException {
  int hhhhh=myOwnMaciHandle();
  try {
    org.omg.CORBA.Object stub=myManagerReference().get_component(hhhhh,curl,true);
    log.fine(""String_Node_Str"" + curl + ""String_Node_Str"");
  }
 catch (  CannotGetComponentEx e) {
    AcsJCannotGetComponentEx je=new AcsJCannotGetComponentEx(e);
    je.setCURL(curl);
    je.log(log);
  }
catch (  ComponentNotAlreadyActivatedEx e) {
    AcsJCannotGetComponentEx je=new AcsJCannotGetComponentEx(e);
    je.setCURL(curl);
    je.log(log);
  }
catch (  ComponentConfigurationNotFoundEx e) {
    AcsJCannotGetComponentEx je=new AcsJCannotGetComponentEx(e);
    je.setCURL(curl);
    je.log(log);
  }
  return null;
}","public org.omg.CORBA.Object getComponent(String curl) throws NotConnectedToManagerException {
  Manager mgr=myManagerReference();
  int hhhhh=myOwnMaciHandle();
  try {
    org.omg.CORBA.Object stub=mgr.get_component(hhhhh,curl,true);
    log.fine(""String_Node_Str"" + curl + ""String_Node_Str"");
    return stub;
  }
 catch (  CannotGetComponentEx e) {
    AcsJCannotGetComponentEx je=new AcsJCannotGetComponentEx(e);
    je.setCURL(curl);
    je.log(log);
  }
catch (  ComponentNotAlreadyActivatedEx e) {
    AcsJCannotGetComponentEx je=new AcsJCannotGetComponentEx(e);
    je.setCURL(curl);
    je.log(log);
  }
catch (  ComponentConfigurationNotFoundEx e) {
    AcsJCannotGetComponentEx je=new AcsJCannotGetComponentEx(e);
    je.setCURL(curl);
    je.log(log);
  }
  return null;
}",0.9516971279373369
135026,"/** 
 * Will attempt to log into the manager. If the manager reference is not available, will enter a loop and keep trying. If login fails on an available manager, will throw a ContainerException.
 * @throws ContainerException
 */
void loginToManager() throws ContainerException {
  Container thisContainer=_this(m_acsCorba.getORB());
  m_managerProxy.loginToManager(thisContainer,true);
}","/** 
 * Will attempt to log into the manager. If the manager reference is not available, will enter a loop and keep trying. If login fails on an available manager, will throw a ContainerException.
 * @throws ContainerException
 */
protected void loginToManager() throws ContainerException {
  Container thisContainer=_this(m_acsCorba.getORB());
  m_managerProxy.loginToManager(thisContainer,true);
}",0.9873096446700508
135027,"/** 
 * Gets a reference to the CDB. Reuses the previously obtained reference. Implemented as on-demand remote call, so always use this method  instead of directly accessing the field   {@link #cdb}.  <p> TODO: reuse this CDB reference in ContainerServicesImpl for method getCDB()
 * @return the CDB reference, or <code>null</code> if it could not be obtained.
 */
DAL getCDB(){
  if (cdb != null) {
    return cdb;
  }
  try {
    IntHolder status=new IntHolder();
    org.omg.CORBA.Object dalObj=m_managerProxy.get_service(""String_Node_Str"",true,status);
    cdb=DALHelper.narrow(dalObj);
    if (cdb == null || status.value != ManagerOperations.COMPONENT_ACTIVATED) {
      m_logger.log(Level.WARNING,""String_Node_Str"" + status.value);
    }
  }
 catch (  Exception e) {
    m_logger.log(Level.WARNING,""String_Node_Str"",e);
  }
  return cdb;
}","/** 
 * Gets a reference to the CDB. Reuses the previously obtained reference. Implemented as on-demand remote call, so always use this method instead of directly accessing the field   {@link #cdb}. <p> TODO: reuse this CDB reference in ContainerServicesImpl for method getCDB()
 * @return the CDB reference, or <code>null</code> if it could not beobtained.
 */
DAL getCDB(){
  if (cdb != null) {
    return cdb;
  }
  try {
    IntHolder status=new IntHolder();
    org.omg.CORBA.Object dalObj=m_managerProxy.get_service(""String_Node_Str"",true,status);
    cdb=DALHelper.narrow(dalObj);
    if (cdb == null || status.value != ManagerOperations.COMPONENT_ACTIVATED) {
      m_logger.log(Level.WARNING,""String_Node_Str"" + status.value);
    }
  }
 catch (  Exception e) {
    m_logger.log(Level.WARNING,""String_Node_Str"",e);
  }
  return cdb;
}",0.9982238010657194
135028,"/** 
 * @param containerName
 * @param acsCorba
 * @param managerProxy
 * @param isEmbedded  true if this container runs within an application. Affects shutdown behavior.
 * @throws ContainerException  if anything goes wrong, or if another instance of this classhas already been created.
 */
AcsContainer(String containerName,AcsCorba acsCorba,AcsManagerProxy managerProxy,boolean isEmbedded) throws ContainerException {
  if (s_instance == null) {
    m_containerName=containerName;
    m_managerProxy=managerProxy;
    this.isEmbedded=isEmbedded;
    ClientLogManager clm=ClientLogManager.getAcsLogManager();
    m_logger=clm.getLoggerForContainer(containerName);
    m_activeComponentMap=new ComponentMap(m_logger);
    m_acsCorba=acsCorba;
    registerWithCorba();
    LogConfig logConfig=clm.getLogConfig();
    logConfig.setCDBContainerPath(""String_Node_Str"" + containerName);
    logConfig.setCDB(getCDB());
    try {
      logConfig.initialize();
    }
 catch (    LogConfigException ex) {
      m_logger.log(Level.FINE,""String_Node_Str"" + ex.getMessage());
    }
    s_instance=this;
    try {
      ACSAlarmSystemInterfaceFactory.init(m_acsCorba.getORB(),m_managerProxy.getManager(),m_logger);
    }
 catch (    Exception e) {
      throw new ContainerException(""String_Node_Str"");
    }
  }
 else {
    throw new ContainerException(""String_Node_Str"" + AcsContainer.class.getName() + ""String_Node_Str"");
  }
}","/** 
 * Constructor which creates a container that is registered as a CORBA object, but not yet logged in to the manager (for that, call   {@link #initialize()}.
 * @param containerName
 * @param acsCorba
 * @param managerProxy
 * @param isEmbedded  true if this container runs within an application. Affects shutdown behavior.
 * @throws ContainerException  if anything goes wrong, or if another instance of this classhas already been created.
 */
AcsContainer(String containerName,AcsCorba acsCorba,AcsManagerProxy managerProxy,boolean isEmbedded) throws ContainerException {
  if (s_instance == null) {
    m_containerName=containerName;
    m_managerProxy=managerProxy;
    this.isEmbedded=isEmbedded;
    m_logger=ClientLogManager.getAcsLogManager().getLoggerForContainer(containerName);
    m_activeComponentMap=new ComponentMap(m_logger);
    m_acsCorba=acsCorba;
    registerWithCorba();
    s_instance=this;
  }
 else {
    throw new ContainerException(""String_Node_Str"" + AcsContainer.class.getName() + ""String_Node_Str"");
  }
}",0.5225885225885226
135029,"/** 
 * Gets a reference to the CDB. Reuses the previously obtained reference. Implemented as on-demand remote call, so always use this method  instead of directly accessing the field   {@link #cdb}.  <p> TODO: reuse this CDB reference in ContainerServicesImpl for method getCDB()
 * @return the CDB reference, or <code>null</code> if it could not be obtained.
 */
DAL getCDB(){
  if (cdb != null) {
    return cdb;
  }
  IntHolder status=new IntHolder();
  try {
    org.omg.CORBA.Object dalObj=m_managerProxy.get_service(""String_Node_Str"",true,status);
    cdb=DALHelper.narrow(dalObj);
  }
 catch (  Exception e) {
    m_logger.log(Level.WARNING,""String_Node_Str"",e);
  }
  if (status.value != ManagerOperations.COMPONENT_ACTIVATED) {
    m_logger.log(Level.WARNING,""String_Node_Str"" + status.value);
  }
  return cdb;
}","/** 
 * Gets a reference to the CDB. Reuses the previously obtained reference. Implemented as on-demand remote call, so always use this method  instead of directly accessing the field   {@link #cdb}.  <p> TODO: reuse this CDB reference in ContainerServicesImpl for method getCDB()
 * @return the CDB reference, or <code>null</code> if it could not be obtained.
 */
DAL getCDB(){
  if (cdb != null) {
    return cdb;
  }
  try {
    IntHolder status=new IntHolder();
    org.omg.CORBA.Object dalObj=m_managerProxy.get_service(""String_Node_Str"",true,status);
    cdb=DALHelper.narrow(dalObj);
    if (cdb == null || status.value != ManagerOperations.COMPONENT_ACTIVATED) {
      m_logger.log(Level.WARNING,""String_Node_Str"" + status.value);
    }
  }
 catch (  Exception e) {
    m_logger.log(Level.WARNING,""String_Node_Str"",e);
  }
  return cdb;
}",0.8651887357699221
135030,"/** 
 * Converts an <code>ErrorTrace</code> object to a Java <code>Throwable</code>. The chain of caused-by exceptions is translated, too. <p> See the comment on class substitution at  {@link DefaultAcsJException}.
 * @param et
 * @return Throwable  current implementation always returns a subclass of <code>AcsJException</code>, but don't rely on it yet.
 */
static Throwable recursiveGetThrowable(ErrorTrace et){
  String classname=ErrorTraceManipulator.getProperty(et,PROPERTY_JAVAEXCEPTION_CLASS);
  String message=ErrorTraceManipulator.getProperty(et,PROPERTY_JAVAEXCEPTION_MESSAGE);
  if (message == null) {
    message=""String_Node_Str"";
  }
  Throwable thr=null;
  if (classname != null) {
    try {
      Class exClass=Class.forName(classname);
      if (Throwable.class.isAssignableFrom(exClass)) {
        if (!AcsJException.class.isAssignableFrom(exClass)) {
          message+=""String_Node_Str"" + classname + ""String_Node_Str"";
          exClass=DefaultAcsJException.class;
        }
        Constructor msgCtor=exClass.getConstructor(new Class[]{String.class});
        thr=(Throwable)msgCtor.newInstance(new Object[]{message});
      }
    }
 catch (    Exception e) {
      message=""String_Node_Str"" + message;
    }
  }
  if (thr == null) {
    thr=new DefaultAcsJException(message,et.errorType,et.errorCode,et.shortDescription);
  }
  resurrectThrowable(thr,et);
  return thr;
}","/** 
 * Converts an <code>ErrorTrace</code> object to a Java <code>Throwable</code>. The chain of caused-by exceptions is translated, too. <p> See the comment on class substitution at  {@link DefaultAcsJException}.
 * @param et
 * @return Throwable  current implementation always returns a subclass of <code>AcsJException</code>, but don't rely on it yet.
 */
static Throwable recursiveGetThrowable(ErrorTrace et){
  String classname=ErrorTraceManipulator.getProperty(et,PROPERTY_JAVAEXCEPTION_CLASS);
  String message=ErrorTraceManipulator.getProperty(et,PROPERTY_JAVAEXCEPTION_MESSAGE);
  if (message == null) {
    message=""String_Node_Str"";
  }
  Throwable thr=null;
  if (classname != null) {
    try {
      Class exClass=Class.forName(classname);
      if (AcsJException.class.isAssignableFrom(exClass)) {
        Constructor msgCtor=exClass.getConstructor(new Class[]{String.class});
        thr=(Throwable)msgCtor.newInstance(new Object[]{message});
      }
 else {
        thr=new DefaultAcsJException(message,0,0,classname);
      }
    }
 catch (    Exception e) {
      message=""String_Node_Str"" + classname + ""String_Node_Str""+ message+ ""String_Node_Str"";
    }
  }
  if (thr == null) {
    thr=new DefaultAcsJException(message,et.errorType,et.errorCode,et.shortDescription);
  }
  resurrectThrowable(thr,et);
  return thr;
}",0.8606946983546618
135031,"/** 
 * Gets a logger for an application (which is not an ACS component itself), e.g. a GUI application using the ACS ComponentClient. 
 * @param namespace  the logger namespace, should identify the application.
 * @param enableRemoteLogging  if true (generally recommended), log messages will be sent to the remote log service,as it always happens for container and component loggers. 
 * @return a configured Logger  
 */
public Logger getLoggerForApplication(String namespace,boolean enableRemoteLogging){
  if (namespace == null || namespace.trim().length() == 0) {
    namespace=""String_Node_Str"";
  }
  Logger logger=null;
  if (enableRemoteLogging) {
    logger=createRemoteLogger(namespace);
  }
 else {
    logger=Logger.getLogger(namespace);
    addLocalHandler(logger);
    AcsLogger.configureJDKLogger(logger,logConfig.getLogConfigData());
  }
  return logger;
}","/** 
 * Gets a logger for an application (which is not an ACS component itself), e.g. a GUI application using the ACS ComponentClient. 
 * @param namespace  the logger namespace, should identify the application.
 * @param enableRemoteLogging  if true (generally recommended), log messages will be sent to the remote log service,as it always happens for container and component loggers. 
 * @return a configured Logger  
 */
public Logger getLoggerForApplication(String namespace,boolean enableRemoteLogging){
  if (namespace == null || namespace.trim().length() == 0) {
    namespace=""String_Node_Str"";
  }
  Logger logger=null;
  if (enableRemoteLogging) {
    logger=createRemoteLogger(namespace);
  }
 else {
    logger=Logger.getLogger(namespace);
    logger.setUseParentHandlers(false);
    addLocalHandler(logger);
    AcsLogger.configureJDKLogger(logger,logConfig.getLogConfigData());
  }
  return logger;
}",0.977628635346756
135032,"/** 
 * Factory method for additional container service instances. This method should only be used by specialized clients such as the OMC GUI which needs independent ContainerServices instances for the plug-ins it runs.
 * @param clientName  name for {@link ContainerServices#getName()}
 * @param csLogger  logger to be used internally by the new ContainerServices instance (which is different from the Logger returned in  {@link ContainerServices#getLogger()}). 
 */
public ContainerServices createContainerServices(String clientName,Logger csLogger) throws ContainerException {
  try {
    ThreadFactory threadFactory=new CleaningDaemonThreadFactory(clientName,csLogger);
    AcsManagerProxy acsManagerProxy=m_acsManagerProxy.createInstance();
    ManagerClient clImpl=new ManagerClient(clientName,csLogger);
    Client managerClient=clImpl._this(acsCorba.getORB());
    acsManagerProxy.loginToManager(managerClient,false);
    int clientHandle=acsManagerProxy.getManagerHandle();
    ContainerServices cs=new ContainerServicesImpl(acsManagerProxy,acsCorba.getRootPOA(),acsCorba,csLogger,clientHandle,clientName,null,threadFactory);
    return cs;
  }
 catch (  ContainerException ex) {
    throw ex;
  }
catch (  Throwable thr) {
    throw new ContainerException(thr);
  }
}","/** 
 * Factory method for additional container service instances. This method should only be used by specialized clients such as the OMC GUI which needs independent ContainerServices instances for the plug-ins it runs. <p> Make sure to call   {@link #destroyContainerServices(ContainerServices)} when done with the new CS.
 * @param clientName  name for {@link ContainerServices#getName()}
 * @param csLogger  logger to be used internally by the new ContainerServices instance (which is different from the Logger returned in  {@link ContainerServices#getLogger()}). 
 */
public ContainerServices createContainerServices(String clientName,Logger csLogger) throws ContainerException {
  try {
    ThreadFactory threadFactory=new CleaningDaemonThreadFactory(clientName,csLogger);
    AcsManagerProxy acsManagerProxy=m_acsManagerProxy.createInstance();
    ManagerClient clImpl=new ManagerClient(clientName,csLogger);
    Client managerClient=clImpl._this(acsCorba.getORB());
    acsManagerProxy.loginToManager(managerClient,false);
    int clientHandle=acsManagerProxy.getManagerHandle();
    ContainerServicesImpl cs=new ContainerServicesImpl(acsManagerProxy,acsCorba.getRootPOA(),acsCorba,csLogger,clientHandle,clientName,null,threadFactory);
    additionalContainerServices.put(cs,acsManagerProxy);
    return cs;
  }
 catch (  ContainerException ex) {
    throw ex;
  }
catch (  Throwable thr) {
    throw new ContainerException(thr);
  }
}",0.9393159249724164
135033,"/** 
 * ""un-factory"" method which inverts   {@link #createContainerServices(String,Logger)}.
 * @param cs ContainerServices instance created by {@link #createContainerServices(String,Logger)}.
 */
public void destroyContainerServices(ContainerServices cs) throws ContainerException {
  try {
    ContainerServicesImpl csImpl=(ContainerServicesImpl)cs;
    m_acsManagerProxy.shutdownNotify();
    csImpl.releaseAllComponents();
    ((CleaningDaemonThreadFactory)csImpl.getThreadFactory()).cleanUp();
    m_acsManagerProxy.logoutFromManager();
  }
 catch (  Throwable thr) {
    throw new ContainerException(""String_Node_Str"",thr);
  }
}","/** 
 * ""un-factory"" method which inverts   {@link #createContainerServices(String,Logger)}.
 * @param cs ContainerServices instance created by {@link #createContainerServices(String,Logger)}.
 */
public void destroyContainerServices(ContainerServices cs) throws ContainerException {
  if (!additionalContainerServices.containsKey(cs)) {
    throw new ContainerException(""String_Node_Str"");
  }
  try {
    ContainerServicesImpl csImpl=(ContainerServicesImpl)cs;
    AcsManagerProxy acsManagerProxy=additionalContainerServices.get(cs);
    acsManagerProxy.shutdownNotify();
    csImpl.releaseAllComponents();
    ((CleaningDaemonThreadFactory)csImpl.getThreadFactory()).cleanUp();
    acsManagerProxy.logoutFromManager();
    additionalContainerServices.remove(cs);
  }
 catch (  Throwable thr) {
    throw new ContainerException(""String_Node_Str"",thr);
  }
}",0.4738955823293173
135034,"/** 
 * @return an XML string representing this log
 */
public String toXMLString(){
  StringBuffer sb=new StringBuffer();
  String logType=LogTypeHelper.getLogTypeDescription(type);
  sb.append(""String_Node_Str"" + logType);
  for (int t=0; t < NUMBER_OF_FIELDS; t++) {
    if (t == FIELD_LOGMESSAGE || t == FIELD_ENTRYTYPE) {
      continue;
    }
    Object attrValue=getField(t);
    if (attrValue != null) {
      if (Date.class.isInstance(attrValue)) {
        SimpleDateFormat df=new SimpleDateFormat(TIME_FORMAT);
        Date dt=(Date)attrValue;
        StringBuffer dateSB=new StringBuffer();
        java.text.FieldPosition pos=new java.text.FieldPosition(0);
        df.format(dt,dateSB,pos);
        attrValue=dateSB.toString();
      }
      String attrValStr=attrValue.toString();
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      sb.append(""String_Node_Str"" + tagAttributes[t] + ""String_Node_Str""+ attrValStr+ ""String_Node_Str"");
    }
  }
  if (type == LogTypeHelper.ENTRYTYPE_TRACE) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"" + logMessage + ""String_Node_Str"");
    if (hasDatas()) {
      sb.append(getXMLDatas());
    }
    sb.append(""String_Node_Str"" + logType + ""String_Node_Str"");
  }
  return sb.toString();
}","/** 
 * @return an XML string representing this log
 */
public String toXMLString(){
  StringBuilder sb=new StringBuilder();
  String logType=LogTypeHelper.getLogTypeDescription(type);
  sb.append(""String_Node_Str"" + logType);
  for (int t=0; t < NUMBER_OF_FIELDS; t++) {
    if (t == FIELD_LOGMESSAGE || t == FIELD_ENTRYTYPE) {
      continue;
    }
    Object attrValue=getField(t);
    if (attrValue != null) {
      if (Date.class.isInstance(attrValue)) {
        SimpleDateFormat df=new SimpleDateFormat(TIME_FORMAT);
        Date dt=(Date)attrValue;
        StringBuffer dateSB=new StringBuffer();
        java.text.FieldPosition pos=new java.text.FieldPosition(0);
        df.format(dt,dateSB,pos);
        attrValue=dateSB.toString();
      }
      String attrValStr=attrValue.toString();
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      sb.append(""String_Node_Str"" + tagAttributes[t] + ""String_Node_Str""+ attrValStr+ ""String_Node_Str"");
    }
  }
  if (type == LogTypeHelper.ENTRYTYPE_TRACE && !hasDatas()) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
    if (logMessage != null) {
      sb.append(""String_Node_Str"" + logMessage + ""String_Node_Str"");
    }
    if (hasDatas()) {
      sb.append(getXMLDatas());
    }
    sb.append(""String_Node_Str"" + logType + ""String_Node_Str"");
  }
  return sb.toString();
}",0.9659050966608084
135035,"/** 
 * @return The XML representation of the additional data
 */
private StringBuffer getXMLDatas(){
  StringBuffer tempStr=new StringBuffer();
  if (additionalData != null) {
    int size=additionalData.size();
    for (int t=0; t < size; t++) {
      AdditionalData temp=additionalData.get(t);
      String name=temp.getName();
      String value=temp.getValue();
      name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      value=value.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      tempStr.append(""String_Node_Str"" + name + ""String_Node_Str"");
      tempStr.append(value);
      tempStr.append(""String_Node_Str"");
    }
  }
  return tempStr;
}","/** 
 * @return The XML representation of the additional data
 */
private StringBuilder getXMLDatas(){
  StringBuilder tempStr=new StringBuilder();
  if (additionalData != null) {
    int size=additionalData.size();
    for (int t=0; t < size; t++) {
      AdditionalData temp=additionalData.get(t);
      String name=temp.getName();
      String value=temp.getValue();
      name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      value=value.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      tempStr.append(""String_Node_Str"" + name + ""String_Node_Str"");
      tempStr.append(value);
      tempStr.append(""String_Node_Str"");
    }
  }
  return tempStr;
}",0.990353697749196
135036,"/** 
 * @return an XML string representing this log
 */
public String toXMLString(){
  StringBuffer sb=new StringBuffer();
  String logType=LogTypeHelper.getLogTypeDescription(type);
  sb.append(""String_Node_Str"" + logType);
  for (int t=0; t < NUMBER_OF_FIELDS; t++) {
    if (t == FIELD_LOGMESSAGE || t == FIELD_ENTRYTYPE) {
      continue;
    }
    Object attrValue=getField(t);
    if (attrValue != null) {
      if (Date.class.isInstance(attrValue)) {
        SimpleDateFormat df=new SimpleDateFormat(TIME_FORMAT);
        Date dt=(Date)attrValue;
        StringBuffer dateSB=new StringBuffer();
        java.text.FieldPosition pos=new java.text.FieldPosition(0);
        df.format(dt,dateSB,pos);
        attrValue=dateSB.toString();
      }
      String attrValStr=attrValue.toString();
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      sb.append(""String_Node_Str"" + tagAttributes[t] + ""String_Node_Str""+ attrValStr+ ""String_Node_Str"");
    }
  }
  if (type == LogTypeHelper.ENTRYTYPE_TRACE) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"" + logMessage + ""String_Node_Str"");
    if (hasDatas()) {
      sb.append(getXMLDatas());
    }
    sb.append(""String_Node_Str"" + logType + ""String_Node_Str"");
  }
  return sb.toString();
}","/** 
 * @return an XML string representing this log
 */
public String toXMLString(){
  StringBuilder sb=new StringBuilder();
  String logType=LogTypeHelper.getLogTypeDescription(type);
  sb.append(""String_Node_Str"" + logType);
  for (int t=0; t < NUMBER_OF_FIELDS; t++) {
    if (t == FIELD_LOGMESSAGE || t == FIELD_ENTRYTYPE) {
      continue;
    }
    Object attrValue=getField(t);
    if (attrValue != null) {
      if (Date.class.isInstance(attrValue)) {
        SimpleDateFormat df=new SimpleDateFormat(TIME_FORMAT);
        Date dt=(Date)attrValue;
        StringBuffer dateSB=new StringBuffer();
        java.text.FieldPosition pos=new java.text.FieldPosition(0);
        df.format(dt,dateSB,pos);
        attrValue=dateSB.toString();
      }
      String attrValStr=attrValue.toString();
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      sb.append(""String_Node_Str"" + tagAttributes[t] + ""String_Node_Str""+ attrValStr+ ""String_Node_Str"");
    }
  }
  if (type == LogTypeHelper.ENTRYTYPE_TRACE && !hasDatas()) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
    if (logMessage != null) {
      sb.append(""String_Node_Str"" + logMessage + ""String_Node_Str"");
    }
    if (hasDatas()) {
      sb.append(getXMLDatas());
    }
    sb.append(""String_Node_Str"" + logType + ""String_Node_Str"");
  }
  return sb.toString();
}",0.9659050966608084
135037,"/** 
 * @return The XML representation of the additional data
 */
private StringBuffer getXMLDatas(){
  StringBuffer tempStr=new StringBuffer();
  if (additionalData != null) {
    int size=additionalData.size();
    for (int t=0; t < size; t++) {
      AdditionalData temp=additionalData.get(t);
      String name=temp.getName();
      String value=temp.getValue();
      name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      value=value.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      tempStr.append(""String_Node_Str"" + name + ""String_Node_Str"");
      tempStr.append(value);
      tempStr.append(""String_Node_Str"");
    }
  }
  return tempStr;
}","/** 
 * @return The XML representation of the additional data
 */
private StringBuilder getXMLDatas(){
  StringBuilder tempStr=new StringBuilder();
  if (additionalData != null) {
    int size=additionalData.size();
    for (int t=0; t < size; t++) {
      AdditionalData temp=additionalData.get(t);
      String name=temp.getName();
      String value=temp.getValue();
      name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      value=value.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      tempStr.append(""String_Node_Str"" + name + ""String_Node_Str"");
      tempStr.append(value);
      tempStr.append(""String_Node_Str"");
    }
  }
  return tempStr;
}",0.990353697749196
135038,"/** 
 * @return an XML string representing this log
 */
public String toXMLString(){
  StringBuffer sb=new StringBuffer();
  String logType=LogTypeHelper.getLogTypeDescription(type);
  sb.append(""String_Node_Str"" + logType);
  for (int t=0; t < NUMBER_OF_FIELDS; t++) {
    if (t == FIELD_LOGMESSAGE || t == FIELD_ENTRYTYPE) {
      continue;
    }
    Object attrValue=getField(t);
    if (attrValue != null) {
      if (Date.class.isInstance(attrValue)) {
        SimpleDateFormat df=new SimpleDateFormat(TIME_FORMAT);
        Date dt=(Date)attrValue;
        StringBuffer dateSB=new StringBuffer();
        java.text.FieldPosition pos=new java.text.FieldPosition(0);
        df.format(dt,dateSB,pos);
        attrValue=dateSB.toString();
      }
      String attrValStr=attrValue.toString();
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      sb.append(""String_Node_Str"" + tagAttributes[t] + ""String_Node_Str""+ attrValStr+ ""String_Node_Str"");
    }
  }
  if (type == LogTypeHelper.ENTRYTYPE_TRACE) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"" + logMessage + ""String_Node_Str"");
    if (hasDatas()) {
      sb.append(getXMLDatas());
    }
    sb.append(""String_Node_Str"" + logType + ""String_Node_Str"");
  }
  return sb.toString();
}","/** 
 * @return an XML string representing this log
 */
public String toXMLString(){
  StringBuilder sb=new StringBuilder();
  String logType=LogTypeHelper.getLogTypeDescription(type);
  sb.append(""String_Node_Str"" + logType);
  for (int t=0; t < NUMBER_OF_FIELDS; t++) {
    if (t == FIELD_LOGMESSAGE || t == FIELD_ENTRYTYPE) {
      continue;
    }
    Object attrValue=getField(t);
    if (attrValue != null) {
      if (Date.class.isInstance(attrValue)) {
        SimpleDateFormat df=new SimpleDateFormat(TIME_FORMAT);
        Date dt=(Date)attrValue;
        StringBuffer dateSB=new StringBuffer();
        java.text.FieldPosition pos=new java.text.FieldPosition(0);
        df.format(dt,dateSB,pos);
        attrValue=dateSB.toString();
      }
      String attrValStr=attrValue.toString();
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      attrValStr=attrValStr.replaceAll(""String_Node_Str"",""String_Node_Str"");
      sb.append(""String_Node_Str"" + tagAttributes[t] + ""String_Node_Str""+ attrValStr+ ""String_Node_Str"");
    }
  }
  if (type == LogTypeHelper.ENTRYTYPE_TRACE && !hasDatas()) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
    if (logMessage != null) {
      sb.append(""String_Node_Str"" + logMessage + ""String_Node_Str"");
    }
    if (hasDatas()) {
      sb.append(getXMLDatas());
    }
    sb.append(""String_Node_Str"" + logType + ""String_Node_Str"");
  }
  return sb.toString();
}",0.9659050966608084
135039,"/** 
 * @return The XML representation of the additional data
 */
private StringBuffer getXMLDatas(){
  StringBuffer tempStr=new StringBuffer();
  if (additionalData != null) {
    int size=additionalData.size();
    for (int t=0; t < size; t++) {
      AdditionalData temp=additionalData.get(t);
      String name=temp.getName();
      String value=temp.getValue();
      name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      value=value.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      tempStr.append(""String_Node_Str"" + name + ""String_Node_Str"");
      tempStr.append(value);
      tempStr.append(""String_Node_Str"");
    }
  }
  return tempStr;
}","/** 
 * @return The XML representation of the additional data
 */
private StringBuilder getXMLDatas(){
  StringBuilder tempStr=new StringBuilder();
  if (additionalData != null) {
    int size=additionalData.size();
    for (int t=0; t < size; t++) {
      AdditionalData temp=additionalData.get(t);
      String name=temp.getName();
      String value=temp.getValue();
      name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      value=value.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
      tempStr.append(""String_Node_Str"" + name + ""String_Node_Str"");
      tempStr.append(value);
      tempStr.append(""String_Node_Str"");
    }
  }
  return tempStr;
}",0.990353697749196
135040,"/** 
 * Implements required method of ACSLogParser interface.
 * @param xmlString the XML string to parse
 * @throws LogParseException when problems are encountered parsing an XML message.
 * @see ACSLogParser
 */
public ILogEntry parse(String xmlString) throws LogParseException {
  LogEntry retVal=null;
  byte[] bytesArray=xmlString.getBytes();
  VTDGen vg=null;
  try {
    try {
      vg=new VTDGen();
      vg.setDoc(bytesArray);
      vg.parse(false);
    }
 catch (    Exception e) {
      vg.clear();
      String newLogString=XmlNormalizer.normalizeXMLEmbeddedTextOnly(xmlString);
      vg.setDoc(newLogString.getBytes());
      vg.parse(false);
    }
    retVal=makeLogEntryFromParsedXML(vg,bytesArray,xmlString);
  }
 catch (  ParseException ex) {
    ex.printStackTrace();
    throw new LogParseException(""String_Node_Str"",ex);
  }
  return retVal;
}","/** 
 * Implements required method of ACSLogParser interface.
 * @param xmlString the XML string to parse
 * @throws LogParseException when problems are encountered parsing an XML message.
 * @see ACSLogParser
 */
public ILogEntry parse(String xmlString) throws LogParseException {
  LogEntry retVal=null;
  byte[] bytesArray=xmlString.getBytes();
  VTDGen vg=null;
  try {
    try {
      vg=new VTDGen();
      vg.setDoc(bytesArray);
      vg.parse(false);
    }
 catch (    Exception e) {
      vg.clear();
      xmlString=XmlNormalizer.normalizeXMLEmbeddedTextOnly(xmlString);
      bytesArray=xmlString.getBytes();
      vg.setDoc(xmlString.getBytes());
      vg.parse(false);
    }
    retVal=makeLogEntryFromParsedXML(vg,bytesArray,xmlString);
  }
 catch (  ParseException ex) {
    ex.printStackTrace();
    throw new LogParseException(""String_Node_Str"",ex);
  }
  return retVal;
}",0.9634703196347032
135041,"/** 
 * Implements required method of ACSLogParser interface.
 * @param xmlString the XML string to parse
 * @throws LogParseException when problems are encountered parsing an XML message.
 * @see ACSLogParser
 */
public ILogEntry parse(String xmlString) throws LogParseException {
  LogEntry retVal=null;
  byte[] bytesArray=xmlString.getBytes();
  VTDGen vg=null;
  try {
    try {
      vg=new VTDGen();
      vg.setDoc(bytesArray);
      vg.parse(false);
    }
 catch (    Exception e) {
      vg.clear();
      String newLogString=XmlNormalizer.normalizeXMLEmbeddedTextOnly(xmlString);
      vg.setDoc(newLogString.getBytes());
      vg.parse(false);
    }
    retVal=makeLogEntryFromParsedXML(vg,bytesArray,xmlString);
  }
 catch (  ParseException ex) {
    ex.printStackTrace();
    throw new LogParseException(""String_Node_Str"",ex);
  }
  return retVal;
}","/** 
 * Implements required method of ACSLogParser interface.
 * @param xmlString the XML string to parse
 * @throws LogParseException when problems are encountered parsing an XML message.
 * @see ACSLogParser
 */
public ILogEntry parse(String xmlString) throws LogParseException {
  LogEntry retVal=null;
  byte[] bytesArray=xmlString.getBytes();
  VTDGen vg=null;
  try {
    try {
      vg=new VTDGen();
      vg.setDoc(bytesArray);
      vg.parse(false);
    }
 catch (    Exception e) {
      vg.clear();
      xmlString=XmlNormalizer.normalizeXMLEmbeddedTextOnly(xmlString);
      bytesArray=xmlString.getBytes();
      vg.setDoc(xmlString.getBytes());
      vg.parse(false);
    }
    retVal=makeLogEntryFromParsedXML(vg,bytesArray,xmlString);
  }
 catch (  ParseException ex) {
    ex.printStackTrace();
    throw new LogParseException(""String_Node_Str"",ex);
  }
  return retVal;
}",0.9634703196347032
135042,"/** 
 * Implements required method of ACSLogParser interface.
 * @param xmlString the XML string to parse
 * @throws LogParseException when problems are encountered parsing an XML message.
 * @see ACSLogParser
 */
public ILogEntry parse(String xmlString) throws LogParseException {
  LogEntry retVal=null;
  byte[] bytesArray=xmlString.getBytes();
  VTDGen vg=null;
  try {
    try {
      vg=new VTDGen();
      vg.setDoc(bytesArray);
      vg.parse(false);
    }
 catch (    Exception e) {
      vg.clear();
      String newLogString=XmlNormalizer.normalizeXMLEmbeddedTextOnly(xmlString);
      vg.setDoc(newLogString.getBytes());
      vg.parse(false);
    }
    retVal=makeLogEntryFromParsedXML(vg,bytesArray,xmlString);
  }
 catch (  ParseException ex) {
    ex.printStackTrace();
    throw new LogParseException(""String_Node_Str"",ex);
  }
  return retVal;
}","/** 
 * Implements required method of ACSLogParser interface.
 * @param xmlString the XML string to parse
 * @throws LogParseException when problems are encountered parsing an XML message.
 * @see ACSLogParser
 */
public ILogEntry parse(String xmlString) throws LogParseException {
  LogEntry retVal=null;
  byte[] bytesArray=xmlString.getBytes();
  VTDGen vg=null;
  try {
    try {
      vg=new VTDGen();
      vg.setDoc(bytesArray);
      vg.parse(false);
    }
 catch (    Exception e) {
      vg.clear();
      xmlString=XmlNormalizer.normalizeXMLEmbeddedTextOnly(xmlString);
      bytesArray=xmlString.getBytes();
      vg.setDoc(xmlString.getBytes());
      vg.parse(false);
    }
    retVal=makeLogEntryFromParsedXML(vg,bytesArray,xmlString);
  }
 catch (  ParseException ex) {
    ex.printStackTrace();
    throw new LogParseException(""String_Node_Str"",ex);
  }
  return retVal;
}",0.9634703196347032
135043,"/** 
 * The thread for async long lasting op. At the end of each operation, it check if there are new logs to add in the buffer Vector. The ordering of logs is not performed in mutual exclusion i.e. other methods like add and setLogOrder will not hang.
 */
public void run(){
  LogOperationRequest request=null;
  AddLogItem item=null;
  while (true) {
synchronized (asyncOps) {
      if (asyncOps.size() > 0) {
        request=asyncOps.get(0);
      }
 else {
        request=null;
      }
    }
    if (request != null) {
      if (request.getType() == LogOperationRequest.TERMINATE) {
        return;
      }
 else {
        sort(request.getOrderingField(),request.orderDirection());
        LoggingClient.getInstance().getLogEntryTable().getTableHeader().setEnabled(true);
        LoggingClient.getInstance().getLogEntryTable().getTableHeader().resizeAndRepaint();
      }
    }
synchronized (buffer) {
      while (buffer.size() > 0) {
        item=buffer.remove(0);
        addLogToVector(item.index,item.log);
      }
    }
    if (request != null) {
synchronized (asyncOps) {
        asyncOps.remove(0);
      }
    }
synchronized (this) {
      if (asyncOps.size() == 0 && buffer.size() == 0) {
        try {
          wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
}","/** 
 * The thread for async long lasting op. At the end of each operation, it check if there are new logs to add in the buffer Vector. The ordering of logs is not performed in mutual exclusion i.e. other methods like add and setLogOrder will not hang.
 */
public void run(){
  LogOperationRequest request=null;
  AddLogItem item=null;
  while (true) {
synchronized (asyncOps) {
      if (asyncOps.size() > 0) {
        request=asyncOps.get(0);
      }
 else {
        request=null;
      }
    }
    if (request != null) {
      if (request.getType() == LogOperationRequest.TERMINATE) {
        return;
      }
 else {
        LoggingClient.getInstance().getLogEntryTable().getTableHeader().setEnabled(false);
        LoggingClient.getInstance().setEnabledGUIControls(false);
        sort(request.getOrderingField(),request.orderDirection());
        LoggingClient.getInstance().getLogEntryTable().getTableHeader().setEnabled(true);
        LoggingClient.getInstance().setEnabledGUIControls(true);
        LoggingClient.getInstance().getLogEntryTable().getTableHeader().resizeAndRepaint();
      }
    }
synchronized (buffer) {
      while (buffer.size() > 0) {
        item=buffer.remove(0);
        addLogToVector(item.index,item.log);
      }
    }
    if (request != null) {
synchronized (asyncOps) {
        asyncOps.remove(0);
      }
    }
synchronized (this) {
      if (asyncOps.size() == 0 && buffer.size() == 0) {
        try {
          wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
}",0.8753501400560224
135044,"/** 
 * When the logs are ordered by entry type, it finds the position in the ordered list where the log has to be inserted. The algoritm has logaritmic complexity
 * @param The entry type of the log to be inserted
 * @return The position log to insert in the visible logs
 */
private int findPosLogarthmicType(int type){
  int minInter=0;
  int maxInter=visibleLogs.size() - 1;
  int middle=0;
  int maxType;
  int minType;
  boolean sortAscending=comparator.isSortAscending();
  do {
    maxType=cache.getLogType(maxInter);
    minType=cache.getLogType(minInter);
    if (maxInter - minInter <= 1) {
      if (sortAscending) {
        if (type > maxType) {
          return maxInter + 1;
        }
 else         if (type < minType) {
          return minInter;
        }
 else {
          return maxInter;
        }
      }
 else {
        if (type > minType) {
          return minInter;
        }
 else         if (type < maxType) {
          return maxInter + 1;
        }
 else {
          return maxInter;
        }
      }
    }
    middle=minInter + (maxInter - minInter) / 2;
    long typeShift=type - cache.getLogType(middle);
    if (sortAscending) {
      if (typeShift > 0) {
        minInter=middle;
        continue;
      }
 else       if (typeShift < 0) {
        maxInter=middle;
        continue;
      }
 else {
        return middle;
      }
    }
 else {
      if (typeShift > 0) {
        maxInter=middle;
        continue;
      }
 else       if (typeShift < 0) {
        minInter=middle;
        continue;
      }
 else {
        return middle;
      }
    }
  }
 while (true);
}","/** 
 * When the logs are ordered by entry type, it finds the position in the ordered list where the log has to be inserted. The algoritm has logaritmic complexity
 * @param The entry type of the log to be inserted
 * @return The position log to insert in the visible logs
 */
private int findPosLogarthmicType(int type){
  int minInter=0;
  int maxInter=visibleLogs.size() - 1;
  int middle=0;
  int maxType;
  int minType;
  boolean sortAscending=comparator.isSortAscending();
  do {
    maxType=cache.getLogType(visibleLogs.get(maxInter));
    minType=cache.getLogType(visibleLogs.get(minInter));
    if (maxInter - minInter <= 1) {
      if (sortAscending) {
        if (type > maxType) {
          return maxInter + 1;
        }
 else         if (type < minType) {
          return minInter;
        }
 else {
          return maxInter;
        }
      }
 else {
        if (type > minType) {
          return minInter;
        }
 else         if (type < maxType) {
          return maxInter + 1;
        }
 else {
          return maxInter;
        }
      }
    }
    middle=minInter + (maxInter - minInter) / 2;
    int typeShift=type - cache.getLogType(visibleLogs.get(middle));
    if (sortAscending) {
      if (typeShift >= 0) {
        minInter=middle;
        continue;
      }
 else {
        maxInter=middle;
        continue;
      }
    }
 else {
      if (typeShift >= 0) {
        maxInter=middle;
        continue;
      }
 else       if (typeShift < 0) {
        minInter=middle;
        continue;
      }
    }
  }
 while (true);
}",0.8274770496992719
135045,"/** 
 * When the logs are ordered by timestamp, it finds the position in the ordered list where the log has to be inserted. The algoritm has logaritmic complexity param The timestamp of the log to be inserted
 * @return The position log to insert in the visible logs
 */
private int findPosLogarthmicDate(long date){
  int minInter=0;
  int maxInter=visibleLogs.size() - 1;
  int middle=0;
  long maxDate=-1;
  long minDate=-1;
  boolean sortAscending=comparator.isSortAscending();
  do {
    maxDate=cache.getLogTimestamp(maxInter);
    minDate=cache.getLogTimestamp(minInter);
    if (maxInter - minInter <= 1) {
      if (sortAscending) {
        if (date > maxDate) {
          return maxInter + 1;
        }
 else         if (date < minDate) {
          return minInter;
        }
 else {
          return maxInter;
        }
      }
 else {
        if (date > minDate) {
          return minInter;
        }
 else         if (date < maxDate) {
          return maxInter + 1;
        }
 else {
          return maxInter;
        }
      }
    }
    middle=minInter + (maxInter - minInter) / 2;
    long dateShift=date - cache.getLogTimestamp(middle);
    if (sortAscending) {
      if (dateShift >= 0) {
        minInter=middle;
        continue;
      }
 else       if (dateShift < 0) {
        maxInter=middle;
        continue;
      }
    }
 else {
      if (dateShift >= 0) {
        maxInter=middle;
        continue;
      }
 else       if (dateShift < 0) {
        minInter=middle;
        continue;
      }
    }
  }
 while (true);
}","/** 
 * When the logs are ordered by entry type, it finds the position in the ordered list where the log has to be inserted. The algoritm has logaritmic complexity
 * @param The entry type of the log to be inserted
 * @return The position log to insert in the visible logs
 */
private int findPosLogarthmicDate(long date){
  int minInter=0;
  int maxInter=visibleLogs.size() - 1;
  int middle=0;
  long maxDate;
  long minDate;
  boolean sortAscending=comparator.isSortAscending();
  int iter=0;
  do {
    maxDate=cache.getLogTimestamp(visibleLogs.get(maxInter));
    minDate=cache.getLogTimestamp(visibleLogs.get(minInter));
    if (maxInter - minInter <= 1) {
      if (sortAscending) {
        if (date >= maxDate) {
          return maxInter + 1;
        }
 else         if (date < minDate) {
          return minInter;
        }
 else {
          return maxInter;
        }
      }
 else {
        if (date >= minDate) {
          return minInter;
        }
 else         if (date >= maxDate) {
          return maxInter;
        }
 else {
          return maxInter + 1;
        }
      }
    }
    middle=minInter + (maxInter - minInter) / 2;
    long dateShift=date - cache.getLogTimestamp(visibleLogs.get(middle));
    if (sortAscending) {
      if (dateShift >= 0) {
        minInter=middle;
        continue;
      }
 else {
        maxInter=middle;
        continue;
      }
    }
 else {
      if (dateShift >= 0) {
        maxInter=middle;
        continue;
      }
 else {
        minInter=middle;
        continue;
      }
    }
  }
 while (true);
}",0.6863753213367609
135046,"/** 
 * Compare the entries with the given position in the cache It works only for TIMESTAMP and ENTRYTYPE because the cache has two arrays and there is no need to load the log
 * @param fisrt The index of the first item to compare
 * @param second The index of the second item to compare
 * @return 
 */
private int fastCompare(int first,int second){
  long firstVal;
  long secondVal;
  if (fieldIndex == ILogEntry.FIELD_TIMESTAMP) {
    firstVal=(Long)cache.getLogTimestamp(first);
    secondVal=(Long)cache.getLogTimestamp(second);
  }
 else {
    firstVal=(Integer)cache.getLogType(first);
    secondVal=(Integer)cache.getLogType(second);
  }
  if (firstVal == secondVal) {
    return 0;
  }
  int ret=(secondVal > firstVal) ? 1 : 1;
  if (sortAscending) {
    return -1 * ret;
  }
 else {
    return ret;
  }
}","/** 
 * Compare the entries with the given position in the cache It works only for TIMESTAMP and ENTRYTYPE because the cache has two arrays and there is no need to load the log
 * @param fisrt The index of the first item to compare
 * @param second The index of the second item to compare
 * @return 
 */
private int fastCompare(int first,int second){
  long firstVal;
  long secondVal;
  if (fieldIndex == ILogEntry.FIELD_TIMESTAMP) {
    firstVal=(Long)cache.getLogTimestamp(first);
    secondVal=(Long)cache.getLogTimestamp(second);
  }
 else {
    firstVal=(Integer)cache.getLogType(first);
    secondVal=(Integer)cache.getLogType(second);
  }
  if (firstVal == secondVal) {
    return 0;
  }
  int ret=(secondVal > firstVal) ? 1 : -1;
  if (sortAscending) {
    return -1 * ret;
  }
 else {
    return ret;
  }
}",0.9540722596448254
135047,"/** 
 * Append a log to the end of the cache
 * @param log The log to append in the cache
 * @return The position in the cache of the added log
 */
public int add(ILogEntry log) throws LogCacheException {
  return wBuffer.addLog(log);
}","/** 
 * Append a log to the end of the cache
 * @param log The log to append in the cache
 * @return The position in the cache of the added log
 */
public synchronized int add(ILogEntry log) throws LogCacheException {
  return wBuffer.addLog(log);
}",0.9731958762886598
135048,"/** 
 * Flush the buffer on disk
 */
private void flushBuffer() throws LogCacheException {
  String logsStr=charBuffer.toString();
  long pos;
synchronized (fileOfLogs) {
    try {
      pos=fileOfLogs.length();
      fileOfLogs.seek(fileOfLogs.length());
      fileOfLogs.writeBytes(logsStr);
    }
 catch (    IOException ioe) {
      throw new LogCacheException(""String_Node_Str"",ioe);
    }
  }
synchronized (index) {
    for (int t=0; t < bufferIndex.size(); t++) {
      index.add(pos + bufferIndex.get(t));
    }
  }
  charBuffer.delete(0,charBuffer.length());
  bufferIndex.clear();
  writeBuffer.clear();
}","/** 
 * Flush the buffer on disk
 */
private synchronized void flushBuffer() throws LogCacheException {
  String logsStr=charBuffer.toString();
  long pos;
synchronized (fileOfLogs) {
    try {
      pos=fileOfLogs.length();
      fileOfLogs.seek(fileOfLogs.length());
      fileOfLogs.writeBytes(logsStr);
    }
 catch (    IOException ioe) {
      throw new LogCacheException(""String_Node_Str"",ioe);
    }
  }
synchronized (index) {
    for (int t=0; t < bufferIndex.size(); t++) {
      index.add(pos + bufferIndex.get(t));
    }
  }
  charBuffer.delete(0,charBuffer.length());
  bufferIndex.clear();
  writeBuffer.clear();
}",0.989541432019308
135049,"/** 
 * Return the log in the given position
 * @param pos The position of the log
 * @return The LogEntryXML or null in case of error
 */
public ILogEntry getLog(int pos) throws LogCacheException {
  if (replacedLogs.containsKey(new Integer(pos))) {
    return replacedLogs.get(new Integer(pos));
  }
  if (pos >= index.size()) {
    return wBuffer.getLog(pos);
  }
 else   return super.getLog(pos);
}","/** 
 * Return the log in the given position
 * @param pos The position of the log
 * @return The LogEntryXML or null in case of error
 */
public synchronized ILogEntry getLog(int pos) throws LogCacheException {
  if (replacedLogs.containsKey(new Integer(pos))) {
    return replacedLogs.get(new Integer(pos));
  }
  if (pos >= index.size()) {
    return wBuffer.getLog(pos);
  }
 else   return super.getLog(pos);
}",0.9840881272949816
135050,"/** 
 * Empty the cache 
 * @param newFile If true the cache allocates a new file for storing the logs
 * @param keepOldFile If true the old file for the cache is not deleted
 * @throws IOException
 */
public void clear(boolean newFile,boolean keepOldFile) throws LogCacheException {
  super.clear(newFile,keepOldFile);
  wBuffer.clear(file,index);
}","/** 
 * Empty the cache 
 * @param newFile If true the cache allocates a new file for storing the logs
 * @param keepOldFile If true the old file for the cache is not deleted
 * @throws IOException
 */
public synchronized void clear(boolean newFile,boolean keepOldFile) throws LogCacheException {
  super.clear(newFile,keepOldFile);
  wBuffer.clear(file,index);
}",0.9817671809256662
135051,"/** 
 * Append a log to the end of the cache
 * @param log The log to append in the cache
 * @return The position in the cache of the added log
 */
public int add(ILogEntry log) throws LogCacheException {
  return wBuffer.addLog(log);
}","/** 
 * Append a log to the end of the cache
 * @param log The log to append in the cache
 * @return The position in the cache of the added log
 */
public synchronized int add(ILogEntry log) throws LogCacheException {
  return wBuffer.addLog(log);
}",0.9731958762886598
135052,"/** 
 * Flush the buffer on disk
 */
private void flushBuffer() throws LogCacheException {
  String logsStr=charBuffer.toString();
  long pos;
synchronized (fileOfLogs) {
    try {
      pos=fileOfLogs.length();
      fileOfLogs.seek(fileOfLogs.length());
      fileOfLogs.writeBytes(logsStr);
    }
 catch (    IOException ioe) {
      throw new LogCacheException(""String_Node_Str"",ioe);
    }
  }
synchronized (index) {
    for (int t=0; t < bufferIndex.size(); t++) {
      index.add(pos + bufferIndex.get(t));
    }
  }
  charBuffer.delete(0,charBuffer.length());
  bufferIndex.clear();
  writeBuffer.clear();
}","/** 
 * Flush the buffer on disk
 */
private synchronized void flushBuffer() throws LogCacheException {
  String logsStr=charBuffer.toString();
  long pos;
synchronized (fileOfLogs) {
    try {
      pos=fileOfLogs.length();
      fileOfLogs.seek(fileOfLogs.length());
      fileOfLogs.writeBytes(logsStr);
    }
 catch (    IOException ioe) {
      throw new LogCacheException(""String_Node_Str"",ioe);
    }
  }
synchronized (index) {
    for (int t=0; t < bufferIndex.size(); t++) {
      index.add(pos + bufferIndex.get(t));
    }
  }
  charBuffer.delete(0,charBuffer.length());
  bufferIndex.clear();
  writeBuffer.clear();
}",0.989541432019308
135053,"/** 
 * Return the log in the given position
 * @param pos The position of the log
 * @return The LogEntryXML or null in case of error
 */
public ILogEntry getLog(int pos) throws LogCacheException {
  if (replacedLogs.containsKey(new Integer(pos))) {
    return replacedLogs.get(new Integer(pos));
  }
  if (pos >= index.size()) {
    return wBuffer.getLog(pos);
  }
 else   return super.getLog(pos);
}","/** 
 * Return the log in the given position
 * @param pos The position of the log
 * @return The LogEntryXML or null in case of error
 */
public synchronized ILogEntry getLog(int pos) throws LogCacheException {
  if (replacedLogs.containsKey(new Integer(pos))) {
    return replacedLogs.get(new Integer(pos));
  }
  if (pos >= index.size()) {
    return wBuffer.getLog(pos);
  }
 else   return super.getLog(pos);
}",0.9840881272949816
135054,"/** 
 * Empty the cache 
 * @param newFile If true the cache allocates a new file for storing the logs
 * @param keepOldFile If true the old file for the cache is not deleted
 * @throws IOException
 */
public void clear(boolean newFile,boolean keepOldFile) throws LogCacheException {
  super.clear(newFile,keepOldFile);
  wBuffer.clear(file,index);
}","/** 
 * Empty the cache 
 * @param newFile If true the cache allocates a new file for storing the logs
 * @param keepOldFile If true the old file for the cache is not deleted
 * @throws IOException
 */
public synchronized void clear(boolean newFile,boolean keepOldFile) throws LogCacheException {
  super.clear(newFile,keepOldFile);
  wBuffer.clear(file,index);
}",0.9817671809256662
135055,"/** 
 * Append a log to the end of the cache
 * @param log The log to append in the cache
 * @return The position in the cache of the added log
 */
public int add(ILogEntry log) throws LogCacheException {
  return wBuffer.addLog(log);
}","/** 
 * Append a log to the end of the cache
 * @param log The log to append in the cache
 * @return The position in the cache of the added log
 */
public synchronized int add(ILogEntry log) throws LogCacheException {
  return wBuffer.addLog(log);
}",0.9731958762886598
135056,"/** 
 * Flush the buffer on disk
 */
private void flushBuffer() throws LogCacheException {
  String logsStr=charBuffer.toString();
  long pos;
synchronized (fileOfLogs) {
    try {
      pos=fileOfLogs.length();
      fileOfLogs.seek(fileOfLogs.length());
      fileOfLogs.writeBytes(logsStr);
    }
 catch (    IOException ioe) {
      throw new LogCacheException(""String_Node_Str"",ioe);
    }
  }
synchronized (index) {
    for (int t=0; t < bufferIndex.size(); t++) {
      index.add(pos + bufferIndex.get(t));
    }
  }
  charBuffer.delete(0,charBuffer.length());
  bufferIndex.clear();
  writeBuffer.clear();
}","/** 
 * Flush the buffer on disk
 */
private synchronized void flushBuffer() throws LogCacheException {
  String logsStr=charBuffer.toString();
  long pos;
synchronized (fileOfLogs) {
    try {
      pos=fileOfLogs.length();
      fileOfLogs.seek(fileOfLogs.length());
      fileOfLogs.writeBytes(logsStr);
    }
 catch (    IOException ioe) {
      throw new LogCacheException(""String_Node_Str"",ioe);
    }
  }
synchronized (index) {
    for (int t=0; t < bufferIndex.size(); t++) {
      index.add(pos + bufferIndex.get(t));
    }
  }
  charBuffer.delete(0,charBuffer.length());
  bufferIndex.clear();
  writeBuffer.clear();
}",0.989541432019308
135057,"/** 
 * Return the log in the given position
 * @param pos The position of the log
 * @return The LogEntryXML or null in case of error
 */
public ILogEntry getLog(int pos) throws LogCacheException {
  if (replacedLogs.containsKey(new Integer(pos))) {
    return replacedLogs.get(new Integer(pos));
  }
  if (pos >= index.size()) {
    return wBuffer.getLog(pos);
  }
 else   return super.getLog(pos);
}","/** 
 * Return the log in the given position
 * @param pos The position of the log
 * @return The LogEntryXML or null in case of error
 */
public synchronized ILogEntry getLog(int pos) throws LogCacheException {
  if (replacedLogs.containsKey(new Integer(pos))) {
    return replacedLogs.get(new Integer(pos));
  }
  if (pos >= index.size()) {
    return wBuffer.getLog(pos);
  }
 else   return super.getLog(pos);
}",0.9840881272949816
135058,"/** 
 * Empty the cache 
 * @param newFile If true the cache allocates a new file for storing the logs
 * @param keepOldFile If true the old file for the cache is not deleted
 * @throws IOException
 */
public void clear(boolean newFile,boolean keepOldFile) throws LogCacheException {
  super.clear(newFile,keepOldFile);
  wBuffer.clear(file,index);
}","/** 
 * Empty the cache 
 * @param newFile If true the cache allocates a new file for storing the logs
 * @param keepOldFile If true the old file for the cache is not deleted
 * @throws IOException
 */
public synchronized void clear(boolean newFile,boolean keepOldFile) throws LogCacheException {
  super.clear(newFile,keepOldFile);
  wBuffer.clear(file,index);
}",0.9817671809256662
135059,"/** 
 * Method unpacks the RemoteResponse data and writes it into the ResultArea Creation date: (2/25/00 12:44:55 PM)
 */
public void reportRemoteResponse(RemoteResponse response){
  getJLabel3().setText(String.valueOf(response.getSequenceNumber()));
  getmessageField().setText(response.getName());
  if (enabled) {
    processChartValues(response);
    boolean errorResponse=response.isErrorResponse();
    String resultString=processResponse(response,errorResponse | isExpand());
    if (reportLength == -1) {
      reportLength=DataFormatter.getLineCount(resultString);
      editing=true;
      jTextField1_ActionPerformed();
    }
    if (getState() == java.awt.Frame.ICONIFIED) {
      minimText.append(resultString);
      if (minimTextReportCount > maxLines) {
        minimText.delete(0,resultString.length());
      }
 else       minimTextReportCount++;
    }
 else {
      SmartTextPane resultArea=getReportArea();
      try {
        if (errorResponse) {
          resultArea.setCaretPosition(resultArea.getText().length());
          resultArea.setLogicalStyle(redStyle);
        }
        getReportArea().append(resultString);
        if (errorResponse)         resultArea.append(""String_Node_Str"");
      }
  finally {
        resultArea.setLogicalStyle(blackStyle);
      }
    }
  }
}","/** 
 * Method unpacks the RemoteResponse data and writes it into the ResultArea Creation date: (2/25/00 12:44:55 PM)
 */
public void reportRemoteResponse(RemoteResponse response){
  getJLabel3().setText(String.valueOf(response.getSequenceNumber()));
  getmessageField().setText(response.getName());
  if (enabled) {
    processChartValues(response);
    boolean errorResponse=response.isErrorResponse();
    String resultString=processResponse(response,errorResponse | isExpand());
    if (reportLength == -1) {
      reportLength=DataFormatter.getLineCount(resultString);
      editing=true;
      jTextField1_ActionPerformed();
    }
    if (getState() == java.awt.Frame.ICONIFIED) {
      minimText.append(resultString);
      if (minimTextReportCount > maxLines) {
        minimText.delete(0,resultString.length());
      }
 else       minimTextReportCount++;
    }
 else {
      SmartTextPane resultArea=getReportArea();
      try {
        if (errorResponse) {
          resultArea.setCaretPosition(resultArea.getText().length());
          resultArea.setLogicalStyle(redStyle);
        }
        resultArea.append(resultString);
        if (errorResponse)         resultArea.append(""String_Node_Str"");
      }
  finally {
        resultArea.setLogicalStyle(blackStyle);
      }
    }
  }
}",0.9942285494420932
135060,"/** 
 * Return the ReportArea property value.
 * @return com.cosylab.gui.components.SmartTextArea
 */
private SmartTextPane getReportArea(){
  if (ivjReportArea == null) {
    try {
      ivjReportArea=new SmartTextPane();
      ivjReportArea.setName(""String_Node_Str"");
      ivjReportArea.setMaxLines(1000);
      ivjReportArea.setLocation(0,0);
      blackStyle=ivjReportArea.getLogicalStyle();
      redStyle=ivjReportArea.addStyle(""String_Node_Str"",null);
      StyleConstants.setForeground(redStyle,Color.red);
      ivjReportArea.setEnabled(false);
    }
 catch (    java.lang.Throwable ivjExc) {
      handleException(ivjExc);
    }
  }
  return ivjReportArea;
}","/** 
 * Return the ReportArea property value.
 * @return com.cosylab.gui.components.SmartTextArea
 */
private SmartTextPane getReportArea(){
  if (ivjReportArea == null) {
    try {
      ivjReportArea=new SmartTextPane();
      ivjReportArea.setName(""String_Node_Str"");
      ivjReportArea.setMaxLines(1000);
      ivjReportArea.setLocation(0,0);
      blackStyle=ivjReportArea.getLogicalStyle();
      redStyle=ivjReportArea.addStyle(""String_Node_Str"",null);
      StyleConstants.setForeground(redStyle,Color.red);
    }
 catch (    java.lang.Throwable ivjExc) {
      handleException(ivjExc);
    }
  }
  return ivjReportArea;
}",0.970023059185242
135061,"/** 
 * Method unpacks the RemoteResponse data and writes it into the ResultArea Creation date: (2/25/00 12:44:55 PM)
 */
public void reportRemoteResponse(RemoteResponse response){
  getJLabel3().setText(String.valueOf(response.getSequenceNumber()));
  getmessageField().setText(response.getName());
  if (enabled) {
    processChartValues(response);
    boolean errorResponse=response.isErrorResponse();
    String resultString=processResponse(response,errorResponse | isExpand());
    if (reportLength == -1) {
      reportLength=DataFormatter.getLineCount(resultString);
      editing=true;
      jTextField1_ActionPerformed();
    }
    if (getState() == java.awt.Frame.ICONIFIED) {
      minimText.append(resultString);
      if (minimTextReportCount > maxLines) {
        minimText.delete(0,resultString.length());
      }
 else       minimTextReportCount++;
    }
 else {
      SmartTextPane resultArea=getReportArea();
      try {
        if (errorResponse) {
          resultArea.setCaretPosition(resultArea.getText().length());
          resultArea.setLogicalStyle(redStyle);
        }
        getReportArea().append(resultString);
        if (errorResponse)         resultArea.append(""String_Node_Str"");
      }
  finally {
        resultArea.setLogicalStyle(blackStyle);
      }
    }
  }
}","/** 
 * Method unpacks the RemoteResponse data and writes it into the ResultArea Creation date: (2/25/00 12:44:55 PM)
 */
public void reportRemoteResponse(RemoteResponse response){
  getJLabel3().setText(String.valueOf(response.getSequenceNumber()));
  getmessageField().setText(response.getName());
  if (enabled) {
    processChartValues(response);
    boolean errorResponse=response.isErrorResponse();
    String resultString=processResponse(response,errorResponse | isExpand());
    if (reportLength == -1) {
      reportLength=DataFormatter.getLineCount(resultString);
      editing=true;
      jTextField1_ActionPerformed();
    }
    if (getState() == java.awt.Frame.ICONIFIED) {
      minimText.append(resultString);
      if (minimTextReportCount > maxLines) {
        minimText.delete(0,resultString.length());
      }
 else       minimTextReportCount++;
    }
 else {
      SmartTextPane resultArea=getReportArea();
      try {
        if (errorResponse) {
          resultArea.setCaretPosition(resultArea.getText().length());
          resultArea.setLogicalStyle(redStyle);
        }
        resultArea.append(resultString);
        if (errorResponse)         resultArea.append(""String_Node_Str"");
      }
  finally {
        resultArea.setLogicalStyle(blackStyle);
      }
    }
  }
}",0.9942285494420932
135062,"/** 
 * Return the ReportArea property value.
 * @return com.cosylab.gui.components.SmartTextArea
 */
private SmartTextPane getReportArea(){
  if (ivjReportArea == null) {
    try {
      ivjReportArea=new SmartTextPane();
      ivjReportArea.setName(""String_Node_Str"");
      ivjReportArea.setMaxLines(1000);
      ivjReportArea.setLocation(0,0);
      blackStyle=ivjReportArea.getLogicalStyle();
      redStyle=ivjReportArea.addStyle(""String_Node_Str"",null);
      StyleConstants.setForeground(redStyle,Color.red);
      ivjReportArea.setEnabled(false);
    }
 catch (    java.lang.Throwable ivjExc) {
      handleException(ivjExc);
    }
  }
  return ivjReportArea;
}","/** 
 * Return the ReportArea property value.
 * @return com.cosylab.gui.components.SmartTextArea
 */
private SmartTextPane getReportArea(){
  if (ivjReportArea == null) {
    try {
      ivjReportArea=new SmartTextPane();
      ivjReportArea.setName(""String_Node_Str"");
      ivjReportArea.setMaxLines(1000);
      ivjReportArea.setLocation(0,0);
      blackStyle=ivjReportArea.getLogicalStyle();
      redStyle=ivjReportArea.addStyle(""String_Node_Str"",null);
      StyleConstants.setForeground(redStyle,Color.red);
    }
 catch (    java.lang.Throwable ivjExc) {
      handleException(ivjExc);
    }
  }
  return ivjReportArea;
}",0.970023059185242
135063,"/** 
 * Prints usage information.
 */
protected void usage(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
}","/** 
 * Prints usage information.
 */
protected static void usage(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
}",0.9932367149758454
135064,"/** 
 * The method executes the search for both the public overloaded  find methods.
 * @param regExp The regular expression to look for in the logsnull if the method search for a string 
 * @param searchString The string to look for in the logsnull if the method search for a reg exp
 * @param caseSensitive If true performs a CaseSensitive searchIgnored for reg exp searchs (it is coded in the Pattern)
 * @param wholeWord If true look for the whole word int the columnIgnored for reg exp searchs
 * @param forwardSearch If true search forward otherwise backward
 * @param cols The columns of each log tool for the string
 * @return -1 if no log is found otherwise the row containing the string/reg exp
 */
private int find(Pattern regExp,String searchString,boolean caseSensitive,boolean wholeWord,boolean forwardSearch,boolean[] cols){
  int startingRow=getStartingRow(forwardSearch);
  int endRow=(forwardSearch) ? logEntryTable.getRowCount() - 1 : 0;
  FieldPosition pos=new java.text.FieldPosition(0);
  StringBuffer tempSB=new StringBuffer();
  int cursor=startingRow;
  if (endRow < startingRow) {
    int temp=startingRow;
    startingRow=endRow;
    endRow=temp;
  }
  int foundRow=-1;
  while (cursor >= startingRow && cursor <= endRow && foundRow == -1) {
    ILogEntry log=logTableDataModel.getVisibleLogEntry(cursor);
    String string=null;
    for (int t=0; t < cols.length - 1; t++) {
      Object obj=log.getField(t);
      if (obj == null) {
        continue;
      }
      if (cols[t]) {
switch (t) {
case ILogEntry.FIELD_TIMESTAMP:
{
            SimpleDateFormat df=new SimpleDateFormat(ILogEntry.TIME_FORMAT);
            Date dt=(Date)obj;
            tempSB.delete(0,tempSB.length());
            df.format(dt,tempSB,pos);
            string=tempSB.toString();
            break;
          }
case ILogEntry.FIELD_ENTRYTYPE:
case ILogEntry.FIELD_LINE:
case ILogEntry.FIELD_PRIORITY:
case ILogEntry.FIELD_STACKLEVEL:
{
          string=""String_Node_Str"" + ILogEntry.FIELD_ENTRYTYPE;
          break;
        }
default :
{
        string=obj.toString();
        break;
      }
  }
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (cols[cols.length - 1] && log.hasDatas()) {
Vector<ILogEntry.AdditionalData> addData=log.getAdditionalData();
for (int t=0; t < addData.size(); t++) {
  ILogEntry.AdditionalData data=addData.elementAt(t);
  string=data.getName();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
  string=data.getValue();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (forwardSearch) {
cursor++;
}
 else {
cursor--;
}
}
return foundRow;
}","/** 
 * The method executes the search for both the public overloaded  find methods.
 * @param regExp The regular expression to look for in the logsnull if the method search for a string 
 * @param searchString The string to look for in the logsnull if the method search for a reg exp
 * @param caseSensitive If true performs a CaseSensitive searchIgnored for reg exp searchs (it is coded in the Pattern)
 * @param wholeWord If true look for the whole word int the columnIgnored for reg exp searchs
 * @param forwardSearch If true search forward otherwise backward
 * @param cols The columns of each log tool for the string
 * @return -1 if no log is found otherwise the row containing the string/reg exp
 */
private int find(Pattern regExp,String searchString,boolean caseSensitive,boolean wholeWord,boolean forwardSearch,boolean[] cols){
  int startingRow=getStartingRow(forwardSearch);
  int endRow=(forwardSearch) ? logEntryTable.getRowCount() - 1 : 0;
  FieldPosition pos=new java.text.FieldPosition(0);
  StringBuffer tempSB=new StringBuffer();
  int cursor=startingRow;
  if (endRow < startingRow) {
    int temp=startingRow;
    startingRow=endRow;
    endRow=temp;
  }
  int foundRow=-1;
  while (cursor >= startingRow && cursor <= endRow && foundRow == -1) {
    ILogEntry log=logTableDataModel.getVisibleLogEntry(cursor);
    String string=null;
    for (int t=0; t < cols.length - 1; t++) {
      Object obj=log.getField(t);
      if (obj == null) {
        continue;
      }
      if (cols[t]) {
switch (t) {
case ILogEntry.FIELD_TIMESTAMP:
{
            SimpleDateFormat df=new SimpleDateFormat(ILogEntry.TIME_FORMAT);
            Date dt=(Date)obj;
            tempSB.delete(0,tempSB.length());
            df.format(dt,tempSB,pos);
            string=tempSB.toString();
            break;
          }
case ILogEntry.FIELD_ENTRYTYPE:
case ILogEntry.FIELD_LINE:
case ILogEntry.FIELD_PRIORITY:
case ILogEntry.FIELD_STACKLEVEL:
{
          string=obj.toString();
          break;
        }
default :
{
        string=obj.toString();
        break;
      }
  }
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (cols[cols.length - 1] && log.hasDatas()) {
Vector<ILogEntry.AdditionalData> addData=log.getAdditionalData();
for (int t=0; t < addData.size(); t++) {
  ILogEntry.AdditionalData data=addData.elementAt(t);
  string=data.getName();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
  string=data.getValue();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (forwardSearch) {
cursor++;
}
 else {
cursor--;
}
}
return foundRow;
}",0.9914657882916604
135065,"/** 
 * The method executes the search for both the public overloaded  find methods.
 * @param regExp The regular expression to look for in the logsnull if the method search for a string 
 * @param searchString The string to look for in the logsnull if the method search for a reg exp
 * @param caseSensitive If true performs a CaseSensitive searchIgnored for reg exp searchs (it is coded in the Pattern)
 * @param wholeWord If true look for the whole word int the columnIgnored for reg exp searchs
 * @param forwardSearch If true search forward otherwise backward
 * @param cols The columns of each log tool for the string
 * @return -1 if no log is found otherwise the row containing the string/reg exp
 */
private int find(Pattern regExp,String searchString,boolean caseSensitive,boolean wholeWord,boolean forwardSearch,boolean[] cols){
  int startingRow=getStartingRow(forwardSearch);
  int endRow=(forwardSearch) ? logEntryTable.getRowCount() - 1 : 0;
  FieldPosition pos=new java.text.FieldPosition(0);
  StringBuffer tempSB=new StringBuffer();
  int cursor=startingRow;
  if (endRow < startingRow) {
    int temp=startingRow;
    startingRow=endRow;
    endRow=temp;
  }
  int foundRow=-1;
  while (cursor >= startingRow && cursor <= endRow && foundRow == -1) {
    ILogEntry log=logTableDataModel.getVisibleLogEntry(cursor);
    String string=null;
    for (int t=0; t < cols.length - 1; t++) {
      Object obj=log.getField(t);
      if (obj == null) {
        continue;
      }
      if (cols[t]) {
switch (t) {
case ILogEntry.FIELD_TIMESTAMP:
{
            SimpleDateFormat df=new SimpleDateFormat(ILogEntry.TIME_FORMAT);
            Date dt=(Date)obj;
            tempSB.delete(0,tempSB.length());
            df.format(dt,tempSB,pos);
            string=tempSB.toString();
            break;
          }
case ILogEntry.FIELD_ENTRYTYPE:
case ILogEntry.FIELD_LINE:
case ILogEntry.FIELD_PRIORITY:
case ILogEntry.FIELD_STACKLEVEL:
{
          string=""String_Node_Str"" + ILogEntry.FIELD_ENTRYTYPE;
          break;
        }
default :
{
        string=obj.toString();
        break;
      }
  }
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (cols[cols.length - 1] && log.hasDatas()) {
Vector<ILogEntry.AdditionalData> addData=log.getAdditionalData();
for (int t=0; t < addData.size(); t++) {
  ILogEntry.AdditionalData data=addData.elementAt(t);
  string=data.getName();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
  string=data.getValue();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (forwardSearch) {
cursor++;
}
 else {
cursor--;
}
}
return foundRow;
}","/** 
 * The method executes the search for both the public overloaded  find methods.
 * @param regExp The regular expression to look for in the logsnull if the method search for a string 
 * @param searchString The string to look for in the logsnull if the method search for a reg exp
 * @param caseSensitive If true performs a CaseSensitive searchIgnored for reg exp searchs (it is coded in the Pattern)
 * @param wholeWord If true look for the whole word int the columnIgnored for reg exp searchs
 * @param forwardSearch If true search forward otherwise backward
 * @param cols The columns of each log tool for the string
 * @return -1 if no log is found otherwise the row containing the string/reg exp
 */
private int find(Pattern regExp,String searchString,boolean caseSensitive,boolean wholeWord,boolean forwardSearch,boolean[] cols){
  int startingRow=getStartingRow(forwardSearch);
  int endRow=(forwardSearch) ? logEntryTable.getRowCount() - 1 : 0;
  FieldPosition pos=new java.text.FieldPosition(0);
  StringBuffer tempSB=new StringBuffer();
  int cursor=startingRow;
  if (endRow < startingRow) {
    int temp=startingRow;
    startingRow=endRow;
    endRow=temp;
  }
  int foundRow=-1;
  while (cursor >= startingRow && cursor <= endRow && foundRow == -1) {
    ILogEntry log=logTableDataModel.getVisibleLogEntry(cursor);
    String string=null;
    for (int t=0; t < cols.length - 1; t++) {
      Object obj=log.getField(t);
      if (obj == null) {
        continue;
      }
      if (cols[t]) {
switch (t) {
case ILogEntry.FIELD_TIMESTAMP:
{
            SimpleDateFormat df=new SimpleDateFormat(ILogEntry.TIME_FORMAT);
            Date dt=(Date)obj;
            tempSB.delete(0,tempSB.length());
            df.format(dt,tempSB,pos);
            string=tempSB.toString();
            break;
          }
case ILogEntry.FIELD_ENTRYTYPE:
case ILogEntry.FIELD_LINE:
case ILogEntry.FIELD_PRIORITY:
case ILogEntry.FIELD_STACKLEVEL:
{
          string=obj.toString();
          break;
        }
default :
{
        string=obj.toString();
        break;
      }
  }
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (cols[cols.length - 1] && log.hasDatas()) {
Vector<ILogEntry.AdditionalData> addData=log.getAdditionalData();
for (int t=0; t < addData.size(); t++) {
  ILogEntry.AdditionalData data=addData.elementAt(t);
  string=data.getName();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
  string=data.getValue();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (forwardSearch) {
cursor++;
}
 else {
cursor--;
}
}
return foundRow;
}",0.9914657882916604
135066,"/** 
 * The method executes the search for both the public overloaded  find methods.
 * @param regExp The regular expression to look for in the logsnull if the method search for a string 
 * @param searchString The string to look for in the logsnull if the method search for a reg exp
 * @param caseSensitive If true performs a CaseSensitive searchIgnored for reg exp searchs (it is coded in the Pattern)
 * @param wholeWord If true look for the whole word int the columnIgnored for reg exp searchs
 * @param forwardSearch If true search forward otherwise backward
 * @param cols The columns of each log tool for the string
 * @return -1 if no log is found otherwise the row containing the string/reg exp
 */
private int find(Pattern regExp,String searchString,boolean caseSensitive,boolean wholeWord,boolean forwardSearch,boolean[] cols){
  int startingRow=getStartingRow(forwardSearch);
  int endRow=(forwardSearch) ? logEntryTable.getRowCount() - 1 : 0;
  FieldPosition pos=new java.text.FieldPosition(0);
  StringBuffer tempSB=new StringBuffer();
  int cursor=startingRow;
  if (endRow < startingRow) {
    int temp=startingRow;
    startingRow=endRow;
    endRow=temp;
  }
  int foundRow=-1;
  while (cursor >= startingRow && cursor <= endRow && foundRow == -1) {
    ILogEntry log=logTableDataModel.getVisibleLogEntry(cursor);
    String string=null;
    for (int t=0; t < cols.length - 1; t++) {
      Object obj=log.getField(t);
      if (obj == null) {
        continue;
      }
      if (cols[t]) {
switch (t) {
case ILogEntry.FIELD_TIMESTAMP:
{
            SimpleDateFormat df=new SimpleDateFormat(ILogEntry.TIME_FORMAT);
            Date dt=(Date)obj;
            tempSB.delete(0,tempSB.length());
            df.format(dt,tempSB,pos);
            string=tempSB.toString();
            break;
          }
case ILogEntry.FIELD_ENTRYTYPE:
case ILogEntry.FIELD_LINE:
case ILogEntry.FIELD_PRIORITY:
case ILogEntry.FIELD_STACKLEVEL:
{
          string=""String_Node_Str"" + ILogEntry.FIELD_ENTRYTYPE;
          break;
        }
default :
{
        string=obj.toString();
        break;
      }
  }
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (cols[cols.length - 1] && log.hasDatas()) {
Vector<ILogEntry.AdditionalData> addData=log.getAdditionalData();
for (int t=0; t < addData.size(); t++) {
  ILogEntry.AdditionalData data=addData.elementAt(t);
  string=data.getName();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
  string=data.getValue();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (forwardSearch) {
cursor++;
}
 else {
cursor--;
}
}
return foundRow;
}","/** 
 * The method executes the search for both the public overloaded  find methods.
 * @param regExp The regular expression to look for in the logsnull if the method search for a string 
 * @param searchString The string to look for in the logsnull if the method search for a reg exp
 * @param caseSensitive If true performs a CaseSensitive searchIgnored for reg exp searchs (it is coded in the Pattern)
 * @param wholeWord If true look for the whole word int the columnIgnored for reg exp searchs
 * @param forwardSearch If true search forward otherwise backward
 * @param cols The columns of each log tool for the string
 * @return -1 if no log is found otherwise the row containing the string/reg exp
 */
private int find(Pattern regExp,String searchString,boolean caseSensitive,boolean wholeWord,boolean forwardSearch,boolean[] cols){
  int startingRow=getStartingRow(forwardSearch);
  int endRow=(forwardSearch) ? logEntryTable.getRowCount() - 1 : 0;
  FieldPosition pos=new java.text.FieldPosition(0);
  StringBuffer tempSB=new StringBuffer();
  int cursor=startingRow;
  if (endRow < startingRow) {
    int temp=startingRow;
    startingRow=endRow;
    endRow=temp;
  }
  int foundRow=-1;
  while (cursor >= startingRow && cursor <= endRow && foundRow == -1) {
    ILogEntry log=logTableDataModel.getVisibleLogEntry(cursor);
    String string=null;
    for (int t=0; t < cols.length - 1; t++) {
      Object obj=log.getField(t);
      if (obj == null) {
        continue;
      }
      if (cols[t]) {
switch (t) {
case ILogEntry.FIELD_TIMESTAMP:
{
            SimpleDateFormat df=new SimpleDateFormat(ILogEntry.TIME_FORMAT);
            Date dt=(Date)obj;
            tempSB.delete(0,tempSB.length());
            df.format(dt,tempSB,pos);
            string=tempSB.toString();
            break;
          }
case ILogEntry.FIELD_ENTRYTYPE:
case ILogEntry.FIELD_LINE:
case ILogEntry.FIELD_PRIORITY:
case ILogEntry.FIELD_STACKLEVEL:
{
          string=obj.toString();
          break;
        }
default :
{
        string=obj.toString();
        break;
      }
  }
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (cols[cols.length - 1] && log.hasDatas()) {
Vector<ILogEntry.AdditionalData> addData=log.getAdditionalData();
for (int t=0; t < addData.size(); t++) {
  ILogEntry.AdditionalData data=addData.elementAt(t);
  string=data.getName();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
  string=data.getValue();
  if (matches(string,regExp,searchString,caseSensitive,wholeWord)) {
    if ((forwardSearch && cursor != startingRow) || (!forwardSearch && cursor != endRow)) {
      foundRow=cursor;
      if (forwardSearch) {
        cursor++;
      }
 else {
        cursor--;
      }
      return foundRow;
    }
  }
}
}
if (forwardSearch) {
cursor++;
}
 else {
cursor--;
}
}
return foundRow;
}",0.9914657882916604
135067,"/** 
 * Compare a log with another log knowing the index of this last one
 * @param log The first log to compare
 * @param secondItem The index in the LogCache of the second log entry
 * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second
 * @see java.util.Comparable
 */
public final int compare(ILogEntry log,Integer secondItem){
  ILogEntry log2=null;
  try {
    VisibleLogsVector.this.cache.getLog(secondItem);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace(System.err);
  }
  return compareLogs(log,log2);
}","/** 
 * Compare a log with another log knowing the index of this last one
 * @param log The first log to compare
 * @param secondItem The index in the LogCache of the second log entry
 * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second
 * @see java.util.Comparable
 */
public final int compare(ILogEntry log,Integer secondItem){
  ILogEntry log2=null;
  try {
    log2=VisibleLogsVector.this.cache.getLog(secondItem);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace(System.err);
  }
  return compareLogs(log,log2);
}",0.996191926884996
135068,"/** 
 * Compare a log with another log knowing the index of this last one
 * @param log The first log to compare
 * @param secondItem The index in the LogCache of the second log entry
 * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second
 * @see java.util.Comparable
 */
public final int compare(ILogEntry log,Integer secondItem){
  ILogEntry log2=null;
  try {
    VisibleLogsVector.this.cache.getLog(secondItem);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace(System.err);
  }
  return compareLogs(log,log2);
}","/** 
 * Compare a log with another log knowing the index of this last one
 * @param log The first log to compare
 * @param secondItem The index in the LogCache of the second log entry
 * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second
 * @see java.util.Comparable
 */
public final int compare(ILogEntry log,Integer secondItem){
  ILogEntry log2=null;
  try {
    log2=VisibleLogsVector.this.cache.getLog(secondItem);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace(System.err);
  }
  return compareLogs(log,log2);
}",0.996191926884996
135069,"/** 
 * Compare a log with another log knowing the index of this last one
 * @param log The first log to compare
 * @param secondItem The index in the LogCache of the second log entry
 * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second
 * @see java.util.Comparable
 */
public final int compare(ILogEntry log,Integer secondItem){
  ILogEntry log2=null;
  try {
    VisibleLogsVector.this.cache.getLog(secondItem);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace(System.err);
  }
  return compareLogs(log,log2);
}","/** 
 * Compare a log with another log knowing the index of this last one
 * @param log The first log to compare
 * @param secondItem The index in the LogCache of the second log entry
 * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second
 * @see java.util.Comparable
 */
public final int compare(ILogEntry log,Integer secondItem){
  ILogEntry log2=null;
  try {
    log2=VisibleLogsVector.this.cache.getLog(secondItem);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace(System.err);
  }
  return compareLogs(log,log2);
}",0.996191926884996
135070,"/** 
 * Creates a new instance of SimpleSupplier
 * @param cName name of the notification channel events will be published to.
 * @param services This is used to get the name of the component and to access the ACS logging system.
 * @throws AcsJException There are literally dozens of CORBA exceptions that could be thrown by the SimpleSupplier class. Instead, these are converted into an ACS Error System exception for the developer's convenience.
 */
public SimpleSupplier(String cName,ContainerServices services) throws AcsJException {
  m_channelName=cName;
  m_logger=services.getLogger();
  m_services=services;
  m_anyAide=new AnyAide(services);
  if (m_channelName == null) {
    String reason=""String_Node_Str"";
    throw new alma.ACSErrTypeJavaNative.wrappers.AcsJJavaLangEx(reason);
  }
  m_helper=new Helper(services);
  m_supplierAdmin=getNotificationChannel(cName).new_for_suppliers(IFGOP,new IntHolder());
  if (m_supplierAdmin == null) {
    String reason=""String_Node_Str"";
    throw new alma.ACSErrTypeJavaNative.wrappers.AcsJJavaLangEx(reason);
  }
  try {
    org.omg.CORBA.Object tempCorbaObj=m_supplierAdmin.obtain_notification_push_consumer(ClientType.STRUCTURED_EVENT,new IntHolder());
    if (tempCorbaObj == null) {
      String reason=""String_Node_Str"";
      throw new alma.ACSErrTypeJavaNative.wrappers.AcsJJavaLangEx(reason);
    }
    m_proxyConsumer=StructuredProxyPushConsumerHelper.narrow(tempCorbaObj);
  }
 catch (  org.omg.CosNotifyChannelAdmin.AdminLimitExceeded e) {
    throw new alma.ACSErrTypeCommon.wrappers.AcsJCORBAProblemEx(e.getMessage());
  }
  try {
    alma.ACS.OffShoot myOS=getHelper().getContainerServices().activateOffShoot(this);
    m_corbaRef=OSPushSupplierHelper.narrow(myOS);
    org.omg.CosNotifyComm.StructuredPushSupplier mySps=org.omg.CosNotifyComm.StructuredPushSupplierHelper.narrow(m_corbaRef);
    m_proxyConsumer.connect_structured_push_supplier(mySps);
  }
 catch (  alma.acs.container.ContainerException e) {
    throw new alma.ACSErrTypeCommon.wrappers.AcsJCORBAProblemEx(e);
  }
catch (  org.omg.CosEventChannelAdmin.AlreadyConnected e) {
    throw new alma.ACSErrTypeCommon.wrappers.AcsJCORBAProblemEx(e.getMessage());
  }
  if (m_helper.getChannelProperties().getIntegrationLogs(m_channelName) == true) {
    m_integrationLogs=true;
  }
}","/** 
 * Creates a new instance of SimpleSupplier
 * @param cName name of the notification channel events will be published to.
 * @param services This is used to get the name of the component and to access the ACS logging system.
 * @throws AcsJException There are literally dozens of CORBA exceptions that could be thrown by the SimpleSupplier class. Instead, these are converted into an ACS Error System exception for the developer's convenience.
 */
public SimpleSupplier(String cName,ContainerServices services) throws AcsJException {
  m_channelName=cName;
  m_logger=services.getLogger();
  m_services=services;
  m_anyAide=new AnyAide(services);
  if (m_channelName == null) {
    String reason=""String_Node_Str"";
    throw new alma.ACSErrTypeJavaNative.wrappers.AcsJJavaLangEx(reason);
  }
  m_helper=new Helper(services);
  EventChannel ec=getNotificationChannel(cName);
  IntHolder ih=new IntHolder();
  m_supplierAdmin=ec.new_for_suppliers(IFGOP,ih);
  if (m_supplierAdmin == null) {
    String reason=""String_Node_Str"";
    throw new alma.ACSErrTypeJavaNative.wrappers.AcsJJavaLangEx(reason);
  }
  try {
    IntHolder cp_ih=new IntHolder();
    org.omg.CORBA.Object tempCorbaObj=null;
    tempCorbaObj=m_supplierAdmin.obtain_notification_push_consumer(ClientType.STRUCTURED_EVENT,cp_ih);
    if (tempCorbaObj == null) {
      String reason=""String_Node_Str"";
      throw new alma.ACSErrTypeJavaNative.wrappers.AcsJJavaLangEx(reason);
    }
    m_proxyConsumer=StructuredProxyPushConsumerHelper.narrow(tempCorbaObj);
  }
 catch (  org.omg.CosNotifyChannelAdmin.AdminLimitExceeded e) {
    throw new alma.ACSErrTypeCommon.wrappers.AcsJCORBAProblemEx(e.getMessage());
  }
  try {
    ContainerServices cs=m_helper.getContainerServices();
    alma.ACS.OffShoot myOS=null;
    myOS=cs.activateOffShoot(this);
    m_corbaRef=OSPushSupplierHelper.narrow(myOS);
    org.omg.CosNotifyComm.StructuredPushSupplier mySps=null;
    mySps=org.omg.CosNotifyComm.StructuredPushSupplierHelper.narrow(m_corbaRef);
    m_proxyConsumer.connect_structured_push_supplier(mySps);
  }
 catch (  alma.acs.container.ContainerException e) {
    throw new alma.ACSErrTypeCommon.wrappers.AcsJCORBAProblemEx(e);
  }
catch (  org.omg.CosEventChannelAdmin.AlreadyConnected e) {
    throw new alma.ACSErrTypeCommon.wrappers.AcsJCORBAProblemEx(e);
  }
  ChannelProperties channelProps=m_helper.getChannelProperties();
  m_integrationLogs=channelProps.getIntegrationLogs(m_channelName);
}",0.903306822938468
135071,"/** 
 * Logs a single record and waits for it to come back from the Log service  and to pass the queue (which is set to zero delay). Then the record is verified, and the same test is repeated a couple of times with different log records. 
 * @throws Exception
 */
public void testLogQueueNoDelay() throws Exception {
  logReceiver.setDelayMillis(0);
  BlockingQueue<DelayedLogEntry> queue=logReceiver.getLogQueue();
  final int numLogs=5;
  Level[] levels=new Level[]{Level.FINEST,Level.FINE,Level.INFO,Level.WARNING,Level.SEVERE};
  Random random=new Random(System.currentTimeMillis());
  for (int i=0; i < numLogs; i++) {
    Level level=levels[random.nextInt(levels.length)];
    String acsLevelName=AcsLogLevel.getNativeLevel(level).getEntryName();
    int jlogLevelIndex=LogTypeHelper.parseLogTypeDescription(acsLevelName).intValue();
    String logMessage=""String_Node_Str"" + i;
    m_logger.log(level,logMessage);
    long timeoutSec=15L;
    DelayedLogEntry delayedLogEntry=queue.poll(timeoutSec,TimeUnit.SECONDS);
    if (delayedLogEntry != null) {
      ILogEntry logEntry=delayedLogEntry.getLogEntry();
      String sourceObjectName=(String)logEntry.getField(ILogEntry.FIELD_SOURCEOBJECT);
      if (sourceObjectName.equals(""String_Node_Str"")) {
        assertEquals(logMessage,logEntry.getField(ILogEntry.FIELD_LOGMESSAGE));
        assertEquals(jlogLevelIndex,((Integer)logEntry.getField(ILogEntry.FIELD_ENTRYTYPE)).intValue());
        System.out.println(""String_Node_Str"" + i);
      }
 else {
        System.out.println(""String_Node_Str"" + sourceObjectName);
      }
    }
 else {
      fail(""String_Node_Str"" + i + ""String_Node_Str""+ timeoutSec+ ""String_Node_Str"");
    }
  }
  logReceiver.stop();
}","/** 
 * Logs a single record and waits for it to come back from the Log service  and to pass the queue (which is set to zero delay). Then the record is verified, and the same test is repeated a couple of times with different log records. 
 * @throws Exception
 */
public void testLogQueueNoDelay() throws Exception {
  logReceiver.setDelayMillis(0);
  BlockingQueue<DelayedLogEntry> queue=logReceiver.getLogQueue();
  final int numLogs=5;
  Level[] levels=new Level[]{Level.FINEST,Level.FINE,Level.INFO,Level.WARNING,Level.SEVERE};
  Random random=new Random(System.currentTimeMillis());
  for (int i=0; i < numLogs; i++) {
    Level level=levels[random.nextInt(levels.length)];
    String acsLevelName=AcsLogLevel.getNativeLevel(level).getEntryName();
    int jlogLevelIndex=LogTypeHelper.parseLogTypeDescription(acsLevelName).intValue();
    String logMessage=""String_Node_Str"" + i;
    m_logger.log(level,logMessage);
    long timeoutSec=15L;
    while (true) {
      DelayedLogEntry delayedLogEntry=queue.poll(timeoutSec,TimeUnit.SECONDS);
      if (delayedLogEntry != null) {
        if (delayedLogEntry.isQueuePoison()) {
          fail(""String_Node_Str"");
        }
        ILogEntry logEntry=delayedLogEntry.getLogEntry();
        String sourceObjectName=(String)logEntry.getField(ILogEntry.FIELD_SOURCEOBJECT);
        if (sourceObjectName.equals(""String_Node_Str"")) {
          assertEquals(logMessage,logEntry.getField(ILogEntry.FIELD_LOGMESSAGE));
          assertEquals(jlogLevelIndex,((Integer)logEntry.getField(ILogEntry.FIELD_ENTRYTYPE)).intValue());
          System.out.println(""String_Node_Str"" + i);
          break;
        }
 else {
          System.out.println(""String_Node_Str"" + sourceObjectName);
        }
      }
 else {
        fail(""String_Node_Str"" + i + ""String_Node_Str""+ timeoutSec+ ""String_Node_Str"");
      }
    }
  }
  logReceiver.stop();
}",0.9549248747913188
135072,"/** 
 * Load the logs from the given file in the Cache appending their starting position in the index vector. The logs are appended at the end of the cache as well as the new positions are appended at the end of the index vector. The load is performed in a thread as it might be very slow
 * @param br The the file to read
 * @param logListener The callback for each new log read from the IO
 * @param cache The cache of logs
 */
private void loadLogsFromDisk(BufferedReader br,IACSLogRemoteConnection logListener,LogCache cache){
  if (br == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String tag=null;
  LogStringBuffer buffer=new LogStringBuffer();
  int chRead;
  int bytesRead=0;
  int logRecordsRead=0;
  boolean lookForOpenTag=true;
  try {
    StopWatch stopWatch=new StopWatch();
    while ((chRead=br.read()) != -1) {
      bytesRead++;
      buffer.append((char)chRead);
      if (chRead == '>') {
        if (lookForOpenTag) {
          tag=buffer.getOpeningTag();
          if (tag.length() > 0) {
            lookForOpenTag=false;
            buffer.trim(tag);
          }
        }
 else {
          if (buffer.hasClosingTag(tag)) {
            lookForOpenTag=true;
            injectLog(buffer.toString(),logListener);
            buffer.clear();
            logRecordsRead++;
            if (progressDialog != null) {
              if (cache != null) {
                progressDialog.updateStatus(""String_Node_Str"" + cache.getSize() + ""String_Node_Str"");
              }
              progressDialog.updateProgressBar(bytesRead);
              if (progressDialog.wantsToAbort()) {
                break;
              }
            }
          }
        }
      }
    }
    System.out.println(""String_Node_Str"" + logRecordsRead + ""String_Node_Str""+ stopWatch.getLapTimeMillis() / 1000 + ""String_Node_Str"");
    System.out.println(ResourceChecker.getMemoryStatusMessage());
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"" + ioe.getMessage());
    ioe.printStackTrace(System.err);
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ioe.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  if (progressDialog != null) {
    progressDialog.setVisible(false);
    progressDialog.dispose();
    progressDialog=null;
  }
  IOOperationTerminated();
}","/** 
 * Load the logs from the given file in the Cache appending their starting position in the index vector. The logs are appended at the end of the cache as well as the new positions are appended at the end of the index vector. The load is performed in a thread as it might be very slow
 * @param br The the file to read
 * @param logListener The callback for each new log read from the IO
 * @param cache The cache of logs
 */
private void loadLogsFromDisk(BufferedReader br,IACSLogRemoteConnection logListener,LogCache cache){
  if (br == null || logListener == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String tag=null;
  LogStringBuffer buffer=new LogStringBuffer();
  int chRead;
  int bytesRead=0;
  int logRecordsRead=0;
  try {
    StopWatch stopWatch=new StopWatch();
    while ((chRead=br.read()) != -1) {
      bytesRead++;
      buffer.append((char)chRead);
      if (chRead == '>') {
        tag=buffer.getOpeningTag();
        if (tag.length() > 0) {
          buffer.trim(tag);
        }
        if (buffer.hasClosingTag(tag)) {
          injectLog(buffer.toString(),logListener);
          buffer.clear();
          logRecordsRead++;
          if (progressDialog != null) {
            if (cache != null) {
              progressDialog.updateStatus(""String_Node_Str"" + cache.getSize() + ""String_Node_Str"");
            }
            progressDialog.updateProgressBar(bytesRead);
            if (progressDialog.wantsToAbort()) {
              break;
            }
          }
        }
      }
    }
    System.out.println(""String_Node_Str"" + logRecordsRead + ""String_Node_Str""+ stopWatch.getLapTimeMillis() / 1000 + ""String_Node_Str"");
    System.out.println(ResourceChecker.getMemoryStatusMessage());
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"" + ioe.getMessage());
    ioe.printStackTrace(System.err);
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ioe.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  if (progressDialog != null) {
    progressDialog.setVisible(false);
    progressDialog.dispose();
    progressDialog=null;
  }
  IOOperationTerminated();
}",0.8954233915542781
135073,"/** 
 * Load the logs from a buffered reader
 * @param reader The buffered reader containing the logs
 * @param engine The LCEngine to inject logs in the GUI
 * @param cache The cache To show info in the dialog (can be null)
 * @param showProgress If true a progress bar is shown
 * @see loadLogs
 */
public void loadLogs(BufferedReader reader,IACSLogRemoteConnection listener,LogCache cache,boolean showProgress){
  if (!this.isAlive()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (listener == null || reader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IOOperationInProgress=true;
  LoggingClient.getInstance().getScrollPaneTable().setVisible(false);
  if (showProgress) {
    progressDialog=new ProgressDialog(""String_Node_Str"");
  }
 else {
    progressDialog=null;
  }
  IOAction action=new IOAction(reader,listener,cache);
synchronized (actions) {
    actions.add(action);
  }
synchronized (this) {
    notifyAll();
  }
}","/** 
 * Load the logs from a buffered reader
 * @param reader The buffered reader containing the logs
 * @param listener The listener to add logs in
 * @param cache The cache To show info in the dialog (can be null)
 * @param showProgress If true a progress bar is shown
 * @param progressRange An integer to make the progress bar showing the real state of the operation (determinate) If it is <=0 then the progress bar is indeterminate
 * @see loadLogs
 */
public void loadLogs(BufferedReader reader,IACSLogRemoteConnection listener,LogCache cache,boolean showProgress,int progressRange){
  if (!this.isAlive()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (listener == null || reader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IOOperationInProgress=true;
  LoggingClient.getInstance().getScrollPaneTable().setVisible(false);
  if (showProgress) {
    if (progressRange <= 0) {
      progressDialog=new ProgressDialog(""String_Node_Str"");
    }
 else {
      progressDialog=new ProgressDialog(""String_Node_Str"",0,progressRange);
    }
  }
 else {
    progressDialog=null;
  }
  IOAction action=new IOAction(reader,listener,cache);
synchronized (actions) {
    actions.add(action);
  }
synchronized (this) {
    notifyAll();
  }
}",0.8309050772626931
135074,"/** 
 * Load the logs from the given file in the Cache appending their starting position in the index vector. The logs are appended at the end of the cache as well as the new positions are appended at the end of the index vector. The load is performed in a thread as it might be very slow
 * @param br The the file to read
 * @param logListener The callback for each new log read from the IO
 * @param cache The cache of logs
 */
private void loadLogsFromDisk(BufferedReader br,IACSLogRemoteConnection logListener,LogCache cache){
  if (br == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String tag=null;
  LogStringBuffer buffer=new LogStringBuffer();
  int chRead;
  int bytesRead=0;
  int logRecordsRead=0;
  boolean lookForOpenTag=true;
  try {
    StopWatch stopWatch=new StopWatch();
    while ((chRead=br.read()) != -1) {
      bytesRead++;
      buffer.append((char)chRead);
      if (chRead == '>') {
        if (lookForOpenTag) {
          tag=buffer.getOpeningTag();
          if (tag.length() > 0) {
            lookForOpenTag=false;
            buffer.trim(tag);
          }
        }
 else {
          if (buffer.hasClosingTag(tag)) {
            lookForOpenTag=true;
            injectLog(buffer.toString(),logListener);
            buffer.clear();
            logRecordsRead++;
            if (progressDialog != null) {
              if (cache != null) {
                progressDialog.updateStatus(""String_Node_Str"" + cache.getSize() + ""String_Node_Str"");
              }
              progressDialog.updateProgressBar(bytesRead);
              if (progressDialog.wantsToAbort()) {
                break;
              }
            }
          }
        }
      }
    }
    System.out.println(""String_Node_Str"" + logRecordsRead + ""String_Node_Str""+ stopWatch.getLapTimeMillis() / 1000 + ""String_Node_Str"");
    System.out.println(ResourceChecker.getMemoryStatusMessage());
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"" + ioe.getMessage());
    ioe.printStackTrace(System.err);
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ioe.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  if (progressDialog != null) {
    progressDialog.setVisible(false);
    progressDialog.dispose();
    progressDialog=null;
  }
  IOOperationTerminated();
}","/** 
 * Load the logs from the given file in the Cache appending their starting position in the index vector. The logs are appended at the end of the cache as well as the new positions are appended at the end of the index vector. The load is performed in a thread as it might be very slow
 * @param br The the file to read
 * @param logListener The callback for each new log read from the IO
 * @param cache The cache of logs
 */
private void loadLogsFromDisk(BufferedReader br,IACSLogRemoteConnection logListener,LogCache cache){
  if (br == null || logListener == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String tag=null;
  LogStringBuffer buffer=new LogStringBuffer();
  int chRead;
  int bytesRead=0;
  int logRecordsRead=0;
  try {
    StopWatch stopWatch=new StopWatch();
    while ((chRead=br.read()) != -1) {
      bytesRead++;
      buffer.append((char)chRead);
      if (chRead == '>') {
        tag=buffer.getOpeningTag();
        if (tag.length() > 0) {
          buffer.trim(tag);
        }
        if (buffer.hasClosingTag(tag)) {
          injectLog(buffer.toString(),logListener);
          buffer.clear();
          logRecordsRead++;
          if (progressDialog != null) {
            if (cache != null) {
              progressDialog.updateStatus(""String_Node_Str"" + cache.getSize() + ""String_Node_Str"");
            }
            progressDialog.updateProgressBar(bytesRead);
            if (progressDialog.wantsToAbort()) {
              break;
            }
          }
        }
      }
    }
    System.out.println(""String_Node_Str"" + logRecordsRead + ""String_Node_Str""+ stopWatch.getLapTimeMillis() / 1000 + ""String_Node_Str"");
    System.out.println(ResourceChecker.getMemoryStatusMessage());
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"" + ioe.getMessage());
    ioe.printStackTrace(System.err);
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ioe.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  if (progressDialog != null) {
    progressDialog.setVisible(false);
    progressDialog.dispose();
    progressDialog=null;
  }
  IOOperationTerminated();
}",0.8954233915542781
135075,"/** 
 * Load the logs from a buffered reader
 * @param reader The buffered reader containing the logs
 * @param engine The LCEngine to inject logs in the GUI
 * @param cache The cache To show info in the dialog (can be null)
 * @param showProgress If true a progress bar is shown
 * @see loadLogs
 */
public void loadLogs(BufferedReader reader,IACSLogRemoteConnection listener,LogCache cache,boolean showProgress){
  if (!this.isAlive()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (listener == null || reader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IOOperationInProgress=true;
  LoggingClient.getInstance().getScrollPaneTable().setVisible(false);
  if (showProgress) {
    progressDialog=new ProgressDialog(""String_Node_Str"");
  }
 else {
    progressDialog=null;
  }
  IOAction action=new IOAction(reader,listener,cache);
synchronized (actions) {
    actions.add(action);
  }
synchronized (this) {
    notifyAll();
  }
}","/** 
 * Load the logs from a buffered reader
 * @param reader The buffered reader containing the logs
 * @param listener The listener to add logs in
 * @param cache The cache To show info in the dialog (can be null)
 * @param showProgress If true a progress bar is shown
 * @param progressRange An integer to make the progress bar showing the real state of the operation (determinate) If it is <=0 then the progress bar is indeterminate
 * @see loadLogs
 */
public void loadLogs(BufferedReader reader,IACSLogRemoteConnection listener,LogCache cache,boolean showProgress,int progressRange){
  if (!this.isAlive()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (listener == null || reader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IOOperationInProgress=true;
  LoggingClient.getInstance().getScrollPaneTable().setVisible(false);
  if (showProgress) {
    if (progressRange <= 0) {
      progressDialog=new ProgressDialog(""String_Node_Str"");
    }
 else {
      progressDialog=new ProgressDialog(""String_Node_Str"",0,progressRange);
    }
  }
 else {
    progressDialog=null;
  }
  IOAction action=new IOAction(reader,listener,cache);
synchronized (actions) {
    actions.add(action);
  }
synchronized (this) {
    notifyAll();
  }
}",0.8309050772626931
135076,"/** 
 * Load the logs from the given file in the Cache appending their starting position in the index vector. The logs are appended at the end of the cache as well as the new positions are appended at the end of the index vector. The load is performed in a thread as it might be very slow
 * @param br The the file to read
 * @param logListener The callback for each new log read from the IO
 * @param cache The cache of logs
 */
private void loadLogsFromDisk(BufferedReader br,IACSLogRemoteConnection logListener,LogCache cache){
  if (br == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String tag=null;
  LogStringBuffer buffer=new LogStringBuffer();
  int chRead;
  int bytesRead=0;
  int logRecordsRead=0;
  boolean lookForOpenTag=true;
  try {
    StopWatch stopWatch=new StopWatch();
    while ((chRead=br.read()) != -1) {
      bytesRead++;
      buffer.append((char)chRead);
      if (chRead == '>') {
        if (lookForOpenTag) {
          tag=buffer.getOpeningTag();
          if (tag.length() > 0) {
            lookForOpenTag=false;
            buffer.trim(tag);
          }
        }
 else {
          if (buffer.hasClosingTag(tag)) {
            lookForOpenTag=true;
            injectLog(buffer.toString(),logListener);
            buffer.clear();
            logRecordsRead++;
            if (progressDialog != null) {
              if (cache != null) {
                progressDialog.updateStatus(""String_Node_Str"" + cache.getSize() + ""String_Node_Str"");
              }
              progressDialog.updateProgressBar(bytesRead);
              if (progressDialog.wantsToAbort()) {
                break;
              }
            }
          }
        }
      }
    }
    System.out.println(""String_Node_Str"" + logRecordsRead + ""String_Node_Str""+ stopWatch.getLapTimeMillis() / 1000 + ""String_Node_Str"");
    System.out.println(ResourceChecker.getMemoryStatusMessage());
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"" + ioe.getMessage());
    ioe.printStackTrace(System.err);
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ioe.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  if (progressDialog != null) {
    progressDialog.setVisible(false);
    progressDialog.dispose();
    progressDialog=null;
  }
  IOOperationTerminated();
}","/** 
 * Load the logs from the given file in the Cache appending their starting position in the index vector. The logs are appended at the end of the cache as well as the new positions are appended at the end of the index vector. The load is performed in a thread as it might be very slow
 * @param br The the file to read
 * @param logListener The callback for each new log read from the IO
 * @param cache The cache of logs
 */
private void loadLogsFromDisk(BufferedReader br,IACSLogRemoteConnection logListener,LogCache cache){
  if (br == null || logListener == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String tag=null;
  LogStringBuffer buffer=new LogStringBuffer();
  int chRead;
  int bytesRead=0;
  int logRecordsRead=0;
  try {
    StopWatch stopWatch=new StopWatch();
    while ((chRead=br.read()) != -1) {
      bytesRead++;
      buffer.append((char)chRead);
      if (chRead == '>') {
        tag=buffer.getOpeningTag();
        if (tag.length() > 0) {
          buffer.trim(tag);
        }
        if (buffer.hasClosingTag(tag)) {
          injectLog(buffer.toString(),logListener);
          buffer.clear();
          logRecordsRead++;
          if (progressDialog != null) {
            if (cache != null) {
              progressDialog.updateStatus(""String_Node_Str"" + cache.getSize() + ""String_Node_Str"");
            }
            progressDialog.updateProgressBar(bytesRead);
            if (progressDialog.wantsToAbort()) {
              break;
            }
          }
        }
      }
    }
    System.out.println(""String_Node_Str"" + logRecordsRead + ""String_Node_Str""+ stopWatch.getLapTimeMillis() / 1000 + ""String_Node_Str"");
    System.out.println(ResourceChecker.getMemoryStatusMessage());
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"" + ioe.getMessage());
    ioe.printStackTrace(System.err);
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ioe.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  if (progressDialog != null) {
    progressDialog.setVisible(false);
    progressDialog.dispose();
    progressDialog=null;
  }
  IOOperationTerminated();
}",0.8954233915542781
135077,"/** 
 * Load the logs from a buffered reader
 * @param reader The buffered reader containing the logs
 * @param engine The LCEngine to inject logs in the GUI
 * @param cache The cache To show info in the dialog (can be null)
 * @param showProgress If true a progress bar is shown
 * @see loadLogs
 */
public void loadLogs(BufferedReader reader,IACSLogRemoteConnection listener,LogCache cache,boolean showProgress){
  if (!this.isAlive()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (listener == null || reader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IOOperationInProgress=true;
  LoggingClient.getInstance().getScrollPaneTable().setVisible(false);
  if (showProgress) {
    progressDialog=new ProgressDialog(""String_Node_Str"");
  }
 else {
    progressDialog=null;
  }
  IOAction action=new IOAction(reader,listener,cache);
synchronized (actions) {
    actions.add(action);
  }
synchronized (this) {
    notifyAll();
  }
}","/** 
 * Load the logs from a buffered reader
 * @param reader The buffered reader containing the logs
 * @param listener The listener to add logs in
 * @param cache The cache To show info in the dialog (can be null)
 * @param showProgress If true a progress bar is shown
 * @param progressRange An integer to make the progress bar showing the real state of the operation (determinate) If it is <=0 then the progress bar is indeterminate
 * @see loadLogs
 */
public void loadLogs(BufferedReader reader,IACSLogRemoteConnection listener,LogCache cache,boolean showProgress,int progressRange){
  if (!this.isAlive()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (listener == null || reader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IOOperationInProgress=true;
  LoggingClient.getInstance().getScrollPaneTable().setVisible(false);
  if (showProgress) {
    if (progressRange <= 0) {
      progressDialog=new ProgressDialog(""String_Node_Str"");
    }
 else {
      progressDialog=new ProgressDialog(""String_Node_Str"",0,progressRange);
    }
  }
 else {
    progressDialog=null;
  }
  IOAction action=new IOAction(reader,listener,cache);
synchronized (actions) {
    actions.add(action);
  }
synchronized (this) {
    notifyAll();
  }
}",0.8309050772626931
135078,"/** 
 * Fill the cache with dinamically generated logs The number of logs inserted in the list is gretare than the  memory cache size to stress the disk cache also.
 * @return The number of logs inserted in the cache
 * @throws Exception
 */
private long fillCache() throws Exception {
  ACSLogParser parser=new ACSLogParser();
  String logMsg=""String_Node_Str"";
  cache.clear();
  long logToInsert=2 * cache.getCacheSize();
  for (int t=0; t < logToInsert; t++) {
    String newLogMsg=logMsg + ""String_Node_Str"";
    String logStr=""String_Node_Str"" + newLogMsg + ""String_Node_Str"";
    LogEntryXML newLog=parser.parse(logStr);
    cache.add(newLog);
  }
  return logToInsert;
}","/** 
 * Fill the cache with dynamically generated logs The number of logs inserted in the list is greater than the  memory cache size to stress the disk cache also.
 * @return The number of logs inserted in the cache
 * @throws Exception
 */
private long fillCache() throws Exception {
  ACSLogParser parser=new ACSLogParser();
  String logMsg=""String_Node_Str"";
  cache.clear();
  long logToInsert=2 * cache.getCacheSize();
  for (int t=0; t < logToInsert; t++) {
    String newLogMsg=logMsg + ""String_Node_Str"";
    String logStr=""String_Node_Str"" + newLogMsg + ""String_Node_Str"";
    LogEntryXML newLog=parser.parse(logStr);
    cache.add(newLog);
  }
  return logToInsert;
}",0.9926253687315634
135079,"/** 
 * This execute for each test and we want to have a cache with some logs 
 * @see junit.framework.TestCase
 */
protected void setUp() throws Exception {
  try {
    cache=new LogCache();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace();
    System.exit(0);
  }
  logsGenerated=fillCache();
}","/** 
 * This execute for each test and we want to have a cache with some logs 
 * @see junit.framework.TestCase
 */
protected void setUp() throws Exception {
  try {
    cache=new LogCache();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    throw e;
  }
  logsGenerated=fillCache();
}",0.9331395348837208
135080,"/** 
 * Fill the cache with dinamically generated logs The number of logs inserted in the list is gretare than the  memory cache size to stress the disk cache also.
 * @return The number of logs inserted in the cache
 * @throws Exception
 */
private long fillCache() throws Exception {
  ACSLogParser parser=new ACSLogParser();
  String logMsg=""String_Node_Str"";
  cache.clear();
  long logToInsert=2 * cache.getCacheSize();
  for (int t=0; t < logToInsert; t++) {
    String newLogMsg=logMsg + ""String_Node_Str"";
    String logStr=""String_Node_Str"" + newLogMsg + ""String_Node_Str"";
    LogEntryXML newLog=parser.parse(logStr);
    cache.add(newLog);
  }
  return logToInsert;
}","/** 
 * Fill the cache with dynamically generated logs The number of logs inserted in the list is greater than the  memory cache size to stress the disk cache also.
 * @return The number of logs inserted in the cache
 * @throws Exception
 */
private long fillCache() throws Exception {
  ACSLogParser parser=new ACSLogParser();
  String logMsg=""String_Node_Str"";
  cache.clear();
  long logToInsert=2 * cache.getCacheSize();
  for (int t=0; t < logToInsert; t++) {
    String newLogMsg=logMsg + ""String_Node_Str"";
    String logStr=""String_Node_Str"" + newLogMsg + ""String_Node_Str"";
    LogEntryXML newLog=parser.parse(logStr);
    cache.add(newLog);
  }
  return logToInsert;
}",0.9926253687315634
135081,"/** 
 * This execute for each test and we want to have a cache with some logs 
 * @see junit.framework.TestCase
 */
protected void setUp() throws Exception {
  try {
    cache=new LogCache();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace();
    System.exit(0);
  }
  logsGenerated=fillCache();
}","/** 
 * This execute for each test and we want to have a cache with some logs 
 * @see junit.framework.TestCase
 */
protected void setUp() throws Exception {
  try {
    cache=new LogCache();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    throw e;
  }
  logsGenerated=fillCache();
}",0.9331395348837208
135082,"/** 
 * Fill the cache with dinamically generated logs The number of logs inserted in the list is gretare than the  memory cache size to stress the disk cache also.
 * @return The number of logs inserted in the cache
 * @throws Exception
 */
private long fillCache() throws Exception {
  ACSLogParser parser=new ACSLogParser();
  String logMsg=""String_Node_Str"";
  cache.clear();
  long logToInsert=2 * cache.getCacheSize();
  for (int t=0; t < logToInsert; t++) {
    String newLogMsg=logMsg + ""String_Node_Str"";
    String logStr=""String_Node_Str"" + newLogMsg + ""String_Node_Str"";
    LogEntryXML newLog=parser.parse(logStr);
    cache.add(newLog);
  }
  return logToInsert;
}","/** 
 * Fill the cache with dynamically generated logs The number of logs inserted in the list is greater than the  memory cache size to stress the disk cache also.
 * @return The number of logs inserted in the cache
 * @throws Exception
 */
private long fillCache() throws Exception {
  ACSLogParser parser=new ACSLogParser();
  String logMsg=""String_Node_Str"";
  cache.clear();
  long logToInsert=2 * cache.getCacheSize();
  for (int t=0; t < logToInsert; t++) {
    String newLogMsg=logMsg + ""String_Node_Str"";
    String logStr=""String_Node_Str"" + newLogMsg + ""String_Node_Str"";
    LogEntryXML newLog=parser.parse(logStr);
    cache.add(newLog);
  }
  return logToInsert;
}",0.9926253687315634
135083,"/** 
 * This execute for each test and we want to have a cache with some logs 
 * @see junit.framework.TestCase
 */
protected void setUp() throws Exception {
  try {
    cache=new LogCache();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace();
    System.exit(0);
  }
  logsGenerated=fillCache();
}","/** 
 * This execute for each test and we want to have a cache with some logs 
 * @see junit.framework.TestCase
 */
protected void setUp() throws Exception {
  try {
    cache=new LogCache();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    throw e;
  }
  logsGenerated=fillCache();
}",0.9331395348837208
135084,"/** 
 * Reads a List of enchantments from an ItemEnchantedBook stack.
 * @param book Instance of ItemEnchantedBook, as it uses non-static methods for somereason.
 * @param stack The stack to read the data from.
 * @return The list of enchantments stored on the stack.
 */
private List<Enchantment> getEnchantments(ItemEnchantedBook book,ItemStack stack){
  final NBTTagList enchTags=book.getEnchantments(stack);
  final List<Enchantment> enchantments=new ArrayList<>();
  if (enchTags != null)   for (int index=0; index < enchTags.tagCount(); ++index) {
    final int id=enchTags.getCompoundTagAt(index).getShort(""String_Node_Str"");
    final Enchantment enchant=Enchantment.getEnchantmentByID(id);
    if (enchant != null)     enchantments.add(enchant);
  }
  return enchantments;
}","/** 
 * Reads a List of enchantments from an ItemEnchantedBook stack.
 * @param book Instance of ItemEnchantedBook, as it uses non-static methods for somereason.
 * @param stack The stack to read the data from.
 * @return The list of enchantments stored on the stack.
 */
@SideOnly(Side.CLIENT) private List<Enchantment> getEnchantments(ItemEnchantedBook book,ItemStack stack){
  final NBTTagList enchTags=book.getEnchantments(stack);
  final List<Enchantment> enchantments=new ArrayList<>();
  if (enchTags != null)   for (int index=0; index < enchTags.tagCount(); ++index) {
    final int id=enchTags.getCompoundTagAt(index).getShort(""String_Node_Str"");
    final Enchantment enchant=Enchantment.getEnchantmentByID(id);
    if (enchant != null)     enchantments.add(enchant);
  }
  return enchantments;
}",0.9855254877281308
135085,"/** 
 * Gets the name of the mod that registered the passed object. Works for anthing which uses Forge's registry.
 * @param registerable The object to get the mod name of.
 * @return The name of the mod which registered the object.
 */
public static String getModName(IForgeRegistryEntry.Impl<?> registerable){
  final String modID=registerable.getRegistryName().getResourceDomain();
  final ModContainer mod=Loader.instance().getIndexedModList().get(modID);
  return mod != null ? mod.getName() : modID;
}","/** 
 * Gets the name of the mod that registered the passed object. Works for anthing which uses Forge's registry.
 * @param registerable The object to get the mod name of.
 * @return The name of the mod which registered the object.
 */
@SideOnly(Side.CLIENT) public static String getModName(IForgeRegistryEntry.Impl<?> registerable){
  final String modID=registerable.getRegistryName().getResourceDomain();
  final ModContainer mod=Loader.instance().getIndexedModList().get(modID);
  return mod != null ? mod.getName() : modID;
}",0.9778206364513018
135086,"public static String getTranslationKey(Enchantment enchant){
  return String.format(""String_Node_Str"",enchant.getRegistryName().getResourceDomain(),enchant.getRegistryName().getResourcePath());
}","@SideOnly(Side.CLIENT) public static String getTranslationKey(Enchantment enchant){
  return String.format(""String_Node_Str"",enchant.getRegistryName().getResourceDomain(),enchant.getRegistryName().getResourcePath());
}",0.9443099273607748
135087,"@Override public void addItemInfo(List<String> info,ItemStack stack,boolean advanced,EntityPlayer entityPlayer){
  if (stack.getItem() instanceof ItemEnchantedBook)   if (GameSettings.isKeyDown(keyBindSneak)) {
    final ItemEnchantedBook item=(ItemEnchantedBook)stack.getItem();
    final List<Enchantment> enchants=this.getEnchantments(item,stack);
    for (    final Enchantment enchant : enchants) {
      info.add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + I18n.format(enchant.getName()));
      info.add(this.getDescription(enchant));
      if (showOwner)       info.add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + ChatFormatting.BLUE+ getModName(enchant));
    }
  }
 else   info.add(I18n.format(""String_Node_Str"",ChatFormatting.LIGHT_PURPLE,keyBindSneak.getDisplayName(),ChatFormatting.GRAY));
}","@Override @SideOnly(Side.CLIENT) public void addItemInfo(List<String> info,ItemStack stack,boolean advanced,EntityPlayer entityPlayer){
  final KeyBinding keyBindSneak=Minecraft.getMinecraft().gameSettings.keyBindSneak;
  if (stack.getItem() instanceof ItemEnchantedBook)   if (GameSettings.isKeyDown(keyBindSneak)) {
    final ItemEnchantedBook item=(ItemEnchantedBook)stack.getItem();
    final List<Enchantment> enchants=this.getEnchantments(item,stack);
    for (    final Enchantment enchant : enchants) {
      info.add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + I18n.format(enchant.getName()));
      info.add(this.getDescription(enchant));
      if (showOwner)       info.add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + ChatFormatting.BLUE+ getModName(enchant));
    }
  }
 else   info.add(I18n.format(""String_Node_Str"",ChatFormatting.LIGHT_PURPLE,keyBindSneak.getDisplayName(),ChatFormatting.GRAY));
}",0.9388920616790406
135088,"/** 
 * Gets the description of the enchantment. Or the missing text, if no description exists.
 * @param enchantment The enchantment to get a description for.
 * @return The enchantment description.
 */
private String getDescription(Enchantment enchantment){
  final String key=getTranslationKey(enchantment);
  String description=I18n.format(key);
  if (description.startsWith(""String_Node_Str""))   description=I18n.format(""String_Node_Str"",getModName(enchantment),key);
  return description;
}","/** 
 * Gets the description of the enchantment. Or the missing text, if no description exists.
 * @param enchantment The enchantment to get a description for.
 * @return The enchantment description.
 */
@SideOnly(Side.CLIENT) private String getDescription(Enchantment enchantment){
  final String key=getTranslationKey(enchantment);
  String description=I18n.format(key);
  if (description.startsWith(""String_Node_Str""))   description=I18n.format(""String_Node_Str"",getModName(enchantment),key);
  return description;
}",0.9773399014778326
135089,"@EventHandler public void preInit(FMLPreInitializationEvent event){
  if (Loader.isModLoaded(""String_Node_Str""))   engine=new WailaEngine();
 else   if (Loader.isModLoaded(""String_Node_Str"")) {
    engine=new ICSEEngine();
    ICSE.plugins.add((ICSEEngine)engine);
  }
  tileProviders.add(new PluginBreakProgression());
  tileProviders.add(new PluginEnchantmentPower());
  tileProviders.add(new PluginBlastResistance());
  tileProviders.add(new PluginHardness());
  tileProviders.add(new PluginHarvestability());
  entityProviders.add(new PluginEquipment());
  entityProviders.add(new PluginArmorPoints());
  entityProviders.add(new PluginTameable());
  entityProviders.add(new PluginAnimal());
  itemProviders.add(new PluginEnchantmentPower());
  itemProviders.add(new PluginFluidDescription());
  if (!Loader.isModLoaded(""String_Node_Str""))   itemProviders.add(new PluginEnchantmentDescription());
  tileProviders.add(new PluginSkulls());
  tileProviders.add(new PluginFurnace());
  entityProviders.add(new PluginHorse());
  entityProviders.add(new PluginVillagerTypes());
  entityProviders.add(new PluginItemFrame());
  entityProviders.add(new PluginPrimedTNT());
  entityProviders.add(new PluginEXPOrb());
  if (Loader.isModLoaded(""String_Node_Str"")) {
    tileProviders.add(new PluginEggInfo());
    entityProviders.add(new PluginStageInfo());
  }
  new WawlaConfiguration(event.getSuggestedConfigurationFile());
  proxy.preInit();
}","@EventHandler public void preInit(FMLPreInitializationEvent event){
  if (Loader.isModLoaded(""String_Node_Str""))   engine=new WailaEngine();
 else   if (Loader.isModLoaded(""String_Node_Str"")) {
    engine=new ICSEEngine();
    ICSE.plugins.add((ICSEEngine)engine);
  }
  tileProviders.add(new PluginBreakProgression());
  tileProviders.add(new PluginEnchantmentPower());
  tileProviders.add(new PluginBlastResistance());
  tileProviders.add(new PluginHardness());
  tileProviders.add(new PluginHarvestability());
  entityProviders.add(new PluginEquipment());
  entityProviders.add(new PluginArmorPoints());
  entityProviders.add(new PluginTameable());
  entityProviders.add(new PluginAnimal());
  itemProviders.add(new PluginEnchantmentPower());
  itemProviders.add(new PluginFluidDescription());
  if (!Loader.isModLoaded(""String_Node_Str"") && event.getSide().equals(Side.CLIENT))   itemProviders.add(new PluginEnchantmentDescription());
  tileProviders.add(new PluginSkulls());
  tileProviders.add(new PluginFurnace());
  entityProviders.add(new PluginHorse());
  entityProviders.add(new PluginVillagerTypes());
  entityProviders.add(new PluginItemFrame());
  entityProviders.add(new PluginPrimedTNT());
  entityProviders.add(new PluginEXPOrb());
  if (Loader.isModLoaded(""String_Node_Str"")) {
    tileProviders.add(new PluginEggInfo());
    entityProviders.add(new PluginStageInfo());
  }
  new WawlaConfiguration(event.getSuggestedConfigurationFile());
  proxy.preInit();
}",0.9866209262435678
135090,"@SubscribeEvent public void onItemTooltip(ItemTooltipEvent event){
  if (event.getEntityPlayer() != null && event.getEntityPlayer().worldObj != null && event.getItemStack() != null) {
    final KeyBinding keyBindSneak=Minecraft.getMinecraft().gameSettings.keyBindSneak;
    final boolean isShifting=GameSettings.isKeyDown(keyBindSneak);
    final Item item=event.getItemStack().getItem();
    final Block block=Block.getBlockFromItem(item);
    if (item instanceof ItemEnchantedBook && enchantmentDescription) {
      final List<String> tooltip=event.getToolTip();
      if (GameSettings.isKeyDown(keyBindSneak)) {
        final List<Enchantment> enchants=getEnchantments((ItemEnchantedBook)item,event.getItemStack());
        for (        Enchantment enchant : enchants) {
          tooltip.add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + I18n.format(enchant.getName()));
          tooltip.add(getDescription(enchant));
          tooltip.add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + ChatFormatting.BLUE+ getModName(enchant));
        }
      }
 else       tooltip.add(I18n.format(""String_Node_Str"",ChatFormatting.LIGHT_PURPLE,keyBindSneak.getDisplayName(),ChatFormatting.GRAY));
    }
    if (block != null && showEnchantmentPower)     try {
      final float enchPower=block.getEnchantPowerBonus(event.getEntityPlayer().worldObj,BlockPos.ORIGIN);
      if (enchPower > 0)       event.getToolTip().add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + enchPower);
    }
 catch (    final IllegalArgumentException exception) {
    }
  }
}","@SubscribeEvent public void onItemTooltip(ItemTooltipEvent event){
  if (event.getEntityPlayer() != null && event.getEntityPlayer().worldObj != null && event.getItemStack() != null) {
    final Item item=event.getItemStack().getItem();
    final Block block=Block.getBlockFromItem(item);
    if (item instanceof ItemEnchantedBook && enchantmentDescription && GameSettings.isKeyDown(keyBindSneak)&& !isEnchDescLoaded) {
      final List<String> tooltip=event.getToolTip();
      if (GameSettings.isKeyDown(keyBindSneak)) {
        final List<Enchantment> enchants=getEnchantments((ItemEnchantedBook)item,event.getItemStack());
        for (        Enchantment enchant : enchants) {
          tooltip.add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + I18n.format(enchant.getName()));
          tooltip.add(getDescription(enchant));
          tooltip.add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + ChatFormatting.BLUE+ getModName(enchant));
        }
      }
 else       tooltip.add(I18n.format(""String_Node_Str"",ChatFormatting.LIGHT_PURPLE,keyBindSneak.getDisplayName(),ChatFormatting.GRAY));
    }
    if (block != null && showEnchantmentPower)     try {
      final float enchPower=block.getEnchantPowerBonus(event.getEntityPlayer().worldObj,BlockPos.ORIGIN);
      if (enchPower > 0)       event.getToolTip().add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + enchPower);
    }
 catch (    final IllegalArgumentException exception) {
    }
  }
}",0.8327284724513362
135091,"public static void handleConfigs(Configuration config){
  showEnchantmentPower=config.getBoolean(""String_Node_Str"",CATAGORY,true,""String_Node_Str"");
  enchantmentDescription=config.getBoolean(""String_Node_Str"",CATAGORY,true,""String_Node_Str"");
}","public static void handleConfigs(Configuration config){
  showEnchantmentPower=config.getBoolean(""String_Node_Str"",CATAGORY,true,""String_Node_Str"");
  enchantmentDescription=config.getBoolean(""String_Node_Str"",CATAGORY,true,""String_Node_Str"");
  isEnchDescLoaded=Loader.isModLoaded(""String_Node_Str"");
}",0.8941605839416058
135092,"@SubscribeEvent public void onItemTooltip(ItemTooltipEvent event){
  if (event.getEntityPlayer() != null && event.getEntityPlayer().worldObj != null && event.getItemStack() != null) {
    final KeyBinding keyBindSneak=Minecraft.getMinecraft().gameSettings.keyBindSneak;
    final boolean isShifting=GameSettings.isKeyDown(keyBindSneak);
    final Item item=event.getItemStack().getItem();
    final Block block=Block.getBlockFromItem(item);
    if (item instanceof ItemEnchantedBook && enchantmentDescription) {
      final Set<Enchantment> enchants=EnchantmentHelper.getEnchantments(event.getItemStack()).keySet();
      if (!enchants.isEmpty()) {
        final Enchantment enchant=enchants.iterator().next();
        if (enchant != null)         if (isShifting) {
          final String description=I18n.format(""String_Node_Str"" + enchant.getName());
          if (description.startsWith(""String_Node_Str""))           Utilities.wrapStringToList(String.format(I18n.format(""String_Node_Str""),Utilities.getModName(enchant),description),45,false,event.getToolTip());
 else {
            Utilities.wrapStringToList(description,45,false,event.getToolTip());
            if (enchantmentMod)             event.getToolTip().add(String.format(I18n.format(""String_Node_Str""),Utilities.getModName(enchant)));
          }
        }
 else         Utilities.wrapStringToList(String.format(I18n.format(""String_Node_Str""),keyBindSneak.getDisplayName()),45,false,event.getToolTip());
      }
    }
    if (block != null && showEnchantmentPower)     try {
      final float enchPower=block.getEnchantPowerBonus(event.getEntityPlayer().worldObj,BlockPos.ORIGIN);
      if (enchPower > 0)       event.getToolTip().add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + enchPower);
    }
 catch (    final IllegalArgumentException exception) {
    }
  }
}","@SubscribeEvent public void onItemTooltip(ItemTooltipEvent event){
  if (event.getEntityPlayer() != null && event.getEntityPlayer().worldObj != null && event.getItemStack() != null) {
    final KeyBinding keyBindSneak=Minecraft.getMinecraft().gameSettings.keyBindSneak;
    final boolean isShifting=GameSettings.isKeyDown(keyBindSneak);
    final Item item=event.getItemStack().getItem();
    final Block block=Block.getBlockFromItem(item);
    if (item instanceof ItemEnchantedBook && enchantmentDescription) {
      final Set<Enchantment> enchants=EnchantmentHelper.getEnchantments(event.getItemStack()).keySet();
      if (!enchants.isEmpty()) {
        final Enchantment enchant=enchants.iterator().next();
        if (enchant != null)         if (isShifting) {
          final String description=I18n.format(""String_Node_Str"" + enchant.getName());
          if (description.startsWith(""String_Node_Str""))           Utilities.wrapStringToList(I18n.format(""String_Node_Str"",Utilities.getModName(enchant),description),45,false,event.getToolTip());
 else {
            Utilities.wrapStringToList(description,45,false,event.getToolTip());
            if (enchantmentMod)             event.getToolTip().add(I18n.format(""String_Node_Str"",Utilities.getModName(enchant)));
          }
        }
 else         Utilities.wrapStringToList(I18n.format(""String_Node_Str"",keyBindSneak.getDisplayName()),45,false,event.getToolTip());
      }
    }
    if (block != null && showEnchantmentPower)     try {
      final float enchPower=block.getEnchantPowerBonus(event.getEntityPlayer().worldObj,BlockPos.ORIGIN);
      if (enchPower > 0)       event.getToolTip().add(I18n.format(""String_Node_Str"") + ""String_Node_Str"" + enchPower);
    }
 catch (    final IllegalArgumentException exception) {
    }
  }
}",0.987599889776798
135093,"public static void register(IWailaRegistrar register){
  final EntityProvider provider=new EntityProvider();
  register.registerOverrideEntityProvider(provider,Entity.class);
  register.registerBodyProvider(provider,Entity.class);
  register.registerNBTProvider(provider,EntitySkeleton.class);
}","public static void register(IWailaRegistrar register){
  final EntityProvider provider=new EntityProvider();
  register.registerOverrideEntityProvider(provider,Entity.class);
  register.registerBodyProvider(provider,Entity.class);
  register.registerNBTProvider(provider,Entity.class);
}",0.986254295532646
135094,"@Override public DataAccess overrideEntity(DataAccess data){
  InfoAccess info=new InfoAccess(data.world,data.player,data.entity,data.tag);
  if (info.isValidBlock())   for (  InfoProvider provider : Wawla.entityProviders)   if (provider.requireEntityOverride(info))   info=provider.overrideTile(info);
  return new DataAccess(info.world,info.player,info.entity,info.tag);
}","@Override public DataAccess overrideEntity(DataAccess data){
  InfoAccess info=new InfoAccess(data.world,data.player,data.entity,data.tag);
  if (info.entity != null)   for (  InfoProvider provider : Wawla.entityProviders)   if (provider.requireEntityOverride(info))   info=provider.overrideTile(info);
  return new DataAccess(info.world,info.player,info.entity,info.tag);
}",0.962566844919786
135095,"@Override public boolean requireTileSync(World world,TileEntity tile){
  for (  InfoProvider plugin : Wawla.entityProviders)   if (plugin.requireTileSync(world,tile))   return true;
  return false;
}","@Override public boolean requireTileSync(World world,TileEntity tile){
  for (  InfoProvider plugin : Wawla.tileProviders)   if (plugin.requireTileSync(world,tile))   return true;
  return false;
}",0.9848484848484848
135096,"private void syncConfigData(){
  for (  InfoProvider provider : Wawla.tileProviders)   provider.syncConfig(config);
  for (  InfoProvider provider : Wawla.entityProviders)   provider.syncConfig(config);
}","private void syncConfigData(){
  for (  InfoProvider provider : Wawla.tileProviders)   provider.syncConfig(config);
  for (  InfoProvider provider : Wawla.entityProviders)   provider.syncConfig(config);
  config.save();
}",0.96
135097,"@SubscribeEvent public void onTooltip(ItemTooltipEvent event){
  if (event.entityPlayer != null && event.entityPlayer.worldObj != null) {
    boolean isShifting=Minecraft.getMinecraft().gameSettings.isKeyDown(Minecraft.getMinecraft().gameSettings.keyBindSneak);
    if (event.entityPlayer.worldObj.isRemote) {
      Item item=event.itemStack.getItem();
      Block block=Block.getBlockFromItem(item);
      if (item instanceof ItemEnchantedBook) {
        if (isShifting) {
          Enchantment[] enchArr=Utilities.getEnchantmentsFromStack(event.itemStack,true);
          Enchantment ench=enchArr.length > 0 ? enchArr[0] : null;
          if (ench != null) {
            String translation=StatCollector.translateToLocal(""String_Node_Str"" + ench.getName());
            if (translation.startsWith(""String_Node_Str""))             event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str""));
 else             Utilities.wrapStringToList(StatCollector.translateToLocal(""String_Node_Str"" + ench.getName()),45,false,event.toolTip);
          }
        }
 else         event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str""));
      }
 else       if (item instanceof ItemArmor) {
        ItemArmor armor=(ItemArmor)item;
        event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + armor.damageReduceAmount);
      }
      if (!(block instanceof BlockAir) && block != null) {
        float enchPower=block.getEnchantPowerBonus(event.entityPlayer.worldObj,BlockPos.ORIGIN);
        if (enchPower > 0)         event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + enchPower);
      }
    }
  }
}","@SubscribeEvent public void onTooltip(ItemTooltipEvent event){
  if (event.entityPlayer != null && event.entityPlayer.worldObj != null) {
    boolean isShifting=Minecraft.getMinecraft().gameSettings.isKeyDown(Minecraft.getMinecraft().gameSettings.keyBindSneak);
    if (event.entityPlayer.worldObj.isRemote) {
      Item item=event.itemStack.getItem();
      Block block=Block.getBlockFromItem(item);
      if (item instanceof ItemEnchantedBook) {
        if (isShifting) {
          Enchantment[] enchArr=Utilities.getEnchantmentsFromStack(event.itemStack,true);
          Enchantment ench=enchArr.length > 0 ? enchArr[0] : null;
          if (ench != null) {
            String translation=StatCollector.translateToLocal(""String_Node_Str"" + ench.getName());
            if (translation.startsWith(""String_Node_Str""))             event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str""));
 else             Utilities.wrapStringToList(StatCollector.translateToLocal(""String_Node_Str"" + ench.getName()),45,false,event.toolTip);
          }
        }
 else         event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str""));
      }
 else       if (item instanceof ItemArmor) {
        ItemArmor armor=(ItemArmor)item;
        event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + armor.damageReduceAmount);
      }
      if (!(block instanceof BlockAir) && block != null) {
        float enchPower=0;
        try {
          enchPower=block.getEnchantPowerBonus(event.entityPlayer.worldObj,BlockPos.ORIGIN);
        }
 catch (        IllegalArgumentException exception) {
        }
        if (enchPower > 0)         event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + enchPower);
      }
    }
  }
}",0.9680759275237274
135098,"@Override public List<String> getWailaBody(Entity entity,List<String> tip,IWailaEntityAccessor data,IWailaConfigHandler cfg){
  if (entity instanceof EntityLiving && cfg.getConfig(showEquippedItems)) {
    EntityLiving living=(EntityLiving)entity;
    for (int i=0; i < 5; i++) {
      ItemStack stack=living.getEquipmentInSlot(i);
      if (stack != null && data.getPlayer().isSneaking())       tip.add(StatCollector.translateToLocal(""String_Node_Str"" + itemTypes[i]) + ""String_Node_Str"" + stack.getDisplayName());
    }
    if (cfg.getConfig(showEntityArmor) && living.getTotalArmorValue() > 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + living.getTotalArmorValue());
  }
  if (cfg.getConfig(showPetOwner)) {
    NBTTagCompound tag=Utilities.convertEntityToNbt(entity);
    NBTTagCompound extTag=entity.getEntityData();
    for (    String currentKey : petTags) {
      if (tag.hasKey(currentKey) && !tag.getString(currentKey).isEmpty())       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + tag.getString(currentKey));
      if (extTag.hasKey(currentKey) && !extTag.getString(currentKey).isEmpty())       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + extTag.getString(currentKey));
    }
  }
  if (entity instanceof EntityAnimal) {
    EntityAnimal animal=(EntityAnimal)entity;
    if (cfg.getConfig(showAge) && animal.isChild() && animal.getGrowingAge() != 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + ((animal.getGrowingAge() / 20) * -1)+ ""String_Node_Str""+ StatCollector.translateToLocal(""String_Node_Str""));
 else     if (cfg.getConfig(showBirthCooldown) && animal.getGrowingAge() != 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + ((animal.getGrowingAge() / 20))+ ""String_Node_Str""+ StatCollector.translateToLocal(""String_Node_Str""));
  }
  if (entity instanceof EntityTameable && cfg.getConfig(showPetSitting)) {
    EntityTameable pet=(EntityTameable)entity;
    tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + pet.isSitting());
  }
  return tip;
}","@Override public List<String> getWailaBody(Entity entity,List<String> tip,IWailaEntityAccessor data,IWailaConfigHandler cfg){
  if (entity instanceof EntityLiving && cfg.getConfig(showEquippedItems)) {
    EntityLiving living=(EntityLiving)entity;
    for (int i=0; i < 5; i++) {
      ItemStack stack=living.getEquipmentInSlot(i);
      if (stack != null && data.getPlayer().isSneaking())       tip.add(StatCollector.translateToLocal(""String_Node_Str"" + itemTypes[i]) + ""String_Node_Str"" + stack.getDisplayName());
    }
    if (cfg.getConfig(showEntityArmor) && living.getTotalArmorValue() > 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + living.getTotalArmorValue());
  }
  if (cfg.getConfig(showPetOwner)) {
    NBTTagCompound tag=Utilities.convertEntityToNbt(entity);
    NBTTagCompound extTag=entity.getEntityData();
    for (    String currentKey : petTags) {
      if (tag.hasKey(currentKey) && !tag.getString(currentKey).isEmpty())       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + tag.getString(currentKey));
      if (extTag.hasKey(currentKey) && !extTag.getString(currentKey).isEmpty())       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + extTag.getString(currentKey));
    }
  }
  if (entity instanceof EntityAnimal) {
    EntityAnimal animal=(EntityAnimal)entity;
    if (cfg.getConfig(showAge) && animal.isChild() && animal.getGrowingAge() != 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + ((animal.getGrowingAge() / 20) * -1)+ ""String_Node_Str""+ StatCollector.translateToLocal(""String_Node_Str""));
 else     if (cfg.getConfig(showBirthCooldown) && animal.getGrowingAge() != 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + ((animal.getGrowingAge() / 20))+ ""String_Node_Str""+ StatCollector.translateToLocal(""String_Node_Str""));
  }
  if (entity instanceof EntityTameable && cfg.getConfig(showPetSitting)) {
    EntityTameable pet=(EntityTameable)entity;
    if (pet.isTamed())     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + pet.isSitting());
  }
  return tip;
}",0.9947476592829412
135099,"@Override public List<String> getWailaBody(Entity entity,List<String> tip,IWailaEntityAccessor data,IWailaConfigHandler cfg){
  if (entity instanceof EntityHorse) {
    EntityHorse horse=(EntityHorse)entity;
    if (cfg.getConfig(""String_Node_Str""))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + Utilities.round(horse.getHorseJumpStrength(),4));
    if (cfg.getConfig(""String_Node_Str""))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + Utilities.round(horse.getEntityAttribute(SharedMonsterAttributes.movementSpeed).getAttributeValue(),4));
  }
 else   if (cfg.getConfig(showProfession)) {
    String profession=""String_Node_Str"";
    if (FMLCommonHandler.instance().getSide().equals(Side.CLIENT) && entity instanceof EntityVillager) {
      EntityVillager villager=(EntityVillager)entity;
      profession=StatCollector.translateToLocal(""String_Node_Str"" + Utilities.getVillagerName(villager.getProfession()));
    }
    if (entity instanceof EntityZombie) {
      EntityZombie zombie=(EntityZombie)entity;
      if (zombie.isVillager())       profession=StatCollector.translateToLocal(""String_Node_Str"");
    }
    if (entity instanceof EntityWitch)     profession=StatCollector.translateToLocal(""String_Node_Str"");
    if (!profession.isEmpty())     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + profession);
  }
 else   if (entity instanceof EntityTNTPrimed && cfg.getConfig(showTntFuse))   tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + data.getNBTData().getByte(""String_Node_Str""));
  return tip;
}","@Override public List<String> getWailaBody(Entity entity,List<String> tip,IWailaEntityAccessor data,IWailaConfigHandler cfg){
  if (entity instanceof EntityHorse) {
    EntityHorse horse=(EntityHorse)entity;
    if (cfg.getConfig(""String_Node_Str""))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + Utilities.round(horse.getHorseJumpStrength(),4));
    if (cfg.getConfig(""String_Node_Str""))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + Utilities.round(horse.getEntityAttribute(SharedMonsterAttributes.movementSpeed).getAttributeValue(),4));
  }
 else   if (entity instanceof EntityTNTPrimed && cfg.getConfig(showTntFuse))   tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + data.getNBTData().getByte(""String_Node_Str""));
  if (cfg.getConfig(showProfession)) {
    String profession=""String_Node_Str"";
    if (FMLCommonHandler.instance().getSide().equals(Side.CLIENT) && entity instanceof EntityVillager) {
      EntityVillager villager=(EntityVillager)entity;
      profession=StatCollector.translateToLocal(""String_Node_Str"" + Utilities.getVillagerName(villager.getProfession()));
    }
    if (entity instanceof EntityZombie) {
      EntityZombie zombie=(EntityZombie)entity;
      if (zombie.isVillager())       profession=StatCollector.translateToLocal(""String_Node_Str"");
    }
    if (entity instanceof EntityWitch)     profession=StatCollector.translateToLocal(""String_Node_Str"");
    if (!profession.isEmpty())     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + profession);
  }
  return tip;
}",0.8763702801461632
135100,"@Override public List<String> getWailaBody(ItemStack stack,List<String> tip,IWailaDataAccessor data,IWailaConfigHandler cfg){
  if (data.getTileEntity() instanceof TileEntityBeacon) {
    NBTTagCompound tag=data.getNBTData();
    int level=tag.getInteger(""String_Node_Str"");
    int primary=tag.getInteger(""String_Node_Str"");
    int secondary=tag.getInteger(""String_Node_Str"");
    if (cfg.getConfig(showBeaconLevel))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + level);
    if (cfg.getConfig(showBeaconPrimaryEffect) && primary > 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + StatCollector.translateToLocal(Potion.potionTypes[primary].getName()));
    if (cfg.getConfig(showBeaconSecondaryEffect) && secondary > 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + StatCollector.translateToLocal(Potion.potionTypes[secondary].getName()));
  }
 else   if (data.getTileEntity() instanceof TileEntityFurnace) {
    TileEntityFurnace furnace=(TileEntityFurnace)data.getTileEntity();
    int burnTime=data.getNBTData().getInteger(""String_Node_Str"") / 20;
    if (burnTime > 0 && cfg.getConfig(showFurnaceBurnTime))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + burnTime+ ""String_Node_Str""+ StatCollector.translateToLocal(""String_Node_Str""));
    if (data.getPlayer().isSneaking()) {
      ItemStack[] furnaceStacks=Utilities.getInventoryStacks(data.getNBTData(),3);
      if (furnaceStacks[0] != null && cfg.getConfig(showFurnaceInput))       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + furnaceStacks[0].getDisplayName()+ ""String_Node_Str""+ furnaceStacks[0].stackSize);
      if (furnaceStacks[1] != null && cfg.getConfig(showFurnaceFuel))       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + furnaceStacks[1].getDisplayName()+ ""String_Node_Str""+ furnaceStacks[1].stackSize);
      if (furnaceStacks[2] != null && cfg.getConfig(showFurnaceOutput))       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + furnaceStacks[2].getDisplayName()+ ""String_Node_Str""+ furnaceStacks[2].stackSize);
    }
  }
  if (data.getTileEntity() instanceof TileEntitySkull && cfg.getConfig(showSkullName))   tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + NBTUtil.func_152459_a(data.getNBTData().getCompoundTag(""String_Node_Str"")).getName());
  return tip;
}","@Override public List<String> getWailaBody(ItemStack stack,List<String> tip,IWailaDataAccessor data,IWailaConfigHandler cfg){
  if (data.getTileEntity() instanceof TileEntityBeacon) {
    NBTTagCompound tag=data.getNBTData();
    int level=tag.getInteger(""String_Node_Str"");
    int primary=tag.getInteger(""String_Node_Str"");
    int secondary=tag.getInteger(""String_Node_Str"");
    if (cfg.getConfig(showBeaconLevel))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + level);
    if (cfg.getConfig(showBeaconPrimaryEffect) && primary > 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + StatCollector.translateToLocal(Potion.potionTypes[primary].getName()));
    if (cfg.getConfig(showBeaconSecondaryEffect) && secondary > 0)     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + StatCollector.translateToLocal(Potion.potionTypes[secondary].getName()));
  }
 else   if (data.getTileEntity() instanceof TileEntityFurnace) {
    TileEntityFurnace furnace=(TileEntityFurnace)data.getTileEntity();
    int burnTime=data.getNBTData().getInteger(""String_Node_Str"") / 20;
    if (burnTime > 0 && cfg.getConfig(showFurnaceBurnTime))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + burnTime+ ""String_Node_Str""+ StatCollector.translateToLocal(""String_Node_Str""));
    if (data.getPlayer().isSneaking()) {
      ItemStack[] furnaceStacks=Utilities.getInventoryStacks(data.getNBTData(),3);
      if (furnaceStacks[0] != null && cfg.getConfig(showFurnaceInput))       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + furnaceStacks[0].getDisplayName()+ ""String_Node_Str""+ furnaceStacks[0].stackSize);
      if (furnaceStacks[1] != null && cfg.getConfig(showFurnaceFuel))       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + furnaceStacks[1].getDisplayName()+ ""String_Node_Str""+ furnaceStacks[1].stackSize);
      if (furnaceStacks[2] != null && cfg.getConfig(showFurnaceOutput))       tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + furnaceStacks[2].getDisplayName()+ ""String_Node_Str""+ furnaceStacks[2].stackSize);
    }
  }
  if (data.getTileEntity() instanceof TileEntitySkull && cfg.getConfig(showSkullName) && data.getNBTData().hasKey(""String_Node_Str""))   tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + NBTUtil.func_152459_a(data.getNBTData().getCompoundTag(""String_Node_Str"")).getName());
  return tip;
}",0.9907462098838354
135101,"@Override public List<String> getWailaBody(Entity entity,List<String> tip,IWailaEntityAccessor data,IWailaConfigHandler cfg){
  if (entity instanceof EntityHorse) {
    EntityHorse horse=(EntityHorse)entity;
    if (cfg.getConfig(""String_Node_Str""))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + Utilities.round(horse.getHorseJumpStrength(),4));
    if (cfg.getConfig(""String_Node_Str""))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + Utilities.round(horse.getEntityAttribute(SharedMonsterAttributes.movementSpeed).getAttributeValue(),4));
  }
 else   if (cfg.getConfig(showProfession)) {
    String profession=""String_Node_Str"";
    if (FMLCommonHandler.instance().getSide().equals(Side.CLIENT) && entity instanceof EntityVillager) {
      EntityVillager villager=(EntityVillager)entity;
      profession=StatCollector.translateToLocal(""String_Node_Str"" + Utilities.getVillagerName(villager.getProfession()));
    }
    if (entity instanceof EntityZombie) {
      EntityZombie zombie=(EntityZombie)entity;
      if (zombie.isVillager())       profession=StatCollector.translateToLocal(""String_Node_Str"");
    }
    if (entity instanceof EntityWitch)     profession=StatCollector.translateToLocal(""String_Node_Str"");
    tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + profession);
  }
 else   if (entity instanceof EntityTNTPrimed && cfg.getConfig(showTntFuse))   tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + data.getNBTData().getByte(""String_Node_Str""));
  return tip;
}","@Override public List<String> getWailaBody(Entity entity,List<String> tip,IWailaEntityAccessor data,IWailaConfigHandler cfg){
  if (entity instanceof EntityHorse) {
    EntityHorse horse=(EntityHorse)entity;
    if (cfg.getConfig(""String_Node_Str""))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + Utilities.round(horse.getHorseJumpStrength(),4));
    if (cfg.getConfig(""String_Node_Str""))     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + Utilities.round(horse.getEntityAttribute(SharedMonsterAttributes.movementSpeed).getAttributeValue(),4));
  }
 else   if (cfg.getConfig(showProfession)) {
    String profession=""String_Node_Str"";
    if (FMLCommonHandler.instance().getSide().equals(Side.CLIENT) && entity instanceof EntityVillager) {
      EntityVillager villager=(EntityVillager)entity;
      profession=StatCollector.translateToLocal(""String_Node_Str"" + Utilities.getVillagerName(villager.getProfession()));
    }
    if (entity instanceof EntityZombie) {
      EntityZombie zombie=(EntityZombie)entity;
      if (zombie.isVillager())       profession=StatCollector.translateToLocal(""String_Node_Str"");
    }
    if (entity instanceof EntityWitch)     profession=StatCollector.translateToLocal(""String_Node_Str"");
    if (!profession.isEmpty())     tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + profession);
  }
 else   if (entity instanceof EntityTNTPrimed && cfg.getConfig(showTntFuse))   tip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + data.getNBTData().getByte(""String_Node_Str""));
  return tip;
}",0.9904878797177048
135102,"public static void registerAddon(IWailaRegistrar register){
  AddonGenericTiles dataProvider=new AddonGenericTiles();
  register.addConfig(""String_Node_Str"",showTool);
  register.addConfig(""String_Node_Str"",showHarvestable);
  register.addConfig(""String_Node_Str"",showTier);
  register.addConfig(""String_Node_Str"",showProgress);
  register.addConfig(""String_Node_Str"",showLightLevel);
  register.addConfig(""String_Node_Str"",showMonsterSpawn);
  register.addConfig(""String_Node_Str"",showDay);
  register.registerBodyProvider(dataProvider,Block.class);
  if (FMLCommonHandler.instance().getSide().equals(Side.CLIENT))   currentBlockDamage=ReflectionHelper.findField(PlayerControllerMP.class,""String_Node_Str"",""String_Node_Str"");
}","public static void registerAddon(IWailaRegistrar register){
  AddonGenericTiles dataProvider=new AddonGenericTiles();
  register.addConfig(""String_Node_Str"",showTool);
  register.addConfig(""String_Node_Str"",showHarvestable);
  register.addConfig(""String_Node_Str"",showTier);
  register.addConfig(""String_Node_Str"",showProgress);
  register.addConfig(""String_Node_Str"",showLightLevel);
  register.addConfig(""String_Node_Str"",showMonsterSpawn);
  register.addConfig(""String_Node_Str"",showDay);
  register.registerBodyProvider(dataProvider,Block.class);
  if (FMLCommonHandler.instance().getSide().equals(Side.CLIENT))   currentBlockDamage=ReflectionHelper.findField(PlayerControllerMP.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.9877883310719132
135103,"public static void registerAddon(IWailaRegistrar register){
  AddonVanillaEntities dataProvider=new AddonVanillaEntities();
  register.registerBodyProvider(dataProvider,EntityHorse.class);
  register.registerNBTProvider(dataProvider,EntityHorse.class);
  register.registerBodyProvider(dataProvider,EntityVillager.class);
  register.registerBodyProvider(dataProvider,EntityVillager.class);
}","public static void registerAddon(IWailaRegistrar register){
  AddonVanillaEntities dataProvider=new AddonVanillaEntities();
  register.registerBodyProvider(dataProvider,EntityHorse.class);
  register.registerNBTProvider(dataProvider,EntityHorse.class);
  register.registerBodyProvider(dataProvider,EntityVillager.class);
  register.registerNBTProvider(dataProvider,EntityVillager.class);
}",0.993581514762516
135104,"@SubscribeEvent public void onTooltip(ItemTooltipEvent event){
  boolean isShifting=Minecraft.getMinecraft().gameSettings.isKeyDown(Minecraft.getMinecraft().gameSettings.keyBindSneak);
  if (event.entityPlayer.worldObj.isRemote) {
    if (event.itemStack.getItem() instanceof ItemEnchantedBook) {
      if (isShifting) {
        Enchantment[] enchArr=Utilities.getEnchantmentsFromStack(event.itemStack,true);
        Enchantment ench=enchArr.length > 0 ? enchArr[0] : null;
        if (ench != null && !blacklist.contains(ench))         Utilities.wrapStringToList(StatCollector.translateToLocal(""String_Node_Str"" + ench.getName()),45,false,event.toolTip);
      }
 else       event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str""));
    }
 else     if (event.itemStack.getItem() instanceof ItemArmor) {
      ItemArmor armor=(ItemArmor)event.itemStack.getItem();
      event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + armor.damageReduceAmount);
    }
  }
}","@SubscribeEvent public void onTooltip(ItemTooltipEvent event){
  if (event.entityPlayer != null && event.entityPlayer.worldObj != null) {
    boolean isShifting=Minecraft.getMinecraft().gameSettings.isKeyDown(Minecraft.getMinecraft().gameSettings.keyBindSneak);
    if (event.entityPlayer.worldObj.isRemote) {
      if (event.itemStack.getItem() instanceof ItemEnchantedBook) {
        if (isShifting) {
          Enchantment[] enchArr=Utilities.getEnchantmentsFromStack(event.itemStack,true);
          Enchantment ench=enchArr.length > 0 ? enchArr[0] : null;
          if (ench != null && !blacklist.contains(ench))           Utilities.wrapStringToList(StatCollector.translateToLocal(""String_Node_Str"" + ench.getName()),45,false,event.toolTip);
        }
 else         event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str""));
      }
 else       if (event.itemStack.getItem() instanceof ItemArmor) {
        ItemArmor armor=(ItemArmor)event.itemStack.getItem();
        event.toolTip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + armor.damageReduceAmount);
      }
    }
  }
}",0.8305959643359925
135105,"@Override public void onWailaBlockDescription(ItemStack stack,List<String> tooltip,IWailaDataAccessor access,IWailaConfigHandler config){
  MovingObjectPosition pos=access.getPosition();
  Block block=access.getBlock();
  ItemStack item=access.getPlayer().getHeldItem();
  String tool=(block != null) ? block.getHarvestTool(access.getMetadata()) : ""String_Node_Str"";
  int blockLevel=block.getHarvestLevel(access.getMetadata());
  int itemLevel=(item != null) ? item.getItem().getHarvestLevel(item,tool) : 0;
  if (tool != null && tool.equalsIgnoreCase(""String_Node_Str"")) {
    if (block == Blocks.stone)     tool=""String_Node_Str"";
    if (block == Blocks.planks)     tool=""String_Node_Str"";
  }
  if (item != null && (item.getItem().getToolClasses(item).contains(tool) || ModuleTinkers.canHarvest(item,tool))) {
    if (config.getConfig(showHarvestable) && (blockLevel <= itemLevel || blockLevel == 0))     tooltip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + ((EnumChatFormatting.DARK_GREEN + StatCollector.translateToLocal(""String_Node_Str""))));
 else {
      tooltip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + EnumChatFormatting.RED+ StatCollector.translateToLocal(""String_Node_Str""));
      if (config.getConfig(showTier))       tooltip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + blockLevel);
    }
    return;
  }
  if (tool != null && config.getConfig(showTool))   tooltip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + tool);
}","@Override public void onWailaBlockDescription(ItemStack stack,List<String> tooltip,IWailaDataAccessor access,IWailaConfigHandler config){
  MovingObjectPosition pos=access.getPosition();
  Block block=access.getBlock();
  ItemStack item=access.getPlayer().getHeldItem();
  String tool=(block != null) ? block.getHarvestTool(access.getMetadata()) : ""String_Node_Str"";
  int blockLevel=block.getHarvestLevel(access.getMetadata());
  int itemLevel=(item != null) ? item.getItem().getHarvestLevel(item,tool) : 0;
  if (tool != null && tool.equalsIgnoreCase(""String_Node_Str"")) {
    if (block == Blocks.stone)     tool=""String_Node_Str"";
    if (block == Blocks.planks)     tool=""String_Node_Str"";
  }
  if (item != null && (item.getItem().getToolClasses(item).contains(tool) || ModuleTinkers.canHarvest(item,tool))) {
    if (config.getConfig(showHarvestable) && (blockLevel <= itemLevel || blockLevel == 0))     tooltip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + ((EnumChatFormatting.DARK_GREEN + StatCollector.translateToLocal(""String_Node_Str""))));
 else {
      tooltip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + EnumChatFormatting.RED+ StatCollector.translateToLocal(""String_Node_Str""));
      if (config.getConfig(showTier))       tooltip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + blockLevel);
    }
    return;
  }
  if (tool != null && config.getConfig(showTool))   tooltip.add(StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"" + Utilities.upperCase(tool));
}",0.9907848744836352
135106,"@EventHandler public void preInit(FMLPreInitializationEvent event){
  setModMeta(event.getModMetadata());
  new ForgeEventHandler();
  proxy.registerSidedEvents();
  proxy.registerSidedModules();
  proxy.registerSidedPlugins();
}","@EventHandler public void preInit(FMLPreInitializationEvent event){
  setModMeta(event.getModMetadata());
  proxy.registerSidedEvents();
  proxy.registerSidedModules();
  proxy.registerSidedPlugins();
}",0.937354988399072
135107,"@SubscribeEvent public void onItemTooltip(ItemTooltipEvent event){
  for (  Module module : Module.getModules())   module.onTooltipDisplayed(event.itemStack,event.entityPlayer,event.toolTip,event.showAdvancedItemTooltips);
}","@SubscribeEvent public void onItemTooltip(ItemTooltipEvent event){
  for (  Module module : Module.getModules())   module.onTooltipDisplayed(event.itemStack.copy(),event.entityPlayer,event.toolTip,event.showAdvancedItemTooltips);
}",0.9846153846153848
135108,"@Override public void onTooltipDisplayed(ItemStack stack,EntityPlayer player,List<String> toolTip,boolean advanced){
  if (player.worldObj.isRemote) {
    if (stack.getItem() instanceof ItemEnchantedBook) {
      if (Minecraft.getMinecraft().gameSettings.isKeyDown(Minecraft.getMinecraft().gameSettings.keyBindSneak)) {
        Enchantment ench=Utilities.getEnchantmentsFromStack(stack,true)[0];
        if (!blacklist.contains(ench))         Utilities.wrapStringToList(StatCollector.translateToLocal(""String_Node_Str"" + ench.getName()),45,false,toolTip);
      }
 else       toolTip.add(StatCollector.translateToLocal(""String_Node_Str""));
    }
  }
}","@Override public void onTooltipDisplayed(ItemStack stack,EntityPlayer player,List<String> toolTip,boolean advanced){
  if (player.worldObj.isRemote) {
    if (stack.getItem() instanceof ItemEnchantedBook) {
      if (Minecraft.getMinecraft().gameSettings.isKeyDown(Minecraft.getMinecraft().gameSettings.keyBindSneak)) {
        Enchantment ench=Utilities.getEnchantmentsFromStack(stack,true)[0];
        if (ench != null && !blacklist.contains(ench))         Utilities.wrapStringToList(StatCollector.translateToLocal(""String_Node_Str"" + ench.getName()),45,false,toolTip);
      }
 else       toolTip.add(StatCollector.translateToLocal(""String_Node_Str""));
    }
  }
}",0.9878603945371776
135109,"/** 
 * The client side alternative to .registerSidedEvents(), this method should only be called from the client side. The purpose of this method is to register events that are unique to the client.
 */
@Override public void registerSidedEvents(){
  new WailaBlockHandler();
  new WailaEntityHandler();
}","/** 
 * The client side alternative to .registerSidedEvents(), this method should only be called from the client side. The purpose of this method is to register events that are unique to the client.
 */
@Override public void registerSidedEvents(){
  new ForgeEventHandler();
  new WailaBlockHandler();
  new WailaEntityHandler();
}",0.95748031496063
135110,"@EventHandler public void preInit(FMLPreInitializationEvent event){
  setModMeta(event.getModMetadata());
  proxy.registerSidedEvents();
  proxy.registerSidedModules();
  proxy.registerSidedPlugins();
}","@EventHandler public void preInit(FMLPreInitializationEvent event){
  setModMeta(event.getModMetadata());
  new ForgeEventHandler();
  proxy.registerSidedEvents();
  proxy.registerSidedModules();
  proxy.registerSidedPlugins();
}",0.937354988399072
135111,"@SubscribeEvent @SideOnly(Side.CLIENT) public void onItemTooltip(ItemTooltipEvent event){
  for (  Module module : Module.getModules())   module.onTooltipDisplayed(event.itemStack,event.entityPlayer,event.toolTip,event.showAdvancedItemTooltips);
}","@SubscribeEvent public void onItemTooltip(ItemTooltipEvent event){
  for (  Module module : Module.getModules())   module.onTooltipDisplayed(event.itemStack,event.entityPlayer,event.toolTip,event.showAdvancedItemTooltips);
}",0.951167728237792
135112,"/** 
 * The client side alternative to .registerSidedEvents(), this method should only be called from the client side. The purpose of this method is to register events that are unique to the client.
 */
@Override public void registerSidedEvents(){
  new ForgeEventHandler();
  new WailaBlockHandler();
  new WailaEntityHandler();
}","/** 
 * The client side alternative to .registerSidedEvents(), this method should only be called from the client side. The purpose of this method is to register events that are unique to the client.
 */
@Override public void registerSidedEvents(){
  new WailaBlockHandler();
  new WailaEntityHandler();
}",0.9070866141732284
135113,"/** 
 * This is a method that when called will print out all the entries stored by the tryTranslateKey method.
 * @param fileName: This param allows for the location of the file to be changed. By default this should be logs/missingStrings.txt
 * @return : The file being generated.
 */
static File print(String fileName){
  ArrayList<String> lines=TranslationHooks.lines;
  BufferedWriter writer=null;
  try {
    File logFile=new File(fileName + ""String_Node_Str"" + Reference.DATE.format(new Date()).toString()+ ""String_Node_Str"");
    writer=new BufferedWriter(new FileWriter(logFile));
    for (int i=0; i < lines.size(); i++) {
      writer.write(lines.get(i));
      writer.newLine();
    }
    return logFile;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      writer.close();
    }
 catch (    Exception e) {
    }
  }
  return null;
}","/** 
 * This is a method that when called will print out all the entries stored by the tryTranslateKey method.
 * @param fileName: This param allows for the location of the file to be changed. Bydefault this should be logs/missingStrings.txt
 * @return : The file being generated.
 */
static File print(String fileName){
  ArrayList<String> lines=TranslationHooks.lines;
  BufferedWriter writer=null;
  try {
    File logFile=new File(fileName + ""String_Node_Str"" + Reference.DATE.format(new Date()).toString()+ ""String_Node_Str"");
    writer=new BufferedWriter(new FileWriter(logFile));
    for (int i=0; i < lines.size(); i++) {
      writer.write(lines.get(i));
      writer.newLine();
    }
    return logFile;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      writer.close();
    }
 catch (    Exception e) {
    }
  }
  return null;
}",0.9994288977727012
135114,"/** 
 * Registers and enchantment with the blacklist. If an enchantment is on the blacklist its enchantment book will not receive additional information on the tooltip.
 * @param id: ID of the enchantment being added. Can't wait to change this to strings in 1.8
 * @param modid: The id of the mod. Used in case something goes wrong.
 */
public static void registerEnchantToBlacklist(int id,String modid){
  Enchantment ench=Enchantment.enchantmentsList[id];
  if (ench != null)   ModuleEnchantmentBooks.blacklist.add(ench);
 else   Reference.LOG.info(modid + ""String_Node_Str"" + id+ ""String_Node_Str"");
}","/** 
 * Registers and enchantment with the blacklist. If an enchantment is on the blacklist its enchantment book will not receive additional information on the tooltip.
 * @param id: ID of the enchantment being added. Can't wait to change this to strings in1.8
 * @param modid: The id of the mod. Used in case something goes wrong.
 */
public static void registerEnchantToBlacklist(int id,String modid){
  Enchantment ench=Enchantment.enchantmentsList[id];
  if (ench != null)   ModuleEnchantmentBooks.blacklist.add(ench);
 else   Reference.LOG.info(modid + ""String_Node_Str"" + id+ ""String_Node_Str"");
}",0.9991714995857498
135115,"/** 
 * This method is called when waila prints the end of a block tooltip. This is used by waila to print the name of the mod that owns the block.
 * @param stack: An instance of an ItemStack that contains data about the block being looked at.
 * @param tooltip: A list of all the current text being displayed about the block.
 * @param access: An accessor that can be used to pull a bunch of miscellaneous information.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaBlockTail(ItemStack stack,List<String> tooltip,IWailaDataAccessor access,IWailaConfigHandler config){
}","/** 
 * This method is called when waila prints the end of a block tooltip. This is used by waila to print the name of the mod that owns the block.
 * @param stack: An instance of an ItemStack that contains data about the block beinglooked at.
 * @param tooltip: A list of all the current text being displayed about the block.
 * @param access: An accessor that can be used to pull a bunch of miscellaneousinformation.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaBlockTail(ItemStack stack,List<String> tooltip,IWailaDataAccessor access,IWailaConfigHandler config){
}",0.998330550918197
135116,"/** 
 * This method is called when waila prints a block name. This is used to manipulate the display name of the block. This is the upper most section of the tool tip.
 * @param stack: An instance of an ItemStack that contains data about the block being looked at.
 * @param tooltip: A list of all the current text being displayed about the block.
 * @param access: An accessor that can be used to pull a bunch of miscellaneous information.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaBlockName(ItemStack stack,List<String> tooltip,IWailaDataAccessor access,IWailaConfigHandler config){
}","/** 
 * This method is called when waila prints a block name. This is used to manipulate the display name of the block. This is the upper most section of the tool tip.
 * @param stack: An instance of an ItemStack that contains data about the block beinglooked at.
 * @param tooltip: A list of all the current text being displayed about the block.
 * @param access: An accessor that can be used to pull a bunch of miscellaneousinformation.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaBlockName(ItemStack stack,List<String> tooltip,IWailaDataAccessor access,IWailaConfigHandler config){
}",0.9983844911147012
135117,"/** 
 * This method is called when waila prints the name of an entity into an entity tooltip. This is used by waila to display the block name. This is the upper most part of the tooltip.
 * @param entity: An instance of the entity that is currently being looked at by the player.
 * @param tooltip: An list of all the current text being displayed in the top part of the tooltip.
 * @param accessor: An accessor that can be used to pull information.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaEntityName(Entity entity,List<String> tooltip,IWailaEntityAccessor accessor,IWailaConfigHandler config){
}","/** 
 * This method is called when waila prints the name of an entity into an entity tooltip. This is used by waila to display the block name. This is the upper most part of the tooltip.
 * @param entity: An instance of the entity that is currently being looked at by theplayer.
 * @param tooltip: An list of all the current text being displayed in the top part of thetooltip.
 * @param accessor: An accessor that can be used to pull information.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaEntityName(Entity entity,List<String> tooltip,IWailaEntityAccessor accessor,IWailaConfigHandler config){
}",0.9984126984126984
135118,"/** 
 * This method is called when waila prints the description of a block. This can be used to add information about a block. This makes up the middle section of the tool tip.
 * @param stack: An instance of an ItemStack that contains data about the block being looked at.
 * @param tooltip: A list of all the current text being displayed about the block.
 * @param access: An accessor that can be used to pull a bunch of miscellaneous information.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaBlockDescription(ItemStack stack,List<String> tooltip,IWailaDataAccessor access,IWailaConfigHandler config){
}","/** 
 * This method is called when waila prints the description of a block. This can be used to add information about a block. This makes up the middle section of the tool tip.
 * @param stack: An instance of an ItemStack that contains data about the block beinglooked at.
 * @param tooltip: A list of all the current text being displayed about the block.
 * @param access: An accessor that can be used to pull a bunch of miscellaneousinformation.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaBlockDescription(ItemStack stack,List<String> tooltip,IWailaDataAccessor access,IWailaConfigHandler config){
}",0.9984251968503935
135119,"/** 
 * This method is called when Waila displays information on an Entity. This can be used to override the Entity being shown.
 * @param entity: The Entity that is being displayed. This can be overridden to display a custom Entity.
 * @param accessor: An instance of IWailaEntityAccessor containing many goodies for you to use.
 * @param config: Access to the Waila Configuration.
 */
public void onEntityOverride(Entity entity,IWailaEntityAccessor accessor,IWailaConfigHandler config){
}","/** 
 * This method is called when Waila displays information on an Entity. This can be used to override the Entity being shown.
 * @param entity: The Entity that is being displayed. This can be overridden to display acustom Entity.
 * @param accessor: An instance of IWailaEntityAccessor containing many goodies for you touse.
 * @param config: Access to the Waila Configuration.
 */
public void onEntityOverride(Entity entity,IWailaEntityAccessor accessor,IWailaConfigHandler config){
}",0.9979550102249488
135120,"/** 
 * This method is called when waila prints the body of an entity tooltip. This is the middle section of the tooltip.
 * @param entity: An instance of the entity that is currently being looked at by the player.
 * @param tooltip: An list of all the current text being displayed in the middle part of the tooltip.
 * @param accessor: An accessor that can be used to pull information.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaEntityDescription(Entity entity,List<String> tooltip,IWailaEntityAccessor accessor,IWailaConfigHandler config){
}","/** 
 * This method is called when waila prints the body of an entity tooltip. This is the middle section of the tooltip.
 * @param entity: An instance of the entity that is currently being looked at by theplayer.
 * @param tooltip: An list of all the current text being displayed in the middle part ofthe tooltip.
 * @param accessor: An accessor that can be used to pull information.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaEntityDescription(Entity entity,List<String> tooltip,IWailaEntityAccessor accessor,IWailaConfigHandler config){
}",0.9982608695652174
135121,"/** 
 * This method is called when waila prints the end section of a tooltip. This is used by waila to add the name of the mob that the entity is registered to.
 * @param entity: An instance of the entity that is currently being looked at by the player.
 * @param tooltip: An list of all the current text being displayed in the bottom part of the tooltip.
 * @param accessor: An accessor that can be used to pull information.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaEntityTail(Entity entity,List<String> tooltip,IWailaEntityAccessor accessor,IWailaConfigHandler config){
}","/** 
 * This method is called when waila prints the end section of a tooltip. This is used by waila to add the name of the mob that the entity is registered to.
 * @param entity: An instance of the entity that is currently being looked at by theplayer.
 * @param tooltip: An list of all the current text being displayed in the bottom part ofthe tooltip.
 * @param accessor: An accessor that can be used to pull information.
 * @param config: Access to the Waila Configuration.
 */
public void onWailaEntityTail(Entity entity,List<String> tooltip,IWailaEntityAccessor accessor,IWailaConfigHandler config){
}",0.99835255354201
135122,"/** 
 * This method is called when Waila displays information on a block. This can be used to override the block used to generate a waila tooltip with another ItemStack.
 * @param stack: The ItemStack being displayed. This can be overridden to display a custom stack.
 * @param accessor: An instance of IWailaDataAccessor containing many goodies for you to use.
 * @param config: Access to the Waila Configuration.
 */
public ItemStack onBlockOverride(ItemStack stack,IWailaDataAccessor accessor,IWailaConfigHandler config){
  return stack;
}","/** 
 * This method is called when Waila displays information on a block. This can be used to override the block used to generate a waila tooltip with another ItemStack.
 * @param stack: The ItemStack being displayed. This can be overridden to display a customstack.
 * @param accessor: An instance of IWailaDataAccessor containing many goodies for you touse.
 * @param config: Access to the Waila Configuration.
 */
public ItemStack onBlockOverride(ItemStack stack,IWailaDataAccessor accessor,IWailaConfigHandler config){
  return stack;
}",0.99815157116451
135123,"@Override public void onWailaRegistrar(IWailaRegistrar register){
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.registerSyncedNBTKey(""String_Node_Str"",BlockFurnace.class);
}","@Override public void onWailaRegistrar(IWailaRegistrar register){
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.registerSyncedNBTKey(""String_Node_Str"",BlockFurnace.class);
  ItemStack stack=new ItemStack(Item.getItemFromBlock(Blocks.sandstone_stairs));
}",0.902291917973462
135124,"public ModulePixelmon(Boolean enabled){
  super(enabled);
  try {
    classEntityPixelmon=Class.forName(""String_Node_Str"");
    classTileEntityApricornTree=Class.forName(""String_Node_Str"");
    enumNature=Class.forName(""String_Node_Str"");
    enumGrowth=Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
}","public ModulePixelmon(Boolean enabled){
  super(enabled);
  if (enabled) {
    try {
      classEntityPixelmon=Class.forName(""String_Node_Str"");
      classTileEntityApricornTree=Class.forName(""String_Node_Str"");
      enumNature=Class.forName(""String_Node_Str"");
      enumGrowth=Class.forName(""String_Node_Str"");
    }
 catch (    ClassNotFoundException e) {
      e.printStackTrace();
    }
  }
}",0.9486166007905138
135125,"public ModulePixelmon(Boolean Enabled){
  super(true);
  try {
    classEntityPixelmon=Class.forName(""String_Node_Str"");
    classTileEntityApricornTree=Class.forName(""String_Node_Str"");
    enumNature=Class.forName(""String_Node_Str"");
    enumGrowth=Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
}","public ModulePixelmon(Boolean enabled){
  super(enabled);
  try {
    classEntityPixelmon=Class.forName(""String_Node_Str"");
    classTileEntityApricornTree=Class.forName(""String_Node_Str"");
    enumNature=Class.forName(""String_Node_Str"");
    enumGrowth=Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
}",0.9818688981868898
135126,"@Override public ItemStack getWailaStack(IWailaDataAccessor accessor,IWailaConfigHandler config){
  ItemStack stack=accessor.getStack();
  for (  Module module : Module.getModules())   module.onBlockOverride(stack,accessor,config);
  return (stack != null) ? stack : null;
}","@Override public ItemStack getWailaStack(IWailaDataAccessor accessor,IWailaConfigHandler config){
  ItemStack stack=null;
  for (  Module module : Module.getModules())   stack=module.onBlockOverride(stack,accessor,config);
  return (stack != null) ? stack : null;
}",0.7977736549165121
135127,"/** 
 * This method is called when Waila displays information on a block. This can be used to override the block used to generate a waila tooltip with another ItemStack.
 * @param stack: The ItemStack being displayed. This can be overridden to display a custom stack.
 * @param accessor: An instance of IWailaDataAccessor containing many goodies for you to use.
 * @param config: Access to the Waila Configuration.
 */
public void onBlockOverride(ItemStack stack,IWailaDataAccessor accessor,IWailaConfigHandler config){
}","/** 
 * This method is called when Waila displays information on a block. This can be used to override the block used to generate a waila tooltip with another ItemStack.
 * @param stack: The ItemStack being displayed. This can be overridden to display a custom stack.
 * @param accessor: An instance of IWailaDataAccessor containing many goodies for you to use.
 * @param config: Access to the Waila Configuration.
 */
public ItemStack onBlockOverride(ItemStack stack,IWailaDataAccessor accessor,IWailaConfigHandler config){
  return stack;
}",0.9727187206020697
135128,"@EventHandler public void preInit(FMLPreInitializationEvent event){
  setModMeta(event.getModMetadata());
  new Config(event.getSuggestedConfigurationFile());
  proxy.registerSidedEvents();
  proxy.registerSidedModules();
}","@EventHandler public void preInit(FMLPreInitializationEvent event){
  setModMeta(event.getModMetadata());
  new Config(event.getSuggestedConfigurationFile());
  proxy.registerSidedEvents();
  proxy.registerSidedModules();
  proxy.registerSidedPlugins();
}",0.9330543933054394
135129,"public static void callbackRegister(IWailaRegistrar register){
  WailaBlockHandler instance=new WailaBlockHandler();
  register.registerHeadProvider(instance,Block.class);
  register.registerBodyProvider(instance,Block.class);
  register.registerTailProvider(instance,Block.class);
}","public static void callbackRegister(IWailaRegistrar register){
  WailaBlockHandler instance=new WailaBlockHandler();
  register.registerHeadProvider(instance,Block.class);
  register.registerBodyProvider(instance,Block.class);
  register.registerTailProvider(instance,Block.class);
  register.registerStackProvider(instance,Block.class);
}",0.909967845659164
135130,"public static void onWailaRegistrar(IWailaRegistrar register){
  WailaEntityHandler instance=new WailaEntityHandler();
  register.registerHeadProvider(instance,Entity.class);
  register.registerBodyProvider(instance,Entity.class);
  register.registerTailProvider(instance,Entity.class);
  for (  Module module : Module.getModules())   module.onWailaRegistrar(register);
}","public static void onWailaRegistrar(IWailaRegistrar register){
  WailaEntityHandler instance=new WailaEntityHandler();
  register.registerHeadProvider(instance,Entity.class);
  register.registerBodyProvider(instance,Entity.class);
  register.registerTailProvider(instance,Entity.class);
  register.registerOverrideEntityProvider(instance,Entity.class);
  for (  Module module : Module.getModules())   module.onWailaRegistrar(register);
}",0.9183168316831684
135131,"@Override public void onWailaEntityDescription(Entity entity,List<String> tooltip,IWailaEntityAccessor accessor){
  if (entity instanceof EntityLiving) {
    String ench=StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"";
    EntityLiving living=(EntityLiving)entity;
    for (int i=0; i < 5; i++) {
      ItemStack stack=living.getEquipmentInSlot(i);
      if (stack != null) {
        tooltip.add(StatCollector.translateToLocal(""String_Node_Str"" + itemTypes[i]) + ""String_Node_Str"" + stack.getDisplayName());
        Enchantment[] enchantments=Utilities.getEnchantmentsFromStack(stack,false);
        if (accessor.getPlayer().isSneaking()) {
          for (int x=0; x < enchantments.length; x++) {
            String name=StatCollector.translateToLocal(enchantments[x].getName());
            if (!ench.contains(name))             ench=ench + name + ""String_Node_Str"";
          }
        }
      }
    }
    if (accessor.getPlayer().isSneaking()) {
      if (ench.equals(""String_Node_Str""))       tooltip.add(StatCollector.translateToLocal(""String_Node_Str""));
 else {
        ench=ench.substring(0,ench.length() - 2);
        Utilities.wrapStringToList(ench,50,false,tooltip);
      }
    }
  }
}","@Override public void onWailaEntityDescription(Entity entity,List<String> tooltip,IWailaEntityAccessor accessor){
  if (entity instanceof EntityLiving) {
    String ench=StatCollector.translateToLocal(""String_Node_Str"") + ""String_Node_Str"";
    EntityLiving living=(EntityLiving)entity;
    for (int i=0; i < 5; i++) {
      ItemStack stack=living.getEquipmentInSlot(i);
      if (stack != null) {
        tooltip.add(StatCollector.translateToLocal(""String_Node_Str"" + itemTypes[i]) + ""String_Node_Str"" + stack.getDisplayName());
        Enchantment[] enchantments=Utilities.getEnchantmentsFromStack(stack,false);
        if (accessor.getPlayer().isSneaking()) {
          for (int x=0; x < enchantments.length; x++) {
            String name=StatCollector.translateToLocal(enchantments[x].getName());
            if (!ench.contains(name))             ench=ench + name + ""String_Node_Str"";
          }
        }
      }
    }
    if (accessor.getPlayer().isSneaking()) {
      if (!ench.equals(""String_Node_Str"")) {
        ench=ench.substring(0,ench.length() - 2);
      }
    }
  }
}",0.9409722222222222
135132,"@Override public void onWailaRegistrar(IWailaRegistrar register){
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.registerSyncedNBTKey(""String_Node_Str"",TileEntityFurnace.class);
}","@Override public void onWailaRegistrar(IWailaRegistrar register){
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.addConfig(""String_Node_Str"",""String_Node_Str"");
  register.registerSyncedNBTKey(""String_Node_Str"",BlockFurnace.class);
}",0.9800796812749004
135133,"public static void callbackRegister(IWailaRegistrar register){
  WailaBlockHandler instance=new WailaBlockHandler();
  register.registerBodyProvider(instance,Block.class);
}","public static void callbackRegister(IWailaRegistrar register){
  WailaBlockHandler instance=new WailaBlockHandler();
  register.registerHeadProvider(instance,Block.class);
  register.registerBodyProvider(instance,Block.class);
  register.registerTailProvider(instance,Block.class);
}",0.7587719298245614
135134,"public static void onWailaRegistrar(IWailaRegistrar register){
  WailaEntityHandler instance=new WailaEntityHandler();
  register.registerBodyProvider(instance,Entity.class);
  for (  Module module : Module.getModules())   module.onWailaRegistrar(register);
}","public static void onWailaRegistrar(IWailaRegistrar register){
  WailaEntityHandler instance=new WailaEntityHandler();
  register.registerHeadProvider(instance,Entity.class);
  register.registerBodyProvider(instance,Entity.class);
  register.registerTailProvider(instance,Entity.class);
  for (  Module module : Module.getModules())   module.onWailaRegistrar(register);
}",0.8222222222222222
135135,"public CpuData getCpuInfo(){
  final CpuData result=new CpuData(getTotalCpuUsage());
  for (int i=0; i < mCpuInfoList.size(); i++) {
    final CpuInfo info=mCpuInfoList.get(i);
    result.addCpuUtil(info.getUsage());
  }
  return result;
}","public CpuData getCpuInfo(){
  final CpuData result=new CpuData(getTotalCpuUsage());
  if (mCpuInfoList != null) {
    for (int i=0; i < mCpuInfoList.size(); i++) {
      final CpuInfo info=mCpuInfoList.get(i);
      result.addCpuUtil(info.getUsage());
    }
  }
  return result;
}",0.8615384615384616
135136,"public int getBackgroundColor(){
  final int v=mPrefs.getInt(mResources.getString(R.string.pref_key_bg_opacity),0);
  final int level=0;
  final int retVal;
  if (v > 0) {
    final int a=(int)((float)v / 100f * 255);
    retVal=Color.argb(a,level,level,level);
  }
 else {
    retVal=0;
  }
  return retVal;
}","public int getBackgroundColor(){
  final int v=mPrefs.getInt(mResources.getString(R.string.pref_key_bg_opacity),mResources.getInteger(R.integer.background_opacity_default));
  final int level=0;
  final int retVal;
  if (v > 0) {
    final int a=(int)((float)v / 100f * 255);
    retVal=Color.argb(a,level,level,level);
  }
 else {
    retVal=0;
  }
  return retVal;
}",0.911504424778761
135137,"@Override public JsonToken nextToken() throws IOException, JsonParseException {
  MessageUnpacker messageUnpacker=messageUnpackerHolder.get();
  JsonToken nextToken=null;
  if (_parsingContext.inObject() || _parsingContext.inArray()) {
    if (stack.getFirst().isEmpty()) {
      stack.pop();
      _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
      _parsingContext=_parsingContext.getParent();
      if (!messageUnpacker.hasNext()) {
        if (!stack.isEmpty() && !stack.getFirst().isEmpty()) {
          stack.getFirst().consume();
        }
      }
      return _currToken;
    }
  }
  if (!messageUnpacker.hasNext()) {
    if (!_parsingContext.inObject() && !_parsingContext.inArray()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
    _parsingContext=_parsingContext.getParent();
    messageUnpacker.close();
    _handleEOF();
    return _currToken;
  }
  MessageFormat nextFormat=messageUnpacker.getNextFormat();
  ValueType valueType=nextFormat.getValueType();
switch (valueType) {
case NIL:
    messageUnpacker.unpackNil();
  nextToken=JsonToken.VALUE_NULL;
break;
case BOOLEAN:
boolean b=messageUnpacker.unpackBoolean();
nextToken=b ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
break;
case INTEGER:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_NUMBER_INT;
break;
case FLOAT:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_NUMBER_FLOAT;
break;
case STRING:
messageUnpacker.unpackValue(valueHolder);
if (_parsingContext.inObject() && _currToken != JsonToken.FIELD_NAME) {
_parsingContext.setCurrentName(valueHolder.getRef().asRaw().toString());
nextToken=JsonToken.FIELD_NAME;
}
 else {
nextToken=JsonToken.VALUE_STRING;
}
break;
case BINARY:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_EMBEDDED_OBJECT;
break;
case ARRAY:
nextToken=JsonToken.START_ARRAY;
stack.push(new StackItemForArray(messageUnpacker.unpackArrayHeader()));
_parsingContext=_parsingContext.createChildArrayContext(-1,-1);
break;
case MAP:
nextToken=JsonToken.START_OBJECT;
stack.push(new StackItemForObject(messageUnpacker.unpackMapHeader()));
_parsingContext=_parsingContext.createChildObjectContext(-1,-1);
break;
case EXTENDED:
throw new NotImplementedException();
default :
throw new IllegalStateException(""String_Node_Str"");
}
_currToken=nextToken;
if ((_parsingContext.inObject() && (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.FIELD_NAME)) || (_parsingContext.inArray() && _currToken != JsonToken.START_ARRAY)) {
stack.getFirst().consume();
}
return nextToken;
}","@Override public JsonToken nextToken() throws IOException, JsonParseException {
  MessageUnpacker messageUnpacker=messageUnpackerHolder.get();
  JsonToken nextToken=null;
  if (_parsingContext.inObject() || _parsingContext.inArray()) {
    if (stack.getFirst().isEmpty()) {
      stack.pop();
      _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
      _parsingContext=_parsingContext.getParent();
      if (stack.isEmpty()) {
        _handleEOF();
        if (!messageUnpacker.hasNext()) {
          messageUnpacker.close();
        }
      }
      return _currToken;
    }
  }
  MessageFormat nextFormat=messageUnpacker.getNextFormat();
  ValueType valueType=nextFormat.getValueType();
  StackItem newStack=null;
switch (valueType) {
case NIL:
    messageUnpacker.unpackNil();
  nextToken=JsonToken.VALUE_NULL;
break;
case BOOLEAN:
boolean b=messageUnpacker.unpackBoolean();
nextToken=b ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
break;
case INTEGER:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_NUMBER_INT;
break;
case FLOAT:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_NUMBER_FLOAT;
break;
case STRING:
messageUnpacker.unpackValue(valueHolder);
if (_parsingContext.inObject() && _currToken != JsonToken.FIELD_NAME) {
_parsingContext.setCurrentName(valueHolder.getRef().asRaw().toString());
nextToken=JsonToken.FIELD_NAME;
}
 else {
nextToken=JsonToken.VALUE_STRING;
}
break;
case BINARY:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_EMBEDDED_OBJECT;
break;
case ARRAY:
newStack=new StackItemForArray(messageUnpacker.unpackArrayHeader());
break;
case MAP:
newStack=new StackItemForObject(messageUnpacker.unpackMapHeader());
break;
case EXTENDED:
throw new NotImplementedException();
default :
throw new IllegalStateException(""String_Node_Str"");
}
if (_parsingContext.inObject() && nextToken != JsonToken.FIELD_NAME || _parsingContext.inArray()) {
stack.getFirst().consume();
}
if (newStack != null) {
stack.push(newStack);
if (newStack instanceof StackItemForArray) {
nextToken=JsonToken.START_ARRAY;
_parsingContext=_parsingContext.createChildArrayContext(-1,-1);
}
 else if (newStack instanceof StackItemForObject) {
nextToken=JsonToken.START_OBJECT;
_parsingContext=_parsingContext.createChildObjectContext(-1,-1);
}
}
_currToken=nextToken;
return nextToken;
}",0.64902231878333
135138,"@Override public JsonToken nextToken() throws IOException, JsonParseException {
  MessageUnpacker messageUnpacker=messageUnpackerHolder.get();
  JsonToken nextToken=null;
  if (_parsingContext.inObject() || _parsingContext.inArray()) {
    if (stack.getFirst().isEmpty()) {
      stack.pop();
      _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
      _parsingContext=_parsingContext.getParent();
      return _currToken;
    }
  }
  if (!messageUnpacker.hasNext()) {
    if (!_parsingContext.inObject() && !_parsingContext.inArray()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
    _parsingContext=_parsingContext.getParent();
    messageUnpacker.close();
    _handleEOF();
    return _currToken;
  }
  MessageFormat nextFormat=messageUnpacker.getNextFormat();
  ValueType valueType=nextFormat.getValueType();
switch (valueType) {
case NIL:
    messageUnpacker.unpackNil();
  nextToken=JsonToken.VALUE_NULL;
break;
case BOOLEAN:
boolean b=messageUnpacker.unpackBoolean();
nextToken=b ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
break;
case INTEGER:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_NUMBER_INT;
break;
case FLOAT:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_NUMBER_FLOAT;
break;
case STRING:
messageUnpacker.unpackValue(valueHolder);
if (_parsingContext.inObject() && _currToken != JsonToken.FIELD_NAME) {
_parsingContext.setCurrentName(valueHolder.getRef().asRaw().toString());
nextToken=JsonToken.FIELD_NAME;
}
 else {
nextToken=JsonToken.VALUE_STRING;
}
break;
case BINARY:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_EMBEDDED_OBJECT;
break;
case ARRAY:
nextToken=JsonToken.START_ARRAY;
stack.push(new StackItemForArray(messageUnpacker.unpackArrayHeader()));
_parsingContext=_parsingContext.createChildArrayContext(-1,-1);
break;
case MAP:
nextToken=JsonToken.START_OBJECT;
stack.push(new StackItemForObject(messageUnpacker.unpackMapHeader()));
_parsingContext=_parsingContext.createChildObjectContext(-1,-1);
break;
case EXTENDED:
throw new NotImplementedException();
default :
throw new IllegalStateException(""String_Node_Str"");
}
_currToken=nextToken;
if ((_parsingContext.inObject() && (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.FIELD_NAME)) || (_parsingContext.inArray() && _currToken != JsonToken.START_ARRAY)) {
stack.getFirst().consume();
}
return nextToken;
}","@Override public JsonToken nextToken() throws IOException, JsonParseException {
  MessageUnpacker messageUnpacker=messageUnpackerHolder.get();
  JsonToken nextToken=null;
  if (_parsingContext.inObject() || _parsingContext.inArray()) {
    if (stack.getFirst().isEmpty()) {
      stack.pop();
      _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
      _parsingContext=_parsingContext.getParent();
      if (!messageUnpacker.hasNext()) {
        if (!stack.isEmpty() && !stack.getFirst().isEmpty()) {
          stack.getFirst().consume();
        }
      }
      return _currToken;
    }
  }
  if (!messageUnpacker.hasNext()) {
    if (!_parsingContext.inObject() && !_parsingContext.inArray()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
    _parsingContext=_parsingContext.getParent();
    messageUnpacker.close();
    _handleEOF();
    return _currToken;
  }
  MessageFormat nextFormat=messageUnpacker.getNextFormat();
  ValueType valueType=nextFormat.getValueType();
switch (valueType) {
case NIL:
    messageUnpacker.unpackNil();
  nextToken=JsonToken.VALUE_NULL;
break;
case BOOLEAN:
boolean b=messageUnpacker.unpackBoolean();
nextToken=b ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
break;
case INTEGER:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_NUMBER_INT;
break;
case FLOAT:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_NUMBER_FLOAT;
break;
case STRING:
messageUnpacker.unpackValue(valueHolder);
if (_parsingContext.inObject() && _currToken != JsonToken.FIELD_NAME) {
_parsingContext.setCurrentName(valueHolder.getRef().asRaw().toString());
nextToken=JsonToken.FIELD_NAME;
}
 else {
nextToken=JsonToken.VALUE_STRING;
}
break;
case BINARY:
messageUnpacker.unpackValue(valueHolder);
nextToken=JsonToken.VALUE_EMBEDDED_OBJECT;
break;
case ARRAY:
nextToken=JsonToken.START_ARRAY;
stack.push(new StackItemForArray(messageUnpacker.unpackArrayHeader()));
_parsingContext=_parsingContext.createChildArrayContext(-1,-1);
break;
case MAP:
nextToken=JsonToken.START_OBJECT;
stack.push(new StackItemForObject(messageUnpacker.unpackMapHeader()));
_parsingContext=_parsingContext.createChildObjectContext(-1,-1);
break;
case EXTENDED:
throw new NotImplementedException();
default :
throw new IllegalStateException(""String_Node_Str"");
}
_currToken=nextToken;
if ((_parsingContext.inObject() && (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.FIELD_NAME)) || (_parsingContext.inArray() && _currToken != JsonToken.START_ARRAY)) {
stack.getFirst().consume();
}
return nextToken;
}",0.969499328601573
135139,"@Before public void setup(){
  factory=new MessagePackFactory();
  objectMapper=new ObjectMapper(factory);
  out=new ByteArrayOutputStream();
  in=new ByteArrayInputStream(new byte[4096]);
  normalPojo=new NormalPojo();
  normalPojo.setS(""String_Node_Str"");
  normalPojo.i=Integer.MAX_VALUE;
  normalPojo.l=Long.MIN_VALUE;
  normalPojo.f=Float.MIN_VALUE;
  normalPojo.d=Double.MAX_VALUE;
  normalPojo.b=new byte[]{0x01,0x02,(byte)0xFE,(byte)0xFF};
  normalPojo.bi=BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
  normalPojo.suit=Suit.HEART;
}","@Before public void setup(){
  factory=new MessagePackFactory();
  objectMapper=new ObjectMapper(factory);
  out=new ByteArrayOutputStream();
  in=new ByteArrayInputStream(new byte[4096]);
  normalPojo=new NormalPojo();
  normalPojo.setS(""String_Node_Str"");
  normalPojo.i=Integer.MAX_VALUE;
  normalPojo.l=Long.MIN_VALUE;
  normalPojo.f=Float.MIN_VALUE;
  normalPojo.d=Double.MAX_VALUE;
  normalPojo.b=new byte[]{0x01,0x02,(byte)0xFE,(byte)0xFF};
  normalPojo.bi=BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);
  normalPojo.suit=Suit.HEART;
  nestedListPojo=new NestedListPojo();
  nestedListPojo.s=""String_Node_Str"";
  nestedListPojo.strs=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  tinyPojo=new TinyPojo();
  tinyPojo.t=""String_Node_Str"";
  nestedListComplexPojo=new NestedListComplexPojo();
  nestedListComplexPojo.s=""String_Node_Str"";
  nestedListComplexPojo.foos=new ArrayList<TinyPojo>();
  nestedListComplexPojo.foos.add(tinyPojo);
}",0.7146562905317769
135140,"@Override public ObjectCodec getCodec(){
  System.out.println(""String_Node_Str"");
  return codec;
}","@Override public ObjectCodec getCodec(){
  return codec;
}",0.7388535031847133
135141,"@Override protected boolean loadMore() throws IOException {
  System.out.println(""String_Node_Str"");
  return false;
}","@Override protected boolean loadMore() throws IOException {
  return false;
}",0.7897435897435897
135142,"@Override public void setCodec(ObjectCodec c){
  System.out.println(""String_Node_Str"");
  codec=c;
}","@Override public void setCodec(ObjectCodec c){
  codec=c;
}",0.7421383647798742
135143,"@Override public char[] getTextCharacters() throws IOException, JsonParseException {
  System.out.println(""String_Node_Str"");
  return new char[0];
}","@Override public char[] getTextCharacters() throws IOException, JsonParseException {
  return new char[0];
}",0.8404669260700389
135144,"@Override public int getTextLength() throws IOException, JsonParseException {
  System.out.println(""String_Node_Str"");
  return 0;
}","@Override public int getTextLength() throws IOException, JsonParseException {
  return 0;
}",0.8161434977578476
135145,"@Override protected void _closeInput() throws IOException {
  System.out.println(""String_Node_Str"");
}","@Override protected void _closeInput() throws IOException {
}",0.7484662576687117
135146,"@Override public int getTextOffset() throws IOException, JsonParseException {
  System.out.println(""String_Node_Str"");
  return 0;
}","@Override public int getTextOffset() throws IOException, JsonParseException {
  return 0;
}",0.8161434977578476
135147,"@Override public JsonToken nextToken() throws IOException, JsonParseException {
  JsonToken nextToken=null;
  if (!unpacker.hasNext()) {
    if (_parsingContext.inObject()) {
      nextToken=JsonToken.END_OBJECT;
    }
 else     if (_parsingContext.inArray()) {
      nextToken=JsonToken.END_ARRAY;
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
    _currToken=nextToken;
    _parsingContext=_parsingContext.getParent();
    _handleEOF();
    unpacker.close();
    return nextToken;
  }
  if (_parsingContext.inObject() || _parsingContext.inArray()) {
    if (stack.getFirst().isEmpty()) {
      stack.pop();
      _parsingContext=_parsingContext.getParent();
      _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
      return _currToken;
    }
  }
  MessageFormat nextFormat=unpacker.getNextFormat();
  ValueType valueType=nextFormat.getValueType();
switch (valueType) {
case NIL:
    unpacker.unpackNil();
  nextToken=JsonToken.VALUE_NULL;
break;
case BOOLEAN:
boolean b=unpacker.unpackBoolean();
nextToken=b ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
break;
case INTEGER:
unpacker.unpackInteger(integerHolder);
currentNumber=integerHolder.isBigInteger() ? integerHolder.toBigInteger() : integerHolder.toLong();
nextToken=JsonToken.VALUE_NUMBER_INT;
break;
case FLOAT:
currentDouble=unpacker.unpackDouble();
nextToken=JsonToken.VALUE_NUMBER_FLOAT;
break;
case STRING:
String str=unpacker.unpackString();
currentString=str;
if (_parsingContext.inObject() && _currToken != JsonToken.FIELD_NAME) {
_parsingContext.setCurrentName(str);
nextToken=JsonToken.FIELD_NAME;
}
 else {
nextToken=JsonToken.VALUE_STRING;
}
break;
case BINARY:
nextToken=JsonToken.VALUE_STRING;
break;
case ARRAY:
nextToken=JsonToken.START_ARRAY;
stack.push(new StackItemForArray(unpacker.unpackMapHeader()));
_parsingContext=_parsingContext.createChildArrayContext(-1,-1);
break;
case MAP:
nextToken=JsonToken.START_OBJECT;
stack.push(new StackItemForObject(unpacker.unpackMapHeader()));
_parsingContext=_parsingContext.createChildObjectContext(-1,-1);
break;
case EXTENDED:
throw new NotImplementedException();
default :
throw new IllegalStateException(""String_Node_Str"");
}
_currToken=nextToken;
if ((_parsingContext.inObject() && (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.FIELD_NAME)) || (_parsingContext.inArray() && _currToken != JsonToken.START_ARRAY)) {
stack.getFirst().consume();
}
return nextToken;
}","@Override public JsonToken nextToken() throws IOException, JsonParseException {
  JsonToken nextToken=null;
  if (_parsingContext.inObject() || _parsingContext.inArray()) {
    if (stack.getFirst().isEmpty()) {
      stack.pop();
      _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
      _parsingContext=_parsingContext.getParent();
      return _currToken;
    }
  }
  if (!unpacker.hasNext()) {
    if (!_parsingContext.inObject() && !_parsingContext.inArray()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    _currToken=_parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
    _parsingContext=_parsingContext.getParent();
    unpacker.close();
    _handleEOF();
    return _currToken;
  }
  MessageFormat nextFormat=unpacker.getNextFormat();
  ValueType valueType=nextFormat.getValueType();
switch (valueType) {
case NIL:
    unpacker.unpackNil();
  nextToken=JsonToken.VALUE_NULL;
break;
case BOOLEAN:
boolean b=unpacker.unpackBoolean();
nextToken=b ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
break;
case INTEGER:
unpacker.unpackInteger(integerHolder);
currentNumber=integerHolder.isBigInteger() ? integerHolder.toBigInteger() : integerHolder.toLong();
nextToken=JsonToken.VALUE_NUMBER_INT;
break;
case FLOAT:
currentDouble=unpacker.unpackDouble();
nextToken=JsonToken.VALUE_NUMBER_FLOAT;
break;
case STRING:
String str=unpacker.unpackString();
currentString=str;
if (_parsingContext.inObject() && _currToken != JsonToken.FIELD_NAME) {
_parsingContext.setCurrentName(str);
nextToken=JsonToken.FIELD_NAME;
}
 else {
nextToken=JsonToken.VALUE_STRING;
}
break;
case BINARY:
nextToken=JsonToken.VALUE_STRING;
break;
case ARRAY:
nextToken=JsonToken.START_ARRAY;
stack.push(new StackItemForArray(unpacker.unpackMapHeader()));
_parsingContext=_parsingContext.createChildArrayContext(-1,-1);
break;
case MAP:
nextToken=JsonToken.START_OBJECT;
stack.push(new StackItemForObject(unpacker.unpackMapHeader()));
_parsingContext=_parsingContext.createChildObjectContext(-1,-1);
break;
case EXTENDED:
throw new NotImplementedException();
default :
throw new IllegalStateException(""String_Node_Str"");
}
_currToken=nextToken;
if ((_parsingContext.inObject() && (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.FIELD_NAME)) || (_parsingContext.inArray() && _currToken != JsonToken.START_ARRAY)) {
stack.getFirst().consume();
}
return nextToken;
}",0.824847250509165
135148,"@Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {
  System.out.println(""String_Node_Str"");
  return new byte[0];
}","@Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {
  return new byte[0];
}",0.862876254180602
135149,"@Override protected void _finishString() throws IOException, JsonParseException {
  System.out.println(""String_Node_Str"");
}","@Override protected void _finishString() throws IOException, JsonParseException {
}",0.8019323671497585
135150,"@Test public void testParserShouldReadObject() throws IOException {
  MessagePacker packer=new MessagePacker(out);
  packer.packMapHeader(6);
  packer.packString(""String_Node_Str"");
  packer.packString(""String_Node_Str"");
  packer.packString(""String_Node_Str"");
  packer.packInt(Integer.MIN_VALUE);
  packer.packString(""String_Node_Str"");
{
    packer.packMapHeader(2);
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packInt(Integer.MAX_VALUE);
  }
  packer.packString(""String_Node_Str"");
  packer.packDouble(Double.MAX_VALUE);
  packer.packString(""String_Node_Str"");
  packer.packLong(Long.MIN_VALUE);
  packer.packString(""String_Node_Str"");
  BigInteger bigInteger=new BigInteger(Long.toString(Long.MAX_VALUE));
  packer.packBigInteger(bigInteger.add(BigInteger.ONE));
  packer.flush();
  byte[] bytes=out.toByteArray();
  TypeReference<Map<String,Object>> typeReference=new TypeReference<Map<String,Object>>(){
  }
;
  Map<String,Object> object=objectMapper.readValue(bytes,typeReference);
  assertEquals(6,object.keySet().size());
  int bitmap=0;
  for (  Map.Entry<String,Object> entry : object.entrySet()) {
    String k=entry.getKey();
    Object v=entry.getValue();
    if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 0;
      assertEquals(""String_Node_Str"",v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 1;
      assertEquals((long)Integer.MIN_VALUE,v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 2;
      Map<String,Object> child=(Map<String,Object>)v;
      assertEquals(2,child.keySet().size());
      for (      Map.Entry<String,Object> childEntry : child.entrySet()) {
        String ck=childEntry.getKey();
        Object cv=childEntry.getValue();
        if (ck.equals(""String_Node_Str"")) {
          bitmap|=1 << 3;
          assertEquals(""String_Node_Str"",cv);
        }
 else         if (ck.equals(""String_Node_Str"")) {
          bitmap|=1 << 4;
          assertEquals((long)Integer.MAX_VALUE,cv);
        }
      }
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 5;
      assertEquals(Double.MAX_VALUE,(Double)v,0.0001f);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 6;
      assertEquals(Long.MIN_VALUE,v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 7;
      BigInteger bi=new BigInteger(Long.toString(Long.MAX_VALUE));
      assertEquals(bi.add(BigInteger.ONE),v);
    }
  }
  assertEquals(0xFF,bitmap);
}","@Test public void testParserShouldReadObject() throws IOException {
  MessagePacker packer=new MessagePacker(out);
  packer.packMapHeader(7);
  packer.packString(""String_Node_Str"");
  packer.packString(""String_Node_Str"");
  packer.packString(""String_Node_Str"");
  packer.packInt(Integer.MIN_VALUE);
  packer.packString(""String_Node_Str"");
{
    packer.packMapHeader(2);
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packInt(Integer.MAX_VALUE);
  }
  packer.packString(""String_Node_Str"");
  packer.packDouble(Double.MAX_VALUE);
  packer.packString(""String_Node_Str"");
  packer.packLong(Long.MIN_VALUE);
  packer.packString(""String_Node_Str"");
  BigInteger bigInteger=new BigInteger(Long.toString(Long.MAX_VALUE));
  packer.packBigInteger(bigInteger.add(BigInteger.ONE));
  packer.packString(""String_Node_Str"");
{
    packer.packArrayHeader(3);
    packer.packFloat(Float.MIN_VALUE);
    packer.packNil();
    packer.packString(""String_Node_Str"");
  }
  packer.flush();
  byte[] bytes=out.toByteArray();
  TypeReference<Map<String,Object>> typeReference=new TypeReference<Map<String,Object>>(){
  }
;
  Map<String,Object> object=objectMapper.readValue(bytes,typeReference);
  assertEquals(7,object.keySet().size());
  int bitmap=0;
  for (  Map.Entry<String,Object> entry : object.entrySet()) {
    String k=entry.getKey();
    Object v=entry.getValue();
    if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 0;
      assertEquals(""String_Node_Str"",v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 1;
      assertEquals((long)Integer.MIN_VALUE,v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 2;
      Map<String,Object> child=(Map<String,Object>)v;
      assertEquals(2,child.keySet().size());
      for (      Map.Entry<String,Object> childEntry : child.entrySet()) {
        String ck=childEntry.getKey();
        Object cv=childEntry.getValue();
        if (ck.equals(""String_Node_Str"")) {
          bitmap|=1 << 3;
          assertEquals(""String_Node_Str"",cv);
        }
 else         if (ck.equals(""String_Node_Str"")) {
          bitmap|=1 << 4;
          assertEquals((long)Integer.MAX_VALUE,cv);
        }
      }
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 5;
      assertEquals(Double.MAX_VALUE,(Double)v,0.0001f);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 6;
      assertEquals(Long.MIN_VALUE,v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 7;
      BigInteger bi=new BigInteger(Long.toString(Long.MAX_VALUE));
      assertEquals(bi.add(BigInteger.ONE),v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 8;
      List<? extends Serializable> expected=Arrays.asList((double)Float.MIN_VALUE,null,""String_Node_Str"");
      assertEquals(expected,v);
    }
  }
  assertEquals(0x1FF,bitmap);
}",0.9277525022747952
135151,"@Test public void testParserShouldReadArray() throws IOException {
  MessagePacker packer=new MessagePacker(out);
  packer.packArrayHeader(6);
  packer.packString(""String_Node_Str"");
  packer.packInt(Integer.MAX_VALUE);
  packer.packLong(Long.MIN_VALUE);
  packer.packFloat(Float.MAX_VALUE);
  packer.packDouble(Double.MIN_VALUE);
  BigInteger bi=new BigInteger(Long.toString(Long.MAX_VALUE));
  bi=bi.add(BigInteger.ONE);
  packer.packBigInteger(bi);
  packer.flush();
  byte[] bytes=out.toByteArray();
  TypeReference<List<Object>> typeReference=new TypeReference<List<Object>>(){
  }
;
  List<Object> array=objectMapper.readValue(bytes,typeReference);
  assertEquals(6,array.size());
  int i=0;
  assertEquals(""String_Node_Str"",array.get(i++));
  assertEquals((long)Integer.MAX_VALUE,array.get(i++));
  assertEquals(Long.MIN_VALUE,array.get(i++));
  assertEquals(Float.MAX_VALUE,(Double)array.get(i++),0.001f);
  assertEquals(Double.MIN_VALUE,(Double)array.get(i++),0.001f);
  assertEquals(bi,array.get(i++));
}","@Test public void testParserShouldReadArray() throws IOException {
  MessagePacker packer=new MessagePacker(out);
  packer.packArrayHeader(8);
  packer.packArrayHeader(3);
{
    packer.packLong(Long.MAX_VALUE);
    packer.packNil();
    packer.packString(""String_Node_Str"");
  }
  packer.packString(""String_Node_Str"");
  packer.packInt(Integer.MAX_VALUE);
  packer.packLong(Long.MIN_VALUE);
  packer.packFloat(Float.MAX_VALUE);
  packer.packDouble(Double.MIN_VALUE);
  BigInteger bi=new BigInteger(Long.toString(Long.MAX_VALUE));
  bi=bi.add(BigInteger.ONE);
  packer.packBigInteger(bi);
  packer.packMapHeader(2);
{
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packInt(42);
  }
  packer.flush();
  byte[] bytes=out.toByteArray();
  TypeReference<List<Object>> typeReference=new TypeReference<List<Object>>(){
  }
;
  List<Object> array=objectMapper.readValue(bytes,typeReference);
  assertEquals(8,array.size());
  int i=0;
  List<Object> childArray=(List<Object>)array.get(i++);
{
    int j=0;
    assertEquals(Long.MAX_VALUE,childArray.get(j++));
    assertEquals(null,childArray.get(j++));
    assertEquals(""String_Node_Str"",childArray.get(j++));
  }
  assertEquals(""String_Node_Str"",array.get(i++));
  assertEquals((long)Integer.MAX_VALUE,array.get(i++));
  assertEquals(Long.MIN_VALUE,array.get(i++));
  assertEquals(Float.MAX_VALUE,(Double)array.get(i++),0.001f);
  assertEquals(Double.MIN_VALUE,(Double)array.get(i++),0.001f);
  assertEquals(bi,array.get(i++));
  Map<String,Object> childMap=(Map<String,Object>)array.get(i++);
{
    assertEquals(2,childMap.keySet().size());
    for (    Map.Entry<String,Object> entry : childMap.entrySet()) {
      String k=entry.getKey();
      Object v=entry.getValue();
      if (k.equals(""String_Node_Str"")) {
        assertEquals(""String_Node_Str"",v);
      }
 else       if (k.equals(""String_Node_Str"")) {
        assertEquals((long)42,v);
      }
    }
  }
}",0.6699834162520729
135152,"@Override public JsonToken nextToken() throws IOException, JsonParseException {
  JsonToken nextToken=null;
  if (!unpacker.hasNext()) {
    _currToken=null;
    _parsingContext=_parsingContext.getParent();
    _handleEOF();
    unpacker.close();
    return null;
  }
  if (_parsingContext.inObject()) {
    if (stack.getFirst().isEmpty()) {
      stack.pop();
      _parsingContext=_parsingContext.getParent();
      _currToken=JsonToken.END_OBJECT;
      return _currToken;
    }
  }
  MessageFormat nextFormat=unpacker.getNextFormat();
  ValueType valueType=nextFormat.getValueType();
switch (valueType) {
case NIL:
    unpacker.unpackNil();
  nextToken=JsonToken.VALUE_NULL;
break;
case BOOLEAN:
boolean b=unpacker.unpackBoolean();
nextToken=b ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
break;
case INTEGER:
unpacker.unpackInteger(integerHolder);
currentNumber=integerHolder.isBigInteger() ? integerHolder.toBigInteger() : integerHolder.toLong();
nextToken=JsonToken.VALUE_NUMBER_INT;
break;
case FLOAT:
currentDouble=unpacker.unpackDouble();
nextToken=JsonToken.VALUE_NUMBER_FLOAT;
break;
case STRING:
String str=unpacker.unpackString();
if (_parsingContext.inObject() && _currToken != JsonToken.FIELD_NAME) {
_parsingContext.setCurrentName(str);
nextToken=JsonToken.FIELD_NAME;
}
 else {
currentString=str;
nextToken=JsonToken.VALUE_STRING;
}
break;
case BINARY:
nextToken=JsonToken.VALUE_STRING;
break;
case ARRAY:
nextToken=JsonToken.START_ARRAY;
break;
case MAP:
nextToken=JsonToken.START_OBJECT;
stack.push(new StackItemForObject(unpacker.unpackMapHeader()));
_parsingContext=_parsingContext.createChildObjectContext(-1,-1);
break;
case EXTENDED:
throw new NotImplementedException();
default :
throw new IllegalStateException(""String_Node_Str"");
}
_currToken=nextToken;
if (_parsingContext.inObject() && (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.FIELD_NAME)) {
stack.getFirst().consume();
}
return nextToken;
}","@Override public JsonToken nextToken() throws IOException, JsonParseException {
  JsonToken nextToken=null;
  if (!unpacker.hasNext()) {
    _currToken=null;
    _parsingContext=_parsingContext.getParent();
    _handleEOF();
    unpacker.close();
    return null;
  }
  if (_parsingContext.inObject()) {
    if (stack.getFirst().isEmpty()) {
      stack.pop();
      _parsingContext=_parsingContext.getParent();
      _currToken=JsonToken.END_OBJECT;
      return _currToken;
    }
  }
  MessageFormat nextFormat=unpacker.getNextFormat();
  ValueType valueType=nextFormat.getValueType();
switch (valueType) {
case NIL:
    unpacker.unpackNil();
  nextToken=JsonToken.VALUE_NULL;
break;
case BOOLEAN:
boolean b=unpacker.unpackBoolean();
nextToken=b ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
break;
case INTEGER:
unpacker.unpackInteger(integerHolder);
currentNumber=integerHolder.isBigInteger() ? integerHolder.toBigInteger() : integerHolder.toLong();
nextToken=JsonToken.VALUE_NUMBER_INT;
break;
case FLOAT:
currentDouble=unpacker.unpackDouble();
nextToken=JsonToken.VALUE_NUMBER_FLOAT;
break;
case STRING:
String str=unpacker.unpackString();
if (_parsingContext.inObject() && _currToken != JsonToken.FIELD_NAME) {
currentString=str;
_parsingContext.setCurrentName(str);
nextToken=JsonToken.FIELD_NAME;
}
 else {
currentString=str;
nextToken=JsonToken.VALUE_STRING;
}
break;
case BINARY:
nextToken=JsonToken.VALUE_STRING;
break;
case ARRAY:
nextToken=JsonToken.START_ARRAY;
break;
case MAP:
nextToken=JsonToken.START_OBJECT;
stack.push(new StackItemForObject(unpacker.unpackMapHeader()));
_parsingContext=_parsingContext.createChildObjectContext(-1,-1);
break;
case EXTENDED:
throw new NotImplementedException();
default :
throw new IllegalStateException(""String_Node_Str"");
}
_currToken=nextToken;
if (_parsingContext.inObject() && (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.FIELD_NAME)) {
stack.getFirst().consume();
}
return nextToken;
}",0.99514687100894
135153,"@Test public void testParserShouldReadObject() throws IOException {
  MessagePacker packer=new MessagePacker(out);
  packer.packMapHeader(6);
  packer.packString(""String_Node_Str"");
  packer.packString(""String_Node_Str"");
  packer.packString(""String_Node_Str"");
  packer.packInt(Integer.MIN_VALUE);
  packer.packString(""String_Node_Str"");
{
    packer.packMapHeader(2);
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packInt(Integer.MAX_VALUE);
  }
  packer.packString(""String_Node_Str"");
  packer.packDouble(Double.MAX_VALUE);
  packer.packString(""String_Node_Str"");
  packer.packLong(Long.MIN_VALUE);
  packer.packString(""String_Node_Str"");
  BigInteger bigInteger=new BigInteger(Long.toString(Long.MAX_VALUE));
  packer.packBigInteger(bigInteger.add(BigInteger.ONE));
  packer.flush();
  byte[] bytes=out.toByteArray();
  TypeReference<Map<String,Object>> typeReference=new TypeReference<Map<String,Object>>(){
  }
;
  Map<String,Object> object=objectMapper.readValue(bytes,typeReference);
  assertEquals(6,object.keySet().size());
  int bitmap=0;
  for (  Map.Entry<String,Object> entry : object.entrySet()) {
    String k=entry.getKey();
    Object v=entry.getValue();
    if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 0;
      assertEquals(""String_Node_Str"",v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 1;
      assertEquals((long)Integer.MIN_VALUE,v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 2;
      Map<String,Object> child=(Map<String,Object>)v;
      assertEquals(2,child.keySet().size());
      for (      Map.Entry<String,Object> childEntry : child.entrySet()) {
        System.out.println(childEntry);
        String ck=childEntry.getKey();
        Object cv=childEntry.getValue();
        if (ck.equals(""String_Node_Str"")) {
          bitmap|=1 << 3;
          assertEquals(""String_Node_Str"",cv);
        }
 else         if (ck.equals(""String_Node_Str"")) {
          bitmap|=1 << 4;
          assertEquals(Integer.MAX_VALUE,cv);
        }
      }
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 5;
      assertEquals(Double.MAX_VALUE,(Double)v,0.0001f);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 6;
      assertEquals(Long.MIN_VALUE,v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 7;
      BigInteger bi=new BigInteger(Long.toString(Long.MAX_VALUE));
      assertEquals(bi.add(BigInteger.ONE),v);
    }
  }
  assertEquals(0xFF,bitmap);
}","@Test public void testParserShouldReadObject() throws IOException {
  MessagePacker packer=new MessagePacker(out);
  packer.packMapHeader(6);
  packer.packString(""String_Node_Str"");
  packer.packString(""String_Node_Str"");
  packer.packString(""String_Node_Str"");
  packer.packInt(Integer.MIN_VALUE);
  packer.packString(""String_Node_Str"");
{
    packer.packMapHeader(2);
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packString(""String_Node_Str"");
    packer.packInt(Integer.MAX_VALUE);
  }
  packer.packString(""String_Node_Str"");
  packer.packDouble(Double.MAX_VALUE);
  packer.packString(""String_Node_Str"");
  packer.packLong(Long.MIN_VALUE);
  packer.packString(""String_Node_Str"");
  BigInteger bigInteger=new BigInteger(Long.toString(Long.MAX_VALUE));
  packer.packBigInteger(bigInteger.add(BigInteger.ONE));
  packer.flush();
  byte[] bytes=out.toByteArray();
  TypeReference<Map<String,Object>> typeReference=new TypeReference<Map<String,Object>>(){
  }
;
  Map<String,Object> object=objectMapper.readValue(bytes,typeReference);
  assertEquals(6,object.keySet().size());
  int bitmap=0;
  for (  Map.Entry<String,Object> entry : object.entrySet()) {
    String k=entry.getKey();
    Object v=entry.getValue();
    if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 0;
      assertEquals(""String_Node_Str"",v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 1;
      assertEquals((long)Integer.MIN_VALUE,v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 2;
      Map<String,Object> child=(Map<String,Object>)v;
      assertEquals(2,child.keySet().size());
      for (      Map.Entry<String,Object> childEntry : child.entrySet()) {
        String ck=childEntry.getKey();
        Object cv=childEntry.getValue();
        if (ck.equals(""String_Node_Str"")) {
          bitmap|=1 << 3;
          assertEquals(""String_Node_Str"",cv);
        }
 else         if (ck.equals(""String_Node_Str"")) {
          bitmap|=1 << 4;
          assertEquals((long)Integer.MAX_VALUE,cv);
        }
      }
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 5;
      assertEquals(Double.MAX_VALUE,(Double)v,0.0001f);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 6;
      assertEquals(Long.MIN_VALUE,v);
    }
 else     if (k.equals(""String_Node_Str"")) {
      bitmap|=1 << 7;
      BigInteger bi=new BigInteger(Long.toString(Long.MAX_VALUE));
      assertEquals(bi.add(BigInteger.ONE),v);
    }
  }
  assertEquals(0xFF,bitmap);
}",0.9910436137071652
135154,"private String promptUserForNewWatchListPanelName(){
  TextInputDialog dialog=new TextInputDialog(DEFAULT_WATCH_LIST_PANEL_NAME);
  dialog.setTitle(WATCH_LIST_PANEL_NAME_PROMPT_TITLE);
  dialog.setHeaderText(WATCH_LIST_PANEL_NAME_PROMPT_HEADER);
  Optional<String> result=dialog.showAndWait();
  return result.orElse(DEFAULT_WATCH_LIST_PANEL_NAME);
}","private Optional<String> promptUserForNewWatchListPanelName(){
  TextInputDialog dialog=new TextInputDialog(DEFAULT_WATCH_LIST_PANEL_NAME);
  dialog.setTitle(WATCH_LIST_PANEL_NAME_PROMPT_TITLE);
  dialog.setHeaderText(WATCH_LIST_PANEL_NAME_PROMPT_HEADER);
  Optional<String> result=dialog.showAndWait();
  return result;
}",0.9107142857142856
135155,"/** 
 * Selects the next milestone in the list of best matching milestones
 */
public void selectNextBestMatchingMilestone(){
  Optional<Integer> curSelectedIndex=getSelectedIndex(bestMatchingMilestones);
  if (canIncreaseIndex(curSelectedIndex,bestMatchingMilestones))   return;
  selectMilestoneAtIndex(bestMatchingMilestones,curSelectedIndex.get() + 1);
}","/** 
 * Selects the next milestone in the list of best matching milestones
 */
public void selectNextBestMatchingMilestone(){
  Optional<Integer> curSelectedIndex=getSelectedIndex(bestMatchingMilestones);
  if (!canIncreaseIndex(curSelectedIndex,bestMatchingMilestones))   return;
  selectMilestoneAtIndex(bestMatchingMilestones,curSelectedIndex.get() + 1);
}",0.99860529986053
135156,"/** 
 * Should be called to restore selection after making changes to the item list of this list view. Must be called after saveSelection is.
 * @throws IllegalStateException if called before saveSelection is
 */
public void restoreSelection(){
  if (!lastSelectedItem.isPresent()) {
    if (!saveSelectionCalled) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else {
      saveSelectionCalled=false;
      return;
    }
  }
  saveSelectionCalled=false;
  int index=-1;
  int i=0;
  for (  T item : getItems()) {
    if (areItemsEqual(item,lastSelectedItem.get())) {
      index=i;
      break;
    }
    i++;
  }
  boolean itemFound=index > -1;
  if (itemFound) {
    getSelectionModel().clearAndSelect(index);
    selectedIndex=Optional.of(index);
  }
 else {
    if (getItems().size() == 0) {
      selectedIndex=Optional.empty();
    }
 else {
      int lastIndex=getItems().size() - 1;
      int nextIndex=Math.min(selectedIndex.get(),lastIndex);
      getSelectionModel().clearAndSelect(nextIndex);
      selectedIndex=Optional.of(nextIndex);
      triggerItemSelected(nextIndex);
    }
  }
}","/** 
 * Should be called to restore selection after making changes to the item list of this list view. Must be called after saveSelection is.
 * @throws IllegalStateException if called before saveSelection is
 */
public void restoreSelection(){
  if (!lastSelectedItem.isPresent()) {
    if (!saveSelectionCalled) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else {
      saveSelectionCalled=false;
      return;
    }
  }
  saveSelectionCalled=false;
  int index=-1;
  int i=0;
  for (  T item : getItems()) {
    if (areItemsEqual(item,lastSelectedItem.get())) {
      index=i;
      break;
    }
    i++;
  }
  boolean itemFound=index > -1;
  if (itemFound) {
    getSelectionModel().clearAndSelect(index);
    selectedIndex=Optional.of(index);
  }
 else {
    if (getItems().isEmpty()) {
      selectedIndex=Optional.empty();
    }
 else     if (selectedIndex.isPresent()) {
      int lastIndex=getItems().size() - 1;
      int nextIndex=Math.min(selectedIndex.get(),lastIndex);
      getSelectionModel().clearAndSelect(nextIndex);
      selectedIndex=Optional.of(nextIndex);
      triggerItemSelected(nextIndex);
    }
  }
}",0.9757602468047598
135157,"private boolean authorSatisfies(IModel model,TurboIssue issue){
  if (!content.isPresent())   return false;
  TurboUser author=model.getAuthorOfIssue(issue).get();
  String content=this.content.get().toLowerCase();
  String login=author.getLoginName() == null ? ""String_Node_Str"" : author.getLoginName().toLowerCase();
  String name=author.getRealName() == null ? ""String_Node_Str"" : author.getRealName().toLowerCase();
  return login.contains(content) || name.contains(content);
}","private boolean authorSatisfies(IModel model,TurboIssue issue){
  if (!content.isPresent())   return false;
  Optional<TurboUser> author=model.getAuthorOfIssue(issue);
  String content=this.content.get().toLowerCase();
  String login=issue.getCreator();
  String name=""String_Node_Str"";
  if (author.isPresent()) {
    name=author.get().getRealName() == null ? ""String_Node_Str"" : author.get().getRealName();
  }
  return login.contains(content) || name.contains(content);
}",0.7706806282722513
135158,"@Test public void satisfiesInvolves_validInput(){
  TurboUser user=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  TurboIssue issue=new TurboIssue(REPO,1,""String_Node_Str"");
  issue.setAssignee(user);
  IModel model=TestUtils.modelWith(issue,user);
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  issue=new TurboIssue(REPO,1,""String_Node_Str"",""String_Node_Str"",null,false);
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertFalse(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertFalse(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
}","@Test public void satisfiesInvolves_validInput(){
  TurboUser user=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  TurboIssue issue=new TurboIssue(REPO,1,""String_Node_Str"",""String_Node_Str"",LocalDateTime.now(),true);
  issue.setAssignee(user);
  IModel model=TestUtils.modelWith(issue,user);
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  issue=new TurboIssue(REPO,1,""String_Node_Str"",""String_Node_Str"",null,false);
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertFalse(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
}",0.8542178542178542
135159,"@Test public void satisfiesAuthor_validInputs(){
  TurboIssue issue=new TurboIssue(REPO,1,""String_Node_Str"",""String_Node_Str"",null,false);
  IModel model=TestUtils.modelWith(issue,new TurboUser(""String_Node_Str"",""String_Node_Str""));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
}","@Test public void satisfiesAuthor_validInputs(){
  TurboIssue issue=new TurboIssue(REPO,1,""String_Node_Str"",""String_Node_Str"",null,false);
  IModel model=TestUtils.modelWith(issue,new TurboUser(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertTrue(Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
}",0.8125
135160,"private void updateSuggestion(){
  if (matchedBoards.isEmpty() || matchedBoards.size() == boards.size()) {
    suggestion=Optional.empty();
  }
 else {
    suggestion=matchedBoards.stream().min(String::compareToIgnoreCase);
  }
}","private void updateSuggestion(){
  if (matchedBoards.isEmpty() || (matchedBoards.size() == boards.size() && boards.size() != 1)) {
    suggestion=Optional.empty();
  }
 else {
    suggestion=matchedBoards.stream().min(String::compareToIgnoreCase);
  }
}",0.950207468879668
135161,"private void panelFocus_firstPanel_firstPanelShown(PanelControl panelControl) throws IllegalAccessException {
  clickOn(""String_Node_Str"");
  pushKeys(KeyCode.DOWN);
  pushKeys(KeyCode.DOWN);
  pushKeys(KeyCode.ENTER);
  ((TextField)GuiTest.find(IdGenerator.getBoardNameInputFieldIdReference())).setText(""String_Node_Str"");
  clickOn(""String_Node_Str"");
  awaitCondition(() -> 1 == panelControl.getNumberOfSavedBoards());
  pushKeys(CREATE_RIGHT_PANEL);
  awaitCondition(() -> panelControl.getCurrentlySelectedPanel().get() == panelControl.getPanelCount() - 1);
  pushKeys(SWITCH_BOARD);
  awaitCondition(() -> 0 == panelControl.getCurrentlySelectedPanel().get());
  ScrollPane panelsScrollPaneReflection=(ScrollPane)FieldUtils.readField(panelControl,""String_Node_Str"",true);
  assertEquals(0,panelsScrollPaneReflection.getHvalue(),0.001);
}","private void panelFocus_firstPanel_firstPanelShown(PanelControl panelControl) throws IllegalAccessException {
  clickOn(""String_Node_Str"");
  pushKeys(KeyCode.DOWN);
  pushKeys(KeyCode.DOWN);
  pushKeys(KeyCode.ENTER);
  ((TextField)GuiTest.find(IdGenerator.getBoardNameInputFieldIdReference())).setText(""String_Node_Str"");
  clickOn(""String_Node_Str"");
  awaitCondition(() -> 1 == panelControl.getNumberOfSavedBoards());
  pushKeys(CREATE_RIGHT_PANEL);
  awaitCondition(() -> panelControl.getCurrentlySelectedPanel().get() == panelControl.getPanelCount() - 1);
  pushKeys(SWITCH_BOARD);
  waitUntilNodeAppears(""String_Node_Str"");
  type(""String_Node_Str"");
  pushKeys(KeyCode.ENTER);
  awaitCondition(() -> 0 == panelControl.getCurrentlySelectedPanel().get());
  ScrollPane panelsScrollPaneReflection=(ScrollPane)FieldUtils.readField(panelControl,""String_Node_Str"",true);
  assertEquals(0,panelsScrollPaneReflection.getHvalue(),0.001);
}",0.9454749859471612
135162,"@Test public void eventTriggerOnIssueSelection_byRightClick_selectionEventNotTriggered(){
  AtomicInteger eventCount=new AtomicInteger(0);
  UI.events.registerEvent((IssueSelectedEventHandler)e -> eventCount.incrementAndGet());
  ListPanel issuePanel=getPanel(0);
  rightClickIssue(0,9);
  ContextMenu contextMenu=issuePanel.getContextMenu();
  for (  MenuItem menuItem : contextMenu.getItems()) {
    assertTrue(!menuItem.isDisable());
  }
  assertEquals(0,eventCount.get());
}","@Test public void eventTriggerOnIssueSelection_byRightClick_selectionEventNotTriggered(){
  AtomicInteger eventCount=new AtomicInteger(0);
  UI.events.registerEvent((IssueSelectedEventHandler)e -> eventCount.incrementAndGet());
  ListPanel issuePanel=getPanel(0);
  waitUntilNodeAppears(PANEL_IDENTIFIER);
  ListPanel issuePanel=GuiTest.find(PANEL_IDENTIFIER);
  rightClickIssue(0,9);
  ContextMenu contextMenu=issuePanel.getContextMenu();
  for (  MenuItem menuItem : contextMenu.getItems()) {
    assertTrue(!menuItem.isDisable());
  }
  assertEquals(0,eventCount.get());
}",0.9078822412155746
135163,"/** 
 * Click on menu item with target text
 * @param menu
 * @param target
 */
private void clickMenuItem(String target){
  clickMenuItem(issuePanel.getContextMenu(),target);
}","/** 
 * Clicks on menu item with target text
 * @param menu
 * @param target
 */
private void clickMenuItem(String target){
  clickMenuItem(issuePanel.getContextMenu(),target);
}",0.9971830985915492
135164,"@Test public void logoutFunctionTest(){
  selectAll();
  type(""String_Node_Str"").push(KeyCode.TAB);
  type(""String_Node_Str"").push(KeyCode.TAB);
  type(""String_Node_Str"").push(KeyCode.TAB);
  type(""String_Node_Str"");
  clickOn(""String_Node_Str"");
  sleep(2000);
  clickOn(""String_Node_Str"");
  clickOn(""String_Node_Str"");
  File testConfig=new File(configFileDirectory,testConfigFileName);
  if (!(testConfig.exists() && testConfig.isFile())) {
    fail(""String_Node_Str"" + testConfig.getAbsolutePath());
  }
  Preferences testPref=TestController.loadTestPreferences();
  assertEquals(""String_Node_Str"",testPref.getLastLoginUsername());
  assertEquals(""String_Node_Str"",testPref.getLastLoginPassword());
}","@Test public void logoutFunctionTest(){
  selectAll();
  type(""String_Node_Str"").push(KeyCode.TAB);
  type(""String_Node_Str"").push(KeyCode.TAB);
  type(""String_Node_Str"").push(KeyCode.TAB);
  type(""String_Node_Str"");
  clickOn(""String_Node_Str"");
  sleep(EVENT_DELAY);
  clickOn(""String_Node_Str"");
  clickOn(""String_Node_Str"");
  File testConfig=new File(configFileDirectory,testConfigFileName);
  if (!(testConfig.exists() && testConfig.isFile())) {
    fail(""String_Node_Str"" + testConfig.getAbsolutePath());
  }
  Preferences testPref=TestController.loadTestPreferences();
  assertEquals(""String_Node_Str"",testPref.getLastLoginUsername());
  assertEquals(""String_Node_Str"",testPref.getLastLoginPassword());
}",0.9894142554693014
135165,"/** 
 * Like drag(from).to(to), but does not relocate the mouse if the target moves.
 */
public void dragUnconditionally(FilterPanel panelFrom,FilterPanel panelTo){
  Node from=dragSrc(panelFrom);
  Node to=dragDest(panelTo);
  Bounds fromBound=from.localToScene(from.getBoundsInLocal());
  Bounds toBound=to.localToScene(to.getBoundsInLocal());
  drag(fromBound.getMinX(),fromBound.getMaxY(),MouseButton.PRIMARY).moveTo(toBound.getMaxX(),toBound.getMaxY());
  drop();
}","/** 
 * Like drag(from).to(to), but does not relocate the mouse if the target moves.
 */
public void dragUnconditionally(FilterPanel panelFrom,FilterPanel panelTo){
  Node from=dragSrc(panelFrom);
  Node to=dragDest(panelTo);
  Bounds fromBound=from.localToScene(from.getBoundsInLocal());
  Bounds toBound=to.localToScene(to.getBoundsInLocal());
  drag(fromBound.getMinX(),fromBound.getMaxY(),MouseButton.PRIMARY).moveTo(toBound.getMaxX(),toBound.getMaxY()).drop();
}",0.9818569903948772
135166,"/** 
 * Click on menu item with target text
 * @param menu
 * @param target
 */
public void clickMenuItem(ContextMenu menu,String target){
  menu.getItems().stream().filter(item -> item.getText().equals(target)).findFirst().ifPresent(item -> {
    Platform.runLater(item::fire);
  }
);
}","/** 
 * Clicks on menu item with target text
 * @param menu
 * @param target
 */
public void clickMenuItem(ContextMenu menu,String target){
  menu.getItems().stream().filter(item -> item.getText().equals(target)).findFirst().ifPresent(item -> {
    Platform.runLater(item::fire);
  }
);
}",0.9982608695652174
135167,"@Test public void isUserInRepo_queryExistingUser_userFound(){
  MultiModel models=new MultiModel(mock(Preferences.class));
  final String REPO=""String_Node_Str"";
  TurboUser user1=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  TurboUser user2=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  List<TurboUser> users=Arrays.asList(user1,user2);
  Model mockedModel=mock(Model.class);
  when(mockedModel.getRepoId()).thenReturn(REPO);
  when(mockedModel.getUsers()).thenReturn(users);
  models.queuePendingRepository(REPO);
  models.addPending(mockedModel);
  assertTrue(models.isUserInRepo(REPO,""String_Node_Str""));
  assertTrue(models.isUserInRepo(REPO,""String_Node_Str""));
  assertTrue(models.isUserInRepo(REPO,""String_Node_Str""));
  assertTrue(models.isUserInRepo(REPO,""String_Node_Str""));
}","@Test public void isUserInRepo_queryExistingUser_userFound(){
  MultiModel models=new MultiModel(mock(Preferences.class));
  TurboUser user1=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  TurboUser user2=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  List<TurboUser> users=Arrays.asList(user1,user2);
  Model mockedModel=mock(Model.class);
  when(mockedModel.getRepoId()).thenReturn(REPO);
  when(mockedModel.getUsers()).thenReturn(users);
  models.queuePendingRepository(REPO);
  models.addPending(mockedModel);
  assertTrue(models.isUserInRepo(REPO,""String_Node_Str""));
  assertTrue(models.isUserInRepo(REPO,""String_Node_Str""));
  assertTrue(models.isUserInRepo(REPO,""String_Node_Str""));
  assertTrue(models.isUserInRepo(REPO,""String_Node_Str""));
}",0.9754253308128544
135168,"@Test public void isUserInRepo_queryNonExistingUser_userNotFound(){
  MultiModel models=new MultiModel(mock(Preferences.class));
  final String REPO=""String_Node_Str"";
  TurboUser user1=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  TurboUser user2=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  List<TurboUser> users=Arrays.asList(user1,user2);
  Model mockedModel=mock(Model.class);
  when(mockedModel.getRepoId()).thenReturn(REPO);
  when(mockedModel.getUsers()).thenReturn(users);
  models.queuePendingRepository(REPO);
  models.addPending(mockedModel);
  assertFalse(models.isUserInRepo(REPO,""String_Node_Str""));
  assertFalse(models.isUserInRepo(REPO,""String_Node_Str""));
}","@Test public void isUserInRepo_queryNonExistingUser_userNotFound(){
  MultiModel models=new MultiModel(mock(Preferences.class));
  TurboUser user1=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  TurboUser user2=new TurboUser(REPO,""String_Node_Str"",""String_Node_Str"");
  List<TurboUser> users=Arrays.asList(user1,user2);
  Model mockedModel=mock(Model.class);
  when(mockedModel.getRepoId()).thenReturn(REPO);
  when(mockedModel.getUsers()).thenReturn(users);
  models.queuePendingRepository(REPO);
  models.addPending(mockedModel);
  assertFalse(models.isUserInRepo(REPO,""String_Node_Str""));
  assertFalse(models.isUserInRepo(REPO,""String_Node_Str""));
}",0.9714703730797366
135169,"private void triggerIssuePicker(List<TurboIssue> allIssues){
  Platform.runLater(stage::hide);
  UI.events.triggerEvent(new ShowIssuePickerEvent(allIssues,false));
  waitUntilNodeAppears(QUERY_FIELD_ID);
}","private void triggerIssuePicker(List<TurboIssue> allIssues){
  Platform.runLater(getStage()::hide);
  UI.events.triggerEvent(new ShowIssuePickerEvent(allIssues,false));
  waitUntilNodeAppears(QUERY_FIELD_ID);
}",0.963855421686747
135170,"@Test public void showIssuePicker_typeQuery_displaysCorrectly(){
  triggerIssuePicker(new ArrayList<>());
  TextField issuePickerTextField=find(QUERY_FIELD_ID);
  click(issuePickerTextField);
  type(""String_Node_Str"");
  assertEquals(""String_Node_Str"",issuePickerTextField.getText());
}","@Test public void showIssuePicker_typeQuery_displaysCorrectly(){
  triggerIssuePicker(new ArrayList<>());
  TextField issuePickerTextField=GuiTest.find(QUERY_FIELD_ID);
  clickOn(issuePickerTextField);
  type(""String_Node_Str"");
  assertEquals(""String_Node_Str"",issuePickerTextField.getText());
}",0.9828178694158076
135171,"public Node getNode(){
  Label repoLabel=new Label();
  if (isSelected)   repoLabel.setText(BALLOT_BOX_WITH_CHECK + ""String_Node_Str"" + repositoryId);
 else   repoLabel.setText(BALLOT_BOX + ""String_Node_Str"" + repositoryId);
  return repoLabel;
}","public Node getNode(){
  Label repoLabel=new Label();
  if (isSelected) {
    repoLabel.setText(BALLOT_BOX_WITH_CHECK + ""String_Node_Str"" + repositoryId);
  }
 else {
    repoLabel.setText(BALLOT_BOX + ""String_Node_Str"" + repositoryId);
  }
  return repoLabel;
}",0.952755905511811
135172,"private void setupMainIssueCard(){
  return;
}","private void setupMainIssueCard(){
  this.backgroundProperty().bind(Bindings.when(this.focusedProperty()).then(new Background(new BackgroundFill(Color.CORNFLOWERBLUE,CornerRadii.EMPTY,Insets.EMPTY))).otherwise(new Background(new BackgroundFill(Color.WHITE,CornerRadii.EMPTY,Insets.EMPTY))));
  this.setStyle(""String_Node_Str"");
}",0.2133333333333333
135173,"private void setup(){
  setupMainIssueCard();
  TurboIssue issue=guiElement.getIssue();
  Text issueTitle=new Text(""String_Node_Str"" + issue.getId() + ""String_Node_Str""+ issue.getTitle());
  issueTitle.setWrappingWidth(CARD_WIDTH);
  issueTitle.getStyleClass().add(""String_Node_Str"");
  if (issue.isCurrentlyRead()) {
    issueTitle.getStyleClass().add(""String_Node_Str"");
  }
  if (!issue.isOpen()) {
    issueTitle.getStyleClass().add(""String_Node_Str"");
  }
  setupIssueDetailsBox();
  setupAuthorAssigneeBox();
  updateDetails();
  setPadding(new Insets(0,0,0,0));
  setSpacing(1);
  getChildren().addAll(issueTitle,issueDetails,authorAssigneeBox);
}","private void setup(){
  setupMainIssueCard();
  TurboIssue issue=guiElement.getIssue();
  Text issueTitle=new Text(""String_Node_Str"" + issue.getId() + ""String_Node_Str""+ issue.getTitle());
  issueTitle.setWrappingWidth(CARD_WIDTH);
  issueTitle.getStyleClass().add(""String_Node_Str"");
  if (issue.isCurrentlyRead()) {
    issueTitle.getStyleClass().add(""String_Node_Str"");
  }
  if (!issue.isOpen()) {
    issueTitle.getStyleClass().add(""String_Node_Str"");
  }
  setupIssueDetailsBox();
  setupAuthorAssigneeBox();
  updateDetails();
  setPadding(new Insets(3,0,3,0));
  setSpacing(1);
  getChildren().addAll(issueTitle,issueDetails,authorAssigneeBox);
}",0.9969418960244648
135174,"private void handleIssueClick(TurboIssue issue,IssueCard card){
  issuepickerQueryField.setDisable(true);
  state.updateSelectedIssues(issue);
  populatePanes(state);
}","private void handleIssueClick(TurboIssue issue,IssueCard card){
  issuepickerQueryField.setDisable(true);
  Platform.runLater(card::requestFocus);
  state.updateSelectedIssues(issue);
  populateSelectedIssues(state.getSelectedIssues(),state.getCurrentSuggestion());
}",0.5195402298850574
135175,"private void setup(){
  TurboIssue issue=guiElement.getIssue();
  Text issueTitle=new Text(""String_Node_Str"" + issue.getId() + ""String_Node_Str""+ issue.getTitle());
  issueTitle.setWrappingWidth(CARD_WIDTH);
  issueTitle.getStyleClass().add(""String_Node_Str"");
  if (issue.isCurrentlyRead()) {
    issueTitle.getStyleClass().add(""String_Node_Str"");
  }
  if (!issue.isOpen()) {
    issueTitle.getStyleClass().add(""String_Node_Str"");
  }
  setupIssueDetailsBox();
  setupAuthorAssigneeBox();
  updateDetails();
  setPadding(new Insets(0,0,0,0));
  setSpacing(1);
  getChildren().addAll(issueTitle,issueDetails,authorAssigneeBox);
}","private void setup(){
  setupMainIssueCard();
  TurboIssue issue=guiElement.getIssue();
  Text issueTitle=new Text(""String_Node_Str"" + issue.getId() + ""String_Node_Str""+ issue.getTitle());
  issueTitle.setWrappingWidth(CARD_WIDTH);
  issueTitle.getStyleClass().add(""String_Node_Str"");
  if (issue.isCurrentlyRead()) {
    issueTitle.getStyleClass().add(""String_Node_Str"");
  }
  if (!issue.isOpen()) {
    issueTitle.getStyleClass().add(""String_Node_Str"");
  }
  setupIssueDetailsBox();
  setupAuthorAssigneeBox();
  updateDetails();
  setPadding(new Insets(0,0,0,0));
  setSpacing(1);
  getChildren().addAll(issueTitle,issueDetails,authorAssigneeBox);
}",0.9813084112149532
135176,"private Node processSuggestedIssue(TurboIssue issue){
  GuiElement element=new GuiElement(issue,models.getLabelsOfIssue(issue),models.getMilestoneOfIssue(issue),models.getAssigneeOfIssue(issue),models.getAuthorOfIssue(issue));
  return new IssueCard(element);
}","private Node processSuggestedIssue(TurboIssue issue){
  GuiElement element=new GuiElement(issue,models.getLabelsOfIssue(issue),models.getMilestoneOfIssue(issue),models.getAssigneeOfIssue(issue),models.getAuthorOfIssue(issue));
  IssueCard card=new IssueCard(element);
  card.setOnMouseClicked(e -> handleIssueClick(issue,card));
  return card;
}",0.8382838283828383
135177,"private void createButtons(){
  ButtonType confirmButtonType=new ButtonType(""String_Node_Str"",ButtonData.OK_DONE);
  getDialogPane().getButtonTypes().addAll(confirmButtonType,ButtonType.CANCEL);
  setResultConverter(dialogButton -> {
    if (dialogButton == confirmButtonType) {
      return state.getSelectedIssues().stream().map(TurboIssue::toString).collect(Collectors.toList());
    }
    return null;
  }
);
}","private void createButtons(){
  ButtonType confirmButtonType=new ButtonType(""String_Node_Str"",ButtonData.OK_DONE);
  getDialogPane().getButtonTypes().addAll(confirmButtonType,ButtonType.CANCEL);
  setResultConverter(dialogButton -> {
    if (dialogButton == confirmButtonType) {
      if (!issuepickerQueryField.isDisabled())       issuepickerQueryField.appendText(""String_Node_Str"");
      return state.getSelectedIssues().stream().map(TurboIssue::toString).collect(Collectors.toList());
    }
    return null;
  }
);
}",0.8865096359743041
135178,"private void populateSelectedIssues(List<TurboIssue> chosenIssues,Optional<TurboIssue> currentSuggestion){
  selectedIssues.getChildren().clear();
  Map<String,FlowPane> repoContent=getRepoContent(chosenIssues,currentSuggestion);
  repoContent.entrySet().forEach(entry -> {
    selectedIssues.getChildren().addAll(createRepoTitle(entry.getKey()),entry.getValue());
  }
);
  if (selectedIssues.getChildren().isEmpty()) {
    selectedIssues.getChildren().add(createTextLabel(NO_SELECTED_ISSUES));
  }
}","private void populateSelectedIssues(List<TurboIssue> chosenIssues,Optional<TurboIssue> currentSuggestion){
  selectedIssues.getChildren().clear();
  Map<String,FlowPane> repoContent=getRepoContent(chosenIssues,currentSuggestion);
  repoContent.entrySet().forEach(entry -> {
    entry.getValue().getChildren().add(0,createRepoTitle(entry.getKey()));
    selectedIssues.getChildren().addAll(entry.getValue());
  }
);
}",0.7445414847161572
135179,"private Label createRepoTitle(String name){
  Label repoName=new Label(name);
  repoName.setPadding(new Insets(0,5,5,0));
  repoName.setMaxWidth(ELEMENT_MAX_WIDTH - 10);
  repoName.setStyle(""String_Node_Str"");
  return repoName;
}","private Label createRepoTitle(String name){
  Label repoName=new Label(name + ""String_Node_Str"");
  repoName.setPadding(new Insets(0,5,5,0));
  repoName.setMaxWidth(ELEMENT_MAX_WIDTH - 10);
  repoName.setStyle(""String_Node_Str"");
  return repoName;
}",0.9583333333333334
135180,"private final Map<String,FlowPane> getRepoContent(List<TurboIssue> chosenIssues,Optional<TurboIssue> suggestion){
  Map<String,FlowPane> repoContent=new HashMap<>();
  chosenIssues.stream().forEach(issue -> {
    String repoId=issue.getRepoId();
    if (!repoContent.containsKey(repoId)) {
      repoContent.put(repoId,createRepoPane(GROUP_PAD));
    }
    repoContent.get(repoId).getChildren().add(processSelectedIssue(issue,suggestion));
  }
);
  if (suggestion.isPresent() && !chosenIssues.contains(suggestion.get())) {
    addCurrentSuggestion(repoContent,suggestion.get());
  }
  return repoContent;
}","private final Map<String,FlowPane> getRepoContent(List<TurboIssue> chosenIssues,Optional<TurboIssue> suggestion){
  Map<String,FlowPane> repoContent=new HashMap<>();
  chosenIssues.stream().forEach(issue -> {
    String repoId=issue.getRepoId();
    if (!repoContent.containsKey(repoId)) {
      repoContent.put(repoId,createRepoPane(GROUP_PAD));
    }
    repoContent.get(repoId).getChildren().add(processSelectedIssue(issue,suggestion));
  }
);
  if (canAddSuggestion(chosenIssues,suggestion))   addCurrentSuggestion(repoContent,suggestion.get());
  return repoContent;
}",0.8871925360474979
135181,"public Optional<TurboIssue> getCurrentSuggestion(){
  if (suggestedIssues.isEmpty())   return Optional.empty();
  return Optional.of(suggestedIssues.get(0));
}","/** 
 * @return current suggestion if there are matches
 */
public Optional<TurboIssue> getCurrentSuggestion(){
  return currentSuggestion;
}",0.4866666666666667
135182,"/** 
 * Updates selected issues if issue is present
 * @param issue
 */
private void updateSelectedIssues(Optional<TurboIssue> issue){
  if (!issue.isPresent())   return;
  TurboIssue selectedIssue=issue.get();
  if (selectedIssues.contains(selectedIssue)) {
    selectedIssues.remove(selectedIssue);
  }
 else {
    selectedIssues.add(selectedIssue);
  }
}","/** 
 * Updates selected issues if issue is present
 * @param issue
 */
public void updateSelectedIssues(TurboIssue selectedIssue){
  if (selectedIssues.contains(selectedIssue)) {
    selectedIssues.remove(selectedIssue);
  }
 else {
    selectedIssues.add(selectedIssue);
  }
}",0.2740157480314961
135183,"/** 
 * Updates current state based on given user input
 * @param userInput 
 */
private final void update(String userInput){
  if (userInput.isEmpty())   return;
  List<String> confirmedKeywords=getConfirmedKeywords(userInput);
  for (  String confirmedKeyword : confirmedKeywords) {
    updateSelectedIssues(Optional.ofNullable(TurboIssue.getMatchedIssues(allIssues,confirmedKeyword).get(0)));
  }
  Optional<String> keywordInProgress=getKeywordInProgress(userInput);
  if (keywordInProgress.isPresent()) {
    updateSuggestedIssues(allIssues,keywordInProgress.get());
  }
}","/** 
 * Updates current state based on given user input
 * @param userInput 
 */
private final void update(String userInput){
  List<String> confirmedKeywords=getConfirmedKeywords(userInput);
  for (  String confirmedKeyword : confirmedKeywords) {
    TurboIssue.getMatchedIssues(allIssues,confirmedKeyword).stream().findFirst().ifPresent(this::updateSelectedIssues);
  }
  Optional<String> keywordInProgress=getKeywordInProgress(userInput);
  if (keywordInProgress.isPresent()) {
    updateSuggestedIssues(allIssues,keywordInProgress.get());
    if (!userInput.isEmpty())     currentSuggestion=suggestedIssues.stream().findFirst();
  }
}",0.7232289950576606
135184,"public CompletableFuture<Boolean> replaceIssueMilestone(TurboIssue issue,Integer milestone){
  logger.info(""String_Node_Str"" + issue + ""String_Node_Str"");
  return repoIO.replaceIssueMilestone(issue,milestone).thenApply(resultingIssue -> {
    logger.info(""String_Node_Str"" + issue + ""String_Node_Str"");
    if (resultingIssue.getMilestone() != null) {
      issue.setMilestoneById(resultingIssue.getMilestone().getNumber());
    }
 else {
      issue.setMilestoneById(null);
    }
    refreshUI();
    return true;
  }
).exceptionally(Futures.withResult(false));
}","public CompletableFuture<Boolean> replaceIssueMilestone(TurboIssue issue,Integer milestone){
  Optional<Integer> originalMilestone=issue.getMilestone();
  logger.info(""String_Node_Str"" + issue + ""String_Node_Str"");
  Optional<TurboIssue> localReplaceResult=models.replaceIssueMilestone(issue.getRepoId(),issue.getId(),milestone);
  if (!localReplaceResult.isPresent()) {
    return CompletableFuture.completedFuture(false);
  }
  refreshUI();
  return updateIssueMilestonesOnServer(issue,milestone).thenApply((isUpdateSuccessful) -> handleIssueMilestoneUpdateOnServerResult(isUpdateSuccessful,localReplaceResult.get(),originalMilestone.orElseGet(() -> null)));
}",0.3504482477587612
135185,"public CompletableFuture<Issue> replaceIssueMilestone(TurboIssue issue,Integer milestone){
  return repoSource.replaceIssueMilestone(issue,milestone);
}","public CompletableFuture<Boolean> replaceIssueMilestone(TurboIssue issue,Integer milestone){
  return repoSource.replaceIssueMilestone(issue,milestone);
}",0.9673202614379084
135186,"@Override public CompletableFuture<Issue> replaceIssueMilestone(TurboIssue issue,Integer milestone){
  return addTask(new ReplaceIssueMilestoneTask(this,gitHub,issue.getRepoId(),issue.getId(),issue.getTitle(),milestone)).response;
}","@Override public CompletableFuture<Boolean> replaceIssueMilestone(TurboIssue issue,Integer milestone){
  return addTask(new ReplaceIssueMilestoneTask(this,gitHub,issue.getRepoId(),issue.getId(),issue.getTitle(),milestone)).response;
}",0.9742489270386266
135187,"@Override public void run(){
  try {
    response.complete(repo.setMilestone(repoId,issueId,issueTitle,issueMilestone));
  }
 catch (  IOException e) {
    response.completeExceptionally(e);
  }
}","@Override public void run(){
  try {
    Issue result=repo.setMilestone(repoId,issueId,issueTitle,issueMilestone);
    if (result.getMilestone() == null) {
      response.complete(issueMilestone == null);
    }
 else {
      response.complete(result.getMilestone().getNumber() == issueMilestone);
    }
  }
 catch (  IOException e) {
    response.completeExceptionally(e);
  }
}",0.6167247386759582
135188,"public abstract CompletableFuture<Issue> replaceIssueMilestone(TurboIssue issue,Integer milestone);","public abstract CompletableFuture<Boolean> replaceIssueMilestone(TurboIssue issue,Integer milestone);",0.95
135189,"public void setMilestone(TurboMilestone milestone){
  setMilestoneById(milestone.getId());
}","public void setMilestone(TurboMilestone milestone){
  setMilestoneById(milestone.getId());
  this.milestoneLastModifiedAt=Optional.of(LocalDateTime.now());
}",0.7389558232931727
135190,"public void setMilestoneById(Integer milestone){
  this.milestone=(milestone == null) ? Optional.empty() : Optional.of(milestone);
}","public void setMilestoneById(Integer milestone){
  this.milestone=(milestone == null) ? Optional.empty() : Optional.of(milestone);
  this.milestoneLastModifiedAt=Optional.of(LocalDateTime.now());
}",0.8024316109422492
135191,"@Override public CompletableFuture<Issue> replaceIssueMilestone(TurboIssue issue,Integer milestone){
  return addTask(new ReplaceIssueMilestoneTask(this,dummy,issue.getRepoId(),issue.getId(),issue.getTitle(),milestone)).response;
}","@Override public CompletableFuture<Boolean> replaceIssueMilestone(TurboIssue issue,Integer milestone){
  return addTask(new ReplaceIssueMilestoneTask(this,dummy,issue.getRepoId(),issue.getId(),issue.getTitle(),milestone)).response;
}",0.9741379310344828
135192,"/** 
 * Replaces the milestone of the issue in the   {@link Logic#models} corresponding to {@code modifiedIssue} with{@code originalLabels} if the current labels on the issue is assigned at the same time as {@code modifiedIssue}
 * @param modifiedIssue
 * @param originalMilestone
 */
private void revertLocalMilestoneReplace(TurboIssue modifiedIssue,Integer originalMilestone){
  TurboIssue currentIssue=getIssue(modifiedIssue.getRepoId(),modifiedIssue.getId()).orElse(modifiedIssue);
  LocalDateTime originalMilestoneModifiedAt=modifiedIssue.getMilestoneLastModifiedAt();
  LocalDateTime currentMilestoneAssignedAt=currentIssue.getMilestoneLastModifiedAt();
  boolean isCurrentMilestoneModifiedFromOriginalMilestone=originalMilestoneModifiedAt.isEqual(currentMilestoneAssignedAt);
  if (isCurrentMilestoneModifiedFromOriginalMilestone) {
    logger.info(""String_Node_Str"" + currentIssue);
    models.replaceIssueMilestone(currentIssue.getRepoId(),currentIssue.getId(),originalMilestone);
    refreshUI();
  }
}","/** 
 * Replaces the milestone of the issue in the   {@link Logic#models} corresponding to {@code modifiedIssue} with{@code originalMilestone} if they were both issues have the same last modified LocalDateTime
 * @param modifiedIssue
 * @param originalMilestone
 */
private void revertLocalMilestoneReplace(TurboIssue modifiedIssue,Integer originalMilestone){
  TurboIssue currentIssue=getIssue(modifiedIssue.getRepoId(),modifiedIssue.getId()).orElse(modifiedIssue);
  LocalDateTime originalMilestoneModifiedAt=modifiedIssue.getMilestoneLastModifiedAt();
  LocalDateTime currentMilestoneAssignedAt=currentIssue.getMilestoneLastModifiedAt();
  boolean isCurrentMilestoneModifiedFromOriginalMilestone=originalMilestoneModifiedAt.isEqual(currentMilestoneAssignedAt);
  if (!isCurrentMilestoneModifiedFromOriginalMilestone)   return;
  logger.info(""String_Node_Str"" + currentIssue);
  models.replaceIssueMilestone(currentIssue.getRepoId(),currentIssue.getId(),originalMilestone);
  refreshUI();
}",0.9031936127744512
135193,"/** 
 * Handles the result of updating an issue's milestone on server. Current implementation includes reverting back to the original labels locally if the server update failed.
 * @param isUpdateSuccessful
 * @param localModifiedIssue
 * @param originalMilestone
 * @return true if the server update is successful
 */
private boolean handleIssueMilestoneUpdateOnServerResult(boolean isUpdateSuccessful,TurboIssue localModifiedIssue,Integer originalMilestone){
  if (isUpdateSuccessful) {
    return true;
  }
  logger.error(""String_Node_Str"");
  revertLocalMilestoneReplace(localModifiedIssue,originalMilestone);
  return false;
}","/** 
 * Handles the result of updating an issue's milestone on server. Current implementation includes reverting back to the original labels locally if the server update failed.
 * @param isUpdateSuccessful
 * @param localModifiedIssue
 * @param originalMilestone
 * @return true if the server update is successful
 */
private boolean handleIssueMilestoneUpdateOnServerResult(boolean isUpdateSuccessful,TurboIssue localModifiedIssue,Integer originalMilestone){
  if (isUpdateSuccessful)   return true;
  logger.error(""String_Node_Str"");
  revertLocalMilestoneReplace(localModifiedIssue,originalMilestone);
  return false;
}",0.9936204146730464
135194,"public CompletableFuture<Boolean> replaceIssueMilestone(TurboIssue issue,Integer milestone){
  Optional<Integer> originalMilestone=issue.getMilestone();
  logger.info(""String_Node_Str"" + issue + ""String_Node_Str"");
  Optional<TurboIssue> localReplaceResult=models.replaceIssueMilestone(issue.getRepoId(),issue.getId(),milestone);
  if (!localReplaceResult.isPresent()) {
    return CompletableFuture.completedFuture(false);
  }
  refreshUI();
  return updateIssueMilestonesOnServer(issue,milestone).thenApply((isUpdateSuccessful) -> handleIssueMilestoneUpdateOnServerResult(isUpdateSuccessful,localReplaceResult.get(),originalMilestone.orElseGet(() -> null)));
}","/** 
 * Replaces existing milestone with the newMilestone in the issue object, the UI, and the server, in that order. Server update is done after the local update to reduce the lag between the user action and the UI response
 * @param issue The issue object whose milestone is to be replaced.
 * @param newMilestone The new milestone to be assigned to the issue
 * @return true if milestone replacement on GitHub was a success, false otherwise.
 */
public CompletableFuture<Boolean> replaceIssueMilestone(TurboIssue issue,Integer newMilestone){
  Optional<Integer> originalMilestone=issue.getMilestone();
  logger.info(""String_Node_Str"" + issue + ""String_Node_Str"");
  Optional<TurboIssue> localReplaceResult=models.replaceIssueMilestone(issue.getRepoId(),issue.getId(),newMilestone);
  if (!localReplaceResult.isPresent())   return CompletableFuture.completedFuture(false);
  refreshUI();
  return updateIssueMilestonesOnServer(issue,newMilestone).thenApply((isUpdateSuccessful) -> handleIssueMilestoneUpdateOnServerResult(isUpdateSuccessful,localReplaceResult.get(),originalMilestone.orElseGet(() -> null)));
}",0.6155580608793687
135195,"private boolean isExistingMilestone(TurboIssue issue,PickerMilestone milestone){
  if (issue.getMilestone().isPresent()) {
    return issue.getMilestone().get() == milestone.getId();
  }
 else {
    return false;
  }
}","private boolean isExistingMilestone(TurboIssue issue,PickerMilestone milestone){
  if (!issue.getMilestone().isPresent())   return false;
  return issue.getMilestone().get() == milestone.getId();
}",0.8771084337349397
135196,"private void updateExistingMilestones(List<PickerMilestone> pickerMilestoneList,FlowPane assignedMilestoneStatus,boolean hasSuggestion){
  if (hasExistingMilestone(pickerMilestoneList)) {
    PickerMilestone existingMilestone=getExistingMilestone(pickerMilestoneList);
    Node existingMilestoneNode=setMouseClickForNode(existingMilestone.getExistingMilestoneNode(hasSuggestion),existingMilestone.getTitle());
    assignedMilestoneStatus.getChildren().add(existingMilestoneNode);
  }
}","private void updateExistingMilestones(List<PickerMilestone> pickerMilestoneList,FlowPane assignedMilestoneStatus,boolean hasSuggestion){
  if (!hasExistingMilestone(pickerMilestoneList))   return;
  PickerMilestone existingMilestone=getExistingMilestone(pickerMilestoneList);
  Node existingMilestoneNode=setMouseClickForNode(existingMilestone.getExistingMilestoneNode(hasSuggestion),existingMilestone.getTitle());
  assignedMilestoneStatus.getChildren().add(existingMilestoneNode);
}",0.5902992776057792
135197,"private void highlightFirstMatchingMilestone(){
  if (hasMatchingMilestone(this.currentMilestonesList)) {
    this.currentMilestonesList.stream().filter(milestone -> !milestone.isFaded()).findAny().get().setHighlighted(true);
  }
}","private void highlightFirstMatchingMilestone(){
  if (!hasMatchingMilestone(this.currentMilestonesList))   return;
  this.currentMilestonesList.stream().filter(milestone -> !milestone.isFaded()).findAny().get().setHighlighted(true);
}",0.9634408602150538
135198,"private FilterExpression parseExpression(int precedence){
  Token token=consume();
  if (token.getType() == TokenType.EOF) {
    throw new ParseException(""String_Node_Str"" + sourcePosition + ""String_Node_Str""+ position+ ""String_Node_Str"");
  }
  FilterExpression left;
switch (token.getType()) {
case LBRACKET:
    left=parseGroup();
  break;
case NOT:
left=parseNegation();
break;
case QUALIFIER:
left=parseQualifier(token);
break;
case QUOTED_CONTENT:
left=parseQuotedContent(QualifierType.KEYWORD,token);
break;
case SYMBOL:
left=parseKeyword(token);
break;
default :
throw new ParseException(""String_Node_Str"" + token);
}
if (lookAhead().getType() == TokenType.EOF) return left;
while (precedence < getInfixPrecedence(token=lookAhead())) {
switch (token.getType()) {
case AND:
consume();
left=parseConjunction(left);
break;
case OR:
consume();
left=parseDisjunction(left);
break;
case QUALIFIER:
case SYMBOL:
case NOT:
case LBRACKET:
left=parseConjunction(left);
break;
default :
throw new ParseException(""String_Node_Str"" + token);
}
}
return left;
}","private FilterExpression parseExpression(int precedence){
  Token token=consume();
  if (token.getType() == TokenType.EOF) {
    if (isCheckingSyntax) {
      throw new IncompleteInputException();
    }
 else {
      throw new ParseException(String.format(""String_Node_Str"",sourcePosition));
    }
  }
  FilterExpression left;
switch (token.getType()) {
case LBRACKET:
    left=parseGroup();
  break;
case NOT:
left=parseNegation();
break;
case QUALIFIER:
left=parseQualifier(token);
break;
case QUOTED_CONTENT:
left=parseQuotedContent(QualifierType.KEYWORD,token);
break;
case SYMBOL:
left=parseKeyword(token);
break;
default :
throw new ParseException(String.format(""String_Node_Str"",token));
}
if (lookAhead().getType() == TokenType.EOF) {
return left;
}
while (precedence < getInfixPrecedence(token=lookAhead())) {
switch (token.getType()) {
case AND:
consume();
left=parseConjunction(left);
break;
case OR:
consume();
left=parseDisjunction(left);
break;
case QUALIFIER:
case SYMBOL:
case NOT:
case LBRACKET:
left=parseConjunction(left);
break;
default :
throw new ParseException(""String_Node_Str"" + token);
}
}
return left;
}",0.897025171624714
135199,"public static FilterExpression parse(String input){
  if (input == null || input.isEmpty())   return Qualifier.EMPTY;
  return new Parser(new Lexer(input).lex()).parseExpression(0);
}","/** 
 * Parses an input string, returning an abstract syntax tree. Throws a   {@link ParseException} on syntax error.
 */
public static FilterExpression parse(String input){
  if (input.isEmpty()) {
    return Qualifier.EMPTY;
  }
  return new Parser(new Lexer(input).lex(),false).parseExpression(0);
}",0.643298969072165
135200,"private Parser(ArrayList<Token> input){
  this.input=input;
}","private Parser(List<Token> input,boolean isCheckingSyntax){
  this.input=input;
  this.isCheckingSyntax=isCheckingSyntax;
}",0.6086956521739131
135201,"private FilterExpression parseQualifierContent(QualifierType type){
  if (type == QualifierType.SORT) {
    return parseSortKeys();
  }
 else   if (isCompoundIdToken(type,lookAhead())) {
    return parseCompoundId();
  }
 else   if (isRangeOperatorToken(lookAhead())) {
    return parseRangeOperator(type,lookAhead());
  }
 else   if (isDateToken(lookAhead())) {
    return parseDateOrDateRange(type);
  }
 else   if (isNumberToken(lookAhead())) {
    return parseNumberOrNumberRange(type);
  }
 else   if (isQuotedContentToken(lookAhead())) {
    Token quotedContent=consume();
    return parseQuotedContent(type,quotedContent);
  }
 else   if (isKeywordToken(lookAhead())) {
    return new Qualifier(type,consume().getValue());
  }
 else {
    throw new ParseException(String.format(""String_Node_Str"",type,lookAhead()));
  }
}","private FilterExpression parseQualifierContent(QualifierType type){
  if (type == QualifierType.SORT) {
    return parseSortKeys();
  }
 else   if (isCompoundIdToken(type,lookAhead())) {
    return parseCompoundId();
  }
 else   if (isRangeOperatorToken(lookAhead())) {
    return parseRangeOperator(type,lookAhead());
  }
 else   if (isDateToken(lookAhead())) {
    return parseDateOrDateRange(type);
  }
 else   if (isNumberToken(lookAhead())) {
    return parseNumberOrNumberRange(type);
  }
 else   if (isQuotedContentToken(lookAhead())) {
    return parseQuotedContent(type,consume());
  }
 else   if (isKeywordToken(lookAhead())) {
    return new Qualifier(type,consume().getValue());
  }
 else   if (lookAhead().getType() == TokenType.EOF) {
    if (isCheckingSyntax) {
      throw new IncompleteInputException();
    }
 else {
      throw new ParseException(String.format(""String_Node_Str"",type));
    }
  }
 else {
    throw new ParseException(String.format(""String_Node_Str"",type,lookAhead()));
  }
}",0.7399347116430903
135202,"public ArrayList<Token> lex(){
  ArrayList<Token> result=new ArrayList<>();
  Token previous=null;
  while (position < input.length() && (previous == null || previous.getType() != TokenType.EOF)) {
    previous=nextToken();
    result.add(previous);
  }
  result.add(nextToken());
  return result;
}","public List<Token> lex(){
  List<Token> result=new ArrayList<>();
  Token previous=null;
  while (position < input.length() && (previous == null || previous.getType() != TokenType.EOF)) {
    previous=nextToken();
    result.add(previous);
  }
  result.add(nextToken());
  return result;
}",0.8333333333333334
135203,"public FilterTextField(String initialText){
  super(initialText);
  previousText=initialText;
  setup();
}","public FilterTextField(Predicate<String> validation){
  super(""String_Node_Str"");
  setup(validation);
}",0.5904761904761905
135204,"private void setup(){
  setPrefColumnCount(30);
  validationSupport.registerValidator(this,(c,newValue) -> {
    boolean wasError=false;
    try {
      Parser.parse(getText());
      setStyleForValidFilter();
    }
 catch (    ParseException e) {
      wasError=true;
      setStyleForInvalidFilter();
    }
    return ValidationResult.fromErrorIf(this,""String_Node_Str"",wasError);
  }
);
  setOnKeyTyped(e -> {
    boolean isModifierKeyPress=e.isAltDown() || e.isMetaDown() || e.isControlDown();
    String key=e.getCharacter();
    if (key == null || key.isEmpty() || isModifierKeyPress) {
      return;
    }
    char typed=e.getCharacter().charAt(0);
    if (typed == '\t') {
      e.consume();
      if (!getSelectedText().isEmpty()) {
        confirmCompletion();
      }
    }
 else     if (Character.isAlphabetic(typed) && shouldStartCompletion()) {
      startCompletion(e);
    }
  }
);
  setOnKeyPressed(e -> {
    if (e.getCode() == KeyCode.TAB) {
      e.consume();
    }
  }
);
  setOnKeyReleased(e -> {
    e.consume();
    if (e.getCode() == KeyCode.ENTER) {
      confirmEdit();
    }
 else     if (e.getCode() == KeyCode.ESCAPE) {
      if (getText().equals(previousText)) {
        onCancel.run();
      }
 else {
        revertEdit();
      }
    }
  }
);
  addEventHandler(KeyEvent.KEY_PRESSED,event -> {
    if (SHOW_DOCS.match(event)) {
      onShowDocs.run();
    }
  }
);
}","private void setup(Predicate<String> validation){
  setPrefColumnCount(30);
  validationSupport.registerValidator(this,(c,newValue) -> {
    boolean isError=!validation.test(getText());
    if (isError) {
      setStyleForInvalidFilter();
    }
 else {
      setStyleForValidFilter();
    }
    return ValidationResult.fromErrorIf(this,""String_Node_Str"",isError);
  }
);
  setOnKeyTyped(e -> {
    boolean isModifierKeyPress=e.isAltDown() || e.isMetaDown() || e.isControlDown();
    String key=e.getCharacter();
    if (key == null || key.isEmpty() || isModifierKeyPress) {
      return;
    }
    char typed=e.getCharacter().charAt(0);
    if (typed == '\t') {
      e.consume();
      if (!getSelectedText().isEmpty()) {
        confirmCompletion();
      }
    }
 else     if (Character.isAlphabetic(typed) && shouldStartCompletion()) {
      startCompletion(e);
    }
  }
);
  setOnKeyPressed(e -> {
    if (e.getCode() == KeyCode.TAB) {
      e.consume();
    }
  }
);
  setOnKeyReleased(e -> {
    e.consume();
    if (e.getCode() == KeyCode.ENTER) {
      confirmEdit();
    }
 else     if (e.getCode() == KeyCode.ESCAPE) {
      if (getText().equals(previousText)) {
        onCancel.run();
      }
 else {
        revertEdit();
      }
    }
  }
);
  addEventHandler(KeyEvent.KEY_PRESSED,event -> {
    if (SHOW_DOCS.match(event)) {
      onShowDocs.run();
    }
  }
);
}",0.91183879093199
135205,"private Node createFilterBox(){
  filterTextField=new FilterTextField(""String_Node_Str"").setOnCancel(this::requestFocus).setOnShowDocs(ui.getBrowserComponent()::showFilterDocs).setOnConfirm((text) -> {
    Platform.runLater(() -> ui.triggerEvent(new ApplyingFilterEvent(this)));
    applyStringFilter(text);
    return text;
  }
);
  filterTextField.setId(guiController.getDefaultRepo() + ""String_Node_Str"" + panelIndex+ ""String_Node_Str"");
  filterTextField.setMinWidth(388);
  filterTextField.setMaxWidth(388);
  ui.registerEvent(onModelUpdate);
  filterTextField.setOnMouseClicked(e -> ui.triggerEvent(new PanelClickedEvent(panelIndex)));
  HBox layout=new HBox();
  layout.getChildren().addAll(filterTextField);
  layout.setPadding(new Insets(0,0,3,0));
  setupPanelDragEvents(layout);
  return layout;
}","private Node createFilterBox(){
  filterTextField=new FilterTextField(Parser::check).setOnCancel(this::requestFocus).setOnShowDocs(ui.getBrowserComponent()::showFilterDocs).setOnConfirm((text) -> {
    Platform.runLater(() -> ui.triggerEvent(new ApplyingFilterEvent(this)));
    applyStringFilter(text);
    return text;
  }
);
  filterTextField.setId(guiController.getDefaultRepo() + ""String_Node_Str"" + panelIndex+ ""String_Node_Str"");
  filterTextField.setMinWidth(388);
  filterTextField.setMaxWidth(388);
  ui.registerEvent(onModelUpdate);
  filterTextField.setOnMouseClicked(e -> ui.triggerEvent(new PanelClickedEvent(panelIndex)));
  HBox layout=new HBox();
  layout.getChildren().addAll(filterTextField);
  layout.setPadding(new Insets(0,0,3,0));
  setupPanelDragEvents(layout);
  return layout;
}",0.9813895781637716
135206,"@Test public void filterTextFieldColor_invalidFilter_invalidFilterStyleApplied(){
  testInvalidFilterStyleApplied(""String_Node_Str"");
  testInvalidFilterStyleApplied(""String_Node_Str"");
  testInvalidFilterStyleApplied(""String_Node_Str"");
  testInvalidFilterStyleApplied(""String_Node_Str"");
  testInvalidFilterStyleAppliedAfterEnter(""String_Node_Str"");
}","@Test public void filterTextFieldColor_invalidFilter_invalidFilterStyleApplied(){
  testInvalidFilterStyleApplied(""String_Node_Str"");
  testInvalidFilterStyleAppliedAfterEnter(""String_Node_Str"");
}",0.7163636363636363
135207,"public ListPanel(UI ui,GUIController guiController,PanelControl parentPanelControl,int panelIndex){
  super(ui,guiController,parentPanelControl,panelIndex);
  this.ui=ui;
  this.guiController=guiController;
  totalLabel=new Label(""String_Node_Str"");
  listView=new IssueListView();
  setupListView();
  getChildren().add(listView);
  getChildren().add(createPanelStats());
}","public ListPanel(UI ui,GUIController guiController,PanelControl parentPanelControl,int panelIndex){
  super(ui,guiController,parentPanelControl,panelIndex);
  this.ui=ui;
  this.guiController=guiController;
  listView=new IssueListView();
  setupListView();
  getChildren().add(listView);
  getChildren().add(createPanelFooter());
}",0.7507082152974505
135208,"/** 
 * Refreshes the list of issue cards shown to the user depending on the currently active filter expression in the panel.
 */
@Override public final void refreshItems(){
  final HashSet<Integer> issuesWithNewComments=updateIssueCommentCounts(Qualifier.hasUpdatedQualifier(getCurrentFilterExpression()));
  listView.setCellFactory(list -> new ListPanelCell(this,panelIndex,issuesWithNewComments));
  listView.saveSelection();
  listView.setItems(null);
  listView.setItems(getElementsList());
  issueCount=getElementsList().size();
  listView.restoreSelection();
  this.setId(guiController.getDefaultRepo() + ""String_Node_Str"" + panelIndex);
  totalLabel.setText(String.format(""String_Node_Str"",issueCount));
}","/** 
 * Refreshes the list of issue cards shown to the user depending on the currently active filter expression in the panel.
 */
@Override public final void refreshItems(){
  final HashSet<Integer> issuesWithNewComments=updateIssueCommentCounts(Qualifier.hasUpdatedQualifier(getCurrentFilterExpression()));
  listView.setCellFactory(list -> new ListPanelCell(this,panelIndex,issuesWithNewComments));
  listView.saveSelection();
  listView.setItems(null);
  listView.setItems(getElementsList());
  issueCount=getElementsList().size();
  listView.restoreSelection();
  this.setId(guiController.getDefaultRepo() + ""String_Node_Str"" + panelIndex);
  updateFooter();
}",0.9455337690631808
135209,"private void initialiseDialog(Stage stage,TurboIssue issue){
  initOwner(stage);
  initModality(Modality.APPLICATION_MODAL);
  setTitle(""String_Node_Str"" + (issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId()+ ""String_Node_Str""+ issue.getRepoId());
}","private void initialiseDialog(Stage stage,TurboIssue issue){
  initOwner(stage);
  initModality(Modality.APPLICATION_MODAL);
  setTitle(""String_Node_Str"" + (issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId()+ ""String_Node_Str""+ issue.getRepoId());
  Platform.runLater(() -> positionDialog(stage));
}",0.9172185430463576
135210,"private PickerLabel processSuggestedLabel(String suggestedLabel){
  return getStyledPickerLabel(getRepoTurboLabel(suggestedLabel),true,false,false,false,false);
}","private PickerLabel processSuggestedLabel(String suggestedLabel){
  return getStyledPickerLabel(getRepoTurboLabel(suggestedLabel),true,false,false,false,true);
}",0.978328173374613
135211,"private PickerLabel processInitialLabel(String initialLabel,List<String> removedLabels,Optional<String> suggestion){
  TurboLabel repoInitialLabel=getRepoTurboLabel(initialLabel);
  if (!removedLabels.contains(initialLabel) && !suggestion.isPresent()) {
    return getStyledPickerLabel(repoInitialLabel,false,false,false,false,true);
  }
  if (!removedLabels.contains(initialLabel) && suggestion.isPresent() && initialLabel.equals(suggestion.get())) {
    return getStyledPickerLabel(repoInitialLabel,true,false,true,false,true);
  }
  if (removedLabels.contains(initialLabel) && !suggestion.isPresent()) {
    return getStyledPickerLabel(repoInitialLabel,false,false,true,false,true);
  }
  if (removedLabels.contains(initialLabel) && suggestion.isPresent() && initialLabel.equals(suggestion.get())) {
    return getStyledPickerLabel(repoInitialLabel,true,false,false,false,true);
  }
  return getStyledPickerLabel(repoInitialLabel,false,false,false,false,true);
}","private PickerLabel processInitialLabel(String initialLabel,List<String> removedLabels,Optional<String> suggestion){
  TurboLabel repoInitialLabel=getRepoTurboLabel(initialLabel);
  if (!removedLabels.contains(initialLabel)) {
    if (suggestion.isPresent() && initialLabel.equals(suggestion.get())) {
      return getStyledPickerLabel(repoInitialLabel,true,false,true,false,true);
    }
    return getStyledPickerLabel(repoInitialLabel,false,false,false,false,true);
  }
  if (suggestion.isPresent() && initialLabel.equals(suggestion.get())) {
    return getStyledPickerLabel(repoInitialLabel,true,false,false,false,true);
  }
  return getStyledPickerLabel(repoInitialLabel,false,false,true,false,true);
}",0.6092160383004189
135212,"private void positionDialog(Stage stage){
  if (!Double.isNaN(getHeight())) {
    setX(stage.getX() + stage.getScene().getX());
    setY(stage.getY() + stage.getScene().getY() + (stage.getScene().getHeight() - getHeight()) / 2);
  }
}","private void positionDialog(Stage stage){
  if (getDialogHeight().isPresent()) {
    setX(stage.getX() + stage.getScene().getX());
    setY(stage.getY() + stage.getScene().getY() + (stage.getScene().getHeight() - getHeight()) / 2);
  }
}",0.929936305732484
135213,"private void createMainLayout() throws IOException {
  FXMLLoader loader=new FXMLLoader(UI.class.getResource(""String_Node_Str""));
  loader.setController(this);
  mainLayout=(VBox)loader.load();
}","private void createMainLayout(){
  FXMLLoader loader=new FXMLLoader(UI.class.getResource(""String_Node_Str""));
  loader.setController(this);
  try {
    mainLayout=(VBox)loader.load();
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    close();
  }
}",0.2863070539419087
135214,"private void setDialogPaneContent(TurboIssue issue){
  try {
    createMainLayout();
    setTitleLabel(issue);
    getDialogPane().setContent(mainLayout);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void setDialogPaneContent(TurboIssue issue){
  createMainLayout();
  setTitleLabel(issue);
  getDialogPane().setContent(mainLayout);
}",0.7932960893854749
135215,"/** 
 * To return the repo's TurboLabel that contains labelName <p> labelName MUST match a repo label's name
 * @param labelName
 * @return
 */
private TurboLabel getRepoTurboLabel(String labelName){
  assert(repoLabels.stream().filter(label -> label.getActualName().equals(labelName)).findFirst().isPresent());
  return repoLabels.stream().filter(label -> label.getActualName().equals(labelName)).findFirst().get();
}","/** 
 * To return the repo's TurboLabel that contains labelName <p> labelName MUST match a repo label's name
 * @param labelName
 * @return
 */
private TurboLabel getRepoTurboLabel(String labelName){
}",0.6494345718901454
135216,"private void populateGrouplessLabels(List<String> finalLabels,List<String> matchedLabels,Optional<String> suggestion){
  FlowPane groupless=createGroupPane(GROUPLESS_PAD);
  repoLabels.stream().filter(label -> !label.getGroup().isPresent()).map(label -> new PickerLabel(this,label,false)).forEach(label -> groupless.getChildren().add(processMatchedLabel(label.getActualName(),matchedLabels,finalLabels,suggestion).getNode()));
  if (!groupless.getChildren().isEmpty())   feedbackLabels.getChildren().add(groupless);
}","private void populateGrouplessLabels(List<String> finalLabels,List<String> matchedLabels,Optional<String> suggestion){
  FlowPane groupless=createGroupPane(GROUPLESS_PAD);
  repoLabels.stream().filter(label -> !label.getGroup().isPresent()).map(label -> new PickerLabel(label,false)).forEach(label -> groupless.getChildren().add(processMatchedLabel(label.getActualName(),matchedLabels,finalLabels,suggestion)));
  if (!groupless.getChildren().isEmpty())   feedbackLabels.getChildren().add(groupless);
}",0.985279685966634
135217,"void handleLabelClick(PickerLabel label){
  if (!queryField.isDisabled()) {
    queryField.setDisable(true);
  }
  finalAssignedLabels=updateFinalAssignedLabels(label);
  populatePanes(new ArrayList<>(),Optional.empty());
}","private void handleLabelClick(PickerLabel label){
  if (!queryField.isDisabled()) {
    queryField.setDisable(true);
  }
  finalAssignedLabels=updateFinalAssignedLabels(label);
  populatePanes(getCleanState(finalAssignedLabels,getRepoLabelsSet()));
}",0.8160676532769556
135218,"private boolean hasNewSuggestion(List<String> addedLabels,Optional<String> suggestion){
  return suggestion.isPresent() && !initialLabels.contains(suggestion.get()) && !addedLabels.contains(suggestion.get());
}","private boolean hasNewSuggestion(List<String> addedLabels,Optional<String> suggestion){
  return suggestion.isPresent() && !(issue.getLabels()).contains(suggestion.get()) && !addedLabels.contains(suggestion.get());
}",0.9248826291079812
135219,"private void populateAddedLabels(List<String> addedLabels,Optional<String> suggestion){
  addedLabels.stream().forEach(label -> {
    assignedLabels.getChildren().add(processAddedLabel(label,suggestion).getNode());
  }
);
}","private void populateAddedLabels(List<String> addedLabels,Optional<String> suggestion){
  addedLabels.stream().forEach(label -> {
    assignedLabels.getChildren().add(processAddedLabel(label,suggestion));
  }
);
}",0.9770642201834864
135220,"private PickerLabel processSuggestedLabel(String suggestedLabel){
  return getStyledPickerLabel(getRepoTurboLabel(suggestedLabel),true,false,false,false,true);
}","private Node processSuggestedLabel(String suggestedLabel){
  return getStyledPickerLabel(getRepoTurboLabel(suggestedLabel),true,false,false,false,true);
}",0.9587301587301588
135221,"private PickerLabel getStyledPickerLabel(TurboLabel label,boolean isFaded,boolean isHighlighted,boolean isRemoved,boolean isSelected,boolean isTop){
  PickerLabel styledLabel=new PickerLabel(this,label,isTop);
  styledLabel.setIsFaded(isFaded);
  styledLabel.setIsHighlighted(isHighlighted);
  styledLabel.setIsRemoved(isRemoved);
  styledLabel.setIsSelected(isSelected);
  return styledLabel;
}","private Node getStyledPickerLabel(TurboLabel label,boolean isFaded,boolean isHighlighted,boolean isRemoved,boolean isSelected,boolean isTop){
  PickerLabel styledLabel=new PickerLabel(label,isTop);
  styledLabel.setIsFaded(isFaded);
  styledLabel.setIsHighlighted(isHighlighted);
  styledLabel.setIsRemoved(isRemoved);
  styledLabel.setIsSelected(isSelected);
  Node node=styledLabel.getNode();
  node.setOnMouseClicked(e -> handleLabelClick(styledLabel));
  return node;
}",0.8341013824884793
135222,"private Map<String,FlowPane> getGroupContent(List<String> finalLabels,List<String> matchedLabels,Optional<String> suggestion){
  Map<String,FlowPane> groupContent=new HashMap<>();
  repoLabels.stream().sorted().filter(label -> label.getGroup().isPresent()).map(label -> new PickerLabel(this,label,false)).forEach(label -> {
    String group=label.getGroupName().get();
    if (!groupContent.containsKey(group)) {
      groupContent.put(group,createGroupPane(GROUP_PAD));
    }
    groupContent.get(group).getChildren().add(processMatchedLabel(label.getActualName(),matchedLabels,finalLabels,suggestion).getNode());
  }
);
  return groupContent;
}","private Map<String,FlowPane> getGroupContent(List<String> finalLabels,List<String> matchedLabels,Optional<String> suggestion){
  Map<String,FlowPane> groupContent=new HashMap<>();
  repoLabels.stream().sorted().filter(label -> label.getGroup().isPresent()).map(label -> new PickerLabel(label,false)).forEach(label -> {
    String group=label.getGroupName().get();
    if (!groupContent.containsKey(group)) {
      groupContent.put(group,createGroupPane(GROUP_PAD));
    }
    groupContent.get(group).getChildren().add(processMatchedLabel(label.getActualName(),matchedLabels,finalLabels,suggestion));
  }
);
  return groupContent;
}",0.9882537196554424
135223,"/** 
 * Populate respective panes with labels that matches current query
 * @param matchedLabels
 * @param suggestion
 */
public void populatePanes(LabelPickerState state){
  populateAssignedLabels(state);
  populateFeedbackLabels(state.getAssignedLabels(),state.getMatchedLabels(),state.getCurrentSuggestion());
}","/** 
 * Populate respective panes with labels that matches current query
 * @param matchedLabels
 * @param suggestion
 */
private void populatePanes(LabelPickerState state){
  populateAssignedLabels(state);
  populateFeedbackLabels(state.getAssignedLabels(),state.getMatchedLabels(),state.getCurrentSuggestion());
}",0.9793322734499204
135224,"private void populateSuggestedLabel(List<String> addedLabels,Optional<String> suggestion){
  if (hasNewSuggestion(addedLabels,suggestion)) {
    assignedLabels.getChildren().add(processSuggestedLabel(suggestion.get()).getNode());
  }
}","private void populateSuggestedLabel(List<String> addedLabels,Optional<String> suggestion){
  if (hasNewSuggestion(addedLabels,suggestion)) {
    assignedLabels.getChildren().add(processSuggestedLabel(suggestion.get()));
  }
}",0.9782608695652174
135225,"private PickerLabel processInitialLabel(String initialLabel,List<String> removedLabels,Optional<String> suggestion){
  TurboLabel repoInitialLabel=getRepoTurboLabel(initialLabel);
  if (!removedLabels.contains(initialLabel)) {
    if (suggestion.isPresent() && initialLabel.equals(suggestion.get())) {
      return getStyledPickerLabel(repoInitialLabel,true,false,true,false,true);
    }
    return getStyledPickerLabel(repoInitialLabel,false,false,false,false,true);
  }
  if (suggestion.isPresent() && initialLabel.equals(suggestion.get())) {
    return getStyledPickerLabel(repoInitialLabel,true,false,false,false,true);
  }
  return getStyledPickerLabel(repoInitialLabel,false,false,true,false,true);
}","private Node processInitialLabel(String initialLabel,List<String> removedLabels,Optional<String> suggestion){
  TurboLabel repoInitialLabel=getRepoTurboLabel(initialLabel);
  if (!removedLabels.contains(initialLabel)) {
    if (suggestion.isPresent() && initialLabel.equals(suggestion.get())) {
      return getStyledPickerLabel(repoInitialLabel,true,false,true,false,true);
    }
    return getStyledPickerLabel(repoInitialLabel,false,false,false,false,true);
  }
  if (suggestion.isPresent() && initialLabel.equals(suggestion.get())) {
    return getStyledPickerLabel(repoInitialLabel,true,false,false,false,true);
  }
  return getStyledPickerLabel(repoInitialLabel,false,false,true,false,true);
}",0.3758007117437722
135226,"private void registerQueryHandler(){
  queryField.textProperty().addListener((observable,oldValue,newValue) -> {
    LabelPickerState state=uiLogic.determineState(getCleanState(initialLabels,getRepoLabelsSet()),repoLabelsSet,queryField.getText().toLowerCase());
    finalAssignedLabels=state.getAssignedLabels();
    populatePanes(state);
  }
);
}","private void registerQueryHandler(){
  queryField.textProperty().addListener((observable,oldValue,newValue) -> {
    LabelPickerState state=uiLogic.determineState(getCleanState(issue.getLabels(),getRepoLabelsSet()),getRepoLabelsSet(),queryField.getText().toLowerCase());
    finalAssignedLabels=state.getAssignedLabels();
    populatePanes(state);
  }
);
}",0.9160739687055476
135227,"private void populateInitialLabels(List<String> initialLabels,List<String> removedLabels,Optional<String> suggestion){
  initialLabels.stream().forEach(label -> assignedLabels.getChildren().add(processInitialLabel(label,removedLabels,suggestion).getNode()));
}","private void populateInitialLabels(List<String> initialLabels,List<String> removedLabels,Optional<String> suggestion){
  initialLabels.stream().forEach(label -> assignedLabels.getChildren().add(processInitialLabel(label,removedLabels,suggestion)));
}",0.9803921568627452
135228,"private PickerLabel processAddedLabel(String addedLabel,Optional<String> suggestion){
  if (!suggestion.isPresent() || !addedLabel.equals(suggestion.get())) {
    return getStyledPickerLabel(getRepoTurboLabel(addedLabel),false,false,false,false,true);
  }
  return getStyledPickerLabel(getRepoTurboLabel(addedLabel),true,false,true,false,true);
}","private Node processAddedLabel(String addedLabel,Optional<String> suggestion){
  if (!suggestion.isPresent() || !addedLabel.equals(suggestion.get())) {
    return getStyledPickerLabel(getRepoTurboLabel(addedLabel),false,false,false,false,true);
  }
  return getStyledPickerLabel(getRepoTurboLabel(addedLabel),true,false,true,false,true);
}",0.2773722627737226
135229,"private PickerLabel processMatchedLabel(String repoLabel,List<String> matchedLabels,List<String> assignedLabels,Optional<String> suggestion){
  boolean shouldHighlight=(suggestion.isPresent()) ? suggestion.get().equals(repoLabel) : false;
  PickerLabel label=getStyledPickerLabel(getRepoTurboLabel(repoLabel),!matchedLabels.contains(repoLabel),shouldHighlight,false,assignedLabels.contains(repoLabel),false);
  return label;
}","private Node processMatchedLabel(String repoLabel,List<String> matchedLabels,List<String> assignedLabels,Optional<String> suggestion){
  boolean shouldHighlight=suggestion.isPresent() && suggestion.get().equals(repoLabel);
  return getStyledPickerLabel(getRepoTurboLabel(repoLabel),!matchedLabels.contains(repoLabel),shouldHighlight,false,assignedLabels.contains(repoLabel),false);
}",0.9122373300370828
135230,"public PickerLabel(LabelPickerDialog presenter,TurboLabel label,boolean isTop){
  super(label.getRepoId(),label.getColour(),label.getActualName());
  this.presenter=presenter;
  isSelected=false;
  isHighlighted=false;
  isRemoved=false;
  isFaded=false;
  this.isTop=isTop;
}","public PickerLabel(TurboLabel label,boolean isTop){
  super(label.getRepoId(),label.getColour(),label.getActualName());
  isSelected=false;
  isHighlighted=false;
  isRemoved=false;
  isFaded=false;
  this.isTop=isTop;
}",0.2137096774193548
135231,"@Override public Node getNode(){
  Label label=new Label((isTop ? getActualName() : getName()));
  label.getStyleClass().add(""String_Node_Str"");
  if (isRemoved)   label.getStyleClass().add(""String_Node_Str"");
  String style=getStyle() + (isHighlighted ? ""String_Node_Str"" : ""String_Node_Str"");
  style+=(isFaded ? ""String_Node_Str"" : ""String_Node_Str"");
  label.setStyle(style);
  FontLoader fontLoader=Toolkit.getToolkit().getFontLoader();
  double width=(double)fontLoader.computeStringWidth(label.getText(),label.getFont());
  label.setPrefWidth(width + 30);
  label.setText(label.getText() + (!isTop && isSelected ? ""String_Node_Str"" : ""String_Node_Str""));
  if (getGroup().isPresent()) {
    Tooltip groupTooltip=new Tooltip(getGroup().get());
    label.setTooltip(groupTooltip);
  }
  label.setOnMouseClicked(e -> {
    presenter.handleLabelClick(this);
  }
);
  return label;
}","@Override public Node getNode(){
  Label label=new Label((isTop ? getActualName() : getName()));
  label.getStyleClass().add(""String_Node_Str"");
  if (isRemoved)   label.getStyleClass().add(""String_Node_Str"");
  String style=getStyle() + (isHighlighted ? ""String_Node_Str"" : ""String_Node_Str"");
  style+=(isFaded ? ""String_Node_Str"" : ""String_Node_Str"");
  label.setStyle(style);
  FontLoader fontLoader=Toolkit.getToolkit().getFontLoader();
  double width=(double)fontLoader.computeStringWidth(label.getText(),label.getFont());
  label.setPrefWidth(width + 30);
  label.setText(label.getText() + (!isTop && isSelected ? ""String_Node_Str"" : ""String_Node_Str""));
  if (getGroup().isPresent()) {
    Tooltip groupTooltip=new Tooltip(getGroup().get());
    label.setTooltip(groupTooltip);
  }
  return label;
}",0.937352245862884
135232,"private LabelPickerState handleCharAddition(LabelPickerState currentState,String currentString){
  return currentState.updateMatchedLabels(repoLabels,currentString);
}","private LabelPickerState handleCharAddition(LabelPickerState currentState,String currentString){
  String[] keywords=currentString.split(""String_Node_Str"");
  if (keywords.length > 0) {
    return currentState.updateMatchedLabels(repoLabels,keywords[keywords.length - 1]);
  }
 else {
    return currentState.updateMatchedLabels(repoLabels,""String_Node_Str"");
  }
}",0.5789473684210527
135233,"private String getName(String name){
  if (hasGroup(name)) {
    return name.substring(name.indexOf(TurboLabel.getDelimiter(name).get()) - 1);
  }
 else {
    return name;
  }
}","private String getName(String name){
  if (hasGroup(name)) {
    return name.substring(name.indexOf(TurboLabel.getDelimiter(name).get()) + 1);
  }
 else {
    return name;
  }
}",0.9943502824858758
135234,"private List<String> filterByName(List<String> repoLabels,String labelName){
  return repoLabels.stream().filter(name -> Utility.containsIgnoreCase(getGroup(name),labelName)).collect(Collectors.toList());
}","private List<String> filterByName(List<String> repoLabels,String labelName){
  return repoLabels.stream().filter(name -> Utility.containsIgnoreCase(getName(name),labelName)).collect(Collectors.toList());
}",0.978102189781022
135235,"public LabelPickerState updateMatchedLabels(Set<String> repoLabels,String query){
  List<String> newMatchedLabels=convertToList(repoLabels);
  newMatchedLabels=filterByName(newMatchedLabels,getName(query));
  newMatchedLabels=filterByGroup(newMatchedLabels,getGroup(query));
  return new LabelPickerState(initialLabels,addedLabels,removedLabels,newMatchedLabels,currentSuggestionIndex);
}","public LabelPickerState updateMatchedLabels(Set<String> repoLabels,String query){
  List<String> newMatchedLabels=convertToList(repoLabels);
  newMatchedLabels=filterByName(newMatchedLabels,getName(query));
  newMatchedLabels=filterByGroup(newMatchedLabels,getGroup(query));
  OptionalInt newSuggestionIndex;
  if (newMatchedLabels.isEmpty()) {
    newSuggestionIndex=currentSuggestionIndex;
  }
 else {
    newSuggestionIndex=OptionalInt.of(0);
  }
  return new LabelPickerState(initialLabels,addedLabels,removedLabels,newMatchedLabels,newSuggestionIndex);
}",0.8046462513199577
135236,"@Override public Node getNode(){
  Label label=new Label((isTop ? getActualName() : getName()));
  label.getStyleClass().add(""String_Node_Str"");
  if (isRemoved)   label.getStyleClass().add(""String_Node_Str"");
  String style=getStyle() + (isHighlighted ? ""String_Node_Str"" : ""String_Node_Str"");
  style+=(isFaded ? ""String_Node_Str"" : ""String_Node_Str"");
  label.setStyle(style);
  FontLoader fontLoader=Toolkit.getToolkit().getFontLoader();
  double width=(double)fontLoader.computeStringWidth(label.getText(),label.getFont());
  label.setPrefWidth(width + 30);
  label.setText(label.getText() + (!isTop && isSelected ? ""String_Node_Str"" : ""String_Node_Str""));
  if (getGroup().isPresent()) {
    Tooltip groupTooltip=new Tooltip(getGroup().get());
    label.setTooltip(groupTooltip);
  }
  label.setOnMouseClicked(e -> labelPickerUILogic.toggleLabel(getActualName()));
  return label;
}","@Override public Node getNode(){
  Label label=new Label((isTop ? getActualName() : getName()));
  label.getStyleClass().add(""String_Node_Str"");
  if (isRemoved)   label.getStyleClass().add(""String_Node_Str"");
  String style=getStyle() + (isHighlighted ? ""String_Node_Str"" : ""String_Node_Str"");
  style+=(isFaded ? ""String_Node_Str"" : ""String_Node_Str"");
  label.setStyle(style);
  FontLoader fontLoader=Toolkit.getToolkit().getFontLoader();
  double width=(double)fontLoader.computeStringWidth(label.getText(),label.getFont());
  label.setPrefWidth(width + 30);
  label.setText(label.getText() + (!isTop && isSelected ? ""String_Node_Str"" : ""String_Node_Str""));
  if (getGroup().isPresent()) {
    Tooltip groupTooltip=new Tooltip(getGroup().get());
    label.setTooltip(groupTooltip);
  }
  return label;
}",0.952212389380531
135237,"private List<String> convertToList(Set<String> labelSet){
  List<String> resultingList=new ArrayList<>();
  resultingList.addAll(initialLabels);
  return resultingList;
}","private List<String> convertToList(Set<String> labelSet){
  List<String> resultingList=new ArrayList<>();
  resultingList.addAll(labelSet);
  return resultingList;
}",0.9671641791044776
135238,"public SemanticException(QualifierType type,String details){
  super(String.format(ERR_MSG,type,details));
  System.out.println(String.format(ERR_MSG,type,details));
}","public SemanticException(QualifierType type,String details){
  super(String.format(ERROR_MESSAGE,type,details));
}",0.7758007117437722
135239,"private boolean satisfiesCreationDate(TurboIssue issue){
  LocalDate creationDate=issue.getCreatedAt().toLocalDate();
  if (date.isPresent()) {
    return creationDate.isEqual(date.get());
  }
 else   if (dateRange.isPresent()) {
    return dateRange.get().encloses(creationDate);
  }
 else {
    throw new SemanticException(type,type.getValidInputs());
  }
}","private boolean satisfiesCreationDate(TurboIssue issue){
  LocalDate creationDate=issue.getCreatedAt().toLocalDate();
  if (date.isPresent()) {
    return creationDate.isEqual(date.get());
  }
 else   if (dateRange.isPresent()) {
    return dateRange.get().encloses(creationDate);
  }
 else {
    throw new SemanticException(type,type.getDescriptionOfValidInputs());
  }
}",0.9822161422708618
135240,"private boolean stateSatisfies(TurboIssue issue){
  if (!content.isPresent())   return false;
  String content=this.content.get().toLowerCase();
  if (content.contains(""String_Node_Str"")) {
    return issue.isOpen();
  }
 else   if (content.contains(""String_Node_Str"")) {
    return !issue.isOpen();
  }
 else {
    throw new SemanticException(type,type.getValidInputs());
  }
}","private boolean stateSatisfies(TurboIssue issue){
  if (!content.isPresent())   return false;
  String content=this.content.get().toLowerCase();
  if (content.contains(""String_Node_Str"")) {
    return issue.isOpen();
  }
 else   if (content.contains(""String_Node_Str"")) {
    return !issue.isOpen();
  }
 else {
    throw new SemanticException(type,type.getDescriptionOfValidInputs());
  }
}",0.9830949284785436
135241,"private boolean typeSatisfies(TurboIssue issue){
  if (!content.isPresent())   return false;
  String content=this.content.get().toLowerCase();
switch (content) {
case ""String_Node_Str"":
    return !issue.isPullRequest();
case ""String_Node_Str"":
case ""String_Node_Str"":
  return issue.isPullRequest();
default :
throw new SemanticException(type,type.getValidInputs());
}
}","private boolean typeSatisfies(TurboIssue issue){
  if (!content.isPresent())   return false;
  String content=this.content.get().toLowerCase();
switch (content) {
case ""String_Node_Str"":
    return !issue.isPullRequest();
case ""String_Node_Str"":
case ""String_Node_Str"":
  return issue.isPullRequest();
default :
throw new SemanticException(type,type.getDescriptionOfValidInputs());
}
}",0.9828269484808454
135242,"private boolean satisfiesUpdatedHours(TurboIssue issue){
  NumberRange updatedRange;
  if (numberRange.isPresent()) {
    updatedRange=numberRange.get();
  }
 else   if (number.isPresent()) {
    updatedRange=new NumberRange(null,number.get(),true);
  }
 else {
    throw new SemanticException(type,type.getValidInputs());
  }
  LocalDateTime dateOfUpdate=issue.getUpdatedAt();
  int hoursSinceUpdate=Utility.safeLongToInt(dateOfUpdate.until(getCurrentTime(),ChronoUnit.HOURS));
  return updatedRange.encloses(hoursSinceUpdate);
}","private boolean satisfiesUpdatedHours(TurboIssue issue){
  NumberRange updatedRange;
  if (numberRange.isPresent()) {
    updatedRange=numberRange.get();
  }
 else   if (number.isPresent()) {
    updatedRange=new NumberRange(null,number.get(),true);
  }
 else {
    throw new SemanticException(type,type.getDescriptionOfValidInputs());
  }
  LocalDateTime dateOfUpdate=issue.getUpdatedAt();
  int hoursSinceUpdate=Utility.safeLongToInt(dateOfUpdate.until(getCurrentTime(),ChronoUnit.HOURS));
  return updatedRange.encloses(hoursSinceUpdate);
}",0.9878844361602982
135243,"private boolean idSatisfies(TurboIssue issue){
  if (number.isPresent()) {
    return issue.getId() == number.get();
  }
 else   if (numberRange.isPresent()) {
    return numberRange.get().encloses(issue.getId());
  }
  throw new SemanticException(type,type.getValidInputs());
}","private boolean idSatisfies(TurboIssue issue){
  if (number.isPresent()) {
    return issue.getId() == number.get();
  }
 else   if (numberRange.isPresent()) {
    return numberRange.get().encloses(issue.getId());
  }
  throw new SemanticException(type,type.getDescriptionOfValidInputs());
}",0.9771528998242532
135244,"private boolean satisfiesIsConditions(TurboIssue issue){
  if (!content.isPresent())   return false;
switch (content.get()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    return stateSatisfies(issue);
case ""String_Node_Str"":
case ""String_Node_Str"":
  return typeSatisfies(issue);
case ""String_Node_Str"":
return issue.isPullRequest() && !issue.isOpen();
case ""String_Node_Str"":
return issue.isPullRequest() && issue.isOpen();
case ""String_Node_Str"":
return issue.isCurrentlyRead();
case ""String_Node_Str"":
return !issue.isCurrentlyRead();
default :
throw new SemanticException(type,type.getValidInputs());
}
}","private boolean satisfiesIsConditions(TurboIssue issue){
  if (!content.isPresent())   return false;
switch (content.get()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    return stateSatisfies(issue);
case ""String_Node_Str"":
case ""String_Node_Str"":
  return typeSatisfies(issue);
case ""String_Node_Str"":
return issue.isPullRequest() && !issue.isOpen();
case ""String_Node_Str"":
return issue.isPullRequest() && issue.isOpen();
case ""String_Node_Str"":
return issue.isCurrentlyRead();
case ""String_Node_Str"":
return !issue.isCurrentlyRead();
default :
throw new SemanticException(type,type.getDescriptionOfValidInputs());
}
}",0.989541432019308
135245,"private void applyStringFilter(String filterString){
  try {
    FilterExpression filter=Parser.parse(filterString);
    if (filter != null) {
      this.applyFilterExpression(filter);
    }
 else {
      this.applyFilterExpression(Qualifier.EMPTY);
    }
  }
 catch (  FilterException ex) {
    this.applyFilterExpression(Qualifier.EMPTY);
    UI.status.displayMessage(""String_Node_Str"" + (panelIndex + 1) + ""String_Node_Str""+ ex.getMessage());
  }
}","private void applyStringFilter(String filterString){
  try {
    FilterExpression filter=Parser.parse(filterString);
    if (filter != null) {
      this.applyFilterExpression(filter);
    }
 else {
      this.applyFilterExpression(Qualifier.EMPTY);
    }
  }
 catch (  FilterException ex) {
    this.applyFilterExpression(Qualifier.EMPTY);
    UI.status.displayMessage(getUniquePanelName(panelMenuBar.getPanelName()) + ""String_Node_Str"" + ex.getMessage());
  }
}",0.9037199124726476
135246,"@Test public void invalidNo(){
  expectSemanticException(QualifierType.NO,""String_Node_Str"");
}","@Test public void invalidNo(){
  verifySemanticException(QualifierType.NO,""String_Node_Str"");
}",0.9473684210526316
135247,"@Test public void invalidUpdated(){
  expectSemanticException(QualifierType.UPDATED,""String_Node_Str"");
}","@Test public void invalidUpdated(){
  verifySemanticException(QualifierType.UPDATED,""String_Node_Str"");
}",0.9523809523809524
135248,"@Test public void invalidState(){
  expectSemanticException(QualifierType.STATE,""String_Node_Str"");
}","@Test public void invalidState(){
  verifySemanticException(QualifierType.STATE,""String_Node_Str"");
}",0.9504950495049505
135249,"@Test public void invalidIs(){
  expectSemanticException(QualifierType.IS,""String_Node_Str"");
}","@Test public void invalidIs(){
  verifySemanticException(QualifierType.IS,""String_Node_Str"");
}",0.9473684210526316
135250,"@Test public void invalidType(){
  expectSemanticException(QualifierType.TYPE,""String_Node_Str"");
}","@Test public void invalidType(){
  verifySemanticException(QualifierType.TYPE,""String_Node_Str"");
}",0.9494949494949496
135251,"@Test public void invalidId(){
  expectSemanticException(QualifierType.ID,""String_Node_Str"");
}","@Test public void invalidId(){
  verifySemanticException(QualifierType.ID,""String_Node_Str"");
}",0.9473684210526316
135252,"@Test public void invalidCreated(){
  expectSemanticException(QualifierType.CREATED,""String_Node_Str"");
}","@Test public void invalidCreated(){
  verifySemanticException(QualifierType.CREATED,""String_Node_Str"");
}",0.9523809523809524
135253,"@Test public void invalidHas(){
  expectSemanticException(QualifierType.HAS,""String_Node_Str"");
}","@Test public void invalidHas(){
  verifySemanticException(QualifierType.HAS,""String_Node_Str"");
}",0.9484536082474226
135254,"private void addListener(){
  nameField.textProperty().addListener(c -> {
    String newName=nameField.getText().trim();
    if (nameField.getText().length() > BOARD_MAX_NAME_LENGTH) {
      nameField.setText(previousText);
      errorText.setText(ERROR_LONG_NAME);
      submitButton.setDisable(false);
    }
 else     if (isBoardNameInvalid(newName)) {
      errorText.setText(ERROR_INVALID_NAME);
      submitButton.setDisable(true);
    }
 else     if (isBoardNameEmpty(newName)) {
      errorText.setText(ERROR_EMPTY_NAME);
      submitButton.setDisable(true);
    }
 else     if (isBoardNameDuplicate(newName)) {
      errorText.setText(WARNING_DUPLICATE_NAME);
      submitButton.setDisable(false);
    }
 else {
      errorText.setText(""String_Node_Str"");
      submitButton.setDisable(false);
    }
    previousText=nameField.getText();
  }
);
}","private void addListener(){
  nameField.textProperty().addListener(c -> {
    String newName=nameField.getText().trim();
    if (nameField.getText().length() > BOARD_MAX_NAME_LENGTH) {
      nameField.setText(previousText);
      errorText.setText(String.format(ERROR_LONG_NAME,BOARD_MAX_NAME_LENGTH));
      submitButton.setDisable(false);
    }
 else     if (isBoardNameInvalid(newName)) {
      errorText.setText(ERROR_INVALID_NAME);
      submitButton.setDisable(true);
    }
 else     if (isBoardNameEmpty(newName)) {
      errorText.setText(ERROR_EMPTY_NAME);
      submitButton.setDisable(true);
    }
 else     if (isBoardNameDuplicate(newName)) {
      errorText.setText(WARNING_DUPLICATE_NAME);
      submitButton.setDisable(false);
    }
 else {
      errorText.setText(""String_Node_Str"");
      submitButton.setDisable(false);
    }
    previousText=nameField.getText();
  }
);
}",0.9787965616045844
135255,"private static Optional<Integer> getCurrentMilestoneIndex(List<TurboMilestone> allMilestones){
  if (allMilestones.isEmpty()) {
    return Optional.empty();
  }
  int currentIndex=0;
  for (  TurboMilestone checker : allMilestones) {
    if (checker.isOpen() && isRelevantMilestone(checker)) {
      return Optional.of(currentIndex);
    }
    currentIndex++;
  }
  return Optional.of(allMilestones.size());
}","private static Optional<Integer> getCurrentMilestoneIndex(List<TurboMilestone> allMilestones){
  if (allMilestones.isEmpty()) {
    return Optional.empty();
  }
  Optional<TurboMilestone> openAndRelevantMilestone=allMilestones.stream().filter(ms -> ms.isOpen() && isRelevantMilestone(ms)).findFirst();
  if (openAndRelevantMilestone.isPresent()) {
    return Optional.of(allMilestones.indexOf(openAndRelevantMilestone.get()));
  }
 else {
    int currentIndex=0;
    for (    TurboMilestone checker : allMilestones) {
      if (checker.isOpen()) {
        return Optional.of(currentIndex);
      }
      currentIndex++;
    }
  }
  return Optional.of(allMilestones.size());
}",0.6863468634686347
135256,"public static FilterExpression replaceMilestoneAliases(IModel model,FilterExpression expr){
  List<String> repoIds=getMetaQualifierContent(expr,QualifierType.REPO).stream().map(String::toLowerCase).collect(Collectors.toList());
  if (repoIds.isEmpty()) {
    repoIds.add(model.getDefaultRepo().toLowerCase());
  }
  List<TurboMilestone> allMilestones=model.getMilestones().stream().filter(ms -> ms.getDueDate().isPresent()).filter(ms -> repoIds.contains(ms.getRepoId().toLowerCase())).sorted((a,b) -> getMilestoneDueDateComparator().compare(a,b)).collect(Collectors.toList());
  boolean hasRelevantMilestone=allMilestones.stream().anyMatch(ms -> isRelevantMilestone(ms));
  if (!hasRelevantMilestone) {
    List<TurboMilestone> openMilestonesWithoutDueDate=model.getMilestones().stream().filter(ms -> !ms.getDueDate().isPresent()).filter(ms -> repoIds.contains(ms.getRepoId().toLowerCase())).filter(ms -> ms.isOpen()).collect(Collectors.toList());
    if (openMilestonesWithoutDueDate.size() == 1) {
      allMilestones.add(openMilestonesWithoutDueDate.get(0));
    }
  }
  Optional<Integer> currentMilestoneIndex=getCurrentMilestoneIndex(allMilestones);
  if (!currentMilestoneIndex.isPresent()) {
    return expr;
  }
  return expr.map(q -> {
    if (Qualifier.isMilestoneQualifier(q)) {
      return q.convertMilestoneAliasQualifier(allMilestones,currentMilestoneIndex.get());
    }
 else {
      return q;
    }
  }
);
}","public static FilterExpression replaceMilestoneAliases(IModel model,FilterExpression expr){
  List<String> repoIds=getMetaQualifierContent(expr,QualifierType.REPO).stream().map(String::toLowerCase).collect(Collectors.toList());
  if (repoIds.isEmpty()) {
    repoIds.add(model.getDefaultRepo().toLowerCase());
  }
  List<TurboMilestone> allMilestones=model.getMilestones().stream().filter(ms -> ms.getDueDate().isPresent()).filter(ms -> repoIds.contains(ms.getRepoId().toLowerCase())).sorted((a,b) -> getMilestoneDueDateComparator().compare(a,b)).collect(Collectors.toList());
  List<TurboMilestone> openMilestones=model.getMilestones().stream().filter(ms -> ms.isOpen()).collect(Collectors.toList());
  if (openMilestones.size() == 1 && !openMilestones.get(0).getDueDate().isPresent()) {
    allMilestones.addAll(openMilestones);
  }
  Optional<Integer> currentMilestoneIndex=getCurrentMilestoneIndex(allMilestones);
  if (!currentMilestoneIndex.isPresent()) {
    return expr;
  }
  return expr.map(q -> {
    if (Qualifier.isMilestoneQualifier(q)) {
      return q.convertMilestoneAliasQualifier(allMilestones,currentMilestoneIndex.get());
    }
 else {
      return q;
    }
  }
);
}",0.6104940635771735
135257,"@Test public void replaceMilestoneAliasesTestNoRelevantMilestone(){
  TurboMilestone msIrrelevant1=new TurboMilestone(REPO,1,""String_Node_Str"");
  msIrrelevant1.setDueDate(Optional.of(LocalDate.now().minusDays(1)));
  msIrrelevant1.setOpen(true);
  TurboMilestone msIrrelevant2=new TurboMilestone(REPO,2,""String_Node_Str"");
  msIrrelevant2.setDueDate(Optional.of(LocalDate.now().minusDays(2)));
  msIrrelevant1.setOpen(true);
  TurboMilestone msRelevant1=new TurboMilestone(REPO,3,""String_Node_Str"");
  msRelevant1.setDueDate(Optional.empty());
  msRelevant1.setOpen(true);
  TurboMilestone msRelevant2=new TurboMilestone(REPO,4,""String_Node_Str"");
  msRelevant2.setDueDate(Optional.empty());
  msRelevant2.setOpen(true);
  model=TestUtils.singletonModel(new Model(REPO,new ArrayList<>(),new ArrayList<>(),new ArrayList<>(Arrays.asList(msIrrelevant1,msIrrelevant2)),new ArrayList<>()));
  FilterExpression expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  List<Qualifier> milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  assertEquals(0,milestoneQualifiers.size());
  model=TestUtils.singletonModel(new Model(REPO,new ArrayList<>(),new ArrayList<>(),new ArrayList<>(Arrays.asList(msIrrelevant1,msIrrelevant2,msRelevant1)),new ArrayList<>()));
  expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  milestoneQualifiers.stream().forEach(msQ -> {
    assertEquals(""String_Node_Str"",msQ.getContent().get());
  }
);
  expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  milestoneQualifiers.stream().forEach(msQ -> {
    assertEquals(""String_Node_Str"",msQ.getContent().get());
  }
);
  expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  assertEquals(0,milestoneQualifiers.size());
  model=TestUtils.singletonModel(new Model(REPO,new ArrayList<>(),new ArrayList<>(),new ArrayList<>(Arrays.asList(msIrrelevant1,msIrrelevant2,msRelevant1,msRelevant2)),new ArrayList<>()));
  expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  assertEquals(0,milestoneQualifiers.size());
}","@Test public void replaceMilestoneAliasesTestNoRelevantMilestone(){
  TurboMilestone msIrrelevant1=new TurboMilestone(REPO,1,""String_Node_Str"");
  msIrrelevant1.setDueDate(Optional.of(LocalDate.now().minusDays(1)));
  msIrrelevant1.setOpen(false);
  TurboMilestone msIrrelevant2=new TurboMilestone(REPO,2,""String_Node_Str"");
  msIrrelevant2.setDueDate(Optional.of(LocalDate.now().minusDays(2)));
  msIrrelevant2.setOpen(true);
  TurboMilestone msRelevant1=new TurboMilestone(REPO,3,""String_Node_Str"");
  msRelevant1.setDueDate(Optional.empty());
  msRelevant1.setOpen(true);
  TurboMilestone msRelevant2=new TurboMilestone(REPO,4,""String_Node_Str"");
  msRelevant2.setDueDate(Optional.empty());
  msRelevant2.setOpen(true);
  model=TestUtils.singletonModel(new Model(REPO,new ArrayList<>(),new ArrayList<>(),new ArrayList<>(Arrays.asList(msIrrelevant1,msIrrelevant2)),new ArrayList<>()));
  FilterExpression expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  List<Qualifier> milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  milestoneQualifiers.stream().forEach(msQ -> {
    assertEquals(""String_Node_Str"",msQ.getContent().get());
  }
);
  msIrrelevant2.setOpen(false);
  model=TestUtils.singletonModel(new Model(REPO,new ArrayList<>(),new ArrayList<>(),new ArrayList<>(Arrays.asList(msIrrelevant1,msIrrelevant2,msRelevant1)),new ArrayList<>()));
  expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  milestoneQualifiers.stream().forEach(msQ -> {
    assertEquals(""String_Node_Str"",msQ.getContent().get());
  }
);
  expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  milestoneQualifiers.stream().forEach(msQ -> {
    assertEquals(""String_Node_Str"",msQ.getContent().get());
  }
);
  expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  assertEquals(0,milestoneQualifiers.size());
  model=TestUtils.singletonModel(new Model(REPO,new ArrayList<>(),new ArrayList<>(),new ArrayList<>(Arrays.asList(msIrrelevant1,msIrrelevant2,msRelevant1,msRelevant2)),new ArrayList<>()));
  expr=Qualifier.replaceMilestoneAliases(model,Parser.parse(""String_Node_Str""));
  milestoneQualifiers=expr.find(Qualifier::isMilestoneQualifier);
  assertEquals(0,milestoneQualifiers.size());
}",0.9659975419909872
135258,"private CompletableFuture<Boolean> updateIssueLabelsOnRepo(TurboIssue issue,List<String> newLabels){
  logger.info(""String_Node_Str"" + issue + ""String_Node_Str"");
  return repoOpControl.replaceIssueLabels(issue,newLabels).thenApply(labels -> labels.containsAll(newLabels)).exceptionally(Futures.withResult(false));
}","private CompletableFuture<Boolean> updateIssueLabelsOnRepo(TurboIssue issue,List<String> newLabels){
  logger.info(""String_Node_Str"" + issue + ""String_Node_Str"");
  return repoOpControl.replaceIssueLabels(issue,newLabels).thenApply(labels -> newLabels.containsAll(labels)).exceptionally(Futures.withResult(false));
}",0.9841772151898734
135259,"/** 
 * Replaces existing labels with new labels in the issue object, the UI, and the server, in that order. Server update is done after the local update to reduce the lag between the user action and the UI response
 * @param issue The issue object whose labels are to be replaced.
 * @param newLabels The list of new labels to be assigned to the issue.
 * @return true if label replacement on GitHub was a success, false otherwise.
 */
public CompletableFuture<Boolean> replaceIssueLabels(TurboIssue issue,List<String> newLabels){
  logger.info(""String_Node_Str"" + issue + ""String_Node_Str"");
  issue.setLabels(newLabels);
  refreshUI();
  return updateIssueLabelsOnRepo(issue,newLabels);
}","/** 
 * Replaces existing labels with new labels in the issue object, the UI, and the server, in that order. Server update is done after the local update to reduce the lag between the user action and the UI response
 * @param issue The issue object whose labels are to be replaced.
 * @param newLabels The list of new labels to be assigned to the issue.
 * @return true if label replacement on GitHub was a success, false otherwise.
 */
public CompletableFuture<Boolean> replaceIssueLabels(TurboIssue issue,List<String> newLabels){
  logger.info(""String_Node_Str"" + issue + ""String_Node_Str"");
  if (!models.replaceIssueLabels(issue,newLabels)) {
    return CompletableFuture.completedFuture(false);
  }
  refreshUI();
  return updateIssueLabelsOnRepo(issue,newLabels);
}",0.9357045143638852
135260,"@Override public Optional<Model> getModelById(String repoId){
  return models.containsKey(repoId) ? Optional.of(models.get(repoId)) : Optional.empty();
}","@Override public synchronized Optional<Model> getModelById(String repoId){
  return models.containsKey(repoId) ? Optional.of(models.get(repoId)) : Optional.empty();
}",0.9592476489028212
135261,"public void addLabel(TurboLabel label){
  addLabel(label.getActualName());
}","public void addLabel(TurboLabel label){
  addLabel(label.getActualName());
  this.labelsLastModifiedAt=Optional.of(LocalDateTime.now());
}",0.7102803738317757
135262,"public List<String> getLabels(){
  return labels;
}","public List<String> getLabels(){
  return new ArrayList<>(labels);
}",0.8571428571428571
135263,"public void setLabels(List<String> labels){
  this.labels=labels;
}","public void setLabels(List<String> labels){
  this.labels=labels;
  this.labelsLastModifiedAt=Optional.of(LocalDateTime.now());
}",0.6836734693877551
135264,"/** 
 * Takes lists of TurboIssues and reconciles the changes between them, returning a list of TurboIssues with updates from the second.
 */
public static List<TurboIssue> reconcile(String repoId,List<TurboIssue> existing,List<TurboIssue> changed){
  List<TurboIssue> existingCopy=new ArrayList<>(existing);
  for (  TurboIssue issue : changed) {
    int id=issue.getId();
    Optional<Integer> corresponding=findIssueWithId(existingCopy,id);
    if (corresponding.isPresent()) {
      TurboIssue newIssue=new TurboIssue(issue);
      newIssue.transferTransientState(existingCopy.get(corresponding.get()));
      existingCopy.set(corresponding.get(),newIssue);
    }
 else {
      existingCopy.add(new TurboIssue(issue));
    }
  }
  return existingCopy;
}","/** 
 * Takes lists of TurboIssues and reconciles the changes between them, returning a list of TurboIssues with updates from the second.
 */
public static List<TurboIssue> reconcile(String repoId,List<TurboIssue> existing,List<TurboIssue> changed){
  List<TurboIssue> existingCopy=new ArrayList<>(existing);
  for (  TurboIssue issue : changed) {
    int id=issue.getId();
    Optional<Integer> correspondingIssueIndex=findIssueWithId(existingCopy,id);
    if (correspondingIssueIndex.isPresent()) {
      TurboIssue existingIssue=existingCopy.get(correspondingIssueIndex.get());
      TurboIssue newIssue=new TurboIssue(issue);
      newIssue.transferTransientState(existingIssue);
      newIssue.reconcile(existingIssue);
      existingCopy.set(correspondingIssueIndex.get(),newIssue);
    }
 else {
      existingCopy.add(new TurboIssue(issue));
    }
  }
  return existingCopy;
}",0.765386959171237
135265,"public static Optional<Integer> findIssueWithId(List<TurboIssue> issues,int id){
  int i=0;
  for (  TurboIssue issue : issues) {
    if (issue.getId() == id) {
      return Optional.of(i);
    }
    ++i;
  }
  return Optional.empty();
}","/** 
 * Finds the index of an issue with specified id in a list of issues
 * @param issues
 * @param id
 * @return the list's index of the issue or empty of there is no issue with such id in the list
 */
public static Optional<Integer> findIssueWithId(List<TurboIssue> issues,int id){
  for (int i=0; i < issues.size(); i++) {
    if (issues.get(i).getId() == id) {
      return Optional.of(i);
    }
  }
  return Optional.empty();
}",0.4955223880597015
135266,"private Node createFilterBox(){
  filterTextField=new FilterTextField(""String_Node_Str"").setOnConfirm((text) -> {
    ui.triggerEvent(new PanelReloadingEvent());
    applyStringFilter(text);
    ui.triggerEvent(new PanelReloadedEvent());
    return text;
  }
).setOnCancel(this::requestFocus);
  filterTextField.setId(guiController.getDefaultRepo() + ""String_Node_Str"" + panelIndex+ ""String_Node_Str"");
  filterTextField.setMinWidth(388);
  filterTextField.setMaxWidth(388);
  ui.registerEvent(onModelUpdate);
  filterTextField.setOnMouseClicked(e -> ui.triggerEvent(new PanelClickedEvent(panelIndex)));
  HBox layout=new HBox();
  layout.getChildren().addAll(filterTextField);
  layout.setPadding(new Insets(0,0,3,0));
  setupPanelDragEvents(layout);
  return layout;
}","private Node createFilterBox(){
  filterTextField=new FilterTextField(""String_Node_Str"").setOnConfirm((text) -> {
    Platform.runLater(() -> ui.triggerEvent(new PanelReloadingEvent()));
    applyStringFilter(text);
    Platform.runLater(() -> ui.triggerEvent(new PanelReloadedEvent()));
    return text;
  }
).setOnCancel(this::requestFocus);
  filterTextField.setId(guiController.getDefaultRepo() + ""String_Node_Str"" + panelIndex+ ""String_Node_Str"");
  filterTextField.setMinWidth(388);
  filterTextField.setMaxWidth(388);
  ui.registerEvent(onModelUpdate);
  filterTextField.setOnMouseClicked(e -> ui.triggerEvent(new PanelClickedEvent(panelIndex)));
  HBox layout=new HBox();
  layout.getChildren().addAll(filterTextField);
  layout.setPadding(new Insets(0,0,3,0));
  setupPanelDragEvents(layout);
  return layout;
}",0.9685534591194968
135267,"public void setDefaultWidth(){
  mainStage.setMaximized(false);
  mainStage.setIconified(false);
  Rectangle dimensions=getDimensions();
  mainStage.setMinWidth(panels.getPanelWidth());
  mainStage.setMinHeight(dimensions.getHeight());
  mainStage.setMaxWidth(panels.getPanelWidth());
  mainStage.setMaxHeight(dimensions.getHeight());
  mainStage.setX(0);
  mainStage.setY(0);
}","public void setDefaultWidth(){
  mainStage.setMaximized(false);
  mainStage.setIconified(false);
  Rectangle dimensions=getDimensions();
  mainStage.setWidth(panels.getPanelWidth());
  mainStage.setHeight(dimensions.getHeight());
  mainStage.setX(0);
  mainStage.setY(0);
}",0.8387096774193549
135268,"public void maximizeWindow(){
  mainStage.setMaximized(true);
  Rectangle dimensions=getDimensions();
  mainStage.setMinWidth(dimensions.getWidth());
  mainStage.setMinHeight(dimensions.getHeight());
  mainStage.setMaxWidth(dimensions.getWidth());
  mainStage.setMaxHeight(dimensions.getHeight());
  mainStage.setX(0);
  mainStage.setY(0);
}","public void maximizeWindow(){
  mainStage.setMaximized(true);
  Rectangle dimensions=getDimensions();
  mainStage.setWidth(dimensions.getWidth());
  mainStage.setHeight(dimensions.getHeight());
  mainStage.setX(0);
  mainStage.setY(0);
}",0.8200692041522492
135269,"@Test public void keyboardShortcutsTest(){
  UI.events.registerEvent((IssueSelectedEventHandler)e -> selectedIssueId=e.id);
  UI.events.registerEvent((UIComponentFocusEventHandler)e -> uiComponentFocusEventType=e.eventType);
  UI.events.registerEvent((PanelClickedEventHandler)e -> panelIndex=e.panelIndex);
  clearSelectedIssueId();
  clearUiComponentFocusEventType();
  clearPanelIndex();
  assertEquals(false,stage.getMinWidth() > 500);
  press(MAXIMIZE_WINDOW);
  assertEquals(true,stage.getMinWidth() > 500);
  press(DEFAULT_SIZE_WINDOW);
  assertEquals(false,stage.getMinWidth() > 500);
  press(JUMP_TO_FIRST_ISSUE);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  press(JUMP_TO_FILTER_BOX);
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  press(JUMP_TO_FIRST_ISSUE);
  press(JUMP_TO_FILTER_BOX);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(1));
  PlatformEx.waitOnFxThread();
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  press(JUMP_TO_FILTER_BOX);
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(2));
  PlatformEx.waitOnFxThread();
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(3));
  PlatformEx.waitOnFxThread();
  assertEquals(8,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(4));
  PlatformEx.waitOnFxThread();
  assertEquals(7,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(5));
  PlatformEx.waitOnFxThread();
  assertEquals(6,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(6));
  PlatformEx.waitOnFxThread();
  assertEquals(5,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(7));
  PlatformEx.waitOnFxThread();
  assertEquals(4,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(8));
  PlatformEx.waitOnFxThread();
  assertEquals(3,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(9));
  PlatformEx.waitOnFxThread();
  assertEquals(2,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.END);
  assertEquals(1,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.HOME);
  sleep(1000);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(8,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  press(CREATE_RIGHT_PANEL);
  press(JUMP_TO_FIRST_ISSUE);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,panelIndex);
  clearPanelIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,panelIndex);
  clearPanelIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,panelIndex);
  clearPanelIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,panelIndex);
  clearPanelIndex();
  ComboBox<String> repoSelectorComboBox=find(""String_Node_Str"");
  doubleClick(repoSelectorComboBox);
  assertEquals(true,repoSelectorComboBox.isFocused());
  press(KeyCode.ESCAPE).release(KeyCode.ESCAPE);
  assertEquals(false,repoSelectorComboBox.isFocused());
  clearUiComponentFocusEventType();
  assertEquals(1,repoSelectorComboBox.getItems().size());
  doubleClick(repoSelectorComboBox);
  doubleClick();
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  PlatformEx.waitOnFxThread();
  assertEquals(2,repoSelectorComboBox.getItems().size());
  assertEquals(repoSelectorComboBox.getValue(),""String_Node_Str"");
  doubleClick(repoSelectorComboBox);
  pushKeys(SWITCH_DEFAULT_REPO);
  waitUntilNodeAppears(""String_Node_Str"");
  assertEquals(repoSelectorComboBox.getValue(),""String_Node_Str"");
  click(""String_Node_Str"");
  press(SWITCH_DEFAULT_REPO);
  PlatformEx.waitOnFxThread();
  assertEquals(repoSelectorComboBox.getValue(),""String_Node_Str"");
  press(JUMP_TO_NTH_ISSUE_KEYS.get(1));
  press(SWITCH_DEFAULT_REPO);
  PlatformEx.waitOnFxThread();
  assertEquals(repoSelectorComboBox.getValue(),""String_Node_Str"");
  ListPanel issuePanel=find(""String_Node_Str"");
  push(KeyCode.HOME);
  int issueIdBeforeMark=selectedIssueId;
  int issueIdExpected=issueIdBeforeMark - 1;
  push(getKeyCode(""String_Node_Str""));
  PlatformEx.waitOnFxThread();
  assertEquals(issueIdExpected,selectedIssueId);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(true,issuePanel.getSelectedIssue().isPresent());
  assertEquals(true,issuePanel.getSelectedIssue().get().isCurrentlyRead());
  push(KeyCode.END);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,selectedIssueId);
  assertEquals(true,issuePanel.getSelectedIssue().isPresent());
  assertEquals(true,issuePanel.getSelectedIssue().get().isCurrentlyRead());
  push(getKeyCode(""String_Node_Str""));
  assertEquals(true,issuePanel.getSelectedIssue().isPresent());
  assertEquals(false,issuePanel.getSelectedIssue().get().isCurrentlyRead());
  clearSelectedIssueId();
  click(""String_Node_Str"");
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  press(JUMP_TO_FIRST_ISSUE);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(5,selectedIssueId);
  press(MINIMIZE_WINDOW);
  assertEquals(true,stage.isIconified());
}","@Test public void keyboardShortcutsTest(){
  UI.events.registerEvent((IssueSelectedEventHandler)e -> selectedIssueId=e.id);
  UI.events.registerEvent((UIComponentFocusEventHandler)e -> uiComponentFocusEventType=e.eventType);
  UI.events.registerEvent((PanelClickedEventHandler)e -> panelIndex=e.panelIndex);
  clearSelectedIssueId();
  clearUiComponentFocusEventType();
  clearPanelIndex();
  assertEquals(false,stage.getWidth() > 500);
  press(MAXIMIZE_WINDOW);
  assertEquals(true,stage.getWidth() > 500);
  press(DEFAULT_SIZE_WINDOW);
  assertEquals(false,stage.getWidth() > 500);
  press(JUMP_TO_FIRST_ISSUE);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  press(JUMP_TO_FILTER_BOX);
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  press(JUMP_TO_FIRST_ISSUE);
  press(JUMP_TO_FILTER_BOX);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(1));
  PlatformEx.waitOnFxThread();
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  press(JUMP_TO_FILTER_BOX);
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(2));
  PlatformEx.waitOnFxThread();
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(3));
  PlatformEx.waitOnFxThread();
  assertEquals(8,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(4));
  PlatformEx.waitOnFxThread();
  assertEquals(7,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(5));
  PlatformEx.waitOnFxThread();
  assertEquals(6,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(6));
  PlatformEx.waitOnFxThread();
  assertEquals(5,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(7));
  PlatformEx.waitOnFxThread();
  assertEquals(4,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(8));
  PlatformEx.waitOnFxThread();
  assertEquals(3,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(JUMP_TO_NTH_ISSUE_KEYS.get(9));
  PlatformEx.waitOnFxThread();
  assertEquals(2,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.END);
  assertEquals(1,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.HOME);
  sleep(1000);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(8,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  press(CREATE_RIGHT_PANEL);
  press(JUMP_TO_FIRST_ISSUE);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,panelIndex);
  clearPanelIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,panelIndex);
  clearPanelIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,panelIndex);
  clearPanelIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,panelIndex);
  clearPanelIndex();
  ComboBox<String> repoSelectorComboBox=find(""String_Node_Str"");
  doubleClick(repoSelectorComboBox);
  assertEquals(true,repoSelectorComboBox.isFocused());
  press(KeyCode.ESCAPE).release(KeyCode.ESCAPE);
  assertEquals(false,repoSelectorComboBox.isFocused());
  clearUiComponentFocusEventType();
  assertEquals(1,repoSelectorComboBox.getItems().size());
  doubleClick(repoSelectorComboBox);
  doubleClick();
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  PlatformEx.waitOnFxThread();
  assertEquals(2,repoSelectorComboBox.getItems().size());
  assertEquals(repoSelectorComboBox.getValue(),""String_Node_Str"");
  doubleClick(repoSelectorComboBox);
  pushKeys(SWITCH_DEFAULT_REPO);
  waitUntilNodeAppears(""String_Node_Str"");
  assertEquals(repoSelectorComboBox.getValue(),""String_Node_Str"");
  click(""String_Node_Str"");
  press(SWITCH_DEFAULT_REPO);
  PlatformEx.waitOnFxThread();
  assertEquals(repoSelectorComboBox.getValue(),""String_Node_Str"");
  press(JUMP_TO_NTH_ISSUE_KEYS.get(1));
  press(SWITCH_DEFAULT_REPO);
  PlatformEx.waitOnFxThread();
  assertEquals(repoSelectorComboBox.getValue(),""String_Node_Str"");
  ListPanel issuePanel=find(""String_Node_Str"");
  push(KeyCode.HOME);
  int issueIdBeforeMark=selectedIssueId;
  int issueIdExpected=issueIdBeforeMark - 1;
  push(getKeyCode(""String_Node_Str""));
  PlatformEx.waitOnFxThread();
  assertEquals(issueIdExpected,selectedIssueId);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(true,issuePanel.getSelectedIssue().isPresent());
  assertEquals(true,issuePanel.getSelectedIssue().get().isCurrentlyRead());
  push(KeyCode.END);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,selectedIssueId);
  assertEquals(true,issuePanel.getSelectedIssue().isPresent());
  assertEquals(true,issuePanel.getSelectedIssue().get().isCurrentlyRead());
  push(getKeyCode(""String_Node_Str""));
  assertEquals(true,issuePanel.getSelectedIssue().isPresent());
  assertEquals(false,issuePanel.getSelectedIssue().get().isCurrentlyRead());
  clearSelectedIssueId();
  click(""String_Node_Str"");
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  press(JUMP_TO_FIRST_ISSUE);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(5,selectedIssueId);
  press(MINIMIZE_WINDOW);
  assertEquals(true,stage.isIconified());
}",0.999206978588422
135270,"@Test public void panelRenameTest(){
  Random rand=new Random();
  UI ui=TestController.getUI();
  PanelControl panels=ui.getPanelControl();
  pushKeys(MAXIMIZE_WINDOW);
  sleep(EVENT_DELAY);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(0)));
  sleep(EVENT_DELAY);
  type(""String_Node_Str"");
  push(KeyCode.ESCAPE);
  FilterPanel panel0=(FilterPanel)panels.getPanel(0);
  Text panelNameText0=panel0.getNameText();
  assertEquals(""String_Node_Str"",panelNameText0.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(1)));
  sleep(EVENT_DELAY);
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  FilterPanel panel1=(FilterPanel)panels.getPanel(1);
  Text panelNameText1=panel1.getNameText();
  assertEquals(""String_Node_Str"",panelNameText1.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(2)));
  sleep(EVENT_DELAY);
  push(KeyCode.BACK_SPACE);
  push(KeyCode.ENTER);
  FilterPanel panel2=(FilterPanel)panels.getPanel(2);
  Text panelNameText2=panel2.getNameText();
  assertEquals(""String_Node_Str"",panelNameText2.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(3)));
  sleep(EVENT_DELAY);
  String randomName3=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH - 1);
  PanelNameTextField renameTextField3=find(""String_Node_Str"");
  renameTextField3.setText(randomName3);
  push(KeyCode.ENTER);
  FilterPanel panel3=(FilterPanel)panels.getPanel(3);
  Text panelNameText3=panel3.getNameText();
  assertEquals(randomName3,panelNameText3.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(4)));
  sleep(EVENT_DELAY);
  String randomName4=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH);
  PanelNameTextField renameTextField4=find(""String_Node_Str"");
  renameTextField4.setText(randomName4);
  push(KeyCode.ENTER);
  FilterPanel panel4=(FilterPanel)panels.getPanel(4);
  Text panelNameText4=panel4.getNameText();
  assertEquals(randomName4,panelNameText4.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(5)));
  sleep(EVENT_DELAY);
  String randomName5=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH + 1);
  PanelNameTextField renameTextField5=find(""String_Node_Str"");
  renameTextField5.setText(randomName5);
  push(KeyCode.ENTER);
  FilterPanel panel5=(FilterPanel)panels.getPanel(5);
  Text panelNameText5=panel5.getNameText();
  assertEquals(""String_Node_Str"",panelNameText5.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(6)));
  sleep(EVENT_DELAY);
  String randomName6=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH);
  PanelNameTextField renameTextField6=find(""String_Node_Str"");
  renameTextField6.setText(randomName6);
  int randomCaret6=rand.nextInt(PANEL_MAX_NAME_LENGTH - 1);
  renameTextField6.positionCaret(randomCaret6);
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  FilterPanel panel6=(FilterPanel)panels.getPanel(6);
  Text panelNameText6=panel6.getNameText();
  assertEquals(randomName6,panelNameText6.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(7)));
  sleep(EVENT_DELAY);
  String randomName7=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH - 4);
  PanelNameTextField renameTextField7=find(""String_Node_Str"");
  renameTextField7.setText(randomName7);
  int randomCaret7=rand.nextInt(randomName7.length());
  renameTextField7.positionCaret(randomCaret7);
  String randomString=RandomStringUtils.randomAlphanumeric(5);
  type(randomString);
  push(KeyCode.ENTER);
  String expected=(randomName7.substring(0,randomCaret7) + randomString.substring(0,4) + randomName7.substring(randomCaret7,randomName7.length()));
  FilterPanel panel7=(FilterPanel)panels.getPanel(7);
  Text panelNameText7=panel7.getNameText();
  assertEquals(expected,panelNameText7.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.waitOnFxThread();
  boolean isPresentBeforeEdit=exists(""String_Node_Str"");
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(8)));
  PlatformEx.waitOnFxThread();
  boolean isPresentDuringEdit=true;
  try {
    exists(""String_Node_Str"");
  }
 catch (  NoNodesFoundException e) {
    isPresentDuringEdit=false;
  }
  String randomName8=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH - 1);
  PanelNameTextField renameTextField8=find(""String_Node_Str"");
  renameTextField8.setText(randomName8);
  push(KeyCode.ENTER);
  boolean isPresentAfterEdit=exists(""String_Node_Str"");
  Text panelNameText8=find(""String_Node_Str"");
  assertEquals(true,isPresentBeforeEdit);
  assertEquals(false,isPresentDuringEdit);
  assertEquals(true,isPresentAfterEdit);
  assertEquals(randomName8,panelNameText8.getText());
  PlatformEx.waitOnFxThread();
  click(""String_Node_Str"");
  push(KeyCode.DOWN).push(KeyCode.DOWN).push(KeyCode.ENTER);
  sleep(EVENT_DELAY);
}","@Test public void panelRenameTest(){
  Random rand=new Random();
  UI ui=TestController.getUI();
  PanelControl panels=ui.getPanelControl();
  pushKeys(MAXIMIZE_WINDOW);
  sleep(EVENT_DELAY);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(0)));
  sleep(EVENT_DELAY);
  type(""String_Node_Str"");
  push(KeyCode.ESCAPE);
  FilterPanel panel0=(FilterPanel)panels.getPanel(0);
  Text panelNameText0=panel0.getNameText();
  assertEquals(""String_Node_Str"",panelNameText0.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(1)));
  sleep(EVENT_DELAY);
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  FilterPanel panel1=(FilterPanel)panels.getPanel(1);
  Text panelNameText1=panel1.getNameText();
  assertEquals(""String_Node_Str"",panelNameText1.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(2)));
  sleep(EVENT_DELAY);
  push(KeyCode.BACK_SPACE);
  push(KeyCode.ENTER);
  FilterPanel panel2=(FilterPanel)panels.getPanel(2);
  Text panelNameText2=panel2.getNameText();
  assertEquals(""String_Node_Str"",panelNameText2.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(3)));
  sleep(EVENT_DELAY);
  String randomName3=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH - 1);
  PanelNameTextField renameTextField3=find(""String_Node_Str"");
  renameTextField3.setText(randomName3);
  push(KeyCode.ENTER);
  FilterPanel panel3=(FilterPanel)panels.getPanel(3);
  Text panelNameText3=panel3.getNameText();
  assertEquals(randomName3,panelNameText3.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(4)));
  sleep(EVENT_DELAY);
  String randomName4=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH);
  PanelNameTextField renameTextField4=find(""String_Node_Str"");
  renameTextField4.setText(randomName4);
  push(KeyCode.ENTER);
  FilterPanel panel4=(FilterPanel)panels.getPanel(4);
  Text panelNameText4=panel4.getNameText();
  assertEquals(randomName4,panelNameText4.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(5)));
  sleep(EVENT_DELAY);
  String randomName5=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH + 1);
  PanelNameTextField renameTextField5=find(""String_Node_Str"");
  renameTextField5.setText(randomName5);
  push(KeyCode.ENTER);
  FilterPanel panel5=(FilterPanel)panels.getPanel(5);
  Text panelNameText5=panel5.getNameText();
  assertEquals(""String_Node_Str"",panelNameText5.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(6)));
  sleep(EVENT_DELAY);
  String randomName6=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH);
  PanelNameTextField renameTextField6=find(""String_Node_Str"");
  renameTextField6.setText(randomName6);
  int randomCaret6=rand.nextInt(PANEL_MAX_NAME_LENGTH - 1);
  renameTextField6.positionCaret(randomCaret6);
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  FilterPanel panel6=(FilterPanel)panels.getPanel(6);
  Text panelNameText6=panel6.getNameText();
  assertEquals(randomName6,panelNameText6.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(7)));
  sleep(EVENT_DELAY);
  String randomName7=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH - 4);
  PanelNameTextField renameTextField7=find(""String_Node_Str"");
  renameTextField7.setText(randomName7);
  int randomCaret7=rand.nextInt(randomName7.length());
  renameTextField7.positionCaret(randomCaret7);
  String randomString=RandomStringUtils.randomAlphanumeric(5);
  type(randomString);
  push(KeyCode.ENTER);
  String expected=(randomName7.substring(0,randomCaret7) + randomString.substring(0,4) + randomName7.substring(randomCaret7,randomName7.length()));
  FilterPanel panel7=(FilterPanel)panels.getPanel(7);
  Text panelNameText7=panel7.getNameText();
  assertEquals(expected,panelNameText7.getText());
  sleep(EVENT_DELAY);
  pushKeys(CREATE_RIGHT_PANEL);
  waitUntilNodeAppears(""String_Node_Str"");
  boolean isPresentBeforeEdit=exists(""String_Node_Str"");
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(8)));
  PlatformEx.waitOnFxThread();
  boolean isPresentDuringEdit=true;
  try {
    exists(""String_Node_Str"");
  }
 catch (  NoNodesFoundException e) {
    isPresentDuringEdit=false;
  }
  String randomName8=RandomStringUtils.randomAlphanumeric(PANEL_MAX_NAME_LENGTH - 1);
  PanelNameTextField renameTextField8=find(""String_Node_Str"");
  renameTextField8.setText(randomName8);
  push(KeyCode.ENTER);
  boolean isPresentAfterEdit=exists(""String_Node_Str"");
  Text panelNameText8=find(""String_Node_Str"");
  assertEquals(true,isPresentBeforeEdit);
  assertEquals(false,isPresentDuringEdit);
  assertEquals(true,isPresentAfterEdit);
  assertEquals(randomName8,panelNameText8.getText());
  PlatformEx.waitOnFxThread();
  click(""String_Node_Str"");
  push(KeyCode.DOWN).push(KeyCode.DOWN).push(KeyCode.ENTER);
  sleep(EVENT_DELAY);
}",0.9948032665181886
135271,"/** 
 * Retrieves the requested items from GitHub
 * @param repoId the repository to get the items from
 * @return a list of requested items
 */
public ArrayList<T> getUpdatedItems(IRepositoryIdProvider repoId){
  if (updatedItems != null) {
    return updatedItems;
  }
  ArrayList<T> result=new ArrayList<>();
  String resourceDesc=repoId.generateId() + apiSuffix;
  logger.info(String.format(""String_Node_Str"",resourceDesc,lastETags));
  try {
    PagedRequest<T> request=createUpdatedRequest(repoId);
    Optional<ImmutablePair<List<String>,HttpURLConnection>> etags=getPagedEtags(request,client);
    if (!etags.isPresent()) {
      logger.warn(String.format(""String_Node_Str"",getClass().getSimpleName()));
    }
 else {
      updatedETags=combineETags(etags.get().getLeft());
      if (!updatedETags.isPresent() || updatedETags.get().equals(lastETags)) {
        logger.info(""String_Node_Str"");
      }
 else {
        result=new ArrayList<>(getPagedItems(resourceDesc,new PageIterator<>(request,client)));
        logger.info(String.format(""String_Node_Str"",resourceDesc,updatedETags));
      }
      updateCheckTime(etags.get().getRight());
    }
  }
 catch (  IOException e) {
    logger.error(e.getLocalizedMessage(),e);
    return result;
  }
  updatedItems=result;
  return result;
}","/** 
 * Retrieves the requested items from GitHub
 * @param repoId the repository to get the items from
 * @return a list of requested items
 */
public ArrayList<T> getUpdatedItems(IRepositoryIdProvider repoId){
  if (updatedItems != null) {
    return updatedItems;
  }
  ArrayList<T> result=new ArrayList<>();
  String resourceDesc=repoId.generateId() + apiSuffix;
  logger.info(String.format(""String_Node_Str"",resourceDesc,lastETags));
  try {
    PagedRequest<T> headerRequest=createUpdatedRequest(repoId);
    Optional<ImmutablePair<List<String>,HttpURLConnection>> etags=getPagedEtags(headerRequest,client);
    if (!etags.isPresent()) {
      logger.warn(String.format(""String_Node_Str"",getClass().getSimpleName()));
    }
 else {
      Optional<String> updatedETags=combineETags(etags.get().getLeft());
      result=downloadUpdatedItems(repoId,resourceDesc,updatedETags);
      updateCheckTime(etags.get().getRight());
    }
  }
 catch (  IOException e) {
    logger.error(e.getLocalizedMessage(),e);
    return result;
  }
  updatedItems=result;
  return result;
}",0.8378378378378378
135272,"@Test(expected=IOException.class) public void testInvalidRepositoryInGetReviewComments() throws IOException {
  PullRequestServiceEx service=new PullRequestServiceEx();
  service.getReviewComments(RepositoryId.createFromId(""String_Node_Str""),1);
}","@Test(expected=IOException.class) public void testInvalidRepositoryInGetReviewComments() throws IOException {
  GitHubClientEx client=new GitHubClientEx();
  PullRequestServiceEx service=new PullRequestServiceEx(client);
  service.getReviewComments(RepositoryId.createFromId(""String_Node_Str""),1);
}",0.9047619047619048
135273,"@Test(expected=IllegalArgumentException.class) public void testInvalidArgumentsToGetReviewComments3() throws IOException {
  PullRequestServiceEx service=new PullRequestServiceEx();
  service.getReviewComments(RepositoryId.createFromId(""String_Node_Str""),""String_Node_Str"");
}","@Test(expected=IllegalArgumentException.class) public void testInvalidArgumentsToGetReviewComments3() throws IOException {
  GitHubClientEx client=new GitHubClientEx();
  PullRequestServiceEx service=new PullRequestServiceEx(client);
  service.getReviewComments(RepositoryId.createFromId(""String_Node_Str""),""String_Node_Str"");
}",0.913907284768212
135274,"@Test(expected=IllegalArgumentException.class) public void testInvalidArgumentsToGetReviewComments2() throws IOException {
  PullRequestServiceEx service=new PullRequestServiceEx();
  service.getReviewComments(RepositoryId.createFromId(""String_Node_Str""),null);
}","@Test(expected=IllegalArgumentException.class) public void testInvalidArgumentsToGetReviewComments2() throws IOException {
  GitHubClientEx client=new GitHubClientEx();
  PullRequestServiceEx service=new PullRequestServiceEx(client);
  service.getReviewComments(RepositoryId.createFromId(""String_Node_Str""),null);
}",0.9100346020761244
135275,"@Test(expected=IllegalArgumentException.class) public void testInvalidArgumentsToGetReviewComments1() throws IOException {
  PullRequestServiceEx service=new PullRequestServiceEx();
  service.getReviewComments(null,12);
}","@Test(expected=IllegalArgumentException.class) public void testInvalidArgumentsToGetReviewComments1() throws IOException {
  GitHubClientEx client=new GitHubClientEx();
  PullRequestServiceEx service=new PullRequestServiceEx(client);
  service.getReviewComments(null,12);
}",0.8947368421052632
135276,"@Test public void globalConfigTest(){
  TextField repoOwnerField=find(""String_Node_Str"");
  doubleClick(repoOwnerField);
  doubleClick(repoOwnerField);
  type(""String_Node_Str"").push(KeyCode.TAB);
  type(""String_Node_Str"").push(KeyCode.TAB);
  type(""String_Node_Str"").push(KeyCode.TAB);
  type(""String_Node_Str"");
  click(""String_Node_Str"");
  ComboBox<String> repositorySelector=findOrWaitFor(""String_Node_Str"");
  waitForValue(repositorySelector);
  assertEquals(""String_Node_Str"",repositorySelector.getValue());
  press(KeyCode.CONTROL).press(KeyCode.X).release(KeyCode.X).release(KeyCode.CONTROL);
  click(""String_Node_Str"");
  click(""String_Node_Str"");
  ((TextField)find(""String_Node_Str"")).setText(""String_Node_Str"");
  click(""String_Node_Str"");
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(0)));
  type(""String_Node_Str"");
  PanelNameTextField renameTextField1=find(""String_Node_Str"");
  assertEquals(""String_Node_Str"",renameTextField1.getText());
  push(KeyCode.ENTER);
  press(KeyCode.CONTROL).press(KeyCode.P).release(KeyCode.P).release(KeyCode.CONTROL);
  waitUntilNodeAppears(""String_Node_Str"");
  click(""String_Node_Str"");
  type(""String_Node_Str"");
  press(KeyCode.SHIFT).press(KeyCode.SEMICOLON).release(KeyCode.SEMICOLON).release(KeyCode.SHIFT);
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  click(""String_Node_Str"");
  type(""String_Node_Str"");
  PanelNameTextField renameTextField2=find(""String_Node_Str"");
  assertEquals(""String_Node_Str"",renameTextField2.getText());
  push(KeyCode.ENTER);
  press(KeyCode.SHIFT).press(KeyCode.CONTROL).press(KeyCode.P);
  release(KeyCode.P).release(KeyCode.CONTROL).release(KeyCode.SHIFT);
  FilterTextField filterTextField3=find(""String_Node_Str"");
  click(filterTextField3);
  type(""String_Node_Str"");
  press(KeyCode.SHIFT).press(KeyCode.SEMICOLON).release(KeyCode.SEMICOLON).release(KeyCode.SHIFT);
  type(""String_Node_Str"");
  assertEquals(""String_Node_Str"",filterTextField3.getText());
  push(KeyCode.ENTER);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(0)));
  type(""String_Node_Str"");
  PanelNameTextField renameTextField3=find(""String_Node_Str"");
  assertEquals(""String_Node_Str"",renameTextField3.getText());
  push(KeyCode.ENTER);
  click(""String_Node_Str"");
  click(""String_Node_Str"");
  ((TextField)find(""String_Node_Str"")).setText(""String_Node_Str"");
  click(""String_Node_Str"");
  click(""String_Node_Str"");
  click(""String_Node_Str"");
  File testConfig=new File(Preferences.DIRECTORY,Preferences.TEST_CONFIG_FILE);
  if (!(testConfig.exists() && testConfig.isFile()))   fail();
  Preferences testPref=new Preferences(true);
  assertEquals(""String_Node_Str"",testPref.getLastLoginUsername());
  assertEquals(""String_Node_Str"",testPref.getLastLoginPassword());
  RepositoryId lastViewedRepository=testPref.getLastViewedRepository().get();
  assertEquals(""String_Node_Str"",lastViewedRepository.generateId());
  Map<String,List<PanelInfo>> boards=testPref.getAllBoards();
  List<PanelInfo> emptyBoard=boards.get(""String_Node_Str"");
  assertEquals(1,emptyBoard.size());
  assertEquals(""String_Node_Str"",emptyBoard.get(0).getPanelFilter());
  assertEquals(""String_Node_Str"",emptyBoard.get(0).getPanelName());
  List<PanelInfo> dummyBoard=boards.get(""String_Node_Str"");
  assertEquals(3,dummyBoard.size());
  assertEquals(""String_Node_Str"",dummyBoard.get(0).getPanelFilter());
  assertEquals(""String_Node_Str"",dummyBoard.get(1).getPanelFilter());
  assertEquals(""String_Node_Str"",dummyBoard.get(2).getPanelFilter());
  assertEquals(""String_Node_Str"",dummyBoard.get(0).getPanelName());
  assertEquals(""String_Node_Str"",dummyBoard.get(1).getPanelName());
  assertEquals(""String_Node_Str"",dummyBoard.get(2).getPanelName());
  List<String> lastOpenFilters=testPref.getLastOpenFilters();
  List<String> lastOpenPanelNames=testPref.getPanelNames();
  assertEquals(""String_Node_Str"",lastOpenFilters.get(0));
  assertEquals(""String_Node_Str"",lastOpenFilters.get(1));
  assertEquals(""String_Node_Str"",lastOpenFilters.get(2));
  assertEquals(""String_Node_Str"",lastOpenPanelNames.get(0));
  assertEquals(""String_Node_Str"",lastOpenPanelNames.get(1));
  assertEquals(""String_Node_Str"",lastOpenPanelNames.get(2));
}","@Test public void globalConfigTest(){
  TextField repoOwnerField=find(""String_Node_Str"");
  doubleClick(repoOwnerField);
  doubleClick(repoOwnerField);
  type(""String_Node_Str"");
  pushKeys(KeyCode.TAB);
  type(""String_Node_Str"");
  pushKeys(KeyCode.TAB);
  type(""String_Node_Str"");
  pushKeys(KeyCode.TAB);
  type(""String_Node_Str"");
  click(""String_Node_Str"");
  ComboBox<String> repositorySelector=findOrWaitFor(""String_Node_Str"");
  waitForValue(repositorySelector);
  assertEquals(""String_Node_Str"",repositorySelector.getValue());
  pushKeys(KeyboardShortcuts.MAXIMIZE_WINDOW);
  click(""String_Node_Str"");
  click(""String_Node_Str"");
  ((TextField)find(""String_Node_Str"")).setText(""String_Node_Str"");
  click(""String_Node_Str"");
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(0)));
  type(""String_Node_Str"");
  PanelNameTextField renameTextField1=find(""String_Node_Str"");
  assertEquals(""String_Node_Str"",renameTextField1.getText());
  pushKeys(KeyCode.ENTER);
  pushKeys(KeyboardShortcuts.CREATE_RIGHT_PANEL);
  waitUntilNodeAppears(""String_Node_Str"");
  click(""String_Node_Str"");
  type(""String_Node_Str"");
  pushKeys(KeyCode.SHIFT,KeyCode.SEMICOLON);
  type(""String_Node_Str"");
  pushKeys(KeyCode.ENTER);
  click(""String_Node_Str"");
  type(""String_Node_Str"");
  PanelNameTextField renameTextField2=find(""String_Node_Str"");
  assertEquals(""String_Node_Str"",renameTextField2.getText());
  pushKeys(KeyCode.ENTER);
  pushKeys(KeyboardShortcuts.CREATE_LEFT_PANEL);
  FilterTextField filterTextField3=find(""String_Node_Str"");
  click(filterTextField3);
  type(""String_Node_Str"");
  pushKeys(KeyCode.SHIFT,KeyCode.SEMICOLON);
  type(""String_Node_Str"");
  assertEquals(""String_Node_Str"",filterTextField3.getText());
  pushKeys(KeyCode.ENTER);
  PlatformEx.runAndWait(() -> UI.events.triggerEvent(new ShowRenamePanelEvent(0)));
  type(""String_Node_Str"");
  PanelNameTextField renameTextField3=find(""String_Node_Str"");
  assertEquals(""String_Node_Str"",renameTextField3.getText());
  pushKeys(KeyCode.ENTER);
  click(""String_Node_Str"");
  click(""String_Node_Str"");
  ((TextField)find(""String_Node_Str"")).setText(""String_Node_Str"");
  click(""String_Node_Str"");
  click(""String_Node_Str"");
  click(""String_Node_Str"");
  File testConfig=new File(Preferences.DIRECTORY,Preferences.TEST_CONFIG_FILE);
  if (!(testConfig.exists() && testConfig.isFile()))   fail();
  Preferences testPref=new Preferences(true);
  assertEquals(""String_Node_Str"",testPref.getLastLoginUsername());
  assertEquals(""String_Node_Str"",testPref.getLastLoginPassword());
  RepositoryId lastViewedRepository=testPref.getLastViewedRepository().get();
  assertEquals(""String_Node_Str"",lastViewedRepository.generateId());
  Map<String,List<PanelInfo>> boards=testPref.getAllBoards();
  List<PanelInfo> emptyBoard=boards.get(""String_Node_Str"");
  assertEquals(1,emptyBoard.size());
  assertEquals(""String_Node_Str"",emptyBoard.get(0).getPanelFilter());
  assertEquals(""String_Node_Str"",emptyBoard.get(0).getPanelName());
  List<PanelInfo> dummyBoard=boards.get(""String_Node_Str"");
  assertEquals(3,dummyBoard.size());
  assertEquals(""String_Node_Str"",dummyBoard.get(0).getPanelFilter());
  assertEquals(""String_Node_Str"",dummyBoard.get(1).getPanelFilter());
  assertEquals(""String_Node_Str"",dummyBoard.get(2).getPanelFilter());
  assertEquals(""String_Node_Str"",dummyBoard.get(0).getPanelName());
  assertEquals(""String_Node_Str"",dummyBoard.get(1).getPanelName());
  assertEquals(""String_Node_Str"",dummyBoard.get(2).getPanelName());
  List<String> lastOpenFilters=testPref.getLastOpenFilters();
  List<String> lastOpenPanelNames=testPref.getPanelNames();
  assertEquals(""String_Node_Str"",lastOpenFilters.get(0));
  assertEquals(""String_Node_Str"",lastOpenFilters.get(1));
  assertEquals(""String_Node_Str"",lastOpenFilters.get(2));
  assertEquals(""String_Node_Str"",lastOpenPanelNames.get(0));
  assertEquals(""String_Node_Str"",lastOpenPanelNames.get(1));
  assertEquals(""String_Node_Str"",lastOpenPanelNames.get(2));
}",0.7625986642380085
135277,"@Test public void keyboardShortcutsTest(){
}","@Test public void keyboardShortcutsTest(){
  UI.events.registerEvent((IssueSelectedEventHandler)e -> selectedIssueId=e.id);
  UI.events.registerEvent((UIComponentFocusEventHandler)e -> uiComponentFocusEventType=e.eventType);
  UI.events.registerEvent((PanelClickedEventHandler)e -> panelIndex=e.panelIndex);
  clearSelectedIssueId();
  clearUiComponentFocusEventType();
  clearPanelIndex();
  assertEquals(false,stage.getMinWidth() > 500);
  press(KeyCode.CONTROL).press(KeyCode.X).release(KeyCode.X).release(KeyCode.CONTROL);
  assertEquals(true,stage.getMinWidth() > 500);
  press(KeyCode.CONTROL).press(KeyCode.D).release(KeyCode.D).release(KeyCode.CONTROL);
  assertEquals(false,stage.getMinWidth() > 500);
  press(KeyCode.CONTROL).press(KeyCode.DOWN).release(KeyCode.DOWN).release(KeyCode.CONTROL);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  press(KeyCode.CONTROL).press(KeyCode.UP).release(KeyCode.UP).release(KeyCode.CONTROL);
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  push(DOUBLE_PRESS.getCode()).push(DOUBLE_PRESS.getCode());
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(DOUBLE_PRESS.getCode()).push(DOUBLE_PRESS.getCode());
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  push(KeyCode.ESCAPE);
  press(KeyCode.CONTROL).press(KeyCode.DIGIT1).release(KeyCode.DIGIT1).release(KeyCode.CONTROL);
  PlatformEx.waitOnFxThread();
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(DOUBLE_PRESS.getCode()).push(DOUBLE_PRESS.getCode());
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  push(KeyCode.ESCAPE);
  press(KeyCode.CONTROL).press(KeyCode.DIGIT2).release(KeyCode.CONTROL).release(KeyCode.DIGIT2);
  PlatformEx.waitOnFxThread();
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(KeyCode.CONTROL).press(KeyCode.DIGIT3).release(KeyCode.CONTROL).release(KeyCode.DIGIT3);
  PlatformEx.waitOnFxThread();
  assertEquals(8,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(KeyCode.CONTROL).press(KeyCode.DIGIT4).release(KeyCode.CONTROL).release(KeyCode.DIGIT4);
  PlatformEx.waitOnFxThread();
  assertEquals(7,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(KeyCode.CONTROL).press(KeyCode.DIGIT5).release(KeyCode.CONTROL).release(KeyCode.DIGIT5);
  PlatformEx.waitOnFxThread();
  assertEquals(6,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(KeyCode.CONTROL).press(KeyCode.DIGIT6).release(KeyCode.CONTROL).release(KeyCode.DIGIT6);
  PlatformEx.waitOnFxThread();
  assertEquals(5,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(KeyCode.CONTROL).press(KeyCode.DIGIT7).release(KeyCode.CONTROL).release(KeyCode.DIGIT7);
  PlatformEx.waitOnFxThread();
  assertEquals(4,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(KeyCode.CONTROL).press(KeyCode.DIGIT8).release(KeyCode.CONTROL).release(KeyCode.DIGIT8);
  PlatformEx.waitOnFxThread();
  assertEquals(3,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.ESCAPE);
  press(KeyCode.CONTROL).press(KeyCode.DIGIT9).release(KeyCode.CONTROL).release(KeyCode.DIGIT9);
  PlatformEx.waitOnFxThread();
  assertEquals(2,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.END);
  assertEquals(1,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.HOME);
  sleep(1000);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(8,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  press(KeyCode.CONTROL).press(KeyCode.P).release(KeyCode.P).release(KeyCode.CONTROL);
  push(DOUBLE_PRESS.getCode()).push(DOUBLE_PRESS.getCode());
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,panelIndex);
  clearPanelIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,panelIndex);
  clearPanelIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,panelIndex);
  clearPanelIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,panelIndex);
  clearPanelIndex();
  ComboBox<String> comboBox=find(""String_Node_Str"");
  doubleClick(comboBox);
  assertEquals(true,comboBox.isFocused());
  press(KeyCode.ESCAPE).release(KeyCode.ESCAPE);
  assertEquals(false,comboBox.isFocused());
  clearUiComponentFocusEventType();
  click(""String_Node_Str"");
  ListPanel issuePanel=find(""String_Node_Str"");
  push(KeyCode.HOME);
  int issueIdBeforeMark=selectedIssueId;
  int issueIdExpected=issueIdBeforeMark - 1;
  push(getKeyCode(""String_Node_Str""));
  assertEquals(issueIdExpected,selectedIssueId);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(true,issuePanel.getSelectedIssue().isCurrentlyRead());
  push(KeyCode.END);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,selectedIssueId);
  assertEquals(true,issuePanel.getSelectedIssue().isCurrentlyRead());
  push(getKeyCode(""String_Node_Str""));
  assertEquals(false,issuePanel.getSelectedIssue().isCurrentlyRead());
  clearSelectedIssueId();
  click(""String_Node_Str"");
  type(""String_Node_Str"");
  press(KeyCode.SHIFT).press(KeyCode.SEMICOLON).release(KeyCode.SEMICOLON).release(KeyCode.SHIFT);
  type(""String_Node_Str"");
  push(KeyCode.ENTER);
  push(KeyCode.SPACE).push(KeyCode.SPACE);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(5,selectedIssueId);
  press(KeyCode.CONTROL).press(KeyCode.N).release(KeyCode.N).release(KeyCode.CONTROL);
  assertEquals(true,stage.isIconified());
}",0.0149152542372881
135278,"private static Map<Integer,KeyCodeCombination> populateJumpToNthIssueMap(){
  Map<Integer,KeyCodeCombination> result=Collections.unmodifiableMap(new HashMap<>());
  result.put(1,new KeyCodeCombination(KeyCode.DIGIT1,KeyCombination.CONTROL_DOWN));
  result.put(2,new KeyCodeCombination(KeyCode.DIGIT2,KeyCombination.CONTROL_DOWN));
  result.put(3,new KeyCodeCombination(KeyCode.DIGIT3,KeyCombination.CONTROL_DOWN));
  result.put(4,new KeyCodeCombination(KeyCode.DIGIT4,KeyCombination.CONTROL_DOWN));
  result.put(5,new KeyCodeCombination(KeyCode.DIGIT5,KeyCombination.CONTROL_DOWN));
  result.put(6,new KeyCodeCombination(KeyCode.DIGIT6,KeyCombination.CONTROL_DOWN));
  result.put(7,new KeyCodeCombination(KeyCode.DIGIT7,KeyCombination.CONTROL_DOWN));
  result.put(8,new KeyCodeCombination(KeyCode.DIGIT8,KeyCombination.CONTROL_DOWN));
  result.put(9,new KeyCodeCombination(KeyCode.DIGIT9,KeyCombination.CONTROL_DOWN));
  return result;
}","private static Map<Integer,KeyCodeCombination> populateJumpToNthIssueMap(){
  Map<Integer,KeyCodeCombination> result=new HashMap<>();
  result.put(1,new KeyCodeCombination(KeyCode.DIGIT1,KeyCombination.CONTROL_DOWN));
  result.put(2,new KeyCodeCombination(KeyCode.DIGIT2,KeyCombination.CONTROL_DOWN));
  result.put(3,new KeyCodeCombination(KeyCode.DIGIT3,KeyCombination.CONTROL_DOWN));
  result.put(4,new KeyCodeCombination(KeyCode.DIGIT4,KeyCombination.CONTROL_DOWN));
  result.put(5,new KeyCodeCombination(KeyCode.DIGIT5,KeyCombination.CONTROL_DOWN));
  result.put(6,new KeyCodeCombination(KeyCode.DIGIT6,KeyCombination.CONTROL_DOWN));
  result.put(7,new KeyCodeCombination(KeyCode.DIGIT7,KeyCombination.CONTROL_DOWN));
  result.put(8,new KeyCodeCombination(KeyCode.DIGIT8,KeyCombination.CONTROL_DOWN));
  result.put(9,new KeyCodeCombination(KeyCode.DIGIT9,KeyCombination.CONTROL_DOWN));
  return Collections.unmodifiableMap(result);
}",0.9626467449306296
135279,"private void setupKeyboardShortcuts(){
  filterTextField.addEventHandler(KeyEvent.KEY_RELEASED,event -> {
    if (KeyboardShortcuts.BOX_TO_LIST.match(event)) {
      event.consume();
      listView.selectFirstItem();
    }
    if (!KeyboardShortcuts.DOUBLE_PRESS.match(event)) {
      currentFilterText=Optional.of(getCurrentFilterString());
    }
    if (KeyPress.isDoublePress(KeyboardShortcuts.DOUBLE_PRESS.getCode(),event.getCode())) {
      event.consume();
      if (currentFilterText.isPresent()) {
        filterTextField.setText(currentFilterText.get());
      }
      listView.selectFirstItem();
    }
    if (KeyboardShortcuts.MAXIMIZE_WINDOW.match(event)) {
      ui.maximizeWindow();
    }
    if (KeyboardShortcuts.MINIMIZE_WINDOW.match(event)) {
      ui.minimizeWindow();
    }
    if (KeyboardShortcuts.DEFAULT_SIZE_WINDOW.match(event)) {
      ui.setDefaultWidth();
    }
    if (KeyboardShortcuts.SWITCH_DEFAULT_REPO.match(event)) {
      ui.switchDefaultRepo();
    }
  }
);
  addEventHandler(KeyEvent.KEY_RELEASED,event -> {
    if (KeyboardShortcuts.markAsRead.match(event)) {
      markAsRead();
    }
    if (KeyboardShortcuts.markAsUnread.match(event)) {
      markAsUnread();
    }
    if (KeyboardShortcuts.SHOW_DOCS.match(event)) {
      ui.getBrowserComponent().showDocs();
    }
    if (KeyboardShortcuts.LIST_TO_BOX.match(event)) {
      setFocusToFilterBox();
    }
    if (KeyboardShortcuts.DOUBLE_PRESS.match(event) && KeyPress.isDoublePress(KeyboardShortcuts.DOUBLE_PRESS.getCode(),event.getCode())) {
      setFocusToFilterBox();
    }
    if (KeyboardShortcuts.SHOW_ISSUES.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showIssues();
      }
    }
    if (KeyboardShortcuts.SHOW_PULL_REQUESTS.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showPullRequests();
      }
    }
    if (KeyboardShortcuts.SHOW_HELP.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showDocs();
      }
    }
    if (KeyboardShortcuts.SHOW_KEYBOARD_SHORTCUTS.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showKeyboardShortcuts();
      }
    }
    if (KeyboardShortcuts.SHOW_CONTRIBUTORS.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showContributors();
        event.consume();
      }
    }
    if (KeyboardShortcuts.scrollToTop.match(event)) {
      ui.getBrowserComponent().scrollToTop();
    }
    if (KeyboardShortcuts.scrollToBottom.match(event)) {
      if (!KeyboardShortcuts.MINIMIZE_WINDOW.match(event)) {
        ui.getBrowserComponent().scrollToBottom();
      }
    }
    if (KeyboardShortcuts.scrollUp.match(event) || KeyboardShortcuts.scrollDown.match(event)) {
      ui.getBrowserComponent().scrollPage(KeyboardShortcuts.scrollDown.match(event));
    }
    if (KeyboardShortcuts.GOTO_MODIFIER.match(event)) {
      KeyPress.setLastKeyPressedCodeAndTime(event.getCode());
    }
    if (KeyboardShortcuts.NEW_COMMENT.match(event) && ui.getBrowserComponent().isCurrentUrlIssue()) {
      ui.getBrowserComponent().switchToConversationTab();
      ui.getBrowserComponent().jumpToComment();
    }
    if (KeyboardShortcuts.SHOW_LABELS.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().newLabel();
      }
 else {
        changeLabels();
      }
    }
    if (KeyboardShortcuts.MANAGE_ASSIGNEES.match(event) && ui.getBrowserComponent().isCurrentUrlIssue()) {
      ui.getBrowserComponent().switchToConversationTab();
      ui.getBrowserComponent().manageAssignees(event.getCode().toString());
    }
    if (KeyboardShortcuts.SHOW_MILESTONES.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showMilestones();
      }
 else       if (ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().switchToConversationTab();
        ui.getBrowserComponent().manageMilestones(event.getCode().toString());
      }
    }
    if (KeyboardShortcuts.MAXIMIZE_WINDOW.match(event)) {
      ui.maximizeWindow();
    }
    if (KeyboardShortcuts.MINIMIZE_WINDOW.match(event)) {
      ui.minimizeWindow();
    }
    if (KeyboardShortcuts.DEFAULT_SIZE_WINDOW.match(event)) {
      ui.setDefaultWidth();
    }
    if (KeyboardShortcuts.SWITCH_DEFAULT_REPO.match(event)) {
      ui.switchDefaultRepo();
    }
    if (KeyboardShortcuts.UNDO_LABEL_CHANGES.match(event)) {
      ui.triggerNotificationPaneAction();
    }
    for (    KeyCodeCombination key : KeyboardShortcuts.jumpToFirstIssueKeys) {
      if (key.match(event)) {
        event.consume();
        listView.selectFirstItem();
      }
    }
  }
);
}","private void setupKeyboardShortcuts(){
  filterTextField.addEventHandler(KeyEvent.KEY_RELEASED,event -> {
    if (KeyboardShortcuts.BOX_TO_LIST.match(event)) {
      event.consume();
      listView.selectFirstItem();
    }
    if (!KeyboardShortcuts.DOUBLE_PRESS.match(event)) {
      currentFilterText=Optional.of(getCurrentFilterString());
    }
    if (KeyPress.isDoublePress(KeyboardShortcuts.DOUBLE_PRESS.getCode(),event.getCode())) {
      event.consume();
      if (currentFilterText.isPresent()) {
        filterTextField.setText(currentFilterText.get());
      }
      listView.selectFirstItem();
    }
    if (KeyboardShortcuts.MAXIMIZE_WINDOW.match(event)) {
      ui.maximizeWindow();
    }
    if (KeyboardShortcuts.MINIMIZE_WINDOW.match(event)) {
      ui.minimizeWindow();
    }
    if (KeyboardShortcuts.DEFAULT_SIZE_WINDOW.match(event)) {
      ui.setDefaultWidth();
    }
    if (KeyboardShortcuts.SWITCH_DEFAULT_REPO.match(event)) {
      ui.switchDefaultRepo();
    }
  }
);
  addEventHandler(KeyEvent.KEY_RELEASED,event -> {
    if (KeyboardShortcuts.markAsRead.match(event)) {
      markAsRead();
    }
    if (KeyboardShortcuts.markAsUnread.match(event)) {
      markAsUnread();
    }
    if (KeyboardShortcuts.SHOW_DOCS.match(event)) {
      ui.getBrowserComponent().showDocs();
    }
    if (KeyboardShortcuts.LIST_TO_BOX.match(event)) {
      setFocusToFilterBox();
    }
    if (KeyboardShortcuts.DOUBLE_PRESS.match(event) && KeyPress.isDoublePress(KeyboardShortcuts.DOUBLE_PRESS.getCode(),event.getCode())) {
      setFocusToFilterBox();
    }
    if (KeyboardShortcuts.SHOW_ISSUES.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showIssues();
      }
    }
    if (KeyboardShortcuts.SHOW_PULL_REQUESTS.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showPullRequests();
      }
    }
    if (KeyboardShortcuts.SHOW_HELP.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showDocs();
      }
    }
    if (KeyboardShortcuts.SHOW_KEYBOARD_SHORTCUTS.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showKeyboardShortcuts();
      }
    }
    if (KeyboardShortcuts.SHOW_CONTRIBUTORS.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showContributors();
        event.consume();
      }
    }
    if (KeyboardShortcuts.scrollToTop.match(event)) {
      ui.getBrowserComponent().scrollToTop();
    }
    if (KeyboardShortcuts.scrollToBottom.match(event)) {
      if (!KeyboardShortcuts.MINIMIZE_WINDOW.match(event)) {
        ui.getBrowserComponent().scrollToBottom();
      }
    }
    if (KeyboardShortcuts.scrollUp.match(event) || KeyboardShortcuts.scrollDown.match(event)) {
      ui.getBrowserComponent().scrollPage(KeyboardShortcuts.scrollDown.match(event));
    }
    if (KeyboardShortcuts.GOTO_MODIFIER.match(event)) {
      KeyPress.setLastKeyPressedCodeAndTime(event.getCode());
    }
    if (KeyboardShortcuts.NEW_COMMENT.match(event) && ui.getBrowserComponent().isCurrentUrlIssue()) {
      ui.getBrowserComponent().switchToConversationTab();
      ui.getBrowserComponent().jumpToComment();
    }
    if (KeyboardShortcuts.SHOW_LABELS.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().newLabel();
      }
 else {
        changeLabels();
      }
    }
    if (KeyboardShortcuts.MANAGE_ASSIGNEES.match(event) && ui.getBrowserComponent().isCurrentUrlIssue()) {
      ui.getBrowserComponent().switchToConversationTab();
      ui.getBrowserComponent().manageAssignees(event.getCode().toString());
    }
    if (KeyboardShortcuts.SHOW_MILESTONES.match(event)) {
      if (KeyPress.isValidKeyCombination(KeyboardShortcuts.GOTO_MODIFIER.getCode(),event.getCode())) {
        ui.getBrowserComponent().showMilestones();
      }
 else       if (ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().switchToConversationTab();
        ui.getBrowserComponent().manageMilestones(event.getCode().toString());
      }
    }
    if (KeyboardShortcuts.MAXIMIZE_WINDOW.match(event)) {
      ui.maximizeWindow();
    }
    if (KeyboardShortcuts.MINIMIZE_WINDOW.match(event)) {
      ui.minimizeWindow();
    }
    if (KeyboardShortcuts.DEFAULT_SIZE_WINDOW.match(event)) {
      ui.setDefaultWidth();
    }
    if (KeyboardShortcuts.SWITCH_DEFAULT_REPO.match(event)) {
      ui.switchDefaultRepo();
    }
    if (KeyboardShortcuts.UNDO_LABEL_CHANGES.match(event)) {
      ui.triggerNotificationPaneAction();
    }
    for (    KeyCodeCombination key : KeyboardShortcuts.JUMP_TO_FIRST_ISSUE_KEYS) {
      if (key.match(event)) {
        event.consume();
        listView.selectFirstItem();
      }
    }
  }
);
}",0.9961285327138986
135280,"private boolean labelsSatisfy(IModel model,TurboIssue issue){
  if (!content.isPresent())   return false;
  TurboLabel tokens=new TurboLabel(""String_Node_Str"",content.get().toLowerCase());
  String group=""String_Node_Str"";
  if (tokens.getGroup().isPresent()) {
    group=tokens.getGroup().get();
  }
  String labelName=tokens.getName();
  for (  TurboLabel label : model.getLabelsOfIssue(issue)) {
    if (label.getGroup().isPresent()) {
      if (labelName.isEmpty()) {
        if (Utility.containsIgnoreCase(label.getGroup().get(),group)) {
          return true;
        }
      }
 else {
        if (Utility.containsIgnoreCase(label.getGroup().get(),group) && Utility.containsIgnoreCase(label.getName(),labelName)) {
          return true;
        }
      }
    }
 else {
      if (!group.isEmpty()) {
        return false;
      }
 else       if (!labelName.isEmpty() && Utility.containsIgnoreCase(label.getName(),labelName)) {
        return true;
      }
    }
  }
  return false;
}","private boolean labelsSatisfy(IModel model,TurboIssue issue){
  if (!content.isPresent())   return false;
  for (  TurboLabel label : model.getLabelsOfIssue(issue)) {
    if (labelMatches(content.get(),label.getActualName())) {
      return true;
    }
  }
  return false;
}",0.2104430379746835
135281,"@Test public void label(){
  TurboLabel label=TurboLabel.exclusive(REPO,""String_Node_Str"",""String_Node_Str"");
  TurboIssue issue=new TurboIssue(REPO,1,""String_Node_Str"");
  issue.addLabel(label);
  IModel model=TestUtils.modelWith(issue,label);
  assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  try {
    assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
  try {
    assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
  label=new TurboLabel(REPO,""String_Node_Str"");
  issue=new TurboIssue(REPO,1,""String_Node_Str"");
  issue.addLabel(label);
  model=TestUtils.modelWith(issue,label);
  assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  try {
    assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
  try {
    assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
}","@Test public void label(){
  TurboLabel label=TurboLabel.exclusive(REPO,""String_Node_Str"",""String_Node_Str"");
  TurboIssue issue=new TurboIssue(REPO,1,""String_Node_Str"");
  issue.addLabel(label);
  IModel model=TestUtils.modelWith(issue,label);
  assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  try {
    assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
  try {
    assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
  label=TurboLabel.exclusive(REPO,""String_Node_Str"",""String_Node_Str"");
  TurboLabel label2=new TurboLabel(REPO,""String_Node_Str"");
  issue=new TurboIssue(REPO,1,""String_Node_Str"");
  issue.addLabel(label2);
  issue.addLabel(label);
  model=TestUtils.singletonModel(new Model(new Model(REPO,new ArrayList<>(Arrays.asList(issue)),new ArrayList<>(Arrays.asList(label,label2)),new ArrayList<>(),new ArrayList<>())));
  assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  label=new TurboLabel(REPO,""String_Node_Str"");
  issue=new TurboIssue(REPO,1,""String_Node_Str"");
  issue.addLabel(label);
  model=TestUtils.modelWith(issue,label);
  assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
  try {
    assertEquals(true,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
  try {
    assertEquals(false,Qualifier.process(model,Parser.parse(""String_Node_Str""),issue));
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
}",0.8763933614069854
135282,"/** 
 * Called upon the Boards > Save as being clicked
 */
private void onBoardSaveAs(){
  logger.info(""String_Node_Str"");
  List<PanelInfo> panels=getCurrentPanels();
  if (panels.isEmpty()) {
    logger.info(""String_Node_Str"");
    return;
  }
  TextInputDialog dlg=new TextInputDialog(""String_Node_Str"");
  dlg.getEditor().setId(""String_Node_Str"");
  dlg.setTitle(""String_Node_Str"");
  dlg.getDialogPane().setContentText(""String_Node_Str"");
  dlg.getDialogPane().setHeaderText(""String_Node_Str"");
  Optional<String> response=dlg.showAndWait();
  if (response.isPresent()) {
    String boardName=response.get();
    prefs.addBoard(response.get(),panels);
    ui.triggerEvent(new BoardSavedEvent());
    logger.info(""String_Node_Str"" + boardName + ""String_Node_Str"");
  }
}","/** 
 * Called upon the Boards > Save as being clicked
 */
private void onBoardSaveAs(){
  logger.info(""String_Node_Str"");
  List<PanelInfo> panels=getCurrentPanels();
  if (panels.isEmpty()) {
    logger.info(""String_Node_Str"");
    return;
  }
  TextInputDialog dlg=new TextInputDialog(""String_Node_Str"");
  dlg.getEditor().setId(""String_Node_Str"");
  dlg.setTitle(""String_Node_Str"");
  dlg.getDialogPane().setContentText(""String_Node_Str"");
  dlg.getDialogPane().setHeaderText(""String_Node_Str"");
  Optional<String> response=dlg.showAndWait();
  if (response.isPresent()) {
    String boardName=response.get();
    prefs.addBoard(response.get(),panels);
    ui.triggerEvent(new BoardSavedEvent());
    openBoardName=boardName;
    logger.info(""String_Node_Str"" + boardName + ""String_Node_Str"");
  }
}",0.9816106531388712
135283,"/** 
 * Checks if this label update event in the same group as another label update event e
 * @param e another label update event
 * @return true if this event and e have same author and times withinMAX_TIME_DIFF from each other. false otherwise
 */
public boolean isInSameLabelUpdateEventGroup(TurboIssueEvent e){
  long timeDiffMs=Math.abs(getDate().getTime() - e.getDate().getTime());
  long timeDiffMin=TimeUnit.MILLISECONDS.toSeconds(timeDiffMs);
  return getActor().getLogin().equals(e.getActor().getLogin()) && timeDiffMin <= MAX_TIME_DIFF;
}","/** 
 * Checks if this label update event in the same group as another label update event e
 * @param e another label update event
 * @return true if this event and e have same author and times withinMAX_TIME_DIFF from each other. false otherwise
 */
public boolean isInSameLabelUpdateEventGroup(TurboIssueEvent e){
  long timeDiffMs=Math.abs(getDate().getTime() - e.getDate().getTime());
  long timeDiffSec=TimeUnit.MILLISECONDS.toSeconds(timeDiffMs);
  return getActor().getLogin().equals(e.getActor().getLogin()) && timeDiffSec <= MAX_TIME_DIFF;
}",0.9890909090909092
135284,"/** 
 * Given a list of issue events, returns a JavaFX node laying them out properly.
 * @param events
 * @param comments
 * @return
 */
public static Node layoutEvents(Model model,TurboIssue issue,List<TurboIssueEvent> events,List<Comment> comments){
  VBox result=new VBox();
  result.setSpacing(3);
  VBox.setMargin(result,new Insets(3,0,0,0));
  TurboIssueEvent.createLabelUpdateEventNodes(model,events.stream().filter(e -> e.isLabelUpdateEvent()).collect(Collectors.toList())).forEach(node -> result.getChildren().add(node));
  ;
  events.stream().filter(e -> !e.isLabelUpdateEvent()).map(e -> e.display(model,issue)).forEach(e -> result.getChildren().add(e));
  if (comments.size() > 0) {
    String names=comments.stream().map(comment -> comment.getUser().getLogin()).distinct().collect(Collectors.joining(""String_Node_Str""));
    HBox commentDisplay=new HBox();
    commentDisplay.getChildren().addAll(TurboIssueEvent.octicon(TurboIssueEvent.OCTICON_QUOTE),new javafx.scene.control.Label(String.format(""String_Node_Str"",comments.size(),names)));
    result.getChildren().add(commentDisplay);
  }
  return result;
}","/** 
 * Given a list of issue events, returns a JavaFX node laying them out properly.
 * @param events
 * @param comments
 * @return
 */
private static Node layoutEvents(Model model,TurboIssue issue,List<TurboIssueEvent> events,List<Comment> comments){
  VBox result=new VBox();
  result.setSpacing(3);
  VBox.setMargin(result,new Insets(3,0,0,0));
  List<TurboIssueEvent> labelUpdateEvents=events.stream().filter(e -> e.isLabelUpdateEvent()).collect(Collectors.toList());
  List<Node> labelUpdateEventNodes=TurboIssueEvent.createLabelUpdateEventNodes(model,labelUpdateEvents);
  labelUpdateEventNodes.forEach(node -> result.getChildren().add(node));
  events.stream().filter(e -> !e.isLabelUpdateEvent()).map(e -> e.display(model,issue)).forEach(e -> result.getChildren().add(e));
  if (comments.size() > 0) {
    String names=comments.stream().map(comment -> comment.getUser().getLogin()).distinct().collect(Collectors.joining(""String_Node_Str""));
    HBox commentDisplay=new HBox();
    commentDisplay.getChildren().addAll(TurboIssueEvent.octicon(TurboIssueEvent.OCTICON_QUOTE),new javafx.scene.control.Label(String.format(""String_Node_Str"",comments.size(),names)));
    result.getChildren().add(commentDisplay);
  }
  return result;
}",0.9254237288135592
135285,"@Test public void testCreateLabelUpdateEventNodesForSampleEvents(){
  List<TurboLabel> labels=new ArrayList<>();
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  Model sampleModel=new Model(""String_Node_Str"",null,labels,null,null);
  List<TurboIssueEvent> events=new ArrayList<>(new TurboIssueEventTests().sampleEvents);
  List<Node> nodes=TurboIssueEvent.createLabelUpdateEventNodes(sampleModel,events);
  assertEquals(5,TurboIssueEvent.createLabelUpdateEventNodes(sampleModel,events).size());
  assertEquals(5,((HBox)nodes.get(0)).getChildren().size());
  assertEquals(5,((HBox)nodes.get(1)).getChildren().size());
  assertEquals(4,((HBox)nodes.get(2)).getChildren().size());
  assertEquals(4,((HBox)nodes.get(3)).getChildren().size());
  assertEquals(4,((HBox)nodes.get(4)).getChildren().size());
  assertEquals(5,((VBox)ListPanelCard.layoutEvents(sampleModel,new TurboIssue(""String_Node_Str"",1,""String_Node_Str""),events,new ArrayList<Comment>())).getChildren().size());
}","@Test public void testCreateLabelUpdateEventNodesForSampleEvents() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {
  Method layoutMethod=ListPanelCard.class.getDeclaredMethod(""String_Node_Str"",Model.class,TurboIssue.class,List.class,List.class);
  layoutMethod.setAccessible(true);
  List<TurboLabel> labels=new ArrayList<>();
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  labels.add(new TurboLabel(""String_Node_Str"",""String_Node_Str""));
  Model sampleModel=new Model(""String_Node_Str"",null,labels,null,null);
  List<TurboIssueEvent> events=new ArrayList<>(new TurboIssueEventTests().sampleEvents);
  List<Node> nodes=TurboIssueEvent.createLabelUpdateEventNodes(sampleModel,events);
  assertEquals(5,TurboIssueEvent.createLabelUpdateEventNodes(sampleModel,events).size());
  assertEquals(5,((HBox)nodes.get(0)).getChildren().size());
  assertEquals(5,((HBox)nodes.get(1)).getChildren().size());
  assertEquals(4,((HBox)nodes.get(2)).getChildren().size());
  assertEquals(4,((HBox)nodes.get(3)).getChildren().size());
  assertEquals(4,((HBox)nodes.get(4)).getChildren().size());
  assertEquals(5,((VBox)layoutMethod.invoke(null,sampleModel,new TurboIssue(""String_Node_Str"",1,""String_Node_Str""),events,new ArrayList<Comment>())).getChildren().size());
}",0.8878346323280244
135286,"/** 
 * Test the events grouping when there is only 1 event
 */
@Test public void testLabelUpdateEventsGroupingForOneEvent(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(sampleEvents.get(0));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(sampleEvents.get(0));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}","/** 
 * Tests the events grouping when there is only 1 event
 */
@Test public void testLabelUpdateEventsGroupingForOneEvent(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(sampleEvents.get(0));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(sampleEvents.get(0));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}",0.998963730569948
135287,"/** 
 * Test when A and B update the overlapping set of labels at overlapping time. The order of modification are A:+L1 -> B:-L1 -> A:+L2 -> B:+L2 Expected: [A:[+L1, +L2], B:[-L1, +L2]] Note: This scenario may not actually occur since A and B might not be recorded as adding the same label L2 by github
 */
@Test public void testLabelUpdateEventsGrouping1(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,25),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,2,11),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(0));
  expectedSubList1.add(events.get(2));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(1));
  expectedSubList2.add(events.get(3));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}","/** 
 * Tests when A and B update the overlapping set of labels at overlapping time. The order of modification are A:+L1 -> B:-L1 -> A:+L2 -> B:+L2 Expected: [A:[+L1, +L2], B:[-L1, +L2]] Note: This scenario may not actually occur since A and B might not be recorded as adding the same label L2 by github
 */
@Test public void testLabelUpdateEventsGrouping1(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,25),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,2,11),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(0));
  expectedSubList1.add(events.get(2));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(1));
  expectedSubList2.add(events.get(3));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}",0.9996514464970372
135288,"/** 
 * Test the events grouping when list of events is empty
 */
@Test public void testLabelUpdateEventsGroupingForNoEvent(){
  assertEquals(new ArrayList<TurboIssueEvent>(),TurboIssueEvent.groupLabelUpdateEvents(new ArrayList<TurboIssueEvent>()));
}","/** 
 * Tests the events grouping when list of events is empty
 */
@Test public void testLabelUpdateEventsGroupingForNoEvent(){
  assertEquals(new ArrayList<TurboIssueEvent>(),TurboIssueEvent.groupLabelUpdateEvents(new ArrayList<TurboIssueEvent>()));
}",0.9980119284294234
135289,"/** 
 * Test when A and B update at exactly the same time at overlapping time. The order of modification are (A:+L1 = B:-L1) -> (A:+L2 = B:+L2) Expected: [A:[+L1, +L2], B:[-L1, +L2]] according to lexicographic order since Collections.sort is stable
 */
@Test public void testLabelUpdateEventsGrouping2(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(1));
  expectedSubList1.add(events.get(2));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(0));
  expectedSubList2.add(events.get(3));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}","/** 
 * Tests when A and B update at exactly the same time at overlapping time. The order of modification are (A:+L1 = B:-L1) -> (A:+L2 = B:+L2) Expected: [A:[+L1, +L2], B:[-L1, +L2]] according to lexicographic order since Collections.sort is stable
 */
@Test public void testLabelUpdateEventsGrouping2(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(1));
  expectedSubList1.add(events.get(2));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(0));
  expectedSubList2.add(events.get(3));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}",0.9996375498368976
135290,"/** 
 * Test when A modify same set of labels multiple times A: +L1, +L1, -L1, +L2, +L3, -L2, +L2 Expected: [[+L1, +L1, -L1, +L2, +L3, -L2, +L2]] since all events are reflected and groupLabelUpdateEvents does not attempt to repetitive labels
 */
@Test public void testLabelUpdateEventsGrouping3(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,5),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,10),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,25),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,35),""String_Node_Str""));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(events);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}","/** 
 * Tests when A modify same set of labels multiple times A: +L1, +L1, -L1, +L2, +L3, -L2, +L2 Expected: [[+L1, +L1, -L1, +L2, +L3, -L2, +L2]] since all events are reflected and groupLabelUpdateEvents does not attempt to repetitive labels
 */
@Test public void testLabelUpdateEventsGrouping3(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,5),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,10),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,25),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,35),""String_Node_Str""));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(events);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}",0.9996588195155236
135291,"/** 
 * Test when A modify a set of labels but are separated into 3 groups due to time stamp's difference A: +L1, +L1, -L1, +L2, +L3, -L2, +L2 Expected: [[+L1, +L1, -L1, +L2], [+L3, -L2], [+L2]]
 */
@Test public void testLabelUpdateEventsGrouping4(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,5),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,10),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,2,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,2,45),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,5,35),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(0));
  expectedSubList1.add(events.get(1));
  expectedSubList1.add(events.get(2));
  expectedSubList1.add(events.get(3));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(4));
  expectedSubList2.add(events.get(5));
  List<TurboIssueEvent> expectedSubList3=new ArrayList<>();
  expectedSubList3.add(events.get(6));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  expected.add(expectedSubList3);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}","/** 
 * Tests when A modify a set of labels but are separated into 3 groups due to time stamp's difference A: +L1, +L1, -L1, +L2, +L3, -L2, +L2 Expected: [[+L1, +L1, -L1, +L2], [+L3, -L2], [+L2]]
 */
@Test public void testLabelUpdateEventsGrouping4(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,5),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,10),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,2,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,2,45),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,5,35),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(0));
  expectedSubList1.add(events.get(1));
  expectedSubList1.add(events.get(2));
  expectedSubList1.add(events.get(3));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(4));
  expectedSubList2.add(events.get(5));
  List<TurboIssueEvent> expectedSubList3=new ArrayList<>();
  expectedSubList3.add(events.get(6));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  expected.add(expectedSubList3);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}",0.9997435239805078
135292,"/** 
 * Test a generic events list with several corner cases: All events are not in chronological order in the input events list A has 2 events exactly 1 minute from each other B has 3 events 2 of which are 30s part and the 3rd one is 61s apart from the 1st one B's first 2 events overlap with A's events but B's 1st event occurs first C and D have completely separate events Expected grouping: [[B1, B2], [A1, A2], [B3], [C1], [D1]]
 */
@Test public void testLabelUpdateEventsGrouping5(){
  List<TurboIssueEvent> events=new ArrayList<>(sampleEvents);
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(sampleEvents.get(2));
  expectedSubList1.add(sampleEvents.get(3));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(sampleEvents.get(0));
  expectedSubList2.add(sampleEvents.get(1));
  List<TurboIssueEvent> expectedSubList3=new ArrayList<>();
  expectedSubList3.add(sampleEvents.get(4));
  List<TurboIssueEvent> expectedSubList4=new ArrayList<>();
  expectedSubList4.add(sampleEvents.get(5));
  List<TurboIssueEvent> expectedSubList5=new ArrayList<>();
  expectedSubList5.add(sampleEvents.get(6));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  expected.add(expectedSubList3);
  expected.add(expectedSubList4);
  expected.add(expectedSubList5);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}","/** 
 * Tests a generic events list with several corner cases: All events are not in chronological order in the input events list A has 2 events exactly 1 minute from each other B has 3 events 2 of which are 30s part and the 3rd one is 61s apart from the 1st one B's first 2 events overlap with A's events but B's 1st event occurs first C and D have completely separate events Expected grouping: [[B1, B2], [A1, A2], [B3], [C1], [D1]]
 */
@Test public void testLabelUpdateEventsGrouping5(){
  List<TurboIssueEvent> events=new ArrayList<>(sampleEvents);
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(sampleEvents.get(2));
  expectedSubList1.add(sampleEvents.get(3));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(sampleEvents.get(0));
  expectedSubList2.add(sampleEvents.get(1));
  List<TurboIssueEvent> expectedSubList3=new ArrayList<>();
  expectedSubList3.add(sampleEvents.get(4));
  List<TurboIssueEvent> expectedSubList4=new ArrayList<>();
  expectedSubList4.add(sampleEvents.get(5));
  List<TurboIssueEvent> expectedSubList5=new ArrayList<>();
  expectedSubList5.add(sampleEvents.get(6));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  expected.add(expectedSubList3);
  expected.add(expectedSubList4);
  expected.add(expectedSubList5);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}",0.999659748213678
135293,"/** 
 * Test when A and B update the overlapping set of labels immediately following each other. The order of modification are A:+L1 -> A:+L2 -> B:-L1 -> B:-L2 Expected: [A:[+L1, +L2], B:[-L1, -L2]]
 */
@Test public void testLabelUpdateEventsGrouping6(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,2,0),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(0));
  expectedSubList1.add(events.get(2));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(1));
  expectedSubList2.add(events.get(3));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}","/** 
 * Tests when A and B update the overlapping set of labels immediately following each other. The order of modification are A:+L1 -> A:+L2 -> B:-L1 -> B:-L2 Expected: [A:[+L1, +L2], B:[-L1, -L2]]
 */
@Test public void testLabelUpdateEventsGrouping6(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,1,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,2,0),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(0));
  expectedSubList1.add(events.get(2));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(1));
  expectedSubList2.add(events.get(3));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}",0.9996244836650394
135294,"/** 
 * Test when A and B and C update at overlapping times but C's events appear before A and B in the input events List A's events are too far apart to be considered in the same group A1 -> C1 -> A2 -> B1 -> C2 -> B2 Expected: [[A1], [A2], [C1, C2], [B1, B2]]
 */
@Test public void testLabelUpdateEventsGrouping7(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,5,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,5,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,5,59),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,4,55),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,6,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,3,40),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(5));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(3));
  List<TurboIssueEvent> expectedSubList3=new ArrayList<>();
  expectedSubList3.add(events.get(0));
  expectedSubList3.add(events.get(2));
  List<TurboIssueEvent> expectedSubList4=new ArrayList<>();
  expectedSubList4.add(events.get(1));
  expectedSubList4.add(events.get(4));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  expected.add(expectedSubList3);
  expected.add(expectedSubList4);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}","/** 
 * Tests when A and B and C update at overlapping times but C's events appear before A and B in the input events List A's events are too far apart to be considered in the same group A1 -> C1 -> A2 -> B1 -> C2 -> B2 Expected: [[A1], [A2], [C1, C2], [B1, B2]]
 */
@Test public void testLabelUpdateEventsGrouping7(){
  List<TurboIssueEvent> events=new ArrayList<>();
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,5,0),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,5,40),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,5,59),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,4,55),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Unlabeled,new GregorianCalendar(2015,1,1,1,6,15),""String_Node_Str""));
  events.add(createLabelUpdateEvent(""String_Node_Str"",IssueEventType.Labeled,new GregorianCalendar(2015,1,1,1,3,40),""String_Node_Str""));
  List<TurboIssueEvent> expectedSubList1=new ArrayList<>();
  expectedSubList1.add(events.get(5));
  List<TurboIssueEvent> expectedSubList2=new ArrayList<>();
  expectedSubList2.add(events.get(3));
  List<TurboIssueEvent> expectedSubList3=new ArrayList<>();
  expectedSubList3.add(events.get(0));
  expectedSubList3.add(events.get(2));
  List<TurboIssueEvent> expectedSubList4=new ArrayList<>();
  expectedSubList4.add(events.get(1));
  expectedSubList4.add(events.get(4));
  List<List<TurboIssueEvent>> expected=new ArrayList<>();
  expected.add(expectedSubList1);
  expected.add(expectedSubList2);
  expected.add(expectedSubList3);
  expected.add(expectedSubList4);
  assertEquals(expected,TurboIssueEvent.groupLabelUpdateEvents(events));
}",0.9997419354838708
135295,"public static TurboIssueEvent createLabelUpdateEvent(String userName,IssueEventType eventType,GregorianCalendar time,String labelName){
  return new TurboIssueEvent(new User().setLogin(userName),eventType,time.getTime()).setLabelName(labelName);
}","private static TurboIssueEvent createLabelUpdateEvent(String userName,IssueEventType eventType,GregorianCalendar time,String labelName){
  return new TurboIssueEvent(new User().setLogin(userName),eventType,time.getTime()).setLabelName(labelName);
}",0.9777777777777776
135296,"private void showRenameTextField(){
  PanelNameTextField renameTextField=new PanelNameTextField(panelName,this);
  renameTextField.setPrefWidth(400);
  nameArea.getChildren().remove(nameText);
  nameArea.getChildren().add(renameTextField);
  renameTextField.setOnAction(renameEvent -> {
    String newName=renameTextField.getText();
    if (newName.equals(""String_Node_Str"")) {
      newName=panelName;
    }
    setPanelName(newName);
    closeRenameTextField(renameTextField);
  }
);
}","private void showRenameTextField(){
  PanelNameTextField renameTextField=new PanelNameTextField(panelName,this);
  nameArea.getChildren().remove(nameText);
  nameArea.getChildren().add(renameTextField);
  renameTextField.setOnAction(renameEvent -> {
    String newName=renameTextField.getText();
    if (newName.equals(""String_Node_Str"")) {
      newName=panelName;
    }
    setPanelName(newName);
    closeRenameTextField(renameTextField);
  }
);
}",0.96051227321238
135297,"public void closeRenameTextField(PanelNameTextField renameTextField){
  nameArea.getChildren().remove(renameTextField);
  nameArea.getChildren().add(nameText);
}","public void closeRenameTextField(PanelNameTextField renameTextField){
  nameArea.getChildren().remove(renameTextField);
  nameArea.getChildren().add(nameText);
  this.requestFocus();
}",0.9333333333333332
135298,"public void removeBoard(String name){
  boards.remove(name);
}","public void removeBoard(String name){
  savedBoards.remove(name);
}",0.9457364341085271
135299,"public List<PanelInfo> getBoardPanels(String name){
  return boards.get(name);
}","public List<PanelInfo> getBoardPanels(String name){
  return savedBoards.get(name);
}",0.9575757575757576
135300,"public Map<String,List<PanelInfo>> getAllBoards(){
  return new HashMap<>(boards);
}","public Map<String,List<PanelInfo>> getAllBoards(){
  return new HashMap<>(savedBoards);
}",0.9595375722543352
135301,"public void addBoard(String name,List<PanelInfo> panels){
  boards.put(name,panels);
}","public void addBoard(String name,List<PanelInfo> panels){
  savedBoards.put(name,panels);
}",0.96045197740113
135302,"public CompletableFuture<Boolean> getIssueMetadata(String repoId,List<Integer> issues){
  String message=""String_Node_Str"" + repoId + ""String_Node_Str"";
  logger.info(""String_Node_Str"" + issues);
  UI.status.displayMessage(message);
  String currentUser=prefs.getLastLoginUsername();
  return repoIO.getIssueMetadata(repoId,issues).thenApply(this::processNonSelfUpdate).thenApply(metadata -> {
    String updatedMessage=""String_Node_Str"" + repoId + ""String_Node_Str"";
    UI.status.displayMessage(updatedMessage);
    models.insertMetadata(repoId,metadata,currentUser);
    return metadata;
  }
).thenApply(Futures.tap(this::updateUIWithMetadata)).thenCompose(n -> getRateLimitResetTime()).thenApply(this::updateRemainingRate).thenApply(rateLimits -> true).exceptionally(withResult(false));
}","public CompletableFuture<Boolean> getIssueMetadata(String repoId,List<Integer> issues){
  String message=""String_Node_Str"" + repoId + ""String_Node_Str"";
  logger.info(""String_Node_Str"" + issues);
  UI.status.displayMessage(message);
  String currentUser=prefs.getLastLoginUsername();
  return repoIO.getIssueMetadata(repoId,issues).thenApply(this::processNonSelfUpdate).thenApply(metadata -> {
    String updatedMessage=""String_Node_Str"" + repoId + ""String_Node_Str"";
    UI.status.displayMessage(updatedMessage);
    models.insertMetadata(repoId,metadata,currentUser);
    return metadata;
  }
).thenApply(Futures.tap(this::updateUIAndShow)).thenCompose(n -> getRateLimitResetTime()).thenApply(this::updateRemainingRate).thenApply(rateLimits -> true).exceptionally(withResult(false));
}",0.987967067764408
135303,"private void populateTopPanel(){
  topPane.getChildren().clear();
  topLabels.forEach(label -> topPane.getChildren().add(label.getNode()));
  if (topPane.getChildren().size() == 0) {
    Label label=new Label(""String_Node_Str"");
    label.setPadding(new Insets(5));
    topPane.getChildren().add(label);
  }
}","private void populateTopPanel(){
  topPane.getChildren().clear();
  topLabels.forEach(label -> topPane.getChildren().add(label.getNode()));
  if (topPane.getChildren().size() == 0) {
    Label label=new Label(""String_Node_Str"");
    label.setPadding(new Insets(2,5,2,5));
    topPane.getChildren().add(label);
  }
  setHeight(vBox.getHeight() + VBOX_SPACING);
}",0.9223880597014924
135304,"private void populateBottomPane(){
  bottomPane.getChildren().clear();
  bottomLabels.forEach(label -> bottomPane.getChildren().add(label.getNode()));
  if (bottomPane.getChildren().size() == 0) {
    Label label=new Label(""String_Node_Str"");
    label.setPadding(new Insets(5));
    bottomPane.getChildren().add(label);
  }
}","private void populateBottomPane(){
  bottomPane.getChildren().clear();
  bottomLabels.forEach(label -> bottomPane.getChildren().add(label.getNode()));
  if (bottomPane.getChildren().size() == 0) {
    Label label=new Label(""String_Node_Str"");
    label.setPadding(new Insets(2,5,2,5));
    bottomPane.getChildren().add(label);
  }
  setHeight(vBox.getHeight() + VBOX_SPACING);
}",0.9261363636363636
135305,"LabelPickerDialog(TurboIssue issue,List<TurboLabel> allLabels,Stage stage){
  initOwner(stage);
  initModality(Modality.APPLICATION_MODAL);
  setTitle(""String_Node_Str"" + (issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId()+ ""String_Node_Str""+ issue.getRepoId());
  setHeaderText((issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId() + ""String_Node_Str""+ issue.getTitle());
  this.allLabels=allLabels;
  resultList=new HashMap<>();
  topLabels=new ArrayList<>();
  allLabels.forEach(label -> resultList.put(label.getActualName(),issue.getLabels().contains(label.getActualName())));
  ButtonType confirmButtonType=new ButtonType(""String_Node_Str"",ButtonBar.ButtonData.OK_DONE);
  getDialogPane().getButtonTypes().addAll(confirmButtonType,ButtonType.CANCEL);
  VBox vBox=new VBox();
  vBox.setPadding(new Insets(10));
  topPane=new FlowPane();
  topPane.setPadding(new Insets(0,0,10,0));
  topPane.setMaxWidth(LABELS_LIST_WIDTH);
  topPane.setPrefWrapLength(LABELS_LIST_WIDTH);
  topPane.setHgap(5);
  topPane.setVgap(5);
  textField=new TextField();
  textField.setPrefColumnCount(30);
  setupKeyEvents();
  bottomPane=new FlowPane();
  bottomPane.setPadding(new Insets(10,0,0,0));
  bottomPane.setMaxWidth(LABELS_LIST_WIDTH);
  bottomPane.setPrefWrapLength(LABELS_LIST_WIDTH);
  bottomPane.setHgap(5);
  bottomPane.setVgap(5);
  updateTopLabels();
  populateTopPanel();
  updateBottomLabels(""String_Node_Str"");
  populateBottomPane();
  vBox.getChildren().addAll(topPane,textField,bottomPane);
  getDialogPane().setContent(vBox);
  setResultConverter(dialogButton -> {
    if (dialogButton == confirmButtonType) {
      return resultList.entrySet().stream().filter(Map.Entry::getValue).map(Map.Entry::getKey).collect(Collectors.toList());
    }
    return null;
  }
);
  requestFocus();
}","LabelPickerDialog(TurboIssue issue,List<TurboLabel> allLabels,Stage stage){
  initOwner(stage);
  initModality(Modality.APPLICATION_MODAL);
  setTitle(""String_Node_Str"" + (issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId()+ ""String_Node_Str""+ issue.getRepoId());
  setHeaderText((issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId() + ""String_Node_Str""+ issue.getTitle());
  this.allLabels=allLabels;
  resultList=new HashMap<>();
  topLabels=new ArrayList<>();
  allLabels.forEach(label -> resultList.put(label.getActualName(),issue.getLabels().contains(label.getActualName())));
  ButtonType confirmButtonType=new ButtonType(""String_Node_Str"",ButtonBar.ButtonData.OK_DONE);
  getDialogPane().getButtonTypes().addAll(confirmButtonType,ButtonType.CANCEL);
  vBox=new VBox();
  vBox.setPadding(new Insets(10));
  vBox.setPrefHeight(1);
  topPane=new FlowPane();
  topPane.setPadding(new Insets(0,0,10,0));
  topPane.setHgap(5);
  topPane.setVgap(5);
  textField=new TextField();
  textField.setPrefColumnCount(30);
  setupKeyEvents();
  bottomPane=new FlowPane();
  bottomPane.setPadding(new Insets(10,0,0,0));
  bottomPane.setHgap(5);
  bottomPane.setVgap(5);
  updateTopLabels();
  populateTopPanel();
  updateBottomLabels(""String_Node_Str"");
  populateBottomPane();
  vBox.getChildren().addAll(topPane,textField,bottomPane);
  getDialogPane().setContent(vBox);
  setHeight(vBox.getHeight() + VBOX_SPACING);
  setResultConverter(dialogButton -> {
    if (dialogButton == confirmButtonType) {
      return resultList.entrySet().stream().filter(Map.Entry::getValue).map(Map.Entry::getKey).collect(Collectors.toList());
    }
    return null;
  }
);
  requestFocus();
}",0.926445816956766
135306,"LabelPickerDialog(TurboIssue issue,List<TurboLabel> allLabels,Stage stage){
  this.issue=issue;
  this.allLabels=allLabels;
  resultList=new HashMap<>();
  allLabels.forEach(label -> resultList.put(label.getActualName(),issue.getLabels().contains(label.getActualName())));
  initOwner(stage);
  initModality(Modality.APPLICATION_MODAL);
  setTitle(""String_Node_Str"" + (issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId()+ ""String_Node_Str""+ issue.getRepoId());
  setHeaderText((issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId() + ""String_Node_Str""+ issue.getTitle());
  ButtonType confirmButtonType=new ButtonType(""String_Node_Str"",ButtonBar.ButtonData.OK_DONE);
  getDialogPane().getButtonTypes().addAll(confirmButtonType,ButtonType.CANCEL);
  VBox vBox=new VBox();
  vBox.setPadding(new Insets(10));
  textField=new TextField();
  textField.setPrefColumnCount(30);
  setupKeyEvents();
  Label instructions=new Label(""String_Node_Str"");
  instructions.setPadding(new Insets(0,0,10,0));
  updateLabelsList(""String_Node_Str"");
  labelListView=new LabelListView(this);
  labelListView.setItems(labels);
  labelListView.setCellFactory(LabelPickerCell.forListView(LabelPicker.Label::checkedProperty,new StringConverter<LabelPicker.Label>(){
    @Override public String toString(    LabelPicker.Label object){
      return object.getName();
    }
    @Override public LabelPicker.Label fromString(    String string){
      return null;
    }
  }
));
  vBox.getChildren().addAll(instructions,textField,labelListView);
  getDialogPane().setContent(vBox);
  setResultConverter(dialogButton -> {
    if (dialogButton == confirmButtonType) {
      return allLabels.stream().filter(label -> resultList.get(label.getName())).map(TurboLabel::getActualName).collect(Collectors.toList());
    }
    return null;
  }
);
  labelListView.setFirstItem();
  requestFocus();
}","LabelPickerDialog(TurboIssue issue,List<TurboLabel> allLabels,Stage stage){
  this.issue=issue;
  this.allLabels=allLabels;
  resultList=new HashMap<>();
  allLabels.forEach(label -> resultList.put(label.getActualName(),issue.getLabels().contains(label.getActualName())));
  initOwner(stage);
  initModality(Modality.APPLICATION_MODAL);
  setTitle(""String_Node_Str"" + (issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId()+ ""String_Node_Str""+ issue.getRepoId());
  setHeaderText((issue.isPullRequest() ? ""String_Node_Str"" : ""String_Node_Str"") + issue.getId() + ""String_Node_Str""+ issue.getTitle());
  ButtonType confirmButtonType=new ButtonType(""String_Node_Str"",ButtonBar.ButtonData.OK_DONE);
  getDialogPane().getButtonTypes().addAll(confirmButtonType,ButtonType.CANCEL);
  VBox vBox=new VBox();
  vBox.setPadding(new Insets(10));
  textField=new TextField();
  textField.setPrefColumnCount(30);
  setupKeyEvents();
  Label instructions=new Label(""String_Node_Str"");
  instructions.setPadding(new Insets(0,0,10,0));
  updateLabelsList(""String_Node_Str"");
  labelListView=new LabelListView(this);
  labelListView.setItems(labels);
  labelListView.setCellFactory(LabelPickerCell.forListView(LabelPicker.Label::checkedProperty,new StringConverter<LabelPicker.Label>(){
    @Override public String toString(    LabelPicker.Label object){
      return object.getName();
    }
    @Override public LabelPicker.Label fromString(    String string){
      return null;
    }
  }
));
  vBox.getChildren().addAll(instructions,textField,labelListView);
  getDialogPane().setContent(vBox);
  setResultConverter(dialogButton -> {
    if (dialogButton == confirmButtonType) {
      return allLabels.stream().filter(label -> resultList.get(label.getActualName())).map(TurboLabel::getActualName).collect(Collectors.toList());
    }
    return null;
  }
);
  labelListView.setFirstItem();
  requestFocus();
}",0.9984326018808778
135307,"@Test public void filterTextFieldTest(){
  click(""String_Node_Str"");
  type(""String_Node_Str"");
  push(KeyCode.ESCAPE);
  type(""String_Node_Str"");
  press(KeyCode.SHIFT).press(KeyCode.SEMICOLON).release(KeyCode.SEMICOLON).release(KeyCode.SHIFT);
  press(KeyCode.SHIFT).press(KeyCode.DIGIT9).release(KeyCode.DIGIT9).release(KeyCode.SHIFT);
  push(KeyCode.LEFT);
  push(KeyCode.TAB);
  push(KeyCode.RIGHT);
  type(""String_Node_Str"");
  press(KeyCode.SHIFT).press(KeyCode.DIGIT0).release(KeyCode.DIGIT0).release(KeyCode.SHIFT);
  push(KeyCode.ENTER);
}","@Test public void filterTextFieldTest(){
  click(""String_Node_Str"");
  type(""String_Node_Str"");
  push(KeyCode.ESCAPE);
  press(KeyCode.SHIFT).press(KeyCode.DIGIT9).release(KeyCode.DIGIT9).release(KeyCode.SHIFT);
  type(""String_Node_Str"");
  press(KeyCode.SHIFT).press(KeyCode.SEMICOLON).release(KeyCode.SEMICOLON).release(KeyCode.SHIFT);
  push(KeyCode.LEFT);
  push(KeyCode.TAB);
  push(KeyCode.RIGHT);
  type(""String_Node_Str"");
  press(KeyCode.SHIFT).press(KeyCode.SEMICOLON).release(KeyCode.SEMICOLON).release(KeyCode.SHIFT);
  type(""String_Node_Str"");
  press(KeyCode.SHIFT).press(KeyCode.DIGIT0).release(KeyCode.DIGIT0).release(KeyCode.SHIFT);
  push(KeyCode.ENTER);
}",0.7450980392156863
135308,"@Test public void keyboardShortcutsTest(){
  UI.events.registerEvent((IssueSelectedEventHandler)e -> selectedIssueId=e.id);
  UI.events.registerEvent((UIComponentFocusEventHandler)e -> uiComponentFocusEventType=e.eventType);
  UI.events.registerEvent((ColumnClickedEventHandler)e -> columnIndex=e.columnIndex);
  clearSelectedIssueId();
  clearUiComponentFocusEventType();
  clearColumnIndex();
  System.out.println(""String_Node_Str"");
  press(KeyCode.CONTROL).press(KeyCode.X).release(KeyCode.X).release(KeyCode.CONTROL);
  System.out.println(""String_Node_Str"" + stage.isMaximized());
  System.out.println(""String_Node_Str"");
  press(KeyCode.CONTROL).press(KeyCode.D).release(KeyCode.D).release(KeyCode.CONTROL);
  System.out.println(""String_Node_Str"" + stage.isMaximized());
  press(KeyCode.CONTROL).press(KeyCode.DOWN).release(KeyCode.DOWN).release(KeyCode.CONTROL);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  press(KeyCode.CONTROL).press(KeyCode.UP).release(KeyCode.UP).release(KeyCode.CONTROL);
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  push(DOUBLE_PRESS).push(DOUBLE_PRESS);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(DOUBLE_PRESS).push(DOUBLE_PRESS);
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  push(DOUBLE_PRESS).push(DOUBLE_PRESS);
  push(KeyCode.END);
  assertEquals(1,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.HOME);
  sleep(1000);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(8,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  press(KeyCode.CONTROL).press(KeyCode.P).release(KeyCode.P).release(KeyCode.CONTROL);
  push(DOUBLE_PRESS).push(DOUBLE_PRESS);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,columnIndex);
  clearColumnIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,columnIndex);
  clearColumnIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,columnIndex);
  clearColumnIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,columnIndex);
  clearColumnIndex();
  click(""String_Node_Str"");
  IssuePanel issuePanel=find(""String_Node_Str"");
  push(getKeyCode(""String_Node_Str""));
  assertEquals(true,issuePanel.getSelectedIssue().isCurrentlyRead());
  push(getKeyCode(""String_Node_Str""));
  assertEquals(false,issuePanel.getSelectedIssue().isCurrentlyRead());
  System.out.println(""String_Node_Str"");
  press(KeyCode.CONTROL).press(KeyCode.N).release(KeyCode.N).release(KeyCode.CONTROL);
  System.out.println(""String_Node_Str"" + stage.isIconified());
}","@Test public void keyboardShortcutsTest(){
  UI.events.registerEvent((IssueSelectedEventHandler)e -> selectedIssueId=e.id);
  UI.events.registerEvent((UIComponentFocusEventHandler)e -> uiComponentFocusEventType=e.eventType);
  UI.events.registerEvent((ColumnClickedEventHandler)e -> columnIndex=e.columnIndex);
  clearSelectedIssueId();
  clearUiComponentFocusEventType();
  clearColumnIndex();
  assertEquals(false,stage.isMaximized());
  press(KeyCode.CONTROL).press(KeyCode.X).release(KeyCode.X).release(KeyCode.CONTROL);
  assertEquals(true,stage.isMaximized());
  System.out.println(""String_Node_Str"");
  press(KeyCode.CONTROL).press(KeyCode.D).release(KeyCode.D).release(KeyCode.CONTROL);
  System.out.println(""String_Node_Str"" + stage.isMaximized());
  press(KeyCode.CONTROL).press(KeyCode.DOWN).release(KeyCode.DOWN).release(KeyCode.CONTROL);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  press(KeyCode.CONTROL).press(KeyCode.UP).release(KeyCode.UP).release(KeyCode.CONTROL);
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  push(DOUBLE_PRESS).push(DOUBLE_PRESS);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(DOUBLE_PRESS).push(DOUBLE_PRESS);
  assertEquals(UIComponentFocusEvent.EventType.FILTER_BOX,uiComponentFocusEventType);
  clearUiComponentFocusEventType();
  push(DOUBLE_PRESS).push(DOUBLE_PRESS);
  push(KeyCode.END);
  assertEquals(1,selectedIssueId);
  clearSelectedIssueId();
  push(KeyCode.HOME);
  sleep(1000);
  assertEquals(10,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(8,selectedIssueId);
  clearSelectedIssueId();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(9,selectedIssueId);
  clearSelectedIssueId();
  press(KeyCode.CONTROL).press(KeyCode.P).release(KeyCode.P).release(KeyCode.CONTROL);
  push(DOUBLE_PRESS).push(DOUBLE_PRESS);
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,columnIndex);
  clearColumnIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,columnIndex);
  clearColumnIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(0,columnIndex);
  clearColumnIndex();
  push(getKeyCode(""String_Node_Str""));
  assertEquals(1,columnIndex);
  clearColumnIndex();
  click(""String_Node_Str"");
  IssuePanel issuePanel=find(""String_Node_Str"");
  push(getKeyCode(""String_Node_Str""));
  assertEquals(true,issuePanel.getSelectedIssue().isCurrentlyRead());
  push(getKeyCode(""String_Node_Str""));
  assertEquals(false,issuePanel.getSelectedIssue().isCurrentlyRead());
  press(KeyCode.CONTROL).press(KeyCode.N).release(KeyCode.N).release(KeyCode.CONTROL);
  assertEquals(true,stage.isIconified());
}",0.9605148721516784
135309,"public static Comparator<TurboIssue> getSortComparator(IModel model,String key,boolean inverted,boolean metadataRefresh){
  Comparator<TurboIssue> comparator=(a,b) -> 0;
  boolean isLabelGroup=false;
switch (key) {
case ""String_Node_Str"":
    comparator=(a,b) -> a.getCommentCount() - b.getCommentCount();
  break;
case ""String_Node_Str"":
comparator=(a,b) -> a.getRepoId().compareTo(b.getRepoId());
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
if (metadataRefresh) {
comparator=(a,b) -> {
if (a.getRepoId().equalsIgnoreCase(""String_Node_Str"")) {
  System.out.println(""String_Node_Str"");
  System.out.println(a.getMetadata().getNonSelfUpdatedAt().toString());
  System.out.println(b.getMetadata().getNonSelfUpdatedAt().toString());
}
return a.getMetadata().getNonSelfUpdatedAt().compareTo(b.getMetadata().getNonSelfUpdatedAt());
}
;
}
 else {
comparator=(a,b) -> a.getUpdatedAt().compareTo(b.getUpdatedAt());
}
break;
case ""String_Node_Str"":
comparator=(a,b) -> a.getId() - b.getId();
break;
default :
isLabelGroup=true;
break;
}
if (isLabelGroup) {
return getLabelGroupComparator(model,key,inverted);
}
 else {
if (!inverted) {
return comparator;
}
 else {
final Comparator<TurboIssue> finalComparator=comparator;
return (a,b) -> -finalComparator.compare(a,b);
}
}
}","public static Comparator<TurboIssue> getSortComparator(IModel model,String key,boolean inverted,boolean metadataRefresh){
  Comparator<TurboIssue> comparator=(a,b) -> 0;
  boolean isLabelGroup=false;
switch (key) {
case ""String_Node_Str"":
    comparator=(a,b) -> a.getCommentCount() - b.getCommentCount();
  break;
case ""String_Node_Str"":
comparator=(a,b) -> a.getRepoId().compareTo(b.getRepoId());
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
comparator=(a,b) -> a.getUpdatedAt().compareTo(b.getUpdatedAt());
break;
case ""String_Node_Str"":
if (metadataRefresh) {
comparator=(a,b) -> b.getMetadata().getNonSelfUpdatedAt().compareTo(a.getMetadata().getNonSelfUpdatedAt());
}
 else {
comparator=(a,b) -> b.getUpdatedAt().compareTo(a.getUpdatedAt());
}
break;
case ""String_Node_Str"":
comparator=(a,b) -> a.getId() - b.getId();
break;
default :
isLabelGroup=true;
break;
}
if (isLabelGroup) {
return getLabelGroupComparator(model,key,inverted);
}
 else {
if (!inverted) {
return comparator;
}
 else {
final Comparator<TurboIssue> finalComparator=comparator;
return (a,b) -> -finalComparator.compare(a,b);
}
}
}",0.4966555183946488
135310,"private void setupKeyboardShortcuts(){
  filterTextField.addEventHandler(KeyEvent.KEY_RELEASED,event -> {
    if (keyCombBoxToList.match(event)) {
      event.consume();
      listView.selectFirstItem();
    }
    if (event.getCode() == KeyCode.SPACE) {
      event.consume();
    }
    if (KeyPress.isDoublePress(KeyCode.SPACE,event.getCode())) {
      event.consume();
      listView.selectFirstItem();
    }
    if (maximizeWindow.match(event)) {
      ui.maximizeWindow();
    }
    if (minimizeWindow.match(event)) {
      ui.minimizeWindow();
    }
    if (defaultSizeWindow.match(event)) {
      ui.setDefaultWidth();
    }
  }
);
  addEventHandler(KeyEvent.KEY_RELEASED,event -> {
    if (event.getCode() == KeyCode.R) {
      Optional<TurboIssue> item=listView.getSelectedItem();
      if (!item.isPresent()) {
        return;
      }
      TurboIssue issue=item.get();
      LocalDateTime now=LocalDateTime.now();
      ui.prefs.setMarkedReadAt(issue.getRepoId(),issue.getId(),now);
      issue.setMarkedReadAt(Optional.of(now));
      issue.setIsCurrentlyRead(true);
      parentColumnControl.refresh();
    }
    if (event.getCode() == KeyCode.U) {
      Optional<TurboIssue> item=listView.getSelectedItem();
      if (!item.isPresent()) {
        return;
      }
      TurboIssue issue=item.get();
      ui.prefs.clearMarkedReadAt(issue.getRepoId(),issue.getId());
      issue.setMarkedReadAt(Optional.empty());
      issue.setIsCurrentlyRead(false);
      parentColumnControl.refresh();
    }
    if (event.getCode() == KeyCode.F5) {
      ui.logic.refresh();
    }
    if (event.getCode() == KeyCode.F1) {
      ui.getBrowserComponent().showDocs();
    }
    if (keyCombListToBox.match(event)) {
      setFocusToFilterBox();
    }
    if (event.getCode() == KeyCode.SPACE && KeyPress.isDoublePress(KeyCode.SPACE,event.getCode())) {
      setFocusToFilterBox();
    }
    if (event.getCode() == KeyCode.I) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showIssues();
      }
    }
    if (event.getCode() == KeyCode.P) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showPullRequests();
      }
    }
    if (event.getCode() == KeyCode.H) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showDocs();
      }
    }
    if (event.getCode() == KeyCode.K) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showKeyboardShortcuts();
      }
    }
    if (event.getCode() == KeyCode.D) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showContributors();
        event.consume();
      }
    }
    if (event.getCode() == KeyCode.U) {
      ui.getBrowserComponent().scrollToTop();
    }
    if (event.getCode() == KeyCode.N) {
      ui.getBrowserComponent().scrollToBottom();
    }
    if (event.getCode() == KeyCode.J || event.getCode() == KeyCode.K) {
      ui.getBrowserComponent().scrollPage(event.getCode() == KeyCode.K);
    }
    if (event.getCode() == KeyCode.G) {
      KeyPress.setLastKeyPressedCodeAndTime(event.getCode());
    }
    if (event.getCode() == KeyCode.C && ui.getBrowserComponent().isCurrentUrlIssue()) {
      ui.getBrowserComponent().jumpToComment();
    }
    if (event.getCode() == KeyCode.L) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().newLabel();
      }
 else       if (ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().manageLabels(event.getCode().toString());
      }
    }
    if (event.getCode() == KeyCode.A && ui.getBrowserComponent().isCurrentUrlIssue()) {
      ui.getBrowserComponent().manageAssignees(event.getCode().toString());
    }
    if (event.getCode() == KeyCode.M) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showMilestones();
      }
 else       if (ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().manageMilestones(event.getCode().toString());
      }
    }
    if (maximizeWindow.match(event)) {
      ui.maximizeWindow();
    }
    if (minimizeWindow.match(event)) {
      ui.minimizeWindow();
    }
    if (defaultSizeWindow.match(event)) {
      ui.setDefaultWidth();
    }
  }
);
}","private void setupKeyboardShortcuts(){
  filterTextField.addEventHandler(KeyEvent.KEY_RELEASED,event -> {
    if (keyCombBoxToList.match(event)) {
      event.consume();
      listView.selectFirstItem();
    }
    if (event.getCode() == KeyCode.SPACE) {
      event.consume();
    }
    if (KeyPress.isDoublePress(KeyCode.SPACE,event.getCode())) {
      event.consume();
      listView.selectFirstItem();
    }
    if (maximizeWindow.match(event)) {
      ui.maximizeWindow();
    }
    if (minimizeWindow.match(event)) {
      ui.minimizeWindow();
    }
    if (defaultSizeWindow.match(event)) {
      ui.setDefaultWidth();
    }
  }
);
  addEventHandler(KeyEvent.KEY_RELEASED,event -> {
    if (event.getCode() == KeyCode.R) {
      Optional<TurboIssue> item=listView.getSelectedItem();
      if (!item.isPresent()) {
        return;
      }
      TurboIssue issue=item.get();
      LocalDateTime now=LocalDateTime.now();
      ui.prefs.setMarkedReadAt(issue.getRepoId(),issue.getId(),now);
      issue.setMarkedReadAt(Optional.of(now));
      issue.setIsCurrentlyRead(true);
      parentColumnControl.refresh();
    }
    if (event.getCode() == KeyCode.U) {
      Optional<TurboIssue> item=listView.getSelectedItem();
      if (!item.isPresent()) {
        return;
      }
      TurboIssue issue=item.get();
      ui.prefs.clearMarkedReadAt(issue.getRepoId(),issue.getId());
      issue.setMarkedReadAt(Optional.empty());
      issue.setIsCurrentlyRead(false);
      parentColumnControl.refresh();
    }
    if (event.getCode() == KeyCode.F5) {
      ui.logic.refresh();
    }
    if (event.getCode() == KeyCode.F1) {
      ui.getBrowserComponent().showDocs();
    }
    if (keyCombListToBox.match(event)) {
      setFocusToFilterBox();
    }
    if (event.getCode() == KeyCode.SPACE && KeyPress.isDoublePress(KeyCode.SPACE,event.getCode())) {
      setFocusToFilterBox();
    }
    if (event.getCode() == KeyCode.I) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showIssues();
      }
    }
    if (event.getCode() == KeyCode.P) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showPullRequests();
      }
    }
    if (event.getCode() == KeyCode.H) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showDocs();
      }
    }
    if (event.getCode() == KeyCode.K) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showKeyboardShortcuts();
      }
    }
    if (event.getCode() == KeyCode.D) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showContributors();
        event.consume();
      }
    }
    if (event.getCode() == KeyCode.U) {
      ui.getBrowserComponent().scrollToTop();
    }
    if (event.getCode() == KeyCode.N) {
      if (!minimizeWindow.match(event)) {
        ui.getBrowserComponent().scrollToBottom();
      }
    }
    if (event.getCode() == KeyCode.J || event.getCode() == KeyCode.K) {
      ui.getBrowserComponent().scrollPage(event.getCode() == KeyCode.K);
    }
    if (event.getCode() == KeyCode.G) {
      KeyPress.setLastKeyPressedCodeAndTime(event.getCode());
    }
    if (event.getCode() == KeyCode.C && ui.getBrowserComponent().isCurrentUrlIssue()) {
      ui.getBrowserComponent().jumpToComment();
    }
    if (event.getCode() == KeyCode.L) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().newLabel();
      }
 else       if (ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().manageLabels(event.getCode().toString());
      }
    }
    if (event.getCode() == KeyCode.A && ui.getBrowserComponent().isCurrentUrlIssue()) {
      ui.getBrowserComponent().manageAssignees(event.getCode().toString());
    }
    if (event.getCode() == KeyCode.M) {
      if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
        ui.getBrowserComponent().showMilestones();
      }
 else       if (ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().manageMilestones(event.getCode().toString());
      }
    }
    if (maximizeWindow.match(event)) {
      ui.maximizeWindow();
    }
    if (minimizeWindow.match(event)) {
      ui.minimizeWindow();
    }
    if (defaultSizeWindow.match(event)) {
      ui.setDefaultWidth();
    }
  }
);
}",0.994149414941494
135311,"private String getCurrentPageSource(){
  JavascriptExecutor executor=(JavascriptExecutor)driver;
  String result=StringEscapeUtils.escapeHtml4((String)executor.executeScript(""String_Node_Str""));
  return result;
}","private String getCurrentPageSource(){
  return StringEscapeUtils.escapeHtml4((String)driver.executeScript(""String_Node_Str""));
}",0.7076023391812866
135312,"@Override protected Void call(){
  if (isBrowserActive()) {
    try {
      operation.run();
      pageContentOnLoad=getCurrentPageSource();
    }
 catch (    WebDriverException e) {
switch (BrowserComponentError.fromErrorMessage(e.getMessage())) {
case NoSuchWindow:
        resetBrowser();
      runBrowserOperation(operation);
case NoSuchElement:
    logger.info(""String_Node_Str"" + e.getMessage());
  break;
default :
break;
}
}
}
 else {
logger.info(""String_Node_Str"");
resetBrowser();
runBrowserOperation(operation);
}
return null;
}","@Override protected Void call(){
  if (isBrowserActive()) {
    try {
      operation.run();
      pageContentOnLoad=getCurrentPageSource();
    }
 catch (    WebDriverException e) {
switch (BrowserComponentError.fromErrorMessage(e.getMessage())) {
case NoSuchWindow:
        resetBrowser();
      runBrowserOperation(operation);
    break;
case NoSuchElement:
  logger.info(""String_Node_Str"" + e.getMessage());
break;
default :
break;
}
}
}
 else {
logger.info(""String_Node_Str"");
resetBrowser();
runBrowserOperation(operation);
}
return null;
}",0.9861751152073732
135313,"/** 
 * A helper function for running browser operations. Takes care of running it on a separate thread, and normalises error-handling across all types of code.
 */
private void runBrowserOperation(Runnable operation){
  executor.execute(new Task<Void>(){
    @Override protected Void call(){
      if (isBrowserActive()) {
        try {
          operation.run();
          pageContentOnLoad=getCurrentPageSource();
        }
 catch (        WebDriverException e) {
switch (BrowserComponentError.fromErrorMessage(e.getMessage())) {
case NoSuchWindow:
            resetBrowser();
          runBrowserOperation(operation);
case NoSuchElement:
        logger.info(""String_Node_Str"" + e.getMessage());
      break;
default :
    break;
}
}
}
 else {
logger.info(""String_Node_Str"");
resetBrowser();
runBrowserOperation(operation);
}
return null;
}
}
);
}","/** 
 * A helper function for running browser operations. Takes care of running it on a separate thread, and normalises error-handling across all types of code.
 */
private void runBrowserOperation(Runnable operation){
  executor.execute(new Task<Void>(){
    @Override protected Void call(){
      if (isBrowserActive()) {
        try {
          operation.run();
          pageContentOnLoad=getCurrentPageSource();
        }
 catch (        WebDriverException e) {
switch (BrowserComponentError.fromErrorMessage(e.getMessage())) {
case NoSuchWindow:
            resetBrowser();
          runBrowserOperation(operation);
        break;
case NoSuchElement:
      logger.info(""String_Node_Str"" + e.getMessage());
    break;
default :
  break;
}
}
}
 else {
logger.info(""String_Node_Str"");
resetBrowser();
runBrowserOperation(operation);
}
return null;
}
}
);
}",0.9877121123464014
135314,"private void applyAssignee(TurboIssue issue,IModel model) throws QualifierApplicationException {
  if (!content.isPresent()) {
    throw new QualifierApplicationException(""String_Node_Str"" + (date.isPresent() ? date.get() : dateRange.get()));
  }
  List<TurboUser> assignees=model.getUsers().stream().filter(c -> c.getLoginName().toLowerCase().contains(content.get().toLowerCase())).collect(Collectors.toList());
  if (assignees.size() > 1) {
    throw new QualifierApplicationException(""String_Node_Str"" + assignees.toString());
  }
 else {
    issue.setAssignee(assignees.get(0));
  }
}","private void applyAssignee(TurboIssue issue,IModel model) throws QualifierApplicationException {
  if (!content.isPresent()) {
    throw new QualifierApplicationException(""String_Node_Str"");
  }
  List<TurboUser> assignees=model.getUsers().stream().filter(c -> c.getLoginName().toLowerCase().contains(content.get().toLowerCase())).collect(Collectors.toList());
  if (assignees.isEmpty()) {
    throw new QualifierApplicationException(""String_Node_Str"" + content.get());
  }
 else   if (assignees.size() == 1) {
    issue.setAssignee(assignees.get(0));
    return;
  }
  assignees=model.getUsers().stream().filter(c -> c.getLoginName().toLowerCase().equals(content.get().toLowerCase())).collect(Collectors.toList());
  if (assignees.isEmpty()) {
    throw new QualifierApplicationException(""String_Node_Str"" + content.get());
  }
 else   if (assignees.size() == 1) {
    issue.setAssignee(assignees.get(0));
    return;
  }
  throw new QualifierApplicationException(""String_Node_Str"" + assignees.toString());
}",0.6437069505322479
135315,"private void applyMilestone(TurboIssue issue,IModel model) throws QualifierApplicationException {
  if (!content.isPresent()) {
    throw new QualifierApplicationException(""String_Node_Str"" + (date.isPresent() ? date.get() : dateRange.get()));
  }
  List<TurboMilestone> milestones=model.getMilestones().stream().filter(m -> m.getTitle().toLowerCase().contains(content.get().toLowerCase())).collect(Collectors.toList());
  if (milestones.size() > 1) {
    throw new QualifierApplicationException(""String_Node_Str"" + milestones.toString());
  }
 else {
    issue.setMilestone(milestones.get(0));
  }
}","private void applyMilestone(TurboIssue issue,IModel model) throws QualifierApplicationException {
  if (!content.isPresent()) {
    throw new QualifierApplicationException(""String_Node_Str"");
  }
  List<TurboMilestone> milestones=model.getMilestones().stream().filter(m -> m.getTitle().toLowerCase().contains(content.get().toLowerCase())).collect(Collectors.toList());
  if (milestones.isEmpty()) {
    throw new QualifierApplicationException(""String_Node_Str"" + content.get());
  }
 else   if (milestones.size() == 1) {
    issue.setMilestone(milestones.get(0));
    return;
  }
  milestones=model.getMilestones().stream().filter(m -> m.getTitle().toLowerCase().equals(content.get().toLowerCase())).collect(Collectors.toList());
  if (milestones.isEmpty()) {
    throw new QualifierApplicationException(""String_Node_Str"" + content.get());
  }
 else   if (milestones.size() == 1) {
    issue.setMilestone(milestones.get(0));
    return;
  }
  throw new QualifierApplicationException(""String_Node_Str"" + milestones.toString());
}",0.644963144963145
135316,"private void applyLabel(TurboIssue issue,IModel model) throws QualifierApplicationException {
  if (!content.isPresent()) {
    throw new QualifierApplicationException(""String_Node_Str"" + (date.isPresent() ? date.get() : dateRange.get()));
  }
  List<TurboLabel> labels=model.getLabels().stream().filter(l -> l.getActualName().toLowerCase().contains(content.get().toLowerCase())).collect(Collectors.toList());
  if (labels.size() > 1) {
    throw new QualifierApplicationException(""String_Node_Str"" + labels.toString());
  }
 else {
    issue.addLabel(labels.get(0));
  }
}","private void applyLabel(TurboIssue issue,IModel model) throws QualifierApplicationException {
  if (!content.isPresent()) {
    throw new QualifierApplicationException(""String_Node_Str"");
  }
  List<TurboLabel> labels=model.getLabels().stream().filter(l -> l.getActualName().toLowerCase().contains(content.get().toLowerCase())).collect(Collectors.toList());
  if (labels.isEmpty()) {
    throw new QualifierApplicationException(""String_Node_Str"" + content.get());
  }
 else   if (labels.size() == 1) {
    issue.addLabel(labels.get(0));
    return;
  }
  labels=model.getLabels().stream().filter(l -> l.getActualName().toLowerCase().equals(content.get().toLowerCase())).collect(Collectors.toList());
  if (labels.isEmpty()) {
    throw new QualifierApplicationException(""String_Node_Str"" + content.get());
  }
 else   if (labels.size() == 1) {
    issue.addLabel(labels.get(0));
    return;
  }
  throw new QualifierApplicationException(""String_Node_Str"" + labels.toString());
}",0.647324306898775
135317,"private void applyState(TurboIssue issue) throws QualifierApplicationException {
  if (!content.isPresent()) {
    throw new QualifierApplicationException(""String_Node_Str"" + (date.isPresent() ? date.get() : dateRange.get()));
  }
  if (content.get().toLowerCase().contains(""String_Node_Str"")) {
    issue.setOpen(true);
  }
 else   if (content.get().toLowerCase().contains(""String_Node_Str"")) {
    issue.setOpen(false);
  }
}","private void applyState(TurboIssue issue) throws QualifierApplicationException {
  if (!content.isPresent()) {
    throw new QualifierApplicationException(""String_Node_Str"");
  }
  if (content.get().toLowerCase().contains(""String_Node_Str"")) {
    issue.setOpen(true);
  }
 else   if (content.get().toLowerCase().contains(""String_Node_Str"")) {
    issue.setOpen(false);
  }
 else {
    throw new QualifierApplicationException(""String_Node_Str"" + content.get());
  }
}",0.4116331096196868
135318,"@Test public void getters(){
  assertEquals(REPO,modelUpdated.getRepoId());
  assertEquals(modelUpdated.getRepoId(),modelUpdated.getRepoId());
  assertEquals(modelEmptySig.getUpdateSignature(),UpdateSignature.empty);
  assertEquals(modelEmptySig.getUpdateSignature(),modelEmptySig2.getUpdateSignature());
  int issueCount=1;
  for (  TurboIssue issue : modelUpdated.getIssues()) {
    assertEquals(issueCount,modelUpdated.getIssueById(issueCount).get().getId());
    assertEquals(issueCount,issue.getId());
    issueCount++;
  }
  int labelCount=1;
  for (  TurboLabel label : modelUpdated.getLabels()) {
    assertEquals(""String_Node_Str"" + labelCount,label.getActualName());
    assertEquals(""String_Node_Str"" + labelCount,modelUpdated.getLabelByActualName(""String_Node_Str"" + labelCount).get().getActualName());
    labelCount++;
  }
  int milestoneCount=1;
  for (  TurboMilestone milestone : modelUpdated.getMilestones()) {
    assertEquals(milestoneCount,milestone.getId());
    assertEquals(milestoneCount,modelUpdated.getMilestoneById(milestoneCount).get().getId());
    assertEquals(""String_Node_Str"" + milestoneCount,modelUpdated.getMilestoneByTitle(""String_Node_Str"" + milestoneCount).get().getTitle());
    milestoneCount++;
  }
  int userCount=1;
  for (  TurboUser user : modelUpdated.getUsers()) {
    assertEquals(""String_Node_Str"" + userCount,user.getLoginName());
    assertEquals(""String_Node_Str"" + userCount,modelUpdated.getUserByLogin(""String_Node_Str"" + userCount).get().getLoginName());
    userCount++;
  }
}","@Test public void getters(){
  assertEquals(REPO,modelUpdated.getRepoId());
  assertEquals(modelUpdated.getRepoId(),modelUpdated.getRepoId());
  assertEquals(modelEmptySig.getUpdateSignature(),UpdateSignature.empty);
  assertEquals(modelEmptySig.getUpdateSignature(),modelEmptySig2.getUpdateSignature());
  ArrayList<Integer> issueIds=new ArrayList<>();
  for (int i=1; i <= 10; i++) {
    issueIds.add(i);
  }
  Collections.sort(issueIds);
  int issueCount=1;
  for (  TurboIssue issue : modelUpdated.getIssues()) {
    assertEquals(issueCount,modelUpdated.getIssueById(issueCount).get().getId());
    assertEquals(issueIds.get(issueCount - 1).intValue(),issue.getId());
    issueCount++;
  }
  ArrayList<String> labelNames=new ArrayList<>();
  for (int i=1; i <= 10; i++) {
    labelNames.add(""String_Node_Str"" + i);
  }
  Collections.sort(labelNames);
  int labelCount=1;
  for (  TurboLabel label : modelUpdated.getLabels()) {
    assertEquals(labelNames.get(labelCount - 1),label.getActualName());
    assertEquals(""String_Node_Str"" + labelCount,modelUpdated.getLabelByActualName(""String_Node_Str"" + labelCount).get().getActualName());
    labelCount++;
  }
  ArrayList<Integer> milestoneIds=new ArrayList<>();
  for (int i=1; i <= 10; i++) {
    milestoneIds.add(i);
  }
  Collections.sort(milestoneIds);
  int milestoneCount=1;
  for (  TurboMilestone milestone : modelUpdated.getMilestones()) {
    assertEquals(milestoneCount,milestone.getId());
    assertEquals(milestoneIds.get(milestoneCount - 1).intValue(),modelUpdated.getMilestoneById(milestoneCount).get().getId());
    assertEquals(""String_Node_Str"" + milestoneCount,modelUpdated.getMilestoneByTitle(""String_Node_Str"" + milestoneCount).get().getTitle());
    milestoneCount++;
  }
  ArrayList<String> userLogins=new ArrayList<>();
  for (int i=1; i <= 10; i++) {
    userLogins.add(""String_Node_Str"" + i);
  }
  Collections.sort(userLogins);
  int userCount=1;
  for (  TurboUser user : modelUpdated.getUsers()) {
    assertEquals(userLogins.get(userCount - 1),user.getLoginName());
    assertEquals(""String_Node_Str"" + userCount,modelUpdated.getUserByLogin(""String_Node_Str"" + userCount).get().getLoginName());
    userCount++;
  }
}",0.7691483663631494
135319,"private void setupKeyboardShortcuts(){
  filterTextField.addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      if (keyCombBoxToList.match(event)) {
        event.consume();
        listView.selectFirstItem();
      }
      if (event.getCode() == KeyCode.SPACE) {
        event.consume();
      }
      if (KeyPress.isDoublePress(KeyCode.SPACE,event.getCode())) {
        event.consume();
        listView.selectFirstItem();
      }
      if (maximizeWindow.match(event)) {
        ui.maximizeWindow();
      }
      if (minimizeWindow.match(event)) {
        ui.minimizeWindow();
      }
      if (defaultSizeWindow.match(event)) {
        ui.setDefaultWidth();
      }
    }
  }
);
  addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      TurboIssue issue=listView.getSelectionModel().getSelectedItem();
      if (event.getCode() == KeyCode.R) {
        LocalDateTime now=LocalDateTime.now();
        ui.prefs.setMarkedReadAt(issue.getRepoId(),issue.getId(),now);
        issue.setMarkedReadAt(Optional.of(now));
        issue.setIsCurrentlyRead(true);
        parentColumnControl.refresh();
      }
      if (event.getCode() == KeyCode.U) {
        ui.prefs.clearMarkedReadAt(issue.getRepoId(),issue.getId());
        issue.setMarkedReadAt(Optional.empty());
        issue.setIsCurrentlyRead(false);
        parentColumnControl.refresh();
      }
      if (event.getCode() == KeyCode.F5) {
        ui.logic.refresh();
      }
      if (event.getCode() == KeyCode.F1) {
        ui.getBrowserComponent().showDocs();
      }
      if (keyCombListToBox.match(event)) {
        setFocusToFilterBox();
      }
      if (event.getCode() == KeyCode.SPACE && KeyPress.isDoublePress(KeyCode.SPACE,event.getCode())) {
        setFocusToFilterBox();
      }
      if (event.getCode() == KeyCode.I) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showIssues();
        }
      }
      if (event.getCode() == KeyCode.P) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showPullRequests();
        }
      }
      if (event.getCode() == KeyCode.H) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showDocs();
        }
      }
      if (event.getCode() == KeyCode.K) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showKeyboardShortcuts();
        }
      }
      if (event.getCode() == KeyCode.D) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showContributors();
          event.consume();
        }
      }
      if (event.getCode() == KeyCode.U) {
        ui.getBrowserComponent().scrollToTop();
      }
      if (event.getCode() == KeyCode.N) {
        ui.getBrowserComponent().scrollToBottom();
      }
      if (event.getCode() == KeyCode.J || event.getCode() == KeyCode.K) {
        ui.getBrowserComponent().scrollPage(event.getCode() == KeyCode.K);
      }
      if (event.getCode() == KeyCode.G) {
        KeyPress.setLastKeyPressedCodeAndTime(event.getCode());
      }
      if (event.getCode() == KeyCode.C && ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().jumpToComment();
      }
      if (event.getCode() == KeyCode.L) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().newLabel();
        }
 else         if (ui.getBrowserComponent().isCurrentUrlIssue()) {
          ui.getBrowserComponent().manageLabels(event.getCode().toString());
        }
      }
      if (event.getCode() == KeyCode.A && ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().manageAssignees(event.getCode().toString());
      }
      if (event.getCode() == KeyCode.M) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showMilestones();
        }
 else         if (ui.getBrowserComponent().isCurrentUrlIssue()) {
          ui.getBrowserComponent().manageMilestones(event.getCode().toString());
        }
      }
      if (maximizeWindow.match(event)) {
        ui.maximizeWindow();
      }
      if (minimizeWindow.match(event)) {
        ui.minimizeWindow();
      }
      if (defaultSizeWindow.match(event)) {
        ui.setDefaultWidth();
      }
    }
  }
);
}","private void setupKeyboardShortcuts(){
  filterTextField.addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      if (keyCombBoxToList.match(event)) {
        event.consume();
        listView.selectFirstItem();
      }
      if (event.getCode() == KeyCode.SPACE) {
        event.consume();
      }
      if (KeyPress.isDoublePress(KeyCode.SPACE,event.getCode())) {
        event.consume();
        listView.selectFirstItem();
      }
      if (maximizeWindow.match(event)) {
        ui.maximizeWindow();
      }
      if (minimizeWindow.match(event)) {
        ui.minimizeWindow();
      }
      if (defaultSizeWindow.match(event)) {
        ui.setDefaultWidth();
      }
    }
  }
);
  addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      if (event.getCode() == KeyCode.R) {
        Optional<TurboIssue> item=listView.getSelectedItem();
        if (!item.isPresent()) {
          return;
        }
        TurboIssue issue=item.get();
        LocalDateTime now=LocalDateTime.now();
        ui.prefs.setMarkedReadAt(issue.getRepoId(),issue.getId(),now);
        issue.setMarkedReadAt(Optional.of(now));
        issue.setIsCurrentlyRead(true);
        parentColumnControl.refresh();
      }
      if (event.getCode() == KeyCode.U) {
        Optional<TurboIssue> item=listView.getSelectedItem();
        if (!item.isPresent()) {
          return;
        }
        TurboIssue issue=item.get();
        ui.prefs.clearMarkedReadAt(issue.getRepoId(),issue.getId());
        issue.setMarkedReadAt(Optional.empty());
        issue.setIsCurrentlyRead(false);
        parentColumnControl.refresh();
      }
      if (event.getCode() == KeyCode.F5) {
        ui.logic.refresh();
      }
      if (event.getCode() == KeyCode.F1) {
        ui.getBrowserComponent().showDocs();
      }
      if (keyCombListToBox.match(event)) {
        setFocusToFilterBox();
      }
      if (event.getCode() == KeyCode.SPACE && KeyPress.isDoublePress(KeyCode.SPACE,event.getCode())) {
        setFocusToFilterBox();
      }
      if (event.getCode() == KeyCode.I) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showIssues();
        }
      }
      if (event.getCode() == KeyCode.P) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showPullRequests();
        }
      }
      if (event.getCode() == KeyCode.H) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showDocs();
        }
      }
      if (event.getCode() == KeyCode.K) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showKeyboardShortcuts();
        }
      }
      if (event.getCode() == KeyCode.D) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showContributors();
          event.consume();
        }
      }
      if (event.getCode() == KeyCode.U) {
        ui.getBrowserComponent().scrollToTop();
      }
      if (event.getCode() == KeyCode.N) {
        ui.getBrowserComponent().scrollToBottom();
      }
      if (event.getCode() == KeyCode.J || event.getCode() == KeyCode.K) {
        ui.getBrowserComponent().scrollPage(event.getCode() == KeyCode.K);
      }
      if (event.getCode() == KeyCode.G) {
        KeyPress.setLastKeyPressedCodeAndTime(event.getCode());
      }
      if (event.getCode() == KeyCode.C && ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().jumpToComment();
      }
      if (event.getCode() == KeyCode.L) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().newLabel();
        }
 else         if (ui.getBrowserComponent().isCurrentUrlIssue()) {
          ui.getBrowserComponent().manageLabels(event.getCode().toString());
        }
      }
      if (event.getCode() == KeyCode.A && ui.getBrowserComponent().isCurrentUrlIssue()) {
        ui.getBrowserComponent().manageAssignees(event.getCode().toString());
      }
      if (event.getCode() == KeyCode.M) {
        if (KeyPress.isValidKeyCombination(KeyCode.G,event.getCode())) {
          ui.getBrowserComponent().showMilestones();
        }
 else         if (ui.getBrowserComponent().isCurrentUrlIssue()) {
          ui.getBrowserComponent().manageMilestones(event.getCode().toString());
        }
      }
      if (maximizeWindow.match(event)) {
        ui.maximizeWindow();
      }
      if (minimizeWindow.match(event)) {
        ui.minimizeWindow();
      }
      if (defaultSizeWindow.match(event)) {
        ui.setDefaultWidth();
      }
    }
  }
);
}",0.9582220322684049
135320,"/** 
 * Should be called to restore selection after making changes to the item list of this list view. Must be called after saveSelection is.
 * @throws IllegalStateException if called before saveSelection is
 */
public void restoreSelection(){
  if (!lastSelectedItem.isPresent()) {
    if (!saveSelectionCalled) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else {
      saveSelectionCalled=false;
      return;
    }
  }
  saveSelectionCalled=false;
  int index=-1;
  int i=0;
  for (  T item : getItems()) {
    if (item.equals(lastSelectedItem)) {
      index=i;
      break;
    }
    i++;
  }
  if (index == -1) {
  }
 else {
    getSelectionModel().clearAndSelect(index);
    selectedIndex=Optional.of(index);
  }
}","/** 
 * Should be called to restore selection after making changes to the item list of this list view. Must be called after saveSelection is.
 * @throws IllegalStateException if called before saveSelection is
 */
public void restoreSelection(){
  if (!lastSelectedItem.isPresent()) {
    if (!saveSelectionCalled) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else {
      saveSelectionCalled=false;
      return;
    }
  }
  saveSelectionCalled=false;
  int index=-1;
  int i=0;
  for (  T item : getItems()) {
    if (item.equals(lastSelectedItem.get())) {
      index=i;
      break;
    }
    i++;
  }
  if (index == -1) {
  }
 else {
    getSelectionModel().clearAndSelect(index);
    selectedIndex=Optional.of(index);
  }
}",0.9959839357429718
135321,"/** 
 * Takes lists of TurboIssues and reconciles the changes between them, returning a list of TurboIssues with updates from the second.
 */
public static List<TurboIssue> reconcile(String repoId,List<TurboIssue> existing,List<TurboIssue> changed){
  existing=new ArrayList<>(existing);
  for (  TurboIssue issue : changed) {
    int id=issue.getId();
    Optional<Integer> corresponding=findIssueWithId(existing,id);
    if (corresponding.isPresent()) {
      existing.set(corresponding.get(),new TurboIssue(issue));
    }
 else {
      existing.add(new TurboIssue(issue));
    }
  }
  return existing;
}","/** 
 * Takes lists of TurboIssues and reconciles the changes between them, returning a list of TurboIssues with updates from the second.
 */
public static List<TurboIssue> reconcile(String repoId,List<TurboIssue> existing,List<TurboIssue> changed){
  existing=new ArrayList<>(existing);
  for (  TurboIssue issue : changed) {
    int id=issue.getId();
    Optional<Integer> corresponding=findIssueWithId(existing,id);
    if (corresponding.isPresent()) {
      TurboIssue newIssue=new TurboIssue(issue);
      newIssue.transferTransientState(existing.get(corresponding.get()));
      existing.set(corresponding.get(),newIssue);
    }
 else {
      existing.add(new TurboIssue(issue));
    }
  }
  return existing;
}",0.8880484114977307
135322,"public synchronized MultiModel add(Model model){
  this.models.put(model.getRepoId(),model);
  preprocessNewIssues(model);
  return this;
}","public synchronized MultiModel add(Model model){
  this.models.put(model.getRepoId(),model);
  return this;
}",0.8790322580645161
135323,"public String getName(){
  if (getDelimiter().isPresent()) {
    return actualName.split(""String_Node_Str"" + getDelimiter().get())[1];
  }
 else {
    return actualName;
  }
}","public String getName(){
}",0.2587064676616915
135324,"public Optional<String> getGroup(){
  if (getDelimiter().isPresent()) {
    return Optional.of(actualName.split(""String_Node_Str"" + getDelimiter().get())[0]);
  }
 else {
    return Optional.empty();
  }
}","public Optional<String> getGroup(){
}",0.3057851239669421
135325,"private static TurboLabel updateRandomLabel(String repoId){
  int i=(int)(Math.random() * issueCounter);
  return new TurboLabel(repoId,""String_Node_Str"" + i + ""String_Node_Str""+ Math.random());
}","private static TurboLabel updateRandomLabel(String repoId){
  int i=(int)(Math.random() * labelCounter);
  return labels.set(i,new TurboLabel(repoId,""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ Math.random()));
}",0.9223300970873788
135326,"@Override public List<TurboUser> getCollaborators(String repoId){
  List<TurboUser> users=new ArrayList<>();
  for (int i=0; i < 10; i++) {
    users.add(makeDummyUser(DUMMY_REPO_ID));
  }
  return users;
}","@Override public List<TurboUser> getCollaborators(String repoId){
  return users;
}",0.5743944636678201
135327,"private static TurboIssue updateRandomIssue(String repoId){
  int i=(int)(Math.random() * issueCounter);
  return new TurboIssue(repoId,i,""String_Node_Str"" + i + ""String_Node_Str""+ Math.random());
}","private static TurboIssue updateRandomIssue(String repoId){
  int i=(int)(Math.random() * issueCounter);
  return issues.set(i,new TurboIssue(repoId,i + 1,""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ Math.random()));
}",0.938095238095238
135328,"@Override public List<TurboMilestone> getMilestones(String repoId){
  List<TurboMilestone> milestones=new ArrayList<>();
  for (int i=0; i < 10; i++) {
    milestones.add(makeDummyMilestone(DUMMY_REPO_ID));
  }
  return milestones;
}","@Override public List<TurboMilestone> getMilestones(String repoId){
  return milestones;
}",0.5572755417956656
135329,"@Override public List<TurboLabel> getLabels(String repoId){
  List<TurboLabel> labels=new ArrayList<>();
  for (int i=0; i < 10; i++) {
    labels.add(makeDummyLabel(DUMMY_REPO_ID));
  }
  return labels;
}","@Override public List<TurboLabel> getLabels(String repoId){
  return labels;
}",0.5512367491166078
135330,"private static TurboMilestone updateRandomMilestone(String repoId){
  int i=(int)(Math.random() * milestoneCounter);
  return new TurboMilestone(repoId,i,""String_Node_Str"" + i + ""String_Node_Str""+ Math.random());
}","private static TurboMilestone updateRandomMilestone(String repoId){
  int i=(int)(Math.random() * milestoneCounter);
  return milestones.set(i,new TurboMilestone(repoId,(i + 1),""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ Math.random()));
}",0.925764192139738
135331,"public DummyRepo(){
}","public DummyRepo(){
  for (int i=0; i < 10; i++) {
    issues.add(makeDummyIssue(DUMMY_REPO_ID));
    labels.add(makeDummyLabel(DUMMY_REPO_ID));
    milestones.add(makeDummyMilestone(DUMMY_REPO_ID));
    users.add(makeDummyUser(DUMMY_REPO_ID));
  }
}",0.1549815498154981
135332,"private static TurboUser updateRandomUser(String repoId){
  int i=(int)(Math.random() * userCounter);
  return new TurboUser(repoId,""String_Node_Str"" + i + ""String_Node_Str""+ Math.random());
}","private static TurboUser updateRandomUser(String repoId){
  int i=(int)(Math.random() * userCounter);
  return users.set(i,new TurboUser(repoId,""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ Math.random()));
}",0.9478908188585607
135333,"@Override public List<TurboIssue> getIssues(String repoName){
  List<TurboIssue> issues=new ArrayList<>();
  for (int i=0; i < 10; i++) {
    issues.add(makeDummyIssue(DUMMY_REPO_ID));
  }
  return issues;
}","@Override public List<TurboIssue> getIssues(String repoName){
  return issues;
}",0.5574912891986062
135334,"private boolean keywordSatisfies(TurboIssue issue,MetaQualifierInfo info){
  if (info.getIn().isPresent()) {
switch (info.getIn().get()) {
case ""String_Node_Str"":
      return titleSatisfies(issue);
case ""String_Node_Str"":
case ""String_Node_Str"":
    return bodySatisfies(issue);
default :
  return false;
}
}
 else {
return titleSatisfies(issue) || bodySatisfies(issue);
}
}","private boolean keywordSatisfies(TurboIssue issue,MetaQualifierInfo info){
  if (info.getIn().isPresent()) {
switch (info.getIn().get()) {
case ""String_Node_Str"":
      return titleSatisfies(issue);
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
    return bodySatisfies(issue);
default :
  return false;
}
}
 else {
return titleSatisfies(issue) || bodySatisfies(issue);
}
}",0.9689922480620154
135335,"private boolean labelsSatisfy(IModel model,TurboIssue issue){
  if (!content.isPresent())   return false;
  TurboLabel tokens=new TurboLabel(""String_Node_Str"",content.get().toLowerCase());
  String group=""String_Node_Str"";
  if (tokens.getGroup().isPresent()) {
    group=tokens.getGroup().get().toLowerCase();
  }
  String labelName=tokens.getName().toLowerCase();
  for (  TurboLabel label : model.getLabelsOfIssue(issue)) {
    if (label.getGroup().isPresent()) {
      if (label.getGroup().get().toLowerCase().contains(group) && label.getName().toLowerCase().contains(labelName)) {
        return true;
      }
    }
 else {
      return label.getName().toLowerCase().contains(labelName);
    }
  }
  return false;
}","private boolean labelsSatisfy(IModel model,TurboIssue issue){
  if (!content.isPresent())   return false;
  TurboLabel tokens=new TurboLabel(""String_Node_Str"",content.get().toLowerCase());
  String group=""String_Node_Str"";
  if (tokens.getGroup().isPresent()) {
    group=tokens.getGroup().get().toLowerCase();
  }
  String labelName=tokens.getName().toLowerCase();
  for (  TurboLabel label : model.getLabelsOfIssue(issue)) {
    if (label.getGroup().isPresent()) {
      if (labelName.isEmpty()) {
        if (label.getGroup().get().toLowerCase().contains(group)) {
          return true;
        }
      }
 else {
        if (label.getGroup().get().toLowerCase().contains(group) && label.getName().toLowerCase().contains(labelName)) {
          return true;
        }
      }
    }
 else {
      if (!group.isEmpty()) {
        return false;
      }
 else       if (!labelName.isEmpty() && label.getName().toLowerCase().contains(labelName)) {
        return true;
      }
    }
  }
  return false;
}",0.8176538908246226
135336,"private boolean satisfiesHasConditions(TurboIssue issue){
  if (!content.isPresent())   return false;
switch (content.get()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    return issue.getLabels().size() > 0;
case ""String_Node_Str"":
case ""String_Node_Str"":
  return issue.getMilestone() != null;
case ""String_Node_Str"":
case ""String_Node_Str"":
return issue.getAssignee() != null;
default :
return false;
}
}","private boolean satisfiesHasConditions(TurboIssue issue){
}",0.2494714587737843
135337,"public List<TurboLabel> getLabelsOfIssue(TurboIssue issue){
  return issue.getLabels().stream().map(this::getLabelByName).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
}","public List<TurboLabel> getLabelsOfIssue(TurboIssue issue){
  return issue.getLabels().stream().map(this::getLabelByActualName).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
}",0.9852216748768472
135338,"@Override public void run(){
  UpdateIssuesTask issuesTask=new UpdateIssuesTask(taskRunner,repo,model);
  UpdateLabelsTask labelsTask=new UpdateLabelsTask(taskRunner,repo,model);
  UpdateMilestonesTask milestonesTask=new UpdateMilestonesTask(taskRunner,repo,model);
  UpdateUsersTask usersTask=new UpdateUsersTask(taskRunner,repo,model);
  taskRunner.execute(issuesTask);
  taskRunner.execute(labelsTask);
  taskRunner.execute(milestonesTask);
  taskRunner.execute(usersTask);
  try {
    GitHubRepoTask.Result<TurboIssue> issuesResult=issuesTask.response.get();
    GitHubRepoTask.Result<TurboLabel> labelsResult=labelsTask.response.get();
    GitHubRepoTask.Result<TurboMilestone> milestonesResult=milestonesTask.response.get();
    GitHubRepoTask.Result<TurboUser> usersResult=usersTask.response.get();
    UpdateSignature newSignature=new UpdateSignature(issuesResult.ETag,labelsResult.ETag,milestonesResult.ETag,usersResult.ETag,issuesResult.lastCheckTime);
    Model result=new Model(model.getRepoId(),model.getIssues(),model.getLabels(),model.getMilestones(),model.getUsers(),newSignature);
    logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"" + result.summarise()));
    response.complete(result);
  }
 catch (  InterruptedException|ExecutionException e) {
    HTLog.error(logger,e);
  }
}","@Override public void run(){
  UpdateIssuesTask issuesTask=new UpdateIssuesTask(taskRunner,repo,model);
  UpdateLabelsTask labelsTask=new UpdateLabelsTask(taskRunner,repo,model);
  UpdateMilestonesTask milestonesTask=new UpdateMilestonesTask(taskRunner,repo,model);
  UpdateUsersTask usersTask=new UpdateUsersTask(taskRunner,repo,model);
  taskRunner.execute(issuesTask);
  taskRunner.execute(labelsTask);
  taskRunner.execute(milestonesTask);
  taskRunner.execute(usersTask);
  try {
    GitHubRepoTask.Result<TurboIssue> issuesResult=issuesTask.response.get();
    GitHubRepoTask.Result<TurboLabel> labelsResult=labelsTask.response.get();
    GitHubRepoTask.Result<TurboMilestone> milestonesResult=milestonesTask.response.get();
    GitHubRepoTask.Result<TurboUser> usersResult=usersTask.response.get();
    UpdateSignature newSignature=new UpdateSignature(issuesResult.ETag,labelsResult.ETag,milestonesResult.ETag,usersResult.ETag,issuesResult.lastCheckTime);
    Model result=new Model(model.getRepoId(),issuesResult.items,labelsResult.items,milestonesResult.items,usersResult.items,newSignature);
    logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"" + result.summarise()));
    response.complete(result);
  }
 catch (  InterruptedException|ExecutionException e) {
    HTLog.error(logger,e);
  }
}",0.9420289855072465
135339,"private void updateUI(){
  uiManager.update(models);
}","private void updateUI(MultiModel models){
  uiManager.update(models);
}",0.864
135340,"public void refresh(){
  logger.info(""String_Node_Str"" + models.toModels().stream().map(Model::getRepoId).collect(Collectors.toList()));
  Utility.sequence(models.toModels().stream().map(repoIO::updateModel).collect(Collectors.toList())).thenAccept(models::replace).thenRun(this::updateUI);
}","public void refresh(){
  logger.info(""String_Node_Str"" + models.toModels().stream().map(Model::getRepoId).collect(Collectors.toList()));
  Utility.sequence(models.toModels().stream().map(repoIO::updateModel).collect(Collectors.toList())).thenApply(models::replace).thenAccept(this::updateUI).exceptionally(HTLog::log);
}",0.9281045751633988
135341,"public Logic(UIManager uiManager,Preferences prefs){
  this.uiManager=uiManager;
  this.prefs=prefs;
  updateUI();
}","public Logic(UIManager uiManager,Preferences prefs){
  this.uiManager=uiManager;
  this.prefs=prefs;
  updateUI(models);
}",0.9747899159663864
135342,"public CompletableFuture<Map<Integer,IssueMetadata>> getIssueMetadata(String repoId,List<Integer> issues){
  logger.info(""String_Node_Str"" + issues);
  return repoIO.getIssueMetadata(repoId,issues).thenApply(metadata -> {
    models.insertMetadata(repoId,metadata);
    return metadata;
  }
);
}","public CompletableFuture<Map<Integer,IssueMetadata>> getIssueMetadata(String repoId,List<Integer> issues){
  logger.info(""String_Node_Str"" + issues);
  return repoIO.getIssueMetadata(repoId,issues).thenApply(metadata -> {
    models.insertMetadata(repoId,metadata);
    return metadata;
  }
).exceptionally(HTLog.withResult(new HashMap<>()));
}",0.9233176838810642
135343,"public CompletableFuture<Model> updateModel(Model model){
  return repoSource.updateModel(model).thenApply(newModel -> {
    if (!model.equals(newModel)) {
      repoStore.saveRepository(newModel.getRepoId().generateId(),new SerializableModel(newModel));
    }
 else {
      logger.info(HTLog.format(model.getRepoId(),""String_Node_Str""));
    }
    return model;
  }
);
}","public CompletableFuture<Model> updateModel(Model model){
  return repoSource.updateModel(model).thenApply(newModel -> {
    if (!model.equals(newModel)) {
      repoStore.saveRepository(newModel.getRepoId().generateId(),new SerializableModel(newModel));
    }
 else {
      logger.info(HTLog.format(model.getRepoId(),""String_Node_Str""));
    }
    return newModel;
  }
).exceptionally(HTLog.withResult(new Model(model.getRepoId())));
}",0.9169764560099132
135344,"public CompletableFuture<Model> openRepository(String repoId){
  if (repoStore.isRepoStored(repoId)) {
    return repoStore.loadRepository(repoId).thenCompose(this::updateModel);
  }
 else {
    return repoSource.downloadRepository(repoId).thenCompose(this::updateModel);
  }
}","public CompletableFuture<Model> openRepository(String repoId){
  if (repoStore.isRepoStored(repoId)) {
    return repoStore.loadRepository(repoId).thenCompose(this::updateModel).exceptionally(HTLog.withResult(new Model(RepositoryId.createFromId(repoId))));
  }
 else {
    return repoSource.downloadRepository(repoId).thenCompose(this::updateModel).exceptionally(HTLog.withResult(new Model(RepositoryId.createFromId(repoId))));
  }
}",0.780281690140845
135345,"@Override public void run(){
  ImmutableTriple<List<TurboIssue>,String,Date> changes=repo.getUpdatedIssues(model.getRepoId().generateId(),model.getUpdateSignature().issuesETag,model.getUpdateSignature().lastCheckTime);
  List<TurboIssue> existing=model.getIssues();
  List<TurboIssue> changed=changes.left;
  logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"",changed.size(),changed.size() == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + changed));
  List<TurboIssue> updated=TurboIssue.reconcile(model.getRepoId().generateId(),existing,changed);
  response.complete(new Result<>(updated,changes.middle,changes.right));
}","@Override public void run(){
  ImmutableTriple<List<TurboIssue>,String,Date> changes=repo.getUpdatedIssues(model.getRepoId().generateId(),model.getUpdateSignature().issuesETag,model.getUpdateSignature().lastCheckTime);
  List<TurboIssue> existing=model.getIssues();
  List<TurboIssue> changed=changes.left;
  logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"",changed.size(),changed.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + changed));
  List<TurboIssue> updated=changed.isEmpty() ? existing : TurboIssue.reconcile(model.getRepoId().generateId(),existing,changed);
  response.complete(new Result<>(updated,changes.middle,changes.right));
}",0.9604344453064392
135346,"@Override public void run(){
  ImmutablePair<List<TurboLabel>,String> changes=repo.getUpdatedLabels(model.getRepoId().generateId(),model.getUpdateSignature().labelsETag);
  List<TurboLabel> changed=changes.left;
  logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"",changed.size(),changed.size() == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + changed));
  List<TurboLabel> updated=new ArrayList<>(changed);
  response.complete(new Result<>(updated,changes.right));
}","@Override public void run(){
  ImmutablePair<List<TurboLabel>,String> changes=repo.getUpdatedLabels(model.getRepoId().generateId(),model.getUpdateSignature().labelsETag);
  List<TurboLabel> changed=changes.left;
  logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"",changed.size(),changed.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + changed));
  List<TurboLabel> updated=changed.isEmpty() ? model.getLabels() : new ArrayList<>(changed);
  response.complete(new Result<>(updated,changes.right));
}",0.9392712550607288
135347,"@Override public void run(){
  ImmutablePair<List<TurboMilestone>,String> changes=repo.getUpdatedMilestones(model.getRepoId().generateId(),model.getUpdateSignature().milestonesETag);
  List<TurboMilestone> changed=changes.left;
  logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"",changed.size(),changed.size() == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + changed));
  List<TurboMilestone> updated=new ArrayList<>(changed);
  response.complete(new Result<>(updated,changes.right));
}","@Override public void run(){
  ImmutablePair<List<TurboMilestone>,String> changes=repo.getUpdatedMilestones(model.getRepoId().generateId(),model.getUpdateSignature().milestonesETag);
  List<TurboMilestone> changed=changes.left;
  logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"",changed.size(),changed.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + changed));
  List<TurboMilestone> updated=changed.isEmpty() ? model.getMilestones() : new ArrayList<>(changed);
  response.complete(new Result<>(updated,changes.right));
}",0.937984496124031
135348,"@Override public void run(){
  ImmutablePair<List<TurboUser>,String> changes=repo.getUpdatedCollaborators(model.getRepoId().generateId(),model.getUpdateSignature().collaboratorsETag);
  List<TurboUser> changed=changes.left;
  logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"",changed.size(),changed.size() == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + changed));
  List<TurboUser> updated=new ArrayList<>(changed);
  response.complete(new Result<>(updated,changes.right));
}","@Override public void run(){
  ImmutablePair<List<TurboUser>,String> changes=repo.getUpdatedCollaborators(model.getRepoId().generateId(),model.getUpdateSignature().collaboratorsETag);
  List<TurboUser> changed=changes.left;
  logger.info(HTLog.format(model.getRepoId(),""String_Node_Str"",changed.size(),changed.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + changed));
  List<TurboUser> updated=changed.isEmpty() ? model.getUsers() : new ArrayList<>(changed);
  response.complete(new Result<>(updated,changes.right));
}",0.9415262636273538
135349,"private Model load(String repoId){
  Optional<String> input=RepoStore.read(repoId);
  if (!input.isPresent()) {
    logger.error(""String_Node_Str"" + repoId + ""String_Node_Str"");
    return new Model(RepositoryId.createFromId(repoId),UpdateSignature.empty);
  }
 else {
    logger.info(HTLog.format(repoId,""String_Node_Str""));
    SerializableModel sModel=new Gson().fromJson(input.get(),new TypeToken<SerializableModel>(){
    }
.getType());
    return new Model(sModel);
  }
}","private Model load(String repoId){
  Optional<String> input=RepoStore.read(repoId);
  if (!input.isPresent()) {
    logger.error(""String_Node_Str"" + repoId + ""String_Node_Str"");
    return new Model(RepositoryId.createFromId(repoId));
  }
 else {
    logger.info(HTLog.format(repoId,""String_Node_Str""));
    SerializableModel sModel=new Gson().fromJson(input.get(),new TypeToken<SerializableModel>(){
    }
.getType());
    return new Model(sModel);
  }
}",0.9763948497854076
135350,"public synchronized void add(Model model){
}","public synchronized MultiModel add(Model model){
  this.models.put(model.getRepoId().generateId(),model);
  return this;
}",0.5060240963855421
135351,"public synchronized void replace(List<Model> models){
  this.models.clear();
  models.forEach(this::add);
}","public synchronized MultiModel replace(List<Model> newModels){
  this.models.clear();
  newModels.forEach(this::add);
  return this;
}",0.8547717842323651
135352,"public String getName(){
}","public String getName(){
  if (getDelimiter().isPresent()) {
    return actualName.split(""String_Node_Str"" + getDelimiter().get())[1];
  }
 else {
    return actualName;
  }
}",0.2587064676616915
135353,"public boolean isExclusive(){
}","public boolean isExclusive(){
  if (getDelimiter().isPresent()) {
    return getDelimiter().get().equals(EXCLUSIVE_DELIMITER);
  }
 else {
    return false;
  }
}",0.3212435233160621
135354,"public Optional<String> getGroup(){
}","public Optional<String> getGroup(){
  if (getDelimiter().isPresent()) {
    return Optional.of(actualName.split(""String_Node_Str"" + getDelimiter().get())[0]);
  }
 else {
    return Optional.empty();
  }
}",0.3057851239669421
135355,"public static FilterExpression parse(String input){
  if (input == null)   return null;
 else   if (input.isEmpty())   return Qualifier.EMPTY;
  return new Parser(new Lexer(input).lex()).parseExpression(0);
}","public static FilterExpression parse(String input){
  if (input == null || input.isEmpty())   return Qualifier.EMPTY;
  return new Parser(new Lexer(input).lex()).parseExpression(0);
}",0.9258312020460358
135356,"@Test public void basics(){
  assertEquals(Parser.parse(null),null);
  assertEquals(Parser.parse(""String_Node_Str""),Qualifier.EMPTY);
}","@Test public void basics(){
  assertEquals(Parser.parse(null),Qualifier.EMPTY);
  assertEquals(Parser.parse(""String_Node_Str""),Qualifier.EMPTY);
}",0.9466192170818504
135357,"@Test public void emptyQualifiers(){
  try {
    Parser.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  try {
    Parser.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
}","@Test public void emptyQualifiers(){
  try {
    Parser.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
  try {
    Parser.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
}",0.9365671641791044
135358,"@Test public void dates(){
  assertEquals(Parser.parse(""String_Node_Str""),new Qualifier(""String_Node_Str"",LocalDate.of(2014,6,1)));
  assertEquals(Parser.parse(""String_Node_Str""),new Qualifier(""String_Node_Str"",LocalDate.of(2014,6,1)));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Conjunction(new Qualifier(""String_Node_Str"",""String_Node_Str""),new Qualifier(""String_Node_Str"",LocalDate.of(2014,06,01))),new Qualifier(""String_Node_Str"",""String_Node_Str"")));
}","@Test public void dates(){
  assertEquals(Parser.parse(""String_Node_Str""),new Qualifier(""String_Node_Str"",LocalDate.of(2014,6,1)));
  assertEquals(Parser.parse(""String_Node_Str""),new Qualifier(""String_Node_Str"",LocalDate.of(2014,6,1)));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Conjunction(new Qualifier(""String_Node_Str"",""String_Node_Str""),new Qualifier(""String_Node_Str"",LocalDate.of(2014,6,1))),new Qualifier(""String_Node_Str"",""String_Node_Str"")));
}",0.9979166666666668
135359,"@Test public void lexer(){
  assertEquals(new Lexer(""String_Node_Str"").lex(),new ArrayList<Token>(Arrays.asList(new Token(TokenType.EOF,""String_Node_Str"",0))));
  assertEquals(new Lexer(""String_Node_Str"").lex(),new ArrayList<Token>(Arrays.asList(new Token(TokenType.SYMBOL,""String_Node_Str"",0),new Token(TokenType.SYMBOL,""String_Node_Str"",0),new Token(TokenType.SYMBOL,""String_Node_Str"",0),new Token(TokenType.EOF,""String_Node_Str"",0))));
}","@Test public void lexer(){
  assertEquals(new Lexer(""String_Node_Str"").lex(),Arrays.asList(new Token(TokenType.EOF,""String_Node_Str"",0)));
  assertEquals(new Lexer(""String_Node_Str"").lex(),Arrays.asList(new Token(TokenType.SYMBOL,""String_Node_Str"",0),new Token(TokenType.SYMBOL,""String_Node_Str"",0),new Token(TokenType.SYMBOL,""String_Node_Str"",0),new Token(TokenType.EOF,""String_Node_Str"",0)));
}",0.9473684210526316
135360,"@Test public void dateRanges(){
  assertEquals(Parser.parse(""String_Node_Str""),new Qualifier(""String_Node_Str"",new DateRange(LocalDate.of(2014,06,01),LocalDate.of(2013,03,15))));
  assertEquals(Parser.parse(""String_Node_Str""),new Qualifier(""String_Node_Str"",new DateRange(LocalDate.of(2014,06,01),null)));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Conjunction(new Qualifier(""String_Node_Str"",""String_Node_Str""),new Qualifier(""String_Node_Str"",new DateRange(LocalDate.of(2014,06,01),LocalDate.of(2013,03,15)))),new Qualifier(""String_Node_Str"",""String_Node_Str"")));
}","@Test public void dateRanges(){
  assertEquals(Parser.parse(""String_Node_Str""),new Qualifier(""String_Node_Str"",new DateRange(LocalDate.of(2014,6,1),LocalDate.of(2013,3,15))));
  assertEquals(Parser.parse(""String_Node_Str""),new Qualifier(""String_Node_Str"",new DateRange(LocalDate.of(2014,6,1),null)));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Conjunction(new Qualifier(""String_Node_Str"",""String_Node_Str""),new Qualifier(""String_Node_Str"",new DateRange(LocalDate.of(2014,6,1),LocalDate.of(2013,03,15)))),new Qualifier(""String_Node_Str"",""String_Node_Str"")));
}",0.9940323955669224
135361,"@Test public void serialisation(){
  String[] tests={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < tests.length; i++) {
    assertEquals(Parser.parse(Parser.parse(tests[i]).toString()),Parser.parse(tests[i]));
  }
}","@Test public void serialisation(){
}",0.1265377855887522
135362,"@Test public void unexpectedEOFs(){
  try {
    Parser.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
  try {
    Parser.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
  }
}","@Test public void unexpectedEOFs(){
  try {
    Parser.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
  try {
    Parser.parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  ParseException ignored) {
  }
}",0.9363295880149812
135363,"/** 
 * Creates a JavaFX node containing a graphical display of this issue's events.
 * @param withinHours
 * @return
 */
public Node getEventDisplay(final int withinHours){
  final LocalDateTime now=LocalDateTime.now();
  List<TurboIssueEvent> eventsWithinDuration=events.stream().filter(event -> {
    LocalDateTime eventTime=Utility.longToLocalDateTime(event.getDate().getTime());
    int hours=Utility.safeLongToInt(eventTime.until(now,ChronoUnit.HOURS));
    return hours < withinHours;
  }
).collect(Collectors.toList());
  List<Comment> commentsWithinDuration=this.comments.stream().filter(comment -> {
    LocalDateTime created=Utility.longToLocalDateTime(comment.getCreatedAt().getTime());
    int hours=Utility.safeLongToInt(created.until(now,ChronoUnit.HOURS));
    return hours < withinHours;
  }
).collect(Collectors.toList());
  return layoutEvents(eventsWithinDuration,commentsWithinDuration);
}","/** 
 * Creates a JavaFX node containing a graphical display of this issue's events.
 * @param withinHours the number of hours to bound the returned events by
 * @return the node
 */
public Node getEventDisplay(final int withinHours){
  final LocalDateTime now=LocalDateTime.now();
  List<TurboIssueEvent> eventsWithinDuration=events.stream().filter(event -> {
    LocalDateTime eventTime=Utility.longToLocalDateTime(event.getDate().getTime());
    int hours=Utility.safeLongToInt(eventTime.until(now,ChronoUnit.HOURS));
    return hours < withinHours;
  }
).collect(Collectors.toList());
  List<Comment> commentsWithinDuration=this.comments.stream().filter(comment -> {
    LocalDateTime created=Utility.longToLocalDateTime(comment.getCreatedAt().getTime());
    int hours=Utility.safeLongToInt(created.until(now,ChronoUnit.HOURS));
    return hours < withinHours;
  }
).collect(Collectors.toList());
  return layoutEvents(eventsWithinDuration,commentsWithinDuration);
}",0.9675704412546516
135364,"public void addLabels(List<TurboLabel> labList){
  for (  TurboLabel label : labList) {
    addLabel(label);
  }
}","public void addLabels(List<TurboLabel> newLabels){
  newLabels.forEach(this::addLabel);
}",0.6600985221674877
135365,"private ObservableList<TurboLabel> translateLabels(List<Label> labels){
  ObservableList<TurboLabel> turboLabels=FXCollections.observableArrayList();
  if (labels == null)   return turboLabels;
  for (  Label label : labels) {
    turboLabels.add(new TurboLabel(label));
  }
  return turboLabels;
}","private ObservableList<TurboLabel> translateLabels(List<Label> labels){
  ObservableList<TurboLabel> turboLabels=FXCollections.observableArrayList();
  if (labels == null) {
    return turboLabels;
  }
  turboLabels.addAll(labels.stream().map(label -> new TurboLabel(label)).collect(Collectors.toList()));
  return turboLabels;
}",0.7655502392344498
135366,"public void setLabels(List<TurboLabel> labels){
  if (this.labels != labels) {
    this.labels.clear();
    for (    TurboLabel label : labels) {
      addLabel(label);
    }
  }
}","public void setLabels(List<TurboLabel> labels){
  if (this.labels != labels) {
    this.labels.clear();
    labels.forEach(this::addLabel);
  }
}",0.8
135367,"/** 
 * A convenient string representation of this object, for purposes of readable logs.
 * @return
 */
public String logString(){
  return ""String_Node_Str"" + getId() + ""String_Node_Str""+ getTitle();
}","/** 
 * A convenient string representation of this object, for purposes of readable logs.
 * @return a string representation suitable for logs
 */
public String logString(){
  return ""String_Node_Str"" + getId() + ""String_Node_Str""+ getTitle();
}",0.90625
135368,"public void removeLabel(TurboLabel label){
  if (!labels.remove(label)) {
    return;
  }
}","public void removeLabel(TurboLabel label){
  labels.remove(label);
}",0.8553459119496856
135369,"public void removeLabels(List<TurboLabel> labList){
  for (  TurboLabel label : labList) {
    removeLabel(label);
  }
}","public void removeLabels(List<TurboLabel> toRemove){
  toRemove.forEach(this::removeLabel);
}",0.647887323943662
135370,"/** 
 * Given a list of issue events, returns a JavaFX node laying them out properly.
 * @param events
 * @return
 */
private static Node layoutEvents(List<TurboIssueEvent> events,List<Comment> comments){
  VBox result=new VBox();
  result.setSpacing(3);
  VBox.setMargin(result,new Insets(3,0,0,0));
  events.stream().map(TurboIssueEvent::display).forEach(e -> result.getChildren().add(e));
  if (comments.size() > 0) {
    String names=comments.stream().map(comment -> comment.getUser().getLogin()).distinct().collect(Collectors.joining(""String_Node_Str""));
    HBox commentDisplay=new HBox();
    commentDisplay.getChildren().addAll(TurboIssueEvent.octicon(TurboIssueEvent.OCTICON_QUOTE),new javafx.scene.control.Label(String.format(""String_Node_Str"",comments.size(),names)));
    result.getChildren().add(commentDisplay);
  }
  return result;
}","/** 
 * Given a list of issue events, returns a JavaFX node laying them out properly.
 * @param events
 * @param comments
 * @return
 */
private static Node layoutEvents(List<TurboIssueEvent> events,List<Comment> comments){
  VBox result=new VBox();
  result.setSpacing(3);
  VBox.setMargin(result,new Insets(3,0,0,0));
  events.stream().map(TurboIssueEvent::display).forEach(e -> result.getChildren().add(e));
  if (comments.size() > 0) {
    String names=comments.stream().map(comment -> comment.getUser().getLogin()).distinct().collect(Collectors.joining(""String_Node_Str""));
    HBox commentDisplay=new HBox();
    commentDisplay.getChildren().addAll(TurboIssueEvent.octicon(TurboIssueEvent.OCTICON_QUOTE),new javafx.scene.control.Label(String.format(""String_Node_Str"",comments.size(),names)));
    result.getChildren().add(commentDisplay);
  }
  return result;
}",0.9889212827988338
135371,"public static int extractIssueParent(String issueBody){
  if (issueBody == null) {
    return -1;
  }
  String[] lines=issueBody.split(REGEX_SPLIT_LINES);
  int seperatorLineIndex=getSeparatorIndex(lines);
  for (int i=0; i < seperatorLineIndex; i++) {
    String line=lines[i];
    if (line.startsWith(METADATA_HEADER_PARENT)) {
      String value=line.replace(METADATA_HEADER_PARENT,""String_Node_Str"");
      String[] valueTokens=value.split(REGEX_SPLIT_PARENT);
      for (int j=0; j < valueTokens.length; j++) {
        if (!valueTokens[j].trim().isEmpty()) {
          return Integer.parseInt(valueTokens[j].trim());
        }
      }
    }
 else     if (line.startsWith(OLD_METADATA_HEADER_PARENT)) {
      String value=line.replace(OLD_METADATA_HEADER_PARENT,""String_Node_Str"");
      String[] valueTokens=value.split(REGEX_SPLIT_PARENT);
      for (int j=0; j < valueTokens.length; j++) {
        if (!valueTokens[j].trim().isEmpty()) {
          return Integer.parseInt(valueTokens[j].trim());
        }
      }
    }
  }
  return -1;
}","public static int extractIssueParent(String issueBody){
  if (issueBody == null) {
    return -1;
  }
  String[] lines=issueBody.split(REGEX_SPLIT_LINES);
  int seperatorLineIndex=getSeparatorIndex(lines);
  for (int i=0; i < seperatorLineIndex; i++) {
    String line=lines[i];
    if (line.startsWith(METADATA_HEADER_PARENT)) {
      String value=line.replace(METADATA_HEADER_PARENT,""String_Node_Str"");
      String[] valueTokens=value.split(REGEX_SPLIT_PARENT);
      for (      String valueToken : valueTokens) {
        if (!valueToken.trim().isEmpty()) {
          return Integer.parseInt(valueToken.trim());
        }
      }
    }
 else     if (line.startsWith(OLD_METADATA_HEADER_PARENT)) {
      String value=line.replace(OLD_METADATA_HEADER_PARENT,""String_Node_Str"");
      String[] valueTokens=value.split(REGEX_SPLIT_PARENT);
      for (      String valueToken : valueTokens) {
        if (!valueToken.trim().isEmpty()) {
          return Integer.parseInt(valueToken.trim());
        }
      }
    }
  }
  return -1;
}",0.9431599229287092
135372,"public static String extractDescription(String issueBody){
  if (issueBody == null)   return ""String_Node_Str"";
  String description=issueBody.replaceAll(REGEX_REPLACE_DESC,""String_Node_Str"").trim();
  return description;
}","public static String extractDescription(String issueBody){
  if (issueBody == null) {
    return ""String_Node_Str"";
  }
  return issueBody.replaceAll(REGEX_REPLACE_DESC,""String_Node_Str"").trim();
}",0.8857142857142857
135373,"/** 
 * Given a list of issue events, returns a textual representation of them, concatenated together with newlines.
 * @param events
 * @return
 */
private static Node formatEventsText(List<TurboIssueEvent> events,int width){
  String text=events.stream().map(TurboIssueEvent::toString).collect(Collectors.joining(""String_Node_Str""));
  Text display=new Text(text);
  display.setWrappingWidth(width);
  display.getStyleClass().add(""String_Node_Str"");
  return display;
}","/** 
 * Given a list of issue events, returns a textual representation of them, concatenated together with newlines.
 * @param events
 * @param width
 * @return
 */
private static Node formatEventsText(List<TurboIssueEvent> events,int width){
  String text=events.stream().map(TurboIssueEvent::toString).collect(Collectors.joining(""String_Node_Str""));
  Text display=new Text(text);
  display.setWrappingWidth(width);
  display.getStyleClass().add(""String_Node_Str"");
  return display;
}",0.9832985386221296
135374,"private boolean typeSatisfies(TurboIssue issue){
  if (!content.isPresent())   return false;
  String content=this.content.get().toLowerCase();
  if (content.equals(""String_Node_Str"")) {
    return !isPullRequest(issue);
  }
 else   if (content.equals(""String_Node_Str"") || content.equals(""String_Node_Str"")) {
    return isPullRequest(issue);
  }
 else {
    return false;
  }
}","private boolean typeSatisfies(TurboIssue issue){
  if (!content.isPresent())   return false;
  String content=this.content.get().toLowerCase();
  if (content.equals(""String_Node_Str"")) {
    return !issue.isPullRequest();
  }
 else   if (content.equals(""String_Node_Str"") || content.equals(""String_Node_Str"")) {
    return issue.isPullRequest();
  }
 else {
    return false;
  }
}",0.9710526315789474
135375,"private boolean satisfiesIsConditions(TurboIssue issue){
  if (!content.isPresent())   return false;
switch (content.get()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    return stateSatisfies(issue);
case ""String_Node_Str"":
case ""String_Node_Str"":
  return typeSatisfies(issue);
case ""String_Node_Str"":
return isPullRequest(issue) && !issue.isOpen();
case ""String_Node_Str"":
return isPullRequest(issue) && issue.isOpen();
default :
return false;
}
}","private boolean satisfiesIsConditions(TurboIssue issue){
  if (!content.isPresent())   return false;
switch (content.get()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    return stateSatisfies(issue);
case ""String_Node_Str"":
case ""String_Node_Str"":
  return typeSatisfies(issue);
case ""String_Node_Str"":
return issue.isPullRequest() && !issue.isOpen();
case ""String_Node_Str"":
return issue.isPullRequest() && issue.isOpen();
default :
return false;
}
}",0.9759825327510916
135376,"public void updateIssueCheckTime(String date){
  this.lastIssueCheckTime=date;
}","public void updateIssueCheckTime(Date date){
  this.lastIssueCheckTime=date;
}",0.9493670886075948
135377,"public void updateModel(CountDownLatch latch,String repoId){
  logger.info(""String_Node_Str"");
  model.disableModelChanges();
  updateModelCollaborators(latch,repoId);
  updateModelLabels(latch,repoId);
  updateModelMilestones(latch,repoId);
  updateModelIssues(latch,repoId);
  lastUpdateTime=issueUpdateService.lastCheckTime;
  model.enableModelChanges();
}","public void updateModel(CountDownLatch latch,String repoId){
  logger.info(""String_Node_Str"");
  model.disableModelChanges();
  updateModelCollaborators(latch,repoId);
  updateModelLabels(latch,repoId);
  updateModelMilestones(latch,repoId);
  updateModelIssues(latch,repoId);
  lastUpdateTime=issueUpdateService.getUpdatedCheckTime();
  model.enableModelChanges();
}",0.977961432506887
135378,"private void updateModelIssues(CountDownLatch latch,String repoId){
  if (model.getRepoId().generateId().equals(repoId)) {
    List<Issue> updatedIssues=issueUpdateService.getUpdatedItems(RepositoryId.createFromId(repoId));
    if (updatedIssues.size() > 0) {
      model.updateIssuesETag(issueUpdateService.getLastETag());
      model.updateIssueCheckTime(issueUpdateService.getLastIssueCheckTime());
      model.updateCachedIssues(latch,updatedIssues,repoId);
    }
 else {
      logger.info(""String_Node_Str"");
      latch.countDown();
    }
  }
}","private void updateModelIssues(CountDownLatch latch,String repoId){
  if (model.getRepoId().generateId().equals(repoId)) {
    List<Issue> updatedIssues=issueUpdateService.getUpdatedItems(RepositoryId.createFromId(repoId));
    if (updatedIssues.size() > 0) {
      model.updateIssuesETag(issueUpdateService.getUpdatedETag());
      model.updateIssueCheckTime(issueUpdateService.getUpdatedCheckTime());
      model.updateCachedIssues(latch,updatedIssues,repoId);
    }
 else {
      logger.info(""String_Node_Str"");
      latch.countDown();
    }
  }
}",0.9754768392370572
135379,"public ModelUpdater(GitHubClientExtended client,Model model,String issuesETag,String collabsETag,String labelsETag,String milestonesETag,String issueCheckTime){
  this.model=model;
  this.issueUpdateService=new IssueUpdateService(client,issuesETag,issueCheckTime);
  this.collaboratorUpdateService=new CollaboratorUpdateService(client,collabsETag);
  this.labelUpdateService=new LabelUpdateService(client,labelsETag);
  this.milestoneUpdateService=new MilestoneUpdateService(client,milestonesETag);
}","public ModelUpdater(GitHubClientExtended client,Model model,String issuesETag,String collabsETag,String labelsETag,String milestonesETag,Date issueCheckTime){
  this.model=model;
  this.issueUpdateService=new IssueUpdateService(client,issuesETag,issueCheckTime);
  this.collaboratorUpdateService=new CollaboratorUpdateService(client,collabsETag);
  this.labelUpdateService=new LabelUpdateService(client,labelsETag);
  this.milestoneUpdateService=new MilestoneUpdateService(client,milestonesETag);
}",0.9899799599198396
135380,"private void updateModelMilestones(CountDownLatch latch,String repoId){
  if (model.getRepoId().generateId().equals(repoId)) {
    List<Milestone> milestones=milestoneUpdateService.getUpdatedItems(RepositoryId.createFromId(repoId));
    if (milestones.size() > 0) {
      model.updateMilestonesETag(milestoneUpdateService.getLastETag());
      model.updateCachedMilestones(latch,milestones,repoId);
    }
 else {
      logger.info(""String_Node_Str"");
      latch.countDown();
      HTStatusBar.addProgress(0.25);
    }
  }
}","private void updateModelMilestones(CountDownLatch latch,String repoId){
  if (model.getRepoId().generateId().equals(repoId)) {
    List<Milestone> milestones=milestoneUpdateService.getUpdatedItems(RepositoryId.createFromId(repoId));
    if (milestones.size() > 0) {
      model.updateMilestonesETag(milestoneUpdateService.getUpdatedETag());
      model.updateCachedMilestones(latch,milestones,repoId);
    }
 else {
      logger.info(""String_Node_Str"");
      latch.countDown();
      HTStatusBar.addProgress(0.25);
    }
  }
}",0.9895337773549
135381,"private void updateModelCollaborators(CountDownLatch latch,String repoId){
  if (model.getRepoId().generateId().equals(repoId)) {
    List<User> collaborators=collaboratorUpdateService.getUpdatedItems(RepositoryId.createFromId(repoId));
    if (collaborators.size() > 0) {
      model.updateCollabsETag(collaboratorUpdateService.getLastETag());
      model.updateCachedCollaborators(latch,collaborators,repoId);
    }
 else {
      logger.info(""String_Node_Str"");
      latch.countDown();
      HTStatusBar.addProgress(0.25);
    }
  }
}","private void updateModelCollaborators(CountDownLatch latch,String repoId){
  if (model.getRepoId().generateId().equals(repoId)) {
    List<User> collaborators=collaboratorUpdateService.getUpdatedItems(RepositoryId.createFromId(repoId));
    if (collaborators.size() > 0) {
      model.updateCollabsETag(collaboratorUpdateService.getUpdatedETag());
      model.updateCachedCollaborators(latch,collaborators,repoId);
    }
 else {
      logger.info(""String_Node_Str"");
      latch.countDown();
      HTStatusBar.addProgress(0.25);
    }
  }
}",0.989786443825441
135382,"private void updateModelLabels(CountDownLatch latch,String repoId){
  if (model.getRepoId().generateId().equals(repoId)) {
    List<Label> labels=labelUpdateService.getUpdatedItems(RepositoryId.createFromId(repoId));
    if (labels.size() > 0) {
      model.updateLabelsETag(labelUpdateService.getLastETag());
      model.updateCachedLabels(latch,labels,repoId);
    }
 else {
      logger.info(""String_Node_Str"");
      latch.countDown();
      HTStatusBar.addProgress(0.25);
    }
  }
}","private void updateModelLabels(CountDownLatch latch,String repoId){
  if (model.getRepoId().generateId().equals(repoId)) {
    List<Label> labels=labelUpdateService.getUpdatedItems(RepositoryId.createFromId(repoId));
    if (labels.size() > 0) {
      model.updateLabelsETag(labelUpdateService.getUpdatedETag());
      model.updateCachedLabels(latch,labels,repoId);
    }
 else {
      logger.info(""String_Node_Str"");
      latch.countDown();
      HTStatusBar.addProgress(0.25);
    }
  }
}",0.9887640449438202
135383,"@SuppressWarnings(""String_Node_Str"") public HashMap<String,List> getResources(RepositoryId repoId) throws IOException {
  this.repoId=repoId;
  CacheFileHandler dcHandler=new CacheFileHandler(repoId.toString());
  model.setDataCacheFileHandler(dcHandler);
  model.setRepoId(repoId);
  boolean needToGetResources=true;
  CachedRepoData repo=dcHandler.getRepo();
  if (repo != null) {
    needToGetResources=false;
  }
  if (!needToGetResources) {
    logger.info(""String_Node_Str"");
    issuesETag=repo.getIssuesETag();
    collabsETag=repo.getCollaboratorsETag();
    labelsETag=repo.getLabelsETag();
    milestonesETag=repo.getMilestonesETag();
    issueCheckTime=repo.getIssueCheckTime();
    List<TurboUser> collaborators=repo.getCollaborators();
    List<TurboLabel> labels=repo.getLabels();
    List<TurboMilestone> milestones=repo.getMilestones();
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,collaborators);
    map.put(KEY_LABELS,labels);
    map.put(KEY_MILESTONES,milestones);
    return map;
  }
 else {
    logger.info(""String_Node_Str"");
    return getGitHubResources();
  }
}","@SuppressWarnings(""String_Node_Str"") public HashMap<String,List> getResources(RepositoryId repoId) throws IOException {
  this.repoId=repoId;
  CacheFileHandler dcHandler=new CacheFileHandler(repoId.toString());
  model.setDataCacheFileHandler(dcHandler);
  model.setRepoId(repoId);
  boolean needToGetResources=true;
  CachedRepoData repo=dcHandler.getRepo();
  if (repo != null) {
    needToGetResources=false;
  }
  if (!needToGetResources) {
    logger.info(""String_Node_Str"");
    issuesETag=repo.getIssuesETag();
    collabsETag=repo.getCollaboratorsETag();
    labelsETag=repo.getLabelsETag();
    milestonesETag=repo.getMilestonesETag();
    issueCheckTime=Utility.localDateTimeToDate(repo.getIssueCheckTime());
    List<TurboUser> collaborators=repo.getCollaborators();
    List<TurboLabel> labels=repo.getLabels();
    List<TurboMilestone> milestones=repo.getMilestones();
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,collaborators);
    map.put(KEY_LABELS,labels);
    map.put(KEY_MILESTONES,milestones);
    return map;
  }
 else {
    logger.info(""String_Node_Str"");
    return getGitHubResources();
  }
}",0.9873417721518988
135384,"public IssueUpdateService(GitHubClientExtended client,String issuesETag,String lastIssueCheckTime){
  super(client,SEGMENT_ISSUES,issuesETag);
  lastCheckTime=new Date();
  super.setLastIssueCheckTime(lastIssueCheckTime);
}","public IssueUpdateService(GitHubClientExtended client,String issuesETag,Date lastIssueCheckTime){
  super(client,SEGMENT_ISSUES,issuesETag);
  this.lastIssueCheckTime=lastIssueCheckTime;
}",0.7931873479318735
135385,"private Map<String,String> createUpdatedIssuesParams(){
  Map<String,String> params=new HashMap<String,String>();
  params.put(""String_Node_Str"",getFormattedDate(lastCheckTime));
  params.put(""String_Node_Str"",""String_Node_Str"");
  return params;
}","private Map<String,String> createUpdatedIssuesParams(){
  Map<String,String> params=new HashMap<>();
  params.put(""String_Node_Str"",Utility.formatDateISO8601(lastIssueCheckTime));
  params.put(""String_Node_Str"",""String_Node_Str"");
  return params;
}",0.89738430583501
135386,"public void writeToFile(String repoIdString,String issuesETag,String collabsETag,String labelsETag,String milestonesETag,String issueCheckTime,List<TurboUser> collaborators,List<TurboLabel> labels,List<TurboMilestone> milestones,List<TurboIssue> issues){
  CachedRepoData currentRepoData=new CachedRepoData(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,new ArrayList<>(collaborators),new ArrayList<>(labels),new ArrayList<>(milestones),new ArrayList<>(issues));
  Gson gson=new GsonBuilder().setPrettyPrinting().registerTypeAdapter(LocalDateTime.class,new LocalDateTimeAdapter()).create();
  String json=gson.toJson(currentRepoData);
  try {
    FileWriter writer=new FileWriter(getFileName(FILE_DATA_CACHE_TEMP,repoIdString));
    writer.write(json);
    writer.close();
    File file=new File(getFileName(FILE_DATA_CACHE,repoIdString));
    if (file.exists() && !file.delete()) {
      logger.error(""String_Node_Str"");
    }
    File newFile=new File(getFileName(FILE_DATA_CACHE_TEMP,repoIdString));
    if (!newFile.renameTo(file)) {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    logger.error(e.getLocalizedMessage(),e);
  }
  logger.info(""String_Node_Str"" + repoIdString + ""String_Node_Str""+ issueCheckTime);
}","public void writeToFile(String repoIdString,String issuesETag,String collabsETag,String labelsETag,String milestonesETag,Date issueCheckTime,List<TurboUser> collaborators,List<TurboLabel> labels,List<TurboMilestone> milestones,List<TurboIssue> issues){
  CachedRepoData currentRepoData=new CachedRepoData(issuesETag,collabsETag,labelsETag,milestonesETag,Utility.dateToLocalDateTime(issueCheckTime),new ArrayList<>(collaborators),new ArrayList<>(labels),new ArrayList<>(milestones),new ArrayList<>(issues));
  Gson gson=new GsonBuilder().setPrettyPrinting().registerTypeAdapter(LocalDateTime.class,new LocalDateTimeAdapter()).create();
  String json=gson.toJson(currentRepoData);
  try {
    FileWriter writer=new FileWriter(getFileName(FILE_DATA_CACHE_TEMP,repoIdString));
    writer.write(json);
    writer.close();
    File file=new File(getFileName(FILE_DATA_CACHE,repoIdString));
    if (file.exists() && !file.delete()) {
      logger.error(""String_Node_Str"");
    }
    File newFile=new File(getFileName(FILE_DATA_CACHE_TEMP,repoIdString));
    if (!newFile.renameTo(file)) {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    logger.error(e.getLocalizedMessage(),e);
  }
  logger.info(""String_Node_Str"" + repoIdString + ""String_Node_Str""+ issueCheckTime);
}",0.984759671746776
135387,"public CachedRepoData(String issuesETag,String collabsETag,String labelsETag,String milestonesETag,String issueCheckTime,List<TurboUser> collaborators,List<TurboLabel> labels,List<TurboMilestone> milestones,List<TurboIssue> issues){
  this.issuesETag=issuesETag;
  this.collabsETag=collabsETag;
  this.labelsETag=labelsETag;
  this.milestonesETag=milestonesETag;
  this.issueCheckTime=issueCheckTime;
  this.collaborators=collaborators;
  this.labels=new ArrayList<SerializableLabel>();
  if (this.labels != null) {
    for (    TurboLabel label : labels) {
      this.labels.add(new SerializableLabel(label));
    }
  }
  this.milestones=new ArrayList<SerializableMilestone>();
  if (this.milestones != null) {
    for (    TurboMilestone milestone : milestones) {
      this.milestones.add(new SerializableMilestone(milestone));
    }
  }
  this.issues=new ArrayList<SerializableIssue>();
  if (this.issues != null) {
    for (    TurboIssue issue : issues) {
      this.issues.add(new SerializableIssue(issue));
    }
  }
}","public CachedRepoData(String issuesETag,String collabsETag,String labelsETag,String milestonesETag,LocalDateTime issueCheckTime,List<TurboUser> collaborators,List<TurboLabel> labels,List<TurboMilestone> milestones,List<TurboIssue> issues){
  this.issuesETag=issuesETag;
  this.collabsETag=collabsETag;
  this.labelsETag=labelsETag;
  this.milestonesETag=milestonesETag;
  this.issueCheckTime=issueCheckTime;
  this.collaborators=collaborators;
  this.labels=new ArrayList<SerializableLabel>();
  if (this.labels != null) {
    for (    TurboLabel label : labels) {
      this.labels.add(new SerializableLabel(label));
    }
  }
  this.milestones=new ArrayList<SerializableMilestone>();
  if (this.milestones != null) {
    for (    TurboMilestone milestone : milestones) {
      this.milestones.add(new SerializableMilestone(milestone));
    }
  }
  this.issues=new ArrayList<SerializableIssue>();
  if (this.issues != null) {
    for (    TurboIssue issue : issues) {
      this.issues.add(new SerializableIssue(issue));
    }
  }
}",0.9907722195240408
135388,"public String getIssueCheckTime(){
  return issueCheckTime;
}","public LocalDateTime getIssueCheckTime(){
  return issueCheckTime;
}",0.8837209302325582
135389,"private void setup(){
  setPrefColumnCount(30);
  validationSupport.registerValidator(this,(c,newValue) -> {
    boolean wasError=false;
    try {
      Parser.parse(getText());
    }
 catch (    ParseException e) {
      wasError=true;
    }
    return ValidationResult.fromErrorIf(this,""String_Node_Str"",wasError);
  }
);
  setOnKeyTyped(e -> {
    boolean isModifierKeyPress=e.isAltDown() || e.isMetaDown() || e.isControlDown();
    String key=e.getCharacter();
    if (key == null || key.isEmpty() || isModifierKeyPress) {
      return;
    }
    char typed=e.getCharacter().charAt(0);
    if (typed == ')') {
      if (getCharAfterCaret().equals(""String_Node_Str"")) {
        e.consume();
        positionCaret(getCaretPosition() + 1);
      }
    }
 else     if (typed == '(') {
      e.consume();
      insertMatchingBracket();
    }
 else     if (typed == '\t') {
      e.consume();
      if (getSelectedText().isEmpty()) {
        movePastRemainingBrackets();
      }
 else {
        confirmCompletion();
      }
    }
 else     if (typed == '\b') {
    }
 else     if (Character.isAlphabetic(typed)) {
      performCompletion(e);
    }
 else     if (typed == ' ' && getText().isEmpty()) {
      e.consume();
    }
  }
);
  setOnKeyPressed(e -> {
    if (e.getCode() == KeyCode.TAB) {
      e.consume();
    }
  }
);
  setOnKeyReleased(e -> {
    if (e.getCode() == KeyCode.ENTER) {
      confirmEdit();
    }
 else     if (e.getCode() == KeyCode.ESCAPE) {
      revertEdit();
      getParent().requestFocus();
    }
  }
);
}","private void setup(){
  setPrefColumnCount(30);
  validationSupport.registerValidator(this,(c,newValue) -> {
    boolean wasError=false;
    try {
      Parser.parse(getText());
    }
 catch (    ParseException e) {
      wasError=true;
    }
    return ValidationResult.fromErrorIf(this,""String_Node_Str"",wasError);
  }
);
  setOnKeyTyped(e -> {
    boolean isModifierKeyPress=e.isAltDown() || e.isMetaDown() || e.isControlDown();
    String key=e.getCharacter();
    if (key == null || key.isEmpty() || isModifierKeyPress) {
      return;
    }
    char typed=e.getCharacter().charAt(0);
    if (typed == ')') {
      if (getCharAfterCaret().equals(""String_Node_Str"")) {
        e.consume();
        positionCaret(getCaretPosition() + 1);
      }
    }
 else     if (typed == '(') {
      e.consume();
      insertMatchingBracket();
    }
 else     if (typed == '\t') {
      e.consume();
      if (getSelectedText().isEmpty()) {
        movePastRemainingBrackets();
      }
 else {
        confirmCompletion();
      }
    }
 else     if (typed == '\b') {
    }
 else     if (Character.isAlphabetic(typed)) {
      performCompletion(e);
    }
 else     if (typed == ' ' && (getText().isEmpty() || getText().endsWith(""String_Node_Str""))) {
      e.consume();
    }
  }
);
  setOnKeyPressed(e -> {
    if (e.getCode() == KeyCode.TAB) {
      e.consume();
    }
  }
);
  setOnKeyReleased(e -> {
    if (e.getCode() == KeyCode.ENTER) {
      confirmEdit();
    }
 else     if (e.getCode() == KeyCode.ESCAPE) {
      revertEdit();
      getParent().requestFocus();
    }
  }
);
}",0.9861780777884924
135390,"private void handleKeys(boolean isDownKey){
  if (!currentlySelectedColumn.isPresent())   return;
  if (getChildren().size() == 0)   return;
  Column selectedColumn=getColumn(currentlySelectedColumn.get());
  if (selectedColumn instanceof IssueColumn) {
    if (((IssueColumn)selectedColumn).filterTextField.isFocused()) {
      return;
    }
 else {
      int newIndex=currentlySelectedColumn.get() + (isDownKey ? 1 : -1);
      newIndex=Math.min(Math.max(0,newIndex),getChildren().size() - 1);
      currentlySelectedColumn=Optional.of(newIndex);
      selectedColumn=getColumn(currentlySelectedColumn.get());
      ((IssueColumn)selectedColumn).filterTextField.requestFocus();
    }
  }
}","private void handleKeys(boolean isForwardKey){
  if (!currentlySelectedColumn.isPresent())   return;
  if (getChildren().size() == 0)   return;
  Column selectedColumn=getColumn(currentlySelectedColumn.get());
  if (selectedColumn instanceof IssueColumn) {
    if (((IssueColumn)selectedColumn).filterTextField.isFocused()) {
      return;
    }
 else {
      int newIndex=currentlySelectedColumn.get() + (isForwardKey ? 1 : -1);
      newIndex=Math.min(Math.max(0,newIndex),getChildren().size() - 1);
      currentlySelectedColumn=Optional.of(newIndex);
      selectedColumn=getColumn(currentlySelectedColumn.get());
      ((IssueColumn)selectedColumn).requestFocus();
    }
  }
}",0.9664723032069972
135391,"private void setupKeyboardShortcuts(){
  filterTextField.addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      if (keyCombBoxToList.match(event)) {
        listView.selectFirstItem();
      }
      if (event.getCode() == KeyCode.SPACE) {
        if (KeyPress.isDoublePress(event,System.currentTimeMillis())) {
          event.consume();
          listView.selectFirstItem();
        }
      }
    }
  }
);
  listView.addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      if (event.getCode() == KeyCode.C) {
        ui.getBrowserComponent().jumpToComment();
      }
    }
  }
);
  this.addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      if (event.getCode() == KeyCode.F5) {
        ServiceManager.getInstance().updateModelNow();
      }
      if (keyCombListToBox.match(event)) {
        filterTextField.requestFocus();
      }
      if (event.getCode() == KeyCode.SPACE) {
        if (KeyPress.isDoublePress(event,System.currentTimeMillis())) {
          filterTextField.requestFocus();
        }
      }
    }
  }
);
}","private void setupKeyboardShortcuts(){
  filterTextField.addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      if (keyCombBoxToList.match(event)) {
        listView.selectFirstItem();
      }
      if (event.getCode() == KeyCode.SPACE) {
        if (KeyPress.isDoublePress(event,System.currentTimeMillis())) {
          KeyPress.setTimeKeyDown(0);
          event.consume();
          listView.selectFirstItem();
        }
      }
    }
  }
);
  listView.addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      if (event.getCode() == KeyCode.C) {
        ui.getBrowserComponent().jumpToComment();
      }
    }
  }
);
  this.addEventHandler(KeyEvent.KEY_RELEASED,new EventHandler<KeyEvent>(){
    public void handle(    KeyEvent event){
      if (event.getCode() == KeyCode.F5) {
        ServiceManager.getInstance().updateModelNow();
      }
      if (keyCombListToBox.match(event)) {
        filterTextField.requestFocus();
      }
      if (event.getCode() == KeyCode.SPACE) {
        if (KeyPress.isDoublePress(event,System.currentTimeMillis())) {
          filterTextField.requestFocus();
        }
      }
    }
  }
);
}",0.9845904298459044
135392,"public static boolean isDoublePress(KeyEvent event,long KeyEventTime){
  if ((KeyEventTime - timeKeyDown) < doublePressSpeed) {
    return true;
  }
 else {
    timeKeyDown=KeyEventTime;
  }
  lastKeyPressedCode=event.getCode();
  return false;
}","public static boolean isDoublePress(KeyEvent event,long KeyEventTime){
  if ((KeyEventTime - timeKeyDown) < doublePressSpeed) {
    return true;
  }
 else {
    timeKeyDown=KeyEventTime;
  }
  return false;
}",0.9162995594713657
135393,"public Node getEventDisplay(int width,final int withinHours){
  final LocalDateTime now=LocalDateTime.now();
  List<TurboIssueEvent> eventsWithinDuration=events.stream().filter(event -> {
    LocalDateTime eventTime=Utility.longToLocalDateTime(event.getDate().getTime());
    int hours=Utility.safeLongToInt(getUpdatedAt().until(now,ChronoUnit.HOURS));
    return hours < withinHours;
  }
).collect(Collectors.toList());
  return layoutEvents(eventsWithinDuration);
}","public Node getEventDisplay(int width,final int withinHours){
  final LocalDateTime now=LocalDateTime.now();
  List<TurboIssueEvent> eventsWithinDuration=events.stream().filter(event -> {
    LocalDateTime eventTime=Utility.longToLocalDateTime(event.getDate().getTime());
    int hours=Utility.safeLongToInt(eventTime.until(now,ChronoUnit.HOURS));
    return hours < withinHours;
  }
).collect(Collectors.toList());
  return layoutEvents(eventsWithinDuration);
}",0.9752421959095802
135394,"public String toGhName(){
  String groupDelimiter=isExclusive ? EXCLUSIVE_DELIM : NONEXCLUSIVE_DELIM;
  String groupPrefix=getGroup() == null ? ""String_Node_Str"" : getGroup() + groupDelimiter;
  String groupAppended=groupPrefix + getName();
  return groupAppended;
}","public String toGhName(){
  String groupDelimiter=isExclusive ? EXCLUSIVE_DELIM : NONEXCLUSIVE_DELIM;
  String groupPrefix=(getGroup() == null || getGroup().isEmpty()) ? ""String_Node_Str"" : getGroup() + groupDelimiter;
  String groupAppended=groupPrefix + getName();
  return groupAppended;
}",0.8888888888888888
135395,"private void setupMainStage(Scene scene){
  mainStage.setTitle(""String_Node_Str"" + Utility.version(VERSION_MAJOR,VERSION_MINOR,VERSION_PATCH));
  mainStage.setScene(scene);
  mainStage.show();
  mainStage.setOnCloseRequest(e -> quit());
  initialiseJNA();
  mainStage.focusedProperty().addListener(new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> unused,    Boolean wasFocused,    Boolean isFocused){
      if (isFocused) {
        if (PlatformSpecific.isOnWindows()) {
          browserComponent.focus(mainWindowHandle);
        }
        PlatformEx.runLaterDelayed(() -> {
          boolean shouldRefresh=isRepoSwitchingAllowed() && !repoSelector.isInFocus();
          if (shouldRefresh) {
            logger.info(""String_Node_Str"");
            ServiceManager.getInstance().updateModelNow();
            ServiceManager.getInstance().resetTimeRemainingUntilRefresh();
          }
        }
);
      }
    }
  }
);
}","private void setupMainStage(Scene scene){
  mainStage.setTitle(""String_Node_Str"" + Utility.version(VERSION_MAJOR,VERSION_MINOR,VERSION_PATCH));
  mainStage.setScene(scene);
  mainStage.show();
  mainStage.setOnCloseRequest(e -> quit());
  initialiseJNA();
  mainStage.focusedProperty().addListener(new ChangeListener<Boolean>(){
    @Override public void changed(    ObservableValue<? extends Boolean> unused,    Boolean wasFocused,    Boolean isFocused){
      if (!isFocused) {
        return;
      }
      if (PlatformSpecific.isOnWindows()) {
        browserComponent.focus(mainWindowHandle);
      }
      PlatformEx.runLaterDelayed(() -> {
        boolean shouldRefresh=isRepoSwitchingAllowed() && !repoSelector.isInFocus();
        if (shouldRefresh) {
          logger.info(""String_Node_Str"");
          ServiceManager.getInstance().updateModelNow();
          ServiceManager.getInstance().resetTimeRemainingUntilRefresh();
        }
      }
);
    }
  }
);
}",0.9706336939721792
135396,"@Override public void changed(ObservableValue<? extends Boolean> unused,Boolean wasFocused,Boolean isFocused){
  if (isFocused) {
    if (PlatformSpecific.isOnWindows()) {
      browserComponent.focus(mainWindowHandle);
    }
    PlatformEx.runLaterDelayed(() -> {
      boolean shouldRefresh=isRepoSwitchingAllowed() && !repoSelector.isInFocus();
      if (shouldRefresh) {
        logger.info(""String_Node_Str"");
        ServiceManager.getInstance().updateModelNow();
        ServiceManager.getInstance().resetTimeRemainingUntilRefresh();
      }
    }
);
  }
}","@Override public void changed(ObservableValue<? extends Boolean> unused,Boolean wasFocused,Boolean isFocused){
  if (!isFocused) {
    return;
  }
  if (PlatformSpecific.isOnWindows()) {
    browserComponent.focus(mainWindowHandle);
  }
  PlatformEx.runLaterDelayed(() -> {
    boolean shouldRefresh=isRepoSwitchingAllowed() && !repoSelector.isInFocus();
    if (shouldRefresh) {
      logger.info(""String_Node_Str"");
      ServiceManager.getInstance().updateModelNow();
      ServiceManager.getInstance().resetTimeRemainingUntilRefresh();
    }
  }
);
}",0.9650850492390332
135397,"/** 
 * Downloads the resources of the current repository from GitHub, bypassing the cache, then populates the fields of this class with them. Does not perform network operations in test mode, instead loading stub data from cache.
 * @throws IOException
 */
@SuppressWarnings(""String_Node_Str"") public void forceReloadComponents() throws IOException {
  if (isInTestMode) {
    populateComponents(repoId,TestUtils.getStubResources(this,10));
  }
  HashMap<String,List> items=ServiceManager.getInstance().getGitHubResources();
  populateComponents(repoId,items);
}","/** 
 * Downloads the resources of the current repository from GitHub, bypassing the cache, then populates the fields of this class with them. Does not perform network operations in test mode, instead loading stub data from cache.
 * @throws IOException
 */
@SuppressWarnings(""String_Node_Str"") public void forceReloadComponents() throws IOException {
  if (isInTestMode) {
    populateComponents(repoId,TestUtils.getStubResources(this,10));
    return;
  }
  HashMap<String,List> items=ServiceManager.getInstance().getGitHubResources();
  populateComponents(repoId,items);
}",0.9894551845342706
135398,"public TurboUser getUserByGhName(String name){
  for (int i=0; i < labels.size(); i++) {
    if (collaborators.get(i).getGithubName().equals(name)) {
      return collaborators.get(i);
    }
  }
  return null;
}","public TurboUser getUserByGhName(String name){
  for (int i=0; i < collaborators.size(); i++) {
    if (collaborators.get(i).getGithubName().equals(name)) {
      return collaborators.get(i);
    }
  }
  return null;
}",0.9603729603729604
135399,"/** 
 * Ensures that the chromedriver executable is in the project root before initialisation. Since executables are packaged for all platforms, this also picks the right version to use.
 */
private static void setupChromeDriverExecutable(){
  String binaryFileName=PlatformSpecific.isOnMac() ? ""String_Node_Str"" : PlatformSpecific.isOnWindows() ? ""String_Node_Str"" : ""String_Node_Str"";
  File f=new File(binaryFileName);
  if (!f.exists()) {
    InputStream in=BrowserComponent.class.getClassLoader().getResourceAsStream(""String_Node_Str"" + binaryFileName);
    OutputStream out;
    try {
      out=new FileOutputStream(binaryFileName);
      IOUtils.copy(in,out);
      out.close();
      f.setExecutable(true);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
    }
    System.out.println(""String_Node_Str"" + binaryFileName + ""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"" + binaryFileName);
  }
  System.setProperty(""String_Node_Str"",binaryFileName);
}","/** 
 * Ensures that the chromedriver executable is in the project root before initialisation. Since executables are packaged for all platforms, this also picks the right version to use.
 */
private static void setupChromeDriverExecutable(){
}",0.3799843627834245
135400,"private List<IssueEvent> getGithubFeed(){
  List<IssueEvent> feeds=new ArrayList<IssueEvent>();
  try {
    feeds=ServiceManager.getInstance().getFeeds(getId());
  }
 catch (  Exception e) {
    logger.error(e.getLocalizedMessage(),e);
  }
  return feeds;
}","private List<TurboIssueEvent> getGithubFeed(){
  List<TurboIssueEvent> feeds=new ArrayList<TurboIssueEvent>();
  try {
    feeds=ServiceManager.getInstance().getFeeds(getId());
  }
 catch (  Exception e) {
    logger.error(e.getLocalizedMessage(),e);
  }
  return feeds;
}",0.9716446124763704
135401,"private String formatFeeds(int hours,int minutes,int seconds){
  LocalDateTime currentTime=LocalDateTime.now();
  LocalDateTime cutoffTime=currentTime.minusHours(hours).minusMinutes(minutes).minusSeconds(seconds);
  ArrayList<String> feedMessages=new ArrayList<String>();
  String previousMessage=""String_Node_Str"";
  String currentMessage=""String_Node_Str"";
  boolean isFirstEvent=true;
  for (  IssueEvent event : issueFeeds) {
    if (LocalDateTime.ofInstant(event.getCreatedAt().toInstant(),ZoneId.systemDefault()).isAfter(cutoffTime)) {
      currentMessage=formatMessage(event);
      if (isFirstEvent) {
        feedMessages.add(currentMessage);
        isFirstEvent=false;
        previousMessage=currentMessage;
      }
 else       if (!currentMessage.equals(previousMessage)) {
        feedMessages.add(currentMessage);
        previousMessage=currentMessage;
      }
    }
  }
  StringBuffer stringBuffer=new StringBuffer();
  for (int i=feedMessages.size() - 1; i > 0; i--) {
    if (i == feedMessages.size()) {
      stringBuffer.append(feedMessages.get(i - 1));
    }
 else {
      stringBuffer.append(NEW_LINE + feedMessages.get(i - 1));
    }
  }
  return stringBuffer.toString();
}","private String formatFeeds(int hours,int minutes,int seconds){
  LocalDateTime currentTime=LocalDateTime.now();
  LocalDateTime cutoffTime=currentTime.minusHours(hours).minusMinutes(minutes).minusSeconds(seconds);
  ArrayList<String> feedMessages=new ArrayList<String>();
  ArrayList<String> tempMessages=new ArrayList<String>();
  ArrayList<IssueEventType> eventSeq=new ArrayList<IssueEventType>();
  previousActor=""String_Node_Str"";
  previousPTime=""String_Node_Str"";
  previousMessage=""String_Node_Str"";
  currentMessage=""String_Node_Str"";
  for (  TurboIssueEvent event : issueFeeds) {
    if (LocalDateTime.ofInstant(event.getDate().toInstant(),ZoneId.systemDefault()).isAfter(cutoffTime)) {
      if (isNewEvent(event)) {
        feedMessages.addAll(outputToBuffer(tempMessages,eventSeq));
        tempMessages.clear();
        eventSeq.clear();
      }
      eventSeq.add(event.getType());
      System.out.println(""String_Node_Str"" + event.getType().toString());
      currentMessage=formatMessage(currentActor,currentPTime,event);
      if (currentMessage != null && !currentMessage.isEmpty() && !currentMessage.equals(previousMessage)) {
        tempMessages.add(currentMessage);
        previousMessage=currentMessage;
      }
    }
  }
  feedMessages.addAll(outputToBuffer(tempMessages,eventSeq));
  return outputReverseOrder(feedMessages);
}",0.3652037617554859
135402,"private String formatMessage(IssueEvent issueEvent){
  PrettyTime pt=new PrettyTime();
  String timeString=pt.format(issueEvent.getCreatedAt());
  String actorName=issueEvent.getActor().getLogin();
  Issue issue=issueEvent.getIssue();
  String milestoneTitle=""String_Node_Str"";
  String message=""String_Node_Str"";
switch (IssueEventType.fromString(issueEvent.getEvent())) {
case Renamed:
    message=String.format(""String_Node_Str"",actorName,timeString);
  break;
case Milestoned:
if (issue.getMilestone() != null) {
  milestoneTitle=issue.getMilestone().getTitle();
}
message=String.format(""String_Node_Str"",actorName,milestoneTitle,timeString);
break;
case Demilestoned:
if (issue.getMilestone() != null) {
milestoneTitle=issue.getMilestone().getTitle();
}
message=String.format(""String_Node_Str"",actorName,milestoneTitle,timeString);
break;
case Labeled:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Unlabeled:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Assigned:
String assignee=""String_Node_Str"";
if (issue.getAssignee() != null) {
assignee=issue.getAssignee().getLogin();
}
if (actorName.equalsIgnoreCase(assignee)) {
message=String.format(""String_Node_Str"",assignee,timeString);
}
 else {
message=String.format(""String_Node_Str"",assignee,actorName,timeString);
}
break;
case Unassigned:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Closed:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Reopened:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Locked:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Unlocked:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Referenced:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Subscribed:
case Mentioned:
case Merged:
case HeadRefDeleted:
case HeadRefRestored:
default :
message=String.format(""String_Node_Str"",actorName,issueEvent.getEvent(),timeString);
break;
}
return message;
}","private String formatMessage(String actorName,String timeString,TurboIssueEvent issueEvent){
  String message=""String_Node_Str"";
switch (issueEvent.getType()) {
case Renamed:
    message=String.format(""String_Node_Str"",actorName,timeString);
  break;
case Milestoned:
milestonedCount++;
milestonesAdded.add(issueEvent.getMilestoneTitle());
break;
case Demilestoned:
demilestonedCount++;
milestonesRemoved.add(issueEvent.getMilestoneTitle());
break;
case Labeled:
labeledCount++;
labelsAdded.add(issueEvent.getLabelName());
break;
case Unlabeled:
unlabeledCount++;
labelsRemoved.add(issueEvent.getLabelName());
break;
case Assigned:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Unassigned:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Closed:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Reopened:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Locked:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Unlocked:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Referenced:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Subscribed:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Mentioned:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case Merged:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case HeadRefDeleted:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
case HeadRefRestored:
message=String.format(""String_Node_Str"",actorName,timeString);
break;
default :
message=String.format(""String_Node_Str"",actorName,issueEvent.getType().toString(),timeString);
}
return message;
}",0.074074074074074
135403,"/** 
 * Services for IssueEvent
 */
public List<IssueEvent> getFeeds(int issueNum) throws IOException {
  ArrayList<IssueEvent> eventList=new ArrayList<IssueEvent>();
  String user=getRepoOwner();
  String repo=getRepoName();
  boolean toContinue=true;
  PageIterator<IssueEvent> iter=issueService.pageIssueEvents(user,repo,issueNum);
  if (iter != null && iter.hasNext()) {
    for (    Collection<IssueEvent> currentPage : iter) {
      if (!currentPage.isEmpty()) {
        for (        IssueEvent event : currentPage) {
          if (event != null) {
            IssueEvent fetched=issueService.getIssueEvent(user,repo,event.getId());
            if (fetched != null) {
              if (eventList.size() < MAX_FEED) {
                eventList.add(fetched);
              }
 else {
                toContinue=false;
                break;
              }
            }
          }
        }
      }
      if (!toContinue) {
        break;
      }
    }
  }
  return eventList;
}","/** 
 * Services for IssueEvent
 */
public List<TurboIssueEvent> getFeeds(int issueNum) throws IOException {
  GitHubEventsResponse ghEventsResponse=issueService.getIssueEvents(getRepoId(),issueNum);
  return ghEventsResponse.getTurboIssueEvents();
}",0.1897810218978102
135404,"private void setupMouseEvents(){
  setOnMouseClicked(e -> {
    int currentlySelected=getSelectionModel().getSelectedIndex();
    if (currentlySelected != -1) {
      selectedIndex=Optional.of(currentlySelected);
    }
    logger.info(""String_Node_Str"" + selectedIndex.get());
    onItemSelected.accept(selectedIndex.get());
  }
);
}","private void setupMouseEvents(){
  setOnMouseClicked(e -> {
    int currentlySelected=getSelectionModel().getSelectedIndex();
    if (currentlySelected != -1) {
      selectedIndex=Optional.of(currentlySelected);
      logger.info(""String_Node_Str"" + selectedIndex.get());
      onItemSelected.accept(selectedIndex.get());
    }
  }
);
}",0.9731343283582088
135405,"private boolean satisfiesIsConditions(TurboIssue issue){
  if (!content.isPresent())   return false;
switch (content.get()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    return stateSatisfies(issue);
case ""String_Node_Str"":
case ""String_Node_Str"":
  return typeSatisfies(issue);
case ""String_Node_Str"":
case ""String_Node_Str"":
return isPullRequest(issue) && !issue.isOpen();
default :
return false;
}
}","private boolean satisfiesIsConditions(TurboIssue issue){
  if (!content.isPresent())   return false;
switch (content.get()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    return stateSatisfies(issue);
case ""String_Node_Str"":
case ""String_Node_Str"":
  return typeSatisfies(issue);
case ""String_Node_Str"":
return isPullRequest(issue) && !issue.isOpen();
case ""String_Node_Str"":
return isPullRequest(issue) && issue.isOpen();
default :
return false;
}
}",0.8904267589388697
135406,"private boolean satisfiesUpdatedHours(TurboIssue issue){
  if (!numberRange.isPresent())   return false;
  long hours=LocalDateTime.now().until(issue.getUpdatedAt(),ChronoUnit.HOURS);
  return numberRange.get().encloses(Utility.safeLongToInt(hours));
}","private boolean satisfiesUpdatedHours(TurboIssue issue){
  if (!numberRange.isPresent())   return false;
  long hours=issue.getUpdatedAt().until(LocalDateTime.now(),ChronoUnit.HOURS);
  return numberRange.get().encloses(Utility.safeLongToInt(hours));
}",0.8928571428571429
135407,"@Override public void refreshItems(){
  super.refreshItems();
  WeakReference<IssuePanel> that=new WeakReference<IssuePanel>(this);
  listView.setCellFactory(new Callback<ListView<TurboIssue>,ListCell<TurboIssue>>(){
    @Override public ListCell<TurboIssue> call(    ListView<TurboIssue> list){
      if (that.get() != null) {
        return new IssuePanelCell(ui,model,that.get(),columnIndex);
      }
 else {
        return null;
      }
    }
  }
);
  listView.setItems(null);
  listView.setItems(getIssueList());
}","@Override public void refreshItems(){
  super.refreshItems();
  WeakReference<IssuePanel> that=new WeakReference<IssuePanel>(this);
  listView.setCellFactory(new Callback<ListView<TurboIssue>,ListCell<TurboIssue>>(){
    @Override public ListCell<TurboIssue> call(    ListView<TurboIssue> list){
      if (that.get() != null) {
        return new IssuePanelCell(ui,model,that.get(),columnIndex);
      }
 else {
        return null;
      }
    }
  }
);
  listView.saveSelection();
  listView.setItems(null);
  listView.setItems(getIssueList());
  listView.restoreSelection();
}",0.9462169553327257
135408,"/** 
 * Given an issue id, returns the index of that issue's cell in this panel.
 */
private int getIndexOfIssue(int issueId){
}","/** 
 * Given an issue id, returns the index of that issue's cell in this panel.
 */
private Optional<Integer> getIndexOfIssue(int issueId){
}",0.9481481481481482
135409,"public IssuePanel(UI ui,Stage mainStage,Model model,ColumnControl parentColumnControl,SidePanel sidePanel,int columnIndex,TurboCommandExecutor dragAndDropExecutor){
  super(ui,mainStage,model,parentColumnControl,sidePanel,columnIndex,dragAndDropExecutor);
  this.mainStage=mainStage;
  this.model=model;
  this.parentColumnControl=parentColumnControl;
  this.columnIndex=columnIndex;
  this.sidePanel=sidePanel;
  this.ui=ui;
  listView=new ListView<>();
  setupListView();
  getChildren().add(listView);
  ui.registerEvent(new IssueSelectedEventHandler(){
    @Override public void handle(    IssueSelectedEvent e){
      selectedId=Optional.of(e.id);
    }
  }
);
  refreshItems();
}","public IssuePanel(UI ui,Stage mainStage,Model model,ColumnControl parentColumnControl,SidePanel sidePanel,int columnIndex,TurboCommandExecutor dragAndDropExecutor){
}",0.3901292596944771
135410,"@Override public void deselect(){
  listView.getSelectionModel().clearSelection();
  selectedId=Optional.empty();
}","@Override public void deselect(){
  listView.getSelectionModel().clearSelection();
  selectedId=Optional.empty();
  selectedIndex=-1;
}",0.92
135411,"private void setupMouseEvents(){
  setOnMouseClicked(e -> {
    logger.info(""String_Node_Str"" + selectedIndex.get());
    onItemSelected.accept(selectedIndex.get());
  }
);
}","private void setupMouseEvents(){
  setOnMouseClicked(e -> {
    int currentlySelected=getSelectionModel().getSelectedIndex();
    if (currentlySelected != -1) {
      selectedIndex=Optional.of(currentlySelected);
    }
    logger.info(""String_Node_Str"" + selectedIndex.get());
    onItemSelected.accept(selectedIndex.get());
  }
);
}",0.6863905325443787
135412,"private void getUserCredentials(){
  mainStage.close();
  new LoginDialog(mainStage,columns).show().thenApply(success -> {
    if (!success) {
      quit();
    }
 else {
      columns.loadIssues();
      sidePanel.refresh();
      triggerEvent(new LoginEvent());
      setExpandedWidth(false);
    }
    return true;
  }
).exceptionally(e -> {
    logger.error(e.getLocalizedMessage(),e);
    return false;
  }
);
}","private void getUserCredentials(){
  new LoginDialog(mainStage,columns).show().thenApply(success -> {
    if (success) {
      columns.loadIssues();
      sidePanel.refresh();
      triggerEvent(new LoginEvent());
      setExpandedWidth(false);
    }
 else {
      quit();
    }
    return true;
  }
).exceptionally(e -> {
    logger.error(e.getLocalizedMessage(),e);
    return false;
  }
);
}",0.8839506172839506
135413,"@Override public void run(){
  list.removeAll(removed);
  newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
  dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
}","@Override public void run(){
  list.removeAll(removed);
  newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
  dcHandler.writeToFile(repoId,issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
}",0.9872958257713248
135414,"public void updateCachedLabels(List<Label> ghLabels){
  ArrayList<TurboLabel> newLabels=CollectionUtilities.getHubTurboLabelList(ghLabels);
  updateCachedList(labels,newLabels);
}","public void updateCachedLabels(List<Label> ghLabels,String repoId){
  ArrayList<TurboLabel> newLabels=CollectionUtilities.getHubTurboLabelList(ghLabels);
  updateCachedList(labels,newLabels,repoId);
}",0.9445910290237468
135415,"public void loadIssues(List<Issue> ghIssues){
  if (ghIssues != null) {
    enforceStatusStateConsistency(ghIssues);
  }
  Platform.runLater(() -> {
    issues.clear();
    ArrayList<TurboIssue> buffer=CollectionUtilities.getHubTurboIssueList(ghIssues);
    issues.addAll(buffer);
    dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
  }
);
}","public void loadIssues(List<Issue> ghIssues){
  if (ghIssues != null) {
    enforceStatusStateConsistency(ghIssues);
  }
  Platform.runLater(() -> {
    issues.clear();
    ArrayList<TurboIssue> buffer=CollectionUtilities.getHubTurboIssueList(ghIssues);
    issues.addAll(buffer);
    dcHandler.writeToFile(repoId.toString(),issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
  }
);
}",0.9790209790209792
135416,"public void updateCachedMilestones(List<Milestone> ghMilestones){
  ArrayList<TurboMilestone> newMilestones=CollectionUtilities.getHubTurboMilestoneList(ghMilestones);
  updateCachedList(milestones,newMilestones);
}","public void updateCachedMilestones(List<Milestone> ghMilestones,String repoId){
  ArrayList<TurboMilestone> newMilestones=CollectionUtilities.getHubTurboMilestoneList(ghMilestones);
  updateCachedList(milestones,newMilestones,repoId);
}",0.9534368070953436
135417,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void updateCachedList(List list,List newList){
  HashMap<String,HashSet> changes=CollectionUtilities.getChangesToList(list,newList);
  HashSet removed=changes.get(CollectionUtilities.REMOVED_TAG);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      list.removeAll(removed);
      newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
      dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
    }
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void updateCachedList(List list,List newList,String repoId){
  HashMap<String,HashSet> changes=CollectionUtilities.getChangesToList(list,newList);
  HashSet removed=changes.get(CollectionUtilities.REMOVED_TAG);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      list.removeAll(removed);
      newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
      dcHandler.writeToFile(repoId,issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
    }
  }
);
}",0.9827727645611156
135418,"public void updateCachedCollaborators(List<User> ghCollaborators){
  ArrayList<TurboUser> newCollaborators=CollectionUtilities.getHubTurboUserList(ghCollaborators);
  updateCachedList(collaborators,newCollaborators);
}","public void updateCachedCollaborators(List<User> ghCollaborators,String repoId){
  ArrayList<TurboUser> newCollaborators=CollectionUtilities.getHubTurboUserList(ghCollaborators);
  updateCachedList(collaborators,newCollaborators,repoId);
}",0.9540481400437636
135419,"public void updateCachedIssues(List<Issue> issueList){
  if (issueList.size() == 0) {
    return;
  }
 else {
    enforceStatusStateConsistency(issueList);
  }
  WeakReference<Model> selfRef=new WeakReference<Model>(this);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      for (int i=issueList.size() - 1; i >= 0; i--) {
        Issue issue=issueList.get(i);
        TurboIssue newCached=new TurboIssue(issue,selfRef.get());
        updateCachedIssue(newCached);
      }
      dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
    }
  }
);
}","public void updateCachedIssues(List<Issue> issueList,String repoId){
  if (issueList.size() == 0) {
    return;
  }
 else {
    enforceStatusStateConsistency(issueList);
  }
  WeakReference<Model> selfRef=new WeakReference<Model>(this);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      for (int i=issueList.size() - 1; i >= 0; i--) {
        Issue issue=issueList.get(i);
        TurboIssue newCached=new TurboIssue(issue,selfRef.get());
        updateCachedIssue(newCached);
      }
      dcHandler.writeToFile(repoId,issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
    }
  }
);
}",0.9839326702371844
135420,"private void updateModel(){
  updateModelCollaborators();
  updateModelLabels();
  updateModelMilestones();
  updateModelIssues();
  lastUpdateTime=issueUpdateService.lastCheckTime;
}","private void updateModel(IRepositoryIdProvider repoId){
  updateModelCollaborators(repoId);
  updateModelLabels(repoId);
  updateModelMilestones(repoId);
  updateModelIssues(repoId);
  lastUpdateTime=issueUpdateService.lastCheckTime;
}",0.7655502392344498
135421,"private void updateModelIssues(){
  List<Issue> updatedIssues=issueUpdateService.getUpdatedItems(model.getRepoId());
  model.updateCachedIssues(updatedIssues);
  model.updateIssuesETag(issueUpdateService.getLastETag());
  model.updateIssueCheckTime(issueUpdateService.getLastIssueCheckTime());
}","private void updateModelIssues(IRepositoryIdProvider repoId){
  if (model.getRepoId().equals(repoId)) {
    List<Issue> updatedIssues=issueUpdateService.getUpdatedItems(repoId);
    model.updateCachedIssues(updatedIssues,repoId.toString());
    model.updateIssuesETag(issueUpdateService.getLastETag());
    model.updateIssueCheckTime(issueUpdateService.getLastIssueCheckTime());
  }
}",0.8188512518409425
135422,"private void updateModelMilestones(){
  List<Milestone> milestones=milestoneUpdateService.getUpdatedItems(model.getRepoId());
  model.updateMilestonesETag(milestoneUpdateService.getLastETag());
  if (milestones.size() > 0) {
    model.updateCachedMilestones(milestones);
  }
}","private void updateModelMilestones(IRepositoryIdProvider repoId){
  if (model.getRepoId().equals(repoId)) {
    List<Milestone> milestones=milestoneUpdateService.getUpdatedItems(repoId);
    model.updateMilestonesETag(milestoneUpdateService.getLastETag());
    if (milestones.size() > 0) {
      model.updateCachedMilestones(milestones,repoId.toString());
    }
  }
}",0.8055987558320373
135423,"private void updateModelCollaborators(){
  List<User> collaborators=collaboratorUpdateService.getUpdatedItems(model.getRepoId());
  model.updateCollabsETag(collaboratorUpdateService.getLastETag());
  if (collaborators.size() > 0) {
    model.updateCachedCollaborators(collaborators);
  }
}","private void updateModelCollaborators(IRepositoryIdProvider repoId){
  if (model.getRepoId().equals(repoId)) {
    List<User> collaborators=collaboratorUpdateService.getUpdatedItems(repoId);
    model.updateCollabsETag(collaboratorUpdateService.getLastETag());
    if (collaborators.size() > 0) {
      model.updateCachedCollaborators(collaborators,repoId.toString());
    }
  }
}",0.8131539611360239
135424,"private void updateModelLabels(){
  List<Label> labels=labelUpdateService.getUpdatedItems(model.getRepoId());
  model.updateLabelsETag(labelUpdateService.getLastETag());
  if (labels.size() > 0) {
    model.updateCachedLabels(labels);
  }
}","private void updateModelLabels(IRepositoryIdProvider repoId){
  if (model.getRepoId().equals(repoId)) {
    List<Label> labels=labelUpdateService.getUpdatedItems(repoId);
    model.updateLabelsETag(labelUpdateService.getLastETag());
    if (labels.size() > 0) {
      model.updateCachedLabels(labels,repoId.toString());
    }
  }
}",0.7810858143607706
135425,"public void startModelUpdate(){
  if (pollTimer != null) {
    stopModelUpdate();
  }
  pollTimer=new Timer();
  TimerTask pollTask=new TimerTask(){
    @Override public void run(){
      updateModel();
      UIReference.getInstance().getUI().triggerEvent(new RefreshDoneEvent());
    }
  }
;
  pollTimer.scheduleAtFixedRate(pollTask,0,pollInterval);
  stopwatch=new Timer();
  TimerTask countdown=new TimerTask(){
    @Override public void run(){
      StatusBar.displayMessage(""String_Node_Str"" + getTime());
    }
  }
;
  stopwatch.scheduleAtFixedRate(countdown,0,stopwatchInterval);
}","public void startModelUpdate(){
  if (pollTimer != null) {
    stopModelUpdate();
  }
  pollTimer=new Timer();
  final IRepositoryIdProvider repoId=model.getRepoId();
  TimerTask pollTask=new TimerTask(){
    @Override public void run(){
      updateModel(repoId);
      UIReference.getInstance().getUI().triggerEvent(new RefreshDoneEvent());
    }
  }
;
  pollTimer.scheduleAtFixedRate(pollTask,0,pollInterval);
  stopwatch=new Timer();
  TimerTask countdown=new TimerTask(){
    @Override public void run(){
      StatusBar.displayMessage(""String_Node_Str"" + getTime());
    }
  }
;
  stopwatch.scheduleAtFixedRate(countdown,0,stopwatchInterval);
}",0.9499192245557352
135426,"public void writeToFile(String issuesETag,String collabsETag,String labelsETag,String milestonesETag,String issueCheckTime,ObservableList<TurboUser> collaborators,ObservableList<TurboLabel> labels,ObservableList<TurboMilestone> milestones,ObservableList<TurboIssue> issues){
  this.issues=issues.stream().collect(Collectors.toList());
  this.collaborators=collaborators.stream().collect(Collectors.toList());
  this.labels=labels.stream().collect(Collectors.toList());
  this.milestones=milestones.stream().collect(Collectors.toList());
  TurboRepoData currentRepoData=new TurboRepoData(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,this.collaborators,this.labels,this.milestones,this.issues);
  Gson gson=new GsonBuilder().setPrettyPrinting().create();
  String json=gson.toJson(currentRepoData);
  try {
    FileWriter writer=new FileWriter(getFileName(FILE_DATA_CACHE_TEMP));
    writer.write(json);
    writer.close();
    File file=new File(getFileName(FILE_DATA_CACHE));
    if (file.exists()) {
      if (file.delete()) {
      }
 else {
        logger.error(""String_Node_Str"");
      }
    }
    File newFile=new File(getFileName(FILE_DATA_CACHE_TEMP));
    if (newFile.renameTo(file)) {
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void writeToFile(String repoIdString,String issuesETag,String collabsETag,String labelsETag,String milestonesETag,String issueCheckTime,ObservableList<TurboUser> collaborators,ObservableList<TurboLabel> labels,ObservableList<TurboMilestone> milestones,ObservableList<TurboIssue> issues){
  this.issues=issues.stream().collect(Collectors.toList());
  this.collaborators=collaborators.stream().collect(Collectors.toList());
  this.labels=labels.stream().collect(Collectors.toList());
  this.milestones=milestones.stream().collect(Collectors.toList());
  TurboRepoData currentRepoData=new TurboRepoData(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,this.collaborators,this.labels,this.milestones,this.issues);
  Gson gson=new GsonBuilder().setPrettyPrinting().create();
  String json=gson.toJson(currentRepoData);
  try {
    FileWriter writer=new FileWriter(getFileName(FILE_DATA_CACHE_TEMP,repoIdString));
    writer.write(json);
    writer.close();
    File file=new File(getFileName(FILE_DATA_CACHE,repoIdString));
    if (file.exists()) {
      if (file.delete()) {
      }
 else {
        logger.error(""String_Node_Str"");
      }
    }
    File newFile=new File(getFileName(FILE_DATA_CACHE_TEMP,repoIdString));
    if (newFile.renameTo(file)) {
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9783645031169784
135427,"public void readFromFile(){
  Gson gson=new Gson();
  try {
    BufferedReader bufferedReader=new BufferedReader(new FileReader(getFileName(FILE_DATA_CACHE)));
    repo=gson.fromJson(bufferedReader,TurboRepoData.class);
    bufferedReader.close();
  }
 catch (  FileNotFoundException e) {
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","public void readFromFile(){
  Gson gson=new Gson();
  try {
    BufferedReader bufferedReader=new BufferedReader(new FileReader(getFileName(FILE_DATA_CACHE,this.repoId)));
    repo=gson.fromJson(bufferedReader,TurboRepoData.class);
    bufferedReader.close();
  }
 catch (  FileNotFoundException e) {
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9830985915492958
135428,"private String getFileName(String givenFileName){
  String[] repoIdTokens=repoId.split(""String_Node_Str"");
  String repoFileName=repoIdTokens[0] + ""String_Node_Str"" + repoIdTokens[1];
  return DIR_CACHE + File.separator + repoFileName+ givenFileName;
}","private String getFileName(String givenFileName,String repoIdString){
  String[] repoIdTokens=repoIdString.split(""String_Node_Str"");
  String repoFileName=repoIdTokens[0] + ""String_Node_Str"" + repoIdTokens[1];
  return DIR_CACHE + File.separator + repoFileName+ givenFileName;
}",0.9509433962264152
135429,"@Override public String toString(){
}","/** 
 * This method is used to serialise predicates. Thus whatever form returned should be syntactically valid.
 */
@Override public String toString(){
}",0.3894736842105263
135430,"public boolean encloses(LocalDate date){
  if (start == null) {
    return date.isBefore(start) && (!strictly || !date.isEqual(start));
  }
 else   if (end == null) {
    return date.isAfter(start) && (!strictly || !date.isEqual(end));
  }
 else {
    return date.isAfter(start) && date.isBefore(end) && (!strictly || (!date.isEqual(start) && !date.isEqual(end)));
  }
}","public boolean encloses(LocalDate date){
  if (start == null) {
    return date.isBefore(end) || (!strictly && date.isEqual(end));
  }
 else   if (end == null) {
    return date.isAfter(start) || (!strictly && date.isEqual(start));
  }
 else {
    return date.isAfter(start) && date.isBefore(end) || (!strictly && (date.isEqual(start) || date.isEqual(end)));
  }
}",0.904632152588556
135431,"@Override public void run(){
  list.removeAll(removed);
  newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
}","@Override public void run(){
  list.removeAll(removed);
  newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
  dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
}",0.689156626506024
135432,"public void updateCachedLabels(List<Label> ghLabels){
  ArrayList<TurboLabel> newLabels=CollectionUtilities.getHubTurboLabelList(ghLabels);
  updateCachedList(labels,newLabels);
  dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,collaborators,labels,milestones,issues);
}","public void updateCachedLabels(List<Label> ghLabels){
  ArrayList<TurboLabel> newLabels=CollectionUtilities.getHubTurboLabelList(ghLabels);
  updateCachedList(labels,newLabels);
}",0.7584745762711864
135433,"public void loadIssues(List<Issue> ghIssues){
  if (ghIssues != null) {
    enforceStatusStateConsistency(ghIssues);
  }
  Platform.runLater(() -> {
    issues.clear();
    ArrayList<TurboIssue> buffer=CollectionUtilities.getHubTurboIssueList(ghIssues);
    issues.addAll(buffer);
    dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,collaborators,labels,milestones,issues);
  }
);
}","public void loadIssues(List<Issue> ghIssues){
  if (ghIssues != null) {
    enforceStatusStateConsistency(ghIssues);
  }
  Platform.runLater(() -> {
    issues.clear();
    ArrayList<TurboIssue> buffer=CollectionUtilities.getHubTurboIssueList(ghIssues);
    issues.addAll(buffer);
    dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
  }
);
}",0.9309090909090908
135434,"public void updateCachedMilestones(List<Milestone> ghMilestones){
  ArrayList<TurboMilestone> newMilestones=CollectionUtilities.getHubTurboMilestoneList(ghMilestones);
  updateCachedList(milestones,newMilestones);
  dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,collaborators,labels,milestones,issues);
}","public void updateCachedMilestones(List<Milestone> ghMilestones){
  ArrayList<TurboMilestone> newMilestones=CollectionUtilities.getHubTurboMilestoneList(ghMilestones);
  updateCachedList(milestones,newMilestones);
}",0.7904411764705882
135435,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void updateCachedList(List list,List newList){
  HashMap<String,HashSet> changes=CollectionUtilities.getChangesToList(list,newList);
  HashSet removed=changes.get(CollectionUtilities.REMOVED_TAG);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      list.removeAll(removed);
      newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
    }
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void updateCachedList(List list,List newList){
  HashMap<String,HashSet> changes=CollectionUtilities.getChangesToList(list,newList);
  HashSet removed=changes.get(CollectionUtilities.REMOVED_TAG);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      list.removeAll(removed);
      newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
      dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
    }
  }
);
}",0.8751173708920188
135436,"public void updateCachedCollaborators(List<User> ghCollaborators){
  ArrayList<TurboUser> newCollaborators=CollectionUtilities.getHubTurboUserList(ghCollaborators);
  updateCachedList(collaborators,newCollaborators);
  dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,collaborators,labels,milestones,issues);
}","public void updateCachedCollaborators(List<User> ghCollaborators){
  ArrayList<TurboUser> newCollaborators=CollectionUtilities.getHubTurboUserList(ghCollaborators);
  updateCachedList(collaborators,newCollaborators);
}",0.7927272727272727
135437,"public void updateCachedIssues(List<Issue> issueList){
  if (issueList.size() == 0) {
    return;
  }
 else {
    enforceStatusStateConsistency(issueList);
  }
  WeakReference<Model> selfRef=new WeakReference<Model>(this);
  for (int i=issueList.size() - 1; i >= 0; i--) {
    Issue issue=issueList.get(i);
    Platform.runLater(new Runnable(){
      @Override public void run(){
        TurboIssue newCached=new TurboIssue(issue,selfRef.get());
        updateCachedIssue(newCached);
      }
    }
);
  }
  dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,collaborators,labels,milestones,issues);
}","public void updateCachedIssues(List<Issue> issueList){
  if (issueList.size() == 0) {
    return;
  }
 else {
    enforceStatusStateConsistency(issueList);
  }
  WeakReference<Model> selfRef=new WeakReference<Model>(this);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      for (int i=issueList.size() - 1; i >= 0; i--) {
        Issue issue=issueList.get(i);
        TurboIssue newCached=new TurboIssue(issue,selfRef.get());
        updateCachedIssue(newCached);
      }
      dcHandler.writeToFile(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,collaborators,labels,milestones,issues);
    }
  }
);
}",0.7648456057007126
135438,"@SuppressWarnings(""String_Node_Str"") public HashMap<String,List> getGitHubResources(IRepositoryIdProvider repoId) throws IOException {
  this.repoId=repoId;
  boolean needToGetResources=true;
  String repoIdString=repoId.toString();
  DataCacheFileHandler dcHandler=new DataCacheFileHandler(repoIdString);
  model.setDataCacheFileHandler(dcHandler);
  model.setRepoId(repoId);
  TurboRepoData repo=dcHandler.getRepo();
  if (repo != null) {
    needToGetResources=false;
  }
  if (!needToGetResources) {
    System.out.println(""String_Node_Str"");
    issuesETag=repo.getIssuesETag();
    collabsETag=repo.getCollaboratorsETag();
    labelsETag=repo.getLabelsETag();
    milestonesETag=repo.getMilestonesETag();
    List<TurboUser> collaborators=repo.getCollaborators();
    List<TurboLabel> labels=repo.getLabels();
    List<TurboMilestone> milestones=repo.getMilestones();
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,collaborators);
    map.put(KEY_LABELS,labels);
    map.put(KEY_MILESTONES,milestones);
    return map;
  }
 else {
    List<User> ghCollaborators=null;
    List<Label> ghLabels=null;
    List<Milestone> ghMilestones=null;
    List<Issue> ghIssues=null;
    ghCollaborators=getCollaborators();
    ghLabels=getLabels();
    ghMilestones=getMilestones();
    ghIssues=getAllIssues();
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,ghCollaborators);
    map.put(KEY_LABELS,ghLabels);
    map.put(KEY_MILESTONES,ghMilestones);
    map.put(KEY_ISSUES,ghIssues);
    return map;
  }
}","@SuppressWarnings(""String_Node_Str"") public HashMap<String,List> getGitHubResources(IRepositoryIdProvider repoId) throws IOException {
  this.repoId=repoId;
  boolean needToGetResources=true;
  String repoIdString=repoId.toString();
  DataCacheFileHandler dcHandler=new DataCacheFileHandler(repoIdString);
  model.setDataCacheFileHandler(dcHandler);
  model.setRepoId(repoId);
  TurboRepoData repo=dcHandler.getRepo();
  if (repo != null) {
    needToGetResources=false;
  }
  if (!needToGetResources) {
    System.out.println(""String_Node_Str"");
    issuesETag=repo.getIssuesETag();
    collabsETag=repo.getCollaboratorsETag();
    labelsETag=repo.getLabelsETag();
    milestonesETag=repo.getMilestonesETag();
    issueCheckTime=repo.getIssueCheckTime();
    List<TurboUser> collaborators=repo.getCollaborators();
    List<TurboLabel> labels=repo.getLabels();
    List<TurboMilestone> milestones=repo.getMilestones();
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,collaborators);
    map.put(KEY_LABELS,labels);
    map.put(KEY_MILESTONES,milestones);
    return map;
  }
 else {
    List<User> ghCollaborators=null;
    List<Label> ghLabels=null;
    List<Milestone> ghMilestones=null;
    List<Issue> ghIssues=null;
    ghCollaborators=getCollaborators();
    ghLabels=getLabels();
    ghMilestones=getMilestones();
    ghIssues=getAllIssues();
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,ghCollaborators);
    map.put(KEY_LABELS,ghLabels);
    map.put(KEY_MILESTONES,ghMilestones);
    map.put(KEY_ISSUES,ghIssues);
    return map;
  }
}",0.9859594383775352
135439,"public void setupAndStartModelUpdate(){
  if (modelUpdater != null) {
    stopModelUpdate();
  }
  if (repoId != null) {
    modelUpdater=new ModelUpdater(githubClient,model,issuesETag,collabsETag,labelsETag,milestonesETag);
    modelUpdater.startModelUpdate();
  }
}","public void setupAndStartModelUpdate(){
  if (modelUpdater != null) {
    stopModelUpdate();
  }
  if (repoId != null) {
    modelUpdater=new ModelUpdater(githubClient,model,issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime);
    modelUpdater.startModelUpdate();
  }
}",0.9726775956284152
135440,"public IssueUpdateService(GitHubClientExtended client,String issuesETag){
  super(client);
  apiSuffix=SEGMENT_ISSUES;
  super.setLastETag(issuesETag);
  lastCheckTime=new Date();
}","public IssueUpdateService(GitHubClientExtended client,String issuesETag,String lastIssueCheckTime){
  super(client);
  apiSuffix=SEGMENT_ISSUES;
  super.setLastETag(issuesETag);
  lastCheckTime=new Date();
  super.setLastIssueCheckTime(lastIssueCheckTime);
}",0.8246013667425968
135441,"private void updateModel(){
  updateModelIssues();
  updateModelCollaborators();
  updateModelLabels();
  updateModelMilestones();
  lastUpdateTime=issueUpdateService.lastCheckTime;
}","private void updateModel(){
  updateModelCollaborators();
  updateModelLabels();
  updateModelMilestones();
  updateModelIssues();
  lastUpdateTime=issueUpdateService.lastCheckTime;
}",0.8743169398907104
135442,"private void updateModelIssues(){
  List<Issue> updatedIssues=issueUpdateService.getUpdatedItems(model.getRepoId());
  model.updateIssuesETag(issueUpdateService.getLastETag());
  model.updateCachedIssues(updatedIssues);
}","private void updateModelIssues(){
  List<Issue> updatedIssues=issueUpdateService.getUpdatedItems(model.getRepoId());
  model.updateCachedIssues(updatedIssues);
  model.updateIssuesETag(issueUpdateService.getLastETag());
  model.updateIssueCheckTime(issueUpdateService.getLastIssueCheckTime());
}",0.7674418604651163
135443,"public ModelUpdater(GitHubClientExtended client,Model model,String issuesETag,String collabsETag,String labelsETag,String milestonesETag){
  this.model=model;
  this.issueUpdateService=new IssueUpdateService(client,issuesETag);
  this.collaboratorUpdateService=new CollaboratorUpdateService(client,collabsETag);
  this.labelUpdateService=new LabelUpdateService(client,labelsETag);
  this.milestoneUpdateService=new MilestoneUpdateService(client,milestonesETag);
}","public ModelUpdater(GitHubClientExtended client,Model model,String issuesETag,String collabsETag,String labelsETag,String milestonesETag,String issueCheckTime){
  this.model=model;
  this.issueUpdateService=new IssueUpdateService(client,issuesETag,issueCheckTime);
  this.collaboratorUpdateService=new CollaboratorUpdateService(client,collabsETag);
  this.labelUpdateService=new LabelUpdateService(client,labelsETag);
  this.milestoneUpdateService=new MilestoneUpdateService(client,milestonesETag);
}",0.9615784008307372
135444,"public ArrayList<T> getUpdatedItems(IRepositoryIdProvider repoId){
  ArrayList<T> result=new ArrayList<T>();
  try {
    PagedRequest<T> request=createUpdatedRequest(repoId);
    if (apiSuffix == ""String_Node_Str"") {
      Map<String,String> temp=request.getParams();
      temp.remove(""String_Node_Str"");
      request.setParams(temp);
    }
    PageIterator<T> requestIterator=new PageIterator<T>(request,client);
    HttpURLConnection connection=createUpdatedConnection(request);
    int responseCode=connection.getResponseCode();
    System.out.println(responseCode);
    if (client.isError(responseCode)) {
      return new ArrayList<T>();
    }
    if (responseCode != GitHubClientExtended.NO_UPDATE_RESPONSE_CODE) {
      result=(ArrayList<T>)getAll(requestIterator);
    }
    updateLastETag(connection);
    updateLastCheckTime(connection);
  }
 catch (  IOException e) {
    if (!(e instanceof UnknownHostException || e instanceof SocketTimeoutException)) {
      logger.error(e.getLocalizedMessage(),e);
    }
  }
catch (  ParseException e) {
    logger.error(e.getLocalizedMessage(),e);
  }
  return result;
}","public ArrayList<T> getUpdatedItems(IRepositoryIdProvider repoId){
  ArrayList<T> result=new ArrayList<T>();
  try {
    PagedRequest<T> request=createUpdatedRequest(repoId);
    if (apiSuffix == SUFFIX_ISSUES) {
      Map<String,String> temp=request.getParams();
      if (lastIssueCheckTime == null) {
        temp.remove(SINCE);
        request.setParams(temp);
      }
 else {
        temp.put(SINCE,lastIssueCheckTime);
        request.setParams(temp);
      }
    }
    PageIterator<T> requestIterator=new PageIterator<T>(request,client);
    HttpURLConnection connection=createUpdatedConnection(request);
    int responseCode=connection.getResponseCode();
    System.out.println(responseCode);
    if (client.isError(responseCode)) {
      return new ArrayList<T>();
    }
    if (responseCode != GitHubClientExtended.NO_UPDATE_RESPONSE_CODE) {
      result=(ArrayList<T>)getAll(requestIterator);
    }
    updateLastETag(connection);
    updateLastCheckTime(connection);
  }
 catch (  IOException e) {
    if (!(e instanceof UnknownHostException || e instanceof SocketTimeoutException)) {
      logger.error(e.getLocalizedMessage(),e);
    }
  }
catch (  ParseException e) {
    logger.error(e.getLocalizedMessage(),e);
  }
  return result;
}",0.9194432728806412
135445,"private void updateLastCheckTime(HttpURLConnection connection) throws ParseException {
  String date=connection.getHeaderField(""String_Node_Str"");
  lastCheckTime=new SimpleDateFormat(""String_Node_Str"").parse(date);
}","private void updateLastCheckTime(HttpURLConnection connection) throws ParseException {
  String date=connection.getHeaderField(""String_Node_Str"");
  lastCheckTime=new SimpleDateFormat(""String_Node_Str"").parse(date);
  if (apiSuffix == SUFFIX_ISSUES) {
    lastIssueCheckTime=getFormattedDate(lastCheckTime);
  }
}",0.8188679245283019
135446,"public void writeToFile(String issuesETag,String collabsETag,String labelsETag,String milestonesETag,ObservableList<TurboUser> collaborators,ObservableList<TurboLabel> labels,ObservableList<TurboMilestone> milestones,ObservableList<TurboIssue> issues){
  this.issues=issues.stream().collect(Collectors.toList());
  this.collaborators=collaborators.stream().collect(Collectors.toList());
  this.labels=labels.stream().collect(Collectors.toList());
  this.milestones=milestones.stream().collect(Collectors.toList());
  TurboRepoData currentRepoData=new TurboRepoData(issuesETag,collabsETag,labelsETag,milestonesETag,this.collaborators,this.labels,this.milestones,this.issues);
  Gson gson=new GsonBuilder().setPrettyPrinting().create();
  String json=gson.toJson(currentRepoData);
  try {
    FileWriter writer=new FileWriter(getFileName(FILE_DATA_CACHE_TEMP));
    writer.write(json);
    writer.close();
    File file=new File(getFileName(FILE_DATA_CACHE));
    if (file.exists()) {
      if (file.delete()) {
      }
 else {
        logger.error(""String_Node_Str"");
      }
    }
    File newFile=new File(getFileName(FILE_DATA_CACHE_TEMP));
    if (newFile.renameTo(file)) {
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void writeToFile(String issuesETag,String collabsETag,String labelsETag,String milestonesETag,String issueCheckTime,ObservableList<TurboUser> collaborators,ObservableList<TurboLabel> labels,ObservableList<TurboMilestone> milestones,ObservableList<TurboIssue> issues){
  this.issues=issues.stream().collect(Collectors.toList());
  this.collaborators=collaborators.stream().collect(Collectors.toList());
  this.labels=labels.stream().collect(Collectors.toList());
  this.milestones=milestones.stream().collect(Collectors.toList());
  TurboRepoData currentRepoData=new TurboRepoData(issuesETag,collabsETag,labelsETag,milestonesETag,issueCheckTime,this.collaborators,this.labels,this.milestones,this.issues);
  Gson gson=new GsonBuilder().setPrettyPrinting().create();
  String json=gson.toJson(currentRepoData);
  try {
    FileWriter writer=new FileWriter(getFileName(FILE_DATA_CACHE_TEMP));
    writer.write(json);
    writer.close();
    File file=new File(getFileName(FILE_DATA_CACHE));
    if (file.exists()) {
      if (file.delete()) {
      }
 else {
        logger.error(""String_Node_Str"");
      }
    }
    File newFile=new File(getFileName(FILE_DATA_CACHE_TEMP));
    if (newFile.renameTo(file)) {
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9859369061193464
135447,"public TurboRepoData(String issuesETag,String collabsETag,String labelsETag,String milestonesETag,List<TurboUser> collaborators,List<TurboLabel> labels,List<TurboMilestone> milestones,List<TurboIssue> issues){
  this.issuesETag=issuesETag;
  this.collabsETag=collabsETag;
  this.labelsETag=labelsETag;
  this.milestonesETag=milestonesETag;
  this.collaborators=collaborators;
  this.labels=new ArrayList<TurboSerializableLabel>();
  for (  TurboLabel label : labels) {
    this.labels.add(new TurboSerializableLabel(label));
  }
  this.milestones=new ArrayList<TurboSerializableMilestone>();
  for (  TurboMilestone milestone : milestones) {
    this.milestones.add(new TurboSerializableMilestone(milestone));
  }
  this.issues=new ArrayList<TurboSerializableIssue>();
  for (  TurboIssue issue : issues) {
    this.issues.add(new TurboSerializableIssue(issue));
  }
}","public TurboRepoData(String issuesETag,String collabsETag,String labelsETag,String milestonesETag,String issueCheckTime,List<TurboUser> collaborators,List<TurboLabel> labels,List<TurboMilestone> milestones,List<TurboIssue> issues){
  this.issuesETag=issuesETag;
  this.collabsETag=collabsETag;
  this.labelsETag=labelsETag;
  this.milestonesETag=milestonesETag;
  this.issueCheckTime=issueCheckTime;
  this.collaborators=collaborators;
  this.labels=new ArrayList<TurboSerializableLabel>();
  for (  TurboLabel label : labels) {
    this.labels.add(new TurboSerializableLabel(label));
  }
  this.milestones=new ArrayList<TurboSerializableMilestone>();
  for (  TurboMilestone milestone : milestones) {
    this.milestones.add(new TurboSerializableMilestone(milestone));
  }
  this.issues=new ArrayList<TurboSerializableIssue>();
  for (  TurboIssue issue : issues) {
    this.issues.add(new TurboSerializableIssue(issue));
  }
}",0.9665924276169264
135448,"/** 
 * Controls whether or not the main window is expanded (occupying the whole screen) or not (occupying a percentage).
 * @param expanded
 */
private void setExpandedWidth(boolean expanded){
  this.expanded=expanded;
  Rectangle dimensions=getDimensions();
  double width=expanded ? dimensions.getWidth() : dimensions.getWidth() * WINDOW_DEFAULT_PROPORTION;
  mainStage.setMinWidth(sidePanel.getWidth() + columns.getColumnWidth());
  mainStage.setMinHeight(dimensions.getHeight());
  mainStage.setMaxWidth(width);
  mainStage.setMaxHeight(dimensions.getHeight());
  mainStage.setX(0);
  mainStage.setY(0);
  Platform.runLater(() -> {
    mainStage.setMaxWidth(dimensions.getWidth());
  }
);
}","/** 
 * Controls whether or not the main window is expanded (occupying the whole screen) or not (occupying a percentage).
 * @param expanded
 */
private void setExpandedWidth(boolean expanded){
  this.expanded=expanded;
  Rectangle dimensions=getDimensions();
  double width=expanded ? dimensions.getWidth() : dimensions.getWidth() * WINDOW_DEFAULT_PROPORTION;
  mainStage.setMinWidth(sidePanel.getWidth() + columns.getColumnWidth());
  mainStage.setMinHeight(dimensions.getHeight());
  mainStage.setMaxWidth(width);
  mainStage.setMaxHeight(dimensions.getHeight());
  mainStage.setX(0);
  mainStage.setY(0);
  Platform.runLater(() -> {
    mainStage.setMaxWidth(dimensions.getWidth());
    browserComponent.resize(mainStage.getWidth());
  }
);
}",0.9646079111727968
135449,"private Node tabLayout(){
  VBox everything=new VBox();
  TabPane tabs=new TabPane();
  if (labelsTab == null) {
    labelsTab=createLabelsTab();
  }
  if (milestonesTab == null) {
    milestonesTab=createMilestonesTab();
  }
  if (assigneesTab == null) {
    assigneesTab=createCollaboratorsTab();
  }
  tabs.getTabs().addAll(labelsTab,milestonesTab,assigneesTab);
  if (repoFields == null) {
    repoFields=createRepoFields();
  }
  everything.getChildren().addAll(repoFields,tabs);
  everything.setPrefWidth(PANEL_PREF_WIDTH);
  return everything;
}","private Node tabLayout(){
  VBox everything=new VBox();
  tabs=new TabPane();
  if (labelsTab == null) {
    labelsTab=createLabelsTab();
  }
  if (milestonesTab == null) {
    milestonesTab=createMilestonesTab();
  }
  if (assigneesTab == null) {
    assigneesTab=createCollaboratorsTab();
  }
  tabs.getTabs().addAll(labelsTab,milestonesTab,assigneesTab);
  selectionModel=tabs.getSelectionModel();
  if (repoFields == null) {
    repoFields=createRepoFields();
  }
  everything.getChildren().addAll(repoFields,tabs);
  everything.setPrefWidth(PANEL_PREF_WIDTH);
  return everything;
}",0.9552238805970148
135450,"public void startModelUpdate(){
  if (pollTimer != null) {
    stopModelUpdate();
  }
  pollTimer=new Timer();
  TimerTask pollTask=new TimerTask(){
    @Override public void run(){
      updateModel();
    }
  }
;
  pollTimer.scheduleAtFixedRate(pollTask,0,pollInterval);
  stopwatch=new Timer();
  TimerTask countdown=new TimerTask(){
    @Override public void run(){
      StatusBar.displayMessage(""String_Node_Str"" + getTime());
    }
  }
;
  stopwatch.scheduleAtFixedRate(countdown,0,stopwatchInterval);
}","public void startModelUpdate(){
  if (pollTimer != null) {
    stopModelUpdate();
  }
  pollTimer=new Timer();
  TimerTask pollTask=new TimerTask(){
    @Override public void run(){
      updateModel();
      UIReference.getInstance().getUI().triggerEvent(new RefreshDoneEvent());
    }
  }
;
  pollTimer.scheduleAtFixedRate(pollTask,0,pollInterval);
  stopwatch=new Timer();
  TimerTask countdown=new TimerTask(){
    @Override public void run(){
      StatusBar.displayMessage(""String_Node_Str"" + getTime());
    }
  }
;
  stopwatch.scheduleAtFixedRate(countdown,0,stopwatchInterval);
}",0.9289617486338798
135451,"private Parent createRoot() throws IOException {
  sidePanel=new SidePanel(this,mainStage,ServiceManager.getInstance().getModel());
  columns=new ColumnControl(this,mainStage,ServiceManager.getInstance().getModel(),sidePanel);
  sidePanel.setColumns(columns);
  ScrollPane columnsScroll=new ScrollPane(columns);
  columnsScroll.getStyleClass().add(""String_Node_Str"");
  columnsScroll.setFitToHeight(true);
  columnsScroll.setVbarPolicy(ScrollBarPolicy.NEVER);
  HBox.setHgrow(columnsScroll,Priority.ALWAYS);
  menuBar=new MenuControl(this,columns,columnsScroll);
  HBox centerContainer=new HBox();
  centerContainer.setPadding(new Insets(5,0,5,0));
  centerContainer.getChildren().addAll(sidePanel.getControlLabel(),columnsScroll);
  BorderPane root=new BorderPane();
  root.setTop(menuBar);
  root.setLeft(sidePanel);
  root.setCenter(centerContainer);
  root.setBottom(StatusBar.getInstance());
  return root;
}","private Parent createRoot() throws IOException {
  sidePanel=new SidePanel(this,mainStage,ServiceManager.getInstance().getModel());
  columns=new ColumnControl(this,mainStage,ServiceManager.getInstance().getModel(),sidePanel);
  sidePanel.setColumns(columns);
  UIReference.getInstance().setUI(this);
  ScrollPane columnsScroll=new ScrollPane(columns);
  columnsScroll.getStyleClass().add(""String_Node_Str"");
  columnsScroll.setFitToHeight(true);
  columnsScroll.setVbarPolicy(ScrollBarPolicy.NEVER);
  HBox.setHgrow(columnsScroll,Priority.ALWAYS);
  menuBar=new MenuControl(this,columns,columnsScroll);
  HBox centerContainer=new HBox();
  centerContainer.setPadding(new Insets(5,0,5,0));
  centerContainer.getChildren().addAll(sidePanel.getControlLabel(),columnsScroll);
  BorderPane root=new BorderPane();
  root.setTop(menuBar);
  root.setLeft(sidePanel);
  root.setCenter(centerContainer);
  root.setBottom(StatusBar.getInstance());
  return root;
}",0.9780396357793252
135452,"public ColumnControl(UI ui,Stage stage,Model model,SidePanel sidePanel){
  this.ui=ui;
  this.stage=stage;
  this.model=model;
  this.sidePanel=sidePanel;
  this.dragAndDropExecutor=new TurboCommandExecutor();
  this.uiBrowserBridge=new UIBrowserBridge(ui);
  setSpacing(10);
  setPadding(new Insets(0,10,0,10));
  setupModelChangeResponse();
}","public ColumnControl(UI ui,Stage stage,Model model,SidePanel sidePanel){
  this.ui=ui;
  this.stage=stage;
  this.model=model;
  this.sidePanel=sidePanel;
  this.dragAndDropExecutor=new TurboCommandExecutor();
  this.uiBrowserBridge=new UIBrowserBridge(ui);
  setSpacing(10);
  setPadding(new Insets(0,10,0,10));
  setupModelChangeResponse();
  ui.registerEvent(new RefreshDoneEventHandler(){
    @Override public void handle(    RefreshDoneEvent e){
      Platform.runLater(() -> {
        refresh();
      }
);
    }
  }
);
}",0.7898966704936854
135453,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void loadComponents(IRepositoryIdProvider repoId,HashMap<String,List> ghResources){
  this.repoId=repoId;
  StatusBar.displayMessage(MESSAGE_LOADING_PROJECT_CONFIG);
  DataManager.getInstance().loadProjectConfig(getRepoId());
  cachedGithubComments=new ConcurrentHashMap<Integer,List<Comment>>();
  boolean isTurboResource=false;
  if (ghResources.get(ServiceManager.KEY_COLLABORATORS) != null) {
    if (ghResources.get(ServiceManager.KEY_COLLABORATORS).get(0).getClass() == TurboUser.class) {
      isTurboResource=true;
    }
  }
  if (isTurboResource) {
    StatusBar.displayMessage(MESSAGE_LOADING_COLLABS);
    loadTurboCollaborators((List<TurboUser>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(MESSAGE_LOADING_LABELS);
    loadTurboLabels((List<TurboLabel>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(MESSAGE_LOADING_MILESTONES);
    loadTurboMilestones((List<TurboMilestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    StatusBar.displayMessage(MESSAGE_LOADING_ISSUES);
    loadTurboIssues((List<TurboIssue>)ghResources.get(ServiceManager.KEY_ISSUES));
  }
 else {
    StatusBar.displayMessage(MESSAGE_LOADING_COLLABS);
    loadCollaborators((List<User>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(MESSAGE_LOADING_LABELS);
    loadLabels((List<Label>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(MESSAGE_LOADING_MILESTONES);
    loadMilestones((List<Milestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    StatusBar.displayMessage(MESSAGE_LOADING_ISSUES);
    loadIssues((List<Issue>)ghResources.get(ServiceManager.KEY_ISSUES));
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void loadComponents(IRepositoryIdProvider repoId,HashMap<String,List> ghResources){
  this.repoId=repoId;
  StatusBar.displayMessage(MESSAGE_LOADING_PROJECT_CONFIG);
  DataManager.getInstance().loadProjectConfig(getRepoId());
  cachedGithubComments=new ConcurrentHashMap<Integer,List<Comment>>();
  boolean isTurboResource=false;
  if (ghResources.get(ServiceManager.KEY_COLLABORATORS) != null) {
    if (ghResources.get(ServiceManager.KEY_COLLABORATORS).get(0).getClass() == TurboUser.class) {
      isTurboResource=true;
    }
  }
  WeakReference<Model> selfRef=new WeakReference<>(this);
  if (isTurboResource) {
    StatusBar.displayMessage(MESSAGE_LOADING_COLLABS);
    loadTurboCollaborators((List<TurboUser>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(MESSAGE_LOADING_LABELS);
    loadTurboLabels((List<TurboLabel>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(MESSAGE_LOADING_MILESTONES);
    loadTurboMilestones((List<TurboMilestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    List<TurboIssue> issues=repo.getIssues(ServiceManager.getInstance().getModel());
    StatusBar.displayMessage(MESSAGE_LOADING_ISSUES);
    loadTurboIssues(issues);
  }
 else {
    StatusBar.displayMessage(MESSAGE_LOADING_COLLABS);
    loadCollaborators((List<User>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(MESSAGE_LOADING_LABELS);
    loadLabels((List<Label>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(MESSAGE_LOADING_MILESTONES);
    loadMilestones((List<Milestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    StatusBar.displayMessage(MESSAGE_LOADING_ISSUES);
    loadIssues((List<Issue>)ghResources.get(ServiceManager.KEY_ISSUES));
  }
}",0.9413726035009724
135454,"@SuppressWarnings(""String_Node_Str"") public HashMap<String,List> getGitHubResources(IRepositoryIdProvider repoId) throws IOException {
  this.repoId=repoId;
  model.setRepoId(repoId);
  boolean needToGetResources=true;
  String repoIdString=repoId.toString();
  DataCacheFileHandler dcHandler=DataCacheFileHandler.getInstance();
  TurboRepoData repo=dcHandler.getRepoGivenId(repoIdString);
  if (repo != null) {
    needToGetResources=false;
  }
  if (!needToGetResources) {
    System.out.println(""String_Node_Str"");
    issuesETag=repo.getIssuesETag();
    collabsETag=repo.getCollaboratorsETag();
    labelsETag=repo.getLabelsETag();
    milestonesETag=repo.getMilestonesETag();
    List<TurboUser> collaborators=repo.getCollaborators();
    List<TurboLabel> labels=repo.getLabels();
    List<TurboMilestone> milestones=repo.getMilestones();
    List<TurboIssue> issues=repo.getIssues(model);
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,collaborators);
    map.put(KEY_LABELS,labels);
    map.put(KEY_MILESTONES,milestones);
    map.put(KEY_ISSUES,issues);
    return map;
  }
 else {
    List<User> ghCollaborators=null;
    List<Label> ghLabels=null;
    List<Milestone> ghMilestones=null;
    List<Issue> ghIssues=null;
    ghCollaborators=getCollaborators();
    ghLabels=getLabels();
    ghMilestones=getMilestones();
    ghIssues=getAllIssues();
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,ghCollaborators);
    map.put(KEY_LABELS,ghLabels);
    map.put(KEY_MILESTONES,ghMilestones);
    map.put(KEY_ISSUES,ghIssues);
    return map;
  }
}","@SuppressWarnings(""String_Node_Str"") public HashMap<String,List> getGitHubResources(IRepositoryIdProvider repoId) throws IOException {
  this.repoId=repoId;
  model.setRepoId(repoId);
  boolean needToGetResources=true;
  String repoIdString=repoId.toString();
  DataCacheFileHandler dcHandler=DataCacheFileHandler.getInstance();
  TurboRepoData repo=dcHandler.getRepoGivenId(repoIdString);
  if (repo != null) {
    needToGetResources=false;
  }
  if (!needToGetResources) {
    System.out.println(""String_Node_Str"");
    issuesETag=repo.getIssuesETag();
    collabsETag=repo.getCollaboratorsETag();
    labelsETag=repo.getLabelsETag();
    milestonesETag=repo.getMilestonesETag();
    List<TurboUser> collaborators=repo.getCollaborators();
    List<TurboLabel> labels=repo.getLabels();
    List<TurboMilestone> milestones=repo.getMilestones();
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,collaborators);
    map.put(KEY_LABELS,labels);
    map.put(KEY_MILESTONES,milestones);
    return map;
  }
 else {
    List<User> ghCollaborators=null;
    List<Label> ghLabels=null;
    List<Milestone> ghMilestones=null;
    List<Issue> ghIssues=null;
    ghCollaborators=getCollaborators();
    ghLabels=getLabels();
    ghMilestones=getMilestones();
    ghIssues=getAllIssues();
    HashMap<String,List> map=new HashMap<String,List>();
    map.put(KEY_COLLABORATORS,ghCollaborators);
    map.put(KEY_LABELS,ghLabels);
    map.put(KEY_MILESTONES,ghMilestones);
    map.put(KEY_ISSUES,ghIssues);
    return map;
  }
}",0.9739403453689168
135455,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void loadComponents(IRepositoryIdProvider repoId,HashMap<String,List> ghResources){
  this.repoId=repoId;
  StatusBar.displayMessage(MESSAGE_LOADING_PROJECT_CONFIG);
  DataManager.getInstance().loadProjectConfig(getRepoId());
  cachedGithubComments=new ConcurrentHashMap<Integer,List<Comment>>();
  boolean isTurboResource=false;
  if (ghResources.get(ServiceManager.KEY_COLLABORATORS) != null) {
    if (ghResources.get(ServiceManager.KEY_COLLABORATORS).get(0).getClass() == TurboUser.class) {
      isTurboResource=true;
    }
  }
  if (isTurboResource) {
    StatusBar.displayMessage(MESSAGE_LOADING_COLLABS);
    loadTurboCollaborators((List<TurboUser>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(MESSAGE_LOADING_LABELS);
    loadTurboLabels((List<TurboLabel>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(MESSAGE_LOADING_MILESTONES);
    loadTurboMilestones((List<TurboMilestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    Platform.runLater(() -> {
      List<TurboIssue> issues=dcHandler.getRepo().getIssues(ServiceManager.getInstance().getModel());
      StatusBar.displayMessage(MESSAGE_LOADING_ISSUES);
      loadTurboIssues(issues);
    }
);
  }
 else {
    StatusBar.displayMessage(MESSAGE_LOADING_COLLABS);
    loadCollaborators((List<User>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(MESSAGE_LOADING_LABELS);
    loadLabels((List<Label>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(MESSAGE_LOADING_MILESTONES);
    loadMilestones((List<Milestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    StatusBar.displayMessage(MESSAGE_LOADING_ISSUES);
    loadIssues((List<Issue>)ghResources.get(ServiceManager.KEY_ISSUES));
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void loadComponents(IRepositoryIdProvider repoId,HashMap<String,List> resources){
  this.repoId=repoId;
  StatusBar.displayMessage(MESSAGE_LOADING_PROJECT_CONFIG);
  DataManager.getInstance().loadProjectConfig(getRepoId());
  cachedGithubComments=new ConcurrentHashMap<Integer,List<Comment>>();
  boolean isTurboResource=false;
  if (resources.get(ServiceManager.KEY_COLLABORATORS) != null) {
    if (resources.get(ServiceManager.KEY_COLLABORATORS).get(0).getClass() == TurboUser.class) {
      isTurboResource=true;
    }
  }
  if (isTurboResource) {
    loadTurboResources(resources);
  }
 else {
    StatusBar.displayMessage(MESSAGE_LOADING_COLLABS);
    loadCollaborators((List<User>)resources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(MESSAGE_LOADING_LABELS);
    loadLabels((List<Label>)resources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(MESSAGE_LOADING_MILESTONES);
    loadMilestones((List<Milestone>)resources.get(ServiceManager.KEY_MILESTONES));
    StatusBar.displayMessage(MESSAGE_LOADING_ISSUES);
    loadIssues((List<Issue>)resources.get(ServiceManager.KEY_ISSUES));
  }
}",0.6544021024967148
135456,"public void loadTurboCollaborators(List<TurboUser> list){
  Platform.runLater(() -> {
    collaborators.clear();
    collaborators.addAll(list);
  }
);
}","public void loadTurboCollaborators(List<TurboUser> list){
  collaborators.clear();
  collaborators.addAll(list);
}",0.8539325842696629
135457,"public void loadTurboIssues(List<TurboIssue> list){
  Platform.runLater(() -> {
    issues.clear();
    issues.addAll(list);
  }
);
}","public void loadTurboIssues(List<TurboIssue> list){
  issues.clear();
  issues.addAll(list);
}",0.8281938325991189
135458,"public void loadTurboMilestones(List<TurboMilestone> list){
  Platform.runLater(() -> {
    milestones.clear();
    milestones.addAll(list);
  }
);
}","public void loadTurboMilestones(List<TurboMilestone> list){
  milestones.clear();
  milestones.addAll(list);
}",0.8494208494208494
135459,"public void loadTurboLabels(List<TurboLabel> list){
  Platform.runLater(() -> {
    labels.clear();
    labels.addAll(list);
  }
);
}","public void loadTurboLabels(List<TurboLabel> list){
  labels.clear();
  labels.addAll(list);
}",0.8281938325991189
135460,"public void updateCachedIssues(List<Issue> issueList){
  if (issueList.size() == 0) {
    return;
  }
  WeakReference<Model> selfRef=new WeakReference<Model>(this);
  for (int i=issueList.size() - 1; i >= 0; i--) {
    Issue issue=issueList.get(i);
    Platform.runLater(new Runnable(){
      @Override public void run(){
        TurboIssue newCached=new TurboIssue(issue,selfRef.get());
        updateCachedIssue(newCached);
      }
    }
);
  }
}","public void updateCachedIssues(List<Issue> issueList){
  if (issueList.size() == 0) {
    return;
  }
  WeakReference<Model> selfRef=new WeakReference<Model>(this);
  for (int i=issueList.size() - 1; i >= 0; i--) {
    Issue issue=issueList.get(i);
    Platform.runLater(new Runnable(){
      @Override public void run(){
        TurboIssue newCached=new TurboIssue(issue,selfRef.get());
        updateCachedIssue(newCached);
      }
    }
);
  }
  DataCacheFileHandler.getInstance().writeToFile(repoId.toString(),issuesETag,collabsETag,labelsETag,milestonesETag,collaborators,labels,milestones,issues);
}",0.8509021842355176
135461,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void loadComponents(IRepositoryIdProvider repoId,HashMap<String,List> ghResources){
  this.repoId=repoId;
  StatusBar.displayMessage(""String_Node_Str"");
  DataManager.getInstance().loadProjectConfig(getRepoId());
  cachedGithubComments=new ConcurrentHashMap<Integer,List<Comment>>();
  boolean isTurboResource=false;
  if (ghResources.get(ServiceManager.KEY_COLLABORATORS) != null) {
    if (ghResources.get(ServiceManager.KEY_COLLABORATORS).get(0).getClass() == TurboUser.class) {
      isTurboResource=true;
    }
  }
  if (isTurboResource) {
    StatusBar.displayMessage(""String_Node_Str"");
    loadTurboCollaborators((List<TurboUser>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(""String_Node_Str"");
    loadTurboLabels((List<TurboLabel>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(""String_Node_Str"");
    loadTurboMilestones((List<TurboMilestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    StatusBar.displayMessage(""String_Node_Str"");
    loadTurboIssues((List<TurboIssue>)ghResources.get(ServiceManager.KEY_ISSUES));
  }
 else {
    StatusBar.displayMessage(""String_Node_Str"");
    loadCollaborators((List<User>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(""String_Node_Str"");
    loadLabels((List<Label>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(""String_Node_Str"");
    loadMilestones((List<Milestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    StatusBar.displayMessage(""String_Node_Str"");
    loadIssues((List<Issue>)ghResources.get(ServiceManager.KEY_ISSUES));
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void loadComponents(IRepositoryIdProvider repoId,HashMap<String,List> ghResources){
  this.repoId=repoId;
  StatusBar.displayMessage(MESSAGE_LOADING_PROJECT_CONFIG);
  DataManager.getInstance().loadProjectConfig(getRepoId());
  cachedGithubComments=new ConcurrentHashMap<Integer,List<Comment>>();
  boolean isTurboResource=false;
  if (ghResources.get(ServiceManager.KEY_COLLABORATORS) != null) {
    if (ghResources.get(ServiceManager.KEY_COLLABORATORS).get(0).getClass() == TurboUser.class) {
      isTurboResource=true;
    }
  }
  if (isTurboResource) {
    StatusBar.displayMessage(MESSAGE_LOADING_COLLABS);
    loadTurboCollaborators((List<TurboUser>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(MESSAGE_LOADING_LABELS);
    loadTurboLabels((List<TurboLabel>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(MESSAGE_LOADING_MILESTONES);
    loadTurboMilestones((List<TurboMilestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    StatusBar.displayMessage(MESSAGE_LOADING_ISSUES);
    loadTurboIssues((List<TurboIssue>)ghResources.get(ServiceManager.KEY_ISSUES));
  }
 else {
    StatusBar.displayMessage(MESSAGE_LOADING_COLLABS);
    loadCollaborators((List<User>)ghResources.get(ServiceManager.KEY_COLLABORATORS));
    StatusBar.displayMessage(MESSAGE_LOADING_LABELS);
    loadLabels((List<Label>)ghResources.get(ServiceManager.KEY_LABELS));
    StatusBar.displayMessage(MESSAGE_LOADING_MILESTONES);
    loadMilestones((List<Milestone>)ghResources.get(ServiceManager.KEY_MILESTONES));
    StatusBar.displayMessage(MESSAGE_LOADING_ISSUES);
    loadIssues((List<Issue>)ghResources.get(ServiceManager.KEY_ISSUES));
  }
}",0.8888888888888888
135462,"public void updateCachedIssue(TurboIssue issue){
  TurboIssue tIssue=getIssueWithId(issue.getId());
  if (tIssue != null) {
    tIssue.copyValues(issue);
  }
 else {
    issues.add(0,issue);
  }
  DataCacheFileHandler.getInstance().writeToFile(repoId.toString(),issuesETag,collabsETag,labelsETag,milestonesETag,collaborators,labels,milestones,issues);
}","public void updateCachedIssue(TurboIssue issue){
  TurboIssue tIssue=getIssueWithId(issue.getId());
  if (tIssue != null) {
    tIssue.copyValues(issue);
  }
 else {
    issues.add(0,issue);
  }
}",0.7140255009107468
135463,"public ArrayList<T> getUpdatedItems(IRepositoryIdProvider repoId){
  ArrayList<T> result=new ArrayList<T>();
  try {
    PagedRequest<T> request=createUpdatedRequest(repoId);
    PageIterator<T> requestIterator=new PageIterator<T>(request,client);
    HttpURLConnection connection=createUpdatedConnection(request);
    int responseCode=connection.getResponseCode();
    System.out.println(responseCode);
    if (client.isError(responseCode)) {
      return new ArrayList<T>();
    }
    if (responseCode != GitHubClientExtended.NO_UPDATE_RESPONSE_CODE) {
      result=(ArrayList<T>)getAll(requestIterator);
    }
    updateLastETag(connection);
    updateLastCheckTime(connection);
  }
 catch (  IOException e) {
    if (!(e instanceof UnknownHostException || e instanceof SocketTimeoutException)) {
      logger.error(e.getLocalizedMessage(),e);
    }
  }
catch (  ParseException e) {
    logger.error(e.getLocalizedMessage(),e);
  }
  return result;
}","public ArrayList<T> getUpdatedItems(IRepositoryIdProvider repoId){
  ArrayList<T> result=new ArrayList<T>();
  try {
    PagedRequest<T> request=createUpdatedRequest(repoId);
    if (apiSuffix == ""String_Node_Str"") {
      Map<String,String> temp=request.getParams();
      temp.remove(""String_Node_Str"");
      request.setParams(temp);
    }
    PageIterator<T> requestIterator=new PageIterator<T>(request,client);
    HttpURLConnection connection=createUpdatedConnection(request);
    int responseCode=connection.getResponseCode();
    System.out.println(responseCode);
    if (client.isError(responseCode)) {
      return new ArrayList<T>();
    }
    if (responseCode != GitHubClientExtended.NO_UPDATE_RESPONSE_CODE) {
      result=(ArrayList<T>)getAll(requestIterator);
    }
    updateLastETag(connection);
    updateLastCheckTime(connection);
  }
 catch (  IOException e) {
    if (!(e instanceof UnknownHostException || e instanceof SocketTimeoutException)) {
      logger.error(e.getLocalizedMessage(),e);
    }
  }
catch (  ParseException e) {
    logger.error(e.getLocalizedMessage(),e);
  }
  return result;
}",0.9189971070395372
135464,"@SuppressWarnings(""String_Node_Str"") public void writeToFile(String repoId,String issuesETag,String collabsETag,String labelsETag,String milestonesETag,ObservableList<TurboUser> collaborators,ObservableList<TurboLabel> labels,ObservableList<TurboMilestone> milestones,ObservableList<TurboIssue> issues){
  System.out.println(""String_Node_Str"");
  this.issues=issues.stream().collect(Collectors.toList());
  this.collaborators=collaborators.stream().collect(Collectors.toList());
  this.labels=labels.stream().collect(Collectors.toList());
  this.milestones=milestones.stream().collect(Collectors.toList());
  TurboRepoData currentRepoData=new TurboRepoData(repoId,issuesETag,collabsETag,labelsETag,milestonesETag,this.collaborators,this.labels,this.milestones,this.issues);
  if (repoDataList == null) {
    repoDataList=new ArrayList<TurboRepoData>();
  }
 else {
    for (int i=0; i < repoDataList.size(); i++) {
      if (repoDataList.get(i).getRepoId().equals(repoId)) {
        repoDataList.remove(i);
        break;
      }
    }
  }
  repoDataList.add(currentRepoData);
  Gson gson=new GsonBuilder().setPrettyPrinting().create();
  String json=gson.toJson(repoDataList);
  try {
    FileWriter writer=new FileWriter(FILE_DATA_CACHE_TEMP);
    writer.write(json);
    writer.close();
    File file=new File(FILE_DATA_CACHE);
    if (file.exists()) {
      boolean deleted=file.delete();
    }
    File newFile=new File(FILE_DATA_CACHE_TEMP);
    boolean renamed=newFile.renameTo(file);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void writeToFile(String repoId,String issuesETag,String collabsETag,String labelsETag,String milestonesETag,ObservableList<TurboUser> collaborators,ObservableList<TurboLabel> labels,ObservableList<TurboMilestone> milestones,ObservableList<TurboIssue> issues){
  this.issues=issues.stream().collect(Collectors.toList());
  this.collaborators=collaborators.stream().collect(Collectors.toList());
  this.labels=labels.stream().collect(Collectors.toList());
  this.milestones=milestones.stream().collect(Collectors.toList());
  TurboRepoData currentRepoData=new TurboRepoData(repoId,issuesETag,collabsETag,labelsETag,milestonesETag,this.collaborators,this.labels,this.milestones,this.issues);
  if (repoDataList == null) {
    repoDataList=new ArrayList<TurboRepoData>();
  }
 else {
    removeEntryIfExists(repoId);
  }
  repoDataList.add(currentRepoData);
  Gson gson=new GsonBuilder().setPrettyPrinting().create();
  String json=gson.toJson(repoDataList);
  try {
    FileWriter writer=new FileWriter(FILE_DATA_CACHE_TEMP);
    writer.write(json);
    writer.close();
    File file=new File(FILE_DATA_CACHE);
    if (file.exists()) {
      if (file.delete()) {
      }
 else {
        logger.error(""String_Node_Str"");
      }
    }
    File newFile=new File(FILE_DATA_CACHE_TEMP);
    if (newFile.renameTo(file)) {
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.8517034068136272
135465,"public void readFromFile(){
  Gson gson=new Gson();
  try {
    BufferedReader bufferedReader=new BufferedReader(new FileReader(FILE_DATA_CACHE));
    repoDataList=gson.fromJson(bufferedReader,new TypeToken<List<TurboRepoData>>(){
    }
.getType());
  }
 catch (  FileNotFoundException e) {
  }
}","public void readFromFile(){
  Gson gson=new Gson();
  try {
    BufferedReader bufferedReader=new BufferedReader(new FileReader(FILE_DATA_CACHE));
    repoDataList=gson.fromJson(bufferedReader,new TypeToken<List<TurboRepoData>>(){
    }
.getType());
    bufferedReader.close();
  }
 catch (  FileNotFoundException e) {
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}",0.8740740740740741
135466,"private static void setupChromeDriverExecutable(){
  String osName=System.getProperty(""String_Node_Str"");
  String binaryPath=osName.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : osName.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  File f=new File(binaryPath);
  if (!f.exists()) {
    InputStream in=BrowserComponent.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
    OutputStream out;
    try {
      out=new FileOutputStream(binaryPath);
      IOUtils.copy(in,out);
      out.close();
      f.setExecutable(true);
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"" + binaryPath + ""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"" + binaryPath);
  }
  System.setProperty(""String_Node_Str"",binaryPath);
}","private static void setupChromeDriverExecutable(){
  String osName=System.getProperty(""String_Node_Str"");
  String binaryFileName=osName.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : osName.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  File f=new File(binaryFileName);
  if (!f.exists()) {
    InputStream in=BrowserComponent.class.getClassLoader().getResourceAsStream(""String_Node_Str"" + binaryFileName);
    OutputStream out;
    try {
      out=new FileOutputStream(binaryFileName);
      IOUtils.copy(in,out);
      out.close();
      f.setExecutable(true);
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
      e.printStackTrace();
    }
    System.out.println(""String_Node_Str"" + binaryFileName + ""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"" + binaryFileName);
  }
  System.setProperty(""String_Node_Str"",binaryFileName);
}",0.9505830094392004
135467,"public static Optional<String> readResource(String packagePath){
  ClassLoader classLoader=UI.class.getClassLoader();
  File file=new File(classLoader.getResource(packagePath).getFile());
  BufferedReader reader;
  StringBuilder sb=new StringBuilder();
  try {
    reader=new BufferedReader(new FileReader(file));
    String line;
    while ((line=reader.readLine()) != null) {
      sb.append(line);
      sb.append(""String_Node_Str"");
    }
    reader.close();
    return Optional.of(sb.toString());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return Optional.empty();
}","public static Optional<String> readResource(String packagePath){
  ClassLoader classLoader=UI.class.getClassLoader();
  BufferedReader reader;
  InputStream inputStream=classLoader.getResourceAsStream(packagePath);
  StringBuilder sb=new StringBuilder();
  try {
    reader=new BufferedReader(new InputStreamReader(inputStream));
    String line;
    while ((line=reader.readLine()) != null) {
      sb.append(line);
      sb.append(""String_Node_Str"");
    }
    reader.close();
    return Optional.of(sb.toString());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return Optional.empty();
}",0.8557046979865772
135468,"/** 
 * Navigates to the GitHub page for the given issue in the currently-active driver window. Run on a separate thread.
 */
public void showIssue(int id){
  Thread th=new Thread(new Task<Void>(){
    @Override protected Void call(){
      login();
      driver.get(GitHubURL.getPathForIssue(id));
      hidePageElements();
      return null;
    }
  }
);
  th.setDaemon(true);
  th.start();
}","/** 
 * Navigates to the GitHub page for the given issue in the currently-active driver window. Run on a separate thread.
 */
public void showIssue(int id){
  Thread th=new Thread(new Task<Void>(){
    @Override protected Void call(){
      driver.get(GitHubURL.getPathForIssue(id));
      hidePageElements();
      return null;
    }
  }
);
  th.setDaemon(true);
  th.start();
}",0.9805950840879688
135469,"public IssueCommentsDisplay(UI ui){
  this.ui=ui;
}","public IssueCommentsDisplay(UI ui,TurboIssue current){
  this.ui=ui;
  this.issue=current;
}",0.7132867132867133
135470,"public void toggle(){
  if (!ui.toggleExpandedWidth()) {
    ui.getBrowserComponent().showIssue(1);
  }
 else {
  }
}","public void toggle(){
  if (!ui.toggleExpandedWidth()) {
    ui.getBrowserComponent().showIssue(issue.getId());
  }
 else {
  }
}",0.943089430894309
135471,"public IssueEditDisplay(UI ui,TurboIssue displayedIssue,Stage parentStage,Model model,IssueDisplayPane parent,boolean focusRequested){
  this.issueCommentsDisplay=new IssueCommentsDisplay(ui);
  this.ui=ui;
  this.issue=displayedIssue;
  this.model=model;
  this.parentStage=parentStage;
  this.parentContainer=new WeakReference<IssueDisplayPane>(parent);
  this.focusRequested=focusRequested;
  setup();
  setupKeyboardShortcuts();
}","public IssueEditDisplay(UI ui,TurboIssue displayedIssue,Stage parentStage,Model model,IssueDisplayPane parent,boolean focusRequested){
  this.ui=ui;
  this.issue=displayedIssue;
  this.model=model;
  this.parentStage=parentStage;
  this.parentContainer=new WeakReference<IssueDisplayPane>(parent);
  this.focusRequested=focusRequested;
  this.issueCommentsDisplay=new IssueCommentsDisplay(ui,issue);
  setup();
  setupKeyboardShortcuts();
}",0.8604118993135011
135472,"@SuppressWarnings(""String_Node_Str"") private void parseEventParameters(InputStream jsonBody){
  Gson gson=new Gson();
  Type type=new TypeToken<Map<String,Object>[]>(){
  }
.getType();
  BufferedReader reader;
  try {
    reader=new BufferedReader(new InputStreamReader(jsonBody,CHARSET_UTF8));
    Map<String,Object>[] eventsWithParameters=gson.fromJson(reader,type);
    IssueEvent[] issueEvents=(IssueEvent[])response.getBody();
    Map<String,String> parameters;
    for (int i=0; i < issueEvents.length; i++) {
      TurboIssueEvent event=new TurboIssueEvent(issueEvents[i].getActor(),IssueEventType.fromString(issueEvents[i].getEvent()));
switch (event.getType()) {
case Renamed:
        parameters=(Map<String,String>)eventsWithParameters[i].get(""String_Node_Str"");
      event.setRenamedFrom(parameters.get(""String_Node_Str""));
    event.setRenamedTo(parameters.get(""String_Node_Str""));
  break;
case Milestoned:
case Demilestoned:
parameters=(Map<String,String>)eventsWithParameters[i].get(""String_Node_Str"");
event.setMilestoneTitle(parameters.get(""String_Node_Str""));
break;
case Labeled:
case Unlabeled:
parameters=(Map<String,String>)eventsWithParameters[i].get(""String_Node_Str"");
event.setLabelColour(parameters.get(""String_Node_Str""));
event.setLabelName(parameters.get(""String_Node_Str""));
break;
case Assigned:
case Unassigned:
event.setAssignedUser((User)eventsWithParameters[i].get(""String_Node_Str""));
break;
case Closed:
case Reopened:
case Locked:
case Unlocked:
break;
case Subscribed:
case Merged:
case HeadRefDeleted:
case HeadRefRestored:
case Referenced:
case Mentioned:
default :
}
turboIssueEvents.add(event);
}
}
 catch (UnsupportedEncodingException e) {
e.printStackTrace();
}
}","@SuppressWarnings(""String_Node_Str"") private void parseEventParameters(InputStream jsonBody){
  Gson gson=new Gson();
  Type type=new TypeToken<Map<String,Object>[]>(){
  }
.getType();
  BufferedReader reader;
  try {
    reader=new BufferedReader(new InputStreamReader(jsonBody,CHARSET_UTF8));
    Map<String,Object>[] eventsWithParameters=gson.fromJson(reader,type);
    IssueEvent[] issueEvents=(IssueEvent[])response.getBody();
    Map<String,String> parameters;
    for (int i=0; i < issueEvents.length; i++) {
      TurboIssueEvent event=new TurboIssueEvent(issueEvents[i].getActor(),IssueEventType.fromString(issueEvents[i].getEvent()));
switch (event.getType()) {
case Renamed:
        parameters=(Map<String,String>)eventsWithParameters[i].get(""String_Node_Str"");
      event.setRenamedFrom(parameters.get(""String_Node_Str""));
    event.setRenamedTo(parameters.get(""String_Node_Str""));
  break;
case Milestoned:
case Demilestoned:
parameters=(Map<String,String>)eventsWithParameters[i].get(""String_Node_Str"");
event.setMilestoneTitle(parameters.get(""String_Node_Str""));
break;
case Labeled:
case Unlabeled:
parameters=(Map<String,String>)eventsWithParameters[i].get(""String_Node_Str"");
event.setLabelColour(parameters.get(""String_Node_Str""));
event.setLabelName(parameters.get(""String_Node_Str""));
break;
case Assigned:
case Unassigned:
Object assigneeMap=eventsWithParameters[i].get(""String_Node_Str"");
String json=new Gson().toJson(assigneeMap);
User user=gson.fromJson(json,User.class);
event.setAssignedUser(user);
break;
case Closed:
case Reopened:
case Locked:
case Unlocked:
break;
case Subscribed:
case Merged:
case HeadRefDeleted:
case HeadRefRestored:
case Referenced:
case Mentioned:
default :
}
turboIssueEvents.add(event);
}
}
 catch (UnsupportedEncodingException e) {
e.printStackTrace();
}
}",0.9543262411347516
135473,"public void setExclusive(boolean ex){
  exclusive=ex;
  for (  TurboLabel label : labels) {
    if (label.isExclusive() != ex) {
      String oldName=label.toGhName();
      label.setExclusive(ex);
    }
  }
}","public void setExclusive(boolean ex){
  exclusive=ex;
  for (  TurboLabel label : labels) {
    if (label.isExclusive() != ex) {
      String oldName=label.toGhName();
      label.setExclusive(ex);
      try {
        ServiceManager.getInstance().editLabel(label.toGhResource(),oldName);
      }
 catch (      IOException e) {
        logger.error(e.getLocalizedMessage(),e);
      }
    }
  }
}",0.6688741721854304
135474,"private Node tabLayout(){
  VBox everything=new VBox();
  TabPane tabs=new TabPane();
  if (labelsTab == null) {
    labelsTab=createLabelsTab();
  }
  if (milestonesTab == null) {
    milestonesTab=createMilestonesTab();
  }
  if (assigneesTab == null) {
    assigneesTab=createCollaboratorsTab();
  }
  tabs.getTabs().addAll(labelsTab,milestonesTab,assigneesTab);
  if (repoFields == null) {
    repoFields=createRepoFields();
  }
  everything.getChildren().addAll(repoFields,tabs);
  return everything;
}","private Node tabLayout(){
  VBox everything=new VBox();
  TabPane tabs=new TabPane();
  if (labelsTab == null) {
    labelsTab=createLabelsTab();
  }
  if (milestonesTab == null) {
    milestonesTab=createMilestonesTab();
  }
  if (assigneesTab == null) {
    assigneesTab=createCollaboratorsTab();
  }
  tabs.getTabs().addAll(labelsTab,milestonesTab,assigneesTab);
  if (repoFields == null) {
    repoFields=createRepoFields();
  }
  everything.getChildren().addAll(repoFields,tabs);
  everything.setPrefWidth(PANEL_PREF_WIDTH);
  return everything;
}",0.9575070821529744
135475,"@SuppressWarnings(""String_Node_Str"") public ArrayList<T> getUpdatedItems(IRepositoryIdProvider repoId){
  try {
    PagedRequest<T> request=createUpdatedRequest(repoId);
    PageIterator<T> requestIterator=new PageIterator<T>(request,client);
    HttpURLConnection connection=createUpdatedConnection(request);
    int responseCode=connection.getResponseCode();
    System.out.println(responseCode);
    if (client.isError(responseCode)) {
      return new ArrayList<T>();
    }
    updateLastETag(connection);
    updateLastCheckTime(connection);
    if (responseCode != GitHubClientExtended.NO_UPDATE_RESPONSE_CODE) {
      return (ArrayList<T>)getAll(requestIterator);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ParseException e) {
    e.printStackTrace();
  }
  return new ArrayList<T>();
}","@SuppressWarnings(""String_Node_Str"") public ArrayList<T> getUpdatedItems(IRepositoryIdProvider repoId){
  ArrayList<T> result=new ArrayList<T>();
  try {
    PagedRequest<T> request=createUpdatedRequest(repoId);
    PageIterator<T> requestIterator=new PageIterator<T>(request,client);
    HttpURLConnection connection=createUpdatedConnection(request);
    int responseCode=connection.getResponseCode();
    System.out.println(responseCode);
    if (client.isError(responseCode)) {
      return new ArrayList<T>();
    }
    if (responseCode != GitHubClientExtended.NO_UPDATE_RESPONSE_CODE) {
      result=(ArrayList<T>)getAll(requestIterator);
    }
    updateLastETag(connection);
    updateLastCheckTime(connection);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ParseException e) {
    e.printStackTrace();
  }
  return result;
}",0.8726190476190476
135476,"private void updateCommentsInList(Comment comment){
  comment.setBodyHtml(ServiceManager.getInstance().getMarkupForComment(comment));
  int index=getCommentsInListWithId(comment.getId());
  if (index != -1) {
    commentsList.set(index,comment);
  }
 else {
    commentsList.add(0,comment);
  }
}","private void updateCommentsInList(Comment comment){
  comment.setBodyHtml(ServiceManager.getInstance().getMarkupForComment(comment));
  int index=getCommentsInListWithId(comment.getId());
  if (index != -1) {
    commentsList.set(index,comment);
  }
 else {
    commentsList.add(comment);
  }
}",0.9966101694915256
135477,"private void applyChangeMethods(){
  for (  Runnable method : methodsOnChange) {
    method.run();
  }
}","public void applyChangeMethods(){
  for (  Runnable method : methodsOnChange) {
    method.run();
  }
}",0.9565217391304348
135478,"private TreeView<LabelTreeItem> createTreeView(Stage stage){
  final TreeItem<LabelTreeItem> treeRoot=new TreeItem<>(new TurboLabelGroup(ROOT_NAME));
  populateTree(treeRoot);
  final TreeView<LabelTreeItem> treeView=new TreeView<>();
  treeView.setRoot(treeRoot);
  treeView.setShowRoot(false);
  HBox.setHgrow(treeView,Priority.ALWAYS);
  treeView.setPrefHeight(2000);
  treeRoot.setExpanded(true);
  treeRoot.getChildren().forEach(child -> child.setExpanded(true));
  treeView.setCellFactory(new Callback<TreeView<LabelTreeItem>,TreeCell<LabelTreeItem>>(){
    @Override public TreeCell<LabelTreeItem> call(    TreeView<LabelTreeItem> stringTreeView){
      return new ManageLabelsTreeCell<LabelTreeItem>(stage,model,sidePanel);
    }
  }
);
  return treeView;
}","private TreeView<LabelTreeItem> createTreeView(Stage stage){
  final TreeItem<LabelTreeItem> treeRoot=new TreeItem<>(new TurboLabelGroup(ROOT_NAME));
  populateTree(treeRoot);
  final TreeView<LabelTreeItem> treeView=new TreeView<>();
  treeView.setRoot(treeRoot);
  treeView.setShowRoot(false);
  HBox.setHgrow(treeView,Priority.ALWAYS);
  treeView.setPrefHeight(2000);
  treeRoot.setExpanded(true);
  treeRoot.getChildren().forEach(child -> child.setExpanded(true));
  treeView.setCellFactory(createLabelCellFactory(stage));
  setupLabelsListChangeListener();
  return treeView;
}",0.7394209354120267
135479,"public VBox initialise(){
  VBox layout=new VBox();
  layout.setPadding(new Insets(15));
  layout.setSpacing(10);
  TreeView<LabelTreeItem> treeView=createTreeView(parentStage);
  layout.getChildren().addAll(createButtons(treeView),treeView);
  return layout;
}","public VBox initialise(){
  VBox layout=new VBox();
  layout.setPadding(new Insets(15));
  layout.setSpacing(10);
  treeView=createTreeView(parentStage);
  layout.getChildren().addAll(createButtons(treeView),treeView);
  return layout;
}",0.9518072289156626
135480,"public void deleteComment(TurboComment comment){
  try {
    commentsUpdater.stopCommentsListUpdate();
    ServiceManager.getInstance().deleteComment(comment.getId());
    removeCachedItem(comment.getId());
    commentsUpdater.startCommentsListUpdate();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void deleteComment(TurboComment comment){
  try {
    stopContentUpdate();
    ServiceManager.getInstance().deleteComment(comment.getId());
    removeCachedItem(comment.getId());
    startContentUpdate();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.4863945578231292
135481,"public boolean createComment(String text){
  try {
    ServiceManager.getInstance().createComment(issue.getId(),text);
    commentsUpdater.restartCommentsListUpdate();
    return true;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
}","public boolean createComment(String text){
  try {
    ServiceManager.getInstance().createComment(issue.getId(),text);
    restartContentUpdate();
    return true;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
}",0.9428007889546351
135482,"public boolean editComment(TurboComment comment){
  try {
    commentsUpdater.stopCommentsListUpdate();
    updateItemInCommentsList(comment);
    Comment ghComment=comment.toGhComment();
    ServiceManager.getInstance().editComment(ghComment);
    commentsUpdater.startCommentsListUpdate();
    return true;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
}","public boolean editComment(TurboComment comment){
  try {
    stopContentUpdate();
    updateItemInCommentsList(comment);
    Comment ghComment=comment.toGhComment();
    ServiceManager.getInstance().editComment(ghComment);
    startContentUpdate();
    return true;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
}",0.885558583106267
135483,"private void setupContent(){
  getDetailsContent();
  commentsUpdater=ServiceManager.getInstance().getCommentUpdateService(issue.getId(),allGhContent);
  setupCommentsChangeListener();
}","private void setupContent(){
  getDetailsContent();
  setupContentUpdater();
  setupCommentsChangeListener();
}",0.7070707070707071
135484,"private boolean loadIssues(){
  issues.clear();
  try {
    List<Issue> ghIssues=ServiceManager.getInstance().getAllIssues();
    ArrayList<TurboIssue> buffer=CollectionUtilities.getHubTurboIssueList(ghIssues);
    issues.addAll(buffer);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
  return true;
}","private boolean loadIssues(){
  issues.clear();
  try {
    List<Issue> ghIssues=ServiceManager.getInstance().getAllIssues();
    ArrayList<TurboIssue> buffer=CollectionUtilities.getHubTurboIssueList(ghIssues);
    alignIssueStatusAndState(buffer);
    issues.addAll(buffer);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
  return true;
}",0.945868945868946
135485,"@Override public void start(Stage stage) throws IOException {
  initCSS();
  sessionConfig=ConfigFileHandler.loadSessionConfig();
  mainStage=stage;
  stage.setMaximized(true);
  Scene scene=new Scene(createRoot(),800,600);
  setupMainStage(scene);
  loadFonts();
  applyCSS(scene);
  getUserCredentials();
}","@Override public void start(Stage stage) throws IOException {
  initCSS();
  sessionConfig=ConfigFileHandler.loadSessionConfig();
  mainStage=stage;
  stage.setMaximized(true);
  Scene scene=new Scene(createRoot());
  setupMainStage(scene);
  loadFonts();
  applyCSS(scene);
  getUserCredentials();
}",0.986842105263158
135486,"public void triggerIssueCreate(TurboIssue issue){
  mode=IssueEditMode.CREATE;
  displayedIssue=issue;
  setLayout(Layout.ISSUE);
}","public void triggerIssueCreate(TurboIssue issue){
  mode=IssueEditMode.CREATE;
  displayedIssue=issue;
  focusRequested=true;
  setLayout(Layout.ISSUE);
}",0.9192982456140352
135487,"@Override protected PagedRequest<Comment> createUpdatedRequest(IRepositoryIdProvider repoId){
  PagedRequest<Comment> request=new PagedRequest<Comment>();
  String path=SEGMENT_REPOS + ""String_Node_Str"" + repoId.generateId()+ SEGMENT_ISSUES+ ""String_Node_Str""+ issueId+ SEGMENT_COMMENTS;
  request.setUri(path);
  request.setResponseContentType(CONTENT_TYPE_JSON);
  request.setType(new TypeToken<Comment>(){
  }
.getType());
  request.setArrayType(new TypeToken<ArrayList<Comment>>(){
  }
.getType());
  return request;
}","@Override protected PagedRequest<Comment> createUpdatedRequest(IRepositoryIdProvider repoId){
  PagedRequest<Comment> request=new PagedRequest<Comment>();
  String path=SEGMENT_REPOS + ""String_Node_Str"" + repoId.generateId()+ SEGMENT_ISSUES+ ""String_Node_Str""+ issueId+ SEGMENT_COMMENTS;
  request.setUri(path);
  request.setParams(createUpdatedCommentsParams());
  request.setResponseContentType(CONTENT_TYPE_JSON);
  request.setType(new TypeToken<Comment>(){
  }
.getType());
  request.setArrayType(new TypeToken<ArrayList<Comment>>(){
  }
.getType());
  return request;
}",0.9525547445255474
135488,"protected void updateCachedComments(IRepositoryIdProvider repoId){
  List<Comment> updatedComments=super.getUpdatedItems(repoId);
  if (!updatedComments.isEmpty()) {
    List<Comment> removed=getRemovedComments(updatedComments);
    commentsList.removeAll(removed);
    updatedComments.stream().forEach(comment -> updateCommentsInList(comment));
    updateGlobalCachedCommentsForIssue(updatedComments);
  }
}","protected void updateCachedComments(IRepositoryIdProvider repoId){
  List<Comment> updatedComments=super.getUpdatedItems(repoId);
  Collections.reverse(updatedComments);
  if (!updatedComments.isEmpty()) {
    List<Comment> removed=getRemovedComments(updatedComments);
    commentsList.removeAll(removed);
    updatedComments.stream().forEach(comment -> updateCommentsInList(comment));
    updateGlobalCachedCommentsForIssue(updatedComments);
  }
}",0.9532710280373832
135489,"private HBox createRepoFields(){
  final ComboBox<String> comboBox=new ComboBox<String>();
  comboBox.setEditable(true);
  if (ServiceManager.getInstance().getRepoId() != null) {
    String repoId=ServiceManager.getInstance().getRepoId().generateId();
    comboBox.setValue(repoId);
    SessionConfigurations.addToLastViewedRepositories(repoId);
    comboBox.getItems().addAll(SessionConfigurations.getLastViewedRepositories());
  }
  comboBox.valueProperty().addListener((a,b,c) -> loadRepo(comboBox));
  HBox repoIdBox=new HBox();
  repoIdBox.setSpacing(5);
  repoIdBox.setPadding(new Insets(5));
  repoIdBox.setAlignment(Pos.CENTER);
  repoIdBox.getChildren().addAll(comboBox);
  comboBox.prefWidthProperty().bind(repoIdBox.widthProperty());
  return repoIdBox;
}","private HBox createRepoFields(){
  final ComboBox<String> comboBox=new ComboBox<String>();
  comboBox.setFocusTraversable(false);
  comboBox.setEditable(true);
  if (ServiceManager.getInstance().getRepoId() != null) {
    String repoId=ServiceManager.getInstance().getRepoId().generateId();
    comboBox.setValue(repoId);
    SessionConfigurations.addToLastViewedRepositories(repoId);
    comboBox.getItems().addAll(SessionConfigurations.getLastViewedRepositories());
  }
  comboBox.valueProperty().addListener((a,b,c) -> loadRepo(comboBox));
  HBox repoIdBox=new HBox();
  repoIdBox.setSpacing(5);
  repoIdBox.setPadding(new Insets(5));
  repoIdBox.setAlignment(Pos.CENTER);
  repoIdBox.getChildren().addAll(comboBox);
  comboBox.prefWidthProperty().bind(repoIdBox.widthProperty());
  return repoIdBox;
}",0.9751750477402928
135490,"public void handleDoneClicked(){
  TurboIssueCommand command;
  String message=""String_Node_Str"";
  boolean success=false;
  if (mode == IssueEditMode.CREATE) {
    command=new TurboIssueAdd(model,displayedIssue);
    success=command.execute();
    if (success) {
      displayedIssue.copyValues(((TurboIssueAdd)command).getAddedIssue());
      issueEditDisplay.updateIssueId(displayedIssue.getId());
      message=""String_Node_Str"";
    }
 else {
      message=""String_Node_Str"";
    }
  }
 else   if (mode == IssueEditMode.EDIT) {
    command=new TurboIssueEdit(model,originalIssue,displayedIssue);
    success=command.execute();
    if (success) {
      message=""String_Node_Str"";
    }
 else {
      message=""String_Node_Str"";
    }
  }
  StatusBar.displayMessage(message);
  if (success && !expandedIssueView) {
    showIssueDetailsDisplay(false);
    cleanup();
    parentPanel.get().displayTabs();
  }
}","public void handleDoneClicked(){
  TurboIssueCommand command;
  String message=""String_Node_Str"";
  boolean success=false;
  if (mode == IssueEditMode.CREATE) {
    command=new TurboIssueAdd(model,displayedIssue);
    success=command.execute();
    if (success) {
      updateStateAfterSuccessfulAdd(((TurboIssueAdd)command).getAddedIssue());
      message=""String_Node_Str"";
    }
 else {
      message=""String_Node_Str"";
    }
  }
 else   if (mode == IssueEditMode.EDIT) {
    command=new TurboIssueEdit(model,originalIssue,displayedIssue);
    success=command.execute();
    if (success) {
      updateStateAfterSuccessfulEdit(((TurboIssueEdit)command).getEditedIssue());
      message=""String_Node_Str"";
    }
 else {
      message=""String_Node_Str"";
    }
  }
  StatusBar.displayMessage(message);
  if (success && !expandedIssueView) {
    showIssueDetailsDisplay(false);
    cleanup();
    parentPanel.get().displayTabs();
  }
}",0.8546637744034707
135491,"private void getDetailsContent(){
  try {
    allGhContent.clear();
    List<Comment> allItems=ServiceManager.getInstance().getComments(issue.getId());
    allGhContent.addAll(allItems);
    updateData();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void getDetailsContent(){
  try {
    List<Comment> allItems=ServiceManager.getInstance().getComments(issue.getId());
    setGithubCommentsList(allItems);
    updateData();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.8779527559055118
135492,"private void handleCommentEdit(){
  boolean editRes=commentHandler.editComment(editedComment);
  if (editRes) {
    commentHandler.setCommentEditStateFalse(editedComment);
  }
}","private void handleCommentEdit(){
  if (commentHandler == null) {
    System.out.println(""String_Node_Str"");
  }
  boolean editRes=commentHandler.editComment(editedComment);
  if (editRes) {
    commentHandler.setCommentEditStateFalse(editedComment);
  }
}",0.8175519630484989
135493,"public CommentsEditBox(IssueDetailsContentHandler handler,TurboComment editedComment){
  this.commentHandler=handler;
  this.editedComment=editedComment;
  if (editedComment != null) {
    initialText=editedComment.getBody();
  }
  initialiseUIComponents();
  setupForCommentsEdit(editedComment);
  setupLayout();
}","public CommentsEditBox(IssueDetailsContentHandler handler,TurboComment editedComment){
  this.commentHandler=handler;
  this.editedComment=editedComment;
  if (editedComment != null) {
    initialText=editedComment.getBody();
  }
  setupForEditing();
}",0.8783068783068783
135494,"public void show(){
  if (issue == null || issue.getId() <= 0) {
    return;
  }
  Task<Boolean> bgTask=new Task<Boolean>(){
    @Override protected Boolean call() throws Exception {
      contentHandler.startContentUpdate();
      return true;
    }
  }
;
  WeakReference<IssueDetailsDisplay> selfRef=new WeakReference<>(this);
  bgTask.setOnSucceeded(new EventHandler<WorkerStateEvent>(){
    @Override public void handle(    WorkerStateEvent t){
      IssueDetailsDisplay self=selfRef.get();
      if (self != null) {
        self.scrollDisplayToBottom();
        self.loadFailCount=0;
      }
    }
  }
);
  bgTask.setOnFailed(new EventHandler<WorkerStateEvent>(){
    @Override public void handle(    WorkerStateEvent t){
      IssueDetailsDisplay self=selfRef.get();
      if (self != null) {
        self.loadFailCount+=1;
        if (loadFailCount <= 3) {
          self.show();
        }
 else {
          loadFailCount=0;
          StatusBar.displayMessage(""String_Node_Str"");
        }
      }
    }
  }
);
  DialogMessage.showProgressDialog(bgTask,""String_Node_Str"");
  backgroundThread=new Thread(bgTask);
  backgroundThread.start();
}","public void show(){
  if (issue == null || issue.getId() <= 0) {
    return;
  }
  loadIssueDetailsInBackground();
}",0.1787974683544304
135495,"private void setupWebEngineHeightListener(){
}","private void setupWebEngineHeightListener(){
  webViewHeightListener=new ChangeListener<Document>(){
    @Override public void changed(    ObservableValue<? extends Document> prop,    Document oldDoc,    Document newDoc){
      adjustWebEngineHeight();
    }
  }
;
  commentsText.getEngine().documentProperty().addListener(new WeakChangeListener<Document>(webViewHeightListener));
}",0.2149532710280373
135496,"private void adjustWebEngineHeight(){
  Object res=commentsText.getEngine().executeScript(""String_Node_Str"");
  if (res != null && res instanceof Integer) {
    Integer height=(Integer)res + WEB_TEXT_PADDING;
    commentsText.setPrefHeight(height);
  }
}","private void adjustWebEngineHeight(){
  if (heightAdjusted == true) {
    return;
  }
  Object res=commentsText.getEngine().executeScript(""String_Node_Str"");
  if (res != null && res instanceof Integer) {
    Integer height=(Integer)res + WEB_TEXT_PADDING;
    commentsText.setPrefHeight(height);
  }
  heightAdjusted=true;
}",0.8773747841105354
135497,"protected void setupCommentBodyChangeListener(){
  bodyChangeListener=new ChangeListener<String>(){
    @Override public void changed(    ObservableValue<? extends String> arg0,    String original,    String change){
      setDisplayedCommentText();
    }
  }
;
  originalComment.getBodyHtmlProperty().addListener(new WeakChangeListener<String>(bodyChangeListener));
}","protected void setupCommentBodyChangeListener(){
  bodyChangeListener=new ChangeListener<String>(){
    @Override public void changed(    ObservableValue<? extends String> arg0,    String original,    String change){
      setDisplayedCommentText();
      heightAdjusted=false;
    }
  }
;
  originalComment.getBodyHtmlProperty().addListener(new WeakChangeListener<String>(bodyChangeListener));
}",0.9633507853403142
135498,"@Override public void changed(ObservableValue<? extends String> arg0,String original,String change){
  setDisplayedCommentText();
}","@Override public void changed(ObservableValue<? extends Document> prop,Document oldDoc,Document newDoc){
  adjustWebEngineHeight();
}",0.6363636363636364
135499,"@Override protected void loadTopBar(){
  if (originalComment != null && !originalComment.isIssueLog()) {
    HBox commentsDetailsDisp=createCommentsDetailsDisplay();
    HBox controlsBox=createControlsBox();
    HBox.setHgrow(controlsBox,Priority.ALWAYS);
    topBar.setSpacing(100);
    topBar.getChildren().addAll(commentsDetailsDisp,controlsBox);
  }
 else {
    super.loadTopBar();
  }
}","@Override protected void loadTopBar(){
  if (originalComment != null && !originalComment.isIssueLog()) {
    HBox commentsDetailsDisp=createCommentsDetailsDisplay();
    HBox controlsBox=createControlsBox();
    HBox.setHgrow(controlsBox,Priority.ALWAYS);
    topBar.getChildren().addAll(commentsDetailsDisp,controlsBox);
  }
 else {
    super.loadTopBar();
  }
}",0.9628647214854112
135500,"private void loadNewCommentsBox(){
  CommentsEditBox box=new CommentsEditBox(handler);
  box.setPrefHeight(COMMENTS_CELL_HEIGHT);
  box.setPrefWidth(COMMENTS_CELL_WIDTH);
  TitledPane commentsContainer=new TitledPane(""String_Node_Str"",box);
  commentsContainer.setExpanded(false);
  commentsContainer.setPrefHeight(COMMENTS_BOX_PREF_HEIGHT);
  getChildren().add(commentsContainer);
}","private void loadNewCommentsBox(){
  CommentsEditBox box=new CommentsEditBox(handler);
  box.setPrefHeight(COMMENTS_CELL_HEIGHT);
  box.setPrefWidth(COMMENTS_CELL_WIDTH);
  TitledPane commentsContainer=new TitledPane(""String_Node_Str"",box);
  commentsContainer.setExpanded(false);
  commentsContainer.setPrefHeight(COMMENTS_BOX_PREF_HEIGHT);
  commentsContainer.setAlignment(Pos.BOTTOM_CENTER);
  getChildren().add(commentsContainer);
}",0.9352869352869352
135501,"private void loadItems(){
  if (displayType == DisplayType.COMMENTS) {
    loadNewCommentsBox();
  }
  setListItems();
  getChildren().add(0,listView);
}","private void loadItems(){
  if (displayType == DisplayType.COMMENTS) {
    loadNewCommentsBox();
  }
  setListItems();
  getChildren().add(0,listView);
  VBox.setVgrow(listView,Priority.ALWAYS);
}",0.8767908309455588
135502,"private void adjustWebEngineHeight(){
  try {
    Object res=commentsText.getEngine().executeScript(""String_Node_Str"");
    if (res != null && res instanceof Integer) {
      Integer height=(Integer)res + WEB_TEXT_PADDING;
      commentsText.setPrefHeight(height);
    }
  }
 catch (  Exception e) {
  }
  return;
}","private void adjustWebEngineHeight(){
  try {
    Object res=commentsText.getEngine().executeScript(""String_Node_Str"");
    System.out.println(commentsText.getEngine().executeScript(""String_Node_Str""));
    if (res != null && res instanceof Integer) {
      Integer height=(Integer)res + WEB_TEXT_PADDING;
      commentsText.setPrefHeight(height);
    }
  }
 catch (  Exception e) {
  }
  return;
}",0.8835904628330996
135503,"public void show(){
  if (issue == null || issue.getId() <= 0) {
    return;
  }
  Task<Boolean> bgTask=new Task<Boolean>(){
    @Override protected Boolean call() throws Exception {
      contentHandler.startContentUpdate();
      return true;
    }
  }
;
  WeakReference<IssueDetailsDisplay> selfRef=new WeakReference<>(this);
  bgTask.setOnSucceeded(new EventHandler<WorkerStateEvent>(){
    @Override public void handle(    WorkerStateEvent t){
      IssueDetailsDisplay self=selfRef.get();
      if (self != null) {
        self.scrollDisplayToBottom();
      }
    }
  }
);
  DialogMessage.showProgressDialog(bgTask,""String_Node_Str"");
  new Thread(bgTask).start();
}","public void show(){
  if (issue == null || issue.getId() <= 0) {
    return;
  }
  Task<Boolean> bgTask=new Task<Boolean>(){
    @Override protected Boolean call() throws Exception {
      contentHandler.startContentUpdate();
      return true;
    }
  }
;
  WeakReference<IssueDetailsDisplay> selfRef=new WeakReference<>(this);
  bgTask.setOnSucceeded(new EventHandler<WorkerStateEvent>(){
    @Override public void handle(    WorkerStateEvent t){
      IssueDetailsDisplay self=selfRef.get();
      if (self != null) {
        self.scrollDisplayToBottom();
      }
    }
  }
);
  DialogMessage.showProgressDialog(bgTask,""String_Node_Str"");
  backgroundThread=new Thread(bgTask);
  backgroundThread.start();
}",0.9732465654374548
135504,"private Tab createCommentsTab(){
  Tab comments=new Tab();
  comments.setText(""String_Node_Str"");
  comments.setClosable(false);
  commentsDisplay=createTabContentsDisplay(DisplayType.COMMENTS);
  comments.setContent(commentsDisplay);
  return comments;
}","private Tab createCommentsTab(){
  Tab comments=new Tab();
  comments.setText(""String_Node_Str"");
  comments.setClosable(false);
  commentsDisplay=createTabContentsDisplay(DisplayType.COMMENTS);
  VBox.setVgrow(commentsDisplay,Priority.ALWAYS);
  comments.setContent(commentsDisplay);
  return comments;
}",0.9107142857142856
135505,"private void updateItemInCommentsList(TurboComment comment){
  for (  TurboComment item : comments) {
    if (item.getId() == comment.getId()) {
      item.copyValues(comment);
      return;
    }
  }
  addItemToObservedCommentList(comment);
}","private void updateItemInCommentsList(TurboComment comment){
  for (  TurboComment item : comments) {
    if (item.getId() == comment.getId()) {
      replaceItemInObservedCommentsList(item,comment);
      return;
    }
  }
  addItemToObservedCommentList(comment);
}",0.899803536345776
135506,"private void addLabelsToIssueInGithub(List<Label> ghLabels) throws IOException {
  ServiceManager.getInstance().addLabelsToIssue(issue.getId(),ghLabels);
  updateGithubIssueState();
}","private void addLabelsToIssueInGithub() throws IOException {
  List<Label> issueLabels=CollectionUtilities.getGithubLabelList(issue.getLabels());
  ServiceManager.getInstance().setLabelsForIssue(issue.getId(),issueLabels);
  updateGithubIssueState();
}",0.6896551724137931
135507,"@Override public boolean execute(){
  ArrayList<Label> ghLabels=CollectionUtilities.getGithubLabelList(addedLabels);
  issue.addLabels(addedLabels);
  try {
    addLabelsToIssueInGithub(ghLabels);
    logAddOperation(true);
    isSuccessful=true;
  }
 catch (  IOException e) {
    issue.removeLabels(addedLabels);
    isSuccessful=false;
    e.printStackTrace();
  }
  return isSuccessful;
}","@Override public boolean execute(){
  issue.addLabels(addedLabels);
  try {
    addLabelsToIssueInGithub();
    logAddOperation(true);
    isSuccessful=true;
  }
 catch (  IOException e) {
    issue.removeLabels(addedLabels);
    isSuccessful=false;
    e.printStackTrace();
  }
  return isSuccessful;
}",0.6848920863309352
135508,"@Override public boolean undo(){
  ServiceManager service=ServiceManager.getInstance();
  ArrayList<Label> ghLabels=CollectionUtilities.getGithubLabelList(removedLabels);
  issue.addLabels(removedLabels);
  try {
    service.addLabelsToIssue(issue.getId(),ghLabels);
    updateGithubIssueState();
    logRemoveOperation(false);
    isUndone=true;
  }
 catch (  IOException e) {
    issue.removeLabels(removedLabels);
    isUndone=false;
    e.printStackTrace();
  }
  return isUndone;
}","@Override public boolean undo(){
  ServiceManager service=ServiceManager.getInstance();
  issue.addLabels(removedLabels);
  try {
    ArrayList<Label> ghLabels=CollectionUtilities.getGithubLabelList(issue.getLabels());
    service.setLabelsForIssue(issue.getId(),ghLabels);
    updateGithubIssueState();
    logRemoveOperation(false);
    isUndone=true;
  }
 catch (  IOException e) {
    issue.removeLabels(removedLabels);
    isUndone=false;
    e.printStackTrace();
  }
  return isUndone;
}",0.8273748723186926
135509,"private void removeLabelsWithGroup(String group){
  removeLabels(getLabelsWithGroup(group));
}","private void removeLabelsWithGroup(String group){
  List<TurboLabel> labels=getLabelsWithGroup(group);
  removeLabels(labels);
}",0.8018018018018018
135510,"private void setupDisplayedListSizeListener(){
  WeakReference<DetailsPanel> selfRef=new WeakReference<>(this);
  displayedListSizeListener=new ListChangeListener<TurboComment>(){
    @Override public void onChanged(    javafx.collections.ListChangeListener.Change<? extends TurboComment> arg0){
      if (listView.focusedProperty().get() != true && !detailsList.isEmpty()) {
        listView.scrollTo(detailsList.size() - 1);
      }
    }
  }
;
  detailsList.addListener(new WeakListChangeListener<TurboComment>(displayedListSizeListener));
}","private void setupDisplayedListSizeListener(){
  displayedListSizeListener=new ListChangeListener<TurboComment>(){
    @Override public void onChanged(    javafx.collections.ListChangeListener.Change<? extends TurboComment> arg0){
      if (listView.focusedProperty().get() != true && !detailsList.isEmpty()) {
        listView.scrollTo(detailsList.size() - 1);
      }
    }
  }
;
  detailsList.addListener(new WeakListChangeListener<TurboComment>(displayedListSizeListener));
}",0.9364613880742912
135511,"/** 
 * Returns a list of all repositories the user owns/contributes  and repositories belonging to organisations the user is a member of
 */
public List<Repository> getAllRepositories() throws IOException {
  HashSet<Repository> result=new HashSet<Repository>(getRepositories());
  result.addAll(getOrganisationRepositories());
  return new ArrayList<Repository>(result);
}","/** 
 * Returns a list of all repositories the user owns/contributes  and repositories belonging to organisations the user is a member of
 */
public List<Repository> getAllRepositories(String user) throws IOException {
  HashSet<Repository> result=new HashSet<Repository>(getRepositories(user));
  result.addAll(getOrganisationRepositories());
  return new ArrayList<Repository>(result);
}",0.980340760157274
135512,"public List<String> getRepositoriesNames() throws IOException {
  return getRepositories().stream().map(repo -> repo.getName()).collect(Collectors.toList());
}","public List<String> getRepositoriesNames(String user) throws IOException {
  return getRepositories(user).stream().map(repo -> repo.getName()).collect(Collectors.toList());
}",0.954954954954955
135513,"public List<String> getAllRepositoriesNames() throws IOException {
  return getAllRepositories().stream().map(repo -> repo.getName()).collect(Collectors.toList());
}","public List<String> getAllRepositoriesNames(String user) throws IOException {
  return getAllRepositories(user).stream().map(repo -> repo.getName()).collect(Collectors.toList());
}",0.9565217391304348
135514,"public List<String> getAllRepositoryNames() throws IOException {
  return repositoryService.getAllRepositoriesNames();
}","/** 
 * Returns a list of the names of the public repositories belonging to the user and the user's organisations
 */
public List<String> getAllRepositoryNames() throws IOException {
  return repositoryService.getAllRepositoriesNames(getUserId());
}",0.6504065040650406
135515,"public List<Repository> getAllRepositories() throws IOException {
  return repositoryService.getAllRepositories();
}","/** 
 * Returns a list of the public repositories belonging to the user and the user's organisations
 */
public List<Repository> getAllRepositories() throws IOException {
  return repositoryService.getAllRepositories(getUserId());
}",0.6666666666666666
135516,"public List<String> getRepositoriesNames() throws IOException {
  return repositoryService.getRepositoriesNames();
}","/** 
 * Returns a list of the names of the user's public repositories
 */
public List<String> getRepositoriesNames() throws IOException {
  return repositoryService.getRepositoriesNames(getUserId());
}",0.7318611987381703
135517,"/** 
 * Get user repositories
 */
public List<Repository> getRepositories() throws IOException {
  return repositoryService.getRepositories();
}","/** 
 * Returns a list of the user's public repositories
 */
public List<Repository> getRepositories() throws IOException {
  return repositoryService.getRepositories();
}",0.907936507936508
135518,"private HBox createRepoFields(){
  ComboBox<String> comboBox=new ComboBox<String>();
  HBox repoIdBox=new HBox();
  repoIdBox.setPadding(new Insets(5));
  repoIdBox.setAlignment(Pos.CENTER);
  repoIdBox.getChildren().add(comboBox);
  return repoIdBox;
}","private HBox createRepoFields(){
  ComboBox<String> comboBox=new ComboBox<String>();
  if (ServiceManager.getInstance().getUserId() != null) {
    System.out.println(ServiceManager.getInstance().getUserId());
    try {
      comboBox.setItems(FXCollections.observableArrayList(ServiceManager.getInstance().getAllRepositoryNames()));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  HBox repoIdBox=new HBox();
  repoIdBox.setPadding(new Insets(5));
  repoIdBox.setAlignment(Pos.CENTER);
  repoIdBox.getChildren().add(comboBox);
  return repoIdBox;
}",0.612590799031477
135519,"private FilterExpression parseExpression(int precedence){
}","private FilterExpression parseExpression(int precedence){
  Token token=consume();
  if (token.getType() == TokenType.EOF) {
    throw new ParseException(""String_Node_Str"" + position);
  }
  FilterExpression left;
switch (token.getType()) {
case LBRACKET:
    left=parseGroup(token);
  break;
case NEGATE:
left=parseNegation(token);
break;
case SYMBOL:
left=parsePredicate(token);
break;
default :
throw new ParseException(""String_Node_Str"" + token);
}
if (lookAhead().getType() == TokenType.EOF) return left;
while (precedence < getInfixPrecedence(token=lookAhead())) {
switch (token.getType()) {
case AND:
consume();
left=parseConjunction(left,token);
break;
case OR:
consume();
left=parseDisjunction(left,token);
break;
case SYMBOL:
case NEGATE:
case LBRACKET:
left=parseConjunction(left,token);
break;
default :
throw new ParseException(""String_Node_Str"" + token);
}
}
return left;
}",0.1247357293868921
135520,"public void stopContentUpdate(){
  if (commentsUpdater != null) {
  }
}","public void stopContentUpdate(){
  if (commentsUpdater != null) {
    commentsUpdater.stopCommentsListUpdate();
  }
}",0.7553191489361702
135521,"public void startContentUpdate(){
  if (isNotSetup()) {
    setupContent();
  }
  if (commentsUpdater != null) {
  }
}","public void startContentUpdate(){
  if (isNotSetup()) {
    setupContent();
  }
  if (commentsUpdater != null) {
    commentsUpdater.startCommentsListUpdate();
  }
}",0.833922261484099
135522,"private HBox createButtons(Stage stage){
  HBox buttons=new HBox();
  buttons.setAlignment(Pos.BASELINE_RIGHT);
  buttons.setSpacing(8);
  Button cancel=new Button();
  cancel.setText(""String_Node_Str"");
  cancel.setOnMouseClicked(e -> {
    response.complete(""String_Node_Str"");
    columns.deselect();
  }
);
  Button done=new Button();
  done.setText(""String_Node_Str"");
  done.setOnMouseClicked(e -> {
    response.complete(""String_Node_Str"");
  }
);
  buttons.getChildren().addAll(done,cancel);
  return buttons;
}","private HBox createButtons(Stage stage){
  HBox buttons=new HBox();
  buttons.setAlignment(Pos.BASELINE_RIGHT);
  buttons.setSpacing(8);
  Button cancel=new Button();
  cancel.setText(""String_Node_Str"");
  cancel.setOnMouseClicked(e -> {
    response.complete(""String_Node_Str"");
    columns.deselect();
    issueViewCleanup();
  }
);
  Button done=new Button();
  done.setText(""String_Node_Str"");
  done.setOnMouseClicked(e -> {
    response.complete(""String_Node_Str"");
    issueViewCleanup();
  }
);
  buttons.getChildren().addAll(done,cancel);
  return buttons;
}",0.9558011049723756
135523,"private HBox createIssueDetailsButton(){
  HBox container=new HBox();
  container.setAlignment(Pos.BASELINE_RIGHT);
  ToggleButton details=new ToggleButton();
  details.setText(ISSUE_DETAILS_BTN_TXT);
  WeakReference<ToggleButton> ref=new WeakReference<ToggleButton>(details);
  details.setOnAction((  ActionEvent e) -> {
    boolean selected=ref.get().selectedProperty().get();
    System.out.println(""String_Node_Str"" + selected);
    parentContainer.get().showIssueDetailsDisplay(selected);
  }
);
  container.getChildren().add(details);
  return container;
}","private HBox createIssueDetailsButton(){
  HBox container=new HBox();
  container.setAlignment(Pos.BASELINE_RIGHT);
  ToggleButton details=new ToggleButton();
  details.setText(ISSUE_DETAILS_BTN_TXT);
  WeakReference<ToggleButton> ref=new WeakReference<ToggleButton>(details);
  details.setOnAction((  ActionEvent e) -> {
    boolean selected=ref.get().selectedProperty().get();
    parentContainer.get().showIssueDetailsDisplay(selected);
  }
);
  container.getChildren().add(details);
  return container;
}",0.9495327102803738
135524,"private void setupMainStage(Scene scene){
  mainStage.setTitle(""String_Node_Str"");
  mainStage.setMinWidth(800);
  mainStage.setMinHeight(600);
  mainStage.setScene(scene);
  mainStage.show();
  mainStage.setOnCloseRequest(e -> {
    ServiceManager.getInstance().stopModelUpdate();
    columns.saveSession();
  }
);
}","private void setupMainStage(Scene scene){
  mainStage.setTitle(""String_Node_Str"");
  mainStage.setMinWidth(800);
  mainStage.setMinHeight(600);
  mainStage.setScene(scene);
  mainStage.show();
  mainStage.setOnCloseRequest(e -> {
    ServiceManager.getInstance().stopModelUpdate();
    columns.saveSession();
    Platform.exit();
    System.exit(0);
  }
);
}",0.9392592592592592
135525,"public static void loadFonts(){
  Font res=Font.loadFont(UI.class.getResource(""String_Node_Str"").toExternalForm(),24);
}","public static void loadFonts(){
  Font.loadFont(UI.class.getResource(""String_Node_Str"").toExternalForm(),24);
}",0.961038961038961
135526,"@Override public void run(){
  list.removeAll(removed);
  newList.stream().forEach(item -> updateCachedListItem((Listable)item,list));
}","@Override public void run(){
  list.removeAll(removed);
  newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
}",0.974910394265233
135527,"private void standardiseStatusLabels(List<Label> ghLabels){
  List<String> defaultStatuses=Defaults.getDefaultStatusLabels();
  List<String> projectLabels=new ArrayList<String>();
  ghLabels.stream().forEach(label -> projectLabels.add(label.getName()));
  defaultStatuses.removeAll(projectLabels);
  for (  String standardStatus : defaultStatuses) {
    Label statusLabel=new Label();
    statusLabel.setName(standardStatus);
    if (standardStatus.endsWith(""String_Node_Str"") || standardStatus.endsWith(""String_Node_Str"") || standardStatus.endsWith(""String_Node_Str"")|| standardStatus.endsWith(""String_Node_Str"")) {
      statusLabel.setColor(""String_Node_Str"");
    }
 else {
      statusLabel.setColor(""String_Node_Str"");
    }
    try {
      ghLabels.add(ServiceManager.getInstance().createLabel(statusLabel));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","private void standardiseStatusLabels(List<Label> ghLabels){
  List<String> defaultStatuses=Defaults.getDefaultStatusLabels();
  List<String> projectLabels=new ArrayList<String>();
  for (  Label label : ghLabels) {
    projectLabels.add(label.getName());
  }
  defaultStatuses.removeAll(projectLabels);
  for (  String standardStatus : defaultStatuses) {
    Label statusLabel=new Label();
    statusLabel.setName(standardStatus);
    if (standardStatus.endsWith(""String_Node_Str"") || standardStatus.endsWith(""String_Node_Str"") || standardStatus.endsWith(""String_Node_Str"")|| standardStatus.endsWith(""String_Node_Str"")) {
      statusLabel.setColor(""String_Node_Str"");
    }
 else {
      statusLabel.setColor(""String_Node_Str"");
    }
    try {
      ghLabels.add(ServiceManager.getInstance().createLabel(statusLabel));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}",0.928771733034212
135528,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void updateCachedList(List list,List newList){
  HashMap<String,HashSet> changes=CollectionUtilities.getChangesToList(list,newList);
  HashSet removed=changes.get(CollectionUtilities.REMOVED_TAG);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      list.removeAll(removed);
      newList.stream().forEach(item -> updateCachedListItem((Listable)item,list));
    }
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void updateCachedList(List list,List newList){
  HashMap<String,HashSet> changes=CollectionUtilities.getChangesToList(list,newList);
  HashSet removed=changes.get(CollectionUtilities.REMOVED_TAG);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      list.removeAll(removed);
      newList.stream().forEachOrdered(item -> updateCachedListItem((Listable)item,list));
    }
  }
);
}",0.9924324324324324
135529,"public void setAvatarUrl(String url){
  this.avatarUrl=url;
}","public void setAvatarUrl(String url){
  if (url != null) {
    this.avatarUrl=url;
  }
}",0.8187919463087249
135530,"public Image getAvatar(){
  if (avatar == null) {
    avatar=new Image(getAvatarUrl(),12,12,true,false);
  }
  return avatar;
}","public Image getAvatar(){
  if (avatarUrl == ""String_Node_Str"") {
    return null;
  }
  if (avatar == null) {
    avatar=new Image(getAvatarUrl(),12,12,true,false);
  }
  return avatar;
}",0.8063492063492064
135531,"private void updateCommentsInList(Comment comment){
  int index=getCommentsInListWithId(comment.getId());
  if (index != -1) {
    commentsList.set(index,comment);
  }
 else {
    commentsList.add(0,comment);
  }
}","private void updateCommentsInList(Comment comment){
  int index=getCommentsInListWithId(comment.getId());
  Platform.runLater(new Runnable(){
    @Override public void run(){
      if (index != -1) {
        commentsList.set(index,comment);
      }
 else {
        commentsList.add(0,comment);
      }
    }
  }
);
}",0.7962264150943397
135532,"@Override protected void loadTopBar(){
  topBar.setSpacing(100);
  topBar.getChildren().addAll(createCommentsDetailsDisplay(),createControlsBox());
}","@Override protected void loadTopBar(){
  HBox commentsDetailsDisp=createCommentsDetailsDisplay();
  HBox controlsBox=createControlsBox();
  topBar.setSpacing(100);
  topBar.getChildren().addAll(commentsDetailsDisp,controlsBox);
}",0.5396825396825397
135533,"protected void addListViewCellReference(Long commentId,DetailsCell cell){
  displayedCells.put(commentId,cell);
}","protected void addListViewCellReference(Long commentId,DetailsCell cell){
  displayedCells.put(commentId,cell);
  resizeListView();
}",0.91869918699187
135534,"protected void resizeListView(){
  List<Long> displayedIDs=detailsList.stream().map(item -> item.getId()).collect(Collectors.toList());
  double height;
  if (displayedIDs.size() == 0) {
    height=0;
  }
 else {
    Optional<Double> totalHeight=displayedIDs.stream().map(id -> getHeightOfCommentCell(id)).reduce((accum,val) -> accum + val);
    height=Math.min(totalHeight.get(),LIST_MAX_HEIGHT);
  }
  listView.setPrefHeight(height);
}","protected void resizeListView(){
  List<Long> displayedIDs=detailsList.stream().map(item -> item.getId()).collect(Collectors.toList());
  double height;
  int size=displayedIDs.size();
  if (size == 0) {
    height=0;
  }
 else   if (size > 10) {
    height=LIST_MAX_HEIGHT;
  }
 else {
    Optional<Double> totalHeight=displayedIDs.stream().map(id -> getHeightOfCommentCell(id)).reduce((accum,val) -> accum + val);
    height=Math.min(totalHeight.get(),LIST_MAX_HEIGHT);
  }
  listView.setPrefHeight(height);
}",0.5443037974683544
135535,"public IssueDetailsContentHandler(TurboIssue issue){
  this.issue=issue;
  setupContent();
}","public IssueDetailsContentHandler(TurboIssue issue){
  this.issue=issue;
}",0.891566265060241
135536,"public boolean isIssueLog(){
  return body.get().startsWith(ServiceManager.CHANGELOG_TAG);
}","public boolean isIssueLog(){
  String text=getBodyText();
  if (text == null) {
    text=getBody();
  }
  return text.startsWith(ServiceManager.CHANGELOG_TAG);
}",0.6640316205533597
135537,"public List<Comment> getComments(int issueId) throws IOException {
  ArrayList<Comment> comments=new ArrayList<Comment>();
  User testUser=new User();
  testUser.setLogin(""String_Node_Str"");
  Comment comment1=new Comment();
  comment1.setBody(""String_Node_Str"");
  comment1.setId(1);
  comment1.setUser(testUser);
  comment1.setCreatedAt(new Date());
  Comment comment2=new Comment();
  comment2.setBody(""String_Node_Str"");
  comment2.setId(3);
  comment2.setUser(testUser);
  comment2.setCreatedAt(new Date());
  Comment log1=new Comment();
  log1.setBody(ServiceManager.CHANGELOG_TAG + ""String_Node_Str"");
  log1.setId(2);
  log1.setUser(testUser);
  log1.setCreatedAt(new Date());
  comments.add(comment1);
  comments.add(log1);
  comments.add(comment2);
  return comments;
}","public List<Comment> getComments(int issueId) throws IOException {
  ArrayList<Comment> comments=new ArrayList<Comment>();
  User testUser=new User();
  testUser.setLogin(""String_Node_Str"");
  User anotherUser=new User();
  testUser.setLogin(""String_Node_Str"");
  Comment comment1=new Comment();
  comment1.setBody(""String_Node_Str"");
  comment1.setId(1);
  comment1.setUser(testUser);
  comment1.setCreatedAt(new Date());
  Comment comment2=new Comment();
  comment2.setBody(""String_Node_Str"");
  comment2.setId(3);
  comment2.setUser(anotherUser);
  comment2.setCreatedAt(new Date());
  Comment log1=new Comment();
  log1.setBody(ServiceManager.CHANGELOG_TAG + ""String_Node_Str"");
  log1.setId(2);
  log1.setUser(testUser);
  log1.setCreatedAt(new Date());
  comments.add(comment1);
  comments.add(log1);
  comments.add(comment2);
  return comments;
}",0.9497549019607844
135538,"@Override protected void loadCommentsDisplay(){
  commentsTextDisplay.getChildren().clear();
  if (editButton.selectedProperty().get() == false) {
    super.loadCommentsDisplay();
  }
 else {
    editableCommentsText.setText(originalComment.getBody());
    commentsTextDisplay.getChildren().add(editableCommentsText);
  }
}","@Override protected void loadCommentsDisplay(){
  commentsTextDisplay.getChildren().clear();
  if (!handler.commentIsInEditState(originalComment)) {
    super.loadCommentsDisplay();
  }
 else {
    editableCommentsText.setText(originalComment.getBody());
    commentsTextDisplay.getChildren().add(editableCommentsText);
  }
}",0.3580246913580246
135539,"public CommentCard(TurboComment comment){
  super(comment);
  this.editedComment=new TurboComment(comment);
}","public CommentCard(IssueDetailsContentHandler handler){
  super();
  this.handler=handler;
}",0.5472636815920398
135540,"private void initialiseEditButton(){
  editButton=new ToggleButton();
  editButton.setText(EDIT_BTN_TXT);
  WeakReference<CommentCard> selfRef=new WeakReference<CommentCard>(this);
  editButton.setOnMousePressed(e -> {
    selfRef.get().handleEditButtonPressed();
  }
);
}","private void initialiseEditButton(){
  editButton=new Button();
  editButton.setText(EDIT_BTN_TXT);
  WeakReference<CommentCard> selfRef=new WeakReference<CommentCard>(this);
  editButton.setOnMousePressed(e -> {
    selfRef.get().handleEditButtonPressed();
  }
);
}",0.9888475836431226
135541,"private void handleEditButtonPressed(){
  System.out.println(""String_Node_Str"");
  if (editButton.selectedProperty().get()) {
  }
  loadCommentsDisplay();
}","private void handleEditButtonPressed(){
  handler.toggleCommentEditState(originalComment);
  loadCommentsDisplay();
}",0.6227106227106227
135542,"@Override public void updateItem(TurboComment item,boolean empty){
  super.updateItem(item,empty);
  if (displayType == DisplayType.COMMENTS && item != null) {
    setGraphic(new CommentCard(item));
  }
 else   if (item != null) {
    setGraphic(new IssueDetailsCard(item));
  }
  setAlignment(Pos.CENTER);
}","@Override public void updateItem(TurboComment item,boolean empty){
  super.updateItem(item,empty);
  setAlignment(Pos.CENTER);
  if (item != null) {
    display.setDisplayedItem(item);
    setGraphic(display);
  }
}",0.4894837476099426
135543,"public DetailsCell(TurboIssue issue,DisplayType displayType){
  this.issue=issue;
  this.displayType=displayType;
}","public DetailsCell(TurboIssue issue,DisplayType displayType,IssueDetailsContentHandler handler){
  this.issue=issue;
  this.displayType=displayType;
  if (displayType == DisplayType.COMMENTS) {
    display=new CommentCard(handler);
  }
 else {
    display=new IssueDetailsCard();
  }
}",0.575
135544,"@Override public ListCell<TurboComment> call(ListView<TurboComment> list){
  return new DetailsCell(issue,displayType);
}","@Override public ListCell<TurboComment> call(ListView<TurboComment> list){
  return new DetailsCell(issue,displayType,handler);
}",0.968
135545,"private Callback<ListView<TurboComment>,ListCell<TurboComment>> commentCellFactory(){
  Callback<ListView<TurboComment>,ListCell<TurboComment>> factory=new Callback<ListView<TurboComment>,ListCell<TurboComment>>(){
    @Override public ListCell<TurboComment> call(    ListView<TurboComment> list){
      return new DetailsCell(issue,displayType);
    }
  }
;
  return factory;
}","private Callback<ListView<TurboComment>,ListCell<TurboComment>> commentCellFactory(){
  Callback<ListView<TurboComment>,ListCell<TurboComment>> factory=new Callback<ListView<TurboComment>,ListCell<TurboComment>>(){
    @Override public ListCell<TurboComment> call(    ListView<TurboComment> list){
      return new DetailsCell(issue,displayType,handler);
    }
  }
;
  return factory;
}",0.9895287958115184
135546,"private String stripChangeLogHeader(String text){
  if (text == null || !originalComment.isIssueLog()) {
    System.out.println(""String_Node_Str"" + text);
    return text;
  }
  return text.replaceFirst(Pattern.quote(ServiceManager.CHANGELOG_TAG),""String_Node_Str"");
}","private String stripChangeLogHeader(String text){
  if (text == null || !originalComment.isIssueLog()) {
    return text;
  }
  return text.replaceFirst(Pattern.quote(ServiceManager.CHANGELOG_TAG),""String_Node_Str"");
}",0.897119341563786
135547,"protected void initialiseCommentsText(){
  commentsText=new Text();
  commentsText.setWrappingWidth(PREF_WIDTH);
  initialiseCommentBodyChangeListener();
}","protected void initialiseCommentsText(){
  commentsText=new Text();
  commentsText.setWrappingWidth(PREF_WIDTH);
}",0.8475836431226765
135548,"public IssueDetailsCard(TurboComment comment){
  this.originalComment=comment;
  this.setSpacing(ELEMENTS_SPACING);
  this.setPrefWidth(PREF_WIDTH);
  initialiseUIComponents();
  loadCardComponents();
}","public IssueDetailsCard(){
  this.setSpacing(ELEMENTS_SPACING);
  this.setPrefWidth(PREF_WIDTH);
  initialiseUIComponents();
}",0.7682926829268293
135549,"public IssueDisplayPane(TurboIssue displayedIssue,Model model,ColumnControl columns){
  this.issue=displayedIssue;
  this.model=model;
  this.columns=columns;
  setup();
}","public IssueDisplayPane(TurboIssue displayedIssue,Stage parentStage,Model model,ColumnControl columns){
  this.issue=displayedIssue;
  this.model=model;
  this.parentStage=parentStage;
  this.columns=columns;
  setup();
}",0.8724489795918368
135550,"private void setup(){
  this.issueEditDisplay=new IssueEditDisplay(issue,model,columns,this);
  this.issueEditDisplay.setPrefWidth(ISSUE_WIDTH);
  this.issueEditDisplay.setMinWidth(ISSUE_WIDTH);
  this.issueDetailsDisplay=new IssueDetailsDisplay(issue);
  this.issueDetailsDisplay.setPrefWidth(DETAILS_WIDTH);
  this.issueDetailsDisplay.setMinWidth(DETAILS_WIDTH);
  this.getChildren().add(issueEditDisplay);
}","private void setup(){
  this.issueEditDisplay=new IssueEditDisplay(issue,parentStage,model,columns,this);
  this.issueEditDisplay.setPrefWidth(ISSUE_WIDTH);
  this.issueEditDisplay.setMinWidth(ISSUE_WIDTH);
  this.issueDetailsDisplay=new IssueDetailsDisplay(issue);
  this.issueDetailsDisplay.setPrefWidth(DETAILS_WIDTH);
  this.issueDetailsDisplay.setMinWidth(DETAILS_WIDTH);
  this.getChildren().add(issueEditDisplay);
}",0.9855769230769232
135551,"@Override public List<String> getPredicateNames(){
  return new ArrayList<String>(Arrays.asList(content));
}","@Override public List<String> getPredicateNames(){
  return new ArrayList<String>(Arrays.asList(name));
}",0.9671361502347418
135552,"public void refreshItems(){
  filteredList=new FilteredList<TurboIssue>(issues,predicate);
}","public void refreshItems(){
  transformedIssueList=new FilteredList<TurboIssue>(issues,predicate);
  if (currentFilterExpression instanceof filter.Predicate) {
    List<String> names=((filter.Predicate)currentFilterExpression).getPredicateNames();
    if (names.size() == 1 && names.get(0).equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      transformedIssueList=new SortedList<>(transformedIssueList,new Comparator<TurboIssue>(){
        @Override public int compare(        TurboIssue a,        TurboIssue b){
          if (a.getId() == b.getParentIssue()) {
            return -1;
          }
 else           if (b.getId() == a.getParentIssue()) {
            return 1;
          }
 else {
            return 0;
          }
        }
      }
);
    }
  }
}",0.1911262798634812
135553,"@Override public void refreshItems(){
  super.refreshItems();
  WeakReference<IssuePanel> that=new WeakReference<IssuePanel>(this);
  listView.setCellFactory(new Callback<ListView<TurboIssue>,ListCell<TurboIssue>>(){
    @Override public ListCell<TurboIssue> call(    ListView<TurboIssue> list){
      if (that.get() != null) {
        return new IssuePanelCell(mainStage,model,that.get(),columnIndex,sidePanel,parentColumnControl);
      }
 else {
        return null;
      }
    }
  }
);
  listView.setItems(null);
  listView.setItems(getFilteredList());
}","@Override public void refreshItems(){
  super.refreshItems();
  WeakReference<IssuePanel> that=new WeakReference<IssuePanel>(this);
  listView.setCellFactory(new Callback<ListView<TurboIssue>,ListCell<TurboIssue>>(){
    @Override public ListCell<TurboIssue> call(    ListView<TurboIssue> list){
      if (that.get() != null) {
        return new IssuePanelCell(mainStage,model,that.get(),columnIndex,sidePanel,parentColumnControl);
      }
 else {
        return null;
      }
    }
  }
);
  listView.setItems(null);
  listView.setItems(getIssueList());
}",0.988340807174888
135554,"public void updateCachedIssues(List<Issue> issueList){
  if (issueList.size() == 0) {
    return;
  }
  WeakReference<Model> selfRef=new WeakReference<Model>(this);
  for (  Issue issue : issueList) {
    Platform.runLater(new Runnable(){
      @Override public void run(){
        TurboIssue newCached=new TurboIssue(issue,selfRef.get());
        updateCachedIssue(newCached);
      }
    }
);
  }
}","public void updateCachedIssues(List<Issue> issueList){
  if (issueList.size() == 0) {
    return;
  }
  WeakReference<Model> selfRef=new WeakReference<Model>(this);
  for (int i=issueList.size() - 1; i >= 0; i--) {
    Issue issue=issueList.get(i);
    Platform.runLater(new Runnable(){
      @Override public void run(){
        TurboIssue newCached=new TurboIssue(issue,selfRef.get());
        updateCachedIssue(newCached);
      }
    }
);
  }
}",0.8844339622641509
135555,"public Date getDueOn(){
  return dueOn;
}","public LocalDate getDueOn(){
  return dueOn;
}",0.942528735632184
135556,"public Milestone toGhResource(){
  Milestone ghMilestone=new Milestone();
  ghMilestone.setTitle(getTitle());
  ghMilestone.setNumber(number);
  ghMilestone.setState(state);
  ghMilestone.setDescription(description);
  ghMilestone.setDueOn(dueOn);
  return ghMilestone;
}","public Milestone toGhResource(){
  Milestone ghMilestone=new Milestone();
  ghMilestone.setTitle(getTitle());
  ghMilestone.setNumber(number);
  ghMilestone.setState(state);
  ghMilestone.setDescription(description);
  ghMilestone.setDueOn(toDate(dueOn));
  return ghMilestone;
}",0.9854545454545456
135557,"public void setDueOn(Date dueOn){
  this.dueOn=dueOn;
}","public void setDueOn(LocalDate dueOn){
  this.dueOn=dueOn;
}",0.9565217391304348
135558,"private void respond(String title,Date dueDate){
  originalMilestone.setTitle(title);
  originalMilestone.setDueOn(dueDate);
  completeResponse(originalMilestone);
}","private void respond(String title,LocalDate dueDate){
  originalMilestone.setTitle(title);
  originalMilestone.setDueOn(dueDate);
  completeResponse(originalMilestone);
}",0.9850746268656716
135559,"@Override protected Parent content(){
  TextField milestoneTitleField=new TextField();
  milestoneTitleField.setPrefWidth(120);
  milestoneTitleField.setText(originalMilestone.getTitle());
  DatePicker datePicker=(originalMilestone.getDueOn() != null) ? new DatePicker(toTimeDate(originalMilestone.getDueOn())) : new DatePicker();
  datePicker.setPrefWidth(110);
  Button done=new Button(""String_Node_Str"");
  done.setOnAction(e -> {
    respond(milestoneTitleField.getText(),toUtilDate(datePicker.getValue()));
    close();
  }
);
  HBox layout=new HBox();
  layout.setPadding(new Insets(15));
  layout.setSpacing(10);
  layout.setAlignment(Pos.BASELINE_CENTER);
  layout.getChildren().addAll(milestoneTitleField,datePicker,done);
  return layout;
}","@Override protected Parent content(){
  TextField milestoneTitleField=new TextField();
  milestoneTitleField.setPrefWidth(120);
  milestoneTitleField.setText(originalMilestone.getTitle());
  DatePicker datePicker=(originalMilestone.getDueOn() != null) ? new DatePicker(originalMilestone.getDueOn()) : new DatePicker();
  datePicker.setPrefWidth(110);
  Button done=new Button(""String_Node_Str"");
  done.setOnAction(e -> {
    respond(milestoneTitleField.getText(),datePicker.getValue());
    close();
  }
);
  HBox layout=new HBox();
  layout.setPadding(new Insets(15));
  layout.setSpacing(10);
  layout.setAlignment(Pos.BASELINE_CENTER);
  layout.getChildren().addAll(milestoneTitleField,datePicker,done);
  return layout;
}",0.9552845528455284
135560,"private HBox createTopTitle(){
  HBox title=new HBox();
  title.setAlignment(Pos.BASELINE_LEFT);
  title.setSpacing(TITLE_SPACING);
  Text issueId=new Text(""String_Node_Str"" + issue.getId());
  issueId.setStyle(""String_Node_Str"");
  issueId.setOnMouseClicked(e -> {
    Browse.browse(issue.getHtmlUrl());
  }
);
  TextArea issueTitle=createIssueTitle();
  Parent statusBox=createStatusBox(parentStage);
  VBox topLeft=new VBox();
  topLeft.setSpacing(5);
  topLeft.setAlignment(Pos.CENTER);
  topLeft.getChildren().addAll(issueId,statusBox);
  int maxTitleHeight=TITLE_ROW_NUM * LINE_HEIGHT;
  issueTitle.setMaxHeight(maxTitleHeight);
  title.setMaxHeight(maxTitleHeight);
  topLeft.setMaxHeight(maxTitleHeight);
  title.getChildren().addAll(topLeft,issueTitle);
  return title;
}","private HBox createTopTitle(){
  HBox title=new HBox();
  title.setAlignment(Pos.BASELINE_LEFT);
  title.setSpacing(TITLE_SPACING);
  Text issueId=new Text(""String_Node_Str"" + issue.getId());
  issueId.setStyle(""String_Node_Str"");
  issueId.setOnMouseClicked(e -> {
    Browse.browse(issue.getHtmlUrl());
  }
);
  TextArea issueTitle=createIssueTitle();
  Parent statusBox=createStatusBox(parentStage);
  VBox topLeft=new VBox();
  topLeft.setSpacing(5);
  topLeft.setAlignment(Pos.CENTER);
  topLeft.getChildren().addAll(issueId,statusBox);
  int maxTitleHeight=TITLE_ROW_NUM * LINE_HEIGHT;
  issueTitle.setMaxHeight(maxTitleHeight);
  title.setMaxHeight(maxTitleHeight);
  topLeft.setMaxHeight(maxTitleHeight);
  title.getChildren().addAll(topLeft,issueTitle);
  title.setAlignment(Pos.CENTER);
  return title;
}",0.9786700125470514
135561,"private Parent createAssigneeBox(Stage stage){
}","private Parent createAssigneeBox(Stage stage){
  final ListableDisplayBox assigneeBox=new ListableDisplayBox(""String_Node_Str"",issue.getAssignee());
  List<TurboUser> allAssignees=model.getCollaborators();
  assigneeBox.setOnMouseClicked((e) -> {
    ArrayList<Integer> existingIndices=new ArrayList<Integer>();
    if (issue.getAssignee() != null) {
      int existingIndex=-1;
      for (int i=0; i < allAssignees.size(); i++) {
        if (allAssignees.get(i).equals(issue.getAssignee())) {
          existingIndex=i;
        }
      }
      if (existingIndex != -1) {
        existingIndices.add(existingIndex);
      }
    }
    (new CheckboxListDialog(stage,FXCollections.observableArrayList(allAssignees))).setWindowTitle(""String_Node_Str"").setMultipleSelection(false).setInitialCheckedState(existingIndices).show().thenApply((response) -> {
      TurboUser assignee=response.size() > 0 ? allAssignees.get(response.get(0)) : null;
      assigneeBox.setListableItem(assignee);
      issue.setAssignee(assignee);
      return true;
    }
).exceptionally(ex -> {
      ex.printStackTrace();
      return false;
    }
);
  }
);
  return assigneeBox;
}",0.0798668885191347
135562,"private Parent createMilestoneBox(Stage stage){
}","private Parent createMilestoneBox(Stage stage){
  final ListableDisplayBox milestoneBox=new ListableDisplayBox(""String_Node_Str"",issue.getMilestone());
  List<TurboMilestone> allMilestones=model.getMilestones();
  milestoneBox.setOnMouseClicked((e) -> {
    ArrayList<Integer> existingIndices=new ArrayList<Integer>();
    if (issue.getMilestone() != null) {
      int existingIndex=-1;
      for (int i=0; i < allMilestones.size(); i++) {
        if (allMilestones.get(i).equals(issue.getMilestone())) {
          existingIndex=i;
        }
      }
      if (existingIndex != -1) {
        existingIndices.add(existingIndex);
      }
    }
    (new CheckboxListDialog(stage,FXCollections.observableArrayList(allMilestones))).setWindowTitle(""String_Node_Str"").setMultipleSelection(false).setInitialCheckedState(existingIndices).show().thenApply((response) -> {
      TurboMilestone milestone=response.size() > 0 ? allMilestones.get(response.get(0)) : null;
      milestoneBox.setListableItem(milestone);
      issue.setMilestone(milestone);
      return true;
    }
).exceptionally(ex -> {
      ex.printStackTrace();
      return false;
    }
);
  }
);
  return milestoneBox;
}",0.0798696006519967
135563,"public static void main(String[] args){
}","public static void main(String[] args){
  FilterExpression p=Parser.parse(""String_Node_Str"");
  System.out.println(p);
}",0.5093167701863354
135564,"private int getInfixPrecedence(){
switch (lookAhead().getType()) {
case AND:
case SYMBOL:
case LBRACKET:
    return Precedence.CONJUNCTION;
case OR:
  return Precedence.DISJUNCTION;
case NEGATE:
return Precedence.PREFIX;
default :
return 0;
}
}","private int getInfixPrecedence(Token token){
switch (token.getType()) {
case AND:
case SYMBOL:
case LBRACKET:
    return Precedence.CONJUNCTION;
case OR:
  return Precedence.DISJUNCTION;
case NEGATE:
return Precedence.PREFIX;
default :
return 0;
}
}",0.9533468559837728
135565,"private Node createFilterBox(){
  HBox filterBox=new HBox();
  Label label=new Label(NO_FILTER);
  label.setPadding(new Insets(3));
  filterBox.setOnMouseClicked(e -> onFilterBoxClick(label));
  filterBox.setAlignment(Pos.TOP_LEFT);
  HBox.setHgrow(filterBox,Priority.ALWAYS);
  filterBox.getChildren().add(label);
  HBox rightAlignBox=new HBox();
  Label addIssue=new Label(""String_Node_Str"");
  addIssue.setStyle(""String_Node_Str"");
  addIssue.setOnMouseClicked((e) -> {
    TurboIssue issue=new TurboIssue(""String_Node_Str"",""String_Node_Str"",model);
    applyCurrentFilterExpressionToIssue(issue,false);
    sidePanel.displayIssue(issue).thenApply(r -> {
      if (r.equals(""String_Node_Str"")) {
        model.createIssue(issue);
      }
      parentColumnControl.refresh();
      sidePanel.displayTabs();
      return true;
    }
).exceptionally(ex -> {
      ex.printStackTrace();
      return false;
    }
);
  }
);
  Label closeList=new Label(""String_Node_Str"");
  closeList.setStyle(""String_Node_Str"");
  closeList.setOnMouseClicked((e) -> {
    parentColumnControl.closeColumn(columnIndex);
  }
);
  HBox.setMargin(rightAlignBox,new Insets(0,5,0,0));
  rightAlignBox.setSpacing(5);
  rightAlignBox.setAlignment(Pos.TOP_RIGHT);
  HBox.setHgrow(rightAlignBox,Priority.ALWAYS);
  rightAlignBox.getChildren().addAll(addIssue,closeList);
  HBox topBox=new HBox();
  topBox.setSpacing(5);
  topBox.getChildren().addAll(filterBox,rightAlignBox);
  return topBox;
}","private Node createFilterBox(){
  HBox filterBox=new HBox();
  Label label=new Label(NO_FILTER);
  label.setPadding(new Insets(3));
  filterBox.setOnMouseClicked(e -> onFilterBoxClick(label));
  filterBox.setAlignment(Pos.TOP_LEFT);
  HBox.setHgrow(filterBox,Priority.ALWAYS);
  filterBox.getChildren().add(label);
  HBox rightAlignBox=new HBox();
  WeakReference<Column> selfRef=new WeakReference<Column>(this);
  Label addIssue=new Label(""String_Node_Str"");
  addIssue.setStyle(""String_Node_Str"");
  addIssue.setOnMouseClicked((e) -> {
    TurboIssue issue=new TurboIssue(""String_Node_Str"",""String_Node_Str"",model);
    applyCurrentFilterExpressionToIssue(issue,false);
    sidePanel.displayIssue(issue).thenApply(r -> {
      if (r.equals(""String_Node_Str"")) {
        model.createIssue(issue);
      }
      parentColumnControl.refresh();
      sidePanel.displayTabs();
      return true;
    }
).exceptionally(ex -> {
      ex.printStackTrace();
      return false;
    }
);
  }
);
  Label closeList=new Label(""String_Node_Str"");
  closeList.setStyle(""String_Node_Str"");
  closeList.setOnMouseClicked((e) -> {
    parentColumnControl.closeColumn(selfRef.get());
  }
);
  HBox.setMargin(rightAlignBox,new Insets(0,5,0,0));
  rightAlignBox.setSpacing(5);
  rightAlignBox.setAlignment(Pos.TOP_RIGHT);
  HBox.setHgrow(rightAlignBox,Priority.ALWAYS);
  rightAlignBox.getChildren().addAll(addIssue,closeList);
  HBox topBox=new HBox();
  topBox.setSpacing(5);
  topBox.getChildren().addAll(filterBox,rightAlignBox);
  return topBox;
}",0.970323441147049
135566,"public void closeColumn(int index){
  getChildren().remove(index);
}","public void closeColumn(Column col){
  getChildren().remove(col);
}",0.8296296296296296
135567,"public boolean isSatisfiedBy(TurboIssue issue,Model model){
  if (name == null && content == null)   return true;
switch (name) {
case ""String_Node_Str"":
    return issue.getTitle().toLowerCase().contains(content.toLowerCase());
case ""String_Node_Str"":
  if (issue.getMilestone() == null)   return false;
return issue.getMilestone().getTitle().toLowerCase().contains(content.toLowerCase());
case ""String_Node_Str"":
content=content.toLowerCase();
if (content.startsWith(""String_Node_Str"")) {
return issue.getParentIssue() == Integer.parseInt(content.substring(1));
}
 else if (Character.isDigit(content.charAt(0))) {
return issue.getParentIssue() == Integer.parseInt(content);
}
 else {
List<TurboIssue> actualParentInstances=model.getIssues().stream().filter(i -> (issue.getParentIssue() == i.getId())).collect(Collectors.toList());
for (int i=0; i < actualParentInstances.size(); i++) {
if (actualParentInstances.get(i).getTitle().toLowerCase().contains(content)) {
  return true;
}
}
return false;
}
case ""String_Node_Str"":
content=content.toLowerCase();
String group=null;
if (content.contains(""String_Node_Str"")) {
int pos=content.indexOf('.');
group=content.substring(0,pos);
content=content.substring(pos + 1);
}
for (TurboLabel l : issue.getLabels()) {
if (l.getName().toLowerCase().contains(content)) {
if (group == null || l.getGroup().toLowerCase().contains(group)) {
return true;
}
}
}
return false;
case ""String_Node_Str"":
if (issue.getAssignee() == null) return false;
return issue.getAssignee().getGithubName().toLowerCase().contains(content.toLowerCase()) || (issue.getAssignee().getRealName() != null && issue.getAssignee().getRealName().toLowerCase().contains(content.toLowerCase()));
case ""String_Node_Str"":
case ""String_Node_Str"":
if (content.toLowerCase().contains(""String_Node_Str"")) {
return issue.getOpen();
}
 else if (content.toLowerCase().contains(""String_Node_Str"")) {
return !issue.getOpen();
}
 else {
return false;
}
default :
return false;
}
}","public boolean isSatisfiedBy(TurboIssue issue,Model model){
}",0.0599508599508599
135568,"public void setItems(ObservableList<TurboIssue> issues){
  this.issues=issues;
  refreshItems();
}","public void setItems(ObservableList<TurboIssue> issues){
  this.issues=issues;
  this.issues.addListener(new WeakListChangeListener<TurboIssue>(createIssuesListener()));
}",0.6840148698884758
135569,"private void setup(){
  setMaxWidth(330);
  if (displayWhenEmpty) {
    getStyleClass().add(""String_Node_Str"");
  }
  setHgap(3);
  setVgap(3);
  labels.addListener(new WeakListChangeListener<TurboLabel>(createLabelsChangeListener()));
  populateWithLabels();
}","private void setup(){
  setMaxWidth(330);
  setPrefWrapLength(330);
  if (displayWhenEmpty) {
    getStyleClass().add(""String_Node_Str"");
  }
  setHgap(3);
  setVgap(3);
  labels.addListener(new WeakListChangeListener<TurboLabel>(createLabelsChangeListener()));
  populateWithLabels();
}",0.9525547445255474
135570,"public void setItems(ObservableList<String> items){
  listeners.clear();
  ObservableList<BetterCheckListItem> newItems=FXCollections.observableArrayList();
  WeakReference<BetterCheckListView> that=new WeakReference<>(this);
  for (int i=0; i < items.size(); i++) {
    final int j=i;
    BetterCheckListItem item=new BetterCheckListItem(items.get(i),false);
    ChangeListener<Boolean> strongListener=new ChangeListener<Boolean>(){
      public void changed(      ObservableValue<? extends Boolean> ov,      Boolean oldValue,      Boolean newValue){
        if (!disabled) {
          if (singleSelection) {
            disabled=true;
            for (            BetterCheckListItem item : that.get().items) {
              item.setChecked(false);
            }
            that.get().items.get(j).setChecked(true);
            disabled=false;
          }
        }
      }
    }
;
    WeakChangeListener<Boolean> weakListener=new WeakChangeListener<Boolean>(strongListener);
    item.checkedProperty().addListener(weakListener);
    listeners.add(strongListener);
    newItems.add(item);
  }
  this.items=newItems;
  refresh();
}","public void setItems(ObservableList<String> items){
  listeners.clear();
  ObservableList<BetterCheckListItem> newItems=FXCollections.observableArrayList();
  WeakReference<BetterCheckListView> that=new WeakReference<>(this);
  for (int i=0; i < items.size(); i++) {
    final int j=i;
    BetterCheckListItem item=new BetterCheckListItem(items.get(i),false);
    ChangeListener<Boolean> strongListener=new ChangeListener<Boolean>(){
      public void changed(      ObservableValue<? extends Boolean> ov,      Boolean oldValue,      Boolean newValue){
        if (!disabled) {
          if (singleSelection) {
            disabled=true;
            for (            BetterCheckListItem item : that.get().items) {
              item.setChecked(false);
            }
            that.get().items.get(j).setChecked(newValue);
            disabled=false;
          }
        }
      }
    }
;
    WeakChangeListener<Boolean> weakListener=new WeakChangeListener<Boolean>(strongListener);
    item.checkedProperty().addListener(weakListener);
    listeners.add(strongListener);
    newItems.add(item);
  }
  this.items=newItems;
  refresh();
}",0.99647577092511
135571,"public void changed(ObservableValue<? extends Boolean> ov,Boolean oldValue,Boolean newValue){
  if (!disabled) {
    if (singleSelection) {
      disabled=true;
      for (      BetterCheckListItem item : that.get().items) {
        item.setChecked(false);
      }
      that.get().items.get(j).setChecked(true);
      disabled=false;
    }
  }
}","public void changed(ObservableValue<? extends Boolean> ov,Boolean oldValue,Boolean newValue){
  if (!disabled) {
    if (singleSelection) {
      disabled=true;
      for (      BetterCheckListItem item : that.get().items) {
        item.setChecked(false);
      }
      that.get().items.get(j).setChecked(newValue);
      disabled=false;
    }
  }
}",0.9885057471264368
135572,"public ParentIssuesDisplayBox(ObservableList<Integer> items,boolean displayWhenEmpty){
  setListableItems(items);
  this.displayWhenEmpty=displayWhenEmpty;
  setup();
}","public ParentIssuesDisplayBox(IntegerProperty item,boolean displayWhenEmpty){
  setListableItem(item);
  this.displayWhenEmpty=displayWhenEmpty;
  setup();
}",0.916923076923077
135573,"private void initialiseChangeListener(){
  if (listChangeListener != null) {
    listChangeListener=null;
  }
  if (this.issueNumbers != null) {
    WeakReference<ParentIssuesDisplayBox> that=new WeakReference<ParentIssuesDisplayBox>(this);
    listChangeListener=new ListChangeListener<Integer>(){
      @Override public void onChanged(      ListChangeListener.Change<? extends Integer> arg0){
        if (that.get() != null) {
          that.get().update();
        }
      }
    }
;
  }
}","private void initialiseChangeListener(){
  if (changeListener != null) {
    changeListener=null;
  }
  if (this.issueNumber != null) {
    WeakReference<ParentIssuesDisplayBox> that=new WeakReference<ParentIssuesDisplayBox>(this);
    changeListener=new ChangeListener<Number>(){
      @Override public void changed(      ObservableValue<? extends Number> arg0,      Number arg1,      Number arg2){
        that.get().update();
      }
    }
;
  }
}",0.7545164718384697
135574,"private void update(){
  getChildren().clear();
  Label label;
  if (displayWhenEmpty && issueNumbers.size() == 0) {
    label=new Label(""String_Node_Str"");
    label.getStyleClass().addAll(""String_Node_Str"",""String_Node_Str"");
    getChildren().add(label);
  }
 else {
    StringBuilder parentSB=new StringBuilder();
    for (    Integer p : issueNumbers) {
      parentSB.append(""String_Node_Str"" + p);
      parentSB.append(""String_Node_Str"");
    }
    if (parentSB.length() != 0)     parentSB.delete(parentSB.length() - 2,parentSB.length());
    if (displayWhenEmpty || (!displayWhenEmpty && !parentSB.toString().isEmpty())) {
      label=new Label(parentSB.toString());
      label.getStyleClass().addAll(""String_Node_Str"");
      getChildren().add(label);
    }
  }
}","private void update(){
  getChildren().clear();
  Label label;
  if (displayWhenEmpty && issueNumber.get() <= 0) {
    label=new Label(""String_Node_Str"");
    label.getStyleClass().addAll(""String_Node_Str"",""String_Node_Str"");
    getChildren().add(label);
  }
 else {
    String parentString=""String_Node_Str"" + issueNumber.get();
    label=new Label(parentString);
    label.getStyleClass().addAll(""String_Node_Str"");
    getChildren().add(label);
  }
}",0.5814332247557004
135575,"public void setLabels(List<TurboLabel> labels){
  if (this.labels != labels) {
    clearAllLabels();
    for (    TurboLabel label : labels) {
      addToLabels(label);
    }
  }
}","public void setLabels(List<TurboLabel> labels){
  if (this.labels != labels) {
    clearAllLabels();
    for (    TurboLabel label : labels) {
      addLabel(label);
    }
  }
}",0.9915966386554622
135576,"public void setParents(ObservableList<Integer> parentNumbers){
  if (this.parents == null) {
    this.parents=parentNumbers;
  }
 else   if (parentNumbers != this.parents) {
    this.parents.clear();
    this.parents.addAll(parentNumbers);
  }
}","public void setParents(ObservableList<Integer> parentNumbers){
  if (this.parents == null) {
    this.parents=parentNumbers;
  }
 else   if (parentNumbers != this.parents) {
    this.parents.clear();
    if (!parentNumbers.isEmpty()) {
      this.parents.add(parentNumbers.get(0));
    }
  }
}",0.8364312267657993
135577,"public void addParent(Integer parentId){
  if (!parents.contains(parentId)) {
    parents.add(parentId);
  }
}","public void addParent(Integer parentId){
  this.parents.clear();
  this.parents.add(parentId);
}",0.8058252427184466
135578,"private Parent createParentsBox(Stage stage){
}","private Parent createParentsBox(Stage stage){
  final ParentIssuesDisplayBox parentsBox=new ParentIssuesDisplayBox(issue.parentIssueProperty(),true);
  List<TurboIssue> allIssues=model.getIssues();
  parentsBox.setOnMouseClicked((e) -> {
    Integer originalParent=issue.getParentIssue();
    Integer indexForExistingParent=model.getIndexOfIssue(originalParent);
    ArrayList<Integer> existingIndices=new ArrayList<Integer>();
    existingIndices.add(indexForExistingParent);
    (new CheckboxListDialog(stage,FXCollections.observableArrayList(allIssues))).setWindowTitle(""String_Node_Str"").setMultipleSelection(false).setInitialCheckedState(existingIndices).show().thenApply((    List<Integer> response) -> {
      boolean wasAnythingSelected=response.size() > 0;
      if (wasAnythingSelected) {
        Integer parent=response.size() > 0 ? allIssues.get(response.get(0)).getId() : null;
        issue.setParentIssue(parent);
        model.processInheritedLabels(issue,originalParents);
      }
 else {
        issue.setParentIssue(-1);
      }
      return true;
    }
).exceptionally(ex -> {
      ex.printStackTrace();
      return false;
    }
);
  }
);
  return parentsBox;
}",0.0764227642276422
135579,"private ListChangeListener<Integer> createParentsChangeListener(){
  WeakReference<IssueIndicatorsDisplayBox> that=new WeakReference<IssueIndicatorsDisplayBox>(this);
  ListChangeListener<Integer> listChangeListener=new ListChangeListener<Integer>(){
    @Override public void onChanged(    ListChangeListener.Change<? extends Integer> arg0){
      if (that.get() != null) {
        that.get().updateIndicators(null);
      }
    }
  }
;
  changeListeners.add(listChangeListener);
  return listChangeListener;
}","private ChangeListener<Number> createParentsChangeListener(){
  WeakReference<IssueIndicatorsDisplayBox> that=new WeakReference<IssueIndicatorsDisplayBox>(this);
  ChangeListener<Number> changeListener=new ChangeListener<Number>(){
    @Override public void changed(    ObservableValue<? extends Number> arg0,    Number arg1,    Number arg2){
      if (that.get() != null) {
        that.get().updateIndicators(null);
      }
    }
  }
;
  changeListeners.add(changeListener);
  return changeListener;
}",0.8047337278106509
135580,"public IssueIndicatorsDisplayBox(TurboIssue issue,boolean displayWhenEmpty){
  this.parentIssues=issue.getParentsReference();
  if (issue.getMilestone() != null) {
    this.milestoneTitle=issue.getMilestone().titleProperty();
  }
  this.displayWhenEmpty=displayWhenEmpty;
  setup();
}","public IssueIndicatorsDisplayBox(TurboIssue issue,boolean displayWhenEmpty){
  this.parentIssue=issue.parentIssueProperty();
  if (issue.getMilestone() != null) {
    this.milestoneTitle=issue.getMilestone().titleProperty();
  }
  this.displayWhenEmpty=displayWhenEmpty;
  setup();
}",0.6137566137566137
135581,"private void setup(){
  if (displayWhenEmpty) {
    getStyleClass().add(""String_Node_Str"");
  }
  setSpacing(3);
  parentIssues.addListener(new WeakListChangeListener<Integer>(createParentsChangeListener()));
  if (this.milestoneTitle != null) {
    milestoneTitle.addListener(new WeakChangeListener<String>(createMilestoneChangeListener()));
  }
  updateIndicators(null);
}","private void setup(){
  if (displayWhenEmpty) {
    getStyleClass().add(""String_Node_Str"");
  }
  setSpacing(3);
  parentIssue.addListener(new WeakChangeListener<Number>(createParentsChangeListener()));
  if (this.milestoneTitle != null) {
    milestoneTitle.addListener(new WeakChangeListener<String>(createMilestoneChangeListener()));
  }
  updateIndicators(null);
}",0.981132075471698
135582,"private void updateIndicators(String newMilestoneTitle){
  getChildren().clear();
  if (this.milestoneTitle != null) {
    Label milestoneLabel=new Label();
    milestoneLabel.getStyleClass().add(""String_Node_Str"");
    if (newMilestoneTitle != null) {
      milestoneLabel.setText(newMilestoneTitle);
    }
 else {
      milestoneLabel.setText(milestoneTitle.get());
    }
    getChildren().add(milestoneLabel);
  }
  Label label;
  if (displayWhenEmpty && parentIssues.size() == 0) {
    label=new Label(""String_Node_Str"");
    label.getStyleClass().addAll(""String_Node_Str"",""String_Node_Str"");
    getChildren().add(label);
  }
 else {
    StringBuilder parentSB=new StringBuilder();
    for (    Integer p : parentIssues) {
      parentSB.append(""String_Node_Str"" + p);
      parentSB.append(""String_Node_Str"");
    }
    if (parentSB.length() != 0)     parentSB.delete(parentSB.length() - 2,parentSB.length());
    if (displayWhenEmpty || (!displayWhenEmpty && !parentSB.toString().isEmpty())) {
      label=new Label(parentSB.toString());
      label.getStyleClass().addAll(""String_Node_Str"");
      getChildren().add(label);
    }
  }
}","private void updateIndicators(String newMilestoneTitle){
  getChildren().clear();
  if (this.milestoneTitle != null) {
    Label milestoneLabel=new Label();
    milestoneLabel.getStyleClass().add(""String_Node_Str"");
    if (newMilestoneTitle != null) {
      milestoneLabel.setText(newMilestoneTitle);
    }
 else {
      milestoneLabel.setText(milestoneTitle.get());
    }
    getChildren().add(milestoneLabel);
  }
  Label label;
  if (displayWhenEmpty && parentIssue.get() <= 0) {
    label=new Label(""String_Node_Str"");
    label.getStyleClass().addAll(""String_Node_Str"",""String_Node_Str"");
    getChildren().add(label);
  }
 else {
    String parentString=""String_Node_Str"" + parentIssue.get();
    label=new Label(parentString);
    label.getStyleClass().addAll(""String_Node_Str"");
    getChildren().add(label);
  }
}",0.7121057985757884
135583,"@Override public void changed(ObservableValue<? extends String> stringProperty,String oldValue,String newValue){
  if (that.get() != null) {
    that.get().updateIndicators(newValue);
  }
}","@Override public void changed(ObservableValue<? extends Number> arg0,Number arg1,Number arg2){
  if (that.get() != null) {
    that.get().updateIndicators(null);
  }
}",0.7808988764044944
135584,"public void processInheritedLabels(TurboIssue issue,List<Integer> originalParents){
  List<Integer> editedParents=issue.getParents();
  HashMap<String,HashSet<Integer>> changeSet=CollectionUtilities.getChangesToList(originalParents,editedParents);
  HashSet<Integer> removed=changeSet.get(CollectionUtilities.REMOVED_TAG);
  HashSet<Integer> added=changeSet.get(CollectionUtilities.ADDED_TAG);
  removeInheritedLabels(removed,issue);
  addInheritedLabels(added,issue);
}","public void processInheritedLabels(TurboIssue issue,Integer originalParent){
  Integer newParent=issue.getParentIssue();
  removeInheritedLabel(originalParent,issue);
  addInheritedLabel(newParent,issue);
}",0.1715976331360946
135585,"private Parent createParentsBox(Stage stage){
  final ParentIssuesDisplayBox parentsBox=new ParentIssuesDisplayBox(issue.parentIssueProperty(),true);
  List<TurboIssue> allIssues=model.getIssues();
  parentsBox.setOnMouseClicked((e) -> {
    Integer originalParent=issue.getParentIssue();
    Integer indexForExistingParent=model.getIndexOfIssue(originalParent);
    ArrayList<Integer> existingIndices=new ArrayList<Integer>();
    existingIndices.add(indexForExistingParent);
    (new CheckboxListDialog(stage,FXCollections.observableArrayList(allIssues))).setWindowTitle(""String_Node_Str"").setMultipleSelection(false).setInitialCheckedState(existingIndices).show().thenApply((    List<Integer> response) -> {
      boolean wasAnythingSelected=response.size() > 0;
      if (wasAnythingSelected) {
        Integer parent=response.size() > 0 ? allIssues.get(response.get(0)).getId() : null;
        issue.setParentIssue(parent);
        model.processInheritedLabels(issue,originalParents);
      }
 else {
        issue.setParentIssue(-1);
      }
      return true;
    }
).exceptionally(ex -> {
      ex.printStackTrace();
      return false;
    }
);
  }
);
  return parentsBox;
}","private Parent createParentsBox(Stage stage){
  final ParentIssuesDisplayBox parentsBox=new ParentIssuesDisplayBox(issue.parentIssueProperty(),true);
  List<TurboIssue> allIssues=model.getIssues();
  parentsBox.setOnMouseClicked((e) -> {
    Integer originalParent=issue.getParentIssue();
    Integer indexForExistingParent=model.getIndexOfIssue(originalParent);
    ArrayList<Integer> existingIndices=new ArrayList<Integer>();
    existingIndices.add(indexForExistingParent);
    (new CheckboxListDialog(stage,FXCollections.observableArrayList(allIssues))).setWindowTitle(""String_Node_Str"").setMultipleSelection(false).setInitialCheckedState(existingIndices).show().thenApply((    List<Integer> response) -> {
      boolean wasAnythingSelected=response.size() > 0;
      if (wasAnythingSelected) {
        Integer parent=response.size() > 0 ? allIssues.get(response.get(0)).getId() : null;
        issue.setParentIssue(parent);
        model.processInheritedLabels(issue,originalParent);
      }
 else {
        issue.setParentIssue(-1);
      }
      return true;
    }
).exceptionally(ex -> {
      ex.printStackTrace();
      return false;
    }
);
  }
);
  return parentsBox;
}",0.9995771670190274
135586,"private MenuItem[] createGroupContextMenu(TurboIssue issue){
  MenuItem childMenuItem=new MenuItem(""String_Node_Str"");
  childMenuItem.setOnAction((event) -> {
    TurboIssue childIssue=new TurboIssue(""String_Node_Str"",""String_Node_Str"",model);
    childIssue.addParent(issue.getId());
    model.processInheritedLabels(childIssue,new ArrayList<Integer>());
    (new IssueDialog(mainStage,model,childIssue)).show().thenApply(response -> {
      if (response.equals(""String_Node_Str"")) {
        model.createIssue(childIssue);
      }
      return true;
    }
).exceptionally(ex -> {
      ex.printStackTrace();
      return false;
    }
);
  }
);
  return new MenuItem[]{childMenuItem};
}","private MenuItem[] createGroupContextMenu(TurboIssue issue){
  MenuItem childMenuItem=new MenuItem(""String_Node_Str"");
  childMenuItem.setOnAction((event) -> {
    TurboIssue childIssue=new TurboIssue(""String_Node_Str"",""String_Node_Str"",model);
    childIssue.setParentIssue(issue.getId());
    model.processInheritedLabels(childIssue,new ArrayList<Integer>());
    (new IssueDialog(mainStage,model,childIssue)).show().thenApply(response -> {
      if (response.equals(""String_Node_Str"")) {
        model.createIssue(childIssue);
      }
      return true;
    }
).exceptionally(ex -> {
      ex.printStackTrace();
      return false;
    }
);
  }
);
  return new MenuItem[]{childMenuItem};
}",0.9920232052211748
135587,"public void stopModelUpdate(){
  if (modelUpdater != null) {
    modelUpdater.startModelUpdate();
  }
}","public void stopModelUpdate(){
  if (modelUpdater != null) {
    modelUpdater.stopModelUpdate();
  }
}",0.975609756097561
135588,"private void updateModel(){
  updateModelIssues();
  updateModelCollaborators();
  updateModelLabels();
  updateModelMilestones();
}","private void updateModel(){
  updateModelIssues();
  updateModelCollaborators();
  updateModelLabels();
  updateModelMilestones();
  lastUpdateTime=issueUpdateService.lastCheckTime;
}",0.8380952380952381
135589,"@Override public void run(){
  updateCachedIssue(issue);
}","@Override public void run(){
  list.removeAll(removed);
  for (  Object item : newList) {
    updateCachedListItem((Listable)item,list);
  }
}",0.51
135590,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void updateCachedList(List list,List newList){
  HashMap<String,HashSet> changes=CollectionUtilities.getChangesToList(list,newList);
  HashSet removed=changes.get(CollectionUtilities.REMOVED_TAG);
  list.removeAll(removed);
  for (  Object item : newList) {
    updateCachedListItem((Listable)item,list);
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void updateCachedList(List list,List newList){
  HashMap<String,HashSet> changes=CollectionUtilities.getChangesToList(list,newList);
  HashSet removed=changes.get(CollectionUtilities.REMOVED_TAG);
  Platform.runLater(new Runnable(){
    @Override public void run(){
      list.removeAll(removed);
      for (      Object item : newList) {
        updateCachedListItem((Listable)item,list);
      }
    }
  }
);
}",0.8708920187793427
135591,"public void updateCachedLabels(List<Label> ghLabels){
  for (  Label ghLabel : ghLabels) {
    updateCachedListItem(new TurboLabel(ghLabel),labels);
  }
}","public void updateCachedLabels(List<Label> ghLabels){
  ArrayList<TurboLabel> newLabels=new ArrayList<TurboLabel>();
  for (  Label ghLabel : ghLabels) {
    newLabels.add(new TurboLabel(ghLabel));
  }
  updateCachedList(labels,newLabels);
}",0.6126582278481013
135592,"public void updateCachedMilestones(List<Milestone> ghMilestones){
  for (  Milestone ghMilestone : ghMilestones) {
    updateCachedListItem(new TurboMilestone(ghMilestone),milestones);
  }
}","public void updateCachedMilestones(List<Milestone> ghMilestones){
  ArrayList<TurboMilestone> newMilestones=new ArrayList<TurboMilestone>();
  for (  Milestone ghMilestone : ghMilestones) {
    newMilestones.add(new TurboMilestone(ghMilestone));
  }
  updateCachedList(milestones,newMilestones);
}",0.6160164271047228
135593,"@SuppressWarnings(""String_Node_Str"") private void updateCachedListItem(Listable updated,@SuppressWarnings(""String_Node_Str"") ObservableList list){
  int index=list.indexOf(updated);
  if (index != -1) {
    Listable old=(Listable)list.get(index);
    old.copyValues(updated);
  }
 else {
    list.add(updated);
  }
}","@SuppressWarnings(""String_Node_Str"") private void updateCachedListItem(Listable updated,@SuppressWarnings(""String_Node_Str"") List list){
  int index=list.indexOf(updated);
  if (index != -1) {
    Listable old=(Listable)list.get(index);
    old.copyValues(updated);
  }
 else {
    list.add(updated);
  }
}",0.9839228295819936
135594,"public void updateCachedCollaborators(List<User> ghCollaborators){
  for (  User ghCollaborator : ghCollaborators) {
    updateCachedListItem(new TurboUser(ghCollaborator),collaborators);
  }
}","public void updateCachedCollaborators(List<User> ghCollaborators){
  ArrayList<Listable> newCollaborators=new ArrayList<Listable>();
  for (  User ghCollaborator : ghCollaborators) {
    newCollaborators.add(new TurboUser(ghCollaborator));
  }
  updateCachedList(collaborators,newCollaborators);
}",0.6285714285714286
135595,"@Test public void basics(){
  assertEquals(Parser.parse(null),null);
  assertEquals(Parser.parse(""String_Node_Str""),null);
  assertEquals(Parser.parse(""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str""));
  assertEquals(Parser.parse(""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str""));
  assertEquals(Parser.parse(""String_Node_Str""),new Disjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Disjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Disjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Negation(new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Negation(new Predicate(""String_Node_Str"",""String_Node_Str"")));
}","@Test public void basics(){
  assertEquals(Parser.parse(null),null);
  assertEquals(Parser.parse(""String_Node_Str""),null);
  assertEquals(Parser.parse(""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str""));
  assertEquals(Parser.parse(""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str""));
  assertEquals(Parser.parse(""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str""));
  assertEquals(Parser.parse(""String_Node_Str""),new Disjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Disjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Disjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Conjunction(new Predicate(""String_Node_Str"",""String_Node_Str""),new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Negation(new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Negation(new Predicate(""String_Node_Str"",""String_Node_Str"")));
  assertEquals(Parser.parse(""String_Node_Str""),new Negation(new Predicate(""String_Node_Str"",""String_Node_Str"")));
}",0.8784741144414169
135596,"private FilterExpression parsePredicate(Token token){
  String name=token.getValue();
  String content;
  if (lookAhead().getType() == TokenType.COLON_SYMBOL) {
    String colonPlusContent=consume(TokenType.COLON_SYMBOL).getValue();
    content=colonPlusContent.substring(1).trim();
  }
 else {
    consume(TokenType.LBRACKET);
    content=consume().getValue();
    consume(TokenType.RBRACKET);
  }
  return new Predicate(name,content);
}","private FilterExpression parsePredicate(Token token){
  String name=token.getValue();
  String content=""String_Node_Str"";
  if (lookAhead().getType() == TokenType.COLON) {
    consume(TokenType.COLON);
    content=consume(TokenType.SYMBOL).getValue();
  }
 else {
    consume(TokenType.LBRACKET);
    while (lookAhead().getType() == TokenType.SYMBOL) {
      content+=consume(TokenType.SYMBOL).getValue() + ""String_Node_Str"";
    }
    content=content.trim();
    consume(TokenType.RBRACKET);
  }
  return new Predicate(name,content);
}",0.6344969199178645
135597,"public void setLabels(ObservableList<TurboLabel> labels){
  if (this.labels == labels) {
    return;
  }
  this.labels.clear();
  for (  TurboLabel label : labels) {
    this.labels.add(getLabelReference(label));
  }
  for (  TurboLabel currentLabel : labels) {
    if (UserConfigurations.isClosedStatusLabel(currentLabel.toGhName())) {
      this.setOpen(false);
      return;
    }
  }
  if (!getOpen()) {
    for (    TurboLabel currentLabel : labels) {
      if (UserConfigurations.isOpenStatusLabel(currentLabel.toGhName())) {
        this.setOpen(true);
        return;
      }
    }
  }
}","public void setLabels(ObservableList<TurboLabel> labels){
  this.labels=FXCollections.observableArrayList();
  for (  TurboLabel label : labels) {
    this.labels.add(getLabelReference(label));
  }
  for (  TurboLabel currentLabel : labels) {
    if (UserConfigurations.isClosedStatusLabel(currentLabel.toGhName())) {
      this.setOpen(false);
      return;
    }
  }
  if (!getOpen()) {
    for (    TurboLabel currentLabel : labels) {
      if (UserConfigurations.isOpenStatusLabel(currentLabel.toGhName())) {
        this.setOpen(true);
        return;
      }
    }
  }
}",0.9274124679760888
135598,"public void setItems(ObservableList<String> items){
  listeners.clear();
  ObservableList<BetterCheckListItem> newItems=FXCollections.observableArrayList();
  WeakReference<BetterCheckListView> that=new WeakReference<>(this);
  for (int i=0; i < items.size(); i++) {
    final int j=i;
    BetterCheckListItem item=new BetterCheckListItem(items.get(i),false);
    WeakChangeListener<Boolean> listener=new WeakChangeListener<Boolean>(new ChangeListener<Boolean>(){
      public void changed(      ObservableValue<? extends Boolean> ov,      Boolean oldValue,      Boolean newValue){
        if (!disabled) {
          if (singleSelection) {
            disabled=true;
            for (            BetterCheckListItem item : that.get().items) {
              item.setChecked(false);
            }
            that.get().items.get(j).setChecked(true);
            disabled=false;
          }
        }
      }
    }
);
    item.checkedProperty().addListener(listener);
    listeners.add(listener);
    newItems.add(item);
  }
  this.items=newItems;
  refresh();
}","public void setItems(ObservableList<String> items){
  listeners.clear();
  ObservableList<BetterCheckListItem> newItems=FXCollections.observableArrayList();
  WeakReference<BetterCheckListView> that=new WeakReference<>(this);
  for (int i=0; i < items.size(); i++) {
    final int j=i;
    BetterCheckListItem item=new BetterCheckListItem(items.get(i),false);
    ChangeListener<Boolean> strongListener=new ChangeListener<Boolean>(){
      public void changed(      ObservableValue<? extends Boolean> ov,      Boolean oldValue,      Boolean newValue){
        if (!disabled) {
          if (singleSelection) {
            disabled=true;
            for (            BetterCheckListItem item : that.get().items) {
              item.setChecked(false);
            }
            that.get().items.get(j).setChecked(true);
            disabled=false;
          }
        }
      }
    }
;
    WeakChangeListener<Boolean> weakListener=new WeakChangeListener<Boolean>(strongListener);
    item.checkedProperty().addListener(weakListener);
    listeners.add(strongListener);
    newItems.add(item);
  }
  this.items=newItems;
  refresh();
}",0.4806201550387597
135599,"public void setLabels(ObservableList<TurboLabel> labels){
  if (this.labels == labels) {
    return;
  }
  this.labels.clear();
  for (  TurboLabel label : labels) {
    this.labels.add(getLabelReference(label));
  }
  for (  TurboLabel currentLabel : labels) {
    if (UserConfigurations.isClosedStatusLabel(currentLabel.toGhName())) {
      this.setOpen(false);
      return;
    }
  }
  if (!getOpen()) {
    for (    TurboLabel currentLabel : labels) {
      if (UserConfigurations.isOpenStatusLabel(currentLabel.toGhName())) {
        this.setOpen(true);
        return;
      }
    }
  }
}","public void setLabels(ObservableList<TurboLabel> labels){
  this.labels=FXCollections.observableArrayList();
  for (  TurboLabel label : labels) {
    this.labels.add(getLabelReference(label));
  }
  for (  TurboLabel currentLabel : labels) {
    if (UserConfigurations.isClosedStatusLabel(currentLabel.toGhName())) {
      this.setOpen(false);
      return;
    }
  }
  if (!getOpen()) {
    for (    TurboLabel currentLabel : labels) {
      if (UserConfigurations.isOpenStatusLabel(currentLabel.toGhName())) {
        this.setOpen(true);
        return;
      }
    }
  }
}",0.9274124679760888
135600,"private void logLabelChange(HashSet<TurboLabel> removed,HashSet<TurboLabel> added,StringBuilder changeLog){
  if (added.size() > 0) {
    changeLog.append(""String_Node_Str"" + added.toString() + ""String_Node_Str"");
  }
  if (removed.size() > 0) {
    changeLog.append(""String_Node_Str"" + removed.toString() + ""String_Node_Str"");
  }
}","private void logLabelChange(HashSet<TurboLabel> removed,HashSet<TurboLabel> added,StringBuilder changeLog){
  if (added.size() > 0) {
    System.out.println(""String_Node_Str"" + added.toString());
    changeLog.append(""String_Node_Str"" + added.toString() + ""String_Node_Str"");
  }
  if (removed.size() > 0) {
    System.out.println(""String_Node_Str"" + removed.toString());
    changeLog.append(""String_Node_Str"" + removed.toString() + ""String_Node_Str"");
  }
}",0.8409090909090909
135601,"public void setLabels(ObservableList<TurboLabel> labels){
  this.labels.clear();
  for (  TurboLabel label : labels) {
    this.labels.add(getLabelReference(label));
  }
  for (  TurboLabel currentLabel : labels) {
    if (UserConfigurations.isClosedStatusLabel(currentLabel.toGhName())) {
      this.setOpen(false);
      return;
    }
  }
  if (!getOpen()) {
    for (    TurboLabel currentLabel : labels) {
      if (UserConfigurations.isOpenStatusLabel(currentLabel.toGhName())) {
        this.setOpen(true);
        return;
      }
    }
  }
}","public void setLabels(ObservableList<TurboLabel> labels){
  if (this.labels == labels) {
    return;
  }
  this.labels.clear();
  for (  TurboLabel label : labels) {
    this.labels.add(getLabelReference(label));
  }
  for (  TurboLabel currentLabel : labels) {
    if (UserConfigurations.isClosedStatusLabel(currentLabel.toGhName())) {
      this.setOpen(false);
      return;
    }
  }
  if (!getOpen()) {
    for (    TurboLabel currentLabel : labels) {
      if (UserConfigurations.isOpenStatusLabel(currentLabel.toGhName())) {
        this.setOpen(true);
        return;
      }
    }
  }
}",0.9588801399825022
135602,"public void setLabels(ObservableList<TurboLabel> labels){
  if (this.labels == null) {
    this.labels=labels;
  }
 else   if (labels != this.labels) {
    this.labels.clear();
    this.labels.addAll(labels);
  }
}","public void setLabels(ObservableList<TurboLabel> labels){
  if (this.labels == null) {
    this.labels=labels;
  }
 else   if (labels != this.labels) {
    for (    TurboLabel currentLabel : labels) {
      if (currentLabel.getName().equalsIgnoreCase(""String_Node_Str"") || currentLabel.getName().equalsIgnoreCase(""String_Node_Str"") || currentLabel.getName().equalsIgnoreCase(""String_Node_Str"")) {
        this.setOpen(false);
        break;
      }
    }
    this.labels.clear();
    this.labels.addAll(labels);
  }
}",0.585499316005472
135603,"@Override public ListCell<TurboIssue> call(ListView<TurboIssue> list){
  return new CustomListCell(mainStage,model,that);
}","@Override public ListCell<TurboIssue> call(ListView<TurboIssue> list){
  return new CustomListCell(mainStage,model,that.get());
}",0.9761904761904762
135604,"public void refreshItems(){
  filteredList=new FilteredList<TurboIssue>(issues,predicate);
  IssuePanel that=this;
  listView.setCellFactory(new Callback<ListView<TurboIssue>,ListCell<TurboIssue>>(){
    @Override public ListCell<TurboIssue> call(    ListView<TurboIssue> list){
      return new CustomListCell(mainStage,model,that);
    }
  }
);
  listView.setItems(null);
  listView.setItems(filteredList);
}","public void refreshItems(){
  filteredList=new FilteredList<TurboIssue>(issues,predicate);
  WeakReference<IssuePanel> that=new WeakReference<IssuePanel>(this);
  listView.setCellFactory(new Callback<ListView<TurboIssue>,ListCell<TurboIssue>>(){
    @Override public ListCell<TurboIssue> call(    ListView<TurboIssue> list){
      return new CustomListCell(mainStage,model,that.get());
    }
  }
);
  listView.setItems(null);
  listView.setItems(filteredList);
}",0.9403669724770642
135605,"public void setLabels(ObservableList<TurboLabel> labels){
  if (this.labels == null) {
    this.labels=labels;
  }
 else   if (labels != this.labels) {
    this.labels.clear();
    this.labels.addAll(labels);
  }
}","public void setLabels(ObservableList<TurboLabel> labels){
  if (this.labels == null) {
    this.labels=labels;
  }
 else   if (labels != this.labels) {
    for (    TurboLabel currentLabel : labels) {
      if (currentLabel.getName().equalsIgnoreCase(""String_Node_Str"") || currentLabel.getName().equalsIgnoreCase(""String_Node_Str"") || currentLabel.getName().equalsIgnoreCase(""String_Node_Str"")) {
        this.setOpen(false);
        break;
      }
    }
    this.labels.clear();
    this.labels.addAll(labels);
  }
}",0.585499316005472
135606,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((name == null) ? 0 : name.hashCode());
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((name == null) ? 0 : toGhName().hashCode());
  return result;
}",0.9746835443037974
135607,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  TurboLabel other=(TurboLabel)obj;
  if (name == null) {
    if (other.name != null)     return false;
  }
 else   if (!getName().equals(other.getName()))   return false;
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  TurboLabel other=(TurboLabel)obj;
  if (name == null) {
    return other.name == null;
  }
  return this.toGhName().equals(other.toGhName());
}",0.8300751879699249
135608,"public void updateIssue(TurboIssue originalIssue,TurboIssue editedIssue){
  try {
    int issueId=editedIssue.getId();
    TurboIssue latestIssue=new TurboIssue(issueService.getIssue(repoId,issueId));
    StringBuilder changeLog=editedIssue.mergeIssues(originalIssue,latestIssue);
    if (changeLog.length() > 0) {
      issueService.createComment(repoId,""String_Node_Str"" + issueId,changeLog.toString());
    }
    Issue latest=latestIssue.toGhResource();
    issueService.editIssue(repoId,latest);
    updateCachedIssue(latest);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void updateIssue(TurboIssue originalIssue,TurboIssue editedIssue){
  try {
    int issueId=editedIssue.getId();
    boolean descUpdated=updateIssueDescription(originalIssue,editedIssue.getDescription());
    if (!descUpdated) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(originalIssue.getDescription());
    }
    TurboIssue latestIssue=new TurboIssue(issueService.getIssue(repoId,issueId));
    StringBuilder changeLog=editedIssue.mergeIssues(originalIssue,latestIssue,false);
    if (changeLog.length() > 0) {
      issueService.createComment(repoId,""String_Node_Str"" + issueId,changeLog.toString());
    }
    Issue latest=latestIssue.toGhResource();
    issueService.editIssue(repoId,latest);
    updateCachedIssue(latest);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.8285514345696291
135609,"public Model(GitHubClient ghClient){
  this.collabService=new CollaboratorService(ghClient);
  this.issueService=new IssueService(ghClient);
  this.labelService=new LabelServiceFixed(ghClient);
  this.milestoneService=new MilestoneService(ghClient);
}","public Model(GitHubClientExtended ghClient){
  this.collabService=new CollaboratorService(ghClient);
  this.issueService=new IssueServiceExtended(ghClient);
  this.labelService=new LabelServiceFixed(ghClient);
  this.milestoneService=new MilestoneService(ghClient);
}",0.9691119691119692
135610,"/** 
 * Modifies @param latest to contain the merged changes of this TurboIssue object and @param latest wrt @param edited
 * @return StringBuilder containing a log of changes between this TurboIssue object and @param original
 */
protected StringBuilder mergeIssues(TurboIssue original,TurboIssue latest){
  StringBuilder changeLog=new StringBuilder();
  mergeTitle(original,latest,changeLog);
  mergeDescription(original,latest,changeLog);
  mergeParents(original,latest,changeLog);
  mergeLabels(original,latest,changeLog);
  mergeAssignee(original,latest,changeLog);
  mergeMilestone(original,latest,changeLog);
  mergeOpen(original,latest);
  return changeLog;
}","/** 
 * Modifies @param latest to contain the merged changes of this TurboIssue object and @param latest wrt @param edited
 * @return StringBuilder containing a log of changes between this TurboIssue object and @param original
 */
protected StringBuilder mergeIssues(TurboIssue original,TurboIssue latest,boolean overwriteDesc){
  StringBuilder changeLog=new StringBuilder();
  mergeTitle(original,latest,changeLog);
  if (overwriteDesc) {
    mergeDescription(original,latest,changeLog);
  }
  mergeParents(original,latest,changeLog);
  mergeLabels(original,latest,changeLog);
  mergeAssignee(original,latest,changeLog);
  mergeMilestone(original,latest,changeLog);
  mergeOpen(original,latest);
  return changeLog;
}",0.9574007220216606
135611,"private int getIndexOfIssue(long id){
  for (int i=0; i < issues.size(); i++) {
    if (((TurboIssue)(issues.get(i))).getId() == id) {
      return i;
    }
  }
  return -1;
}","private int getIndexOfIssue(int id){
  for (int i=0; i < issues.size(); i++) {
    if (((TurboIssue)(issues.get(i))).getId() == id) {
      return i;
    }
  }
  return -1;
}",0.98567335243553
135612,"private void updateCachedIssue(Issue issue){
  TurboIssue newCached=new TurboIssue(issue);
  int index=getIndexOfIssue(issue.getNumber());
  if (index != -1) {
    issues.set(index,newCached);
  }
 else {
    issues.add(0,newCached);
  }
}","private void updateCachedIssue(Issue issue){
  TurboIssue newCached=new TurboIssue(issue);
  int index=getIndexOfIssue(issue.getNumber());
  if (index != -1) {
    updateIssueAtIndex(index,newCached);
  }
 else {
    issues.add(0,newCached);
  }
}",0.9423868312757202
135613,"public void updateIssue(TurboIssue orignalIssue,TurboIssue editedIssue){
  Issue original=orignalIssue.toGhResource();
  Issue edited=editedIssue.toGhResource();
  StringBuilder changeLog=new StringBuilder();
  try {
    int issueId=editedIssue.getId();
    Issue latest=issueService.getIssue(repoId,issueId);
    mergeTitle(original,edited,latest);
    mergeBody(original,edited,latest);
    mergeAssignee(original,edited,latest,changeLog);
    mergeState(original,edited,latest,changeLog);
    mergeMilestone(original,edited,latest,changeLog);
    mergeLabels(original,edited,latest,changeLog);
    if (changeLog.length() > 0) {
      issueService.createComment(repoId,""String_Node_Str"" + issueId,changeLog.toString());
    }
    issueService.editIssue(repoId,latest);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void updateIssue(TurboIssue orignalIssue,TurboIssue editedIssue){
  Issue original=orignalIssue.toGhResource();
  Issue edited=editedIssue.toGhResource();
  StringBuilder changeLog=new StringBuilder();
  try {
    int issueId=editedIssue.getId();
    Issue latest=issueService.getIssue(repoId,issueId);
    mergeTitle(original,edited,latest);
    mergeBody(original,edited,latest);
    mergeAssignee(original,edited,latest,changeLog);
    mergeState(original,edited,latest,changeLog);
    mergeMilestone(original,edited,latest,changeLog);
    mergeLabels(original,edited,latest,changeLog);
    if (changeLog.length() > 0) {
      issueService.createComment(repoId,""String_Node_Str"" + issueId,changeLog.toString());
    }
    issueService.editIssue(repoId,latest);
    updateCachedIssue(latest);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9817109144542772
135614,"private void mergeLabels(Issue original,Issue edited,Issue latest,StringBuilder changeLog){
  List<Label> originalLabels=original.getLabels();
  List<Label> editedLabels=edited.getLabels();
  boolean isSameLabels=checkAndLogLabelChange(originalLabels,editedLabels,changeLog);
  if (!isSameLabels) {
    latest.setLabels(editedLabels);
  }
}","private void mergeLabels(Issue original,Issue edited,Issue latest,StringBuilder changeLog){
  List<Label> originalLabels=original.getLabels();
  List<Label> editedLabels=edited.getLabels();
  boolean changed=checkAndLogLabelChange(originalLabels,editedLabels,changeLog);
  if (changed) {
    latest.setLabels(editedLabels);
  }
}",0.9417040358744396
135615,"private void onDoubleClick(TurboIssue issue){
  TurboIssue copy=new TurboIssue(issue);
  (new IssueDialog(mainStage,model,issue)).show().thenApply(response -> {
    if (response.equals(""String_Node_Str"")) {
      model.updateIssue(copy,issue);
    }
    return true;
  }
);
}","private void onDoubleClick(TurboIssue issue){
  TurboIssue modifiedIssue=new TurboIssue(issue);
  (new IssueDialog(mainStage,model,modifiedIssue)).show().thenApply(response -> {
    if (response.equals(""String_Node_Str"")) {
      model.updateIssue(issue,modifiedIssue);
    }
    return true;
  }
);
}",0.9201388888888888
135616,"public void updateIssue(TurboIssue orignalIssue,TurboIssue editedIssue){
  Issue original=orignalIssue.toGhIssue();
  Issue edited=editedIssue.toGhIssue();
  try {
    Issue latest=issueService.getIssue(repoId,editedIssue.getId());
    String originalTitle=original.getTitle();
    String editedTitle=edited.getTitle();
    if (!editedTitle.equals(originalTitle)) {
      latest.setTitle(editedTitle);
    }
    String originalBody=original.getBody();
    String editedBody=edited.getBody();
    if (!editedBody.equals(originalBody)) {
      latest.setBody(editedBody);
    }
    User originalAssignee=original.getAssignee();
    User editedAssignee=edited.getAssignee();
    String originalALogin=(originalAssignee != null) ? originalAssignee.getLogin() : ""String_Node_Str"";
    String editedALogin=(editedAssignee != null) ? editedAssignee.getLogin() : ""String_Node_Str"";
    if (!editedALogin.equals(originalALogin)) {
      if (editedAssignee == null) {
        latest.setAssignee(new User());
      }
 else {
        latest.setAssignee(editedAssignee);
      }
    }
    String originalState=original.getState();
    String editedState=edited.getState();
    if (!editedState.equals(originalState)) {
      latest.setState(editedState);
    }
    Milestone originalMilestone=original.getMilestone();
    Milestone editedMilestone=edited.getMilestone();
    int originalMNumber=(originalMilestone != null) ? originalMilestone.getNumber() : 0;
    int editedMNumber=(editedMilestone != null) ? editedMilestone.getNumber() : 0;
    if (editedMNumber != originalMNumber) {
      if (editedMilestone == null) {
        latest.setMilestone(new Milestone());
      }
 else {
        latest.setMilestone(editedMilestone);
      }
    }
    List<Label> originalLabels=original.getLabels();
    List<Label> editedLabels=edited.getLabels();
    boolean isSameLabels=true;
    for (    Label editedLabel : editedLabels) {
      if (!originalLabels.contains(editedLabel)) {
        isSameLabels=false;
        break;
      }
    }
    if (!isSameLabels) {
      latest.setLabels(editedLabels);
    }
    issueService.editIssue(repoId,latest);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void updateIssue(TurboIssue orignalIssue,TurboIssue editedIssue){
  Issue original=orignalIssue.toGhIssue();
  Issue edited=editedIssue.toGhIssue();
  try {
    Issue latest=issueService.getIssue(repoId,editedIssue.getId());
    String originalTitle=original.getTitle();
    String editedTitle=edited.getTitle();
    if (!editedTitle.equals(originalTitle)) {
      latest.setTitle(editedTitle);
    }
    String originalBody=original.getBody();
    String editedBody=edited.getBody();
    if (!editedBody.equals(originalBody)) {
      latest.setBody(editedBody);
    }
    User originalAssignee=original.getAssignee();
    User editedAssignee=edited.getAssignee();
    String originalALogin=(originalAssignee != null) ? originalAssignee.getLogin() : ""String_Node_Str"";
    String editedALogin=(editedAssignee != null) ? editedAssignee.getLogin() : ""String_Node_Str"";
    if (!editedALogin.equals(originalALogin)) {
      if (editedAssignee == null) {
        latest.setAssignee(new User());
      }
 else {
        latest.setAssignee(editedAssignee);
      }
    }
    String originalState=original.getState();
    String editedState=edited.getState();
    if (!editedState.equals(originalState)) {
      latest.setState(editedState);
    }
    Milestone originalMilestone=original.getMilestone();
    Milestone editedMilestone=edited.getMilestone();
    int originalMNumber=(originalMilestone != null) ? originalMilestone.getNumber() : 0;
    int editedMNumber=(editedMilestone != null) ? editedMilestone.getNumber() : 0;
    if (editedMNumber != originalMNumber) {
      if (editedMilestone == null) {
        latest.setMilestone(new Milestone());
      }
 else {
        latest.setMilestone(editedMilestone);
      }
    }
    List<Label> originalLabels=original.getLabels();
    List<Label> editedLabels=edited.getLabels();
    boolean isSameLabels=true;
    if (originalLabels.size() != editedLabels.size()) {
      isSameLabels=false;
    }
 else {
      for (      Label originalLabel : originalLabels) {
        if (!editedLabels.contains(originalLabel)) {
          isSameLabels=false;
          break;
        }
      }
    }
    if (!isSameLabels) {
      latest.setLabels(editedLabels);
    }
    issueService.editIssue(repoId,latest);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9556737588652482
135617,"public void updateIssue(TurboIssue orignalIssue,TurboIssue editedIssue){
  Issue original=orignalIssue.toGhIssue();
  Issue edited=editedIssue.toGhIssue();
  try {
    Issue latest=issueService.getIssue(repoId,editedIssue.getId());
    String originalTitle=original.getTitle();
    String editedTitle=edited.getTitle();
    if (!editedTitle.equals(originalTitle)) {
      latest.setTitle(editedTitle);
    }
    String originalBody=original.getBody();
    String editedBody=edited.getBody();
    if (!editedBody.equals(originalBody)) {
      latest.setBody(editedBody);
    }
    String originalAssignee=original.getAssignee().getLogin();
    String editedAssignee=edited.getAssignee().getLogin();
    if (!editedAssignee.equals(originalAssignee)) {
      latest.setAssignee(edited.getAssignee());
    }
    String originalState=original.getState();
    String editedState=edited.getState();
    if (!editedState.equals(originalState)) {
      latest.setState(editedState);
    }
    int originalMilestone=original.getMilestone().getNumber();
    int editedMilestone=edited.getMilestone().getNumber();
    if (editedMilestone != originalMilestone) {
      latest.setMilestone(edited.getMilestone());
    }
    List<Label> originalLabels=original.getLabels();
    List<Label> editedLabels=edited.getLabels();
    boolean isSameLabels=true;
    for (    Label editedLabel : editedLabels) {
      if (originalLabels.contains(editedLabel)) {
        isSameLabels=false;
        break;
      }
    }
    if (!isSameLabels) {
      latest.setLabels(editedLabels);
    }
    issueService.editIssue(repoId,latest);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void updateIssue(TurboIssue orignalIssue,TurboIssue editedIssue){
  Issue original=orignalIssue.toGhIssue();
  Issue edited=editedIssue.toGhIssue();
  try {
    Issue latest=issueService.getIssue(repoId,editedIssue.getId());
    String originalTitle=original.getTitle();
    String editedTitle=edited.getTitle();
    if (!editedTitle.equals(originalTitle)) {
      latest.setTitle(editedTitle);
    }
    String originalBody=original.getBody();
    String editedBody=edited.getBody();
    if (!editedBody.equals(originalBody)) {
      latest.setBody(editedBody);
    }
    User originalAssignee=original.getAssignee();
    User editedAssignee=edited.getAssignee();
    String originalALogin=(originalAssignee != null) ? originalAssignee.getLogin() : ""String_Node_Str"";
    String editedALogin=(editedAssignee != null) ? editedAssignee.getLogin() : ""String_Node_Str"";
    if (!editedALogin.equals(originalALogin)) {
      if (editedAssignee == null) {
        latest.setAssignee(new User());
      }
 else {
        latest.setAssignee(editedAssignee);
      }
    }
    String originalState=original.getState();
    String editedState=edited.getState();
    if (!editedState.equals(originalState)) {
      latest.setState(editedState);
    }
    Milestone originalMilestone=original.getMilestone();
    Milestone editedMilestone=edited.getMilestone();
    int originalMNumber=(originalMilestone != null) ? originalMilestone.getNumber() : 0;
    int editedMNumber=(editedMilestone != null) ? editedMilestone.getNumber() : 0;
    if (editedMNumber != originalMNumber) {
      if (editedMilestone == null) {
        latest.setMilestone(new Milestone());
      }
 else {
        latest.setMilestone(editedMilestone);
      }
    }
    List<Label> originalLabels=original.getLabels();
    List<Label> editedLabels=edited.getLabels();
    boolean isSameLabels=true;
    for (    Label editedLabel : editedLabels) {
      if (!originalLabels.contains(editedLabel)) {
        isSameLabels=false;
        break;
      }
    }
    if (!isSameLabels) {
      latest.setLabels(editedLabels);
    }
    issueService.editIssue(repoId,latest);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.7712215320910973
135618,"public void updateLabel(TurboLabel editedLabel){
  Label ghLabel=editedLabel.toGhLabel();
  try {
    labelService.editLabel(repoId,ghLabel);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void updateLabel(TurboLabel editedLabel,String labelName){
  Label ghLabel=editedLabel.toGhLabel();
  try {
    labelService.editLabel(repoId,ghLabel,labelName);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9376443418013856
135619,"public Model(GitHubClient ghClient){
  this.collabService=new CollaboratorService(ghClient);
  this.issueService=new IssueService(ghClient);
  this.labelService=new LabelService(ghClient);
  this.milestoneService=new MilestoneService(ghClient);
}","public Model(GitHubClient ghClient){
  this.collabService=new CollaboratorService(ghClient);
  this.issueService=new IssueService(ghClient);
  this.labelService=new LabelServiceFixed(ghClient);
  this.milestoneService=new MilestoneService(ghClient);
}",0.9899396378269618
135620,"private Node createTreeView(){
  final TreeItem<String> treeRoot=new TreeItem<>(""String_Node_Str"");
  TreeItem<String> status=new TreeItem<>(""String_Node_Str"");
  treeRoot.getChildren().addAll(Arrays.asList(status));
  status.getChildren().addAll(Arrays.asList(new TreeItem<String>(""String_Node_Str""),new TreeItem<String>(""String_Node_Str"")));
  final TreeView<String> treeView=new TreeView<>();
  treeView.setRoot(treeRoot);
  treeView.setShowRoot(true);
  treeRoot.setExpanded(true);
  treeView.setPrefWidth(180);
  treeRoot.getChildren().forEach(child -> child.setExpanded(true));
  treeView.setCellFactory(new Callback<TreeView<String>,TreeCell<String>>(){
    @Override public TreeCell<String> call(    TreeView<String> stringTreeView){
      return new ManageLabelsTreeCell<String>(parentStage);
    }
  }
);
  return treeView;
}","private Node createTreeView(){
  final TreeItem<String> treeRoot=new TreeItem<>(""String_Node_Str"");
  TreeItem<String> status=new TreeItem<>(""String_Node_Str"");
  treeRoot.getChildren().addAll(Arrays.asList(status));
  status.getChildren().addAll(Arrays.asList(new TreeItem<String>(""String_Node_Str""),new TreeItem<String>(""String_Node_Str"")));
  final TreeView<String> treeView=new TreeView<>();
  treeView.setRoot(treeRoot);
  treeView.setShowRoot(false);
  treeRoot.setExpanded(true);
  treeView.setPrefWidth(180);
  treeRoot.getChildren().forEach(child -> child.setExpanded(true));
  treeView.setCellFactory(new Callback<TreeView<String>,TreeCell<String>>(){
    @Override public TreeCell<String> call(    TreeView<String> stringTreeView){
      return new ManageLabelsTreeCell<String>(parentStage);
    }
  }
);
  return treeView;
}",0.9958108916816276
135621,"private Parent createRoot(){
  MenuBar menuBar=createMenuBar();
  BorderPane root=new BorderPane();
  columns=new HBox();
  col1=createIssuePanel();
  IssuePanel col2=createIssuePanel();
  IssuePanel col3=createIssuePanel();
  col1.getItems().add(test=new TurboIssue(""String_Node_Str"",""String_Node_Str""));
  col1.getItems().add(new TurboIssue(""String_Node_Str"",""String_Node_Str""));
  col2.getItems().add(test);
  columns.getChildren().addAll(col1,col2,col3);
  root.setCenter(columns);
  root.setTop(menuBar);
  return root;
}","private Parent createRoot(){
  MenuBar menuBar=createMenuBar();
  BorderPane root=new BorderPane();
  columns=new HBox();
  col1=createIssuePanel();
  IssuePanel col2=createIssuePanel();
  IssuePanel col3=createIssuePanel();
  test=new TurboIssue(""String_Node_Str"",""String_Node_Str"");
  test.getLabels().add(new TurboLabel(""String_Node_Str""));
  TurboIssue two=new TurboIssue(""String_Node_Str"",""String_Node_Str"");
  TurboIssue three=new TurboIssue(""String_Node_Str"",""String_Node_Str"");
  TurboIssue four=new TurboIssue(""String_Node_Str"",""String_Node_Str"");
  TurboIssue five=new TurboIssue(""String_Node_Str"",""String_Node_Str"");
  col1.getItems().add(test);
  col1.getItems().add(two);
  col1.getItems().add(three);
  col1.getItems().add(four);
  col1.getItems().add(five);
  col2.getItems().add(test);
  columns.getChildren().addAll(col1,col2,col3);
  root.setCenter(columns);
  root.setTop(menuBar);
  return root;
}",0.5876645876645876
135622,"private void loadIssues(){
  col1.getItems().setAll(logic.getIssues());
}","private void loadIssues(){
  col1.setItems(FXCollections.observableArrayList(logic.getIssues()));
}",0.7906976744186046
135623,"public void filter(Filter filter){
  filteredList.setPredicate(filter::isSatisfiedBy);
  listView.setCellFactory(new Callback<ListView<TurboIssue>,ListCell<TurboIssue>>(){
    @Override public ListCell<TurboIssue> call(    ListView<TurboIssue> list){
      return new CustomListCell();
    }
  }
);
}","public void filter(Filter filter){
  filteredList.setPredicate(filter::isSatisfiedBy);
  refreshItems();
}",0.4876847290640394
135624,"public IssuePanel(){
  getChildren().add(listView);
  listView.setCellFactory(new Callback<ListView<TurboIssue>,ListCell<TurboIssue>>(){
    @Override public ListCell<TurboIssue> call(    ListView<TurboIssue> list){
      return new CustomListCell();
    }
  }
);
  filteredList=new FilteredList<>(issues,p -> true);
  listView.setItems(filteredList);
  setVgrow(listView,Priority.ALWAYS);
}","public IssuePanel(){
  listView=new ListView<>();
  getChildren().add(listView);
  setVgrow(listView,Priority.ALWAYS);
  refreshItems();
}",0.3440453686200378
135625,"public TurboIssue(Issue issue){
  this.ghIssue=issue;
  setTitle(issue.getTitle());
  setDescription(issue.getBody());
  setId(issue.getNumber());
  this.assignee=new TurboCollaborator(issue.getAssignee());
  this.milestone=new TurboMilestone(issue.getMilestone());
  this.labels=getLabels(issue);
}","public TurboIssue(Issue issue){
  this.ghIssue=issue;
  setTitle(issue.getTitle());
  setDescription(issue.getBody());
  setId(issue.getNumber());
  this.assignee=new TurboCollaborator(issue.getAssignee());
  this.milestone=new TurboMilestone(issue.getMilestone());
  this.labels=translateLabels(issue);
}",0.9801324503311258
135626,"private void onDoubleClick(TurboIssue issue){
  (new IssueDialog(mainStage,logic,issue)).show().thenApply(newIssue -> {
    parentIssuePanel.refreshItems();
    return true;
  }
);
}","private void onDoubleClick(TurboIssue issue){
  (new IssueDialog(mainStage,logic,issue)).show().thenApply(newIssue -> {
    return true;
  }
);
}",0.8868501529051988
135627,"/** 
 * The main class which requires the following parameters: -i *input_file*: the file which contains the text that will be disambiguated -o *output_file*: the file in which you want to save the output -cm *sent|doc|text*: indicates how the input text will be read and disambiguated. The available values are: ""sent"" one sentence per time, ""doc"" one doc per time, ""text"" read the full file -f *xml|oldxml|plain*: indicates the input file format. The available values are: ""xml"" for the SemEval-2013 Task 12 file format (http://www.cs.york.ac.uk/semeval-2013/task12/), ""oldxml"" old SemEval XML format, ""plain"" for plain text. The plain text must contain one token for each line. Each line must contains three values separated by TAB: token, pos-tag, lemma. The pos-tag has four possible values: n (noun), v (verb), j (adjective), r (adverb), any other character for other tags. An example is reported in the *text* folder -dsm *file_path*: the binary file which describes the distributional semantic model. A model for the English language is provided into the *resoruces/dsm* folder -lang *it|en|es|de|fr*: the language of the input text, *en* is the default value -sc *file_path*: the file which contains information about synsets distribution. A file extracted from WordNet 3.0 is provided in *resources/sense* folder -sg *true|false*: enable/disable gloss scoring function (true is the default value) -sf *wn|bn*: output synset format: ""wn"" uses WordNet offset, while ""bn"" uses BabelNet id (bn is the default value) -c *integer value|max*: indicates the context size, ""max"" considers the whole text -of *plain|task*: output format: ""plain"" uses plain text file to store word meanings, while task uses the file format defined in SemEval-2013 Task 12 -stem *true|false*: enable/disable glosses stemming
 * @param args the command line arguments
 */
public static void main(String[] args){
  try {
    Logger.getLogger(RunWSD.class.getName()).log(Level.INFO,""String_Node_Str"");
    TextReader reader;
    Properties props=Utils.parseCmd(args);
    if (!props.containsKey(""String_Node_Str"")) {
      System.exit(1);
    }
    int mode=TextReader.SENTENCE_MODE;
    String modeS=props.getProperty(""String_Node_Str"");
    if (modeS != null) {
switch (modeS) {
case ""String_Node_Str"":
        mode=TextReader.SENTENCE_MODE;
      break;
case ""String_Node_Str"":
    mode=TextReader.DOC_MODE;
  break;
case ""String_Node_Str"":
mode=TextReader.TEXT_MODE;
break;
default :
Logger.getLogger(RunWSD.class.getName()).log(Level.WARNING,""String_Node_Str"",modeS);
break;
}
}
String fileType=props.getProperty(""String_Node_Str"");
if (fileType != null && fileType.equals(""String_Node_Str"")) {
reader=new XMLTextReader(new File(props.getProperty(""String_Node_Str"")),mode);
}
 else if (fileType != null && fileType.equals(""String_Node_Str"")) {
reader=new OldXMLTextReader(new File(props.getProperty(""String_Node_Str"")),mode);
}
 else {
reader=new PlainTextReader(new File(props.getProperty(""String_Node_Str"")),mode);
}
reader.openTextReader();
String langS=props.getProperty(""String_Node_Str"");
Language language=Language.EN;
if (langS != null) {
switch (langS) {
case ""String_Node_Str"":
language=Language.EN;
break;
case ""String_Node_Str"":
language=Language.ES;
break;
case ""String_Node_Str"":
language=Language.DE;
break;
case ""String_Node_Str"":
language=Language.IT;
break;
case ""String_Node_Str"":
language=Language.FR;
break;
default :
Logger.getLogger(RunWSD.class.getName()).log(Level.WARNING,""String_Node_Str"",new Object[]{langS,language});
break;
}
}
String dsmFilename=props.getProperty(""String_Node_Str"");
RevisedLesk wsd;
if (dsmFilename == null) {
wsd=new RevisedLesk(language);
wsd.setStemming(true);
}
 else {
VectorSpace dsm=new VectorSpace(new File(dsmFilename));
dsm.init();
dsm.loadInRam();
wsd=new RevisedLesk(language,dsm);
wsd.setStemming(false);
}
String senseFreqFilename=props.getProperty(""String_Node_Str"");
if (senseFreqFilename != null) {
SenseFreqAPI sfapi=new SenseFreqAPI(new File(senseFreqFilename));
sfapi.init();
wsd.setSenseFreq(sfapi);
}
String projDepth=props.getProperty(""String_Node_Str"");
if (projDepth != null) {
wsd.setMaxDepth(Integer.parseInt(projDepth));
}
String scoreGloss=props.getProperty(""String_Node_Str"");
if (scoreGloss != null) {
wsd.setScoreGloss(Boolean.parseBoolean(scoreGloss));
}
String sf=props.getProperty(""String_Node_Str"");
if (sf == null) {
wsd.setOutType(RevisedLesk.OUT_BABELNET);
}
 else if (sf.equals(""String_Node_Str"")) {
wsd.setOutType(RevisedLesk.OUT_WORDNET);
}
 else if (sf.equals(""String_Node_Str"")) {
wsd.setOutType(RevisedLesk.OUT_BABELNET);
}
 else {
throw new Exception(""String_Node_Str"" + sf);
}
String cs=props.getProperty(""String_Node_Str"");
if (cs != null) {
if (cs.equalsIgnoreCase(""String_Node_Str"")) {
wsd.setContextSize(Integer.MAX_VALUE);
}
 else {
wsd.setContextSize(Integer.parseInt(cs));
}
}
 else {
Logger.getLogger(RunWSD.class.getName()).log(Level.WARNING,""String_Node_Str"",cs);
wsd.setContextSize(5);
}
String outFormat=OUTFORMAT_PLAIN;
String of=props.getProperty(""String_Node_Str"");
if (of != null) {
if (outFormat.equals(OUTFORMAT_PLAIN) || outFormat.equals(OUTFORMAT_TASK)) {
outFormat=of;
}
 else {
throw new Exception(""String_Node_Str"" + of);
}
}
String stemming=props.getProperty(""String_Node_Str"");
if (stemming != null) {
wsd.setStemming(Boolean.parseBoolean(stemming));
}
 else {
wsd.setStemming(false);
}
String outFile=props.getProperty(""String_Node_Str"");
BufferedWriter writer=null;
if (outFile != null) {
writer=new BufferedWriter(new FileWriter(outFile));
}
wsd.init();
Logger.getLogger(RunWSD.class.getName()).log(Level.INFO,""String_Node_Str"");
List<Token> tokens=reader.getTokenList();
while (tokens != null) {
wsd.disambiguate(tokens);
if (writer == null) {
for (Token token : tokens) {
System.out.println(token.print());
}
System.out.println();
}
 else {
switch (outFormat) {
case OUTFORMAT_PLAIN:
for (Token token : tokens) {
writer.append(token.print());
writer.newLine();
}
writer.newLine();
writer.flush();
break;
case OUTFORMAT_TASK:
for (Token token : tokens) {
String id=token.getId();
if (id != null && token.isToDisambiguate() && !token.getSynsetList().isEmpty()) {
writer.append(id.substring(0,id.indexOf(""String_Node_Str""))).append(""String_Node_Str"");
writer.append(id).append(""String_Node_Str"");
List<SynsetOut> out=token.getSynsetList();
if (out.size() == 1) {
writer.append(out.get(0).getSynset()).append(""String_Node_Str"");
}
 else {
double variance=wsd.getVariance(out);
if (out.get(out.size() - 1).getScore() - out.get(out.size() - 2).getScore() <= variance) {
writer.append(out.get(out.size() - 1).getSynset()).append(""String_Node_Str"").append(out.get(out.size() - 2).getSynset()).append(""String_Node_Str"");
}
 else {
writer.append(out.get(out.size() - 1).getSynset()).append(""String_Node_Str"");
}
}
writer.append(""String_Node_Str"" + token.getLemma()).append(""String_Node_Str"").append(token.getPos().name());
writer.newLine();
}
}
writer.flush();
break;
}
}
tokens=reader.getTokenList();
}
reader.closeTextReader();
if (writer != null) {
writer.close();
}
System.out.println(wsd.getExecStats());
wsd.close();
}
 catch (Exception ex) {
Logger.getLogger(RunWSD.class.getName()).log(Level.SEVERE,null,ex);
}
}","/** 
 * The main class which requires the following parameters: -i *input_file*: the file which contains the text that will be disambiguated -o *output_file*: the file in which you want to save the output -cm *sent|doc|text*: indicates how the input text will be read and disambiguated. The available values are: ""sent"" one sentence per time, ""doc"" one doc per time, ""text"" read the full file -f *xml|oldxml|plain*: indicates the input file format. The available values are: ""xml"" for the SemEval-2013 Task 12 file format (http://www.cs.york.ac.uk/semeval-2013/task12/), ""oldxml"" old SemEval XML format, ""plain"" for plain text. The plain text must contain one token for each line. Each line must contains three values separated by TAB: token, pos-tag, lemma. The pos-tag has four possible values: n (noun), v (verb), j (adjective), r (adverb), any other character for other tags. An example is reported in the *text* folder -dsm *file_path*: the binary file which describes the distributional semantic model. A model for the English language is provided into the *resoruces/dsm* folder -lang *it|en|es|de|fr*: the language of the input text, *en* is the default value -sc *file_path*: the file which contains information about synsets distribution. A file extracted from WordNet 3.0 is provided in *resources/sense* folder -sg *true|false*: enable/disable gloss scoring function (true is the default value) -sf *wn|bn*: output synset format: ""wn"" uses WordNet offset, while ""bn"" uses BabelNet id (bn is the default value) -c *integer value|max*: indicates the context size, ""max"" considers the whole text -of *plain|task*: output format: ""plain"" uses plain text file to store word meanings, while task uses the file format defined in SemEval-2013 Task 12 -stem *true|false*: enable/disable glosses stemming
 * @param args the command line arguments
 */
public static void main(String[] args){
  try {
    Logger.getLogger(RunWSD.class.getName()).log(Level.INFO,""String_Node_Str"");
    TextReader reader;
    Properties props=Utils.parseCmd(args);
    if (!props.containsKey(""String_Node_Str"")) {
      System.exit(1);
    }
    int mode=TextReader.SENTENCE_MODE;
    String modeS=props.getProperty(""String_Node_Str"");
    if (modeS != null) {
switch (modeS) {
case ""String_Node_Str"":
        mode=TextReader.SENTENCE_MODE;
      break;
case ""String_Node_Str"":
    mode=TextReader.DOC_MODE;
  break;
case ""String_Node_Str"":
mode=TextReader.TEXT_MODE;
break;
default :
Logger.getLogger(RunWSD.class.getName()).log(Level.WARNING,""String_Node_Str"",modeS);
break;
}
}
String fileType=props.getProperty(""String_Node_Str"");
if (fileType != null && fileType.equals(""String_Node_Str"")) {
reader=new XMLTextReader(new File(props.getProperty(""String_Node_Str"")),mode);
}
 else if (fileType != null && fileType.equals(""String_Node_Str"")) {
reader=new OldXMLTextReader(new File(props.getProperty(""String_Node_Str"")),mode);
}
 else {
reader=new PlainTextReader(new File(props.getProperty(""String_Node_Str"")),mode);
}
reader.openTextReader();
String langS=props.getProperty(""String_Node_Str"");
Language language=Language.EN;
if (langS != null) {
switch (langS) {
case ""String_Node_Str"":
language=Language.EN;
break;
case ""String_Node_Str"":
language=Language.ES;
break;
case ""String_Node_Str"":
language=Language.DE;
break;
case ""String_Node_Str"":
language=Language.IT;
break;
case ""String_Node_Str"":
language=Language.FR;
break;
default :
Logger.getLogger(RunWSD.class.getName()).log(Level.WARNING,""String_Node_Str"",new Object[]{langS,language});
break;
}
}
String dsmFilename=props.getProperty(""String_Node_Str"");
RevisedLesk wsd;
if (dsmFilename == null) {
wsd=new RevisedLesk(language);
wsd.setStemming(true);
}
 else {
String dsmType=props.getProperty(""String_Node_Str"");
VectorStore dsm=null;
if (dsmType != null && dsmType.equals(""String_Node_Str"")) {
dsm=new DataVectorStore();
}
 else {
dsm=new LuceneVectorStore();
}
dsm.init(new File(dsmFilename));
wsd=new RevisedLesk(language,dsm);
wsd.setStemming(false);
}
String senseFreqFilename=props.getProperty(""String_Node_Str"");
if (senseFreqFilename != null) {
SenseFreqAPI sfapi=new SenseFreqAPI(new File(senseFreqFilename));
sfapi.init();
wsd.setSenseFreq(sfapi);
}
String projDepth=props.getProperty(""String_Node_Str"");
if (projDepth != null) {
wsd.setMaxDepth(Integer.parseInt(projDepth));
}
String scoreGloss=props.getProperty(""String_Node_Str"");
if (scoreGloss != null) {
wsd.setScoreGloss(Boolean.parseBoolean(scoreGloss));
}
String sf=props.getProperty(""String_Node_Str"");
if (sf == null) {
wsd.setOutType(RevisedLesk.OUT_BABELNET);
}
 else if (sf.equals(""String_Node_Str"")) {
wsd.setOutType(RevisedLesk.OUT_WORDNET);
}
 else if (sf.equals(""String_Node_Str"")) {
wsd.setOutType(RevisedLesk.OUT_BABELNET);
}
 else {
throw new Exception(""String_Node_Str"" + sf);
}
String cs=props.getProperty(""String_Node_Str"");
if (cs != null) {
if (cs.equalsIgnoreCase(""String_Node_Str"")) {
wsd.setContextSize(Integer.MAX_VALUE);
}
 else {
wsd.setContextSize(Integer.parseInt(cs));
}
}
 else {
Logger.getLogger(RunWSD.class.getName()).log(Level.WARNING,""String_Node_Str"",cs);
wsd.setContextSize(5);
}
String outFormat=OUTFORMAT_PLAIN;
String of=props.getProperty(""String_Node_Str"");
if (of != null) {
if (outFormat.equals(OUTFORMAT_PLAIN) || outFormat.equals(OUTFORMAT_TASK)) {
outFormat=of;
}
 else {
throw new Exception(""String_Node_Str"" + of);
}
}
String stemming=props.getProperty(""String_Node_Str"");
if (stemming != null) {
wsd.setStemming(Boolean.parseBoolean(stemming));
}
 else {
wsd.setStemming(false);
}
String outFile=props.getProperty(""String_Node_Str"");
BufferedWriter writer=null;
if (outFile != null) {
writer=new BufferedWriter(new FileWriter(outFile));
}
wsd.init();
Logger.getLogger(RunWSD.class.getName()).log(Level.INFO,""String_Node_Str"");
List<Token> tokens=reader.getTokenList();
while (tokens != null) {
wsd.disambiguate(tokens);
if (writer == null) {
for (Token token : tokens) {
System.out.println(token.print());
}
System.out.println();
}
 else {
switch (outFormat) {
case OUTFORMAT_PLAIN:
for (Token token : tokens) {
writer.append(token.print());
writer.newLine();
}
writer.newLine();
writer.flush();
break;
case OUTFORMAT_TASK:
for (Token token : tokens) {
String id=token.getId();
if (id != null && token.isToDisambiguate() && !token.getSynsetList().isEmpty()) {
writer.append(id.substring(0,id.indexOf(""String_Node_Str""))).append(""String_Node_Str"");
writer.append(id).append(""String_Node_Str"");
List<SynsetOut> out=token.getSynsetList();
if (out.size() == 1) {
writer.append(out.get(0).getSynset()).append(""String_Node_Str"");
}
 else {
double variance=wsd.getVariance(out);
if (out.get(out.size() - 1).getScore() - out.get(out.size() - 2).getScore() <= variance) {
writer.append(out.get(out.size() - 1).getSynset()).append(""String_Node_Str"").append(out.get(out.size() - 2).getSynset()).append(""String_Node_Str"");
}
 else {
writer.append(out.get(out.size() - 1).getSynset()).append(""String_Node_Str"");
}
}
writer.append(""String_Node_Str"" + token.getLemma()).append(""String_Node_Str"").append(token.getPos().name());
writer.newLine();
}
}
writer.flush();
break;
}
}
tokens=reader.getTokenList();
}
reader.closeTextReader();
if (writer != null) {
writer.close();
}
System.out.println(wsd.getExecStats());
wsd.close();
}
 catch (Exception ex) {
Logger.getLogger(RunWSD.class.getName()).log(Level.SEVERE,null,ex);
}
}",0.9843053937358646
135628,"/** 
 * @return
 */
public VectorSpace getDsm(){
  return dsm;
}","/** 
 * @return
 */
public VectorStore getDsm(){
  return dsm;
}",0.953125
135629,"private List<BabelSense> lookupSense(Language language,String lemma,POS postag) throws IOException {
  List<BabelSense> senses;
  if (language.equals(Language.EN)) {
    senses=babelNet.getSenses(language,lemma,postag,BabelSenseSource.WN);
    if (senses == null || senses.isEmpty()) {
      senses=babelNet.getSenses(language,lemma.replace(""String_Node_Str"",""String_Node_Str""),postag,BabelSenseSource.WN);
    }
  }
 else {
    senses=babelNet.getSenses(language,lemma,postag,BabelSenseSource.WNTR);
    if (senses == null || senses.isEmpty()) {
      senses=babelNet.getSenses(language,lemma.replace(""String_Node_Str"",""String_Node_Str""),postag,BabelSenseSource.WNTR);
    }
  }
  if (senses == null || senses.isEmpty() || !smartLookup) {
    senses=babelNet.getSenses(language,lemma,postag);
    if (senses == null || senses.isEmpty()) {
      senses=babelNet.getSenses(language,lemma.replace(""String_Node_Str"",""String_Node_Str""),postag);
    }
  }
  if (senses == null || senses.isEmpty()) {
    Logger.getLogger(RevisedLesk.class.getName()).log(Level.WARNING,""String_Node_Str"",new Object[]{lemma,postag});
  }
  if (senses != null && !senses.isEmpty()) {
    Set<String> ids=new HashSet<>();
    for (int i=senses.size() - 1; i >= 0; i--) {
      if (!ids.add(senses.get(i).getSynset().getId())) {
        senses.remove(i);
      }
    }
  }
  return senses;
}","private List<BabelSense> lookupSense(Language language,String lemma,POS postag) throws IOException {
  List<BabelSense> senses;
  if (language.equals(Language.EN)) {
    senses=babelNet.getSenses(language,lemma,postag,BabelSenseSource.WN);
    if (senses == null || senses.isEmpty()) {
      senses=babelNet.getSenses(language,lemma.replace(""String_Node_Str"",""String_Node_Str""),postag,BabelSenseSource.WN);
    }
  }
 else {
    senses=babelNet.getSenses(language,lemma,postag,BabelSenseSource.WNTR);
    if (senses == null || senses.isEmpty()) {
      senses=babelNet.getSenses(language,lemma.replace(""String_Node_Str"",""String_Node_Str""),postag,BabelSenseSource.WNTR);
    }
  }
  if (senses == null || senses.isEmpty()) {
    senses=babelNet.getSenses(language,lemma,postag);
    if (senses == null || senses.isEmpty()) {
      senses=babelNet.getSenses(language,lemma.replace(""String_Node_Str"",""String_Node_Str""),postag);
    }
  }
  if (senses == null || senses.isEmpty()) {
    Logger.getLogger(RevisedLesk.class.getName()).log(Level.WARNING,""String_Node_Str"",new Object[]{lemma,postag});
  }
  if (senses != null && !senses.isEmpty()) {
    Set<String> ids=new HashSet<>();
    for (int i=senses.size() - 1; i >= 0; i--) {
      if (!ids.add(senses.get(i).getSynset().getId())) {
        senses.remove(i);
      }
    }
  }
  return senses;
}",0.9941002949852508
135630,"/** 
 * @param sentence
 * @throws Exception
 */
public void disambiguate(List<Token> sentence) throws Exception {
  execStats=new ExecuteStatistics();
  System.out.println();
  for (int i=0; i < sentence.size(); i++) {
    System.out.print(""String_Node_Str"");
    Token token=sentence.get(i);
    if (token.isToDisambiguate() && token.getSynsetList().isEmpty()) {
      Map<String,Float> contextBag=buildContext(sentence,i);
      if (token.getPos() != POSenum.OTHER) {
        List<BabelSense> senses=null;
        if (token.getPos() == POSenum.NOUN) {
          senses=lookupSense(language,token.getLemma(),POS.NOUN);
        }
 else         if (token.getPos() == POSenum.VERB) {
          senses=lookupSense(language,token.getLemma(),POS.VERB);
        }
 else         if (token.getPos() == POSenum.ADJ) {
          senses=lookupSense(language,token.getLemma(),POS.ADJECTIVE);
        }
 else         if (token.getPos() == POSenum.ADV) {
          senses=lookupSense(language,token.getLemma(),POS.ADVERB);
        }
        if (senses != null) {
          List<Map<String,Float>> buildGlossBag=buildGlossBag(senses);
          for (int j=0; j < senses.size(); j++) {
            double sim=0;
            Map<String,Float> bag=buildGlossBag.get(j);
            sim=sim(contextBag,bag);
            if (senseFreq != null) {
              if (language.equals(Language.EN)) {
                String lemmakey=token.getLemma() + ""String_Node_Str"" + convertPosEnum(token.getPos());
                float freq=senseFreq.getFreq(lemmakey,senses.get(j).getWordNetOffset());
                sim=0.5 * sim + 0.5 * freq;
              }
 else {
                String mainSense=senses.get(j).getSynset().getMainSense();
                if (mainSense != null && !mainSense.startsWith(""String_Node_Str"") && mainSense.length() > 0) {
                  int si=mainSense.lastIndexOf(""String_Node_Str"");
                  if (si >= 0) {
                    String lemmakey=mainSense.substring(0,si);
                    float maxFreq=0;
                    for (int l=0; l < senses.get(j).getSynset().getWordNetOffsets().size(); l++) {
                      float freq=senseFreq.getFreq(lemmakey,senses.get(j).getSynset().getWordNetOffsets().get(l));
                      if (freq > maxFreq) {
                        maxFreq=freq;
                      }
                    }
                    sim=0.5 * sim + 0.5 * maxFreq;
                  }
                }
              }
            }
            if (outType == OUT_BABELNET) {
              token.getSynsetList().add(new SynsetOut(senses.get(j).getSynset().getId(),sim));
            }
 else             if (outType == OUT_WORDNET) {
              token.getSynsetList().add(new SynsetOut(senses.get(j).getSensekey(),sim));
            }
 else {
              throw new Exception(""String_Node_Str"" + outType);
            }
          }
          Collections.sort(token.getSynsetList());
        }
      }
    }
  }
}","/** 
 * @param sentence
 * @throws Exception
 */
public void disambiguate(List<Token> sentence) throws Exception {
  execStats=new ExecuteStatistics();
  System.out.println();
  for (int i=0; i < sentence.size(); i++) {
    System.out.print(""String_Node_Str"");
    Token token=sentence.get(i);
    if (token.isToDisambiguate() && token.getSynsetList().isEmpty()) {
      Map<String,Float> contextBag=buildContext(sentence,i);
      if (token.getPos() != POSenum.OTHER) {
        List<BabelSense> senses=null;
        if (token.getPos() == POSenum.NOUN) {
          senses=lookupSense(language,token.getLemma(),POS.NOUN);
        }
 else         if (token.getPos() == POSenum.VERB) {
          senses=lookupSense(language,token.getLemma(),POS.VERB);
        }
 else         if (token.getPos() == POSenum.ADJ) {
          senses=lookupSense(language,token.getLemma(),POS.ADJECTIVE);
        }
 else         if (token.getPos() == POSenum.ADV) {
          senses=lookupSense(language,token.getLemma(),POS.ADVERB);
        }
        if (senses != null) {
          List<Map<String,Float>> buildGlossBag=buildGlossBag(senses);
          for (int j=0; j < senses.size(); j++) {
            double sim=0;
            Map<String,Float> bag=buildGlossBag.get(j);
            sim=sim(contextBag,bag);
            if (senseFreq != null) {
              if (language.equals(Language.EN)) {
                String lemmakey=token.getLemma() + ""String_Node_Str"" + convertPosEnum(token.getPos());
                float freq=senseFreq.getFreq(lemmakey,senses.get(j).getWordNetOffset());
                sim=0.5 * sim + 0.5 * freq;
              }
 else {
                String mainSense=senses.get(j).getSynset().getMainSense();
                if (mainSense != null && !mainSense.startsWith(""String_Node_Str"") && mainSense.length() > 0) {
                  int si=mainSense.lastIndexOf(""String_Node_Str"");
                  if (si >= 0) {
                    String lemmakey=mainSense.substring(0,si);
                    float maxFreq=1 / (float)senses.size();
                    for (int l=0; l < senses.get(j).getSynset().getWordNetOffsets().size(); l++) {
                      float freq=senseFreq.getFreq(lemmakey,senses.get(j).getSynset().getWordNetOffsets().get(l));
                      if (freq > maxFreq) {
                        maxFreq=freq;
                      }
                    }
                    sim=0.5 * sim + 0.5 * maxFreq;
                  }
                }
 else {
                  sim=0.5 * sim + 0.5 / (double)senses.size();
                }
              }
            }
            if (outType == OUT_BABELNET) {
              token.getSynsetList().add(new SynsetOut(senses.get(j).getSynset().getId(),sim));
            }
 else             if (outType == OUT_WORDNET) {
              token.getSynsetList().add(new SynsetOut(senses.get(j).getSensekey(),sim));
            }
 else {
              throw new Exception(""String_Node_Str"" + outType);
            }
          }
          Collections.sort(token.getSynsetList());
        }
      }
    }
  }
}",0.981132075471698
135631,"/** 
 * @param language
 * @param dsm
 */
public RevisedLesk(Language language,VectorSpace dsm){
  this.language=language;
  this.dsm=dsm;
}","/** 
 * @param language
 * @param dsm
 */
public RevisedLesk(Language language,VectorStore dsm){
  this.language=language;
  this.dsm=dsm;
}",0.9785714285714284
135632,"/** 
 * @param inputFile
 * @throws IOException
 */
public void init(File inputFile) throws IOException {
  vectors=new HashMap<>();
  DataInputStream input=new DataInputStream(new BufferedInputStream(new FileInputStream(inputFile)));
  vectorType=input.readUTF();
  dimension=input.readInt();
  int c=0;
  while (input.available() > 0) {
    String key=input.readUTF();
    float[] v=new float[dimension];
    for (int i=0; i < dimension; i++) {
      v[i]=input.readFloat();
    }
    vectors.put(key,v);
    c++;
    if (c % 10000 == 0) {
      System.out.print(c + ""String_Node_Str"");
    }
  }
  input.close();
  logger.log(Level.INFO,""String_Node_Str"",vectors.size());
}","/** 
 * @param inputFile
 * @throws IOException
 */
public void init(File inputFile) throws IOException {
  vectors=new HashMap<>();
  DataInputStream input=new DataInputStream(new BufferedInputStream(new FileInputStream(inputFile)));
  vectorType=input.readUTF();
  dimension=input.readInt();
  ObjectVector.vecLength=dimension;
  int c=0;
  while (input.available() > 0) {
    String key=input.readUTF();
    float[] v=new float[dimension];
    for (int i=0; i < dimension; i++) {
      v[i]=input.readFloat();
    }
    vectors.put(key,v);
    c++;
    if (c % 10000 == 0) {
      System.out.print(c + ""String_Node_Str"");
    }
  }
  input.close();
  logger.log(Level.INFO,""String_Node_Str"",vectors.size());
}",0.9740634005763688
135633,"public ResultCode removeQueue(String queueName,final String user,final String pass){
  _lock.lock();
  try {
    queueName=queueName.toUpperCase();
    if (validUser(user,pass) == false) {
      return ResultCode.AUTHENTICATION_FAILURE;
    }
    FanOutQueueImplEx queue=_mapQueue.get(queueName);
    if (queue == null) {
      return ResultCode.QUEUE_NOT_EXIST;
    }
    try {
      queue=_mapQueue.remove(queueName);
      queue.erase();
      _meta.delete((PREFIX_QUEUE + queueName).getBytes());
      return ResultCode.SUCCESS;
    }
 catch (    Exception ex) {
      _log.error(ex.getMessage(),ex);
      return ResultCode.SUB_REMOVE_ERROR;
    }
  }
  finally {
    _lock.unlock();
  }
}","public ResultCode removeQueue(String queueName,final String user,final String pass){
  _lock.lock();
  try {
    queueName=queueName.toUpperCase();
    if (validUser(user,pass) == false) {
      return ResultCode.AUTHENTICATION_FAILURE;
    }
    FanOutQueueImplEx queue=_mapQueue.get(queueName);
    if (queue == null) {
      return ResultCode.QUEUE_NOT_EXIST;
    }
    try {
      queue=_mapQueue.remove(queueName);
      List<String> subNames=queue.getAllFanoutNames();
      queue.erase();
      _meta.delete((PREFIX_QUEUE + queueName).getBytes());
      for (      String subName : subNames) {
        _meta.delete((PREFIX_SUB + subName + PREFIX_QUEUE+ queueName).getBytes());
      }
      return ResultCode.SUCCESS;
    }
 catch (    Exception ex) {
      _log.error(ex.getMessage(),ex);
      return ResultCode.SUB_REMOVE_ERROR;
    }
  }
  finally {
    _lock.unlock();
  }
}",0.8784810126582279
135634,"@Override protected void drawSlot(int index,int var2,int var3,int var4,Tessellator tessellator){
  Update update=UpdateHandler.getElement(index);
  if (update != null) {
    this.parent.getFontRenderer().drawString(this.parent.getFontRenderer().trimStringToWidth(update.displayName,listWidth - 10),this.left + 3,var3 + 2,0xFFFFFF);
    this.parent.getFontRenderer().drawString(this.parent.getFontRenderer().trimStringToWidth(update.oldVersion + ""String_Node_Str"" + update.newVersion,listWidth - 10),this.left + 3,var3 + 12,0xCCCCCC);
    String info;
    GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
    Minecraft.getMinecraft().renderEngine.bindTexture(Resources.GUI_ICONS);
    if (DownloadThread.isUpdating(update)) {
      Gui.func_146110_a(this.left + listWidth - 30,var3 + 8,0,0,16,16,32,32);
      info=StatCollector.translateToLocal(Strings.UPDATING);
    }
 else     if (update.isDownloaded()) {
      Gui.func_146110_a(this.left + listWidth - 30,var3 + 8,16,0,16,16,32,32);
      if (!update.MOD_ID.equalsIgnoreCase(Reference.MOD_ID)) {
        info=StatCollector.translateToLocal(Strings.IS_DOWNLOADED);
      }
 else {
        info=StatCollector.translateToLocal(Strings.UNABLE_TO_REMOVE_SELF);
      }
    }
 else     if (update.isDirectLink) {
      Gui.func_146110_a(this.left + listWidth - 30,var3 + 8,16,16,16,16,32,32);
      info=StatCollector.translateToLocal(Strings.DL_AVAILABLE);
    }
 else     if (update.updateURL != null) {
      Gui.func_146110_a(this.left + listWidth - 30,var3 + 8,0,16,16,16,32,32);
      info=StatCollector.translateToLocal(Strings.LINK_TO_DL);
    }
 else {
      info=StatCollector.translateToLocal(Strings.CANNOT_UPDATE);
    }
    this.parent.getFontRenderer().drawString(this.parent.getFontRenderer().trimStringToWidth(info,listWidth - 10),this.left + 3,var3 + 22,0xCCCCCC);
  }
}","@Override protected void drawSlot(int index,int var2,int var3,int var4,Tessellator tessellator){
  Update update=UpdateHandler.getElement(index);
  if (update != null) {
    this.parent.getFontRenderer().drawString(this.parent.getFontRenderer().trimStringToWidth(update.displayName,listWidth - 10),this.left + 3,var3 + 2,0xFFFFFF);
    this.parent.getFontRenderer().drawString(this.parent.getFontRenderer().trimStringToWidth(update.oldVersion + ""String_Node_Str"" + update.newVersion,listWidth - 10),this.left + 3,var3 + 12,0xCCCCCC);
    String info;
    GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
    Minecraft.getMinecraft().renderEngine.bindTexture(Resources.GUI_ICONS);
    if (DownloadThread.isUpdating(update)) {
      Gui.func_146110_a(this.left + listWidth - 30,var3 + 8,0,0,16,16,48,32);
      info=StatCollector.translateToLocal(Strings.UPDATING);
    }
 else     if (update.isDownloaded()) {
      Gui.func_146110_a(this.left + listWidth - 30,var3 + 8,16,0,16,16,48,32);
      if (!update.MOD_ID.equalsIgnoreCase(Reference.MOD_ID)) {
        info=StatCollector.translateToLocal(Strings.IS_DOWNLOADED);
      }
 else {
        info=StatCollector.translateToLocal(Strings.UNABLE_TO_REMOVE_SELF);
      }
    }
 else     if (update.isErrored()) {
      Gui.func_146110_a(this.left + listWidth - 30,var3 + 8,32,0,16,16,48,32);
      info=StatCollector.translateToLocal(Strings.ERRORED);
    }
 else     if (update.isDirectLink) {
      Gui.func_146110_a(this.left + listWidth - 30,var3 + 8,16,16,16,16,48,32);
      info=StatCollector.translateToLocal(Strings.DL_AVAILABLE);
    }
 else     if (update.updateURL != null) {
      Gui.func_146110_a(this.left + listWidth - 30,var3 + 8,0,16,16,16,48,32);
      info=StatCollector.translateToLocal(Strings.LINK_TO_DL);
    }
 else {
      info=StatCollector.translateToLocal(Strings.CANNOT_UPDATE);
    }
    this.parent.getFontRenderer().drawString(this.parent.getFontRenderer().trimStringToWidth(info,listWidth - 10),this.left + 3,var3 + 22,0xCCCCCC);
  }
}",0.94283476898982
135635,"@Override public void drawScreen(int mouseX,int mouseY,float par3){
  updateList.drawScreen(mouseX,mouseY,par3);
  if (openUpdate != null) {
    changeLogList.drawScreen(mouseX,mouseY,par3);
  }
  this.fontRendererObj.drawSplitString(StatCollector.translateToLocal(Strings.INFO).replace(""String_Node_Str"",""String_Node_Str""),10,height / 2 - 60,width / 2 - 150 + listShift - 20,0xCCCCCC);
  GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
  Minecraft.getMinecraft().renderEngine.bindTexture(Resources.GUI_LOGO);
  int i=width / 2 - 150 + listShift - 10;
  Gui.func_146110_a(5,5,0,0,i,(int)(i * 0.4),i,(int)(i * 0.4));
  if (openUpdate != null) {
    drawCenteredString(fontRendererObj,openUpdate.displayName,width / 2 + listShift,height / 2 - 80,0xFFFFFF);
    if (openUpdate.changeLog == null) {
      drawCenteredString(fontRendererObj,StatCollector.translateToLocal(Strings.NO_CHANGE_LOG),width / 2 + listShift,height / 2 - 60,0xCCCCCC);
    }
  }
  if (DownloadThread.isUpdating()) {
    GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
    Minecraft.getMinecraft().renderEngine.bindTexture(Resources.GUI_ICONS);
    Gui.func_146110_a(width - 20,4,0,0,16,16,32,32);
  }
  super.drawScreen(mouseX,mouseY,par3);
  drawToolTip(mouseX,mouseY);
}","@Override public void drawScreen(int mouseX,int mouseY,float par3){
  updateList.drawScreen(mouseX,mouseY,par3);
  if (openUpdate != null) {
    changeLogList.drawScreen(mouseX,mouseY,par3);
  }
  this.fontRendererObj.drawSplitString(StatCollector.translateToLocal(Strings.INFO).replace(""String_Node_Str"",""String_Node_Str""),10,height / 2 - 60,width / 2 - 150 + listShift - 20,0xCCCCCC);
  GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
  Minecraft.getMinecraft().renderEngine.bindTexture(Resources.GUI_LOGO);
  int i=width / 2 - 150 + listShift - 10;
  Gui.func_146110_a(5,5,0,0,i,(int)(i * 0.4),i,(int)(i * 0.4));
  if (openUpdate != null) {
    drawCenteredString(fontRendererObj,openUpdate.displayName,width / 2 + listShift,height / 2 - 80,0xFFFFFF);
    if (openUpdate.changeLog == null) {
      drawCenteredString(fontRendererObj,StatCollector.translateToLocal(Strings.NO_CHANGE_LOG),width / 2 + listShift,height / 2 - 60,0xCCCCCC);
    }
  }
  if (DownloadThread.isUpdating()) {
    GL11.glColor4f(1.0F,1.0F,1.0F,1.0F);
    Minecraft.getMinecraft().renderEngine.bindTexture(Resources.GUI_ICONS);
    Gui.func_146110_a(width - 20,4,0,0,16,16,48,32);
  }
  super.drawScreen(mouseX,mouseY,par3);
  drawToolTip(mouseX,mouseY);
}",0.9352459016393444
135636,"@Override public void run(){
  WebHelper.downloadUpdate(update);
  downloadingUpdates.remove(update);
  RemoveHandler.filesToDelete.add(ModHelper.getModContainer(update.MOD_ID).getSource());
  update.setDownloaded(true);
}","@Override public void run(){
  boolean success=WebHelper.downloadUpdate(update);
  downloadingUpdates.remove(update);
  if (success) {
    RemoveHandler.filesToDelete.add(ModHelper.getModContainer(update.MOD_ID).getSource());
    update.setDownloaded(true);
  }
 else {
    update.setErrored();
  }
}",0.8505747126436781
135637,"public static void downloadFileFromURL(URL url,Update update,ModContainer mod,String fileName){
  File newFile=new File(fileName);
  try {
    FileUtils.copyURLToFile(url,newFile);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static File downloadFileFromURL(URL url,Update update,ModContainer mod,String fileName) throws IOException {
  File newFile=new File(fileName);
  FileUtils.copyURLToFile(url,newFile);
  return newFile;
}",0.5132743362831859
135638,"public static void downloadUpdate(Update update){
  ModContainer mod=ModHelper.getModContainer(update.MOD_ID);
  if (mod != null) {
    String fileName=""String_Node_Str"";
    if (update.newFileName != null && !update.newFileName.isEmpty()) {
      fileName=mod.getSource().getParent() + File.separator + update.newFileName;
    }
 else {
      fileName=mod.getSource().getAbsolutePath();
      String newFileName=fileName.replaceAll(update.oldVersion,update.newVersion);
      if (fileName.equalsIgnoreCase(newFileName)) {
        int i=newFileName.lastIndexOf(""String_Node_Str"");
        if (i == -1) {
          newFileName+=""String_Node_Str"";
        }
 else {
          newFileName=newFileName.substring(0,i) + ""String_Node_Str"" + newFileName.substring(i);
        }
      }
      fileName=newFileName;
    }
    try {
      URL url=new URL(update.updateURL);
      downloadFileFromURL(url,update,mod,fileName);
    }
 catch (    MalformedURLException e) {
      e.printStackTrace();
    }
  }
}","public static boolean downloadUpdate(Update update){
  ModContainer mod=ModHelper.getModContainer(update.MOD_ID);
  if (mod != null) {
    String fileName=""String_Node_Str"";
    if (update.newFileName != null && !update.newFileName.isEmpty()) {
      fileName=mod.getSource().getParent() + File.separator + update.newFileName;
    }
 else {
      fileName=mod.getSource().getAbsolutePath();
      String newFileName=fileName.replaceAll(update.oldVersion,update.newVersion);
      if (fileName.equalsIgnoreCase(newFileName)) {
        int i=newFileName.lastIndexOf(""String_Node_Str"");
        if (i == -1) {
          newFileName+=""String_Node_Str"";
        }
 else {
          newFileName=newFileName.substring(0,i) + ""String_Node_Str"" + newFileName.substring(i);
        }
      }
      fileName=newFileName;
    }
    try {
      URL url=new URL(update.updateURL);
      File file=downloadFileFromURL(url,update,mod,fileName);
      if (file != null && file.exists() && file.length() > 0)       return true;
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return false;
}",0.9379770992366412
135639,"public static String getResultMessage(ModContainer mod,CheckState result,VersionContainer.Version version){
  if (result == CheckState.UNINITIALIZED) {
    return String.format(""String_Node_Str"",version);
  }
 else   if (result == CheckState.CURRENT) {
    return String.format(""String_Node_Str"",version);
  }
 else   if (result == CheckState.OUTDATED && version != null) {
    return String.format(""String_Node_Str"",version,mod.getVersion(),version.getModVersion());
  }
 else   if (result == CheckState.ERROR) {
    return String.format(""String_Node_Str"",version);
  }
 else   if (result == CheckState.MC_VERSION_NOT_FOUND) {
    return String.format(""String_Node_Str"",version);
  }
 else {
    return String.format(""String_Node_Str"",version);
  }
}","public static String getResultMessage(ModContainer mod,CheckState result,VersionContainer.Version version){
  if (result == CheckState.UNINITIALIZED) {
    return String.format(""String_Node_Str"",mod.getName());
  }
 else   if (result == CheckState.CURRENT) {
    return String.format(""String_Node_Str"",mod.getName());
  }
 else   if (result == CheckState.OUTDATED && version != null) {
    return String.format(""String_Node_Str"",mod.getName(),mod.getVersion(),version.getModVersion());
  }
 else   if (result == CheckState.ERROR) {
    return String.format(""String_Node_Str"",mod.getName());
  }
 else   if (result == CheckState.MC_VERSION_NOT_FOUND) {
    return String.format(""String_Node_Str"",mod.getName());
  }
 else {
    return String.format(""String_Node_Str"",mod.getName());
  }
}",0.9219765929778934
135640,"public static void downloadUpdate(Update update){
  ModContainer mod=ModHelper.getModContainer(update.MOD_ID);
  if (mod != null) {
    String fileName=""String_Node_Str"";
    if (update.newFileName != null && !update.newFileName.isEmpty()) {
      fileName=update.newFileName;
    }
 else {
      fileName=mod.getSource().getAbsolutePath();
      String newFileName=fileName.replaceAll(update.oldVersion,update.newVersion);
      if (fileName.equalsIgnoreCase(newFileName)) {
        int i=newFileName.lastIndexOf(""String_Node_Str"");
        if (i == -1) {
          newFileName+=""String_Node_Str"";
        }
 else {
          newFileName=newFileName.substring(0,i) + ""String_Node_Str"" + newFileName.substring(i + 1);
        }
      }
      fileName=newFileName;
    }
    try {
      URL url=new URL(update.updateURL);
      downloadFileFromURL(url,update,mod,fileName);
    }
 catch (    MalformedURLException e) {
      e.printStackTrace();
    }
  }
}","public static void downloadUpdate(Update update){
  ModContainer mod=ModHelper.getModContainer(update.MOD_ID);
  if (mod != null) {
    String fileName=""String_Node_Str"";
    if (update.newFileName != null && !update.newFileName.isEmpty()) {
      fileName=update.newFileName;
    }
 else {
      fileName=mod.getSource().getAbsolutePath();
      String newFileName=fileName.replaceAll(update.oldVersion,update.newVersion);
      if (fileName.equalsIgnoreCase(newFileName)) {
        int i=newFileName.lastIndexOf(""String_Node_Str"");
        if (i == -1) {
          newFileName+=""String_Node_Str"";
        }
 else {
          newFileName=newFileName.substring(0,i) + ""String_Node_Str"" + newFileName.substring(i);
        }
      }
      fileName=newFileName;
    }
    try {
      URL url=new URL(update.updateURL);
      downloadFileFromURL(url,update,mod,fileName);
    }
 catch (    MalformedURLException e) {
      e.printStackTrace();
    }
  }
}",0.9979035639412998
135641,"/** 
 * {@inheritDoc}<p> Overridden to record the exception details. </p>
 */
@Override public void exception(final Throwable thrown){
  int count;
synchronized (this) {
    myFailureCount+=1;
    myCount+=1;
    count=myCount;
    if (mySkipped == null) {
      mySkipped=new ArrayList<WriteOperation>();
      myErrors=new IdentityHashMap<WriteOperation,Throwable>();
    }
    if (thrown instanceof BatchedWriteException) {
      final BatchedWriteException errors=(BatchedWriteException)thrown;
      myLastWrite=errors.getWrite();
      mySkipped.addAll(errors.getSkipped());
      myErrors.putAll(errors.getErrors());
    }
  }
  if (count == myExpectedCount) {
    publish();
  }
}","/** 
 * {@inheritDoc}<p> Overridden to record the exception details. </p>
 */
@Override public void exception(final Throwable thrown){
  boolean publish;
synchronized (this) {
    myFailureCount+=1;
    myCount+=1;
    publish=(myCount == myExpectedCount);
    if (mySkipped == null) {
      mySkipped=new ArrayList<WriteOperation>();
      myErrors=new IdentityHashMap<WriteOperation,Throwable>();
    }
    if (thrown instanceof BatchedWriteException) {
      final BatchedWriteException errors=(BatchedWriteException)thrown;
      myLastWrite=errors.getWrite();
      mySkipped.addAll(errors.getSkipped());
      myErrors.putAll(errors.getErrors());
    }
  }
  if (publish) {
    publish();
  }
}",0.9351585014409222
135642,"/** 
 * Publishes the final results to   {@link #myForwardCallback}.
 */
private void publish(){
  if (myFailureCount == 0) {
    final Document doc=BuilderFactory.start().add(""String_Node_Str"",1).add(""String_Node_Str"",myExpectedCount).build();
    final Reply reply=new Reply(0,0,0,Collections.singletonList(doc),false,false,false,false);
    myForwardCallback.callback(reply);
  }
 else {
    myForwardCallback.exception(new BatchedWriteException(myLastWrite,(myExpectedCount - myFailureCount),mySkipped,myErrors));
  }
}","/** 
 * Publishes the final results to   {@link #myForwardCallback}.
 */
private void publish(){
  Reply reply=null;
  BatchedWriteException error=null;
synchronized (this) {
    if (myFailureCount == 0) {
      final Document doc=BuilderFactory.start().add(""String_Node_Str"",1).add(""String_Node_Str"",myExpectedCount).build();
      reply=new Reply(0,0,0,Collections.singletonList(doc),false,false,false,false);
    }
 else {
      error=new BatchedWriteException(myLastWrite,(myExpectedCount - myFailureCount),mySkipped,myErrors);
    }
  }
  if (reply != null) {
    myForwardCallback.callback(reply);
  }
 else {
    myForwardCallback.exception(error);
  }
}",0.7364864864864865
135643,"/** 
 * {@inheritDoc}<p> Overridden to increment the count and when the max is reached forward the final results. </p>
 */
@Override public void callback(final Reply result){
  int count;
synchronized (this) {
    myCount+=1;
    count=myCount;
  }
  if (count == myExpectedCount) {
    publish();
  }
}","/** 
 * {@inheritDoc}<p> Overridden to increment the count and when the max is reached forward the final results. </p>
 */
@Override public void callback(final Reply result){
  boolean publish;
synchronized (this) {
    myCount+=1;
    publish=(myCount == myExpectedCount);
  }
  if (publish) {
    publish();
  }
}",0.8802588996763754
135644,"/** 
 * Creates a new   {@link BootstrapState}.
 * @return The {@link BootstrapState} to track state of loading the clusterinformation.
 */
protected BootstrapState createBootstrapState(){
  return new BootstrapState();
}","/** 
 * Creates a new   {@link BootstrapState}.
 * @return The {@link BootstrapState} to track state of loading the clusterinformation.
 */
protected BootstrapState createBootstrapState(){
  return new BootstrapState(!myConfig.isAutoDiscoverServers());
}",0.9305263157894736
135645,"/** 
 * Creates a new AuthenticatingConnection.
 * @param connection The connection to ensure gets authenticated as needed.
 * @param config The MongoDB client configuration.
 */
public AuthenticatingConnection(final Connection connection,final MongoClientConfiguration config){
  super(connection,config);
  myAuthenticators=new ConcurrentHashMap<String,Authenticator>();
  myFailures=new ConcurrentHashMap<String,MongoDbException>();
  final Collection<Credential> credentials=config.getCredentials();
  for (  final Credential credential : credentials) {
    final Authenticator authenticator=credential.authenticator();
    authenticator.startAuthentication(credential,connection);
    if (credentials.size() > 1) {
      try {
        if (!authenticator.result()) {
          myFailures.put(credential.getDatabase(),new MongoDbAuthenticationException(""String_Node_Str"" + credential.getDatabase() + ""String_Node_Str""));
        }
      }
 catch (      final MongoDbException error) {
        myFailures.put(credential.getDatabase(),error);
      }
    }
 else {
      myAuthenticators.put(credential.getDatabase(),authenticator);
    }
  }
}","/** 
 * Creates a new AuthenticatingConnection.
 * @param connection The connection to ensure gets authenticated as needed.
 * @param config The MongoDB client configuration.
 */
public AuthenticatingConnection(final Connection connection,final MongoClientConfiguration config){
  super(connection);
  myAuthenticators=new ConcurrentHashMap<String,Authenticator>();
  myFailures=new ConcurrentHashMap<String,MongoDbException>();
  final Collection<Credential> credentials=config.getCredentials();
  for (  final Credential credential : credentials) {
    final Authenticator authenticator=credential.authenticator();
    authenticator.startAuthentication(credential,connection);
    if (credentials.size() > 1) {
      try {
        if (!authenticator.result()) {
          myFailures.put(credential.getDatabase(),new MongoDbAuthenticationException(""String_Node_Str"" + credential.getDatabase() + ""String_Node_Str""));
        }
      }
 catch (      final MongoDbException error) {
        myFailures.put(credential.getDatabase(),error);
      }
    }
 else {
      myAuthenticators.put(credential.getDatabase(),authenticator);
    }
  }
}",0.996933858957512
135646,"/** 
 * Creates a AbstractProxyConnection.
 * @param proxiedConnection The connection to forward to.
 * @param config The MongoDB client configuration.
 */
public AbstractProxyConnection(final Connection proxiedConnection,final MongoClientConfiguration config){
  myProxiedConnection=proxiedConnection;
  myConfig=config;
}","/** 
 * Creates a AbstractProxyConnection.
 * @param proxiedConnection The connection to forward to.
 */
public AbstractProxyConnection(final Connection proxiedConnection){
  myProxiedConnection=proxiedConnection;
}",0.7992565055762082
135647,"/** 
 * Tries to send messages to all of the members of the cluster in an indeterminate state.
 * @param state The state of the cluster.
 * @param answers The pending responses.
 * @param connections The connection already created.
 */
private void updateUnknown(final Cluster state,final Map<Server,Future<Reply>> answers,final Map<Server,Connection> connections){
  for (  final Server server : state.getServers()) {
switch (server.getState()) {
case UNKNOWN:
case UNAVAILABLE:
{
        answers.remove(server);
        sendIsPrimary(answers,connections,server,false);
      }
default :
{
    }
}
}
}","/** 
 * Tries to send messages to all of the members of the cluster in an indeterminate state.
 * @param state The state of the cluster.
 * @param answers The pending responses.
 * @param connections The connection already created.
 */
private void updateUnknown(final Cluster state,final Map<Server,Future<Reply>> answers,final Map<Server,Connection> connections){
  for (  final Server server : state.getServers()) {
switch (server.getState()) {
case UNKNOWN:
case UNAVAILABLE:
{
        answers.remove(server);
        sendIsPrimary(answers,connections,server,false);
        break;
      }
case READ_ONLY:
case WRITABLE:
default :
{
      break;
    }
}
}
}",0.953285827395091
135648,"/** 
 * Creates a new   {@link ShardedConnection}.
 * @param proxiedConnection The connection being proxied.
 * @param config The MongoDB client configuration.
 */
public ShardedConnection(final Connection proxiedConnection,final MongoClientConfiguration config){
  super(proxiedConnection,config);
}","/** 
 * Creates a new   {@link ShardedConnection}.
 * @param proxiedConnection The connection being proxied.
 * @param config The MongoDB client configuration.
 */
public ShardedConnection(final Connection proxiedConnection,final MongoClientConfiguration config){
  super(proxiedConnection);
}",0.988195615514334
135649,"/** 
 * Creates a new TestProxiedConnection.
 * @param proxiedConnection The connection to forward to.
 * @param config The MongoDB client configuration.
 */
public TestProxiedConnection(final Connection proxiedConnection,final MongoClientConfiguration config){
  super(proxiedConnection,config);
}","/** 
 * Creates a new TestProxiedConnection.
 * @param proxiedConnection The connection to forward to.
 * @param config The MongoDB client configuration.
 */
public TestProxiedConnection(final Connection proxiedConnection,final MongoClientConfiguration config){
  super(proxiedConnection);
}",0.9881154499151104
135650,"/** 
 * Test method for   {@link SocketConnection#send} .
 * @throws IOException On a failure connecting to the Mock MongoDB server.
 */
@Test public void testCommandToNew() throws IOException {
  myTestConnection=new SocketConnection(myTestServer,new MongoClientConfiguration());
  myTestConnection.start();
  assertTrue(""String_Node_Str"",ourServer.waitForClient(TimeUnit.SECONDS.toMillis(10)));
  final DocumentBuilder builder=BuilderFactory.start();
  builder.add(""String_Node_Str"",1);
  final Document commandDoc=builder.build();
  final Message command=new Command(""String_Node_Str"",commandDoc,ReadPreference.PRIMARY,Version.parse(""String_Node_Str""));
  builder.reset().pushArray(""String_Node_Str"").add(1).add(1).add(1);
  myTestServer.update(builder.build());
  try {
    myTestConnection.send(command,null);
    fail(""String_Node_Str"");
  }
 catch (  final ServerVersionException sve) {
    assertThat(sve.getActualVersion(),is(Version.parse(""String_Node_Str"")));
    assertThat(sve.getOperation(),is(""String_Node_Str""));
    assertThat(sve.getOperationsMessage(),is(command));
    assertThat(sve.getRequiredVersion(),is(Version.parse(""String_Node_Str"")));
  }
}","/** 
 * Test method for   {@link SocketConnection#send} .
 * @throws IOException On a failure connecting to the Mock MongoDB server.
 */
@Test public void testCommandToNew() throws IOException {
  myTestConnection=new SocketConnection(myTestServer,new MongoClientConfiguration());
  myTestConnection.start();
  assertTrue(""String_Node_Str"",ourServer.waitForClient(TimeUnit.SECONDS.toMillis(10)));
  final DocumentBuilder builder=BuilderFactory.start();
  builder.add(""String_Node_Str"",1);
  final Document commandDoc=builder.build();
  final Message command=new Command(""String_Node_Str"",commandDoc,ReadPreference.PRIMARY,Version.parse(""String_Node_Str""));
  builder.reset().pushArray(""String_Node_Str"").add(1).add(1).add(1);
  myTestServer.update(builder.build());
  try {
    myTestConnection.send(command,null);
    fail(""String_Node_Str"");
  }
 catch (  final ServerVersionException sve) {
    assertThat(sve.getActualVersion(),is(Version.parse(""String_Node_Str"")));
    assertThat(sve.getOperation(),is(""String_Node_Str""));
    assertThat(sve.getSentMessage(),is(command));
    assertThat(sve.getRequiredVersion(),is(Version.parse(""String_Node_Str"")));
  }
}",0.9296740994854202
135651,"/** 
 * Test method for   {@link ServerVersionException#ServerVersionException}.
 */
@Test public void testServerVersionException(){
  final Version actual=Version.parse(""String_Node_Str"");
  final Version required=Version.parse(""String_Node_Str"");
  final Message message=new IsMaster();
  final ServerVersionException ex=new ServerVersionException(""String_Node_Str"",required,actual,message);
  assertThat(ex.getMessage(),is(""String_Node_Str"" + ""String_Node_Str""));
  assertThat(ex.getActualVersion(),sameInstance(actual));
  assertThat(ex.getOperation(),is(""String_Node_Str""));
  assertThat(ex.getRequiredVersion(),sameInstance(required));
  assertThat(ex.getOperationsMessage(),sameInstance(message));
}","/** 
 * Test method for   {@link ServerVersionException#ServerVersionException}.
 */
@Test public void testServerVersionException(){
  final Version actual=Version.parse(""String_Node_Str"");
  final Version required=Version.parse(""String_Node_Str"");
  final Message message=new IsMaster();
  final ServerVersionException ex=new ServerVersionException(""String_Node_Str"",required,actual,message);
  assertThat(ex.getMessage(),is(""String_Node_Str"" + ""String_Node_Str""));
  assertThat(ex.getActualVersion(),sameInstance(actual));
  assertThat(ex.getOperation(),is(""String_Node_Str""));
  assertThat(ex.getRequiredVersion(),sameInstance(required));
  assertThat(ex.getSentMessage(),sameInstance(message));
}",0.9900426742532006
135652,"public void run(){
  try {
    while (!cancelled) {
      long start=System.currentTimeMillis();
      ManagedEntity[] vms=null;
      ManagedEntity[] clusters=null;
      clusterMap=new HashMap<String,String>();
      for (int i=0; i < Integer.parseInt(appConfig.get(""String_Node_Str"")); i++) {
        String stats=""String_Node_Str"";
        this.vm_mob_queue.put(stats);
      }
      try {
        vms=new InventoryNavigator(this.si.getRootFolder()).searchManagedEntities(""String_Node_Str"");
        clusters=new InventoryNavigator(si.getRootFolder()).searchManagedEntities(new String[][]{new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}},true);
      }
 catch (      RemoteException e) {
        e.getStackTrace();
        logger.info(""String_Node_Str"" + e);
        System.exit(200);
      }
      for (      ManagedEntity cluster : clusters) {
        String name=cluster.getName();
        ManagedObjectReference[] hosts=(ManagedObjectReference[])cluster.getPropertyByPath(""String_Node_Str"");
        if (hosts == null)         continue;
        for (        ManagedObjectReference host : hosts) {
          clusterMap.put(host.val,name.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
        }
      }
      if (vms != null) {
        logger.info(""String_Node_Str"" + vms.length + ""String_Node_Str"");
        for (        ManagedEntity vm : vms) {
          if (vm != null) {
            String cluster=""String_Node_Str"";
            ManagedObjectReference host=(ManagedObjectReference)vm.getPropertyByPath(""String_Node_Str"");
            if (clusterMap.containsKey(host.val)) {
              cluster=clusterMap.get(host.val);
            }
            this.vm_mob_queue.put(new Object[]{vm,cluster});
          }
        }
      }
 else {
        logger.info(""String_Node_Str"");
      }
      long vm_stop=System.currentTimeMillis();
      long vm_loop_took=vm_stop - start;
      logger.debug(""String_Node_Str"" + vm_loop_took + ""String_Node_Str"");
      for (int i=0; i < Integer.parseInt(appConfig.get(""String_Node_Str"")); i++) {
        String stats=""String_Node_Str"";
        this.vm_mob_queue.put(stats);
      }
      long esx_loop_took=0;
      String graphEsx=this.appConfig.get(""String_Node_Str"");
      if (graphEsx.contains(""String_Node_Str"")) {
        for (int i=0; i < Integer.parseInt(appConfig.get(""String_Node_Str"")); i++) {
          String stats=""String_Node_Str"";
          this.esx_mob_queue.put(stats);
        }
        ManagedEntity[] esx=null;
        try {
          esx=new InventoryNavigator(this.si.getRootFolder()).searchManagedEntities(""String_Node_Str"");
        }
 catch (        RemoteException e) {
          e.getStackTrace();
          logger.info(""String_Node_Str"" + e);
          System.exit(201);
        }
        logger.info(""String_Node_Str"" + esx.length + ""String_Node_Str"");
        if (esx != null) {
          for (          ManagedEntity anEsx : esx) {
            if (anEsx != null) {
              String cluster=""String_Node_Str"";
              String id=anEsx.getMOR().val;
              if (clusterMap.containsKey(id)) {
                cluster=clusterMap.get(id);
              }
              this.esx_mob_queue.put(new Object[]{anEsx,cluster});
            }
          }
        }
        long esx_stop=System.currentTimeMillis();
        esx_loop_took=esx_stop - start;
        logger.debug(""String_Node_Str"" + esx_loop_took + ""String_Node_Str"");
        for (int i=0; i < Integer.parseInt(appConfig.get(""String_Node_Str"")); i++) {
          String stats=""String_Node_Str"";
          this.esx_mob_queue.put(stats);
        }
      }
      long loop_took=vm_loop_took + esx_loop_took;
      int user_sleep_time=Integer.parseInt(appConfig.get(""String_Node_Str"")) * 1000;
      long sleep_time=user_sleep_time - loop_took;
      logger.debug(""String_Node_Str"" + sleep_time + ""String_Node_Str"");
      Thread.sleep(sleep_time);
      String dump=""String_Node_Str"";
      sender.put(dump);
      if (appConfig.get(""String_Node_Str"").contains(""String_Node_Str"")) {
        logger.info(""String_Node_Str"");
        System.exit(0);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    logger.info(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ e.getMessage());
    System.exit(202);
  }
catch (  Exception e) {
    System.out.println(Arrays.toString(e.getStackTrace()));
    logger.info(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ e.getMessage());
    System.exit(203);
  }
}","public void run(){
  try {
    while (!cancelled) {
      long start=System.currentTimeMillis();
      ManagedEntity[] vms=null;
      ManagedEntity[] clusters=null;
      clusterMap=new HashMap<String,String>();
      for (int i=0; i < Integer.parseInt(appConfig.get(""String_Node_Str"")); i++) {
        String stats=""String_Node_Str"";
        this.vm_mob_queue.put(stats);
      }
      try {
        vms=new InventoryNavigator(this.si.getRootFolder()).searchManagedEntities(""String_Node_Str"");
        clusters=new InventoryNavigator(si.getRootFolder()).searchManagedEntities(new String[][]{new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}},true);
      }
 catch (      RemoteException e) {
        e.getStackTrace();
        logger.info(""String_Node_Str"" + e);
        System.exit(200);
      }
      for (      ManagedEntity cluster : clusters) {
        String name=cluster.getName();
        ManagedObjectReference[] hosts=(ManagedObjectReference[])cluster.getPropertyByPath(""String_Node_Str"");
        if (hosts == null)         continue;
        for (        ManagedObjectReference host : hosts) {
          clusterMap.put(host.val,name.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
        }
      }
      if (vms != null) {
        logger.info(""String_Node_Str"" + vms.length + ""String_Node_Str"");
        for (        ManagedEntity vm : vms) {
          if (vm != null) {
            String cluster=""String_Node_Str"";
            ManagedObjectReference host=(ManagedObjectReference)vm.getPropertyByPath(""String_Node_Str"");
            if (clusterMap.containsKey(host.val)) {
              cluster=clusterMap.get(host.val);
            }
            this.vm_mob_queue.put(new Object[]{vm,cluster});
          }
        }
      }
 else {
        logger.info(""String_Node_Str"");
      }
      long vm_stop=System.currentTimeMillis();
      long vm_loop_took=vm_stop - start;
      logger.debug(""String_Node_Str"" + vm_loop_took + ""String_Node_Str"");
      for (int i=0; i < Integer.parseInt(appConfig.get(""String_Node_Str"")); i++) {
        String stats=""String_Node_Str"";
        this.vm_mob_queue.put(stats);
      }
      long esx_start=System.currentTimeMillis();
      long esx_loop_took=0;
      String graphEsx=this.appConfig.get(""String_Node_Str"");
      if (graphEsx.contains(""String_Node_Str"")) {
        for (int i=0; i < Integer.parseInt(appConfig.get(""String_Node_Str"")); i++) {
          String stats=""String_Node_Str"";
          this.esx_mob_queue.put(stats);
        }
        ManagedEntity[] esx=null;
        try {
          esx=new InventoryNavigator(this.si.getRootFolder()).searchManagedEntities(""String_Node_Str"");
        }
 catch (        RemoteException e) {
          e.getStackTrace();
          logger.info(""String_Node_Str"" + e);
          System.exit(201);
        }
        logger.info(""String_Node_Str"" + esx.length + ""String_Node_Str"");
        if (esx != null) {
          for (          ManagedEntity anEsx : esx) {
            if (anEsx != null) {
              String cluster=""String_Node_Str"";
              String id=anEsx.getMOR().val;
              if (clusterMap.containsKey(id)) {
                cluster=clusterMap.get(id);
              }
              this.esx_mob_queue.put(new Object[]{anEsx,cluster});
            }
          }
        }
        esx_loop_took=System.currentTimeMillis() - esx_start;
        logger.debug(""String_Node_Str"" + esx_loop_took + ""String_Node_Str"");
        for (int i=0; i < Integer.parseInt(appConfig.get(""String_Node_Str"")); i++) {
          String stats=""String_Node_Str"";
          this.esx_mob_queue.put(stats);
        }
      }
      long loop_took=vm_loop_took + esx_loop_took;
      int user_sleep_time=Integer.parseInt(appConfig.get(""String_Node_Str"")) * 1000;
      long sleep_time=user_sleep_time - loop_took;
      logger.debug(""String_Node_Str"" + sleep_time + ""String_Node_Str"");
      Thread.sleep(sleep_time);
      String dump=""String_Node_Str"";
      sender.put(dump);
      if (appConfig.get(""String_Node_Str"").contains(""String_Node_Str"")) {
        logger.info(""String_Node_Str"");
        System.exit(0);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    logger.info(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ e.getMessage());
    System.exit(202);
  }
catch (  Exception e) {
    System.out.println(Arrays.toString(e.getStackTrace()));
    logger.info(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ e.getMessage());
    System.exit(203);
  }
}",0.98534997287032
135653,"protected boolean preprocess(@Nonnull AbstractQApiTypeDescriptor root){
  if (fields != null)   return false;
  innerTypes=new ArrayList<QApiTypeDescriptor>();
  fields=new ArrayList<Field>();
  if (data != null) {
    for (    Map.Entry<String,Object> e : data.entrySet()) {
      Field field=new Field();
      field.name=e.getKey();
      if (field.name.startsWith(""String_Node_Str"")) {
        field.optional=true;
        field.name=field.name.substring(1);
        field.annotations=""String_Node_Str"";
      }
 else       if (this instanceof QApiUnionDescriptor) {
        field.optional=true;
        field.annotations=""String_Node_Str"";
      }
 else {
        field.optional=false;
        field.annotations=""String_Node_Str"";
      }
      field.serializedName=field.name;
      field.name=toJavaName(field.name);
      if (e.getValue() instanceof Map) {
        QApiTypeDescriptor type=new QApiTypeDescriptor();
        type.name=""String_Node_Str"" + e.getKey();
        type.data=(Map<String,Object>)e.getValue();
        type.preprocess(root);
        root.innerTypes.add(type);
        field.typeName=type.name;
      }
 else {
        field.typeName=toNestedJavaType(e.getValue());
      }
      if (field.optional)       field.typeName=toWrappedJavaType(field.typeName);
      fields.add(field);
    }
  }
  return true;
}","protected boolean preprocess(@Nonnull AbstractQApiTypeDescriptor root){
  if (fields != null)   return false;
  innerTypes=new ArrayList<QApiTypeDescriptor>();
  fields=new ArrayList<Field>();
  if (data != null) {
    for (    Map.Entry<String,Object> e : data.entrySet()) {
      Field field=new Field();
      field.name=e.getKey();
      if (field.name.startsWith(""String_Node_Str"")) {
        field.optional=true;
        field.name=field.name.substring(1);
        field.annotations=""String_Node_Str"";
      }
 else       if (this instanceof AbstractQApiUnionDescriptor) {
        field.optional=true;
        field.annotations=""String_Node_Str"";
      }
 else {
        field.optional=false;
        field.annotations=""String_Node_Str"";
      }
      field.serializedName=field.name;
      field.name=toJavaName(field.name);
      if (e.getValue() instanceof Map) {
        QApiTypeDescriptor type=new QApiTypeDescriptor();
        type.name=""String_Node_Str"" + e.getKey();
        type.data=(Map<String,Object>)e.getValue();
        type.preprocess(root);
        root.innerTypes.add(type);
        field.typeName=type.name;
      }
 else {
        field.typeName=toNestedJavaType(e.getValue());
      }
      if (field.optional)       field.typeName=toWrappedJavaType(field.typeName);
      fields.add(field);
    }
  }
  return true;
}",0.9970171513795676
135654,"public AuthenticationException(String msg,Throwable cause){
  super(msg,cause);
}","public AuthenticationException(Throwable throwable){
  super(throwable);
}",0.7741935483870968
135655,"private KeyPair doDecodePrivateKey(Reader reader,String passphrase) throws IOException {
  PEMParser keyReader=new PEMParser(reader);
  JcaPEMKeyConverter converter=new JcaPEMKeyConverter();
  PEMDecryptorProvider decryptionProv=new JcePEMDecryptorProviderBuilder().build(passphrase.toCharArray());
  Object privateKey=keyReader.readObject();
  KeyPair keyPair;
  if (privateKey instanceof PEMEncryptedKeyPair) {
    PEMKeyPair decryptedKeyPair=((PEMEncryptedKeyPair)privateKey).decryptKeyPair(decryptionProv);
    keyPair=converter.getKeyPair(decryptedKeyPair);
  }
 else {
    keyPair=converter.getKeyPair((PEMKeyPair)privateKey);
  }
  keyReader.close();
  return keyPair;
}","private KeyPair doDecodePrivateKey(Reader reader,String passphrase) throws IOException {
  try (PEMParser keyReader=new PEMParser(reader)){
    JcaPEMKeyConverter converter=new JcaPEMKeyConverter();
    PEMDecryptorProvider decryptionProv=new JcePEMDecryptorProviderBuilder().build(passphrase.toCharArray());
    Object privateKey=keyReader.readObject();
    KeyPair keyPair;
    if (privateKey instanceof PEMEncryptedKeyPair) {
      PEMKeyPair decryptedKeyPair=((PEMEncryptedKeyPair)privateKey).decryptKeyPair(decryptionProv);
      keyPair=converter.getKeyPair(decryptedKeyPair);
    }
 else {
      keyPair=converter.getKeyPair((PEMKeyPair)privateKey);
    }
    return keyPair;
  }
 }",0.9385065885797952
135656,"private int decodeInt(){
  return ((bytes[pos++] & 0xFF) << 24) | ((bytes[pos++] & 0xFF) << 16) | ((bytes[pos++] & 0xFF) << 8)| (bytes[pos++] & 0xFF);
}","private int decodeInt(){
  return (bytes[pos++] & 0xFF) << 24 | (bytes[pos++] & 0xFF) << 16 | (bytes[pos++] & 0xFF) << 8 | bytes[pos++] & 0xFF;
}",0.9696969696969696
135657,"public KeyPair decodePrivateKey(String keyPath,String passphrase) throws IOException {
  FileReader fileReader=new FileReader(keyPath);
  return doDecodePrivateKey(fileReader,passphrase);
}","public KeyPair decodePrivateKey(String keyPath,String passphrase) throws IOException {
  try (Reader reader=new InputStreamReader(new FileInputStream(keyPath),StandardCharsets.UTF_8)){
    return doDecodePrivateKey(reader,passphrase);
  }
 }",0.4651162790697674
135658,"private String decodeType(){
  int len=decodeInt();
  String type=new String(bytes,pos,len);
  pos+=len;
  return type;
}","private String decodeType(){
  int len=decodeInt();
  String type=new String(bytes,pos,len,StandardCharsets.UTF_8);
  pos+=len;
  return type;
}",0.9132075471698112
135659,"public PublicKey decodePublicKey(String keyLine) throws GeneralSecurityException {
  bytes=Base64.getDecoder().decode(keyLine.getBytes());
  if (bytes.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + keyLine);
  }
  pos=0;
  String type=decodeType();
  if (type.equals(KEY_TYPE_RSA)) {
    return decodeAsRSA();
  }
  if (type.equals(KEY_TYPE_DSA)) {
    return decodeAsDSA();
  }
  if (type.equals(KEY_TYPE_ECDSA)) {
    return decodeAsECDSA();
  }
  throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ keyLine);
}","public PublicKey decodePublicKey(String keyLine) throws GeneralSecurityException {
  bytes=Base64.getDecoder().decode(keyLine.getBytes(StandardCharsets.UTF_8));
  if (bytes.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + keyLine);
  }
  pos=0;
  String type=decodeType();
  if (type.equals(KEY_TYPE_RSA)) {
    return decodeAsRSA();
  }
  if (type.equals(KEY_TYPE_DSA)) {
    return decodeAsDSA();
  }
  if (type.equals(KEY_TYPE_ECDSA)) {
    return decodeAsECDSA();
  }
  throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ keyLine);
}",0.9810344827586208
135660,"public String encodePublicKey(PublicKey publicKey) throws IOException {
  String publicKeyEncoded;
  ByteArrayOutputStream byteOs=new ByteArrayOutputStream();
  if (publicKey.getAlgorithm().equals(KEY_FACTORY_TYPE_RSA)) {
    RSAPublicKey rsaPublicKey=(RSAPublicKey)publicKey;
    DataOutputStream dataOutputStream=new DataOutputStream(byteOs);
    dataOutputStream.writeInt(KEY_TYPE_RSA.getBytes().length);
    dataOutputStream.write(KEY_TYPE_RSA.getBytes());
    dataOutputStream.writeInt(rsaPublicKey.getPublicExponent().toByteArray().length);
    dataOutputStream.write(rsaPublicKey.getPublicExponent().toByteArray());
    dataOutputStream.writeInt(rsaPublicKey.getModulus().toByteArray().length);
    dataOutputStream.write(rsaPublicKey.getModulus().toByteArray());
  }
 else   if (publicKey.getAlgorithm().equals(KEY_FACTORY_TYPE_DSA)) {
    DSAPublicKey dsaPublicKey=(DSAPublicKey)publicKey;
    DSAParams dsaParams=dsaPublicKey.getParams();
    DataOutputStream dataOutputStream=new DataOutputStream(byteOs);
    dataOutputStream.writeInt(KEY_TYPE_DSA.getBytes().length);
    dataOutputStream.write(KEY_TYPE_DSA.getBytes());
    dataOutputStream.writeInt(dsaParams.getP().toByteArray().length);
    dataOutputStream.write(dsaParams.getP().toByteArray());
    dataOutputStream.writeInt(dsaParams.getQ().toByteArray().length);
    dataOutputStream.write(dsaParams.getQ().toByteArray());
    dataOutputStream.writeInt(dsaParams.getG().toByteArray().length);
    dataOutputStream.write(dsaParams.getG().toByteArray());
    dataOutputStream.writeInt(dsaPublicKey.getY().toByteArray().length);
    dataOutputStream.write(dsaPublicKey.getY().toByteArray());
  }
 else   if (publicKey.getAlgorithm().equals(KEY_FACTORY_TYPE_ECDSA)) {
    BCECPublicKey ecPublicKey=(BCECPublicKey)publicKey;
    DataOutputStream dataOutputStream=new DataOutputStream(byteOs);
    dataOutputStream.writeInt(KEY_TYPE_ECDSA.getBytes().length);
    dataOutputStream.write(KEY_TYPE_ECDSA.getBytes());
    dataOutputStream.writeInt(ECDSA_SUPPORTED_CURVE_NAME.getBytes().length);
    dataOutputStream.write(ECDSA_SUPPORTED_CURVE_NAME.getBytes());
    byte[] affineXCoord=ecPublicKey.getQ().getAffineXCoord().getEncoded();
    byte[] affineYCoord=ecPublicKey.getQ().getAffineYCoord().getEncoded();
    dataOutputStream.writeInt(affineXCoord.length + affineYCoord.length + 1);
    dataOutputStream.writeByte(0x04);
    dataOutputStream.write(affineXCoord);
    dataOutputStream.write(affineYCoord);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + publicKey.getAlgorithm());
  }
  publicKeyEncoded=new String(Base64.getEncoder().encodeToString(byteOs.toByteArray()));
  return publicKeyEncoded;
}","public String encodePublicKey(PublicKey publicKey) throws IOException {
  ByteArrayOutputStream byteOs=new ByteArrayOutputStream();
  if (publicKey instanceof RSAPublicKey && publicKey.getAlgorithm().equals(KEY_FACTORY_TYPE_RSA)) {
    RSAPublicKey rsaPublicKey=(RSAPublicKey)publicKey;
    DataOutputStream dataOutputStream=new DataOutputStream(byteOs);
    dataOutputStream.writeInt(KEY_TYPE_RSA.getBytes(StandardCharsets.UTF_8).length);
    dataOutputStream.write(KEY_TYPE_RSA.getBytes(StandardCharsets.UTF_8));
    dataOutputStream.writeInt(rsaPublicKey.getPublicExponent().toByteArray().length);
    dataOutputStream.write(rsaPublicKey.getPublicExponent().toByteArray());
    dataOutputStream.writeInt(rsaPublicKey.getModulus().toByteArray().length);
    dataOutputStream.write(rsaPublicKey.getModulus().toByteArray());
  }
 else   if (publicKey instanceof DSAPublicKey && publicKey.getAlgorithm().equals(KEY_FACTORY_TYPE_DSA)) {
    DSAPublicKey dsaPublicKey=(DSAPublicKey)publicKey;
    DSAParams dsaParams=dsaPublicKey.getParams();
    DataOutputStream dataOutputStream=new DataOutputStream(byteOs);
    dataOutputStream.writeInt(KEY_TYPE_DSA.getBytes(StandardCharsets.UTF_8).length);
    dataOutputStream.write(KEY_TYPE_DSA.getBytes(StandardCharsets.UTF_8));
    dataOutputStream.writeInt(dsaParams.getP().toByteArray().length);
    dataOutputStream.write(dsaParams.getP().toByteArray());
    dataOutputStream.writeInt(dsaParams.getQ().toByteArray().length);
    dataOutputStream.write(dsaParams.getQ().toByteArray());
    dataOutputStream.writeInt(dsaParams.getG().toByteArray().length);
    dataOutputStream.write(dsaParams.getG().toByteArray());
    dataOutputStream.writeInt(dsaPublicKey.getY().toByteArray().length);
    dataOutputStream.write(dsaPublicKey.getY().toByteArray());
  }
 else   if (publicKey instanceof BCECPublicKey && publicKey.getAlgorithm().equals(KEY_FACTORY_TYPE_ECDSA)) {
    BCECPublicKey ecPublicKey=(BCECPublicKey)publicKey;
    DataOutputStream dataOutputStream=new DataOutputStream(byteOs);
    dataOutputStream.writeInt(KEY_TYPE_ECDSA.getBytes(StandardCharsets.UTF_8).length);
    dataOutputStream.write(KEY_TYPE_ECDSA.getBytes(StandardCharsets.UTF_8));
    dataOutputStream.writeInt(ECDSA_SUPPORTED_CURVE_NAME.getBytes(StandardCharsets.UTF_8).length);
    dataOutputStream.write(ECDSA_SUPPORTED_CURVE_NAME.getBytes(StandardCharsets.UTF_8));
    byte[] affineXCoord=ecPublicKey.getQ().getAffineXCoord().getEncoded();
    byte[] affineYCoord=ecPublicKey.getQ().getAffineYCoord().getEncoded();
    dataOutputStream.writeInt(affineXCoord.length + affineYCoord.length + 1);
    dataOutputStream.writeByte(0x04);
    dataOutputStream.write(affineXCoord);
    dataOutputStream.write(affineYCoord);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + publicKey.getAlgorithm());
  }
  return Base64.getEncoder().encodeToString(byteOs.toByteArray());
}",0.9324276010010726
135661,"@Override public Enumeration<String> getInitParameterNames(){
  return new Enumeration<String>(){
    final Iterator<String> keySet=filterConfig.keySet().iterator();
    @Override public boolean hasMoreElements(){
      return (keySet != null ? keySet.hasNext() : false);
    }
    @Override public String nextElement(){
      return (keySet != null ? keySet.next() : null);
    }
  }
;
}","@Override public Enumeration<String> getInitParameterNames(){
  return new Enumeration<String>(){
    final Iterator<String> keySet=filterConfig.keySet().iterator();
    @Override public boolean hasMoreElements(){
      return keySet != null ? keySet.hasNext() : false;
    }
    @Override public String nextElement(){
      return keySet != null ? keySet.next() : null;
    }
  }
;
}",0.9948186528497408
135662,"@Override public boolean hasMoreElements(){
  return (keySet != null ? keySet.hasNext() : false);
}","@Override public boolean hasMoreElements(){
  return keySet != null ? keySet.hasNext() : false;
}",0.9897959183673468
135663,"/** 
 * Utility method to extract a <code>ServletContext</code> from a listener's <code>FilterConfig</code>.
 * @param listener An object which listens for filter chain configuration changes.
 * @return An extracted <code>ServletContext</code>, or null if either the<code>FilterConfig</code> of <code>ServletContext</code> is null
 */
private static ServletContext extractServletContext(final CustomFilterAdapterListener listener){
  final FilterConfig listenerFilterConfig=listener.getFilterConfig();
  final ServletContext listenerServletContext=(listenerFilterConfig != null ? listenerFilterConfig.getServletContext() : null);
  return listenerServletContext;
}","/** 
 * Utility method to extract a <code>ServletContext</code> from a listener's <code>FilterConfig</code>.
 * @param listener An object which listens for filter chain configuration changes.
 * @return An extracted <code>ServletContext</code>, or null if either the<code>FilterConfig</code> of <code>ServletContext</code> is null
 */
private static ServletContext extractServletContext(final CustomFilterAdapterListener listener){
  final FilterConfig listenerFilterConfig=listener.getFilterConfig();
  final ServletContext listenerServletContext=listenerFilterConfig != null ? listenerFilterConfig.getServletContext() : null;
  return listenerServletContext;
}",0.9984917043740572
135664,"@Override public String getInitParameter(final String paramName){
  return (filterConfig != null ? filterConfig.get(paramName) : null);
}","@Override public String getInitParameter(final String paramName){
  return filterConfig != null ? filterConfig.get(paramName) : null;
}",0.9926470588235294
135665,"/** 
 * Extract a subset of properties that apply to a particular Filter.
 * @param clazzName prefix used to specify key value pair (i.e., a.b.c.Filter.property)
 * @param fullConfiguration The entire configuration dictionary, which is traversed for applicable properties.
 * @return A Map of applicable properties for a filter.
 */
private static Map<String,String> extractPropertiesForFilter(final String clazzName,final Map<String,String> fullConfiguration){
  final Map<String,String> extractedConfig=new HashMap<>();
  final Set<String> fullConfigurationKeySet=fullConfiguration.keySet();
  for (  String key : fullConfigurationKeySet) {
    final int lastDotSeparator=key.lastIndexOf(""String_Node_Str"");
    if (lastDotSeparator >= 0) {
      final String comparisonClazzNameSubstring=key.substring(0,lastDotSeparator);
      if (comparisonClazzNameSubstring.equals(clazzName)) {
        final String value=fullConfiguration.get(key);
        final String filterInitParamKey=key.substring(lastDotSeparator + 1);
        extractedConfig.put(filterInitParamKey,value);
      }
    }
 else {
      if (!key.equals(CUSTOM_FILTER_LIST_KEY)) {
        LOG.error(""String_Node_Str"",key);
      }
    }
  }
  return extractedConfig;
}","/** 
 * Extract a subset of properties that apply to a particular Filter.
 * @param clazzName prefix used to specify key value pair (i.e., a.b.c.Filter.property)
 * @param fullConfiguration The entire configuration dictionary, which is traversed for applicable properties.
 * @return A Map of applicable properties for a filter.
 */
private static Map<String,String> extractPropertiesForFilter(final String clazzName,final Map<String,String> fullConfiguration){
  final Map<String,String> extractedConfig=new HashMap<>();
  for (  Entry<String,String> entry : fullConfiguration.entrySet()) {
    String key=entry.getKey();
    final int lastDotSeparator=key.lastIndexOf(""String_Node_Str"");
    if (lastDotSeparator >= 0) {
      final String comparisonClazzNameSubstring=key.substring(0,lastDotSeparator);
      if (comparisonClazzNameSubstring.equals(clazzName)) {
        final String filterInitParamKey=key.substring(lastDotSeparator + 1);
        extractedConfig.put(filterInitParamKey,entry.getValue());
      }
    }
 else {
      if (!key.equals(CUSTOM_FILTER_LIST_KEY)) {
        LOG.error(""String_Node_Str"",key);
      }
    }
  }
  return extractedConfig;
}",0.9057547956630524
135666,"public Dictionary<String,?> getDefaultProperties(){
  return DEFAULT_CONFIGURATION;
}","public Dictionary<String,?> getDefaultProperties(){
  return new Hashtable<>(DEFAULT_CONFIGURATION);
}",0.9090909090909092
135667,"@Override public String nextElement(){
  return (keySet != null ? keySet.next() : null);
}","@Override public String nextElement(){
  return keySet != null ? keySet.next() : null;
}",0.9887640449438202
135668,"/** 
 * Empties the store.
 * @throws StoreException if a connection error occurs.
 */
public void dbClean() throws StoreException {
  try (Connection c=dbConnect()){
    String sql=""String_Node_Str"" + tableName;
    c.createStatement().execute(sql);
  }
 catch (  SQLException e) {
    LOG.error(""String_Node_Str"",tableName,e);
    throw new StoreException(""String_Node_Str"" + tableName,e);
  }
}","/** 
 * Empties the store.
 * @throws StoreException if a connection error occurs.
 */
public void dbClean() throws StoreException {
  try (Connection c=dbConnect()){
    String sql=""String_Node_Str"" + tableName;
    try (Statement statement=c.createStatement()){
      statement.execute(sql);
    }
   }
 catch (  SQLException e) {
    LOG.error(""String_Node_Str"",tableName,e);
    throw new StoreException(""String_Node_Str"" + tableName,e);
  }
}",0.9407582938388626
135669,"protected Domain deleteDomain(String domainid) throws StoreException {
  domainid=StringEscapeUtils.escapeHtml4(domainid);
  Domain deletedDomain=this.getDomain(domainid);
  if (deletedDomain == null) {
    return null;
  }
  String query=String.format(""String_Node_Str"",domainid);
  try (Connection conn=dbConnect();Statement statement=conn.createStatement()){
    int deleteCount=statement.executeUpdate(query);
    LOG.debug(""String_Node_Str"",deleteCount);
    return deletedDomain;
  }
 catch (  SQLException e) {
    LOG.error(""String_Node_Str"",domainid,e);
    throw new StoreException(""String_Node_Str"",e);
  }
}","@SuppressFBWarnings(""String_Node_Str"") protected Domain deleteDomain(String domainid) throws StoreException {
  domainid=StringEscapeUtils.escapeHtml4(domainid);
  Domain deletedDomain=this.getDomain(domainid);
  if (deletedDomain == null) {
    return null;
  }
  String query=String.format(""String_Node_Str"",domainid);
  try (Connection conn=dbConnect();Statement statement=conn.createStatement()){
    int deleteCount=statement.executeUpdate(query);
    LOG.debug(""String_Node_Str"",deleteCount);
    return deletedDomain;
  }
 catch (  SQLException e) {
    LOG.error(""String_Node_Str"",domainid,e);
    throw new StoreException(""String_Node_Str"",e);
  }
}",0.9694596711041504
135670,"protected Grant deleteGrant(String grantid) throws StoreException {
  grantid=StringEscapeUtils.escapeHtml4(grantid);
  Grant savedGrant=this.getGrant(grantid);
  if (savedGrant == null) {
    return null;
  }
  String query=String.format(""String_Node_Str"",grantid);
  try (Connection conn=dbConnect();Statement statement=conn.createStatement()){
    int deleteCount=statement.executeUpdate(query);
    LOG.debug(""String_Node_Str"",deleteCount);
    return savedGrant;
  }
 catch (  SQLException e) {
    throw new StoreException(""String_Node_Str"",e);
  }
}","@SuppressFBWarnings(""String_Node_Str"") protected Grant deleteGrant(String grantid) throws StoreException {
  grantid=StringEscapeUtils.escapeHtml4(grantid);
  Grant savedGrant=this.getGrant(grantid);
  if (savedGrant == null) {
    return null;
  }
  String query=String.format(""String_Node_Str"",grantid);
  try (Connection conn=dbConnect();Statement statement=conn.createStatement()){
    int deleteCount=statement.executeUpdate(query);
    LOG.debug(""String_Node_Str"",deleteCount);
    return savedGrant;
  }
 catch (  SQLException e) {
    throw new StoreException(""String_Node_Str"",e);
  }
}",0.9661164205039096
135671,"protected Role deleteRole(String roleid) throws StoreException {
  roleid=StringEscapeUtils.escapeHtml4(roleid);
  Role savedRole=this.getRole(roleid);
  if (savedRole == null) {
    return null;
  }
  String query=String.format(""String_Node_Str"",roleid);
  try (Connection conn=dbConnect();Statement statement=conn.createStatement()){
    int deleteCount=statement.executeUpdate(query);
    LOG.debug(""String_Node_Str"",deleteCount);
    return savedRole;
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
}","@SuppressFBWarnings(""String_Node_Str"") protected Role deleteRole(String roleid) throws StoreException {
  roleid=StringEscapeUtils.escapeHtml4(roleid);
  Role savedRole=this.getRole(roleid);
  if (savedRole == null) {
    return null;
  }
  String query=String.format(""String_Node_Str"",roleid);
  try (Connection conn=dbConnect();Statement statement=conn.createStatement()){
    int deleteCount=statement.executeUpdate(query);
    LOG.debug(""String_Node_Str"",deleteCount);
    return savedRole;
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
}",0.9655172413793104
135672,"protected User deleteUser(String userid) throws StoreException {
  userid=StringEscapeUtils.escapeHtml4(userid);
  User savedUser=this.getUser(userid);
  if (savedUser == null) {
    return null;
  }
  String query=String.format(""String_Node_Str"",userid);
  try (Connection conn=dbConnect();Statement statement=conn.createStatement()){
    int deleteCount=statement.executeUpdate(query);
    LOG.debug(""String_Node_Str"",deleteCount);
    return savedUser;
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
}","@SuppressFBWarnings(""String_Node_Str"") protected User deleteUser(String userid) throws StoreException {
  userid=StringEscapeUtils.escapeHtml4(userid);
  User savedUser=this.getUser(userid);
  if (savedUser == null) {
    return null;
  }
  String query=String.format(""String_Node_Str"",userid);
  try (Connection conn=dbConnect();Statement statement=conn.createStatement()){
    int deleteCount=statement.executeUpdate(query);
    LOG.debug(""String_Node_Str"",deleteCount);
    return savedUser;
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
}",0.9655172413793104
135673,"public MdsalStore(DataBroker dataBroker){
  this.dataBroker=dataBroker;
}","public MdsalStore(DataBroker dataBroker){
}",0.7413793103448276
135674,"@Override public void writeTo(T type,Class<?> theClass,Type genericType,Annotation[] annotations,MediaType mediaType,MultivaluedMap<String,Object> httpHeaders,OutputStream entityStream) throws IOException, WebApplicationException {
  PrintWriter printWriter=new PrintWriter(entityStream);
  try {
    String json;
    if (ui.getQueryParameters().containsKey(PRETTY_PRINT)) {
      json=prettyGson.toJson(type);
    }
 else {
      json=gson.toJson(type);
    }
    printWriter.write(json);
    printWriter.flush();
  }
  finally {
    printWriter.close();
  }
}","@Override @SuppressFBWarnings(""String_Node_Str"") public void writeTo(T type,Class<?> theClass,Type genericType,Annotation[] annotations,MediaType mediaType,MultivaluedMap<String,Object> httpHeaders,OutputStream entityStream) throws IOException, WebApplicationException {
  PrintWriter printWriter=new PrintWriter(entityStream);
  try {
    String json;
    if (ui.getQueryParameters().containsKey(PRETTY_PRINT)) {
      json=prettyGson.toJson(type);
    }
 else {
      json=gson.toJson(type);
    }
    printWriter.write(json);
    printWriter.flush();
  }
  finally {
    printWriter.close();
  }
}",0.96640826873385
135675,"@Override protected boolean onAccessDenied(final ServletRequest request,final ServletResponse response) throws Exception {
  final Subject currentUser=SecurityUtils.getSubject();
  return executeLogin(request,response);
}","@Override protected boolean onAccessDenied(final ServletRequest request,final ServletResponse response) throws Exception {
  SecurityUtils.getSubject();
  return executeLogin(request,response);
}",0.9375
135676,"@Override @SuppressWarnings(""String_Node_Str"") protected boolean executeLogin(final ServletRequest request,final ServletResponse response) throws Exception {
  final HttpServletRequest req;
  try {
    req=(HttpServletRequest)request;
  }
 catch (  final ClassCastException e) {
    LOG.debug(""String_Node_Str"",e);
    throw e;
  }
  final HttpServletResponse resp;
  try {
    resp=(HttpServletResponse)response;
  }
 catch (  final ClassCastException e) {
    LOG.debug(""String_Node_Str"",e);
    throw e;
  }
  try {
    if (req.getServletPath().equals(TOKEN_GRANT_ENDPOINT)) {
      final UsernamePasswordToken token=createToken(request,response);
      if (token == null) {
        final String msg=""String_Node_Str"" + ""String_Node_Str"";
        throw new IllegalStateException(msg);
      }
      try {
        final Subject subject=getSubject(request,response);
        subject.login(token);
        return onLoginSuccess(token,subject,request,response);
      }
 catch (      final AuthenticationException e) {
        return onLoginFailure(token,e,request,response);
      }
    }
 else     if (req.getServletPath().equals(TOKEN_REVOKE_ENDPOINT)) {
    }
 else     if (req.getServletPath().equals(TOKEN_VALIDATE_ENDPOINT)) {
    }
  }
 catch (  final AuthenticationException e) {
    error(resp,SC_UNAUTHORIZED,e.getMessage());
  }
catch (  final OAuthProblemException oe) {
    error(resp,oe);
  }
catch (  final RuntimeException e) {
    error(resp,e);
  }
  return false;
}","@Override @SuppressWarnings(""String_Node_Str"") protected boolean executeLogin(final ServletRequest request,final ServletResponse response) throws Exception {
  final HttpServletRequest req;
  try {
    req=(HttpServletRequest)request;
  }
 catch (  final ClassCastException e) {
    LOG.debug(""String_Node_Str"",e);
    throw e;
  }
  final HttpServletResponse resp;
  try {
    resp=(HttpServletResponse)response;
  }
 catch (  final ClassCastException e) {
    LOG.debug(""String_Node_Str"",e);
    throw e;
  }
  try {
    if (req.getServletPath().equals(TOKEN_GRANT_ENDPOINT)) {
      final UsernamePasswordToken token=createToken(request,response);
      if (token == null) {
        final String msg=""String_Node_Str"" + ""String_Node_Str"";
        throw new IllegalStateException(msg);
      }
      try {
        final Subject subject=getSubject(request,response);
        subject.login(token);
        return onLoginSuccess(token,subject,request,response);
      }
 catch (      final AuthenticationException e) {
        return onLoginFailure(token,e,request,response);
      }
    }
  }
 catch (  final AuthenticationException e) {
    error(resp,SC_UNAUTHORIZED,e.getMessage());
  }
catch (  final OAuthProblemException oe) {
    error(resp,oe);
  }
catch (  final RuntimeException e) {
    error(resp,e);
  }
  return false;
}",0.9467707594038324
135677,"@Override protected boolean isLoginAttempt(String authzHeader){
  final String authzScheme=getAuthzScheme().toLowerCase();
  final String authzHeaderLowerCase=authzHeader.toLowerCase();
  return authzHeaderLowerCase.startsWith(authzScheme) || authzHeaderLowerCase.startsWith(BEARER_SCHEME);
}","@Override protected boolean isLoginAttempt(String authzHeader){
  final String authzScheme=getAuthzScheme().toLowerCase(Locale.ROOT);
  final String authzHeaderLowerCase=authzHeader.toLowerCase(Locale.ROOT);
  return authzHeaderLowerCase.startsWith(authzScheme) || authzHeaderLowerCase.startsWith(BEARER_SCHEME);
}",0.9636963696369636
135678,"/** 
 * Delete a grant.
 * @param info passed from Jersey
 * @param domainId the domain for the grant
 * @param userId the user for the grant
 * @param roleId the role for the grant
 * @return A response stating success or failure of the grant deletion.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteGrant(@Context UriInfo info,@PathParam(""String_Node_Str"") String domainId,@PathParam(""String_Node_Str"") String userId,@PathParam(""String_Node_Str"") String roleId){
  Domain domain=null;
  User user;
  Role role;
  try {
    domain=iidMStore.readDomain(domainId);
  }
 catch (  IDMStoreException e) {
    LOG.error(""String_Node_Str"",e);
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"");
    idmerror.setDetails(e.getMessage());
    return Response.status(500).entity(idmerror).build();
  }
  if (domain == null) {
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"" + domainId);
    return Response.status(404).entity(idmerror).build();
  }
  try {
    user=iidMStore.readUser(userId);
  }
 catch (  IDMStoreException e) {
    LOG.error(""String_Node_Str"",e);
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"");
    idmerror.setDetails(e.getMessage());
    return Response.status(500).entity(idmerror).build();
  }
  if (user == null) {
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"" + userId);
    return Response.status(404).entity(idmerror).build();
  }
  try {
    role=iidMStore.readRole(roleId);
  }
 catch (  IDMStoreException e) {
    LOG.error(""String_Node_Str"",e);
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"");
    idmerror.setDetails(e.getMessage());
    return Response.status(500).entity(idmerror).build();
  }
  if (role == null) {
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"" + roleId);
    return Response.status(404).entity(idmerror).build();
  }
  try {
    Grant existingGrant=iidMStore.readGrant(domainId,userId,roleId);
    if (existingGrant == null) {
      IDMError idmerror=new IDMError();
      idmerror.setMessage(""String_Node_Str"" + domainId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ roleId);
      return Response.status(404).entity(idmerror).build();
    }
    existingGrant=iidMStore.deleteGrant(existingGrant.getGrantid());
  }
 catch (  IDMStoreException e) {
    LOG.error(""String_Node_Str"",e);
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"");
    idmerror.setDetails(e.getMessage());
    return Response.status(500).entity(idmerror).build();
  }
  IdmLightProxy.clearClaimCache();
  return Response.status(204).build();
}","/** 
 * Delete a grant.
 * @param info passed from Jersey
 * @param domainId the domain for the grant
 * @param userId the user for the grant
 * @param roleId the role for the grant
 * @return A response stating success or failure of the grant deletion.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteGrant(@Context UriInfo info,@PathParam(""String_Node_Str"") String domainId,@PathParam(""String_Node_Str"") String userId,@PathParam(""String_Node_Str"") String roleId){
  Domain domain=null;
  User user;
  Role role;
  try {
    domain=iidMStore.readDomain(domainId);
  }
 catch (  IDMStoreException e) {
    LOG.error(""String_Node_Str"",e);
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"");
    idmerror.setDetails(e.getMessage());
    return Response.status(500).entity(idmerror).build();
  }
  if (domain == null) {
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"" + domainId);
    return Response.status(404).entity(idmerror).build();
  }
  try {
    user=iidMStore.readUser(userId);
  }
 catch (  IDMStoreException e) {
    LOG.error(""String_Node_Str"",e);
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"");
    idmerror.setDetails(e.getMessage());
    return Response.status(500).entity(idmerror).build();
  }
  if (user == null) {
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"" + userId);
    return Response.status(404).entity(idmerror).build();
  }
  try {
    role=iidMStore.readRole(roleId);
  }
 catch (  IDMStoreException e) {
    LOG.error(""String_Node_Str"",e);
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"");
    idmerror.setDetails(e.getMessage());
    return Response.status(500).entity(idmerror).build();
  }
  if (role == null) {
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"" + roleId);
    return Response.status(404).entity(idmerror).build();
  }
  try {
    Grant existingGrant=iidMStore.readGrant(domainId,userId,roleId);
    if (existingGrant == null) {
      IDMError idmerror=new IDMError();
      idmerror.setMessage(""String_Node_Str"" + domainId + ""String_Node_Str""+ userId+ ""String_Node_Str""+ roleId);
      return Response.status(404).entity(idmerror).build();
    }
    iidMStore.deleteGrant(existingGrant.getGrantid());
  }
 catch (  IDMStoreException e) {
    LOG.error(""String_Node_Str"",e);
    IDMError idmerror=new IDMError();
    idmerror.setMessage(""String_Node_Str"");
    idmerror.setDetails(e.getMessage());
    return Response.status(500).entity(idmerror).build();
  }
  IdmLightProxy.clearClaimCache();
  return Response.status(204).build();
}",0.9973997028231798
135679,"@Override public Claim authenticate(PasswordCredentials creds){
  Preconditions.checkNotNull(creds);
  Preconditions.checkNotNull(creds.username());
  Preconditions.checkNotNull(creds.password());
  String domain=creds.domain() == null ? IIDMStore.DEFAULT_DOMAIN : creds.domain();
  Map<PasswordCredentials,Claim> cache=claimCache.get(domain);
  if (cache == null) {
    cache=new ConcurrentHashMap<>();
    claimCache.put(domain,cache);
  }
  Claim claim=cache.get(creds);
  if (claim == null) {
synchronized (claimCache) {
      claim=cache.get(creds);
      if (claim == null) {
        claim=dbAuthenticate(creds);
        if (claim != null) {
          cache.put(creds,claim);
        }
      }
    }
  }
  return claim;
}","@Override public Claim authenticate(PasswordCredentials creds){
  Preconditions.checkNotNull(creds);
  Preconditions.checkNotNull(creds.username());
  Preconditions.checkNotNull(creds.password());
  String domain=creds.domain() == null ? IIDMStore.DEFAULT_DOMAIN : creds.domain();
  Map<PasswordCredentials,Claim> cache=claimCache.get(domain);
  if (cache == null) {
    cache=new ConcurrentHashMap<>();
    claimCache.put(domain,cache);
  }
  Claim claim=cache.get(creds);
  if (claim == null) {
synchronized (claimCache) {
      claim=cache.get(creds);
      if (claim == null) {
        claim=dbAuthenticate(creds);
        cache.put(creds,claim);
      }
    }
  }
  return claim;
}",0.951167728237792
135680,"private Claim dbAuthenticate(PasswordCredentials creds){
  Domain domain=null;
  User user=null;
  String credsDomain=creds.domain() == null ? IIDMStore.DEFAULT_DOMAIN : creds.domain();
  LOG.debug(""String_Node_Str"");
  try {
    domain=idmStore.readDomain(credsDomain);
    if (domain == null) {
      throw new AuthenticationException(""String_Node_Str"" + credsDomain + ""String_Node_Str"");
    }
  }
 catch (  IDMStoreException e) {
    throw new AuthenticationException(""String_Node_Str"",e);
  }
  try {
    LOG.debug(""String_Node_Str"");
    Users users=idmStore.getUsers(creds.username(),credsDomain);
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str""+ credsDomain);
    }
    user=userList.get(0);
    if (!SHA256Calculator.getSHA256(creds.password(),user.getSalt()).equals(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    if (!user.isEnabled()) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    LOG.debug(""String_Node_Str"");
    List<String> roles=new ArrayList<>();
    Grants grants=idmStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=idmStore.readRole(grant.getRoleid());
      if (role != null) {
        roles.add(role.getName());
      }
    }
    LOG.debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid().toString());
    claim.setUser(creds.username());
    claim.setDomain(credsDomain);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  IDMStoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
}","@Nonnull private Claim dbAuthenticate(PasswordCredentials creds){
  Domain domain=null;
  User user=null;
  String credsDomain=creds.domain() == null ? IIDMStore.DEFAULT_DOMAIN : creds.domain();
  LOG.debug(""String_Node_Str"");
  try {
    domain=idmStore.readDomain(credsDomain);
    if (domain == null) {
      throw new AuthenticationException(""String_Node_Str"" + credsDomain + ""String_Node_Str"");
    }
  }
 catch (  IDMStoreException e) {
    throw new AuthenticationException(""String_Node_Str"",e);
  }
  try {
    LOG.debug(""String_Node_Str"");
    Users users=idmStore.getUsers(creds.username(),credsDomain);
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str""+ credsDomain);
    }
    user=userList.get(0);
    if (!SHA256Calculator.getSHA256(creds.password(),user.getSalt()).equals(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    if (!user.isEnabled()) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    LOG.debug(""String_Node_Str"");
    List<String> roles=new ArrayList<>();
    Grants grants=idmStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=idmStore.readRole(grant.getRoleid());
      if (role != null) {
        roles.add(role.getName());
      }
    }
    LOG.debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid());
    claim.setUser(creds.username());
    claim.setDomain(credsDomain);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  IDMStoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
}",0.9947997919916796
135681,"/** 
 * REST endpoint to create a user. Name and domain are required attributes, and all other fields (description, email, password, enabled) are optional. Optional fields default in the following manner: <code>description</code>: An empty string (<code>""""</code>). <code>email</code>: An empty string (<code>""""</code>). <code>password</code>: <code>changeme</code> <code>enabled</code>: <code>true</code> <p> If a password is not provided, please ensure you change the default password ASAP for security reasons!
 * @param info passed from Jersey
 * @param user the user defined in the JSON payload
 * @return A response stating success or failure of user creation
 */
@POST @Consumes(""String_Node_Str"") @Produces(""String_Node_Str"") public Response createUser(@Context UriInfo info,User user){
  LOG.info(""String_Node_Str"");
  if (user.getUserid() != null) {
    final String errorMessage=""String_Node_Str"";
    LOG.debug(errorMessage);
    final IDMError idmError=new IDMError();
    idmError.setMessage(errorMessage);
    return Response.status(400).entity(idmError).build();
  }
  if (user.isEnabled() == null) {
    user.setEnabled(true);
  }
  final String userName=user.getName();
  if (userName == null) {
    return missingRequiredField(""String_Node_Str"");
  }
  if (userName.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  final String domainId=user.getDomainid();
  if (domainId == null) {
    return missingRequiredField(""String_Node_Str"");
  }
  if (domainId.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  final String userDescription=user.getDescription();
  if (userDescription == null) {
    user.setDescription(DEFAULT_DESCRIPTION);
  }
  if (userDescription.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  String userEmail=user.getEmail();
  if (userEmail == null) {
    user.setEmail(DEFAULT_EMAIL);
    userEmail=DEFAULT_EMAIL;
  }
  if (userEmail.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  final String userPassword=user.getPassword();
  if (userPassword == null) {
    user.setPassword(DEFAULT_PWD);
  }
 else   if (userPassword.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  try {
    final User createdUser=iidMStore.writeUser(user);
    user.setUserid(createdUser.getUserid());
  }
 catch (  IDMStoreException se) {
    return internalError(""String_Node_Str"",se);
  }
  redactUserPasswordInfo(user);
  return Response.status(201).entity(user).build();
}","/** 
 * REST endpoint to create a user. Name and domain are required attributes, and all other fields (description, email, password, enabled) are optional. Optional fields default in the following manner: <code>description</code>: An empty string (<code>""""</code>). <code>email</code>: An empty string (<code>""""</code>). <code>password</code>: <code>changeme</code> <code>enabled</code>: <code>true</code> <p> If a password is not provided, please ensure you change the default password ASAP for security reasons!
 * @param info passed from Jersey
 * @param user the user defined in the JSON payload
 * @return A response stating success or failure of user creation
 */
@POST @Consumes(""String_Node_Str"") @Produces(""String_Node_Str"") public Response createUser(@Context UriInfo info,User user){
  LOG.info(""String_Node_Str"");
  if (user.getUserid() != null) {
    final String errorMessage=""String_Node_Str"";
    LOG.debug(errorMessage);
    final IDMError idmError=new IDMError();
    idmError.setMessage(errorMessage);
    return Response.status(400).entity(idmError).build();
  }
  if (user.isEnabled() == null) {
    user.setEnabled(true);
  }
  final String userName=user.getName();
  if (userName == null) {
    return missingRequiredField(""String_Node_Str"");
  }
  if (userName.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  final String domainId=user.getDomainid();
  if (domainId == null) {
    return missingRequiredField(""String_Node_Str"");
  }
  if (domainId.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  String userDescription=user.getDescription();
  if (userDescription == null) {
    user.setDescription(DEFAULT_DESCRIPTION);
  }
 else   if (userDescription.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  final String userEmail=user.getEmail();
  if (userEmail == null) {
    user.setEmail(DEFAULT_EMAIL);
  }
 else   if (userEmail.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  final String userPassword=user.getPassword();
  if (userPassword == null) {
    user.setPassword(DEFAULT_PWD);
  }
 else   if (userPassword.length() > IdmLightApplication.MAX_FIELD_LEN) {
    return providedFieldTooLong(""String_Node_Str"",IdmLightApplication.MAX_FIELD_LEN);
  }
  try {
    final User createdUser=iidMStore.writeUser(user);
    user.setUserid(createdUser.getUserid());
  }
 catch (  IDMStoreException se) {
    return internalError(""String_Node_Str"",se);
  }
  redactUserPasswordInfo(user);
  return Response.status(201).entity(user).build();
}",0.8915917503966155
135682,"private Identity(String username,String password,String domain){
  this.methods=new String[]{METHOD_PASSWORD};
  this.password=new Password(username,password,domain);
}","private Identity(String username,String password,String domain){
  this.password=new Password(username,password,domain);
}",0.8413793103448276
135683,"public String[] getMethods(){
  return methods;
}","public String[] getMethods(){
  return new String[]{METHOD_PASSWORD};
}",0.7333333333333333
135684,"public static String getSHA256(String password,String salt){
  return getSHA256(password.getBytes(),salt);
}","public static String getSHA256(String password,String salt){
  return getSHA256(password.getBytes(StandardCharsets.UTF_8),salt);
}",0.907563025210084
135685,"private void createGrant(String domainID,String userID,String roleID) throws IDMStoreException {
  Grant grant=new Grant();
  grant.setDomainid(domainID);
  grant.setUserid(userID);
  grant.setRoleid(roleID);
  grant=store.writeGrant(grant);
  LOG.debug(""String_Node_Str"" + userID + ""String_Node_Str""+ roleID+ ""String_Node_Str""+ domainID+ ""String_Node_Str"");
}","private void createGrant(String domainID,String userID,String roleID) throws IDMStoreException {
  Grant grant=new Grant();
  grant.setDomainid(domainID);
  grant.setUserid(userID);
  grant.setRoleid(roleID);
  store.writeGrant(grant);
  LOG.debug(""String_Node_Str"" + userID + ""String_Node_Str""+ roleID+ ""String_Node_Str""+ domainID+ ""String_Node_Str"");
}",0.9915966386554622
135686,"/** 
 * Initialize IIDMStore with the default domain and the 'user' and 'admin' roles, if needed. This does not create any default user entries (because they are an inherent security risk).
 * @param domainID ID (same as name) of the ""authentication domain""
 * @return ID of the just newly created Domain, or null if no new one had to be created
 * @throws IDMStoreException for issues coming from the IIDMStore
 */
public String initDomainAndRolesWithoutUsers(String domainID) throws IDMStoreException {
  LOG.info(""String_Node_Str"");
  Domain defaultDomain=store.readDomain(domainID);
  if (defaultDomain != null) {
    LOG.info(""String_Node_Str"");
    return null;
  }
  Domain domain=new Domain();
  domain.setEnabled(true);
  domain.setName(IIDMStore.DEFAULT_DOMAIN);
  domain.setDescription(""String_Node_Str"");
  domain=store.writeDomain(domain);
  LOG.info(""String_Node_Str"");
  String newDomainID=domain.getDomainid();
  Role adminRole=new Role();
  adminRole.setName(""String_Node_Str"");
  adminRole.setDomainid(newDomainID);
  adminRole.setDescription(""String_Node_Str"");
  adminRole=store.writeRole(adminRole);
  LOG.info(""String_Node_Str"");
  Role userRole=new Role();
  userRole.setName(""String_Node_Str"");
  userRole.setDomainid(newDomainID);
  userRole.setDescription(""String_Node_Str"");
  userRole=store.writeRole(userRole);
  LOG.info(""String_Node_Str"");
  return newDomainID;
}","/** 
 * Initialize IIDMStore with the default domain and the 'user' and 'admin' roles, if needed. This does not create any default user entries (because they are an inherent security risk).
 * @param domainID ID (same as name) of the ""authentication domain""
 * @return ID of the just newly created Domain, or null if no new one had to be created
 * @throws IDMStoreException for issues coming from the IIDMStore
 */
public String initDomainAndRolesWithoutUsers(String domainID) throws IDMStoreException {
  LOG.info(""String_Node_Str"");
  Domain defaultDomain=store.readDomain(domainID);
  if (defaultDomain != null) {
    LOG.info(""String_Node_Str"");
    return null;
  }
  Domain domain=new Domain();
  domain.setEnabled(true);
  domain.setName(IIDMStore.DEFAULT_DOMAIN);
  domain.setDescription(""String_Node_Str"");
  domain=store.writeDomain(domain);
  LOG.info(""String_Node_Str"");
  String newDomainID=domain.getDomainid();
  Role adminRole=new Role();
  adminRole.setName(""String_Node_Str"");
  adminRole.setDomainid(newDomainID);
  adminRole.setDescription(""String_Node_Str"");
  store.writeRole(adminRole);
  LOG.info(""String_Node_Str"");
  Role userRole=new Role();
  userRole.setName(""String_Node_Str"");
  userRole.setDomainid(newDomainID);
  userRole.setDescription(""String_Node_Str"");
  store.writeRole(userRole);
  LOG.info(""String_Node_Str"");
  return newDomainID;
}",0.9931383170819792
135687,"@Override public int hashCode(){
  return this.name.hashCode();
}","@Override public int hashCode(){
  return name != null ? name.hashCode() : 0;
}",0.8333333333333334
135688,"@Override public boolean equals(Object obj){
  Domain other=(Domain)obj;
  if (other == null) {
    return false;
  }
  if (compareValues(getName(),other.getName()) && compareValues(getDomainid(),other.getDomainid()) && compareValues(getDescription(),other.getDescription())) {
    return true;
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null || getClass() != obj.getClass()) {
    return false;
  }
  Domain other=(Domain)obj;
  if (Objects.equals(getName(),other.getName()) && Objects.equals(getDomainid(),other.getDomainid()) && Objects.equals(getDescription(),other.getDescription())) {
    return true;
  }
  return false;
}",0.5855728429985856
135689,"@Override public boolean equals(Object obj){
  Grant other=(Grant)obj;
  if (other == null) {
    return false;
  }
  if (compareValues(getDomainid(),other.getDomainid()) && compareValues(getRoleid(),other.getRoleid()) && compareValues(getUserid(),other.getUserid())) {
    return true;
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null || getClass() != obj.getClass()) {
    return false;
  }
  Grant other=(Grant)obj;
  if (Objects.equals(getDomainid(),other.getDomainid()) && Objects.equals(getRoleid(),other.getRoleid()) && Objects.equals(getUserid(),other.getUserid())) {
    return true;
  }
  return false;
}",0.6570188133140377
135690,"@Override public int hashCode(){
  return this.name.hashCode();
}","@Override public int hashCode(){
  return name != null ? name.hashCode() : 0;
}",0.8333333333333334
135691,"@Override public boolean equals(Object obj){
  Role other=(Role)obj;
  if (other == null) {
    return false;
  }
  if (compareValues(getName(),other.getName()) && compareValues(getRoleid(),other.getRoleid()) && compareValues(getDescription(),other.getDescription())) {
    return true;
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null || getClass() != obj.getClass()) {
    return false;
  }
  Role other=(Role)obj;
  if (Objects.equals(getName(),other.getName()) && Objects.equals(getRoleid(),other.getRoleid()) && Objects.equals(getDescription(),other.getDescription())) {
    return true;
  }
  return false;
}",0.5875542691751086
135692,"@Override public int hashCode(){
  return this.name.hashCode();
}","@Override public int hashCode(){
  return name != null ? name.hashCode() : 0;
}",0.8333333333333334
135693,"public Boolean isEnabled(){
  return (enabled == USER_ACCOUNT_ENABLED);
}","public Boolean isEnabled(){
  return enabled == USER_ACCOUNT_ENABLED;
}",0.9861111111111112
135694,"@Override public boolean equals(Object obj){
  User other=(User)obj;
  if (other == null) {
    return false;
  }
  if (compareValues(getName(),other.getName()) && compareValues(getEmail(),other.getEmail()) && isEnabled().equals(other.isEnabled())&& compareValues(getPassword(),other.getPassword())&& compareValues(getSalt(),other.getSalt())&& compareValues(getUserid(),other.getUserid())&& compareValues(getDescription(),other.getDescription())) {
    return true;
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null || getClass() != obj.getClass()) {
    return false;
  }
  User other=(User)obj;
  if (Objects.equals(getName(),other.getName()) && Objects.equals(getEmail(),other.getEmail()) && isEnabled().equals(other.isEnabled())&& Objects.equals(getPassword(),other.getPassword())&& Objects.equals(getSalt(),other.getSalt())&& Objects.equals(getUserid(),other.getUserid())&& Objects.equals(getDescription(),other.getDescription())) {
    return true;
  }
  return false;
}",0.4448669201520912
135695,"public static SessionsManager getInstance(){
  if (sessionMgr == null) {
    sessionMgr=new SessionsManager();
  }
  return sessionMgr;
}","public static SessionsManager getInstance(){
  return sessionMgr;
}",0.6568627450980392
135696,"/** 
 * Retrieve the password from the user.
 * @param session command line session
 * @param pwdPrintStr label for enter password
 * @return the new written password
 * @throws Exception exception reading the password
 */
public static String readPassword(final CommandSession session,final String pwdPrintStr) throws Exception {
  session.getConsole().println(pwdPrintStr);
  final InputStreamReader iStreamReader=new InputStreamReader(session.getKeyboard());
  final BufferedReader bReader=new BufferedReader(iStreamReader);
  final String pwd=bReader.readLine();
  return pwd;
}","/** 
 * Retrieve the password from the user.
 * @param session command line session
 * @param pwdPrintStr label for enter password
 * @return the new written password
 * @throws Exception exception reading the password
 */
public static String readPassword(final CommandSession session,final String pwdPrintStr) throws Exception {
  session.getConsole().println(pwdPrintStr);
  try (BufferedReader bReader=new BufferedReader(new InputStreamReader(session.getKeyboard(),StandardCharsets.UTF_8))){
    return bReader.readLine();
  }
 }",0.8053811659192825
135697,"/** 
 * Get the ODL keystore certificate.
 * @param bundleName name of the bundle that will use the keystores
 * @param withTag  boolean to add cert tag to the return string
 * @return certificate as string
 */
String getODLStoreCertificate(@Nonnull String bundleName,boolean withTag);","/** 
 * Get the ODL keystore certificate.
 * @param bundleName name of the bundle that will use the keystores
 * @param withTag  boolean to add cert tag to the return string
 * @return certificate as string
 */
@Nullable String getODLStoreCertificate(@Nonnull String bundleName,boolean withTag);",0.9827586206896552
135698,"/** 
 * Get a Network node certificate from the Trust keystore.
 * @param bundleName name of the bundle that will use the keystores
 * @param alias of the certificate
 * @param withTag  boolean to add cert tag to the return string
 * @return certificate as string
 */
String getTrustStoreCertificate(@Nonnull String bundleName,@Nonnull String alias,boolean withTag);","/** 
 * Get a Network node certificate from the Trust keystore.
 * @param bundleName name of the bundle that will use the keystores
 * @param alias of the certificate
 * @param withTag  boolean to add cert tag to the return string
 * @return certificate as string
 */
@Nullable String getTrustStoreCertificate(@Nonnull String bundleName,@Nonnull String alias,boolean withTag);",0.9865229110512128
135699,"@Override public String[] getTlsProtocols(final String bundleName){
  final SslData sslData=keyStoresData.getSslData(dataBroker,bundleName);
  if (sslData != null) {
    String tlsProtocols=sslData.getTlsProtocols();
    if (tlsProtocols != null && !tlsProtocols.isEmpty()) {
      tlsProtocols=tlsProtocols.replace(""String_Node_Str"",""String_Node_Str"");
      if (tlsProtocols.contains(""String_Node_Str"")) {
        return tlsProtocols.split(""String_Node_Str"");
      }
 else {
        return new String[]{tlsProtocols};
      }
    }
  }
  return null;
}","@Override @SuppressFBWarnings(""String_Node_Str"") public String[] getTlsProtocols(final String bundleName){
  final SslData sslData=keyStoresData.getSslData(dataBroker,bundleName);
  if (sslData != null) {
    String tlsProtocols=sslData.getTlsProtocols();
    if (tlsProtocols != null && !tlsProtocols.isEmpty()) {
      tlsProtocols=tlsProtocols.replace(""String_Node_Str"",""String_Node_Str"");
      if (tlsProtocols.contains(""String_Node_Str"")) {
        return tlsProtocols.split(""String_Node_Str"");
      }
 else {
        return new String[]{tlsProtocols};
      }
    }
  }
  return null;
}",0.9660574412532638
135700,"@Override public String[] getCipherSuites(final String bundleName){
  final SslData sslData=keyStoresData.getSslData(dataBroker,bundleName);
  if (sslData != null && sslData.getCipherSuites() != null && !sslData.getCipherSuites().isEmpty()) {
    final List<String> suites=new ArrayList<>();
    sslData.getCipherSuites().stream().forEach(cs -> {
      if (!cs.getSuiteName().isEmpty()) {
        suites.add(cs.getSuiteName());
      }
    }
);
    return suites.toArray(new String[suites.size()]);
  }
  return null;
}","@Override @SuppressFBWarnings(""String_Node_Str"") public String[] getCipherSuites(final String bundleName){
  final SslData sslData=keyStoresData.getSslData(dataBroker,bundleName);
  if (sslData != null && sslData.getCipherSuites() != null && !sslData.getCipherSuites().isEmpty()) {
    final List<String> suites=new ArrayList<>();
    sslData.getCipherSuites().stream().forEach(cs -> {
      if (!cs.getSuiteName().isEmpty()) {
        suites.add(cs.getSuiteName());
      }
    }
);
    return suites.toArray(new String[suites.size()]);
  }
  return null;
}",0.9637883008356546
135701,"@Override public String[] getTlsProtocols(){
  String tlsProtocols=ctlKeyStore.getTlsProtocols();
  if (tlsProtocols != null && !tlsProtocols.isEmpty()) {
    tlsProtocols=tlsProtocols.replace(""String_Node_Str"",""String_Node_Str"");
    if (tlsProtocols.contains(""String_Node_Str"")) {
      return tlsProtocols.split(""String_Node_Str"");
    }
 else {
      return new String[]{tlsProtocols};
    }
  }
  return null;
}","@Override @SuppressFBWarnings(""String_Node_Str"") public String[] getTlsProtocols(){
  String tlsProtocols=ctlKeyStore.getTlsProtocols();
  if (tlsProtocols != null && !tlsProtocols.isEmpty()) {
    tlsProtocols=tlsProtocols.replace(""String_Node_Str"",""String_Node_Str"");
    if (tlsProtocols.contains(""String_Node_Str"")) {
      return tlsProtocols.split(""String_Node_Str"");
    }
 else {
      return new String[]{tlsProtocols};
    }
  }
  return null;
}",0.9552238805970148
135702,"@Override public String[] getCipherSuites(){
  final List<CipherSuites> cipherSuites=ctlKeyStore.getCipherSuites();
  if (cipherSuites != null && !cipherSuites.isEmpty()) {
    final List<String> suites=new ArrayList<>();
    cipherSuites.stream().forEach(cs -> {
      if (!cs.getSuiteName().isEmpty()) {
        suites.add(cs.getSuiteName());
      }
    }
);
    return suites.toArray(new String[suites.size()]);
  }
  return null;
}","@Override @SuppressFBWarnings(""String_Node_Str"") public String[] getCipherSuites(){
  final List<CipherSuites> cipherSuites=ctlKeyStore.getCipherSuites();
  if (cipherSuites != null && !cipherSuites.isEmpty()) {
    final List<String> suites=new ArrayList<>();
    cipherSuites.stream().forEach(cs -> {
      if (!cs.getSuiteName().isEmpty()) {
        suites.add(cs.getSuiteName());
      }
    }
);
    return suites.toArray(new String[suites.size()]);
  }
  return null;
}",0.9571899012074644
135703,"@Override public Future<RpcResult<GetODLCertificateReqOutput>> getODLCertificateReq(){
  final SettableFuture<RpcResult<GetODLCertificateReqOutput>> futureResult=SettableFuture.create();
  final String certReq=aaaCertProvider.genODLKeyStoreCertificateReq(false);
  if (certReq != null && !certReq.isEmpty()) {
    final GetODLCertificateReqOutput odlCertReqOutput=new GetODLCertificateReqOutputBuilder().setOdlCertReq(certReq).build();
    futureResult.set(RpcResultBuilder.<GetODLCertificateReqOutput>success(odlCertReqOutput).build());
  }
 else {
    futureResult.set(RpcResultBuilder.<GetODLCertificateReqOutput>failed().build());
  }
  return futureResult;
}","@Override public Future<RpcResult<GetODLCertificateReqOutput>> getODLCertificateReq(){
  final SettableFuture<RpcResult<GetODLCertificateReqOutput>> futureResult=SettableFuture.create();
  final String certReq=aaaCertProvider.genODLKeyStoreCertificateReq(false);
  if (!Strings.isNullOrEmpty(certReq)) {
    final GetODLCertificateReqOutput odlCertReqOutput=new GetODLCertificateReqOutputBuilder().setOdlCertReq(certReq).build();
    futureResult.set(RpcResultBuilder.<GetODLCertificateReqOutput>success(odlCertReqOutput).build());
  }
 else {
    futureResult.set(RpcResultBuilder.<GetODLCertificateReqOutput>failed().build());
  }
  return futureResult;
}",0.9606060606060606
135704,"@Override public Future<RpcResult<GetODLCertificateOutput>> getODLCertificate(){
  final SettableFuture<RpcResult<GetODLCertificateOutput>> futureResult=SettableFuture.create();
  final String cert=aaaCertProvider.getODLKeyStoreCertificate(false);
  if (cert != null && !cert.isEmpty()) {
    final GetODLCertificateOutput odlCertOutput=new GetODLCertificateOutputBuilder().setOdlCert(cert).build();
    futureResult.set(RpcResultBuilder.<GetODLCertificateOutput>success(odlCertOutput).build());
  }
 else {
    futureResult.set(RpcResultBuilder.<GetODLCertificateOutput>failed().build());
  }
  return futureResult;
}","@Override public Future<RpcResult<GetODLCertificateOutput>> getODLCertificate(){
  final SettableFuture<RpcResult<GetODLCertificateOutput>> futureResult=SettableFuture.create();
  final String cert=aaaCertProvider.getODLKeyStoreCertificate(false);
  if (!Strings.isNullOrEmpty(cert)) {
    final GetODLCertificateOutput odlCertOutput=new GetODLCertificateOutputBuilder().setOdlCert(cert).build();
    futureResult.set(RpcResultBuilder.<GetODLCertificateOutput>success(odlCertOutput).build());
  }
 else {
    futureResult.set(RpcResultBuilder.<GetODLCertificateOutput>failed().build());
  }
  return futureResult;
}",0.9667477696674776
135705,"@Override public Future<RpcResult<GetNodeCertifcateOutput>> getNodeCertifcate(GetNodeCertifcateInput input){
  final SettableFuture<RpcResult<GetNodeCertifcateOutput>> futureResult=SettableFuture.create();
  final String cert=aaaCertProvider.getCertificateTrustStore(input.getNodeAlias(),false);
  if (cert != null && !cert.isEmpty()) {
    final GetNodeCertifcateOutput nodeCertOutput=new GetNodeCertifcateOutputBuilder().setNodeCert(cert).build();
    futureResult.set(RpcResultBuilder.<GetNodeCertifcateOutput>success(nodeCertOutput).build());
  }
 else {
    futureResult.set(RpcResultBuilder.<GetNodeCertifcateOutput>failed().build());
  }
  return futureResult;
}","@Override public Future<RpcResult<GetNodeCertifcateOutput>> getNodeCertifcate(GetNodeCertifcateInput input){
  final SettableFuture<RpcResult<GetNodeCertifcateOutput>> futureResult=SettableFuture.create();
  final String cert=aaaCertProvider.getCertificateTrustStore(input.getNodeAlias(),false);
  if (!Strings.isNullOrEmpty(cert)) {
    final GetNodeCertifcateOutput nodeCertOutput=new GetNodeCertifcateOutputBuilder().setNodeCert(cert).build();
    futureResult.set(RpcResultBuilder.<GetNodeCertifcateOutput>success(nodeCertOutput).build());
  }
 else {
    futureResult.set(RpcResultBuilder.<GetNodeCertifcateOutput>failed().build());
  }
  return futureResult;
}",0.9677902621722848
135706,"public CertificateManagerService(AaaCertServiceConfig aaaCertServiceConfig,final DataBroker dataBroker,final AAAEncryptionService encryptionSrv){
  if (aaaCertServiceConfig == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + aaaCertServiceConfig.toString());
  }
  if (aaaCertServiceConfig.isUseConfig()) {
    if (aaaCertServiceConfig.getCtlKeystore() != null && aaaCertServiceConfig.getCtlKeystore().getStorePassword() != null && aaaCertServiceConfig.getCtlKeystore().getStorePassword().isEmpty()) {
      LOG.debug(""String_Node_Str"");
      final String ctlPwd=RandomStringUtils.random(PWD_LENGTH,true,true);
      final String trustPwd=RandomStringUtils.random(PWD_LENGTH,true,true);
      updateCertManagerSrvConfig(ctlPwd,trustPwd);
      final CtlKeystore ctlKeystore=new CtlKeystoreBuilder(aaaCertServiceConfig.getCtlKeystore()).setStorePassword(ctlPwd).build();
      final TrustKeystore trustKeystore=new TrustKeystoreBuilder(aaaCertServiceConfig.getTrustKeystore()).setStorePassword(trustPwd).build();
      aaaCertServiceConfig=new AaaCertServiceConfigBuilder(aaaCertServiceConfig).setCtlKeystore(ctlKeystore).setTrustKeystore(trustKeystore).build();
    }
    if (aaaCertServiceConfig.isUseMdsal()) {
      aaaCertProvider=new DefaultMdsalSslData(new AaaCertMdsalProvider(dataBroker,encryptionSrv),aaaCertServiceConfig.getBundleName(),aaaCertServiceConfig.getCtlKeystore(),aaaCertServiceConfig.getTrustKeystore());
      LOG.debug(""String_Node_Str"");
    }
 else {
      aaaCertProvider=new AaaCertProvider(aaaCertServiceConfig.getCtlKeystore(),aaaCertServiceConfig.getTrustKeystore());
      LOG.debug(""String_Node_Str"");
    }
    aaaCertProvider.createKeyStores();
    LOG.info(""String_Node_Str"");
  }
 else {
    aaaCertProvider=null;
    LOG.info(""String_Node_Str"" + ""String_Node_Str"");
  }
}","public CertificateManagerService(AaaCertServiceConfig aaaCertServiceConfig,final DataBroker dataBroker,final AAAEncryptionService encryptionSrv){
  if (aaaCertServiceConfig == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (aaaCertServiceConfig.isUseConfig()) {
    if (aaaCertServiceConfig.getCtlKeystore() != null && aaaCertServiceConfig.getCtlKeystore().getStorePassword() != null && aaaCertServiceConfig.getCtlKeystore().getStorePassword().isEmpty()) {
      LOG.debug(""String_Node_Str"");
      final String ctlPwd=RandomStringUtils.random(PWD_LENGTH,true,true);
      final String trustPwd=RandomStringUtils.random(PWD_LENGTH,true,true);
      updateCertManagerSrvConfig(ctlPwd,trustPwd);
      final CtlKeystore ctlKeystore=new CtlKeystoreBuilder(aaaCertServiceConfig.getCtlKeystore()).setStorePassword(ctlPwd).build();
      final TrustKeystore trustKeystore=new TrustKeystoreBuilder(aaaCertServiceConfig.getTrustKeystore()).setStorePassword(trustPwd).build();
      aaaCertServiceConfig=new AaaCertServiceConfigBuilder(aaaCertServiceConfig).setCtlKeystore(ctlKeystore).setTrustKeystore(trustKeystore).build();
    }
    if (aaaCertServiceConfig.isUseMdsal()) {
      aaaCertProvider=new DefaultMdsalSslData(new AaaCertMdsalProvider(dataBroker,encryptionSrv),aaaCertServiceConfig.getBundleName(),aaaCertServiceConfig.getCtlKeystore(),aaaCertServiceConfig.getTrustKeystore());
      LOG.debug(""String_Node_Str"");
    }
 else {
      aaaCertProvider=new AaaCertProvider(aaaCertServiceConfig.getCtlKeystore(),aaaCertServiceConfig.getTrustKeystore());
      LOG.debug(""String_Node_Str"");
    }
    aaaCertProvider.createKeyStores();
    LOG.info(""String_Node_Str"");
  }
 else {
    aaaCertProvider=null;
    LOG.info(""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.9906129210381004
135707,"@Override public String getODLKeyStoreCertificate(final boolean withTag){
  return aaaCertMdsalProv.getODLStoreCertificate(bundleName,withTag);
}","@Override public String getODLKeyStoreCertificate(final boolean withTag){
  return MoreObjects.firstNonNull(aaaCertMdsalProv.getODLStoreCertificate(bundleName,withTag),""String_Node_Str"");
}",0.8682634730538922
135708,"@Override public String getCertificateTrustStore(String alias,boolean withTag){
  return aaaCertMdsalProv.getTrustStoreCertificate(bundleName,alias,withTag);
}","@Override public String getCertificateTrustStore(String alias,boolean withTag){
  return MoreObjects.firstNonNull(aaaCertMdsalProv.getTrustStoreCertificate(bundleName,alias,withTag),""String_Node_Str"");
}",0.8784530386740331
135709,"private String[] getCipherSuites(final List<CipherSuites> cipherSuites){
  final List<String> suites=new ArrayList<>();
  if (cipherSuites != null & !cipherSuites.isEmpty()) {
    cipherSuites.stream().forEach(cs -> {
      suites.add(cs.getSuiteName());
    }
);
  }
  return suites.toArray(new String[suites.size()]);
}","private String[] getCipherSuites(final List<CipherSuites> cipherSuites){
  final List<String> suites=new ArrayList<>();
  if (cipherSuites != null && !cipherSuites.isEmpty()) {
    cipherSuites.stream().forEach(cs -> {
      suites.add(cs.getSuiteName());
    }
);
  }
  return suites.toArray(new String[suites.size()]);
}",0.9984447900466564
135710,"public static String readFile(final String certFile){
  if (certFile == null || certFile.isEmpty()) {
    return null;
  }
  try {
    final FileInputStream fInputStream=new FileInputStream(KEY_STORE_PATH + certFile);
    final byte[] certBytes=new byte[fInputStream.available()];
    fInputStream.read(certBytes);
    fInputStream.close();
    final String cert=new String(certBytes,StandardCharsets.UTF_8);
    return cert;
  }
 catch (  final IOException e) {
    return null;
  }
}","public static String readFile(final String certFile){
  if (certFile == null || certFile.isEmpty()) {
    return null;
  }
  final String path=KEY_STORE_PATH + certFile;
  try (FileInputStream fInputStream=new FileInputStream(path)){
    final int available=fInputStream.available();
    final byte[] certBytes=new byte[available];
    final int numRead=fInputStream.read(certBytes);
    if (numRead != available) {
      LOG.warn(""String_Node_Str"",available,path,numRead);
    }
    return new String(certBytes,StandardCharsets.UTF_8);
  }
 catch (  final IOException e) {
    return null;
  }
}",0.5883441258094357
135711,"public static String createDir(final String dir){
  final File file=new File(dir);
  if (!file.exists()) {
    file.mkdirs();
  }
  return file.getAbsolutePath();
}","public static String createDir(final String dir){
  final File file=new File(dir);
  if (!file.exists()) {
    if (!file.mkdirs()) {
      LOG.error(""String_Node_Str"",file);
    }
  }
  return file.getAbsolutePath();
}",0.8586387434554974
135712,"public static boolean saveCert(final String fileName,final String cert){
  if (fileName == null || fileName.isEmpty()) {
    return false;
  }
  BufferedWriter out;
  try {
    out=new BufferedWriter(new FileWriter(KEY_STORE_PATH + fileName));
    out.write(cert);
    out.close();
    return true;
  }
 catch (  final IOException e) {
    return false;
  }
}","public static boolean saveCert(final String fileName,final String cert){
  if (fileName == null || fileName.isEmpty()) {
    return false;
  }
  try (BufferedWriter out=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(KEY_STORE_PATH + fileName),StandardCharsets.UTF_8))){
    out.write(cert);
    return true;
  }
 catch (  final IOException e) {
    return false;
  }
}",0.8532974427994616
135713,"/** 
 * Load the keystore from the working directory.
 * @param keyStoreName keystore file name
 * @param keystorePassword keystore password
 * @return keystore object otherwise return null if it fails to load.
 */
public KeyStore loadKeyStore(final String keyStoreName,final String keystorePassword){
  try {
    final KeyStore keyStore=KeyStore.getInstance(""String_Node_Str"");
    final FileInputStream fInputStream=new FileInputStream(workingDir + keyStoreName);
    keyStore.load(fInputStream,keystorePassword.toCharArray());
    return keyStore;
  }
 catch (  NoSuchAlgorithmException|CertificateException|IOException|KeyStoreException e) {
    LOG.error(""String_Node_Str"",e.getMessage());
    return null;
  }
}","/** 
 * Load the keystore from the working directory.
 * @param keyStoreName keystore file name
 * @param keystorePassword keystore password
 * @return keystore object otherwise return null if it fails to load.
 */
public KeyStore loadKeyStore(final String keyStoreName,final String keystorePassword){
  try (FileInputStream fInputStream=new FileInputStream(workingDir + keyStoreName)){
    final KeyStore keyStore=KeyStore.getInstance(""String_Node_Str"");
    keyStore.load(fInputStream,keystorePassword.toCharArray());
    return keyStore;
  }
 catch (  NoSuchAlgorithmException|CertificateException|IOException|KeyStoreException e) {
    LOG.error(""String_Node_Str"",e.getMessage());
    return null;
  }
}",0.8848314606741573
135714,"public boolean deleteUser(String userIdWithoutDomain) throws IDMStoreException {
  Preconditions.checkNotNull(userIdWithoutDomain,""String_Node_Str"");
  String userID=IDMStoreUtil.createUserid(userIdWithoutDomain,DOMAIN);
  return identityStore.deleteUser(userID) != null;
}","public boolean deleteUser(String userIdWithoutDomain) throws IDMStoreException {
  Preconditions.checkNotNull(userIdWithoutDomain,""String_Node_Str"");
  return storeBuilder.deleteUser(DOMAIN,userIdWithoutDomain);
}",0.6790123456790124
135715,"@Test public void testCreateNewUserAndSetPasswordAndDelete() throws Exception {
  assertThat(cli.getAllUserNames()).hasSize(0);
  cli.createNewUser(""String_Node_Str"",""String_Node_Str"",false);
  assertThat(cli.getAllUserNames()).hasSize(1);
  assertThat(cli.getAllUserNames().get(0)).isEqualTo(""String_Node_Str"");
  assertThat(cli.resetPassword(""String_Node_Str"",""String_Node_Str"")).isTrue();
  assertThat(cli.deleteUser(""String_Node_Str"")).isTrue();
  assertThat(cli.getAllUserNames()).hasSize(0);
}","@Test public void testCreateNewUserAndSetPasswordAndDelete() throws Exception {
  assertThat(cli.getAllUserNames()).isEmpty();
  cli.createNewUser(""String_Node_Str"",""String_Node_Str"",false);
  assertThat(cli.getAllUserNames()).hasSize(1);
  assertThat(cli.getAllUserNames().get(0)).isEqualTo(""String_Node_Str"");
  assertThat(cli.resetPassword(""String_Node_Str"",""String_Node_Str"")).isTrue();
  assertThat(cli.deleteUser(""String_Node_Str"")).isTrue();
  assertThat(cli.getAllUserNames()).hasSize(0);
}",0.9829488465396188
135716,"public IdmLightApplication(){
  try {
    StoreBuilder.init();
  }
 catch (  IDMStoreException e) {
    logger.error(""String_Node_Str"",e);
  }
}","public IdmLightApplication(){
}",0.3542857142857142
135717,"public static void init() throws IDMStoreException {
  logger.info(""String_Node_Str"");
  int waitingTime=5;
  while (AAAIDMLightModule.getStore() == null) {
    try {
      Thread.sleep(5000);
    }
 catch (    Exception err) {
      logger.error(""String_Node_Str"",err);
    }
    logger.info(""String_Node_Str"" + waitingTime + ""String_Node_Str"");
    waitingTime+=5;
    if (waitingTime >= 30)     break;
  }
  if (AAAIDMLightModule.getStore() == null) {
    logger.info(""String_Node_Str"");
    return;
  }
 else {
    logger.info(""String_Node_Str"");
  }
  IIDMStore store=AAAIDMLightModule.getStore();
  Domain defaultDomain=store.readDomain(IIDMStore.DEFAULT_DOMAIN);
  if (defaultDomain != null) {
    logger.info(""String_Node_Str"");
    return;
  }
  Domain domain=new Domain();
  User adminUser=new User();
  User userUser=new User();
  Role adminRole=new Role();
  Role userRole=new Role();
  domain.setEnabled(true);
  domain.setName(IIDMStore.DEFAULT_DOMAIN);
  domain.setDescription(""String_Node_Str"");
  domain=store.writeDomain(domain);
  adminUser.setEnabled(true);
  adminUser.setName(""String_Node_Str"");
  adminUser.setDomainid(domain.getDomainid());
  adminUser.setDescription(""String_Node_Str"");
  adminUser.setEmail(""String_Node_Str"");
  adminUser.setPassword(""String_Node_Str"");
  adminUser=store.writeUser(adminUser);
  userUser.setEnabled(true);
  userUser.setName(""String_Node_Str"");
  userUser.setDomainid(domain.getDomainid());
  userUser.setDescription(""String_Node_Str"");
  userUser.setEmail(""String_Node_Str"");
  userUser.setPassword(""String_Node_Str"");
  userUser=store.writeUser(userUser);
  adminRole.setName(""String_Node_Str"");
  adminRole.setDomainid(domain.getDomainid());
  adminRole.setDescription(""String_Node_Str"");
  adminRole=store.writeRole(adminRole);
  userRole.setName(""String_Node_Str"");
  userRole.setDomainid(domain.getDomainid());
  userRole.setDescription(""String_Node_Str"");
  userRole=store.writeRole(userRole);
  Grant grant=new Grant();
  grant.setDomainid(domain.getDomainid());
  grant.setUserid(userUser.getUserid());
  grant.setRoleid(userRole.getRoleid());
  grant=store.writeGrant(grant);
  grant.setDomainid(domain.getDomainid());
  grant.setUserid(adminUser.getUserid());
  grant.setRoleid(userRole.getRoleid());
  grant=store.writeGrant(grant);
  grant.setDomainid(domain.getDomainid());
  grant.setUserid(adminUser.getUserid());
  grant.setRoleid(adminRole.getRoleid());
  grant=store.writeGrant(grant);
}","public static void init() throws IDMStoreException {
  logger.info(""String_Node_Str"");
  IIDMStore store=AAAIDMLightModule.getStore();
  Domain defaultDomain=store.readDomain(IIDMStore.DEFAULT_DOMAIN);
  if (defaultDomain != null) {
    logger.info(""String_Node_Str"");
    return;
  }
  Domain domain=new Domain();
  User adminUser=new User();
  User userUser=new User();
  Role adminRole=new Role();
  Role userRole=new Role();
  domain.setEnabled(true);
  domain.setName(IIDMStore.DEFAULT_DOMAIN);
  domain.setDescription(""String_Node_Str"");
  domain=store.writeDomain(domain);
  adminUser.setEnabled(true);
  adminUser.setName(""String_Node_Str"");
  adminUser.setDomainid(domain.getDomainid());
  adminUser.setDescription(""String_Node_Str"");
  adminUser.setEmail(""String_Node_Str"");
  adminUser.setPassword(""String_Node_Str"");
  adminUser=store.writeUser(adminUser);
  userUser.setEnabled(true);
  userUser.setName(""String_Node_Str"");
  userUser.setDomainid(domain.getDomainid());
  userUser.setDescription(""String_Node_Str"");
  userUser.setEmail(""String_Node_Str"");
  userUser.setPassword(""String_Node_Str"");
  userUser=store.writeUser(userUser);
  adminRole.setName(""String_Node_Str"");
  adminRole.setDomainid(domain.getDomainid());
  adminRole.setDescription(""String_Node_Str"");
  adminRole=store.writeRole(adminRole);
  userRole.setName(""String_Node_Str"");
  userRole.setDomainid(domain.getDomainid());
  userRole.setDescription(""String_Node_Str"");
  userRole=store.writeRole(userRole);
  Grant grant=new Grant();
  grant.setDomainid(domain.getDomainid());
  grant.setUserid(userUser.getUserid());
  grant.setRoleid(userRole.getRoleid());
  grant=store.writeGrant(grant);
  grant.setDomainid(domain.getDomainid());
  grant.setUserid(adminUser.getUserid());
  grant.setRoleid(userRole.getRoleid());
  grant=store.writeGrant(grant);
  grant.setDomainid(domain.getDomainid());
  grant.setUserid(adminUser.getUserid());
  grant.setRoleid(adminRole.getRoleid());
  grant=store.writeGrant(grant);
}",0.8951612903225806
135718,"@Override public java.lang.AutoCloseable createInstance(){
  final IdmLightProxy proxy=new IdmLightProxy();
  final ServiceRegistration<?> idmService=bundleContext.registerService(IdMService.class.getName(),proxy,null);
  final ServiceRegistration<?> clientAuthService=bundleContext.registerService(CredentialAuth.class.getName(),proxy,null);
  final StoreServiceLocator locator=new StoreServiceLocator();
  locator.start();
  LOGGER.info(""String_Node_Str"");
  return new AutoCloseable(){
    @Override public void close() throws Exception {
      idmService.unregister();
      clientAuthService.unregister();
    }
  }
;
}","@Override public java.lang.AutoCloseable createInstance(){
  final IdmLightProxy proxy=new IdmLightProxy();
  final ServiceRegistration<?> idmService=bundleContext.registerService(IdMService.class.getName(),proxy,null);
  final ServiceRegistration<?> clientAuthService=bundleContext.registerService(CredentialAuth.class.getName(),proxy,null);
  final StoreServiceLocator locator=new StoreServiceLocator();
  locator.setDaemon(true);
  locator.start();
  LOGGER.info(""String_Node_Str"");
  return new AutoCloseable(){
    @Override public void close() throws Exception {
      idmService.unregister();
      clientAuthService.unregister();
    }
  }
;
}",0.9788235294117648
135719,"public void run(){
  while (store == null) {
    retryCount++;
    LOGGER.info(""String_Node_Str"",retryCount);
    final ServiceReference<IIDMStore> serviceReference=bundleContext.getServiceReference(IIDMStore.class);
    if (serviceReference != null) {
      store=bundleContext.getService(serviceReference);
      LOGGER.info(""String_Node_Str"");
      break;
    }
    try {
      Thread.sleep(WAITING_TIME);
    }
 catch (    InterruptedException e) {
      LOGGER.error(""String_Node_Str"",e);
      break;
    }
    if (retryCount >= NUMBER_OF_RETRYS) {
      LOGGER.error(""String_Node_Str"");
      break;
    }
  }
}","public void run(){
  while (store == null) {
    retryCount++;
    LOGGER.info(""String_Node_Str"",retryCount);
    final ServiceReference<IIDMStore> serviceReference=bundleContext.getServiceReference(IIDMStore.class);
    if (serviceReference != null) {
      store=bundleContext.getService(serviceReference);
      LOGGER.info(""String_Node_Str"");
      try {
        StoreBuilder.init();
      }
 catch (      IDMStoreException e) {
        LOGGER.error(""String_Node_Str"",e);
      }
      break;
    }
    try {
      Thread.sleep(WAITING_TIME);
    }
 catch (    InterruptedException e) {
      LOGGER.error(""String_Node_Str"",e);
      break;
    }
    if (retryCount >= NUMBER_OF_RETRYS) {
      LOGGER.error(""String_Node_Str"");
      break;
    }
  }
}",0.9003636363636364
135720,"private static Claim dbAuthenticate(PasswordCredentials creds,String domainName){
  Domain domain=null;
  User user=null;
  debug(""String_Node_Str"");
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + domainName + ""String_Node_Str"");
    }
    domain=domainList.get(0);
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
  try {
    debug(""String_Node_Str"");
    Users users=userStore.getUsers(creds.username());
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str"");
    }
    user=userList.get(0);
    if (!creds.password().equalsIgnoreCase(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    debug(""String_Node_Str"");
    List<String> roles=new ArrayList<String>();
    Grants grants=grantStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid().toString());
    claim.setUser(creds.username());
    claim.setDomain(domainName);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
}","private static Claim dbAuthenticate(PasswordCredentials creds,String domainName){
  Domain domain=null;
  User user=null;
  debug(""String_Node_Str"");
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + domainName + ""String_Node_Str"");
    }
    domain=domainList.get(0);
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
  try {
    debug(""String_Node_Str"");
    Users users=userStore.getUsers(creds.username());
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str"");
    }
    user=userList.get(0);
    if (!SHA256Calculator.getSHA256(creds.password(),user.getSalt()).equals(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    debug(""String_Node_Str"");
    List<String> roles=new ArrayList<String>();
    Grants grants=grantStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid().toString());
    claim.setUser(creds.username());
    claim.setDomain(domainName);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
}",0.9852079263187272
135721,"public User putUser(User user) throws StoreException {
  User savedUser=this.getUser(user.getUserid());
  if (savedUser == null) {
    return null;
  }
  if (user.getDescription() != null) {
    savedUser.setDescription(user.getDescription());
  }
  if (user.getName() != null) {
    savedUser.setName(user.getName());
  }
  if (user.getEnabled() != null) {
    savedUser.setEnabled(user.getEnabled());
  }
  if (user.getEmail() != null) {
    savedUser.setEmail(user.getEmail());
  }
  if (user.getPassword() != null) {
    savedUser.setPassword(user.getPassword());
  }
  Connection conn=dbConnect();
  try {
    String query=""String_Node_Str"";
    PreparedStatement statement=conn.prepareStatement(query);
    statement.setString(1,savedUser.getName());
    statement.setString(2,savedUser.getEmail());
    statement.setString(3,savedUser.getPassword());
    statement.setString(4,savedUser.getDescription());
    statement.setInt(5,savedUser.getEnabled() ? 1 : 0);
    statement.setInt(6,savedUser.getUserid());
    statement.executeUpdate();
    statement.close();
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
 finally {
    dbClose();
  }
  return savedUser;
}","public User putUser(User user) throws StoreException {
  User savedUser=this.getUser(user.getUserid());
  if (savedUser == null) {
    return null;
  }
  if (user.getDescription() != null) {
    savedUser.setDescription(user.getDescription());
  }
  if (user.getName() != null) {
    savedUser.setName(user.getName());
  }
  if (user.getEnabled() != null) {
    savedUser.setEnabled(user.getEnabled());
  }
  if (user.getEmail() != null) {
    savedUser.setEmail(user.getEmail());
  }
  if (user.getPassword() != null) {
    savedUser.setPassword(SHA256Calculator.getSHA256(user.getPassword(),user.getSalt()));
  }
  Connection conn=dbConnect();
  try {
    String query=""String_Node_Str"";
    PreparedStatement statement=conn.prepareStatement(query);
    statement.setString(1,savedUser.getName());
    statement.setString(2,savedUser.getEmail());
    statement.setString(3,savedUser.getPassword());
    statement.setString(4,savedUser.getDescription());
    statement.setInt(5,savedUser.getEnabled() ? 1 : 0);
    statement.setInt(6,savedUser.getUserid());
    statement.executeUpdate();
    statement.close();
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
 finally {
    dbClose();
  }
  return savedUser;
}",0.98254161591555
135722,"protected Connection dbConnect() throws StoreException {
  Connection conn;
  try {
    conn=getDBConnect();
  }
 catch (  StoreException se) {
    throw se;
  }
  try {
    DatabaseMetaData dbm=conn.getMetaData();
    String[] tableTypes={""String_Node_Str""};
    ResultSet rs=dbm.getTables(null,null,""String_Node_Str"",tableTypes);
    if (rs.next()) {
      debug(""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"");
      Statement stmt=null;
      stmt=conn.createStatement();
      String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      stmt.executeUpdate(sql);
      stmt.close();
    }
  }
 catch (  SQLException sqe) {
    throw new StoreException(""String_Node_Str"" + sqe);
  }
  return conn;
}","protected Connection dbConnect() throws StoreException {
  Connection conn;
  try {
    conn=getDBConnect();
  }
 catch (  StoreException se) {
    throw se;
  }
  try {
    DatabaseMetaData dbm=conn.getMetaData();
    String[] tableTypes={""String_Node_Str""};
    ResultSet rs=dbm.getTables(null,null,""String_Node_Str"",tableTypes);
    if (rs.next()) {
      debug(""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"");
      Statement stmt=null;
      stmt=conn.createStatement();
      String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      stmt.executeUpdate(sql);
      stmt.close();
    }
  }
 catch (  SQLException sqe) {
    throw new StoreException(""String_Node_Str"" + sqe);
  }
  return conn;
}",0.9885057471264368
135723,"protected User rsToUser(ResultSet rs) throws SQLException {
  User user=new User();
  try {
    user.setUserid(rs.getInt(SQL_ID));
    user.setName(rs.getString(SQL_NAME));
    user.setEmail(rs.getString(SQL_EMAIL));
    user.setPassword(rs.getString(SQL_PASSWORD));
    user.setDescription(rs.getString(SQL_DESCR));
    user.setEnabled(rs.getInt(SQL_ENABLED) == 1 ? true : false);
  }
 catch (  SQLException sqle) {
    logger.error(""String_Node_Str"" + sqle);
    throw sqle;
  }
  return user;
}","protected User rsToUser(ResultSet rs) throws SQLException {
  User user=new User();
  try {
    user.setUserid(rs.getInt(SQL_ID));
    user.setName(rs.getString(SQL_NAME));
    user.setEmail(rs.getString(SQL_EMAIL));
    user.setPassword(rs.getString(SQL_PASSWORD));
    user.setDescription(rs.getString(SQL_DESCR));
    user.setEnabled(rs.getInt(SQL_ENABLED) == 1 ? true : false);
    user.setSalt(rs.getString(SQL_SALT));
  }
 catch (  SQLException sqle) {
    logger.error(""String_Node_Str"" + sqle);
    throw sqle;
  }
  return user;
}",0.9594594594594594
135724,"public User createUser(User user) throws StoreException {
  int key=0;
  Connection conn=dbConnect();
  try {
    String query=""String_Node_Str"";
    PreparedStatement statement=conn.prepareStatement(query,Statement.RETURN_GENERATED_KEYS);
    statement.setString(1,user.getName());
    statement.setString(2,user.getEmail());
    statement.setString(3,user.getPassword());
    statement.setString(4,user.getDescription());
    statement.setInt(5,user.getEnabled() ? 1 : 0);
    int affectedRows=statement.executeUpdate();
    if (affectedRows == 0) {
      throw new StoreException(""String_Node_Str"");
    }
    ResultSet generatedKeys=statement.getGeneratedKeys();
    if (generatedKeys.next()) {
      key=generatedKeys.getInt(1);
    }
 else {
      throw new StoreException(""String_Node_Str"");
    }
    user.setUserid(key);
    generatedKeys.close();
    statement.close();
    return user;
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
 finally {
    dbClose();
  }
}","public User createUser(User user) throws StoreException {
  int key=0;
  Connection conn=dbConnect();
  try {
    user.setSalt(SHA256Calculator.generateSALT());
    String query=""String_Node_Str"";
    PreparedStatement statement=conn.prepareStatement(query,Statement.RETURN_GENERATED_KEYS);
    statement.setString(1,user.getName());
    statement.setString(2,user.getEmail());
    statement.setString(3,SHA256Calculator.getSHA256(user.getPassword(),user.getSalt()));
    statement.setString(4,user.getDescription());
    statement.setInt(5,user.getEnabled() ? 1 : 0);
    statement.setString(6,user.getSalt());
    int affectedRows=statement.executeUpdate();
    if (affectedRows == 0) {
      throw new StoreException(""String_Node_Str"");
    }
    ResultSet generatedKeys=statement.getGeneratedKeys();
    if (generatedKeys.next()) {
      key=generatedKeys.getInt(1);
    }
 else {
      throw new StoreException(""String_Node_Str"");
    }
    user.setUserid(key);
    generatedKeys.close();
    statement.close();
    return user;
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
 finally {
    dbClose();
  }
}",0.936895439889452
135725,"@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public Response getUser(@PathParam(""String_Node_Str"") String id){
  logger.info(""String_Node_Str"" + id);
  User user=null;
  long longId=0;
  try {
    longId=Long.parseLong(id);
  }
 catch (  NumberFormatException nfe) {
    return new IDMError(400,""String_Node_Str"" + id,""String_Node_Str"").response();
  }
  try {
    user=userStore.getUser(longId);
  }
 catch (  StoreException se) {
    return new IDMError(500,""String_Node_Str"",se.message).response();
  }
  if (user == null) {
    return new IDMError(404,""String_Node_Str"" + id,""String_Node_Str"").response();
  }
  user.setPassword(REDACTED_PASSWORD);
  return Response.ok(user).build();
}","@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public Response getUser(@PathParam(""String_Node_Str"") String id){
  logger.info(""String_Node_Str"" + id);
  User user=null;
  long longId=0;
  try {
    longId=Long.parseLong(id);
  }
 catch (  NumberFormatException nfe) {
    return new IDMError(400,""String_Node_Str"" + id,""String_Node_Str"").response();
  }
  try {
    user=userStore.getUser(longId);
  }
 catch (  StoreException se) {
    return new IDMError(500,""String_Node_Str"",se.message).response();
  }
  if (user == null) {
    return new IDMError(404,""String_Node_Str"" + id,""String_Node_Str"").response();
  }
  user.setPassword(REDACTED_PASSWORD);
  user.setSalt(REDACTED_PASSWORD);
  return Response.ok(user).build();
}",0.966042966042966
135726,"private static Claim dbAuthenticate(PasswordCredentials creds,String domainName){
  Domain domain=null;
  User user=null;
  debug(""String_Node_Str"");
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + domainName + ""String_Node_Str"");
    }
    domain=domainList.get(0);
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
  try {
    debug(""String_Node_Str"");
    Users users=userStore.getUsers(creds.username());
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str"");
    }
    user=userList.get(0);
    if (!creds.password().equalsIgnoreCase(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    debug(""String_Node_Str"");
    List<String> roles=new ArrayList<String>();
    Grants grants=grantStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid().toString());
    claim.setUser(creds.username());
    claim.setDomain(domainName);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
}","private static Claim dbAuthenticate(PasswordCredentials creds,String domainName){
  Domain domain=null;
  User user=null;
  debug(""String_Node_Str"");
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + domainName + ""String_Node_Str"");
    }
    domain=domainList.get(0);
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
  try {
    debug(""String_Node_Str"");
    Users users=userStore.getUsers(creds.username());
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str"");
    }
    user=userList.get(0);
    if (!SHA256Calculator.getSHA256(creds.password(),user.getSalt()).equals(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    debug(""String_Node_Str"");
    List<String> roles=new ArrayList<String>();
    Grants grants=grantStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid().toString());
    claim.setUser(creds.username());
    claim.setDomain(domainName);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
}",0.9852079263187272
135727,"public User putUser(User user) throws StoreException {
  User savedUser=this.getUser(user.getUserid());
  if (savedUser == null) {
    return null;
  }
  if (user.getDescription() != null) {
    savedUser.setDescription(user.getDescription());
  }
  if (user.getName() != null) {
    savedUser.setName(user.getName());
  }
  if (user.getEnabled() != null) {
    savedUser.setEnabled(user.getEnabled());
  }
  if (user.getEmail() != null) {
    savedUser.setEmail(user.getEmail());
  }
  if (user.getPassword() != null) {
    savedUser.setPassword(user.getPassword());
  }
  Connection conn=dbConnect();
  try {
    String query=""String_Node_Str"";
    PreparedStatement statement=conn.prepareStatement(query);
    statement.setString(1,savedUser.getName());
    statement.setString(2,savedUser.getEmail());
    statement.setString(3,savedUser.getPassword());
    statement.setString(4,savedUser.getDescription());
    statement.setInt(5,savedUser.getEnabled() ? 1 : 0);
    statement.setInt(6,savedUser.getUserid());
    statement.executeUpdate();
    statement.close();
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
 finally {
    dbClose();
  }
  return savedUser;
}","public User putUser(User user) throws StoreException {
  User savedUser=this.getUser(user.getUserid());
  if (savedUser == null) {
    return null;
  }
  if (user.getDescription() != null) {
    savedUser.setDescription(user.getDescription());
  }
  if (user.getName() != null) {
    savedUser.setName(user.getName());
  }
  if (user.getEnabled() != null) {
    savedUser.setEnabled(user.getEnabled());
  }
  if (user.getEmail() != null) {
    savedUser.setEmail(user.getEmail());
  }
  if (user.getPassword() != null) {
    savedUser.setPassword(SHA256Calculator.getSHA256(user.getPassword(),user.getSalt()));
  }
  Connection conn=dbConnect();
  try {
    String query=""String_Node_Str"";
    PreparedStatement statement=conn.prepareStatement(query);
    statement.setString(1,savedUser.getName());
    statement.setString(2,savedUser.getEmail());
    statement.setString(3,savedUser.getPassword());
    statement.setString(4,savedUser.getDescription());
    statement.setInt(5,savedUser.getEnabled() ? 1 : 0);
    statement.setInt(6,savedUser.getUserid());
    statement.executeUpdate();
    statement.close();
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
 finally {
    dbClose();
  }
  return savedUser;
}",0.98254161591555
135728,"protected Connection dbConnect() throws StoreException {
  Connection conn;
  try {
    conn=getDBConnect();
  }
 catch (  StoreException se) {
    throw se;
  }
  try {
    DatabaseMetaData dbm=conn.getMetaData();
    String[] tableTypes={""String_Node_Str""};
    ResultSet rs=dbm.getTables(null,null,""String_Node_Str"",tableTypes);
    if (rs.next()) {
      debug(""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"");
      Statement stmt=null;
      stmt=conn.createStatement();
      String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      stmt.executeUpdate(sql);
      stmt.close();
    }
  }
 catch (  SQLException sqe) {
    throw new StoreException(""String_Node_Str"" + sqe);
  }
  return conn;
}","protected Connection dbConnect() throws StoreException {
  Connection conn;
  try {
    conn=getDBConnect();
  }
 catch (  StoreException se) {
    throw se;
  }
  try {
    DatabaseMetaData dbm=conn.getMetaData();
    String[] tableTypes={""String_Node_Str""};
    ResultSet rs=dbm.getTables(null,null,""String_Node_Str"",tableTypes);
    if (rs.next()) {
      debug(""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"");
      Statement stmt=null;
      stmt=conn.createStatement();
      String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      stmt.executeUpdate(sql);
      stmt.close();
    }
  }
 catch (  SQLException sqe) {
    throw new StoreException(""String_Node_Str"" + sqe);
  }
  return conn;
}",0.9885057471264368
135729,"protected User rsToUser(ResultSet rs) throws SQLException {
  User user=new User();
  try {
    user.setUserid(rs.getInt(SQL_ID));
    user.setName(rs.getString(SQL_NAME));
    user.setEmail(rs.getString(SQL_EMAIL));
    user.setPassword(rs.getString(SQL_PASSWORD));
    user.setDescription(rs.getString(SQL_DESCR));
    user.setEnabled(rs.getInt(SQL_ENABLED) == 1 ? true : false);
  }
 catch (  SQLException sqle) {
    logger.error(""String_Node_Str"" + sqle);
    throw sqle;
  }
  return user;
}","protected User rsToUser(ResultSet rs) throws SQLException {
  User user=new User();
  try {
    user.setUserid(rs.getInt(SQL_ID));
    user.setName(rs.getString(SQL_NAME));
    user.setEmail(rs.getString(SQL_EMAIL));
    user.setPassword(rs.getString(SQL_PASSWORD));
    user.setDescription(rs.getString(SQL_DESCR));
    user.setEnabled(rs.getInt(SQL_ENABLED) == 1 ? true : false);
    user.setSalt(rs.getString(SQL_SALT));
  }
 catch (  SQLException sqle) {
    logger.error(""String_Node_Str"" + sqle);
    throw sqle;
  }
  return user;
}",0.9594594594594594
135730,"public User createUser(User user) throws StoreException {
  int key=0;
  Connection conn=dbConnect();
  try {
    String query=""String_Node_Str"";
    PreparedStatement statement=conn.prepareStatement(query,Statement.RETURN_GENERATED_KEYS);
    statement.setString(1,user.getName());
    statement.setString(2,user.getEmail());
    statement.setString(3,user.getPassword());
    statement.setString(4,user.getDescription());
    statement.setInt(5,user.getEnabled() ? 1 : 0);
    int affectedRows=statement.executeUpdate();
    if (affectedRows == 0) {
      throw new StoreException(""String_Node_Str"");
    }
    ResultSet generatedKeys=statement.getGeneratedKeys();
    if (generatedKeys.next()) {
      key=generatedKeys.getInt(1);
    }
 else {
      throw new StoreException(""String_Node_Str"");
    }
    user.setUserid(key);
    generatedKeys.close();
    statement.close();
    return user;
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
 finally {
    dbClose();
  }
}","public User createUser(User user) throws StoreException {
  int key=0;
  Connection conn=dbConnect();
  try {
    user.setSalt(SHA256Calculator.generateSALT());
    String query=""String_Node_Str"";
    PreparedStatement statement=conn.prepareStatement(query,Statement.RETURN_GENERATED_KEYS);
    statement.setString(1,user.getName());
    statement.setString(2,user.getEmail());
    statement.setString(3,SHA256Calculator.getSHA256(user.getPassword(),user.getSalt()));
    statement.setString(4,user.getDescription());
    statement.setInt(5,user.getEnabled() ? 1 : 0);
    statement.setString(6,user.getSalt());
    int affectedRows=statement.executeUpdate();
    if (affectedRows == 0) {
      throw new StoreException(""String_Node_Str"");
    }
    ResultSet generatedKeys=statement.getGeneratedKeys();
    if (generatedKeys.next()) {
      key=generatedKeys.getInt(1);
    }
 else {
      throw new StoreException(""String_Node_Str"");
    }
    user.setUserid(key);
    generatedKeys.close();
    statement.close();
    return user;
  }
 catch (  SQLException s) {
    throw new StoreException(""String_Node_Str"" + s);
  }
 finally {
    dbClose();
  }
}",0.936895439889452
135731,"@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public Response getUser(@PathParam(""String_Node_Str"") String id){
  logger.info(""String_Node_Str"" + id);
  User user=null;
  long longId=0;
  try {
    longId=Long.parseLong(id);
  }
 catch (  NumberFormatException nfe) {
    return new IDMError(400,""String_Node_Str"" + id,""String_Node_Str"").response();
  }
  try {
    user=userStore.getUser(longId);
  }
 catch (  StoreException se) {
    return new IDMError(500,""String_Node_Str"",se.message).response();
  }
  if (user == null) {
    return new IDMError(404,""String_Node_Str"" + id,""String_Node_Str"").response();
  }
  user.setPassword(REDACTED_PASSWORD);
  return Response.ok(user).build();
}","@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public Response getUser(@PathParam(""String_Node_Str"") String id){
  logger.info(""String_Node_Str"" + id);
  User user=null;
  long longId=0;
  try {
    longId=Long.parseLong(id);
  }
 catch (  NumberFormatException nfe) {
    return new IDMError(400,""String_Node_Str"" + id,""String_Node_Str"").response();
  }
  try {
    user=userStore.getUser(longId);
  }
 catch (  StoreException se) {
    return new IDMError(500,""String_Node_Str"",se.message).response();
  }
  if (user == null) {
    return new IDMError(404,""String_Node_Str"" + id,""String_Node_Str"").response();
  }
  user.setPassword(REDACTED_PASSWORD);
  user.setSalt(REDACTED_PASSWORD);
  return Response.ok(user).build();
}",0.966042966042966
135732,"/** 
 * Decode from UTF-8, return Unicode. If we're unable to UTF-8 decode the string the fallback is to return the string unmodified and log a warning. Some data, especially metadata attached to a user principal may be internationalized (i18n). The classic examples are the user's name, location, organization, etc. We need to be able to read this metadata and decode it into unicode characters so that we properly handle i18n string values. One of the the prolems is we often don't know the encoding (i.e. charset) of the string. RFC-5987 is supposed to define how non-ASCII values are transmitted in HTTP headers, this is a follow on from the work in RFC-2231. However at the time of this writing these RFC's are not implemented in the Servlet Request classes. Not only are these RFC's unimplemented but they are specific to HTTP headers, much of our metadata arrives via attributes as opposed to being in a header. Note: ASCII encoding is a subset of UTF-8 encoding therefore any strings which are pure ASCII will decode from UTF-8 just fine. However on the other hand Latin-1 (ISO-8859-1) encoding is not compatible with UTF-8 for code points in the range 128-255 (i.e. beyond 7-bit ascii). ISO-8859-1 is the default encoding for HTTP and HTML 4, however the consensus is the use of ISO-8859-1 was a mistake and Unicode with UTF-8 encoding is now the norm. If a string value is transmitted encoded in ISO-8859-1 contaiing code points in the range 128-255 and we try to UTF-8 decode it it will either not be the correct decoded string or it will throw a decoding exception. Conventional practice at the moment is for the sending side to encode internationalized values in UTF-8 with the receving end decoding the value back from UTF-8. We do not expect the use of ISO-8859-1 on these attributes. However due to peculiarities of the Java String implementation we have to specify the raw bytes are encoded in ISO-8859-1 just to get back the raw bytes to be able to feed into the UTF-8 decoder. This doesn't seem right but it is because we need the full 8-bit byte and the only way to say ""unmodified 8-bit bytes"" in Java is to call it ISO-8859-1. Ugh!
 * @param string The input string in UTF-8 to be decoded.
 * @return Unicode string
 */
private String decodeUTF8(String string){
  if (string == null) {
    return null;
  }
  try {
    return new String(string.getBytes(""String_Node_Str""),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    logger.warn(""String_Node_Str"" + string);
    return string;
  }
}","/** 
 * Decode from UTF-8, return Unicode. If we're unable to UTF-8 decode the string the fallback is to return the string unmodified and log a warning. Some data, especially metadata attached to a user principal may be internationalized (i18n). The classic examples are the user's name, location, organization, etc. We need to be able to read this metadata and decode it into unicode characters so that we properly handle i18n string values. One of the the prolems is we often don't know the encoding (i.e. charset) of the string. RFC-5987 is supposed to define how non-ASCII values are transmitted in HTTP headers, this is a follow on from the work in RFC-2231. However at the time of this writing these RFC's are not implemented in the Servlet Request classes. Not only are these RFC's unimplemented but they are specific to HTTP headers, much of our metadata arrives via attributes as opposed to being in a header. Note: ASCII encoding is a subset of UTF-8 encoding therefore any strings which are pure ASCII will decode from UTF-8 just fine. However on the other hand Latin-1 (ISO-8859-1) encoding is not compatible with UTF-8 for code points in the range 128-255 (i.e. beyond 7-bit ascii). ISO-8859-1 is the default encoding for HTTP and HTML 4, however the consensus is the use of ISO-8859-1 was a mistake and Unicode with UTF-8 encoding is now the norm. If a string value is transmitted encoded in ISO-8859-1 contaiing code points in the range 128-255 and we try to UTF-8 decode it it will either not be the correct decoded string or it will throw a decoding exception. Conventional practice at the moment is for the sending side to encode internationalized values in UTF-8 with the receving end decoding the value back from UTF-8. We do not expect the use of ISO-8859-1 on these attributes. However due to peculiarities of the Java String implementation we have to specify the raw bytes are encoded in ISO-8859-1 just to get back the raw bytes to be able to feed into the UTF-8 decoder. This doesn't seem right but it is because we need the full 8-bit byte and the only way to say ""unmodified 8-bit bytes"" in Java is to call it ISO-8859-1. Ugh!
 * @param string The input string in UTF-8 to be decoded.
 * @return Unicode string
 */
private String decodeUTF8(String string){
  if (string == null) {
    return null;
  }
  try {
    return new String(string.getBytes(""String_Node_Str""),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    logger.warn(""String_Node_Str"",string,e);
    return string;
  }
}",0.9964440932437773
135733,"@Override public void updated(Dictionary<String,?> props) throws ConfigurationException {
  if (props == null) {
    configs.clear();
    configs.putAll(defaults);
  }
 else {
    try {
      Enumeration<String> keys=props.keys();
      while (keys.hasMoreElements()) {
        String key=keys.nextElement();
        configs.put(key,(String)props.get(key));
      }
    }
 catch (    Throwable t) {
      throw new ConfigurationException(null,FEDERATION_CONFIG_ERR);
    }
  }
}","@Override public void updated(Dictionary<String,?> props) throws ConfigurationException {
  if (props == null) {
    configs.clear();
    configs.putAll(defaults);
  }
 else {
    try {
      Enumeration<String> keys=props.keys();
      while (keys.hasMoreElements()) {
        String key=keys.nextElement();
        configs.put(key,(String)props.get(key));
      }
    }
 catch (    Throwable t) {
      throw new ConfigurationException(null,FEDERATION_CONFIG_ERR,t);
    }
  }
}",0.9686847599164928
135734,"/** 
 * Authenticate user. This implementation tracks IUserManager and delegates the decision to it. If the service is not available, IllegalStateException is thrown.
 */
@Override public synchronized boolean authenticated(final String username,final String password){
  if (nullableCredService == null) {
    logger.warn(""String_Node_Str"",username);
    throw new IllegalStateException(""String_Node_Str"");
  }
  Claim claim;
  try {
    claim=nullableCredService.authenticate(new PasswordCredentialsWrapper(username,password),DOMAIN);
  }
 catch (  AuthenticationException e) {
    logger.debug(""String_Node_Str"",username);
    return false;
  }
  logger.debug(""String_Node_Str"",username,claim.domain());
  return true;
}","/** 
 * Authenticate user. This implementation tracks IUserManager and delegates the decision to it. If the service is not available, IllegalStateException is thrown.
 */
@Override public synchronized boolean authenticated(final String username,final String password){
  if (nullableCredService == null) {
    logger.warn(""String_Node_Str"",username);
    throw new IllegalStateException(""String_Node_Str"");
  }
  Claim claim;
  try {
    claim=nullableCredService.authenticate(new PasswordCredentialsWrapper(username,password),DOMAIN);
  }
 catch (  AuthenticationException e) {
    logger.debug(""String_Node_Str"",username,e);
    return false;
  }
  logger.debug(""String_Node_Str"",username,claim.domain());
  return true;
}",0.9986168741355465
135735,"private void reconfig(@SuppressWarnings(""String_Node_Str"") Dictionary props) throws ConfigurationException {
  cacheLock.lock();
  try {
    long secsToIdle=Long.parseLong(props.get(SECS_TO_IDLE).toString());
    long secsToLive=Long.parseLong(props.get(SECS_TO_LIVE).toString());
    int maxMem=Integer.parseInt(props.get(MAX_CACHED_MEMORY).toString());
    int maxDisk=Integer.parseInt(props.get(MAX_CACHED_DISK).toString());
    CacheConfiguration config=tokens.getCacheConfiguration();
    config.setTimeToIdleSeconds(secsToIdle);
    config.setTimeToLiveSeconds(secsToLive);
    config.maxEntriesLocalHeap(maxMem);
    config.maxEntriesLocalDisk(maxDisk);
  }
 catch (  Throwable t) {
    throw new ConfigurationException(null,TOKEN_STORE_CONFIG_ERR);
  }
 finally {
    cacheLock.unlock();
  }
}","private void reconfig(@SuppressWarnings(""String_Node_Str"") Dictionary props) throws ConfigurationException {
  cacheLock.lock();
  try {
    long secsToIdle=Long.parseLong(props.get(SECS_TO_IDLE).toString());
    long secsToLive=Long.parseLong(props.get(SECS_TO_LIVE).toString());
    int maxMem=Integer.parseInt(props.get(MAX_CACHED_MEMORY).toString());
    int maxDisk=Integer.parseInt(props.get(MAX_CACHED_DISK).toString());
    CacheConfiguration config=tokens.getCacheConfiguration();
    config.setTimeToIdleSeconds(secsToIdle);
    config.setTimeToLiveSeconds(secsToLive);
    config.maxEntriesLocalHeap(maxMem);
    config.maxEntriesLocalDisk(maxDisk);
  }
 catch (  Throwable t) {
    throw new ConfigurationException(null,TOKEN_STORE_CONFIG_ERR,t);
  }
 finally {
    cacheLock.unlock();
  }
}",0.9987531172069826
135736,"@Override public List<String> listDomains(String userId){
  debug(""String_Node_Str"" + userId);
  List<String> domains=new ArrayList<String>();
  int uid=0;
  try {
    uid=Integer.parseInt(userId);
  }
 catch (  NumberFormatException nfe) {
    logger.warn(""String_Node_Str"" + userId);
    return domains;
  }
  try {
    Grants grants=grantStore.getGrants(uid);
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Domain domain=domainStore.getDomain(grant.getDomainid());
      domains.add(domain.getName());
    }
    return domains;
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"" + se.toString());
    return domains;
  }
}","@Override public List<String> listDomains(String userId){
  debug(""String_Node_Str"" + userId);
  List<String> domains=new ArrayList<String>();
  int uid=0;
  try {
    uid=Integer.parseInt(userId);
  }
 catch (  NumberFormatException nfe) {
    logger.warn(""String_Node_Str"",userId,nfe);
    return domains;
  }
  try {
    Grants grants=grantStore.getGrants(uid);
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Domain domain=domainStore.getDomain(grant.getDomainid());
      domains.add(domain.getName());
    }
    return domains;
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"",se.toString(),se);
    return domains;
  }
}",0.9720136518771332
135737,"@Override public String getUserId(String userName){
  debug(""String_Node_Str"" + userName);
  try {
    Users users=userStore.getUsers(userName);
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      return null;
    }
    User user=userList.get(0);
    return user.getUserid().toString();
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"" + se.toString());
    return null;
  }
}","@Override public String getUserId(String userName){
  debug(""String_Node_Str"" + userName);
  try {
    Users users=userStore.getUsers(userName);
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      return null;
    }
    User user=userList.get(0);
    return user.getUserid().toString();
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"",se.toString(),se);
    return null;
  }
}",0.96113074204947
135738,"private static Claim dbAuthenticate(PasswordCredentials creds,String domainName){
  Domain domain=null;
  User user=null;
  debug(""String_Node_Str"");
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + domainName + ""String_Node_Str"");
    }
    domain=domainList.get(0);
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString());
  }
  try {
    debug(""String_Node_Str"");
    Users users=userStore.getUsers(creds.username());
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str"");
    }
    user=userList.get(0);
    if (!creds.password().equalsIgnoreCase(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    debug(""String_Node_Str"");
    List<String> roles=new ArrayList<String>();
    Grants grants=grantStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid().toString());
    claim.setUser(creds.username());
    claim.setDomain(domainName);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString());
  }
}","private static Claim dbAuthenticate(PasswordCredentials creds,String domainName){
  Domain domain=null;
  User user=null;
  debug(""String_Node_Str"");
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + domainName + ""String_Node_Str"");
    }
    domain=domainList.get(0);
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
  try {
    debug(""String_Node_Str"");
    Users users=userStore.getUsers(creds.username());
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str"");
    }
    user=userList.get(0);
    if (!creds.password().equalsIgnoreCase(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    debug(""String_Node_Str"");
    List<String> roles=new ArrayList<String>();
    Grants grants=grantStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid().toString());
    claim.setUser(creds.username());
    claim.setDomain(domainName);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
}",0.9971751412429378
135739,"@Override public List<String> listRoles(String userId,String domainName){
  debug(""String_Node_Str"");
  List<String> roles=new ArrayList<String>();
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      debug(""String_Node_Str"" + domainName + ""String_Node_Str"");
      return roles;
    }
    int did=domainList.get(0).getDomainid();
    int uid=0;
    try {
      uid=Integer.parseInt(userId);
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"" + userId);
      return roles;
    }
    Grants grants=grantStore.getGrants(did,uid);
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    return roles;
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"" + se.toString());
    return roles;
  }
}","@Override public List<String> listRoles(String userId,String domainName){
  debug(""String_Node_Str"");
  List<String> roles=new ArrayList<String>();
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      debug(""String_Node_Str"" + domainName + ""String_Node_Str"");
      return roles;
    }
    int did=domainList.get(0).getDomainid();
    int uid=0;
    try {
      uid=Integer.parseInt(userId);
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"",userId,nfe);
      return roles;
    }
    Grants grants=grantStore.getGrants(did,uid);
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    return roles;
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"",se.toString(),se);
    return roles;
  }
}",0.9797730636408486
135740,"private ProcessResult verbUpper(String verb,Map<String,Object> namespace,List<Object> statement){
  Token variable=getVariable(verb,statement,1,namespace);
  Token parameter=getParameter(verb,statement,2,namespace,EnumSet.of(TokenType.STRING,TokenType.ARRAY,TokenType.MAP));
  try {
switch (parameter.type) {
case STRING:
{
        String oldValue=parameter.getStringValue();
        String newValue;
        newValue=oldValue.toUpperCase();
        variable.set(newValue);
      }
    break;
case ARRAY:
{
    List<Object> oldValue=parameter.getListValue();
    List<Object> newValue=new ArrayList<Object>(oldValue.size());
    String oldItem;
    String newItem;
    for (    Object item : oldValue) {
      try {
        oldItem=(String)item;
      }
 catch (      ClassCastException e) {
        throw new InvalidValueException(String.format(""String_Node_Str"",verb,item,parameter.getObjectValue()));
      }
      newItem=oldItem.toUpperCase();
      newValue.add(newItem);
    }
    variable.set(newValue);
  }
break;
case MAP:
{
Map<String,Object> oldValue=parameter.getMapValue();
Map<String,Object> newValue=new LinkedHashMap<String,Object>(oldValue.size());
for (Map.Entry<String,Object> entry : oldValue.entrySet()) {
  String oldKey;
  String newKey;
  Object value=entry.getValue();
  oldKey=entry.getKey();
  newKey=oldKey.toUpperCase();
  newValue.put(newKey,value);
}
variable.set(newValue);
}
break;
default :
throw new IllegalStateException(String.format(""String_Node_Str"",parameter.type));
}
}
 catch (Exception e) {
throw new InvalidValueException(String.format(""String_Node_Str"",verb,variable,parameter.getObjectValue(),e),e);
}
this.success=true;
if (logger.isDebugEnabled()) {
logger.debug(String.format(""String_Node_Str"",statementId(namespace),verb,this.success,variable,variable.get(),parameter.getObjectValue()));
}
return ProcessResult.STATEMENT_CONTINUE;
}","private ProcessResult verbUpper(String verb,Map<String,Object> namespace,List<Object> statement){
  Token variable=getVariable(verb,statement,1,namespace);
  Token parameter=getParameter(verb,statement,2,namespace,EnumSet.of(TokenType.STRING,TokenType.ARRAY,TokenType.MAP));
  try {
switch (parameter.type) {
case STRING:
{
        String oldValue=parameter.getStringValue();
        String newValue;
        newValue=oldValue.toUpperCase();
        variable.set(newValue);
      }
    break;
case ARRAY:
{
    List<Object> oldValue=parameter.getListValue();
    List<Object> newValue=new ArrayList<Object>(oldValue.size());
    String oldItem;
    String newItem;
    for (    Object item : oldValue) {
      try {
        oldItem=(String)item;
      }
 catch (      ClassCastException e) {
        throw new InvalidValueException(String.format(""String_Node_Str"",verb,item,parameter.getObjectValue(),e));
      }
      newItem=oldItem.toUpperCase();
      newValue.add(newItem);
    }
    variable.set(newValue);
  }
break;
case MAP:
{
Map<String,Object> oldValue=parameter.getMapValue();
Map<String,Object> newValue=new LinkedHashMap<String,Object>(oldValue.size());
for (Map.Entry<String,Object> entry : oldValue.entrySet()) {
  String oldKey;
  String newKey;
  Object value=entry.getValue();
  oldKey=entry.getKey();
  newKey=oldKey.toUpperCase();
  newValue.put(newKey,value);
}
variable.set(newValue);
}
break;
default :
throw new IllegalStateException(String.format(""String_Node_Str"",parameter.type));
}
}
 catch (Exception e) {
throw new InvalidValueException(String.format(""String_Node_Str"",verb,variable,parameter.getObjectValue(),e),e);
}
this.success=true;
if (logger.isDebugEnabled()) {
logger.debug(String.format(""String_Node_Str"",statementId(namespace),verb,this.success,variable,variable.get(),parameter.getObjectValue()));
}
return ProcessResult.STATEMENT_CONTINUE;
}",0.9994692144373672
135741,"private Object getRawParameter(String verb,List<Object> statement,int index,Set<TokenType> tokenTypes){
  Object item;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size()));
  }
  if (tokenTypes != null) {
    TokenType itemType=Token.classify(item);
    if (!tokenTypes.contains(itemType)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,statement));
    }
  }
  return item;
}","private Object getRawParameter(String verb,List<Object> statement,int index,Set<TokenType> tokenTypes){
  Object item;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size(),e));
  }
  if (tokenTypes != null) {
    TokenType itemType=Token.classify(item);
    if (!tokenTypes.contains(itemType)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,statement));
    }
  }
  return item;
}",0.9981981981981982
135742,"private Token getParameter(String verb,List<Object> statement,int index,Map<String,Object> namespace,Set<TokenType> tokenTypes){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size()));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  token.load();
  if (tokenTypes != null) {
    try {
      token.get();
    }
 catch (    UndefinedValueException e) {
    }
    if (!tokenTypes.contains(token.type)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,item.getClass().getSimpleName(),statement));
    }
  }
  return token;
}","private Token getParameter(String verb,List<Object> statement,int index,Map<String,Object> namespace,Set<TokenType> tokenTypes){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size(),e));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  token.load();
  if (tokenTypes != null) {
    try {
      token.get();
    }
 catch (    UndefinedValueException e) {
    }
    if (!tokenTypes.contains(token.type)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,item.getClass().getSimpleName(),statement));
    }
  }
  return token;
}",0.998812351543943
135743,"Map<String,Object> getMapping(Map<String,Object> namespace,Map<String,Object> rule){
  Map<String,Object> mapping=null;
  String mappingName=null;
  try {
    @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)rule.get(""String_Node_Str"");
    mapping=map;
  }
 catch (  java.lang.ClassCastException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  if (mapping != null) {
    return mapping;
  }
  try {
    mappingName=(String)rule.get(""String_Node_Str"");
  }
 catch (  java.lang.ClassCastException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  if (mappingName == null) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  mapping=this.mappings.get(mappingName);
  if (mapping == null) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  logger.debug(String.format(""String_Node_Str"",mappingName,this.ruleId(namespace),mapping));
  return mapping;
}","Map<String,Object> getMapping(Map<String,Object> namespace,Map<String,Object> rule){
  Map<String,Object> mapping=null;
  String mappingName=null;
  try {
    @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)rule.get(""String_Node_Str"");
    mapping=map;
  }
 catch (  java.lang.ClassCastException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace),e));
  }
  if (mapping != null) {
    return mapping;
  }
  try {
    mappingName=(String)rule.get(""String_Node_Str"");
  }
 catch (  java.lang.ClassCastException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace),e));
  }
  if (mappingName == null) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  mapping=this.mappings.get(mappingName);
  if (mapping == null) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  logger.debug(String.format(""String_Node_Str"",mappingName,this.ruleId(namespace),mapping));
  return mapping;
}",0.9981634527089072
135744,"private ProcessResult verbLower(String verb,Map<String,Object> namespace,List<Object> statement){
  Token variable=getVariable(verb,statement,1,namespace);
  Token parameter=getParameter(verb,statement,2,namespace,EnumSet.of(TokenType.STRING,TokenType.ARRAY,TokenType.MAP));
  try {
switch (parameter.type) {
case STRING:
{
        String oldValue=parameter.getStringValue();
        String newValue;
        newValue=oldValue.toLowerCase();
        variable.set(newValue);
      }
    break;
case ARRAY:
{
    List<Object> oldValue=parameter.getListValue();
    List<Object> newValue=new ArrayList<Object>(oldValue.size());
    String oldItem;
    String newItem;
    for (    Object item : oldValue) {
      try {
        oldItem=(String)item;
      }
 catch (      ClassCastException e) {
        throw new InvalidValueException(String.format(""String_Node_Str"",verb,item,parameter.getObjectValue()));
      }
      newItem=oldItem.toLowerCase();
      newValue.add(newItem);
    }
    variable.set(newValue);
  }
break;
case MAP:
{
Map<String,Object> oldValue=parameter.getMapValue();
Map<String,Object> newValue=new LinkedHashMap<String,Object>(oldValue.size());
for (Map.Entry<String,Object> entry : oldValue.entrySet()) {
  String oldKey;
  String newKey;
  Object value=entry.getValue();
  oldKey=entry.getKey();
  newKey=oldKey.toLowerCase();
  newValue.put(newKey,value);
}
variable.set(newValue);
}
break;
default :
throw new IllegalStateException(String.format(""String_Node_Str"",parameter.type));
}
}
 catch (Exception e) {
throw new InvalidValueException(String.format(""String_Node_Str"",verb,variable,parameter.getObjectValue(),e),e);
}
this.success=true;
if (logger.isDebugEnabled()) {
logger.debug(String.format(""String_Node_Str"",statementId(namespace),verb,this.success,variable,variable.get(),parameter.getObjectValue()));
}
return ProcessResult.STATEMENT_CONTINUE;
}","private ProcessResult verbLower(String verb,Map<String,Object> namespace,List<Object> statement){
  Token variable=getVariable(verb,statement,1,namespace);
  Token parameter=getParameter(verb,statement,2,namespace,EnumSet.of(TokenType.STRING,TokenType.ARRAY,TokenType.MAP));
  try {
switch (parameter.type) {
case STRING:
{
        String oldValue=parameter.getStringValue();
        String newValue;
        newValue=oldValue.toLowerCase();
        variable.set(newValue);
      }
    break;
case ARRAY:
{
    List<Object> oldValue=parameter.getListValue();
    List<Object> newValue=new ArrayList<Object>(oldValue.size());
    String oldItem;
    String newItem;
    for (    Object item : oldValue) {
      try {
        oldItem=(String)item;
      }
 catch (      ClassCastException e) {
        throw new InvalidValueException(String.format(""String_Node_Str"",verb,item,parameter.getObjectValue(),e));
      }
      newItem=oldItem.toLowerCase();
      newValue.add(newItem);
    }
    variable.set(newValue);
  }
break;
case MAP:
{
Map<String,Object> oldValue=parameter.getMapValue();
Map<String,Object> newValue=new LinkedHashMap<String,Object>(oldValue.size());
for (Map.Entry<String,Object> entry : oldValue.entrySet()) {
  String oldKey;
  String newKey;
  Object value=entry.getValue();
  oldKey=entry.getKey();
  newKey=oldKey.toLowerCase();
  newValue.put(newKey,value);
}
variable.set(newValue);
}
break;
default :
throw new IllegalStateException(String.format(""String_Node_Str"",parameter.type));
}
}
 catch (Exception e) {
throw new InvalidValueException(String.format(""String_Node_Str"",verb,variable,parameter.getObjectValue(),e),e);
}
this.success=true;
if (logger.isDebugEnabled()) {
logger.debug(String.format(""String_Node_Str"",statementId(namespace),verb,this.success,variable,variable.get(),parameter.getObjectValue()));
}
return ProcessResult.STATEMENT_CONTINUE;
}",0.9994692144373672
135745,"private Token getVariable(String verb,List<Object> statement,int index,Map<String,Object> namespace){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size()));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  if (token.storageType != TokenStorageType.VARIABLE) {
    throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,token.storageType,statement));
  }
  return token;
}","private Token getVariable(String verb,List<Object> statement,int index,Map<String,Object> namespace){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size(),e));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  if (token.storageType != TokenStorageType.VARIABLE) {
    throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,token.storageType,statement));
  }
  return token;
}",0.998502994011976
135746,"private Token getToken(String verb,List<Object> statement,int index,Map<String,Object> namespace,Set<TokenStorageType> storageTypes,Set<TokenType> tokenTypes){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size()));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  if (storageTypes != null) {
    if (!storageTypes.contains(token.storageType)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,storageTypes,statement));
    }
  }
  if (tokenTypes != null) {
    token.load();
    if (!tokenTypes.contains(token.type)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,statement));
    }
  }
  return token;
}","private Token getToken(String verb,List<Object> statement,int index,Map<String,Object> namespace,Set<TokenStorageType> storageTypes,Set<TokenType> tokenTypes){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size(),e));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  if (storageTypes != null) {
    if (!storageTypes.contains(token.storageType)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,storageTypes,statement));
    }
  }
  if (tokenTypes != null) {
    token.load();
    if (!tokenTypes.contains(token.type)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,statement));
    }
  }
  return token;
}",0.9989583333333332
135747,"void set(Object value,Object index){
  if (this.storageType == TokenStorageType.CONSTANT) {
    throw new InvalidTypeException(""String_Node_Str"");
  }
  if (index == null) {
    index=this.index;
  }
  if (index == null) {
    this.namespace.put(this.name,value);
  }
 else {
    Object base=null;
    if (this.namespace.containsKey(this.name)) {
      base=this.namespace.get(this.name);
    }
 else {
      throw new UndefinedValueException(String.format(""String_Node_Str"",this.name));
    }
    if (base instanceof List) {
      @SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)base;
      Integer idx=null;
      if (index instanceof Long) {
        idx=new Integer(((Long)index).intValue());
      }
 else       if (index instanceof String) {
        try {
          idx=new Integer((String)index);
        }
 catch (        NumberFormatException e) {
          throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index));
        }
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      try {
        value=list.set(idx,value);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,list.size(),idx));
      }
    }
 else     if (base instanceof Map) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)base;
      String idx=null;
      if (index instanceof String) {
        idx=(String)index;
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      if (!map.containsKey(idx)) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,index));
      }
      value=map.put(idx,value);
    }
 else {
      throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,base.getClass().getSimpleName()));
    }
  }
}","void set(Object value,Object index){
  if (this.storageType == TokenStorageType.CONSTANT) {
    throw new InvalidTypeException(""String_Node_Str"");
  }
  if (index == null) {
    index=this.index;
  }
  if (index == null) {
    this.namespace.put(this.name,value);
  }
 else {
    Object base=null;
    if (this.namespace.containsKey(this.name)) {
      base=this.namespace.get(this.name);
    }
 else {
      throw new UndefinedValueException(String.format(""String_Node_Str"",this.name));
    }
    if (base instanceof List) {
      @SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)base;
      Integer idx=null;
      if (index instanceof Long) {
        idx=new Integer(((Long)index).intValue());
      }
 else       if (index instanceof String) {
        try {
          idx=new Integer((String)index);
        }
 catch (        NumberFormatException e) {
          throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,e));
        }
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      try {
        value=list.set(idx,value);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,list.size(),idx,e));
      }
    }
 else     if (base instanceof Map) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)base;
      String idx=null;
      if (index instanceof String) {
        idx=(String)index;
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      if (!map.containsKey(idx)) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,index));
      }
      value=map.put(idx,value);
    }
 else {
      throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,base.getClass().getSimpleName()));
    }
  }
}",0.9990103908955964
135748,"Object get(Object index){
  Object base=null;
  if (this.storageType == TokenStorageType.CONSTANT) {
    return this.value;
  }
  if (this.namespace.containsKey(this.name)) {
    base=this.namespace.get(this.name);
  }
 else {
    throw new UndefinedValueException(String.format(""String_Node_Str"",this.name));
  }
  if (index == null) {
    index=this.index;
  }
  if (index == null) {
    value=base;
  }
 else {
    if (base instanceof List) {
      @SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)base;
      Integer idx=null;
      if (index instanceof Long) {
        idx=new Integer(((Long)index).intValue());
      }
 else       if (index instanceof String) {
        try {
          idx=new Integer((String)index);
        }
 catch (        NumberFormatException e) {
          throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index));
        }
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      try {
        value=list.get(idx);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,list.size(),idx));
      }
    }
 else     if (base instanceof Map) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)base;
      String idx=null;
      if (index instanceof String) {
        idx=(String)index;
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      if (!map.containsKey(idx)) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,index));
      }
      value=map.get(idx);
    }
 else {
      throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,base.getClass().getSimpleName()));
    }
  }
  this.type=classify(value);
  return value;
}","Object get(Object index){
  Object base=null;
  if (this.storageType == TokenStorageType.CONSTANT) {
    return this.value;
  }
  if (this.namespace.containsKey(this.name)) {
    base=this.namespace.get(this.name);
  }
 else {
    throw new UndefinedValueException(String.format(""String_Node_Str"",this.name));
  }
  if (index == null) {
    index=this.index;
  }
  if (index == null) {
    value=base;
  }
 else {
    if (base instanceof List) {
      @SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)base;
      Integer idx=null;
      if (index instanceof Long) {
        idx=new Integer(((Long)index).intValue());
      }
 else       if (index instanceof String) {
        try {
          idx=new Integer((String)index);
        }
 catch (        NumberFormatException e) {
          throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,e));
        }
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      try {
        value=list.get(idx);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,list.size(),idx,e));
      }
    }
 else     if (base instanceof Map) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)base;
      String idx=null;
      if (index instanceof String) {
        idx=(String)index;
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      if (!map.containsKey(idx)) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,index));
      }
      value=map.get(idx);
    }
 else {
      throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,base.getClass().getSimpleName()));
    }
  }
  this.type=classify(value);
  return value;
}",0.9989868287740628
135749,"/** 
 * Decode from UTF-8, return Unicode. If we're unable to UTF-8 decode the string the fallback is to return the string unmodified and log a warning. Some data, especially metadata attached to a user principal may be internationalized (i18n). The classic examples are the user's name, location, organization, etc. We need to be able to read this metadata and decode it into unicode characters so that we properly handle i18n string values. One of the the prolems is we often don't know the encoding (i.e. charset) of the string. RFC-5987 is supposed to define how non-ASCII values are transmitted in HTTP headers, this is a follow on from the work in RFC-2231. However at the time of this writing these RFC's are not implemented in the Servlet Request classes. Not only are these RFC's unimplemented but they are specific to HTTP headers, much of our metadata arrives via attributes as opposed to being in a header. Note: ASCII encoding is a subset of UTF-8 encoding therefore any strings which are pure ASCII will decode from UTF-8 just fine. However on the other hand Latin-1 (ISO-8859-1) encoding is not compatible with UTF-8 for code points in the range 128-255 (i.e. beyond 7-bit ascii). ISO-8859-1 is the default encoding for HTTP and HTML 4, however the consensus is the use of ISO-8859-1 was a mistake and Unicode with UTF-8 encoding is now the norm. If a string value is transmitted encoded in ISO-8859-1 contaiing code points in the range 128-255 and we try to UTF-8 decode it it will either not be the correct decoded string or it will throw a decoding exception. Conventional practice at the moment is for the sending side to encode internationalized values in UTF-8 with the receving end decoding the value back from UTF-8. We do not expect the use of ISO-8859-1 on these attributes. However due to peculiarities of the Java String implementation we have to specify the raw bytes are encoded in ISO-8859-1 just to get back the raw bytes to be able to feed into the UTF-8 decoder. This doesn't seem right but it is because we need the full 8-bit byte and the only way to say ""unmodified 8-bit bytes"" in Java is to call it ISO-8859-1. Ugh!
 * @param string The input string in UTF-8 to be decoded.
 * @return Unicode string
 */
private String decodeUTF8(String string){
  if (string == null) {
    return null;
  }
  try {
    return new String(string.getBytes(""String_Node_Str""),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    logger.warn(""String_Node_Str"" + string);
    return string;
  }
}","/** 
 * Decode from UTF-8, return Unicode. If we're unable to UTF-8 decode the string the fallback is to return the string unmodified and log a warning. Some data, especially metadata attached to a user principal may be internationalized (i18n). The classic examples are the user's name, location, organization, etc. We need to be able to read this metadata and decode it into unicode characters so that we properly handle i18n string values. One of the the prolems is we often don't know the encoding (i.e. charset) of the string. RFC-5987 is supposed to define how non-ASCII values are transmitted in HTTP headers, this is a follow on from the work in RFC-2231. However at the time of this writing these RFC's are not implemented in the Servlet Request classes. Not only are these RFC's unimplemented but they are specific to HTTP headers, much of our metadata arrives via attributes as opposed to being in a header. Note: ASCII encoding is a subset of UTF-8 encoding therefore any strings which are pure ASCII will decode from UTF-8 just fine. However on the other hand Latin-1 (ISO-8859-1) encoding is not compatible with UTF-8 for code points in the range 128-255 (i.e. beyond 7-bit ascii). ISO-8859-1 is the default encoding for HTTP and HTML 4, however the consensus is the use of ISO-8859-1 was a mistake and Unicode with UTF-8 encoding is now the norm. If a string value is transmitted encoded in ISO-8859-1 contaiing code points in the range 128-255 and we try to UTF-8 decode it it will either not be the correct decoded string or it will throw a decoding exception. Conventional practice at the moment is for the sending side to encode internationalized values in UTF-8 with the receving end decoding the value back from UTF-8. We do not expect the use of ISO-8859-1 on these attributes. However due to peculiarities of the Java String implementation we have to specify the raw bytes are encoded in ISO-8859-1 just to get back the raw bytes to be able to feed into the UTF-8 decoder. This doesn't seem right but it is because we need the full 8-bit byte and the only way to say ""unmodified 8-bit bytes"" in Java is to call it ISO-8859-1. Ugh!
 * @param string The input string in UTF-8 to be decoded.
 * @return Unicode string
 */
private String decodeUTF8(String string){
  if (string == null) {
    return null;
  }
  try {
    return new String(string.getBytes(""String_Node_Str""),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    logger.warn(""String_Node_Str"",string,e);
    return string;
  }
}",0.9964440932437773
135750,"@Override public void updated(Dictionary<String,?> props) throws ConfigurationException {
  if (props == null) {
    configs.clear();
    configs.putAll(defaults);
  }
 else {
    try {
      Enumeration<String> keys=props.keys();
      while (keys.hasMoreElements()) {
        String key=keys.nextElement();
        configs.put(key,(String)props.get(key));
      }
    }
 catch (    Throwable t) {
      throw new ConfigurationException(null,FEDERATION_CONFIG_ERR);
    }
  }
}","@Override public void updated(Dictionary<String,?> props) throws ConfigurationException {
  if (props == null) {
    configs.clear();
    configs.putAll(defaults);
  }
 else {
    try {
      Enumeration<String> keys=props.keys();
      while (keys.hasMoreElements()) {
        String key=keys.nextElement();
        configs.put(key,(String)props.get(key));
      }
    }
 catch (    Throwable t) {
      throw new ConfigurationException(null,FEDERATION_CONFIG_ERR,t);
    }
  }
}",0.9686847599164928
135751,"/** 
 * Authenticate user. This implementation tracks IUserManager and delegates the decision to it. If the service is not available, IllegalStateException is thrown.
 */
@Override public synchronized boolean authenticated(final String username,final String password){
  if (nullableCredService == null) {
    logger.warn(""String_Node_Str"",username);
    throw new IllegalStateException(""String_Node_Str"");
  }
  Claim claim;
  try {
    claim=nullableCredService.authenticate(new PasswordCredentialsWrapper(username,password),DOMAIN);
  }
 catch (  AuthenticationException e) {
    logger.debug(""String_Node_Str"",username);
    return false;
  }
  logger.debug(""String_Node_Str"",username,claim.domain());
  return true;
}","/** 
 * Authenticate user. This implementation tracks IUserManager and delegates the decision to it. If the service is not available, IllegalStateException is thrown.
 */
@Override public synchronized boolean authenticated(final String username,final String password){
  if (nullableCredService == null) {
    logger.warn(""String_Node_Str"",username);
    throw new IllegalStateException(""String_Node_Str"");
  }
  Claim claim;
  try {
    claim=nullableCredService.authenticate(new PasswordCredentialsWrapper(username,password),DOMAIN);
  }
 catch (  AuthenticationException e) {
    logger.debug(""String_Node_Str"",username,e);
    return false;
  }
  logger.debug(""String_Node_Str"",username,claim.domain());
  return true;
}",0.9986168741355465
135752,"private void reconfig(@SuppressWarnings(""String_Node_Str"") Dictionary props) throws ConfigurationException {
  cacheLock.lock();
  try {
    long secsToIdle=Long.parseLong(props.get(SECS_TO_IDLE).toString());
    long secsToLive=Long.parseLong(props.get(SECS_TO_LIVE).toString());
    int maxMem=Integer.parseInt(props.get(MAX_CACHED_MEMORY).toString());
    int maxDisk=Integer.parseInt(props.get(MAX_CACHED_DISK).toString());
    CacheConfiguration config=tokens.getCacheConfiguration();
    config.setTimeToIdleSeconds(secsToIdle);
    config.setTimeToLiveSeconds(secsToLive);
    config.maxEntriesLocalHeap(maxMem);
    config.maxEntriesLocalDisk(maxDisk);
  }
 catch (  Throwable t) {
    throw new ConfigurationException(null,TOKEN_STORE_CONFIG_ERR);
  }
 finally {
    cacheLock.unlock();
  }
}","private void reconfig(@SuppressWarnings(""String_Node_Str"") Dictionary props) throws ConfigurationException {
  cacheLock.lock();
  try {
    long secsToIdle=Long.parseLong(props.get(SECS_TO_IDLE).toString());
    long secsToLive=Long.parseLong(props.get(SECS_TO_LIVE).toString());
    int maxMem=Integer.parseInt(props.get(MAX_CACHED_MEMORY).toString());
    int maxDisk=Integer.parseInt(props.get(MAX_CACHED_DISK).toString());
    CacheConfiguration config=tokens.getCacheConfiguration();
    config.setTimeToIdleSeconds(secsToIdle);
    config.setTimeToLiveSeconds(secsToLive);
    config.maxEntriesLocalHeap(maxMem);
    config.maxEntriesLocalDisk(maxDisk);
  }
 catch (  Throwable t) {
    throw new ConfigurationException(null,TOKEN_STORE_CONFIG_ERR,t);
  }
 finally {
    cacheLock.unlock();
  }
}",0.9987531172069826
135753,"@Override public List<String> listDomains(String userId){
  debug(""String_Node_Str"" + userId);
  List<String> domains=new ArrayList<String>();
  long uid=0;
  try {
    uid=Long.parseLong(userId);
  }
 catch (  NumberFormatException nfe) {
    logger.warn(""String_Node_Str"" + userId);
    return domains;
  }
  try {
    Grants grants=grantStore.getGrants(uid);
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Domain domain=domainStore.getDomain(grant.getDomainid());
      domains.add(domain.getName());
    }
    return domains;
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"" + se.toString());
    return domains;
  }
}","@Override public List<String> listDomains(String userId){
  debug(""String_Node_Str"" + userId);
  List<String> domains=new ArrayList<String>();
  long uid=0;
  try {
    uid=Long.parseLong(userId);
  }
 catch (  NumberFormatException nfe) {
    logger.warn(""String_Node_Str"",userId,nfe);
    return domains;
  }
  try {
    Grants grants=grantStore.getGrants(uid);
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Domain domain=domainStore.getDomain(grant.getDomainid());
      domains.add(domain.getName());
    }
    return domains;
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"",se.toString(),se);
    return domains;
  }
}",0.9719753930280246
135754,"@Override public String getUserId(String userName){
  debug(""String_Node_Str"" + userName);
  try {
    Users users=userStore.getUsers(userName);
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      return null;
    }
    User user=userList.get(0);
    return user.getUserid().toString();
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"" + se.toString());
    return null;
  }
}","@Override public String getUserId(String userName){
  debug(""String_Node_Str"" + userName);
  try {
    Users users=userStore.getUsers(userName);
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      return null;
    }
    User user=userList.get(0);
    return user.getUserid().toString();
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"",se.toString(),se);
    return null;
  }
}",0.96113074204947
135755,"private static Claim dbAuthenticate(PasswordCredentials creds,String domainName){
  Domain domain=null;
  User user=null;
  debug(""String_Node_Str"");
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + domainName + ""String_Node_Str"");
    }
    domain=domainList.get(0);
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString());
  }
  try {
    debug(""String_Node_Str"");
    Users users=userStore.getUsers(creds.username());
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str"");
    }
    user=userList.get(0);
    if (!creds.password().equalsIgnoreCase(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    debug(""String_Node_Str"");
    List<String> roles=new ArrayList<String>();
    Grants grants=grantStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid().toString());
    claim.setUser(creds.username());
    claim.setDomain(domainName);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString());
  }
}","private static Claim dbAuthenticate(PasswordCredentials creds,String domainName){
  Domain domain=null;
  User user=null;
  debug(""String_Node_Str"");
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + domainName + ""String_Node_Str"");
    }
    domain=domainList.get(0);
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
  try {
    debug(""String_Node_Str"");
    Users users=userStore.getUsers(creds.username());
    List<User> userList=users.getUsers();
    if (userList.size() == 0) {
      throw new AuthenticationException(""String_Node_Str"" + creds.username() + ""String_Node_Str"");
    }
    user=userList.get(0);
    if (!creds.password().equalsIgnoreCase(user.getPassword())) {
      throw new AuthenticationException(""String_Node_Str"");
    }
    debug(""String_Node_Str"");
    List<String> roles=new ArrayList<String>();
    Grants grants=grantStore.getGrants(domain.getDomainid(),user.getUserid());
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    debug(""String_Node_Str"");
    ClaimBuilder claim=new ClaimBuilder();
    claim.setUserId(user.getUserid().toString());
    claim.setUser(creds.username());
    claim.setDomain(domainName);
    for (int z=0; z < roles.size(); z++) {
      claim.addRole(roles.get(z));
    }
    return claim.build();
  }
 catch (  StoreException se) {
    throw new AuthenticationException(""String_Node_Str"" + se.toString() + se);
  }
}",0.9971751412429378
135756,"@Override public List<String> listRoles(String userId,String domainName){
  debug(""String_Node_Str"");
  List<String> roles=new ArrayList<String>();
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      debug(""String_Node_Str"" + domainName + ""String_Node_Str"");
      return roles;
    }
    long did=domainList.get(0).getDomainid();
    long uid=0;
    try {
      uid=Long.parseLong(userId);
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"" + userId);
      return roles;
    }
    Grants grants=grantStore.getGrants(did,uid);
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    return roles;
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"" + se.toString());
    return roles;
  }
}","@Override public List<String> listRoles(String userId,String domainName){
  debug(""String_Node_Str"");
  List<String> roles=new ArrayList<String>();
  try {
    Domains domains=domainStore.getDomains(domainName);
    List<Domain> domainList=domains.getDomains();
    if (domainList.size() == 0) {
      debug(""String_Node_Str"" + domainName + ""String_Node_Str"");
      return roles;
    }
    long did=domainList.get(0).getDomainid();
    long uid=0;
    try {
      uid=Long.parseLong(userId);
    }
 catch (    NumberFormatException nfe) {
      logger.warn(""String_Node_Str"",userId,nfe);
      return roles;
    }
    Grants grants=grantStore.getGrants(did,uid);
    List<Grant> grantList=grants.getGrants();
    for (int z=0; z < grantList.size(); z++) {
      Grant grant=grantList.get(z);
      Role role=roleStore.getRole(grant.getRoleid());
      roles.add(role.getName());
    }
    return roles;
  }
 catch (  StoreException se) {
    logger.warn(""String_Node_Str"",se.toString(),se);
    return roles;
  }
}",0.9797730636408486
135757,"private ProcessResult verbUpper(String verb,Map<String,Object> namespace,List<Object> statement){
  Token variable=getVariable(verb,statement,1,namespace);
  Token parameter=getParameter(verb,statement,2,namespace,EnumSet.of(TokenType.STRING,TokenType.ARRAY,TokenType.MAP));
  try {
switch (parameter.type) {
case STRING:
{
        String oldValue=parameter.getStringValue();
        String newValue;
        newValue=oldValue.toUpperCase();
        variable.set(newValue);
      }
    break;
case ARRAY:
{
    List<Object> oldValue=parameter.getListValue();
    List<Object> newValue=new ArrayList<Object>(oldValue.size());
    String oldItem;
    String newItem;
    for (    Object item : oldValue) {
      try {
        oldItem=(String)item;
      }
 catch (      ClassCastException e) {
        throw new InvalidValueException(String.format(""String_Node_Str"",verb,item,parameter.getObjectValue()));
      }
      newItem=oldItem.toUpperCase();
      newValue.add(newItem);
    }
    variable.set(newValue);
  }
break;
case MAP:
{
Map<String,Object> oldValue=parameter.getMapValue();
Map<String,Object> newValue=new LinkedHashMap<String,Object>(oldValue.size());
for (Map.Entry<String,Object> entry : oldValue.entrySet()) {
  String oldKey;
  String newKey;
  Object value=entry.getValue();
  oldKey=entry.getKey();
  newKey=oldKey.toUpperCase();
  newValue.put(newKey,value);
}
variable.set(newValue);
}
break;
default :
throw new IllegalStateException(String.format(""String_Node_Str"",parameter.type));
}
}
 catch (Exception e) {
throw new InvalidValueException(String.format(""String_Node_Str"",verb,variable,parameter.getObjectValue(),e),e);
}
this.success=true;
if (logger.isDebugEnabled()) {
logger.debug(String.format(""String_Node_Str"",statementId(namespace),verb,this.success,variable,variable.get(),parameter.getObjectValue()));
}
return ProcessResult.STATEMENT_CONTINUE;
}","private ProcessResult verbUpper(String verb,Map<String,Object> namespace,List<Object> statement){
  Token variable=getVariable(verb,statement,1,namespace);
  Token parameter=getParameter(verb,statement,2,namespace,EnumSet.of(TokenType.STRING,TokenType.ARRAY,TokenType.MAP));
  try {
switch (parameter.type) {
case STRING:
{
        String oldValue=parameter.getStringValue();
        String newValue;
        newValue=oldValue.toUpperCase();
        variable.set(newValue);
      }
    break;
case ARRAY:
{
    List<Object> oldValue=parameter.getListValue();
    List<Object> newValue=new ArrayList<Object>(oldValue.size());
    String oldItem;
    String newItem;
    for (    Object item : oldValue) {
      try {
        oldItem=(String)item;
      }
 catch (      ClassCastException e) {
        throw new InvalidValueException(String.format(""String_Node_Str"",verb,item,parameter.getObjectValue(),e));
      }
      newItem=oldItem.toUpperCase();
      newValue.add(newItem);
    }
    variable.set(newValue);
  }
break;
case MAP:
{
Map<String,Object> oldValue=parameter.getMapValue();
Map<String,Object> newValue=new LinkedHashMap<String,Object>(oldValue.size());
for (Map.Entry<String,Object> entry : oldValue.entrySet()) {
  String oldKey;
  String newKey;
  Object value=entry.getValue();
  oldKey=entry.getKey();
  newKey=oldKey.toUpperCase();
  newValue.put(newKey,value);
}
variable.set(newValue);
}
break;
default :
throw new IllegalStateException(String.format(""String_Node_Str"",parameter.type));
}
}
 catch (Exception e) {
throw new InvalidValueException(String.format(""String_Node_Str"",verb,variable,parameter.getObjectValue(),e),e);
}
this.success=true;
if (logger.isDebugEnabled()) {
logger.debug(String.format(""String_Node_Str"",statementId(namespace),verb,this.success,variable,variable.get(),parameter.getObjectValue()));
}
return ProcessResult.STATEMENT_CONTINUE;
}",0.9994692144373672
135758,"private Object getRawParameter(String verb,List<Object> statement,int index,Set<TokenType> tokenTypes){
  Object item;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size()));
  }
  if (tokenTypes != null) {
    TokenType itemType=Token.classify(item);
    if (!tokenTypes.contains(itemType)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,statement));
    }
  }
  return item;
}","private Object getRawParameter(String verb,List<Object> statement,int index,Set<TokenType> tokenTypes){
  Object item;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size(),e));
  }
  if (tokenTypes != null) {
    TokenType itemType=Token.classify(item);
    if (!tokenTypes.contains(itemType)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,statement));
    }
  }
  return item;
}",0.9981981981981982
135759,"private Token getParameter(String verb,List<Object> statement,int index,Map<String,Object> namespace,Set<TokenType> tokenTypes){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size()));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  token.load();
  if (tokenTypes != null) {
    try {
      token.get();
    }
 catch (    UndefinedValueException e) {
    }
    if (!tokenTypes.contains(token.type)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,item.getClass().getSimpleName(),statement));
    }
  }
  return token;
}","private Token getParameter(String verb,List<Object> statement,int index,Map<String,Object> namespace,Set<TokenType> tokenTypes){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size(),e));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  token.load();
  if (tokenTypes != null) {
    try {
      token.get();
    }
 catch (    UndefinedValueException e) {
    }
    if (!tokenTypes.contains(token.type)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,item.getClass().getSimpleName(),statement));
    }
  }
  return token;
}",0.998812351543943
135760,"Map<String,Object> getMapping(Map<String,Object> namespace,Map<String,Object> rule){
  Map<String,Object> mapping=null;
  String mappingName=null;
  try {
    @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)rule.get(""String_Node_Str"");
    mapping=map;
  }
 catch (  java.lang.ClassCastException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  if (mapping != null) {
    return mapping;
  }
  try {
    mappingName=(String)rule.get(""String_Node_Str"");
  }
 catch (  java.lang.ClassCastException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  if (mappingName == null) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  mapping=this.mappings.get(mappingName);
  if (mapping == null) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  logger.debug(String.format(""String_Node_Str"",mappingName,this.ruleId(namespace),mapping));
  return mapping;
}","Map<String,Object> getMapping(Map<String,Object> namespace,Map<String,Object> rule){
  Map<String,Object> mapping=null;
  String mappingName=null;
  try {
    @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)rule.get(""String_Node_Str"");
    mapping=map;
  }
 catch (  java.lang.ClassCastException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace),e));
  }
  if (mapping != null) {
    return mapping;
  }
  try {
    mappingName=(String)rule.get(""String_Node_Str"");
  }
 catch (  java.lang.ClassCastException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace),e));
  }
  if (mappingName == null) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  mapping=this.mappings.get(mappingName);
  if (mapping == null) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",this.ruleId(namespace)));
  }
  logger.debug(String.format(""String_Node_Str"",mappingName,this.ruleId(namespace),mapping));
  return mapping;
}",0.9981634527089072
135761,"private ProcessResult verbLower(String verb,Map<String,Object> namespace,List<Object> statement){
  Token variable=getVariable(verb,statement,1,namespace);
  Token parameter=getParameter(verb,statement,2,namespace,EnumSet.of(TokenType.STRING,TokenType.ARRAY,TokenType.MAP));
  try {
switch (parameter.type) {
case STRING:
{
        String oldValue=parameter.getStringValue();
        String newValue;
        newValue=oldValue.toLowerCase();
        variable.set(newValue);
      }
    break;
case ARRAY:
{
    List<Object> oldValue=parameter.getListValue();
    List<Object> newValue=new ArrayList<Object>(oldValue.size());
    String oldItem;
    String newItem;
    for (    Object item : oldValue) {
      try {
        oldItem=(String)item;
      }
 catch (      ClassCastException e) {
        throw new InvalidValueException(String.format(""String_Node_Str"",verb,item,parameter.getObjectValue()));
      }
      newItem=oldItem.toLowerCase();
      newValue.add(newItem);
    }
    variable.set(newValue);
  }
break;
case MAP:
{
Map<String,Object> oldValue=parameter.getMapValue();
Map<String,Object> newValue=new LinkedHashMap<String,Object>(oldValue.size());
for (Map.Entry<String,Object> entry : oldValue.entrySet()) {
  String oldKey;
  String newKey;
  Object value=entry.getValue();
  oldKey=entry.getKey();
  newKey=oldKey.toLowerCase();
  newValue.put(newKey,value);
}
variable.set(newValue);
}
break;
default :
throw new IllegalStateException(String.format(""String_Node_Str"",parameter.type));
}
}
 catch (Exception e) {
throw new InvalidValueException(String.format(""String_Node_Str"",verb,variable,parameter.getObjectValue(),e),e);
}
this.success=true;
if (logger.isDebugEnabled()) {
logger.debug(String.format(""String_Node_Str"",statementId(namespace),verb,this.success,variable,variable.get(),parameter.getObjectValue()));
}
return ProcessResult.STATEMENT_CONTINUE;
}","private ProcessResult verbLower(String verb,Map<String,Object> namespace,List<Object> statement){
  Token variable=getVariable(verb,statement,1,namespace);
  Token parameter=getParameter(verb,statement,2,namespace,EnumSet.of(TokenType.STRING,TokenType.ARRAY,TokenType.MAP));
  try {
switch (parameter.type) {
case STRING:
{
        String oldValue=parameter.getStringValue();
        String newValue;
        newValue=oldValue.toLowerCase();
        variable.set(newValue);
      }
    break;
case ARRAY:
{
    List<Object> oldValue=parameter.getListValue();
    List<Object> newValue=new ArrayList<Object>(oldValue.size());
    String oldItem;
    String newItem;
    for (    Object item : oldValue) {
      try {
        oldItem=(String)item;
      }
 catch (      ClassCastException e) {
        throw new InvalidValueException(String.format(""String_Node_Str"",verb,item,parameter.getObjectValue(),e));
      }
      newItem=oldItem.toLowerCase();
      newValue.add(newItem);
    }
    variable.set(newValue);
  }
break;
case MAP:
{
Map<String,Object> oldValue=parameter.getMapValue();
Map<String,Object> newValue=new LinkedHashMap<String,Object>(oldValue.size());
for (Map.Entry<String,Object> entry : oldValue.entrySet()) {
  String oldKey;
  String newKey;
  Object value=entry.getValue();
  oldKey=entry.getKey();
  newKey=oldKey.toLowerCase();
  newValue.put(newKey,value);
}
variable.set(newValue);
}
break;
default :
throw new IllegalStateException(String.format(""String_Node_Str"",parameter.type));
}
}
 catch (Exception e) {
throw new InvalidValueException(String.format(""String_Node_Str"",verb,variable,parameter.getObjectValue(),e),e);
}
this.success=true;
if (logger.isDebugEnabled()) {
logger.debug(String.format(""String_Node_Str"",statementId(namespace),verb,this.success,variable,variable.get(),parameter.getObjectValue()));
}
return ProcessResult.STATEMENT_CONTINUE;
}",0.9994692144373672
135762,"private Token getVariable(String verb,List<Object> statement,int index,Map<String,Object> namespace){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size()));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  if (token.storageType != TokenStorageType.VARIABLE) {
    throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,token.storageType,statement));
  }
  return token;
}","private Token getVariable(String verb,List<Object> statement,int index,Map<String,Object> namespace){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size(),e));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  if (token.storageType != TokenStorageType.VARIABLE) {
    throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,token.storageType,statement));
  }
  return token;
}",0.998502994011976
135763,"private Token getToken(String verb,List<Object> statement,int index,Map<String,Object> namespace,Set<TokenStorageType> storageTypes,Set<TokenType> tokenTypes){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size()));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  if (storageTypes != null) {
    if (!storageTypes.contains(token.storageType)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,storageTypes,statement));
    }
  }
  if (tokenTypes != null) {
    token.load();
    if (!tokenTypes.contains(token.type)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,statement));
    }
  }
  return token;
}","private Token getToken(String verb,List<Object> statement,int index,Map<String,Object> namespace,Set<TokenStorageType> storageTypes,Set<TokenType> tokenTypes){
  Object item;
  Token token;
  try {
    item=statement.get(index);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new InvalidRuleException(String.format(""String_Node_Str"",verb,index + 1,statement.size(),e));
  }
  try {
    token=new Token(item,namespace);
  }
 catch (  Exception e) {
    throw new StatementErrorException(String.format(""String_Node_Str"",index,e));
  }
  if (storageTypes != null) {
    if (!storageTypes.contains(token.storageType)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,storageTypes,statement));
    }
  }
  if (tokenTypes != null) {
    token.load();
    if (!tokenTypes.contains(token.type)) {
      throw new InvalidTypeException(String.format(""String_Node_Str"",verb,index,tokenTypes,statement));
    }
  }
  return token;
}",0.9989583333333332
135764,"void set(Object value,Object index){
  if (this.storageType == TokenStorageType.CONSTANT) {
    throw new InvalidTypeException(""String_Node_Str"");
  }
  if (index == null) {
    index=this.index;
  }
  if (index == null) {
    this.namespace.put(this.name,value);
  }
 else {
    Object base=null;
    if (this.namespace.containsKey(this.name)) {
      base=this.namespace.get(this.name);
    }
 else {
      throw new UndefinedValueException(String.format(""String_Node_Str"",this.name));
    }
    if (base instanceof List) {
      @SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)base;
      Integer idx=null;
      if (index instanceof Long) {
        idx=new Integer(((Long)index).intValue());
      }
 else       if (index instanceof String) {
        try {
          idx=new Integer((String)index);
        }
 catch (        NumberFormatException e) {
          throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index));
        }
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      try {
        value=list.set(idx,value);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,list.size(),idx));
      }
    }
 else     if (base instanceof Map) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)base;
      String idx=null;
      if (index instanceof String) {
        idx=(String)index;
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      if (!map.containsKey(idx)) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,index));
      }
      value=map.put(idx,value);
    }
 else {
      throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,base.getClass().getSimpleName()));
    }
  }
}","void set(Object value,Object index){
  if (this.storageType == TokenStorageType.CONSTANT) {
    throw new InvalidTypeException(""String_Node_Str"");
  }
  if (index == null) {
    index=this.index;
  }
  if (index == null) {
    this.namespace.put(this.name,value);
  }
 else {
    Object base=null;
    if (this.namespace.containsKey(this.name)) {
      base=this.namespace.get(this.name);
    }
 else {
      throw new UndefinedValueException(String.format(""String_Node_Str"",this.name));
    }
    if (base instanceof List) {
      @SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)base;
      Integer idx=null;
      if (index instanceof Long) {
        idx=new Integer(((Long)index).intValue());
      }
 else       if (index instanceof String) {
        try {
          idx=new Integer((String)index);
        }
 catch (        NumberFormatException e) {
          throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,e));
        }
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      try {
        value=list.set(idx,value);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,list.size(),idx,e));
      }
    }
 else     if (base instanceof Map) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)base;
      String idx=null;
      if (index instanceof String) {
        idx=(String)index;
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      if (!map.containsKey(idx)) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,index));
      }
      value=map.put(idx,value);
    }
 else {
      throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,base.getClass().getSimpleName()));
    }
  }
}",0.9990103908955964
135765,"Object get(Object index){
  Object base=null;
  if (this.storageType == TokenStorageType.CONSTANT) {
    return this.value;
  }
  if (this.namespace.containsKey(this.name)) {
    base=this.namespace.get(this.name);
  }
 else {
    throw new UndefinedValueException(String.format(""String_Node_Str"",this.name));
  }
  if (index == null) {
    index=this.index;
  }
  if (index == null) {
    value=base;
  }
 else {
    if (base instanceof List) {
      @SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)base;
      Integer idx=null;
      if (index instanceof Long) {
        idx=new Integer(((Long)index).intValue());
      }
 else       if (index instanceof String) {
        try {
          idx=new Integer((String)index);
        }
 catch (        NumberFormatException e) {
          throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index));
        }
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      try {
        value=list.get(idx);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,list.size(),idx));
      }
    }
 else     if (base instanceof Map) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)base;
      String idx=null;
      if (index instanceof String) {
        idx=(String)index;
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      if (!map.containsKey(idx)) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,index));
      }
      value=map.get(idx);
    }
 else {
      throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,base.getClass().getSimpleName()));
    }
  }
  this.type=classify(value);
  return value;
}","Object get(Object index){
  Object base=null;
  if (this.storageType == TokenStorageType.CONSTANT) {
    return this.value;
  }
  if (this.namespace.containsKey(this.name)) {
    base=this.namespace.get(this.name);
  }
 else {
    throw new UndefinedValueException(String.format(""String_Node_Str"",this.name));
  }
  if (index == null) {
    index=this.index;
  }
  if (index == null) {
    value=base;
  }
 else {
    if (base instanceof List) {
      @SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)base;
      Integer idx=null;
      if (index instanceof Long) {
        idx=new Integer(((Long)index).intValue());
      }
 else       if (index instanceof String) {
        try {
          idx=new Integer((String)index);
        }
 catch (        NumberFormatException e) {
          throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,e));
        }
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      try {
        value=list.get(idx);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,list.size(),idx,e));
      }
    }
 else     if (base instanceof Map) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> map=(Map<String,Object>)base;
      String idx=null;
      if (index instanceof String) {
        idx=(String)index;
      }
 else {
        throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,index.getClass().getSimpleName()));
      }
      if (!map.containsKey(idx)) {
        throw new UndefinedValueException(String.format(""String_Node_Str"",this.name,index));
      }
      value=map.get(idx);
    }
 else {
      throw new InvalidTypeException(String.format(""String_Node_Str"",this.name,index,base.getClass().getSimpleName()));
    }
  }
  this.type=classify(value);
  return value;
}",0.9989868287740628
135766,"@Override public void updated(Dictionary<String,?> properties) throws ConfigurationException {
  try {
    authEnabled=Boolean.valueOf((String)properties.get(AUTH_ENABLED));
  }
 catch (  Throwable t) {
    throw new ConfigurationException(AUTH_ENABLED,AUTH_ENABLED_ERR);
  }
}","@Override public void updated(Dictionary<String,?> properties) throws ConfigurationException {
  if (properties == null) {
    return;
  }
  String propertyValue=(String)properties.get(AUTH_ENABLED);
  boolean isTrueString=Boolean.parseBoolean(propertyValue);
  if (!isTrueString && !""String_Node_Str"".equalsIgnoreCase(propertyValue)) {
    throw new ConfigurationException(AUTH_ENABLED,AUTH_ENABLED_ERR);
  }
  authEnabled=isTrueString;
}",0.4106145251396648
135767,"@Override public Authentication call() throws Exception {
  return as.get();
}","@Override public Authentication call() throws Exception {
  AuthenticationService as=AuthenticationManager.instance();
  return as.get();
}",0.7188940092165899
135768,"@Override public ContainerRequest filter(ContainerRequest request){
  if (ServiceLocator.INSTANCE.as == null)   throw UNAVAILABLE_EX;
  if (ServiceLocator.INSTANCE.as.isAuthEnabled()) {
    Map<String,List<String>> headers=request.getRequestHeaders();
    for (    TokenAuth ta : ServiceLocator.INSTANCE.ta) {
      try {
        Authentication auth=ta.validate(headers);
        if (auth != null) {
          ServiceLocator.INSTANCE.as.set(auth);
          return request;
        }
      }
 catch (      AuthenticationException ae) {
        throw unauthorized();
      }
    }
    try {
      OAuthAccessResourceRequest or=new OAuthAccessResourceRequest(httpRequest,ParameterStyle.HEADER);
      validate(or.getAccessToken());
    }
 catch (    OAuthSystemException|OAuthProblemException e) {
      throw unauthorized();
    }
  }
  return request;
}","@Override public ContainerRequest filter(ContainerRequest request){
  if (checkCORSOptionRequest(request)) {
    return request;
  }
  if (ServiceLocator.INSTANCE.as == null)   throw UNAVAILABLE_EX;
  if (ServiceLocator.INSTANCE.as.isAuthEnabled()) {
    Map<String,List<String>> headers=request.getRequestHeaders();
    for (    TokenAuth ta : ServiceLocator.INSTANCE.ta) {
      try {
        Authentication auth=ta.validate(headers);
        if (auth != null) {
          ServiceLocator.INSTANCE.as.set(auth);
          return request;
        }
      }
 catch (      AuthenticationException ae) {
        throw unauthorized();
      }
    }
    try {
      OAuthAccessResourceRequest or=new OAuthAccessResourceRequest(httpRequest,ParameterStyle.HEADER);
      validate(or.getAccessToken());
    }
 catch (    OAuthSystemException|OAuthProblemException e) {
      throw unauthorized();
    }
  }
  return request;
}",0.9632975719932242
135769,"@Override public ContainerRequest filter(ContainerRequest request){
  if (ServiceLocator.INSTANCE.as == null)   throw UNAVAILABLE_EX;
  if (ServiceLocator.INSTANCE.as.isAuthEnabled()) {
    Map<String,List<String>> headers=request.getRequestHeaders();
    for (    TokenAuth ta : ServiceLocator.INSTANCE.ta) {
      try {
        Authentication auth=ta.validate(headers);
        if (auth != null) {
          ServiceLocator.INSTANCE.as.set(auth);
          return request;
        }
      }
 catch (      AuthenticationException ae) {
        throw unauthorized();
      }
    }
    try {
      OAuthAccessResourceRequest or=new OAuthAccessResourceRequest(httpRequest,ParameterStyle.HEADER);
      validate(or.getAccessToken());
    }
 catch (    OAuthSystemException|OAuthProblemException e) {
      throw unauthorized();
    }
  }
  return request;
}","@Override public ContainerRequest filter(ContainerRequest request){
  if (checkCORSOptionRequest(request)) {
    return request;
  }
  if (ServiceLocator.INSTANCE.as == null)   throw UNAVAILABLE_EX;
  if (ServiceLocator.INSTANCE.as.isAuthEnabled()) {
    Map<String,List<String>> headers=request.getRequestHeaders();
    for (    TokenAuth ta : ServiceLocator.INSTANCE.ta) {
      try {
        Authentication auth=ta.validate(headers);
        if (auth != null) {
          ServiceLocator.INSTANCE.as.set(auth);
          return request;
        }
      }
 catch (      AuthenticationException ae) {
        throw unauthorized();
      }
    }
    try {
      OAuthAccessResourceRequest or=new OAuthAccessResourceRequest(httpRequest,ParameterStyle.HEADER);
      validate(or.getAccessToken());
    }
 catch (    OAuthSystemException|OAuthProblemException e) {
      throw unauthorized();
    }
  }
  return request;
}",0.9632975719932242
135770,"public void windowClosing(WindowEvent e){
  if (rtspControl != null)   rtspControl.RTSPTeardown();
  System.exit(0);
}","public void windowClosing(WindowEvent e){
  System.exit(0);
}",0.6815642458100558
135771,"public RTSPTest(){
  mainFrame=new JFrame(""String_Node_Str"");
  setupButton=new JButton(""String_Node_Str"");
  playButton=new JButton(""String_Node_Str"");
  pauseButton=new JButton(""String_Node_Str"");
  optionsButton=new JButton(""String_Node_Str"");
  describeButton=new JButton(""String_Node_Str"");
  teardownButton=new JButton(""String_Node_Str"");
  textField=new JTextField(""String_Node_Str"");
  buttonPanel=new JPanel();
  textPanel=new JPanel();
  mainPanel=new JPanel();
  buttonPanel.setLayout(new GridLayout(1,0));
  buttonPanel.add(describeButton);
  buttonPanel.add(optionsButton);
  buttonPanel.add(setupButton);
  buttonPanel.add(playButton);
  buttonPanel.add(pauseButton);
  buttonPanel.add(teardownButton);
  setupButton.addActionListener(this);
  playButton.addActionListener(this);
  pauseButton.addActionListener(this);
  optionsButton.addActionListener(this);
  describeButton.addActionListener(this);
  teardownButton.addActionListener(this);
  textField.addActionListener(this);
  textPanel.setLayout(new GridLayout(1,0));
  textPanel.add(textField);
  mainPanel.setLayout(null);
  mainPanel.add(textPanel);
  mainPanel.add(buttonPanel);
  textPanel.setBounds(0,0,450,25);
  buttonPanel.setBounds(0,25,450,50);
  mainFrame.addWindowListener(new WindowAdapter(){
    public void windowClosing(    WindowEvent e){
      if (rtspControl != null)       rtspControl.RTSPTeardown();
      System.exit(0);
    }
  }
);
  hostName=""String_Node_Str"";
  portNumber=554;
  videoFile=""String_Node_Str"";
  rtspControl=new RTSPControl(hostName,portNumber,videoFile);
  mainFrame.getContentPane().add(mainPanel,BorderLayout.CENTER);
  mainFrame.setSize(new Dimension(450,100));
  mainFrame.setVisible(true);
}","public RTSPTest(){
  mainFrame=new JFrame(""String_Node_Str"");
  setupButton=new JButton(""String_Node_Str"");
  playButton=new JButton(""String_Node_Str"");
  pauseButton=new JButton(""String_Node_Str"");
  optionsButton=new JButton(""String_Node_Str"");
  describeButton=new JButton(""String_Node_Str"");
  teardownButton=new JButton(""String_Node_Str"");
  textField=new JTextField(""String_Node_Str"");
  buttonPanel=new JPanel();
  textPanel=new JPanel();
  mainPanel=new JPanel();
  buttonPanel.setLayout(new GridLayout(1,0));
  buttonPanel.add(describeButton);
  buttonPanel.add(optionsButton);
  buttonPanel.add(setupButton);
  buttonPanel.add(playButton);
  buttonPanel.add(pauseButton);
  buttonPanel.add(teardownButton);
  setupButton.addActionListener(this);
  playButton.addActionListener(this);
  pauseButton.addActionListener(this);
  optionsButton.addActionListener(this);
  describeButton.addActionListener(this);
  teardownButton.addActionListener(this);
  textField.addActionListener(this);
  textPanel.setLayout(new GridLayout(1,0));
  textPanel.add(textField);
  mainPanel.setLayout(null);
  mainPanel.add(textPanel);
  mainPanel.add(buttonPanel);
  textPanel.setBounds(0,0,450,25);
  buttonPanel.setBounds(0,25,450,50);
  mainFrame.addWindowListener(new WindowAdapter(){
    public void windowClosing(    WindowEvent e){
      System.exit(0);
    }
  }
);
  hostName=""String_Node_Str"";
  portNumber=554;
  videoFile=""String_Node_Str"";
  rtspControl=new RTSPControl(hostName,portNumber,videoFile);
  mainFrame.getContentPane().add(mainPanel,BorderLayout.CENTER);
  mainFrame.setSize(new Dimension(450,100));
  mainFrame.setVisible(true);
}",0.9806259314456036
135772,"protected void initAssetEntry(Locale locale) throws PortalException, SystemException {
  try {
    _assetEntry=AssetEntryServiceUtil.getEntry(_assetEntryId);
  }
 catch (  Exception e) {
    if (_log.isDebugEnabled()) {
      _log.debug(e);
    }
    return;
  }
  _assetClassName=_assetEntry.getClassName();
  _assetClassPK=_assetEntry.getClassPK();
  _assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(_assetEntry.getClassName());
  _assetRenderer=_assetRendererFactory.getAssetRenderer(_assetClassPK);
  _assetTitle=_assetEntry.getTitle(locale);
  _assetType=_assetRendererFactory.getTypeName(locale,true);
}","protected void initAssetEntry(Locale locale) throws PortalException, SystemException {
  try {
    _assetEntry=AssetEntryServiceUtil.getEntry(_assetEntryId);
  }
 catch (  Exception e) {
    if (_log.isDebugEnabled()) {
      _log.debug(e);
    }
    return;
  }
  if (!_assetEntry.isVisible()) {
    return;
  }
  _assetClassName=_assetEntry.getClassName();
  _assetClassPK=_assetEntry.getClassPK();
  _assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(_assetEntry.getClassName());
  _assetRenderer=_assetRendererFactory.getAssetRenderer(_assetClassPK);
  _assetTitle=_assetEntry.getTitle(locale);
  _assetType=_assetRendererFactory.getTypeName(locale,true);
}",0.9629629629629628
135773,"protected void addCampaignTrackingActionsTotalFromAnalyticsWithClassName(long campaignId,Date date) throws PortalException, SystemException {
  List<Object[]> campaignTrackingActionTotalAnalyticsList=campaignTrackingActionTotalFinder.findByAnalyticsWithClassName(date);
  for (  Object[] campaignTrackingActionTotalAnalytics : campaignTrackingActionTotalAnalyticsList) {
    String className=(String)campaignTrackingActionTotalAnalytics[0];
    long classPK=(Long)campaignTrackingActionTotalAnalytics[1];
    String eventType=(String)campaignTrackingActionTotalAnalytics[2];
    int count=(Integer)campaignTrackingActionTotalAnalytics[3];
    List<TrackingActionInstance> trackingActionInstances=_trackingActionInstaceLocalService.getTrackingActionInstances(campaignId,className,classPK,eventType);
    if (!trackingActionInstances.isEmpty()) {
      continue;
    }
    TrackingActionInstance trackingActionInstance=trackingActionInstances.get(0);
    addCampaignTrackingActionTotal(campaignId,trackingActionInstance.getAlias(),className,classPK,eventType,count);
  }
}","protected void addCampaignTrackingActionsTotalFromAnalyticsWithClassName(long campaignId,Date date) throws PortalException, SystemException {
  List<Object[]> campaignTrackingActionTotalAnalyticsList=campaignTrackingActionTotalFinder.findByAnalyticsWithClassName(date);
  for (  Object[] campaignTrackingActionTotalAnalytics : campaignTrackingActionTotalAnalyticsList) {
    String className=(String)campaignTrackingActionTotalAnalytics[0];
    long classPK=(Long)campaignTrackingActionTotalAnalytics[1];
    String eventType=(String)campaignTrackingActionTotalAnalytics[2];
    int count=(Integer)campaignTrackingActionTotalAnalytics[3];
    List<TrackingActionInstance> trackingActionInstances=_trackingActionInstaceLocalService.getTrackingActionInstances(campaignId,className,classPK,eventType);
    if (trackingActionInstances.isEmpty()) {
      continue;
    }
    TrackingActionInstance trackingActionInstance=trackingActionInstances.get(0);
    addCampaignTrackingActionTotal(campaignId,trackingActionInstance.getAlias(),className,classPK,eventType,count);
  }
}",0.9995324918186068
135774,"protected void addCampaignTrackingActionsTotalFromAnalyticsWithElementId(long campaignId,Date date) throws PortalException, SystemException {
  if (date == null) {
    date=_analyticsEventLocalService.getMaxAge();
  }
  List<Object[]> campaignTrackingActionTotalAnalyticsList=campaignTrackingActionTotalFinder.findByAnalyticsWithElementId(date);
  for (  Object[] campaignTrackingActionTotalAnalytics : campaignTrackingActionTotalAnalyticsList) {
    String elementId=(String)campaignTrackingActionTotalAnalytics[0];
    String eventType=(String)campaignTrackingActionTotalAnalytics[1];
    int count=(Integer)campaignTrackingActionTotalAnalytics[2];
    List<TrackingActionInstance> trackingActionInstances=_trackingActionInstaceLocalService.getTrackingActionInstances(campaignId,elementId,eventType);
    if (!trackingActionInstances.isEmpty()) {
      continue;
    }
    TrackingActionInstance trackingActionInstance=trackingActionInstances.get(0);
    addCampaignTrackingActionTotal(campaignId,trackingActionInstance.getAlias(),elementId,eventType,count);
  }
}","protected void addCampaignTrackingActionsTotalFromAnalyticsWithElementId(long campaignId,Date date) throws PortalException, SystemException {
  if (date == null) {
    date=_analyticsEventLocalService.getMaxAge();
  }
  List<Object[]> campaignTrackingActionTotalAnalyticsList=campaignTrackingActionTotalFinder.findByAnalyticsWithElementId(date);
  for (  Object[] campaignTrackingActionTotalAnalytics : campaignTrackingActionTotalAnalyticsList) {
    String elementId=(String)campaignTrackingActionTotalAnalytics[0];
    String eventType=(String)campaignTrackingActionTotalAnalytics[1];
    int count=(Integer)campaignTrackingActionTotalAnalytics[2];
    List<TrackingActionInstance> trackingActionInstances=_trackingActionInstaceLocalService.getTrackingActionInstances(campaignId,elementId,eventType);
    if (trackingActionInstances.isEmpty()) {
      continue;
    }
    TrackingActionInstance trackingActionInstance=trackingActionInstances.get(0);
    addCampaignTrackingActionTotal(campaignId,trackingActionInstance.getAlias(),elementId,eventType,count);
  }
}",0.999530736743313
135775,"protected AssetCategory addUserSegmentCategory(long userId,Map<Locale,String> titleMap,Map<Locale,String> descriptionMap,ServiceContext serviceContext) throws PortalException, SystemException {
  long vocabularyId=UserSegmentUtil.getAssetVocabularyId(userId,serviceContext);
  serviceContext.setAddGroupPermissions(true);
  serviceContext.setAddGuestPermissions(true);
  AssetCategory assetCategory=AssetCategoryLocalServiceUtil.addCategory(userId,AssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID,titleMap,descriptionMap,vocabularyId,null,serviceContext);
  return assetCategory;
}","protected AssetCategory addUserSegmentCategory(long userId,Map<Locale,String> titleMap,Map<Locale,String> descriptionMap,ServiceContext serviceContext) throws PortalException, SystemException {
  long vocabularyId=UserSegmentUtil.getAssetVocabularyId(userId,serviceContext);
  serviceContext.setAddGroupPermissions(true);
  serviceContext.setAddGuestPermissions(true);
  AssetCategory assetCategory=null;
  try {
    assetCategory=AssetCategoryLocalServiceUtil.addCategory(userId,AssetCategoryConstants.DEFAULT_PARENT_CATEGORY_ID,titleMap,descriptionMap,vocabularyId,null,serviceContext);
  }
 catch (  DuplicateCategoryException dce) {
    throw new InvalidNameException();
  }
  return assetCategory;
}",0.8740279937791602
135776,"protected void populateContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template) throws Exception {
  BeansWrapper wrapper=BeansWrapper.getDefaultInstance();
  TemplateHashModel staticModels=wrapper.getStaticModels();
  template.put(""String_Node_Str"",Campaign.class);
  template.put(""String_Node_Str"",staticModels.get(CampaignConstants.class.getName()));
  template.put(""String_Node_Str"",staticModels.get(ContentTargetingPath.class.getName()));
  template.put(""String_Node_Str"",PortalUtil.getCurrentURL(portletRequest));
  template.put(""String_Node_Str"",LiferayWindowState.POP_UP);
  template.put(""String_Node_Str"",getPortletContext());
  template.put(""String_Node_Str"",ParamUtil.getString(portletRequest,""String_Node_Str""));
  template.put(""String_Node_Str"",ParamUtil.getString(portletRequest,""String_Node_Str"",""String_Node_Str""));
  template.put(""String_Node_Str"",portletRequest.getAttribute(PortletRequest.USER_INFO));
  template.put(""String_Node_Str"",UserSegment.class);
  populateViewContext(path,portletRequest,portletResponse,template,staticModels);
}","protected void populateContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template) throws Exception {
  BeansWrapper wrapper=BeansWrapper.getDefaultInstance();
  TemplateHashModel staticModels=wrapper.getStaticModels();
  template.put(""String_Node_Str"",ParamUtil.getString(portletRequest,""String_Node_Str""));
  template.put(""String_Node_Str"",Campaign.class);
  template.put(""String_Node_Str"",staticModels.get(CampaignConstants.class.getName()));
  template.put(""String_Node_Str"",staticModels.get(ContentTargetingPath.class.getName()));
  template.put(""String_Node_Str"",PortalUtil.getCurrentURL(portletRequest));
  template.put(""String_Node_Str"",LiferayWindowState.POP_UP);
  template.put(""String_Node_Str"",getPortletContext());
  template.put(""String_Node_Str"",ParamUtil.getString(portletRequest,""String_Node_Str""));
  template.put(""String_Node_Str"",ParamUtil.getString(portletRequest,""String_Node_Str"",""String_Node_Str""));
  template.put(""String_Node_Str"",portletRequest.getAttribute(PortletRequest.USER_INFO));
  template.put(""String_Node_Str"",UserSegment.class);
  populateViewContext(path,portletRequest,portletResponse,template,staticModels);
}",0.9611523352247928
135777,"protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template,TemplateHashModel staticModels) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
  PortletPreferences portletPreferences=portletRequest.getPreferences();
  long assetEntryIdDefault=GetterUtil.getLong(portletPreferences.getValue(""String_Node_Str"",null));
  boolean contentDefaultValue=GetterUtil.getBoolean(portletPreferences.getValue(""String_Node_Str"",null));
  populatePortletDisplayTemplateContext(template,portletPreferences,themeDisplay.getScopeGroupId(),""String_Node_Str"");
  if (Validator.isNull(path) || path.equals(CampaignContentDisplayPath.VIEW)) {
    template.put(""String_Node_Str"",showPreview(themeDisplay));
    template.put(""String_Node_Str"",contentDefaultValue);
    List<QueryRule> campaignQueryRules=CampaignQueryRuleUtil.getCampaignQueryRules(portletPreferences,themeDisplay.getLocale());
    template.put(""String_Node_Str"",campaignQueryRules);
    QueryRule queryRule=null;
    long[] userSegmentIds=(long[])portletRequest.getAttribute(WebKeys.USER_SEGMENT_IDS);
    if (userSegmentIds != null) {
      long[] groupIds=ContentTargetingUtil.getAncestorsAndCurrentGroupIds(themeDisplay.getSiteGroupId());
      List<Campaign> campaigns=_campaignLocalService.getCampaigns(groupIds,userSegmentIds);
      queryRule=CampaignQueryRuleUtil.match(getCampaignIds(campaigns),campaignQueryRules);
      template.put(""String_Node_Str"",queryRule);
    }
    template.put(""String_Node_Str"",campaignQueryRules.indexOf(queryRule));
    template.put(""String_Node_Str"",Campaign.class.getName());
    List<AssetEntry> results=new ArrayList<AssetEntry>();
    if ((queryRule != null) && (queryRule.getAssetEntry() != null)) {
      results.add(queryRule.getAssetEntry());
      queryRule.setAssetAttributes(portletRequest);
    }
 else {
      portletRequest.setAttribute(WebKeys.PORTLET_CONFIGURATOR_VISIBILITY,Boolean.TRUE);
    }
    template.put(""String_Node_Str"",LiferayWindowState.POP_UP);
    populatePortletDisplayTemplateViewContext(template,portletRequest,themeDisplay,results,campaignQueryRules);
  }
 else   if (path.equals(CampaignContentDisplayPath.EDIT_QUERY_RULE) || path.equals(CampaignContentDisplayPath.CONFIGURATION)) {
    template.put(""String_Node_Str"",getSelectableAssetRendererFactories(themeDisplay.getCompanyId()));
    String assetImageDefault=StringPool.BLANK;
    String assetTitleDefault=StringPool.BLANK;
    String assetTypeDefault=StringPool.BLANK;
    if (assetEntryIdDefault > 0) {
      AssetEntry assetEntry=AssetEntryLocalServiceUtil.fetchAssetEntry(assetEntryIdDefault);
      AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(assetEntry.getClassName());
      AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(assetEntry.getClassPK());
      assetImageDefault=assetRenderer.getThumbnailPath(portletRequest);
      assetTitleDefault=assetRenderer.getTitle(themeDisplay.getLocale());
      assetTypeDefault=assetRendererFactory.getTypeName(themeDisplay.getLocale(),true);
    }
    List<Campaign> campaigns=_campaignService.getCampaigns(themeDisplay.getSiteGroupIdOrLiveGroupId());
    template.put(""String_Node_Str"",campaigns);
    template.put(""String_Node_Str"",assetEntryIdDefault);
    template.put(""String_Node_Str"",assetImageDefault);
    template.put(""String_Node_Str"",assetTitleDefault);
    template.put(""String_Node_Str"",assetTypeDefault);
    template.put(""String_Node_Str"",contentDefaultValue);
    template.put(""String_Node_Str"",LiferayWindowState.EXCLUSIVE);
    template.put(""String_Node_Str"",portletPreferences);
    int[] queryRulesIndexes=GetterUtil.getIntegerValues(portletPreferences.getValues(""String_Node_Str"",null),new int[]{0});
    template.put(""String_Node_Str"",queryRulesIndexes);
    template.put(""String_Node_Str"",staticModels.get(CampaignQueryRuleUtil.class.getName()));
    template.put(""String_Node_Str"",staticModels.get(UserSegmentContentDisplayUtil.class.getName()));
  }
}","protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template,TemplateHashModel staticModels) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
  PortletPreferences portletPreferences=portletRequest.getPreferences();
  long assetEntryIdDefault=GetterUtil.getLong(portletPreferences.getValue(""String_Node_Str"",null));
  boolean contentDefaultValue=GetterUtil.getBoolean(portletPreferences.getValue(""String_Node_Str"",null));
  populatePortletDisplayTemplateContext(template,portletPreferences,themeDisplay.getScopeGroupId(),""String_Node_Str"");
  if (Validator.isNull(path) || path.equals(CampaignContentDisplayPath.VIEW)) {
    template.put(""String_Node_Str"",showPreview(themeDisplay));
    template.put(""String_Node_Str"",contentDefaultValue);
    List<QueryRule> campaignQueryRules=CampaignQueryRuleUtil.getCampaignQueryRules(portletPreferences,themeDisplay.getLocale());
    template.put(""String_Node_Str"",campaignQueryRules);
    QueryRule queryRule=campaignQueryRules.get(0);
    long[] userSegmentIds=(long[])portletRequest.getAttribute(WebKeys.USER_SEGMENT_IDS);
    if (userSegmentIds != null) {
      long[] groupIds=ContentTargetingUtil.getAncestorsAndCurrentGroupIds(themeDisplay.getSiteGroupId());
      List<Campaign> campaigns=_campaignLocalService.getCampaigns(groupIds,userSegmentIds);
      queryRule=CampaignQueryRuleUtil.match(getCampaignIds(campaigns),campaignQueryRules);
    }
    template.put(""String_Node_Str"",queryRule);
    template.put(""String_Node_Str"",campaignQueryRules.indexOf(queryRule));
    template.put(""String_Node_Str"",Campaign.class.getName());
    List<AssetEntry> results=new ArrayList<AssetEntry>();
    if ((queryRule != null) && (queryRule.getAssetEntry() != null)) {
      results.add(queryRule.getAssetEntry());
      queryRule.setAssetAttributes(portletRequest);
    }
 else {
      portletRequest.setAttribute(WebKeys.PORTLET_CONFIGURATOR_VISIBILITY,Boolean.TRUE);
    }
    template.put(""String_Node_Str"",LiferayWindowState.POP_UP);
    populatePortletDisplayTemplateViewContext(template,portletRequest,themeDisplay,results,campaignQueryRules);
  }
 else   if (path.equals(CampaignContentDisplayPath.EDIT_QUERY_RULE) || path.equals(CampaignContentDisplayPath.CONFIGURATION)) {
    template.put(""String_Node_Str"",getSelectableAssetRendererFactories(themeDisplay.getCompanyId()));
    String assetImageDefault=StringPool.BLANK;
    String assetTitleDefault=StringPool.BLANK;
    String assetTypeDefault=StringPool.BLANK;
    if (assetEntryIdDefault > 0) {
      AssetEntry assetEntry=AssetEntryLocalServiceUtil.fetchAssetEntry(assetEntryIdDefault);
      AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(assetEntry.getClassName());
      AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(assetEntry.getClassPK());
      assetImageDefault=assetRenderer.getThumbnailPath(portletRequest);
      assetTitleDefault=assetRenderer.getTitle(themeDisplay.getLocale());
      assetTypeDefault=assetRendererFactory.getTypeName(themeDisplay.getLocale(),true);
    }
    List<Campaign> campaigns=_campaignService.getCampaigns(themeDisplay.getSiteGroupIdOrLiveGroupId());
    template.put(""String_Node_Str"",campaigns);
    template.put(""String_Node_Str"",assetEntryIdDefault);
    template.put(""String_Node_Str"",assetImageDefault);
    template.put(""String_Node_Str"",assetTitleDefault);
    template.put(""String_Node_Str"",assetTypeDefault);
    template.put(""String_Node_Str"",contentDefaultValue);
    template.put(""String_Node_Str"",LiferayWindowState.EXCLUSIVE);
    template.put(""String_Node_Str"",portletPreferences);
    int[] queryRulesIndexes=GetterUtil.getIntegerValues(portletPreferences.getValues(""String_Node_Str"",null),new int[]{0});
    template.put(""String_Node_Str"",queryRulesIndexes);
    template.put(""String_Node_Str"",staticModels.get(CampaignQueryRuleUtil.class.getName()));
    template.put(""String_Node_Str"",staticModels.get(UserSegmentContentDisplayUtil.class.getName()));
  }
}",0.9952687128472644
135778,"protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template,TemplateHashModel staticModels) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
  PortletPreferences portletPreferences=portletRequest.getPreferences();
  long assetEntryIdDefault=GetterUtil.getLong(portletPreferences.getValue(""String_Node_Str"",null));
  boolean contentDefaultValue=GetterUtil.getBoolean(portletPreferences.getValue(""String_Node_Str"",null));
  populatePortletDisplayTemplateContext(template,portletPreferences,themeDisplay.getScopeGroupId(),""String_Node_Str"");
  if (Validator.isNull(path) || path.equals(UserSegmentContentDisplayPath.VIEW)) {
    template.put(""String_Node_Str"",showPreview(themeDisplay));
    template.put(""String_Node_Str"",contentDefaultValue);
    List<QueryRule> userSegmentQueryRules=UserSegmentQueryRuleUtil.getUserSegmentQueryRules(portletPreferences,themeDisplay.getLocale());
    template.put(""String_Node_Str"",userSegmentQueryRules);
    QueryRule queryRule=null;
    long[] userSegmentIds=(long[])portletRequest.getAttribute(WebKeys.USER_SEGMENT_IDS);
    if (userSegmentIds != null) {
      long[] userSegmentAssetCategoryIds=ContentTargetingUtil.getAssetCategoryIds(userSegmentIds);
      queryRule=UserSegmentQueryRuleUtil.match(userSegmentAssetCategoryIds,userSegmentQueryRules);
      template.put(""String_Node_Str"",queryRule);
    }
    template.put(""String_Node_Str"",userSegmentQueryRules.indexOf(queryRule));
    List<AssetEntry> results=new ArrayList<AssetEntry>();
    if ((queryRule != null) && (queryRule.getAssetEntry() != null)) {
      results.add(queryRule.getAssetEntry());
      queryRule.setAssetAttributes(portletRequest);
    }
 else {
      portletRequest.setAttribute(WebKeys.PORTLET_CONFIGURATOR_VISIBILITY,Boolean.TRUE);
    }
    template.put(""String_Node_Str"",LiferayWindowState.POP_UP);
    populatePortletDisplayTemplateViewContext(template,portletRequest,themeDisplay,results,userSegmentQueryRules);
  }
 else   if (path.equals(UserSegmentContentDisplayPath.EDIT_QUERY_RULE) || path.equals(UserSegmentContentDisplayPath.CONFIGURATION)) {
    template.put(""String_Node_Str"",getSelectableAssetRendererFactories(themeDisplay.getCompanyId()));
    String assetImageDefault=StringPool.BLANK;
    String assetTitleDefault=StringPool.BLANK;
    String assetTypeDefault=StringPool.BLANK;
    if (assetEntryIdDefault > 0) {
      AssetEntry assetEntry=AssetEntryLocalServiceUtil.fetchAssetEntry(assetEntryIdDefault);
      AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(assetEntry.getClassName());
      AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(assetEntry.getClassPK());
      assetImageDefault=assetRenderer.getThumbnailPath(portletRequest);
      assetTitleDefault=assetRenderer.getTitle(themeDisplay.getLocale());
      assetTypeDefault=assetRendererFactory.getTypeName(themeDisplay.getLocale(),true);
    }
    template.put(""String_Node_Str"",assetEntryIdDefault);
    template.put(""String_Node_Str"",assetImageDefault);
    template.put(""String_Node_Str"",assetTitleDefault);
    template.put(""String_Node_Str"",assetTypeDefault);
    template.put(""String_Node_Str"",contentDefaultValue);
    template.put(""String_Node_Str"",LiferayWindowState.EXCLUSIVE);
    template.put(""String_Node_Str"",portletPreferences);
    int[] queryRulesIndexes=GetterUtil.getIntegerValues(portletPreferences.getValues(""String_Node_Str"",null),new int[]{0});
    template.put(""String_Node_Str"",queryRulesIndexes);
    template.put(""String_Node_Str"",staticModels.get(UserSegmentQueryRuleUtil.class.getName()));
    template.put(""String_Node_Str"",staticModels.get(UserSegmentContentDisplayUtil.class.getName()));
    ServiceContext serviceContext=new ServiceContext();
    serviceContext.setScopeGroupId(themeDisplay.getScopeGroupId());
    long[] vocabularyGroupIds=new long[1];
    long[] vocabularyIds=new long[1];
    if (themeDisplay.getScopeGroupId() == themeDisplay.getCompanyGroupId()) {
      vocabularyGroupIds[0]=themeDisplay.getCompanyGroupId();
      vocabularyIds[0]=UserSegmentUtil.getAssetVocabularyId(themeDisplay.getUserId(),serviceContext);
    }
 else {
      vocabularyGroupIds=ContentTargetingUtil.getAncestorsAndCurrentGroupIds(themeDisplay.getSiteGroupId());
      vocabularyIds=UserSegmentUtil.getAssetVocabularyIds(vocabularyGroupIds);
    }
    template.put(""String_Node_Str"",StringUtil.merge(vocabularyGroupIds));
    template.put(""String_Node_Str"",StringUtil.merge(vocabularyIds));
  }
}","protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template,TemplateHashModel staticModels) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
  PortletPreferences portletPreferences=portletRequest.getPreferences();
  long assetEntryIdDefault=GetterUtil.getLong(portletPreferences.getValue(""String_Node_Str"",null));
  boolean contentDefaultValue=GetterUtil.getBoolean(portletPreferences.getValue(""String_Node_Str"",null));
  populatePortletDisplayTemplateContext(template,portletPreferences,themeDisplay.getScopeGroupId(),""String_Node_Str"");
  if (Validator.isNull(path) || path.equals(UserSegmentContentDisplayPath.VIEW)) {
    template.put(""String_Node_Str"",showPreview(themeDisplay));
    template.put(""String_Node_Str"",contentDefaultValue);
    List<QueryRule> userSegmentQueryRules=UserSegmentQueryRuleUtil.getUserSegmentQueryRules(portletPreferences,themeDisplay.getLocale());
    template.put(""String_Node_Str"",userSegmentQueryRules);
    QueryRule queryRule=userSegmentQueryRules.get(0);
    long[] userSegmentIds=(long[])portletRequest.getAttribute(WebKeys.USER_SEGMENT_IDS);
    if (userSegmentIds != null) {
      long[] userSegmentAssetCategoryIds=ContentTargetingUtil.getAssetCategoryIds(userSegmentIds);
      queryRule=UserSegmentQueryRuleUtil.match(userSegmentAssetCategoryIds,userSegmentQueryRules);
    }
    template.put(""String_Node_Str"",queryRule);
    template.put(""String_Node_Str"",userSegmentQueryRules.indexOf(queryRule));
    List<AssetEntry> results=new ArrayList<AssetEntry>();
    if ((queryRule != null) && (queryRule.getAssetEntry() != null)) {
      results.add(queryRule.getAssetEntry());
      queryRule.setAssetAttributes(portletRequest);
    }
 else {
      portletRequest.setAttribute(WebKeys.PORTLET_CONFIGURATOR_VISIBILITY,Boolean.TRUE);
    }
    template.put(""String_Node_Str"",LiferayWindowState.POP_UP);
    populatePortletDisplayTemplateViewContext(template,portletRequest,themeDisplay,results,userSegmentQueryRules);
  }
 else   if (path.equals(UserSegmentContentDisplayPath.EDIT_QUERY_RULE) || path.equals(UserSegmentContentDisplayPath.CONFIGURATION)) {
    template.put(""String_Node_Str"",getSelectableAssetRendererFactories(themeDisplay.getCompanyId()));
    String assetImageDefault=StringPool.BLANK;
    String assetTitleDefault=StringPool.BLANK;
    String assetTypeDefault=StringPool.BLANK;
    if (assetEntryIdDefault > 0) {
      AssetEntry assetEntry=AssetEntryLocalServiceUtil.fetchAssetEntry(assetEntryIdDefault);
      AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(assetEntry.getClassName());
      AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(assetEntry.getClassPK());
      assetImageDefault=assetRenderer.getThumbnailPath(portletRequest);
      assetTitleDefault=assetRenderer.getTitle(themeDisplay.getLocale());
      assetTypeDefault=assetRendererFactory.getTypeName(themeDisplay.getLocale(),true);
    }
    template.put(""String_Node_Str"",assetEntryIdDefault);
    template.put(""String_Node_Str"",assetImageDefault);
    template.put(""String_Node_Str"",assetTitleDefault);
    template.put(""String_Node_Str"",assetTypeDefault);
    template.put(""String_Node_Str"",contentDefaultValue);
    template.put(""String_Node_Str"",LiferayWindowState.EXCLUSIVE);
    template.put(""String_Node_Str"",portletPreferences);
    int[] queryRulesIndexes=GetterUtil.getIntegerValues(portletPreferences.getValues(""String_Node_Str"",null),new int[]{0});
    template.put(""String_Node_Str"",queryRulesIndexes);
    template.put(""String_Node_Str"",staticModels.get(UserSegmentQueryRuleUtil.class.getName()));
    template.put(""String_Node_Str"",staticModels.get(UserSegmentContentDisplayUtil.class.getName()));
    ServiceContext serviceContext=new ServiceContext();
    serviceContext.setScopeGroupId(themeDisplay.getScopeGroupId());
    long[] vocabularyGroupIds=new long[1];
    long[] vocabularyIds=new long[1];
    if (themeDisplay.getScopeGroupId() == themeDisplay.getCompanyGroupId()) {
      vocabularyGroupIds[0]=themeDisplay.getCompanyGroupId();
      vocabularyIds[0]=UserSegmentUtil.getAssetVocabularyId(themeDisplay.getUserId(),serviceContext);
    }
 else {
      vocabularyGroupIds=ContentTargetingUtil.getAncestorsAndCurrentGroupIds(themeDisplay.getSiteGroupId());
      vocabularyIds=UserSegmentUtil.getAssetVocabularyIds(vocabularyGroupIds);
    }
    template.put(""String_Node_Str"",StringUtil.merge(vocabularyGroupIds));
    template.put(""String_Node_Str"",StringUtil.merge(vocabularyIds));
  }
}",0.9954809554551324
135779,"protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template,TemplateHashModel staticModels) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
  PortletPreferences portletPreferences=portletRequest.getPreferences();
  long assetEntryIdDefault=GetterUtil.getLong(portletPreferences.getValue(""String_Node_Str"",null));
  boolean contentDefaultValue=GetterUtil.getBoolean(portletPreferences.getValue(""String_Node_Str"",null));
  if (Validator.isNull(path) || path.equals(CampaignContentDisplayPath.VIEW)) {
    CampaignQueryRule queryRule=null;
    long[] userSegmentIds=(long[])portletRequest.getAttribute(WebKeys.USER_SEGMENT_IDS);
    if (userSegmentIds != null) {
      long[] groupIds=ContentTargetingUtil.getAncestorsAndCurrentGroupIds(themeDisplay.getSiteGroupId());
      Campaign campaign=_campaignLocalService.fetchCurrentMaxPriorityCampaign(groupIds,userSegmentIds);
      if (campaign != null) {
        queryRule=CampaignQueryRuleUtil.match(campaign.getCampaignId(),portletPreferences,themeDisplay.getLocale());
        template.put(""String_Node_Str"",Campaign.class.getName());
        template.put(""String_Node_Str"",campaign.getCampaignId());
        template.put(""String_Node_Str"",campaign.getGroupId());
      }
    }
    boolean isMatchingRule=false;
    if ((queryRule != null) || (contentDefaultValue && (assetEntryIdDefault > 0))) {
      isMatchingRule=true;
      long assetEntryId=assetEntryIdDefault;
      if (queryRule != null) {
        assetEntryId=queryRule.getAssetEntryId();
      }
      AssetEntry assetEntry=AssetEntryLocalServiceUtil.fetchAssetEntry(assetEntryId);
      AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(assetEntry.getClassName());
      AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(assetEntry.getClassPK());
      portletRequest.setAttribute(""String_Node_Str"",new ArrayList());
      portletRequest.setAttribute(""String_Node_Str"",new Integer(0));
      portletRequest.setAttribute(""String_Node_Str"",assetEntry);
      portletRequest.setAttribute(""String_Node_Str"",assetRendererFactory);
      portletRequest.setAttribute(""String_Node_Str"",assetRenderer);
      portletRequest.setAttribute(""String_Node_Str"",assetEntry.getTitle(themeDisplay.getLocale()));
      portletRequest.setAttribute(""String_Node_Str"",new Boolean(false));
      portletRequest.setAttribute(""String_Node_Str"",new Boolean(false));
      template.put(""String_Node_Str"",assetEntry.getClassName());
      template.put(""String_Node_Str"",assetEntry.getClassPK());
    }
 else {
      portletRequest.setAttribute(WebKeys.PORTLET_CONFIGURATOR_VISIBILITY,Boolean.TRUE);
    }
    template.put(""String_Node_Str"",isMatchingRule);
    template.put(""String_Node_Str"",LiferayWindowState.POP_UP);
  }
 else   if (path.equals(CampaignContentDisplayPath.EDIT_QUERY_RULE) || path.equals(CampaignContentDisplayPath.CONFIGURATION)) {
    template.put(""String_Node_Str"",getSelectableAssetRendererFactories(themeDisplay.getCompanyId()));
    String assetImageDefault=StringPool.BLANK;
    String assetTitleDefault=StringPool.BLANK;
    String assetTypeDefault=StringPool.BLANK;
    if (assetEntryIdDefault > 0) {
      AssetEntry assetEntry=AssetEntryLocalServiceUtil.fetchAssetEntry(assetEntryIdDefault);
      AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(assetEntry.getClassName());
      AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(assetEntry.getClassPK());
      assetImageDefault=assetRenderer.getThumbnailPath(portletRequest);
      assetTitleDefault=assetRenderer.getTitle(themeDisplay.getLocale());
      assetTypeDefault=assetRendererFactory.getTypeName(themeDisplay.getLocale(),true);
    }
    List<Campaign> campaigns=_campaignService.getCampaigns(themeDisplay.getScopeGroupId());
    template.put(""String_Node_Str"",campaigns);
    template.put(""String_Node_Str"",assetEntryIdDefault);
    template.put(""String_Node_Str"",assetImageDefault);
    template.put(""String_Node_Str"",assetTitleDefault);
    template.put(""String_Node_Str"",assetTypeDefault);
    template.put(""String_Node_Str"",contentDefaultValue);
    template.put(""String_Node_Str"",LiferayWindowState.EXCLUSIVE);
    template.put(""String_Node_Str"",portletPreferences);
    int[] queryRulesIndexes=GetterUtil.getIntegerValues(portletPreferences.getValues(""String_Node_Str"",null),new int[]{0});
    template.put(""String_Node_Str"",queryRulesIndexes);
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
  }
}","protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template,TemplateHashModel staticModels) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
  PortletPreferences portletPreferences=portletRequest.getPreferences();
  long assetEntryIdDefault=GetterUtil.getLong(portletPreferences.getValue(""String_Node_Str"",null));
  boolean contentDefaultValue=GetterUtil.getBoolean(portletPreferences.getValue(""String_Node_Str"",null));
  if (Validator.isNull(path) || path.equals(CampaignContentDisplayPath.VIEW)) {
    CampaignQueryRule queryRule=null;
    long[] userSegmentIds=(long[])portletRequest.getAttribute(WebKeys.USER_SEGMENT_IDS);
    if (userSegmentIds != null) {
      long[] groupIds=ContentTargetingUtil.getAncestorsAndCurrentGroupIds(themeDisplay.getSiteGroupId());
      Campaign campaign=_campaignLocalService.fetchCurrentMaxPriorityCampaign(groupIds,userSegmentIds);
      if (campaign != null) {
        queryRule=CampaignQueryRuleUtil.match(campaign.getCampaignId(),portletPreferences,themeDisplay.getLocale());
        template.put(""String_Node_Str"",Campaign.class.getName());
        template.put(""String_Node_Str"",campaign.getCampaignId());
        template.put(""String_Node_Str"",campaign.getGroupId());
      }
    }
    boolean isMatchingRule=false;
    if ((queryRule != null) || (contentDefaultValue && (assetEntryIdDefault > 0))) {
      isMatchingRule=true;
      long assetEntryId=assetEntryIdDefault;
      if (queryRule != null) {
        assetEntryId=queryRule.getAssetEntryId();
      }
      AssetEntry assetEntry=AssetEntryLocalServiceUtil.fetchAssetEntry(assetEntryId);
      AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(assetEntry.getClassName());
      AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(assetEntry.getClassPK());
      portletRequest.setAttribute(""String_Node_Str"",new ArrayList());
      portletRequest.setAttribute(""String_Node_Str"",new Integer(0));
      portletRequest.setAttribute(""String_Node_Str"",assetEntry);
      portletRequest.setAttribute(""String_Node_Str"",assetRendererFactory);
      portletRequest.setAttribute(""String_Node_Str"",assetRenderer);
      portletRequest.setAttribute(""String_Node_Str"",assetEntry.getTitle(themeDisplay.getLocale()));
      portletRequest.setAttribute(""String_Node_Str"",new Boolean(false));
      portletRequest.setAttribute(""String_Node_Str"",new Boolean(false));
      template.put(""String_Node_Str"",assetEntry.getClassName());
      template.put(""String_Node_Str"",assetEntry.getClassPK());
    }
 else {
      portletRequest.setAttribute(WebKeys.PORTLET_CONFIGURATOR_VISIBILITY,Boolean.TRUE);
    }
    template.put(""String_Node_Str"",isMatchingRule);
    template.put(""String_Node_Str"",LiferayWindowState.POP_UP);
  }
 else   if (path.equals(CampaignContentDisplayPath.EDIT_QUERY_RULE) || path.equals(CampaignContentDisplayPath.CONFIGURATION)) {
    template.put(""String_Node_Str"",getSelectableAssetRendererFactories(themeDisplay.getCompanyId()));
    String assetImageDefault=StringPool.BLANK;
    String assetTitleDefault=StringPool.BLANK;
    String assetTypeDefault=StringPool.BLANK;
    if (assetEntryIdDefault > 0) {
      AssetEntry assetEntry=AssetEntryLocalServiceUtil.fetchAssetEntry(assetEntryIdDefault);
      AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(assetEntry.getClassName());
      AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(assetEntry.getClassPK());
      assetImageDefault=assetRenderer.getThumbnailPath(portletRequest);
      assetTitleDefault=assetRenderer.getTitle(themeDisplay.getLocale());
      assetTypeDefault=assetRendererFactory.getTypeName(themeDisplay.getLocale(),true);
    }
    List<Campaign> campaigns=_campaignService.getCampaigns(themeDisplay.getScopeGroupId());
    template.put(""String_Node_Str"",campaigns);
    template.put(""String_Node_Str"",assetEntryIdDefault);
    template.put(""String_Node_Str"",assetImageDefault);
    template.put(""String_Node_Str"",assetTitleDefault);
    template.put(""String_Node_Str"",assetTypeDefault);
    template.put(""String_Node_Str"",contentDefaultValue);
    template.put(""String_Node_Str"",LiferayWindowState.EXCLUSIVE);
    template.put(""String_Node_Str"",portletPreferences);
    int[] queryRulesIndexes=GetterUtil.getIntegerValues(portletPreferences.getValues(""String_Node_Str"",null),new int[0]);
    template.put(""String_Node_Str"",queryRulesIndexes);
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
  }
}",0.9995835935873412
135780,"protected List<UserSegmentQueryRule> getUserSegmentQueryRule(PortletPreferences portletPreferences,long assetEntryIdDefault,Locale locale) throws PortalException, SystemException {
  List<UserSegmentQueryRule> userSegmentQueryRules=new ArrayList<UserSegmentQueryRule>();
  int[] queryRulesIndexes=GetterUtil.getIntegerValues(portletPreferences.getValues(""String_Node_Str"",null),new int[]{0});
  for (  int queryRulesIndex : queryRulesIndexes) {
    UserSegmentQueryRule userSegmentQueryRule=UserSegmentQueryRuleUtil.getQueryRule(portletPreferences,queryRulesIndex,locale);
    userSegmentQueryRules.add(userSegmentQueryRule);
  }
  if (assetEntryIdDefault > 0) {
    UserSegmentQueryRule userSegmentQueryRule=new UserSegmentQueryRule(true,true,assetEntryIdDefault,null,-1,locale);
    userSegmentQueryRules.add(userSegmentQueryRule);
  }
  return userSegmentQueryRules;
}","protected List<UserSegmentQueryRule> getUserSegmentQueryRule(PortletPreferences portletPreferences,long assetEntryIdDefault,Locale locale) throws PortalException, SystemException {
  List<UserSegmentQueryRule> userSegmentQueryRules=new ArrayList<UserSegmentQueryRule>();
  int[] queryRulesIndexes=GetterUtil.getIntegerValues(portletPreferences.getValues(""String_Node_Str"",null),new int[0]);
  for (  int queryRulesIndex : queryRulesIndexes) {
    UserSegmentQueryRule userSegmentQueryRule=UserSegmentQueryRuleUtil.getQueryRule(portletPreferences,queryRulesIndex,locale);
    if (userSegmentQueryRule.getAssetEntry() != null) {
      userSegmentQueryRules.add(userSegmentQueryRule);
    }
  }
  if (assetEntryIdDefault > 0) {
    UserSegmentQueryRule userSegmentQueryRule=new UserSegmentQueryRule(true,true,assetEntryIdDefault,null,-1,locale);
    userSegmentQueryRules.add(userSegmentQueryRule);
  }
  return userSegmentQueryRules;
}",0.9390243902439024
135781,"protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template,TemplateHashModel staticModels) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
  if (Validator.isNull(path) || path.equals(ContentTargetingPath.VIEW) || path.equals(ContentTargetingPath.VIEW_CAMPAIGNS_RESOURCES)|| path.equals(ContentTargetingPath.VIEW_USER_SEGMENTS_RESOURCES)) {
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str""));
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
    template.put(""String_Node_Str"",new RowChecker(portletResponse));
    String keywords=ParamUtil.getString(portletRequest,""String_Node_Str"");
    template.put(""String_Node_Str"",new CampaignSearchContainerIterator(themeDisplay.getSiteGroupIdOrLiveGroupId(),keywords));
    template.put(""String_Node_Str"",new UserSegmentSearchContainerIterator(themeDisplay.getSiteGroupIdOrLiveGroupId(),keywords));
    template.put(""String_Node_Str"",UsedUserSegmentException.class);
  }
 else   if (path.equals(ContentTargetingPath.EDIT_CAMPAIGN)) {
    long campaignId=ParamUtil.getLong(portletRequest,""String_Node_Str"");
    template.put(""String_Node_Str"",campaignId);
    int priority=1;
    long userSegmentId=-1;
    if (campaignId > 0) {
      Campaign campaign=_campaignLocalService.getCampaign(campaignId);
      template.put(""String_Node_Str"",campaign);
      List<UserSegment> campaignUserSegments=_userSegmentLocalService.getCampaignUserSegments(campaignId);
      priority=campaign.getPriority();
      if ((campaignUserSegments != null) && !campaignUserSegments.isEmpty()) {
        UserSegment campaignUserSegment=campaignUserSegments.get(0);
        userSegmentId=campaignUserSegment.getUserSegmentId();
      }
    }
    template.put(""String_Node_Str"",priority);
    template.put(""String_Node_Str"",userSegmentId);
    long[] groupIds=ContentTargetingUtil.getAncestorsAndCurrentGroupIds(themeDisplay.getScopeGroupId());
    List<UserSegment> userSegments=_userSegmentService.getUserSegments(groupIds);
    template.put(""String_Node_Str"",userSegments);
    template.put(""String_Node_Str"",_trackingActionsRegistry);
    Map<String,TrackingAction> trackingActions=_trackingActionsRegistry.getTrackingActions();
    boolean isolated=themeDisplay.isIsolated();
    try {
      themeDisplay.setIsolated(true);
      template.put(""String_Node_Str"",trackingActions.values());
      if (campaignId > 0) {
        List<TrackingActionInstance> instances=_trackingActionInstanceService.getTrackingActionInstances(campaignId);
        template.put(""String_Node_Str"",instances);
        List<TrackingActionTemplate> addedTrackingActionTemplates=new ArrayList<TrackingActionTemplate>();
        for (        TrackingActionInstance instance : instances) {
          TrackingAction trackingAction=_trackingActionsRegistry.getTrackingAction(instance.getTrackingActionKey());
          TrackingActionTemplate trackingActionTemplate=new TrackingActionTemplate();
          String html=trackingAction.getFormHTML(instance,_cloneTemplateContext(template));
          trackingActionTemplate.setInstanceId(instance.getTrackingActionInstanceId());
          trackingActionTemplate.setTrackingAction(trackingAction);
          trackingActionTemplate.setTemplate(HtmlUtil.escapeAttribute(html));
          addedTrackingActionTemplates.add(trackingActionTemplate);
        }
        template.put(""String_Node_Str"",addedTrackingActionTemplates);
      }
      List<TrackingActionTemplate> trackingActionTemplates=new ArrayList<TrackingActionTemplate>();
      for (      TrackingAction trackingAction : trackingActions.values()) {
        TrackingActionTemplate trackingActionTemplate=new TrackingActionTemplate();
        String html=trackingAction.getFormHTML(null,_cloneTemplateContext(template));
        trackingActionTemplate.setTrackingAction(trackingAction);
        trackingActionTemplate.setTemplate(HtmlUtil.escapeAttribute(html));
        trackingActionTemplates.add(trackingActionTemplate);
      }
      template.put(""String_Node_Str"",trackingActionTemplates);
    }
  finally {
      themeDisplay.setIsolated(isolated);
    }
  }
 else   if (path.equals(ContentTargetingPath.EDIT_USER_SEGMENT)) {
    long userSegmentId=ParamUtil.getLong(portletRequest,""String_Node_Str"");
    template.put(""String_Node_Str"",userSegmentId);
    template.put(""String_Node_Str"",_rulesRegistry);
    Map<String,Rule> rules=_rulesRegistry.getRules();
    boolean isolated=themeDisplay.isIsolated();
    try {
      themeDisplay.setIsolated(true);
      template.put(""String_Node_Str"",rules.values());
      if (userSegmentId > 0) {
        List<RuleInstance> ruleInstances=_ruleInstanceService.getRuleInstances(userSegmentId);
        template.put(""String_Node_Str"",ruleInstances);
        List<RuleTemplate> addedRuleTemplates=new ArrayList<RuleTemplate>();
        for (        RuleInstance ruleInstance : ruleInstances) {
          Rule rule=_rulesRegistry.getRule(ruleInstance.getRuleKey());
          RuleTemplate ruleTemplate=new RuleTemplate();
          String html=rule.getFormHTML(ruleInstance,_cloneTemplateContext(template));
          ruleTemplate.setInstanceId(ruleInstance.getRuleInstanceId());
          ruleTemplate.setRule(rule);
          ruleTemplate.setTemplate(HtmlUtil.escapeAttribute(html));
          addedRuleTemplates.add(ruleTemplate);
        }
        template.put(""String_Node_Str"",addedRuleTemplates);
        UserSegment userSegment=_userSegmentLocalService.getUserSegment(userSegmentId);
        template.put(""String_Node_Str"",userSegment);
      }
      List<RuleTemplate> ruleTemplates=new ArrayList<RuleTemplate>();
      for (      Rule rule : rules.values()) {
        RuleTemplate ruleTemplate=new RuleTemplate();
        String html=rule.getFormHTML(null,_cloneTemplateContext(template));
        ruleTemplate.setRule(rule);
        ruleTemplate.setTemplate(HtmlUtil.escapeAttribute(html));
        ruleTemplates.add(ruleTemplate);
      }
      template.put(""String_Node_Str"",ruleTemplates);
    }
  finally {
      themeDisplay.setIsolated(isolated);
    }
  }
 else   if (path.equals(ContentTargetingPath.VIEW_REPORT) || path.equals(ContentTargetingPath.VIEW_REPORTS)) {
    String className=ParamUtil.getString(portletRequest,""String_Node_Str"");
    long classPK=ParamUtil.getLong(portletRequest,""String_Node_Str"");
    template.put(""String_Node_Str"",className);
    template.put(""String_Node_Str"",classPK);
    if (path.equals(ContentTargetingPath.VIEW_REPORT)) {
      String reportKey=ParamUtil.getString(portletRequest,""String_Node_Str"");
      Report report=_reportsRegistry.getReport(reportKey);
      template.put(""String_Node_Str"",report);
      template.put(""String_Node_Str"",report.getHTML(_cloneTemplateContext(template)));
    }
    if (path.equals(ContentTargetingPath.VIEW_REPORTS)) {
      String title=""String_Node_Str"";
      if (className.equals(Campaign.class.getName())) {
        Campaign campaign=_campaignLocalService.getCampaign(classPK);
        title=LanguageUtil.format(themeDisplay.getLocale(),""String_Node_Str"",campaign.getName(themeDisplay.getLocale()));
      }
 else       if (className.equals(UserSegment.class.getName())) {
        UserSegment userSegment=_userSegmentLocalService.getUserSegment(classPK);
        title=LanguageUtil.format(themeDisplay.getLocale(),""String_Node_Str"",userSegment.getName(themeDisplay.getLocale()),false);
      }
      template.put(""String_Node_Str"",title);
      template.put(""String_Node_Str"",new ReportSearchContainerIterator(themeDisplay.getScopeGroupId(),null,className));
    }
  }
}","protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template,TemplateHashModel staticModels) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
  if (Validator.isNull(path) || path.equals(ContentTargetingPath.VIEW) || path.equals(ContentTargetingPath.VIEW_CAMPAIGNS_RESOURCES)|| path.equals(ContentTargetingPath.VIEW_USER_SEGMENTS_RESOURCES)) {
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str""));
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
    template.put(""String_Node_Str"",staticModels.get(""String_Node_Str"" + ""String_Node_Str""));
    template.put(""String_Node_Str"",new RowChecker(portletResponse));
    String keywords=ParamUtil.getString(portletRequest,""String_Node_Str"");
    template.put(""String_Node_Str"",new CampaignSearchContainerIterator(themeDisplay.getSiteGroupIdOrLiveGroupId(),keywords));
    template.put(""String_Node_Str"",new UserSegmentSearchContainerIterator(themeDisplay.getSiteGroupIdOrLiveGroupId(),keywords));
    template.put(""String_Node_Str"",UsedUserSegmentException.class);
  }
 else   if (path.equals(ContentTargetingPath.EDIT_CAMPAIGN)) {
    long campaignId=ParamUtil.getLong(portletRequest,""String_Node_Str"");
    template.put(""String_Node_Str"",campaignId);
    int priority=1;
    long userSegmentId=-1;
    if (campaignId > 0) {
      Campaign campaign=_campaignLocalService.getCampaign(campaignId);
      template.put(""String_Node_Str"",campaign);
      List<UserSegment> campaignUserSegments=_userSegmentLocalService.getCampaignUserSegments(campaignId);
      priority=campaign.getPriority();
      if ((campaignUserSegments != null) && !campaignUserSegments.isEmpty()) {
        UserSegment campaignUserSegment=campaignUserSegments.get(0);
        userSegmentId=campaignUserSegment.getUserSegmentId();
      }
    }
    template.put(""String_Node_Str"",priority);
    template.put(""String_Node_Str"",userSegmentId);
    long[] groupIds=ContentTargetingUtil.getAncestorsAndCurrentGroupIds(themeDisplay.getScopeGroupId());
    List<UserSegment> userSegments=_userSegmentService.getUserSegments(groupIds);
    template.put(""String_Node_Str"",userSegments);
    template.put(""String_Node_Str"",_trackingActionsRegistry);
    Map<String,TrackingAction> trackingActions=_trackingActionsRegistry.getTrackingActions();
    boolean isolated=themeDisplay.isIsolated();
    try {
      themeDisplay.setIsolated(true);
      template.put(""String_Node_Str"",trackingActions.values());
      if (campaignId > 0) {
        List<TrackingActionInstance> instances=_trackingActionInstanceService.getTrackingActionInstances(campaignId);
        template.put(""String_Node_Str"",instances);
        List<TrackingActionTemplate> addedTrackingActionTemplates=new ArrayList<TrackingActionTemplate>();
        for (        TrackingActionInstance instance : instances) {
          TrackingAction trackingAction=_trackingActionsRegistry.getTrackingAction(instance.getTrackingActionKey());
          TrackingActionTemplate trackingActionTemplate=new TrackingActionTemplate();
          String html=trackingAction.getFormHTML(instance,_cloneTemplateContext(template));
          trackingActionTemplate.setInstanceId(instance.getTrackingActionInstanceId());
          trackingActionTemplate.setTrackingAction(trackingAction);
          trackingActionTemplate.setTemplate(HtmlUtil.escapeAttribute(html));
          addedTrackingActionTemplates.add(trackingActionTemplate);
        }
        template.put(""String_Node_Str"",addedTrackingActionTemplates);
      }
      List<TrackingActionTemplate> trackingActionTemplates=new ArrayList<TrackingActionTemplate>();
      for (      TrackingAction trackingAction : trackingActions.values()) {
        TrackingActionTemplate trackingActionTemplate=new TrackingActionTemplate();
        String html=trackingAction.getFormHTML(null,_cloneTemplateContext(template));
        trackingActionTemplate.setTrackingAction(trackingAction);
        trackingActionTemplate.setTemplate(HtmlUtil.escapeAttribute(html));
        trackingActionTemplates.add(trackingActionTemplate);
      }
      template.put(""String_Node_Str"",trackingActionTemplates);
    }
  finally {
      themeDisplay.setIsolated(isolated);
    }
  }
 else   if (path.equals(ContentTargetingPath.EDIT_USER_SEGMENT)) {
    long userSegmentId=ParamUtil.getLong(portletRequest,""String_Node_Str"");
    template.put(""String_Node_Str"",userSegmentId);
    template.put(""String_Node_Str"",_rulesRegistry);
    Map<String,Rule> rules=_rulesRegistry.getRules();
    boolean isolated=themeDisplay.isIsolated();
    try {
      themeDisplay.setIsolated(true);
      template.put(""String_Node_Str"",rules.values());
      if (userSegmentId > 0) {
        List<RuleInstance> ruleInstances=_ruleInstanceService.getRuleInstances(userSegmentId);
        template.put(""String_Node_Str"",ruleInstances);
        List<RuleTemplate> addedRuleTemplates=new ArrayList<RuleTemplate>();
        for (        RuleInstance ruleInstance : ruleInstances) {
          Rule rule=_rulesRegistry.getRule(ruleInstance.getRuleKey());
          RuleTemplate ruleTemplate=new RuleTemplate();
          String html=rule.getFormHTML(ruleInstance,_cloneTemplateContext(template));
          ruleTemplate.setInstanceId(ruleInstance.getRuleInstanceId());
          ruleTemplate.setRule(rule);
          ruleTemplate.setTemplate(HtmlUtil.escapeAttribute(html));
          addedRuleTemplates.add(ruleTemplate);
        }
        template.put(""String_Node_Str"",addedRuleTemplates);
        UserSegment userSegment=_userSegmentLocalService.getUserSegment(userSegmentId);
        template.put(""String_Node_Str"",userSegment);
      }
      List<RuleTemplate> ruleTemplates=new ArrayList<RuleTemplate>();
      for (      Rule rule : rules.values()) {
        RuleTemplate ruleTemplate=new RuleTemplate();
        String html=rule.getFormHTML(null,_cloneTemplateContext(template));
        ruleTemplate.setRule(rule);
        ruleTemplate.setTemplate(HtmlUtil.escapeAttribute(html));
        ruleTemplates.add(ruleTemplate);
      }
      template.put(""String_Node_Str"",ruleTemplates);
    }
  finally {
      themeDisplay.setIsolated(isolated);
    }
  }
 else   if (path.equals(ContentTargetingPath.VIEW_REPORT) || path.equals(ContentTargetingPath.VIEW_REPORTS)) {
    String className=ParamUtil.getString(portletRequest,""String_Node_Str"");
    long classPK=ParamUtil.getLong(portletRequest,""String_Node_Str"");
    template.put(""String_Node_Str"",className);
    template.put(""String_Node_Str"",classPK);
    if (path.equals(ContentTargetingPath.VIEW_REPORT)) {
      String reportKey=ParamUtil.getString(portletRequest,""String_Node_Str"");
      Report report=_reportsRegistry.getReport(reportKey);
      template.put(""String_Node_Str"",report);
      template.put(""String_Node_Str"",report.getHTML(_cloneTemplateContext(template)));
    }
    if (path.equals(ContentTargetingPath.VIEW_REPORTS)) {
      PortletConfig portletConfig=(PortletConfig)portletRequest.getAttribute(JavaConstants.JAVAX_PORTLET_CONFIG);
      String title=""String_Node_Str"";
      if (className.equals(Campaign.class.getName())) {
        Campaign campaign=_campaignLocalService.getCampaign(classPK);
        title=LanguageUtil.format(portletConfig,themeDisplay.getLocale(),""String_Node_Str"",campaign.getName(themeDisplay.getLocale()));
      }
 else       if (className.equals(UserSegment.class.getName())) {
        UserSegment userSegment=_userSegmentLocalService.getUserSegment(classPK);
        title=LanguageUtil.format(portletConfig,themeDisplay.getLocale(),""String_Node_Str"",userSegment.getName(themeDisplay.getLocale()),false);
      }
      template.put(""String_Node_Str"",title);
      template.put(""String_Node_Str"",new ReportSearchContainerIterator(themeDisplay.getScopeGroupId(),null,className));
    }
  }
}",0.9910804020100502
135782,"public static Map<String,Object> getAssetSelectorIconData(HttpServletRequest request,AssetRendererFactory assetRendererFactory,String index) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)request.getAttribute(WebKeys.THEME_DISPLAY);
  PortletURL assetBrowserURL=getAssetBrowserURL(request,assetRendererFactory.getClassName());
  String typeName=assetRendererFactory.getTypeName(themeDisplay.getLocale(),false);
  Map<String,Object> data=new HashMap<String,Object>();
  data.put(""String_Node_Str"",String.valueOf(themeDisplay.getScopeGroupId()));
  data.put(""String_Node_Str"",assetBrowserURL.toString());
  data.put(""String_Node_Str"",index);
  data.put(""String_Node_Str"",LanguageUtil.format(themeDisplay.getLocale(),""String_Node_Str"",typeName,false));
  data.put(""String_Node_Str"",typeName);
  return data;
}","public static Map<String,Object> getAssetSelectorIconData(HttpServletRequest request,AssetRendererFactory assetRendererFactory,String index) throws Exception {
  PortletConfig portletConfig=(PortletConfig)request.getAttribute(JavaConstants.JAVAX_PORTLET_CONFIG);
  ThemeDisplay themeDisplay=(ThemeDisplay)request.getAttribute(WebKeys.THEME_DISPLAY);
  PortletURL assetBrowserURL=getAssetBrowserURL(request,assetRendererFactory.getClassName());
  String typeName=assetRendererFactory.getTypeName(themeDisplay.getLocale(),false);
  Map<String,Object> data=new HashMap<String,Object>();
  data.put(""String_Node_Str"",String.valueOf(themeDisplay.getScopeGroupId()));
  data.put(""String_Node_Str"",assetBrowserURL.toString());
  data.put(""String_Node_Str"",index);
  data.put(""String_Node_Str"",LanguageUtil.format(portletConfig,themeDisplay.getLocale(),""String_Node_Str"",typeName,false));
  data.put(""String_Node_Str"",typeName);
  return data;
}",0.93340922026181
135783,"public String getSummary(Locale locale) throws SystemException {
  String userSegmentQueryRuleContains=_contains ? ""String_Node_Str"" : ""String_Node_Str"";
  String userSegmentQueryRuleAndOperator=_andOperator ? ""String_Node_Str"" : ""String_Node_Str"";
  return UnicodeLanguageUtil.format(locale,""String_Node_Str"",new Object[]{userSegmentQueryRuleContains,userSegmentQueryRuleAndOperator,getUserSegmentNames(locale)},true);
}","public String getSummary(PortletConfig portletConfig,Locale locale) throws SystemException {
  String userSegmentQueryRuleContains=_contains ? ""String_Node_Str"" : ""String_Node_Str"";
  String userSegmentQueryRuleAndOperator=_andOperator ? ""String_Node_Str"" : ""String_Node_Str"";
  return UnicodeLanguageUtil.format(portletConfig,locale,""String_Node_Str"",new Object[]{userSegmentQueryRuleContains,userSegmentQueryRuleAndOperator,getUserSegmentNames(locale)},true);
}",0.9524886877828054
135784,"protected List<Campaign> doFetchByG_D_A_U(long[] groupIds,Date date,boolean active,long[] userSegmentIds,boolean inlineSQLHelper) throws SystemException {
  Session session=null;
  try {
    session=openSession();
    CustomSQLUtil.reloadCustomSQL();
    String sql=CustomSQLUtil.get(FIND_BY_G_D_A_U);
    sql=StringUtil.replace(sql,""String_Node_Str"",getGroupIds(groupIds));
    sql=StringUtil.replace(sql,""String_Node_Str"",StringUtil.merge(userSegmentIds));
    if (inlineSQLHelper) {
      sql=InlineSQLHelperUtil.replacePermissionCheck(sql,Campaign.class.getName(),""String_Node_Str"",groupIds);
    }
    SQLQuery q=session.createSQLQuery(sql);
    q.addEntity(""String_Node_Str"",CampaignImpl.class);
    QueryPos qPos=QueryPos.getInstance(q);
    qPos.add(groupIds);
    qPos.add(date);
    qPos.add(date);
    qPos.add(active);
    return q.list();
  }
 catch (  Exception e) {
    throw new SystemException(e);
  }
 finally {
    closeSession(session);
  }
}","protected List<Campaign> doFetchByG_D_A_U(long[] groupIds,Date date,boolean active,long[] userSegmentIds,boolean inlineSQLHelper) throws SystemException {
  if ((userSegmentIds == null) || (userSegmentIds.length == 0)) {
    return Collections.emptyList();
  }
  Session session=null;
  try {
    session=openSession();
    CustomSQLUtil.reloadCustomSQL();
    String sql=CustomSQLUtil.get(FIND_BY_G_D_A_U);
    sql=StringUtil.replace(sql,""String_Node_Str"",getGroupIds(groupIds));
    sql=StringUtil.replace(sql,""String_Node_Str"",StringUtil.merge(userSegmentIds));
    if (inlineSQLHelper) {
      sql=InlineSQLHelperUtil.replacePermissionCheck(sql,Campaign.class.getName(),""String_Node_Str"",groupIds);
    }
    SQLQuery q=session.createSQLQuery(sql);
    q.addEntity(""String_Node_Str"",CampaignImpl.class);
    QueryPos qPos=QueryPos.getInstance(q);
    qPos.add(groupIds);
    qPos.add(date);
    qPos.add(date);
    qPos.add(active);
    return q.list();
  }
 catch (  Exception e) {
    throw new SystemException(e);
  }
 finally {
    closeSession(session);
  }
}",0.9477832512315272
135785,"@Override public int compareTo(com.liferay.geolocation.model.Geolocation geolocation){
  return _geolocation.compareTo(geolocation);
}","@Override public int compareTo(Geolocation geolocation){
  return _geolocation.compareTo(geolocation);
}",0.8739495798319328
135786,"@Override public com.liferay.portal.model.CacheModel<com.liferay.geolocation.model.Geolocation> toCacheModel(){
  return _geolocation.toCacheModel();
}","@Override public com.liferay.portal.model.CacheModel<Geolocation> toCacheModel(){
  return _geolocation.toCacheModel();
}",0.8897058823529411
135787,"@Override public com.liferay.geolocation.model.Geolocation toUnescapedModel(){
  return new GeolocationWrapper(_geolocation.toUnescapedModel());
}","@Override public Geolocation toUnescapedModel(){
  return new GeolocationWrapper(_geolocation.toUnescapedModel());
}",0.8854961832061069
135788,"@Override public com.liferay.geolocation.model.Geolocation toEscapedModel(){
  return new GeolocationWrapper(_geolocation.toEscapedModel());
}","@Override public Geolocation toEscapedModel(){
  return new GeolocationWrapper(_geolocation.toEscapedModel());
}",0.8818897637795275
135789,"@Override protected void populateContext(RuleInstance ruleInstance,Map<String,Object> context){
  if (ruleInstance != null) {
    String typeSettings=ruleInstance.getTypeSettings();
    try {
      JSONObject jsonObj=JSONFactoryUtil.createJSONObject(typeSettings);
      context.put(""String_Node_Str"",jsonObj.getInt(""String_Node_Str""));
      Locale locale=(Locale)context.get(""String_Node_Str"");
      context.put(""String_Node_Str"",ruleInstance.getUserSegmentName(locale));
    }
 catch (    JSONException jse) {
    }
  }
 else {
    context.put(""String_Node_Str"",0);
  }
}","@Override protected void populateContext(RuleInstance ruleInstance,Map<String,Object> context){
  if (ruleInstance != null) {
    String typeSettings=ruleInstance.getTypeSettings();
    try {
      JSONObject jsonObj=JSONFactoryUtil.createJSONObject(typeSettings);
      context.put(""String_Node_Str"",jsonObj.getInt(""String_Node_Str""));
    }
 catch (    JSONException jse) {
    }
  }
 else {
    context.put(""String_Node_Str"",0);
  }
}",0.8636363636363636
135790,"public String getAssetImage(PortletRequest portletRequest) throws Exception {
  AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(_assetClassName);
  AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(_assetClassPK);
  return assetRenderer.getThumbnailPath(portletRequest);
}","public String getAssetImage(PortletRequest portletRequest) throws Exception {
  if (!isValid()) {
    return StringPool.BLANK;
  }
  AssetRendererFactory assetRendererFactory=AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClassName(_assetClassName);
  AssetRenderer assetRenderer=assetRendererFactory.getAssetRenderer(_assetClassPK);
  return assetRenderer.getThumbnailPath(portletRequest);
}",0.9296148738379814
135791,"@Override public String getSummary(RuleInstance ruleInstance,Locale locale){
  String typeSettings=ruleInstance.getTypeSettings();
  Format format=FastDateFormatFactoryUtil.getSimpleDateFormat(_SIMPLE_DATE_FORMAT_PATTERN,locale);
  StringBundler sb=new StringBundler(4);
  try {
    JSONObject jsonObj=JSONFactoryUtil.createJSONObject(typeSettings);
    Calendar startCalendar=CalendarFactoryUtil.getCalendar(1970,0,1,jsonObj.getInt(""String_Node_Str""),jsonObj.getInt(""String_Node_Str""));
    Calendar endCalendar=CalendarFactoryUtil.getCalendar(1970,0,1,jsonObj.getInt(""String_Node_Str""),jsonObj.getInt(""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(format.format(startCalendar.getTime()));
    sb.append(""String_Node_Str"");
    sb.append(format.format(endCalendar.getTime()));
  }
 catch (  JSONException jse) {
  }
  return sb.toString();
}","@Override public String getSummary(RuleInstance ruleInstance,Locale locale){
  String typeSettings=ruleInstance.getTypeSettings();
  Format format=FastDateFormatFactoryUtil.getSimpleDateFormat(_SIMPLE_DATE_FORMAT_PATTERN,locale);
  StringBundler sb=new StringBundler(4);
  try {
    JSONObject jsonObj=JSONFactoryUtil.createJSONObject(typeSettings);
    int startTimeHour=jsonObj.getInt(""String_Node_Str"");
    int startTimeMinute=jsonObj.getInt(""String_Node_Str"");
    int startTimeAmPm=jsonObj.getInt(""String_Node_Str"");
    if (startTimeAmPm == Calendar.PM) {
      startTimeHour+=12;
    }
    Calendar startCalendar=CalendarFactoryUtil.getCalendar(1970,0,1,startTimeHour,startTimeMinute);
    int endTimeHour=jsonObj.getInt(""String_Node_Str"");
    int endTimeMinute=jsonObj.getInt(""String_Node_Str"");
    int endTimeAmPm=jsonObj.getInt(""String_Node_Str"");
    if (endTimeAmPm == Calendar.PM) {
      endTimeHour+=12;
    }
    Calendar endCalendar=CalendarFactoryUtil.getCalendar(1970,0,1,endTimeHour,endTimeMinute);
    sb.append(""String_Node_Str"");
    sb.append(format.format(startCalendar.getTime()));
    sb.append(""String_Node_Str"");
    sb.append(format.format(endCalendar.getTime()));
  }
 catch (  JSONException jse) {
  }
  return sb.toString();
}",0.7478833490122295
135792,"protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template) throws Exception {
  if (Validator.isNull(path) || path.equals(ContentTargetingPath.VIEW)) {
    ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
    List<UserSegment> userSegments=_userSegmentService.getUserSegments(themeDisplay.getScopeGroupId());
    template.put(""String_Node_Str"",userSegments);
  }
 else   if (path.equals(ContentTargetingPath.EDIT_RULE)) {
  }
 else   if (path.equals(ContentTargetingPath.EDIT_USER_SEGMENT)) {
    template.put(""String_Node_Str"",UserSegment.class);
    template.put(""String_Node_Str"",_rulesRegistry.getRules());
    UserSegment userSegment=null;
    long userSegmentId=ParamUtil.getLong(portletRequest,""String_Node_Str"");
    if (userSegmentId > 0) {
      userSegment=_userSegmentLocalService.getUserSegment(userSegmentId);
    }
    template.put(""String_Node_Str"",userSegment);
  }
}","protected void populateViewContext(String path,PortletRequest portletRequest,PortletResponse portletResponse,Template template) throws Exception {
  if (Validator.isNull(path) || path.equals(ContentTargetingPath.VIEW)) {
    ThemeDisplay themeDisplay=(ThemeDisplay)portletRequest.getAttribute(WebKeys.THEME_DISPLAY);
    List<UserSegment> userSegments=_userSegmentService.getUserSegments(themeDisplay.getScopeGroupId());
    template.put(""String_Node_Str"",userSegments);
  }
 else   if (path.equals(ContentTargetingPath.EDIT_RULE)) {
  }
 else   if (path.equals(ContentTargetingPath.EDIT_USER_SEGMENT)) {
    template.put(""String_Node_Str"",UserSegment.class);
    Map<String,Rule> rules=_rulesRegistry.getRules();
    template.put(""String_Node_Str"",rules.values());
    UserSegment userSegment=null;
    long userSegmentId=ParamUtil.getLong(portletRequest,""String_Node_Str"");
    if (userSegmentId > 0) {
      userSegment=_userSegmentLocalService.getUserSegment(userSegmentId);
    }
    template.put(""String_Node_Str"",userSegment);
  }
}",0.9582309582309584
135793,"@Override public void include(ServletRequest servletRequest,ServletResponse servletResponse) throws IOException, ServletException {
  BundleServletRequest bundleServletRequest=new BundleServletRequest(this,(HttpServletRequest)servletRequest);
  String contextPath=_bundleServletContext.getContextPath();
  if (_requestURI != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_INCLUDE_REQUEST_URI,_bundleServletContext.getContextPath().concat(_requestURI));
  }
  if (contextPath != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_FORWARD_CONTEXT_PATH,contextPath);
  }
  if (_servletPath != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_FORWARD_SERVLET_PATH,_servletPath);
  }
  if (_queryString != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_INCLUDE_QUERY_STRING,_queryString);
  }
  if (_pathInfo != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_INCLUDE_PATH_INFO,_pathInfo);
  }
  doDispatch(bundleServletRequest,servletResponse);
}","@Override public void include(ServletRequest servletRequest,ServletResponse servletResponse) throws IOException, ServletException {
  BundleServletRequest bundleServletRequest=new BundleServletRequest(this,(HttpServletRequest)servletRequest);
  String contextPath=_bundleServletContext.getContextPath();
  if (_requestURI != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_INCLUDE_REQUEST_URI,_bundleServletContext.getContextPath().concat(_requestURI));
  }
  if (contextPath != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_INCLUDE_CONTEXT_PATH,contextPath);
  }
  if (_servletPath != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_INCLUDE_SERVLET_PATH,_servletPath);
  }
  if (_queryString != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_INCLUDE_QUERY_STRING,_queryString);
  }
  if (_pathInfo != null) {
    bundleServletRequest.setAttribute(JavaConstants.JAVAX_SERVLET_INCLUDE_PATH_INFO,_pathInfo);
  }
  doDispatch(bundleServletRequest,servletResponse);
}",0.988785046728972
135794,"synchronized public void notifyFileChanged(){
  Log.i(""String_Node_Str"",""String_Node_Str"");
  if (timer != null) {
    timer.cancel();
  }
  timer=new Timer();
  timer.schedule(new TimerTask(){
    public void run(){
      timer=null;
      Message message=new Message();
      message.what=MSG_FILE_CHANGED_TIMER;
      handler.sendMessage(message);
    }
  }
,1000);
}","synchronized public void notifyFileChanged(){
  if (timer != null) {
    timer.cancel();
  }
  timer=new Timer();
  timer.schedule(new TimerTask(){
    public void run(){
      timer=null;
      Message message=new Message();
      message.what=MSG_FILE_CHANGED_TIMER;
      handler.sendMessage(message);
    }
  }
,1000);
}",0.9337175792507204
135795,"public void getItemSelect(){
  ArrayList<File> files=adapter.getSelectedFiles();
  if (isNormalList()) {
    int mask=MainActivity.MaskNormalListNormal;
    if (files.size() == 1) {
      File file=files.get(0);
      if (file.isDirectory()) {
        mask=MainActivity.MaskNormalListFavor;
      }
 else       if (""String_Node_Str"".equals(FileUtil.getFileSuffix(file))) {
        mask=MainActivity.MaskNormalListUnzip;
      }
    }
    Log.i(""String_Node_Str"",mask + ""String_Node_Str"");
    Intent intent=new Intent();
    intent.putExtra(FileConst.Extra_Menu_Mask,mask);
    intent.setAction(FileConst.Action_Set_File_Operation_ActionBar);
    getActivity().sendBroadcast(intent);
  }
  Log.i(""String_Node_Str"",""String_Node_Str"");
}","public void getItemSelect(){
  ArrayList<File> files=adapter.getSelectedFiles();
  if (isNormalList()) {
    int mask=MainActivity.MaskNormalListNormal;
    if (files.size() == 1) {
      File file=files.get(0);
      if (file.isDirectory()) {
        mask=MainActivity.MaskNormalListFavor;
      }
 else       if (""String_Node_Str"".equals(FileUtil.getFileSuffix(file))) {
        mask=MainActivity.MaskNormalListUnzip;
      }
    }
    Intent intent=new Intent();
    intent.putExtra(FileConst.Extra_Menu_Mask,mask);
    intent.setAction(FileConst.Action_Set_File_Operation_ActionBar);
    getActivity().sendBroadcast(intent);
  }
}",0.9262235208181154
135796,"@Override public boolean doWork(){
  try {
    String bucketName=config.getString(BUCKET_NAME_CONFIG_KEY);
    String pageContentRef=parseInput.getAttribute(PageAttribute.PAGE_CONTENT_REF).toString();
    GetObjectRequest getObjectRequest=new GetObjectRequest(bucketName,pageContentRef);
    final S3Object s3Object=retry(() -> amazonS3Client.getObject(getObjectRequest));
    final String pageContent=IOUtils.toString(s3Object.getObjectContent());
    IOUtils.closeQuietly(s3Object.getObjectContent());
    Document document=Jsoup.parse(pageContent);
    IndexInput.Builder builder=new IndexInput.Builder().withExistingAttributes(parseInput.getAttributes());
    int pageContentSize=pageContent.length();
    builder.withAttribute(PageAttribute.CONTENT_SIZE,pageContentSize);
    String title=document.title();
    if (title != null) {
      builder.withAttribute(PageAttribute.TITLE,title);
    }
    Set<String> outLinks=document.getElementsByTag(""String_Node_Str"").stream().filter(elem -> !StringUtils.equalsIgnoreCase(""String_Node_Str"",elem.attr(""String_Node_Str""))).map(elem -> elem.attr(""String_Node_Str"")).filter(StringUtils::isNotBlank).filter(link -> !StringUtils.startsWith(link,""String_Node_Str"")).filter(link -> !StringUtils.startsWith(link,""String_Node_Str"")).collect(Collectors.toSet());
    builder.withAttribute(PageAttribute.OUT_LINKS_RAW,outLinks);
    outLinks=normalizeLinks(outLinks);
    builder.withAttribute(PageAttribute.OUT_LINKS,outLinks);
    Set<String> cssLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.CSS_LINKS_RAW,cssLinks);
    cssLinks=normalizeLinks(cssLinks);
    builder.withAttribute(PageAttribute.CSS_LINKS,cssLinks);
    Set<String> jsLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.JS_LINKS_RAW,jsLinks);
    jsLinks=normalizeLinks(jsLinks);
    builder.withAttribute(PageAttribute.JS_LINKS,jsLinks);
    Set<String> imgLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.IMG_LINKS_RAW,imgLinks);
    imgLinks=normalizeLinks(imgLinks);
    builder.withAttribute(PageAttribute.IMG_LINKS,imgLinks);
    int totalPageSize=pageContentSize;
    List<String> assetLinks=new ArrayList<>(cssLinks.size() + jsLinks.size() + imgLinks.size());
    assetLinks.addAll(cssLinks);
    assetLinks.addAll(jsLinks);
    assetLinks.addAll(imgLinks);
    for (    String link : assetLinks) {
      Integer assetSize=getCachedAssetSize(link);
      if (assetSize == null && link != null) {
        final Response response=ClientBuilder.newClient().target(link).request().buildGet().invoke();
        assetSize=response.readEntity(String.class).length();
        setCachedAssetSize(link,assetSize);
      }
      if (assetSize != null) {
        totalPageSize+=assetSize;
      }
    }
    builder.withAttribute(PageAttribute.SIZE_WITH_ASSETS,totalPageSize);
    final Map<String,List<String>> linksByContentType=outLinks.stream().filter(StringUtils::isNotBlank).collect(Collectors.groupingBy(link -> {
      try {
        final Response response=ClientBuilder.newClient().target(link).request().build(""String_Node_Str"").invoke();
        final String contentType=response.getStringHeaders().getFirst(CONTENT_TYPE_HEADER_KEY);
        if (StringUtils.isNotBlank(contentType)) {
          return contentType;
        }
 else {
          return NO_CONTENT_TYPE_KEY;
        }
      }
 catch (      Exception ex) {
        logger.error(""String_Node_Str"" + link,ex);
        return EXCEPTION_KEY;
      }
    }
));
    String nextQueue=config.getString(NEXT_QUEUE_CONFIG_KEY);
    queueManager.enqueue(nextQueue,objectMapper.writeValueAsString(builder.build()));
    String fetchQueue=config.getString(FETCH_QUEUE_NAME_CONFIG_KEY);
    linksByContentType.entrySet().forEach(entry -> {
      if (StringUtils.startsWithIgnoreCase(entry.getKey(),IMAGE_CONTENT_TYPE_PREFIX) || StringUtils.equals(entry.getKey(),EXCEPTION_KEY)) {
        return;
      }
      entry.getValue().forEach(link -> {
        if (alreadySentToFetch(link) || (config.getBoolean(USE_BASE_DOMAIN_CONFIG_KEY) && DomainUtils.isBaseDomain(config.getString(BASE_DOMAIN_CONFIG_KEY),link))) {
          return;
        }
        try {
          logger.info(""String_Node_Str"" + link);
          FetchInput fetchInput=new FetchInput(link,parseInput.getAttribute(PageAttribute.ORIGINAL_URL).toString());
          queueManager.enqueue(fetchQueue,objectMapper.writeValueAsString(fetchInput));
          sentToFetch(link);
        }
 catch (        Exception ex) {
          throw new RuntimeException(ex.getMessage(),ex);
        }
      }
);
    }
);
    return true;
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    return false;
  }
}","@Override public boolean doWork(){
  try {
    String bucketName=config.getString(BUCKET_NAME_CONFIG_KEY);
    String pageContentRef=parseInput.getAttribute(PageAttribute.PAGE_CONTENT_REF).toString();
    GetObjectRequest getObjectRequest=new GetObjectRequest(bucketName,pageContentRef);
    final S3Object s3Object=retry(() -> amazonS3Client.getObject(getObjectRequest));
    final String pageContent=IOUtils.toString(s3Object.getObjectContent());
    IOUtils.closeQuietly(s3Object.getObjectContent());
    Document document=Jsoup.parse(pageContent);
    IndexInput.Builder builder=new IndexInput.Builder().withExistingAttributes(parseInput.getAttributes());
    int pageContentSize=pageContent.length();
    builder.withAttribute(PageAttribute.CONTENT_SIZE,pageContentSize);
    String title=document.title();
    if (title != null) {
      builder.withAttribute(PageAttribute.TITLE,title);
    }
    Set<String> outLinks=document.getElementsByTag(""String_Node_Str"").stream().filter(elem -> !StringUtils.equalsIgnoreCase(""String_Node_Str"",elem.attr(""String_Node_Str""))).map(elem -> elem.attr(""String_Node_Str"")).filter(StringUtils::isNotBlank).filter(link -> !StringUtils.startsWith(link,""String_Node_Str"")).filter(link -> !StringUtils.startsWith(link,""String_Node_Str"")).collect(Collectors.toSet());
    builder.withAttribute(PageAttribute.OUT_LINKS_RAW,outLinks);
    outLinks=normalizeLinks(outLinks);
    builder.withAttribute(PageAttribute.OUT_LINKS,outLinks);
    Set<String> cssLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.CSS_LINKS_RAW,cssLinks);
    cssLinks=normalizeLinks(cssLinks);
    builder.withAttribute(PageAttribute.CSS_LINKS,cssLinks);
    Set<String> jsLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.JS_LINKS_RAW,jsLinks);
    jsLinks=normalizeLinks(jsLinks);
    builder.withAttribute(PageAttribute.JS_LINKS,jsLinks);
    Set<String> imgLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.IMG_LINKS_RAW,imgLinks);
    imgLinks=normalizeLinks(imgLinks);
    builder.withAttribute(PageAttribute.IMG_LINKS,imgLinks);
    int totalPageSize=pageContentSize;
    List<String> assetLinks=new ArrayList<>(cssLinks.size() + jsLinks.size() + imgLinks.size());
    assetLinks.addAll(cssLinks);
    assetLinks.addAll(jsLinks);
    assetLinks.addAll(imgLinks);
    for (    String link : assetLinks) {
      Integer assetSize=getCachedAssetSize(link);
      if (assetSize == null && link != null) {
        final Response response=ClientBuilder.newClient().target(link).request().buildGet().invoke();
        assetSize=response.readEntity(String.class).length();
        setCachedAssetSize(link,assetSize);
      }
      if (assetSize != null) {
        totalPageSize+=assetSize;
      }
    }
    builder.withAttribute(PageAttribute.SIZE_WITH_ASSETS,totalPageSize);
    final Map<String,List<String>> linksByContentType=outLinks.stream().filter(StringUtils::isNotBlank).collect(Collectors.groupingBy(link -> {
      try {
        final Response response=ClientBuilder.newClient().target(link).request().build(""String_Node_Str"").invoke();
        final String contentType=response.getStringHeaders().getFirst(CONTENT_TYPE_HEADER_KEY);
        if (StringUtils.isNotBlank(contentType)) {
          return contentType;
        }
 else {
          return NO_CONTENT_TYPE_KEY;
        }
      }
 catch (      Exception ex) {
        logger.error(""String_Node_Str"" + link,ex);
        return EXCEPTION_KEY;
      }
    }
));
    String nextQueue=config.getString(NEXT_QUEUE_CONFIG_KEY);
    queueManager.enqueue(nextQueue,objectMapper.writeValueAsString(builder.build()));
    String fetchQueue=config.getString(FETCH_QUEUE_NAME_CONFIG_KEY);
    linksByContentType.entrySet().forEach(entry -> {
      if (StringUtils.startsWithIgnoreCase(entry.getKey(),IMAGE_CONTENT_TYPE_PREFIX) || StringUtils.equals(entry.getKey(),EXCEPTION_KEY)) {
        return;
      }
      entry.getValue().forEach(link -> {
        if (alreadySentToFetch(link) || (config.getBoolean(USE_BASE_DOMAIN_CONFIG_KEY) && !DomainUtils.isBaseDomain(config.getString(BASE_DOMAIN_CONFIG_KEY),link))) {
          return;
        }
        try {
          logger.info(""String_Node_Str"" + link);
          FetchInput fetchInput=new FetchInput(link,parseInput.getAttribute(PageAttribute.ORIGINAL_URL).toString());
          queueManager.enqueue(fetchQueue,objectMapper.writeValueAsString(fetchInput));
          sentToFetch(link);
        }
 catch (        Exception ex) {
          throw new RuntimeException(ex.getMessage(),ex);
        }
      }
);
    }
);
    return true;
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    return false;
  }
}",0.9998960390893024
135797,"@Override public boolean doWork(){
  try {
    String bucketName=config.getString(BUCKET_NAME_CONFIG_KEY);
    String pageContentRef=parseInput.getAttribute(PageAttribute.PAGE_CONTENT_REF).toString();
    GetObjectRequest getObjectRequest=new GetObjectRequest(bucketName,pageContentRef);
    final S3Object s3Object=retry(() -> amazonS3Client.getObject(getObjectRequest));
    final String pageContent=IOUtils.toString(s3Object.getObjectContent());
    IOUtils.closeQuietly(s3Object.getObjectContent());
    Document document=Jsoup.parse(pageContent);
    IndexInput.Builder builder=new IndexInput.Builder().withExistingAttributes(parseInput.getAttributes());
    int pageContentSize=pageContent.length();
    builder.withAttribute(PageAttribute.CONTENT_SIZE,pageContentSize);
    String title=document.title();
    if (title != null) {
      builder.withAttribute(PageAttribute.TITLE,title);
    }
    final Set<String> outLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.OUT_LINKS,outLinks);
    final Set<String> cssLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.CSS_LINKS,cssLinks);
    final Set<String> jsLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.JS_LINKS,jsLinks);
    final Set<String> imgLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.IMG_LINKS,imgLinks);
    int totalPageSize=pageContentSize;
    List<String> pageLinks=new ArrayList<>(cssLinks.size() + jsLinks.size() + imgLinks.size());
    pageLinks.addAll(cssLinks);
    pageLinks.addAll(jsLinks);
    pageLinks.addAll(imgLinks);
    for (    String link : pageLinks) {
      String norm=linkNormalizer.normalize(parseInput.getAttribute(PageAttribute.ORIGINAL_URL).toString(),link);
      Integer assetSize=null;
      if (norm != null) {
        assetSize=getCachedAssetSize(norm);
      }
      if (assetSize == null && norm != null) {
        final Response response=ClientBuilder.newClient().target(norm).request().buildGet().invoke();
        assetSize=response.readEntity(String.class).length();
        setCachedAssetSize(norm,assetSize);
      }
      if (assetSize != null) {
        totalPageSize+=assetSize;
      }
    }
    builder.withAttribute(PageAttribute.SIZE_WITH_ASSETS,totalPageSize);
    String nextQueue=config.getString(NEXT_QUEUE_CONFIG_KEY);
    queueManager.enqueue(nextQueue,objectMapper.writeValueAsString(builder.build()));
    String fetchQueue=config.getString(FETCH_QUEUE_NAME_CONFIG_KEY);
    outLinks.stream().map((link) -> linkNormalizer.normalize(parseInput.getAttribute(PageAttribute.ORIGINAL_URL).toString(),link)).filter(StringUtils::isNotBlank).forEach((link) -> {
      if (alreadySentToFetch(link))       return;
      try {
        logger.info(""String_Node_Str"" + link);
        FetchInput fetchInput=new FetchInput(link,parseInput.getAttribute(PageAttribute.ORIGINAL_URL).toString());
        queueManager.enqueue(fetchQueue,objectMapper.writeValueAsString(fetchInput));
        sentToFetch(link);
      }
 catch (      Exception ex) {
        throw new RuntimeException(ex.getMessage(),ex);
      }
    }
);
    return true;
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    return false;
  }
}","@Override public boolean doWork(){
  try {
    String bucketName=config.getString(BUCKET_NAME_CONFIG_KEY);
    String pageContentRef=parseInput.getAttribute(PageAttribute.PAGE_CONTENT_REF).toString();
    GetObjectRequest getObjectRequest=new GetObjectRequest(bucketName,pageContentRef);
    final S3Object s3Object=retry(() -> amazonS3Client.getObject(getObjectRequest));
    final String pageContent=IOUtils.toString(s3Object.getObjectContent());
    IOUtils.closeQuietly(s3Object.getObjectContent());
    Document document=Jsoup.parse(pageContent);
    IndexInput.Builder builder=new IndexInput.Builder().withExistingAttributes(parseInput.getAttributes());
    int pageContentSize=pageContent.length();
    builder.withAttribute(PageAttribute.CONTENT_SIZE,pageContentSize);
    String title=document.title();
    if (title != null) {
      builder.withAttribute(PageAttribute.TITLE,title);
    }
    final Set<String> outLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"").stream().filter(link -> !StringUtils.startsWith(link,""String_Node_Str"")).collect(Collectors.toSet());
    builder.withAttribute(PageAttribute.OUT_LINKS,outLinks);
    final Set<String> cssLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.CSS_LINKS,cssLinks);
    final Set<String> jsLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.JS_LINKS,jsLinks);
    final Set<String> imgLinks=collectLinks(document,""String_Node_Str"",""String_Node_Str"");
    builder.withAttribute(PageAttribute.IMG_LINKS,imgLinks);
    int totalPageSize=pageContentSize;
    List<String> pageLinks=new ArrayList<>(cssLinks.size() + jsLinks.size() + imgLinks.size());
    pageLinks.addAll(cssLinks);
    pageLinks.addAll(jsLinks);
    pageLinks.addAll(imgLinks);
    for (    String link : pageLinks) {
      String norm=linkNormalizer.normalize(parseInput.getAttribute(PageAttribute.ORIGINAL_URL).toString(),link);
      Integer assetSize=null;
      if (norm != null) {
        assetSize=getCachedAssetSize(norm);
      }
      if (assetSize == null && norm != null) {
        final Response response=ClientBuilder.newClient().target(norm).request().buildGet().invoke();
        assetSize=response.readEntity(String.class).length();
        setCachedAssetSize(norm,assetSize);
      }
      if (assetSize != null) {
        totalPageSize+=assetSize;
      }
    }
    builder.withAttribute(PageAttribute.SIZE_WITH_ASSETS,totalPageSize);
    String nextQueue=config.getString(NEXT_QUEUE_CONFIG_KEY);
    queueManager.enqueue(nextQueue,objectMapper.writeValueAsString(builder.build()));
    String fetchQueue=config.getString(FETCH_QUEUE_NAME_CONFIG_KEY);
    outLinks.stream().map((link) -> linkNormalizer.normalize(parseInput.getAttribute(PageAttribute.ORIGINAL_URL).toString(),link)).filter(StringUtils::isNotBlank).forEach((link) -> {
      if (alreadySentToFetch(link))       return;
      try {
        logger.info(""String_Node_Str"" + link);
        FetchInput fetchInput=new FetchInput(link,parseInput.getAttribute(PageAttribute.ORIGINAL_URL).toString());
        queueManager.enqueue(fetchQueue,objectMapper.writeValueAsString(fetchInput));
        sentToFetch(link);
      }
 catch (      Exception ex) {
        throw new RuntimeException(ex.getMessage(),ex);
      }
    }
);
    return true;
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    return false;
  }
}",0.9852274389352056
135798,"/** 
 * Normalizes a link extracted from a page given the page's original URI.
 * @param original The URI of the page that is being parsed
 * @param extracted The extracted link from the page
 * @return The normalized URI, or null if there was an error parsing the extracted URI.
 */
public String normalize(String original,String extracted){
  Validate.notBlank(original);
  Validate.notNull(extracted);
  if (StringUtils.startsWith(extracted,JS_PREFIX)) {
    return null;
  }
  URI originalUri=null;
  URI extractedUri=null;
  try {
    originalUri=new URI(original);
    extractedUri=new URI(extracted);
  }
 catch (  URISyntaxException ex) {
    logger.warn(""String_Node_Str"" + extracted,ex);
    return null;
  }
  UriBuilder retval=UriBuilder.fromUri(extractedUri);
  boolean hasHost=StringUtils.isNotBlank(extractedUri.getHost());
  boolean hasScheme=StringUtils.isNotBlank(extractedUri.getScheme());
  if (!hasHost) {
    retval.host(originalUri.getHost());
    String normalizedPath=normalizePath(originalUri.getPath(),extractedUri.getPath());
    retval.replacePath(normalizedPath);
  }
  if (!hasScheme) {
    retval.scheme(originalUri.getScheme());
  }
  retval.fragment(""String_Node_Str"");
  return retval.toString();
}","/** 
 * Normalizes a link extracted from a page given the page's original URI.
 * @param original The URI of the page that is being parsed
 * @param extracted The extracted link from the page
 * @return The normalized URI, or null if there was an error parsing the extracted URI.
 */
public String normalize(String original,String extracted){
  Validate.notBlank(original);
  Validate.notNull(extracted);
  if (StringUtils.startsWith(extracted,JS_PREFIX)) {
    return null;
  }
  URI originalUri=null;
  URI extractedUri=null;
  try {
    originalUri=new URI(original);
    extractedUri=new URI(extracted);
  }
 catch (  URISyntaxException ex) {
    logger.warn(""String_Node_Str"" + extracted,ex);
    return null;
  }
  UriBuilder retval=UriBuilder.fromUri(extractedUri);
  boolean hasHost=StringUtils.isNotBlank(extractedUri.getHost());
  boolean hasScheme=StringUtils.isNotBlank(extractedUri.getScheme());
  if (!hasScheme) {
    retval.scheme(originalUri.getScheme());
  }
  if (!hasHost) {
    retval.host(originalUri.getHost());
    String normalizedPath=normalizePath(originalUri.getPath(),extractedUri.getPath());
    retval.replacePath(normalizedPath);
  }
  retval.fragment(""String_Node_Str"");
  return retval.toString();
}",0.9448499594484996
135799,"private String normalizePath(String originalPath,String extractedPath){
  if (StringUtils.startsWith(extractedPath,""String_Node_Str"")) {
    originalPath=findPathDirectory(originalPath);
    while (StringUtils.startsWith(extractedPath,""String_Node_Str"") && originalPath.length() > 0) {
      originalPath=removePathChunkAtEnd(originalPath);
      extractedPath=removePathChunkAtStart(extractedPath);
    }
  }
  originalPath=StringUtils.stripEnd(originalPath,""String_Node_Str"");
  extractedPath=StringUtils.stripStart(extractedPath,""String_Node_Str"");
  return originalPath + ""String_Node_Str"" + extractedPath;
}","private String normalizePath(String originalPath,String extractedPath){
  originalPath=findPathDirectory(originalPath);
  if (StringUtils.startsWith(extractedPath,""String_Node_Str"")) {
    while (StringUtils.startsWith(extractedPath,""String_Node_Str"") && originalPath.length() > 0) {
      originalPath=removePathChunkAtEnd(originalPath);
      extractedPath=removePathChunkAtStart(extractedPath);
    }
  }
  originalPath=StringUtils.stripEnd(originalPath,""String_Node_Str"");
  extractedPath=StringUtils.stripStart(extractedPath,""String_Node_Str"");
  return originalPath + ""String_Node_Str"" + extractedPath;
}",0.8919803600654664
135800,"public boolean containsWord(char[][] matrix,String word){
  for (int i=0; i < matrix.length; i++) {
    for (int j=0; j < matrix[0].length; j++) {
      Set<Integer> used=new HashSet<>();
      if (bfs(matrix,i,j,word,used))       return true;
    }
  }
  return false;
}","public boolean containsWord(char[][] matrix,String word){
  for (int i=0; i < matrix.length; i++) {
    for (int j=0; j < matrix[0].length; j++) {
      Set<Integer> used=new HashSet<>();
      if (dfs(matrix,i,j,word,used))       return true;
    }
  }
  return false;
}",0.996309963099631
135801,"public static void main(String[] args){
  String[] words=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  char[][] matrix=new char[][]{{'t','h','i','s'},{'w','a','t','s'},{'o','a','h','g'},{'f','g','d','t'}};
  Solution solution=new Solution();
  for (  String s : words) {
    System.out.println(s + ""String_Node_Str"" + solution.containsWord(matrix,s));
  }
}","public static void main(String[] args){
  String[] words=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  char[][] matrix=new char[][]{{'t','h','i','s'},{'w','a','t','s'},{'o','a','h','g'},{'f','g','d','t'}};
  Solution solution=new Solution();
  for (  String s : words) {
    System.out.println(s + ""String_Node_Str"" + solution.containsWord(matrix,s));
  }
}",0.9319213313161876
135802,"/** 
 * Returns BiFunction which does exactly the same as the given AnnoyingBiFunction but without throwing a checked exception that that annoying one might throw. e.g.) <pre> &lt;T, U, R> R doItWithAnnoyance2(T input1, U input2) throws Exception { throw new Exception(""Annoying exception!""); } &lt;T, U, R> R doSomething(BiFunction&lt;T, U, R> function) { // ... return function.apply(someInput1, someInput2); } doSomething(shh(this::doItWithAnnoyance2));            // No compile time error doSomething(shh((x, y) -> doItWithAnnoyance2(x, y)));  // No compile time error </pre>
 * @param function The given AnnoyingBiFunction which may or may not throw a checked Exception.
 * @param < T > the input1 type of the function
 * @param < U > the input2 type of the function
 * @param < R > the result type of the function
 * @return BiFunction which can handle any checked Exception thrown by the given AnnoyingBiFunction and wrap it with an unchecked exception that is RuntimeException.
 */
public static <T,U,R>BiFunction<T,U,R> shh(final AnnoyingBiFunction<T,U,R> function){
  Objects.requireNonNull(function,""String_Node_Str"");
  return (input1,input2) -> {
    try {
      return function.apply(input1,input2);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
;
}","/** 
 * Returns BiFunction which does exactly the same as the given AnnoyingBiFunction but without throwing a checked exception that that annoying one might throw. e.g.) <pre> &lt;T, U, R&gt; R doItWithAnnoyance2(T input1, U input2) throws Exception { throw new Exception(""Annoying exception!""); } &lt;T, U, R&gt; R doSomething(BiFunction&lt;T, U, R&gt; function) { // ... return function.apply(someInput1, someInput2); } doSomething(shh(this::doItWithAnnoyance2));            // No compile time error doSomething(shh((x, y) -&gt; doItWithAnnoyance2(x, y)));  // No compile time error </pre>
 * @param function The given AnnoyingBiFunction which may or may not throw a checked Exception.
 * @param < T > the input1 type of the function
 * @param < U > the input2 type of the function
 * @param < R > the result type of the function
 * @return BiFunction which can handle any checked Exception thrown by the given AnnoyingBiFunction and wrap it with an unchecked exception that is RuntimeException.
 */
public static <T,U,R>BiFunction<T,U,R> shh(final AnnoyingBiFunction<T,U,R> function){
  Objects.requireNonNull(function,""String_Node_Str"");
  return (input1,input2) -> {
    try {
      return function.apply(input1,input2);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
;
}",0.9923254029163469
135803,"/** 
 * <pre> T -&gt; R -&gt; String </pre> <br /> <pre> public class SomeType { private final Long id; public SomeType(final Long id) { this.id = id; } public Long getId() { return id; } } final String result = Arrays.asList(new SomeType(1L), new SomeType(2L), new SomeType(3L)) .stream() .map(toStringOf(SomeType::getId)) .collect(joining(&quot;, &quot;, &quot;(&quot;, &quot;)&quot;)); </pre> <br /> <pre> result: (1, 2, 3) </pre>
 * @param function function to map T to R
 * @param < T >      the given type T
 * @param < R >      the mapped type of the given type T. The R type's toString() method is called to return the result.
 * @return A function to map <code>T -&gt; R -&gt; String</code> (using {@link String#valueOf(Object)})
 */
public static <T,R>Function<T,String> toStringOf(final Function<T,R> function){
  Objects.requireNonNull(function,""String_Node_Str"");
  return input -> function.andThen(String::valueOf).apply(input);
}","/** 
 * <pre> T -&gt; R -&gt; String </pre> <br> <pre> public class SomeType { private final Long id; public SomeType(final Long id) { this.id = id; } public Long getId() { return id; } } final String result = Arrays.asList(new SomeType(1L), new SomeType(2L), new SomeType(3L)) .stream() .map(toStringOf(SomeType::getId)) .collect(joining(&quot;, &quot;, &quot;(&quot;, &quot;)&quot;)); </pre> <br> <pre> result: (1, 2, 3) </pre>
 * @param function function to map T to R
 * @param < T >      the given type T
 * @param < R >      the mapped type of the given type T. The R type's toString() method is called to return the result.
 * @return A function to map <code>T -&gt; R -&gt; String</code> (using {@link String#valueOf(Object)})
 */
public static <T,R>Function<T,String> toStringOf(final Function<T,R> function){
  Objects.requireNonNull(function,""String_Node_Str"");
  return input -> function.andThen(String::valueOf).apply(input);
}",0.9978768577494692
135804,"@Test public final void testLtBigInteger2(){
  final BigInteger number=new BigInteger(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"").when(() -> Numbers.BigIntegers.lt(new BigInteger(""String_Node_Str""))).then(actual -> assertThat(actual.test(number)).isTrue());
}","@Test public final void testLtBigInteger2(){
  final BigInteger number=new BigInteger(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"").when(() -> Numbers.BigIntegers.lt(new BigInteger(""String_Node_Str""))).then(actual -> assertThat(actual.test(number)).isFalse());
}",0.9874776386404294
135805,"/** 
 * {@inheritDoc}
 */
@Override public void stop(){
  workerGroup.shutdownGracefully().awaitUninterruptibly();
}","/** 
 * {@inheritDoc}
 */
@Override public void stop(){
  workerGroup.shutdownGracefully().syncUninterruptibly();
}",0.961038961038961
135806,"@Test public void testChunkedEncode() throws Exception {
  final EmbeddedChannel channel=new EmbeddedChannel(new GelfMessageChunkEncoder());
  final String largeMessage=largeMessage(1500);
  channel.writeOutbound(Unpooled.wrappedBuffer(largeMessage.getBytes()));
  final ByteBuf chunk1=(ByteBuf)channel.readOutbound();
  final ByteBuf chunk2=(ByteBuf)channel.readOutbound();
  assertNull(channel.readOutbound());
  assertEquals((byte)0x1e,chunk1.readByte());
  assertEquals((byte)0x0f,chunk1.readByte());
  assertEquals((byte)0x1e,chunk2.readByte());
  assertEquals((byte)0x0f,chunk2.readByte());
  assertEquals(8,chunk1.readBytes(8).readableBytes());
  assertEquals(8,chunk2.readBytes(8).readableBytes());
  assertEquals((byte)0,chunk1.readByte());
  assertEquals((byte)1,chunk2.readByte());
  assertEquals((byte)2,chunk1.readByte());
  assertEquals((byte)2,chunk2.readByte());
  assertEquals(1420,chunk1.readableBytes());
  assertEquals(largeMessage.length() - 1420,chunk2.readableBytes());
}","@Test public void testChunkedEncode() throws Exception {
  final EmbeddedChannel channel=new EmbeddedChannel(new GelfMessageChunkEncoder());
  final String largeMessage=largeMessage(1500);
  channel.writeOutbound(Unpooled.wrappedBuffer(largeMessage.getBytes(StandardCharsets.US_ASCII)));
  final ByteBuf chunk1=(ByteBuf)channel.readOutbound();
  final ByteBuf chunk2=(ByteBuf)channel.readOutbound();
  assertNull(channel.readOutbound());
  assertEquals((byte)0x1e,chunk1.readByte());
  assertEquals((byte)0x0f,chunk1.readByte());
  assertEquals((byte)0x1e,chunk2.readByte());
  assertEquals((byte)0x0f,chunk2.readByte());
  assertEquals(8,chunk1.readBytes(8).readableBytes());
  assertEquals(8,chunk2.readBytes(8).readableBytes());
  assertEquals((byte)0,chunk1.readByte());
  assertEquals((byte)1,chunk2.readByte());
  assertEquals((byte)2,chunk1.readByte());
  assertEquals((byte)2,chunk2.readByte());
  assertEquals(1420,chunk1.readableBytes());
  assertEquals(largeMessage.length() - 1420,chunk2.readableBytes());
}",0.9875807252856432
135807,"@Test public void testEncode() throws Exception {
  InetSocketAddress remoteAddress=new InetSocketAddress(""String_Node_Str"",12201);
  EmbeddedChannel channel=new EmbeddedChannel(new GelfMessageUdpEncoder(remoteAddress));
  assertTrue(channel.writeOutbound(Unpooled.wrappedBuffer(""String_Node_Str"".getBytes())));
  assertTrue(channel.finish());
  DatagramPacket datagramPacket=(DatagramPacket)channel.readOutbound();
  byte[] bytes=new byte[datagramPacket.content().readableBytes()];
  datagramPacket.content().getBytes(0,bytes);
  assertEquals(remoteAddress,datagramPacket.recipient());
  assertEquals(""String_Node_Str"",new String(bytes));
}","@Test public void testEncode() throws Exception {
  InetSocketAddress remoteAddress=new InetSocketAddress(""String_Node_Str"",12201);
  EmbeddedChannel channel=new EmbeddedChannel(new GelfMessageUdpEncoder(remoteAddress));
  assertTrue(channel.writeOutbound(Unpooled.wrappedBuffer(""String_Node_Str"".getBytes(StandardCharsets.US_ASCII))));
  assertTrue(channel.finish());
  DatagramPacket datagramPacket=(DatagramPacket)channel.readOutbound();
  byte[] bytes=new byte[datagramPacket.content().readableBytes()];
  datagramPacket.content().getBytes(0,bytes);
  assertEquals(remoteAddress,datagramPacket.recipient());
  assertEquals(""String_Node_Str"",new String(bytes,StandardCharsets.US_ASCII));
}",0.9617404351087772
135808,"public boolean getChild(int groupPosition,int childPosition){
  if (hasStableIds()) {
    return childIds.containsKey(getChildId(groupPosition,childPosition));
  }
 else {
    long packedPosition=ExpandableListView.getPackedPositionForChild(groupPosition,childPosition);
    return childPositions.contains(packedPosition);
  }
}","/** 
 * @return The checked state of a child with the given positions.
 */
public boolean getChild(int groupPosition,int childPosition){
  if (hasStableIds()) {
    return childIds.containsKey(getChildId(groupPosition,childPosition));
  }
 else {
    long packedPosition=ExpandableListView.getPackedPositionForChild(groupPosition,childPosition);
    return childPositions.contains(packedPosition);
  }
}",0.8974008207934336
135809,"public boolean getGroup(int groupPosition){
  if (hasStableIds())   return groupIds.containsKey(getGroupId(groupPosition));
 else   return groupPositions.contains(groupPosition);
}","/** 
 * @return The checked state of a group with the given group position
 */
public boolean getGroup(int groupPosition){
  if (hasStableIds())   return groupIds.containsKey(getGroupId(groupPosition));
 else   return groupPositions.contains(groupPosition);
}",0.8200455580865603
135810,"public boolean putChild(int groupPosition,int childPosition,long childId,boolean isChecked){
  long packedPosition=ExpandableListView.getPackedPositionForChild(groupPosition,childPosition);
  if (hasStableIds()) {
    Long result=(isChecked) ? childIds.put(childId,packedPosition) : childIds.remove(childId);
    return result != null;
  }
 else {
    return (isChecked) ? childPositions.add(packedPosition) : childPositions.remove(packedPosition);
  }
}","/** 
 * Records the checked state of the given child positions.
 * @return The previous checked state of the child position.
 */
public boolean putChild(int groupPosition,int childPosition,long childId,boolean isChecked){
  long packedPosition=ExpandableListView.getPackedPositionForChild(groupPosition,childPosition);
  if (hasStableIds()) {
    Long result=(isChecked) ? childIds.put(childId,packedPosition) : childIds.remove(childId);
    return result != null;
  }
 else {
    return (isChecked) ? !childPositions.add(packedPosition) : childPositions.remove(packedPosition);
  }
}",0.8747591522157996
135811,"public boolean putGroup(int groupPosition,long groupId,boolean isChecked){
  if (hasStableIds()) {
    Integer result=(isChecked) ? groupIds.put(groupId,groupPosition) : groupIds.remove(groupId);
    return result != null;
  }
 else {
    return (isChecked) ? groupPositions.add(groupPosition) : groupPositions.remove(groupPosition);
  }
}","/** 
 * Records the checked state of the given group position.
 * @return The previous checked state of the group position.
 */
public boolean putGroup(int groupPosition,long groupId,boolean isChecked){
  if (hasStableIds()) {
    Integer result=(isChecked) ? groupIds.put(groupId,groupPosition) : groupIds.remove(groupId);
    return result != null;
  }
 else {
    return (isChecked) ? !groupPositions.add(groupPosition) : groupPositions.remove(groupPosition);
  }
}",0.8401486988847584
135812,"/** 
 * Add addresses into the MD-SAL data tree
 * @param macAddress       The MacAddress of the new L2Address object
 * @param nodeConnectorRef The NodeConnectorRef of the new L2Address object
 */
public void addAddress(MacAddress macAddress,IpAddress ipAddress,NodeConnectorRef nodeConnectorRef){
  if (macAddress == null || ipAddress == null || nodeConnectorRef == null) {
    return;
  }
  NodeConnectorLock nodeConnectorLock;
synchronized (this) {
    nodeConnectorLock=lockMap.get(nodeConnectorRef);
    if (nodeConnectorLock == null) {
      nodeConnectorLock=new NodeConnectorLock();
      lockMap.put(nodeConnectorRef,nodeConnectorLock);
    }
  }
synchronized (nodeConnectorLock) {
    CheckedFuture<Void,TransactionCommitFailedException> future=futureMap.get(nodeConnectorLock);
    if (future != null) {
      try {
        future.get();
      }
 catch (      InterruptedException|ExecutionException e) {
        _logger.error(""String_Node_Str"",e);
      }
    }
    long now=new Date().getTime();
    final AddressCapableNodeConnectorBuilder acncBuilder=new AddressCapableNodeConnectorBuilder();
    final AddressesBuilder addressBuilder=new AddressesBuilder().setIp(ipAddress).setMac(macAddress).setFirstSeen(now).setLastSeen(now);
    List<Addresses> addresses=null;
    ReadOnlyTransaction readTransaction=dataService.newReadOnlyTransaction();
    NodeConnector nc=null;
    try {
      Optional<NodeConnector> dataObjectOptional=readTransaction.read(LogicalDatastoreType.OPERATIONAL,(InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).get();
      if (dataObjectOptional.isPresent())       nc=(NodeConnector)dataObjectOptional.get();
    }
 catch (    Exception e) {
      _logger.error(""String_Node_Str"",nodeConnectorRef.getValue());
      readTransaction.close();
      throw new RuntimeException(""String_Node_Str"" + nodeConnectorRef,e);
    }
    readTransaction.close();
    if (nc == null) {
      return;
    }
    AddressCapableNodeConnector acnc=(AddressCapableNodeConnector)nc.getAugmentation(AddressCapableNodeConnector.class);
    if (acnc != null && acnc.getAddresses() != null) {
      addresses=acnc.getAddresses();
      for (int i=0; i < addresses.size(); i++) {
        if (addresses.get(i).getIp().equals(ipAddress) && addresses.get(i).getMac().equals(macAddress)) {
          if ((now - addresses.get(i).getLastSeen()) > timestampUpdateInterval) {
            addressBuilder.setFirstSeen(addresses.get(i).getFirstSeen()).setKey(addresses.get(i).getKey());
            addresses.remove(i);
            break;
          }
 else {
            return;
          }
        }
      }
    }
 else {
      addresses=new ArrayList<>();
    }
    if (addressBuilder.getKey() == null) {
      addressBuilder.setKey(new AddressesKey(BigInteger.valueOf(addressKey.getAndIncrement())));
    }
    addresses.add(addressBuilder.build());
    acncBuilder.setAddresses(addresses);
    InstanceIdentifier<AddressCapableNodeConnector> addressCapableNcInstanceId=((InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).augmentation(AddressCapableNodeConnector.class);
    final WriteTransaction writeTransaction=dataService.newWriteOnlyTransaction();
    writeTransaction.merge(LogicalDatastoreType.OPERATIONAL,addressCapableNcInstanceId,acncBuilder.build());
    final CheckedFuture writeTxResultFuture=writeTransaction.submit();
    Futures.addCallback(writeTxResultFuture,new FutureCallback(){
      @Override public void onSuccess(      Object o){
        _logger.debug(""String_Node_Str"",writeTransaction.getIdentifier());
      }
      @Override public void onFailure(      Throwable throwable){
        _logger.error(""String_Node_Str"",writeTransaction.getIdentifier(),throwable.getCause());
      }
    }
);
    futureMap.put(nodeConnectorLock,writeTxResultFuture);
  }
}","/** 
 * Add addresses into the MD-SAL data tree
 * @param macAddress The MacAddress of the new L2Address object
 * @param nodeConnectorRef The NodeConnectorRef of the new L2Address object
 */
public void addAddress(MacAddress macAddress,IpAddress ipAddress,NodeConnectorRef nodeConnectorRef){
  if (macAddress == null || ipAddress == null || nodeConnectorRef == null) {
    return;
  }
  NodeConnectorLock nodeConnectorLock;
synchronized (this) {
    nodeConnectorLock=lockMap.get(nodeConnectorRef);
    if (nodeConnectorLock == null) {
      nodeConnectorLock=new NodeConnectorLock();
      lockMap.put(nodeConnectorRef,nodeConnectorLock);
    }
  }
synchronized (nodeConnectorLock) {
    CheckedFuture<Void,TransactionCommitFailedException> future=futureMap.get(nodeConnectorLock);
    if (future != null) {
      try {
        future.get();
      }
 catch (      InterruptedException|ExecutionException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
    long now=new Date().getTime();
    final AddressCapableNodeConnectorBuilder acncBuilder=new AddressCapableNodeConnectorBuilder();
    final AddressesBuilder addressBuilder=new AddressesBuilder().setIp(ipAddress).setMac(macAddress).setFirstSeen(now).setLastSeen(now);
    List<Addresses> addresses=null;
    ReadOnlyTransaction readTransaction=dataService.newReadOnlyTransaction();
    NodeConnector nc=null;
    try {
      Optional<NodeConnector> dataObjectOptional=readTransaction.read(LogicalDatastoreType.OPERATIONAL,(InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).get();
      if (dataObjectOptional.isPresent())       nc=(NodeConnector)dataObjectOptional.get();
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",nodeConnectorRef.getValue());
      readTransaction.close();
      throw new RuntimeException(""String_Node_Str"" + nodeConnectorRef,e);
    }
    readTransaction.close();
    if (nc == null) {
      return;
    }
    AddressCapableNodeConnector acnc=(AddressCapableNodeConnector)nc.getAugmentation(AddressCapableNodeConnector.class);
    if (acnc != null && acnc.getAddresses() != null) {
      addresses=acnc.getAddresses();
      for (int i=0; i < addresses.size(); i++) {
        if (addresses.get(i).getIp().equals(ipAddress) && addresses.get(i).getMac().equals(macAddress)) {
          if ((now - addresses.get(i).getLastSeen()) > timestampUpdateInterval) {
            addressBuilder.setFirstSeen(addresses.get(i).getFirstSeen()).setKey(addresses.get(i).getKey());
            addresses.remove(i);
            break;
          }
 else {
            return;
          }
        }
      }
    }
 else {
      addresses=new ArrayList<>();
    }
    if (addressBuilder.getKey() == null) {
      addressBuilder.setKey(new AddressesKey(BigInteger.valueOf(addressKey.getAndIncrement())));
    }
    addresses.add(addressBuilder.build());
    acncBuilder.setAddresses(addresses);
    InstanceIdentifier<AddressCapableNodeConnector> addressCapableNcInstanceId=((InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).augmentation(AddressCapableNodeConnector.class);
    final WriteTransaction writeTransaction=dataService.newWriteOnlyTransaction();
    writeTransaction.merge(LogicalDatastoreType.OPERATIONAL,addressCapableNcInstanceId,acncBuilder.build());
    final CheckedFuture writeTxResultFuture=writeTransaction.submit();
    Futures.addCallback(writeTxResultFuture,new FutureCallback(){
      @Override public void onSuccess(      Object o){
        LOG.debug(""String_Node_Str"",writeTransaction.getIdentifier());
      }
      @Override public void onFailure(      Throwable throwable){
        LOG.error(""String_Node_Str"",writeTransaction.getIdentifier(),throwable.getCause());
      }
    }
);
    futureMap.put(nodeConnectorLock,writeTxResultFuture);
  }
}",0.9939505523408732
135813,"@Override public void onFailure(Throwable throwable){
  _logger.error(""String_Node_Str"",writeTransaction.getIdentifier(),throwable.getCause());
}","@Override public void onFailure(Throwable throwable){
  LOG.error(""String_Node_Str"",writeTransaction.getIdentifier(),throwable.getCause());
}",0.965034965034965
135814,"@Override public void onSuccess(Object o){
  _logger.debug(""String_Node_Str"",writeTransaction.getIdentifier());
}","@Override public void onSuccess(Object o){
  LOG.debug(""String_Node_Str"",writeTransaction.getIdentifier());
}",0.954954954954955
135815,"/** 
 * Add addresses into the MD-SAL data tree
 * @param macAddress       The MacAddress of the new L2Address object
 * @param nodeConnectorRef The NodeConnectorRef of the new L2Address object
 */
public void addAddress(MacAddress macAddress,IpAddress ipAddress,NodeConnectorRef nodeConnectorRef){
  if (macAddress == null || ipAddress == null || nodeConnectorRef == null) {
    return;
  }
  NodeConnectorLock nodeConnectorLock;
synchronized (this) {
    nodeConnectorLock=lockMap.get(nodeConnectorRef);
    if (nodeConnectorLock == null) {
      nodeConnectorLock=new NodeConnectorLock();
      lockMap.put(nodeConnectorRef,nodeConnectorLock);
    }
  }
synchronized (nodeConnectorLock) {
    CheckedFuture<Void,TransactionCommitFailedException> future=futureMap.get(nodeConnectorLock);
    if (future != null) {
      try {
        future.get();
      }
 catch (      InterruptedException|ExecutionException e) {
        _logger.error(""String_Node_Str"",e);
      }
    }
    long now=new Date().getTime();
    final AddressCapableNodeConnectorBuilder acncBuilder=new AddressCapableNodeConnectorBuilder();
    final AddressesBuilder addressBuilder=new AddressesBuilder().setIp(ipAddress).setMac(macAddress).setFirstSeen(now).setLastSeen(now);
    List<Addresses> addresses=null;
    ReadOnlyTransaction readTransaction=dataService.newReadOnlyTransaction();
    NodeConnector nc=null;
    try {
      Optional<NodeConnector> dataObjectOptional=readTransaction.read(LogicalDatastoreType.OPERATIONAL,(InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).get();
      if (dataObjectOptional.isPresent())       nc=(NodeConnector)dataObjectOptional.get();
    }
 catch (    Exception e) {
      _logger.error(""String_Node_Str"",nodeConnectorRef.getValue());
      readTransaction.close();
      throw new RuntimeException(""String_Node_Str"" + nodeConnectorRef,e);
    }
    readTransaction.close();
    if (nc == null) {
      return;
    }
    AddressCapableNodeConnector acnc=(AddressCapableNodeConnector)nc.getAugmentation(AddressCapableNodeConnector.class);
    if (acnc != null && acnc.getAddresses() != null) {
      addresses=acnc.getAddresses();
      for (int i=0; i < addresses.size(); i++) {
        if (addresses.get(i).getIp().equals(ipAddress) && addresses.get(i).getMac().equals(macAddress)) {
          if ((now - addresses.get(i).getLastSeen()) > timestampUpdateInterval) {
            addressBuilder.setFirstSeen(addresses.get(i).getFirstSeen()).setKey(addresses.get(i).getKey());
            addresses.remove(i);
            break;
          }
 else {
            return;
          }
        }
      }
    }
 else {
      addresses=new ArrayList<>();
    }
    if (addressBuilder.getKey() == null) {
      addressBuilder.setKey(new AddressesKey(BigInteger.valueOf(addressKey.getAndIncrement())));
    }
    addresses.add(addressBuilder.build());
    acncBuilder.setAddresses(addresses);
    InstanceIdentifier<AddressCapableNodeConnector> addressCapableNcInstanceId=((InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).augmentation(AddressCapableNodeConnector.class);
    final WriteTransaction writeTransaction=dataService.newWriteOnlyTransaction();
    writeTransaction.merge(LogicalDatastoreType.OPERATIONAL,addressCapableNcInstanceId,acncBuilder.build());
    final CheckedFuture writeTxResultFuture=writeTransaction.submit();
    Futures.addCallback(writeTxResultFuture,new FutureCallback(){
      @Override public void onSuccess(      Object o){
        _logger.debug(""String_Node_Str"",writeTransaction.getIdentifier());
      }
      @Override public void onFailure(      Throwable throwable){
        _logger.error(""String_Node_Str"",writeTransaction.getIdentifier(),throwable.getCause());
      }
    }
);
    futureMap.put(nodeConnectorLock,writeTxResultFuture);
  }
}","/** 
 * Add addresses into the MD-SAL data tree
 * @param macAddress The MacAddress of the new L2Address object
 * @param nodeConnectorRef The NodeConnectorRef of the new L2Address object
 */
public void addAddress(MacAddress macAddress,IpAddress ipAddress,NodeConnectorRef nodeConnectorRef){
  if (macAddress == null || ipAddress == null || nodeConnectorRef == null) {
    return;
  }
  NodeConnectorLock nodeConnectorLock;
synchronized (this) {
    nodeConnectorLock=lockMap.get(nodeConnectorRef);
    if (nodeConnectorLock == null) {
      nodeConnectorLock=new NodeConnectorLock();
      lockMap.put(nodeConnectorRef,nodeConnectorLock);
    }
  }
synchronized (nodeConnectorLock) {
    CheckedFuture<Void,TransactionCommitFailedException> future=futureMap.get(nodeConnectorLock);
    if (future != null) {
      try {
        future.get();
      }
 catch (      InterruptedException|ExecutionException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
    long now=new Date().getTime();
    final AddressCapableNodeConnectorBuilder acncBuilder=new AddressCapableNodeConnectorBuilder();
    final AddressesBuilder addressBuilder=new AddressesBuilder().setIp(ipAddress).setMac(macAddress).setFirstSeen(now).setLastSeen(now);
    List<Addresses> addresses=null;
    ReadOnlyTransaction readTransaction=dataService.newReadOnlyTransaction();
    NodeConnector nc=null;
    try {
      Optional<NodeConnector> dataObjectOptional=readTransaction.read(LogicalDatastoreType.OPERATIONAL,(InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).get();
      if (dataObjectOptional.isPresent())       nc=(NodeConnector)dataObjectOptional.get();
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",nodeConnectorRef.getValue());
      readTransaction.close();
      throw new RuntimeException(""String_Node_Str"" + nodeConnectorRef,e);
    }
    readTransaction.close();
    if (nc == null) {
      return;
    }
    AddressCapableNodeConnector acnc=(AddressCapableNodeConnector)nc.getAugmentation(AddressCapableNodeConnector.class);
    if (acnc != null && acnc.getAddresses() != null) {
      addresses=acnc.getAddresses();
      for (int i=0; i < addresses.size(); i++) {
        if (addresses.get(i).getIp().equals(ipAddress) && addresses.get(i).getMac().equals(macAddress)) {
          if ((now - addresses.get(i).getLastSeen()) > timestampUpdateInterval) {
            addressBuilder.setFirstSeen(addresses.get(i).getFirstSeen()).setKey(addresses.get(i).getKey());
            addresses.remove(i);
            break;
          }
 else {
            return;
          }
        }
      }
    }
 else {
      addresses=new ArrayList<>();
    }
    if (addressBuilder.getKey() == null) {
      addressBuilder.setKey(new AddressesKey(BigInteger.valueOf(addressKey.getAndIncrement())));
    }
    addresses.add(addressBuilder.build());
    acncBuilder.setAddresses(addresses);
    InstanceIdentifier<AddressCapableNodeConnector> addressCapableNcInstanceId=((InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).augmentation(AddressCapableNodeConnector.class);
    final WriteTransaction writeTransaction=dataService.newWriteOnlyTransaction();
    writeTransaction.merge(LogicalDatastoreType.OPERATIONAL,addressCapableNcInstanceId,acncBuilder.build());
    final CheckedFuture writeTxResultFuture=writeTransaction.submit();
    Futures.addCallback(writeTxResultFuture,new FutureCallback(){
      @Override public void onSuccess(      Object o){
        LOG.debug(""String_Node_Str"",writeTransaction.getIdentifier());
      }
      @Override public void onFailure(      Throwable throwable){
        LOG.error(""String_Node_Str"",writeTransaction.getIdentifier(),throwable.getCause());
      }
    }
);
    futureMap.put(nodeConnectorLock,writeTxResultFuture);
  }
}",0.9939505523408732
135816,"@Override public void onFailure(Throwable throwable){
  _logger.error(""String_Node_Str"",writeTransaction.getIdentifier(),throwable.getCause());
}","@Override public void onFailure(Throwable throwable){
  LOG.error(""String_Node_Str"",writeTransaction.getIdentifier(),throwable.getCause());
}",0.965034965034965
135817,"@Override public void onSuccess(Object o){
  _logger.debug(""String_Node_Str"",writeTransaction.getIdentifier());
}","@Override public void onSuccess(Object o){
  LOG.debug(""String_Node_Str"",writeTransaction.getIdentifier());
}",0.954954954954955
135818,"/** 
 * Read the Inventory data tree to find information about the Nodes & NodeConnectors. Create the list of NodeConnectors for a given switch.  Also determine the STP status of each NodeConnector.
 */
public void readInventory(){
  if (!refreshData) {
    return;
  }
synchronized (this) {
    if (!refreshData)     return;
    InstanceIdentifier.InstanceIdentifierBuilder<Nodes> nodesInsIdBuilder=InstanceIdentifier.<Nodes>builder(Nodes.class);
    Nodes nodes=null;
    ReadOnlyTransaction readOnlyTransaction=dataService.newReadOnlyTransaction();
    try {
      Optional<Nodes> dataObjectOptional=null;
      dataObjectOptional=readOnlyTransaction.read(LogicalDatastoreType.OPERATIONAL,nodesInsIdBuilder.build()).get();
      if (dataObjectOptional.isPresent())       nodes=(Nodes)dataObjectOptional.get();
    }
 catch (    InterruptedException e) {
      _logger.error(""String_Node_Str"");
      readOnlyTransaction.close();
      throw new RuntimeException(""String_Node_Str"",e);
    }
catch (    ExecutionException e) {
      _logger.error(""String_Node_Str"");
      readOnlyTransaction.close();
      throw new RuntimeException(""String_Node_Str"",e);
    }
    if (nodes != null) {
      for (      Node node : nodes.getNode()) {
        ArrayList<NodeConnectorRef> nodeConnectorRefs=new ArrayList<NodeConnectorRef>();
        List<NodeConnector> nodeConnectors=node.getNodeConnector();
        if (nodeConnectors != null) {
          for (          NodeConnector nodeConnector : nodeConnectors) {
            StpStatusAwareNodeConnector saNodeConnector=nodeConnector.getAugmentation(StpStatusAwareNodeConnector.class);
            if (saNodeConnector != null && StpStatus.Discarding.equals(saNodeConnector.getStatus())) {
              continue;
            }
            if (nodeConnector.getKey().toString().contains(""String_Node_Str"")) {
              continue;
            }
            NodeConnectorRef ncRef=new NodeConnectorRef(InstanceIdentifier.<Nodes>builder(Nodes.class).<Node,NodeKey>child(Node.class,node.getKey()).<NodeConnector,NodeConnectorKey>child(NodeConnector.class,nodeConnector.getKey()).build());
            nodeConnectorRefs.add(ncRef);
          }
        }
        switchNodeConnectors.put(node.getId().getValue(),nodeConnectorRefs);
        NodeConnectorRef ncRef=new NodeConnectorRef(InstanceIdentifier.<Nodes>builder(Nodes.class).<Node,NodeKey>child(Node.class,node.getKey()).<NodeConnector,NodeConnectorKey>child(NodeConnector.class,new NodeConnectorKey(new NodeConnectorId(node.getId().getValue() + ""String_Node_Str""))).build());
        _logger.debug(""String_Node_Str"",node.getKey(),ncRef);
        controllerSwitchConnectors.put(node.getId().getValue(),ncRef);
      }
    }
    readOnlyTransaction.close();
    refreshData=false;
  }
}","/** 
 * Read the Inventory data tree to find information about the Nodes and NodeConnectors. Create the list of NodeConnectors for a given switch.  Also determine the STP status of each NodeConnector.
 */
public void readInventory(){
  if (!refreshData) {
    return;
  }
synchronized (this) {
    if (!refreshData)     return;
    InstanceIdentifier.InstanceIdentifierBuilder<Nodes> nodesInsIdBuilder=InstanceIdentifier.<Nodes>builder(Nodes.class);
    Nodes nodes=null;
    ReadOnlyTransaction readOnlyTransaction=dataService.newReadOnlyTransaction();
    try {
      Optional<Nodes> dataObjectOptional=null;
      dataObjectOptional=readOnlyTransaction.read(LogicalDatastoreType.OPERATIONAL,nodesInsIdBuilder.build()).get();
      if (dataObjectOptional.isPresent())       nodes=(Nodes)dataObjectOptional.get();
    }
 catch (    InterruptedException e) {
      _logger.error(""String_Node_Str"");
      readOnlyTransaction.close();
      throw new RuntimeException(""String_Node_Str"",e);
    }
catch (    ExecutionException e) {
      _logger.error(""String_Node_Str"");
      readOnlyTransaction.close();
      throw new RuntimeException(""String_Node_Str"",e);
    }
    if (nodes != null) {
      for (      Node node : nodes.getNode()) {
        ArrayList<NodeConnectorRef> nodeConnectorRefs=new ArrayList<NodeConnectorRef>();
        List<NodeConnector> nodeConnectors=node.getNodeConnector();
        if (nodeConnectors != null) {
          for (          NodeConnector nodeConnector : nodeConnectors) {
            StpStatusAwareNodeConnector saNodeConnector=nodeConnector.getAugmentation(StpStatusAwareNodeConnector.class);
            if (saNodeConnector != null && StpStatus.Discarding.equals(saNodeConnector.getStatus())) {
              continue;
            }
            if (nodeConnector.getKey().toString().contains(""String_Node_Str"")) {
              continue;
            }
            NodeConnectorRef ncRef=new NodeConnectorRef(InstanceIdentifier.<Nodes>builder(Nodes.class).<Node,NodeKey>child(Node.class,node.getKey()).<NodeConnector,NodeConnectorKey>child(NodeConnector.class,nodeConnector.getKey()).build());
            nodeConnectorRefs.add(ncRef);
          }
        }
        switchNodeConnectors.put(node.getId().getValue(),nodeConnectorRefs);
        NodeConnectorRef ncRef=new NodeConnectorRef(InstanceIdentifier.<Nodes>builder(Nodes.class).<Node,NodeKey>child(Node.class,node.getKey()).<NodeConnector,NodeConnectorKey>child(NodeConnector.class,new NodeConnectorKey(new NodeConnectorId(node.getId().getValue() + ""String_Node_Str""))).build());
        _logger.debug(""String_Node_Str"",node.getKey(),ncRef);
        controllerSwitchConnectors.put(node.getId().getValue(),ncRef);
      }
    }
    readOnlyTransaction.close();
    refreshData=false;
  }
}",0.9992803166606692
135819,"/** 
 * Puts the given value (Host) only in this local HashMap. Ideally used for host data listener events.
 * @param ii the value's (Host's) InstanceIdentifier<Node> f
 * @param value the Host to store locally.
 * @return the previous value associated with <tt>key</tt>, or<tt>null</tt> if there was no mapping for <tt>key</tt>
 */
public synchronized V putLocally(InstanceIdentifier<Node> ii,V value){
  Host h=((Host)value);
  log.trace(""String_Node_Str"",h.getId());
  this.instanceIDs.put(ii,(K)h.getId());
  return this.hostHashMap.put((K)h.getId(),value);
}","/** 
 * Puts the given value (Host) only in this local HashMap. Ideally used for host data listener events.
 * @param ii the value's (Host's) InstanceIdentifier&lt;Node&gt;
 * @param value the Host to store locally.
 * @return the previous value associated with <tt>key</tt>, or<tt>null</tt> if there was no mapping for <tt>key</tt>
 */
public synchronized V putLocally(InstanceIdentifier<Node> ii,V value){
  Host h=((Host)value);
  log.trace(""String_Node_Str"",h.getId());
  this.instanceIDs.put(ii,(K)h.getId());
  return this.hostHashMap.put((K)h.getId(),value);
}",0.9893805309734514
135820,"/** 
 * Writes mac-to-mac flow on all ports that are in the path between given source and destination ports. It uses path provided by NetworkGraphService  {@link org.opendaylight.controller.sample.l2switch.md.topology.NetworkGraphService} to find a links{@link org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Link}between given ports. And then writes appropriate flow on each port that is covered in that path.
 * @param sourceMac
 * @param sourceNodeConnectorRef
 * @param destMac
 * @param destNodeConnectorRef
 */
public void addBidirectionalMacToMacFlows(MacAddress sourceMac,NodeConnectorRef sourceNodeConnectorRef,MacAddress destMac,NodeConnectorRef destNodeConnectorRef);","/** 
 * Writes mac-to-mac flow on all ports that are in the path between given source and destination ports. It uses path provided by org.opendaylight.l2switch.loopremover.topology.NetworkGraphService to find a links  {@link org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Link}between given ports. And then writes appropriate flow on each port that is covered in that path.
 * @param sourceMac
 * @param sourceNodeConnectorRef
 * @param destMac
 * @param destNodeConnectorRef
 */
public void addBidirectionalMacToMacFlows(MacAddress sourceMac,NodeConnectorRef sourceNodeConnectorRef,MacAddress destMac,NodeConnectorRef destNodeConnectorRef);",0.8918169209431346
135821,"/** 
 * Writes mac-to-mac flow on all ports that are in the path between given source and destination ports. It uses path provided by NetworkGraphService  {@link org.opendaylight.controller.sample.l2switch.md.topology.NetworkGraphService} to find a links{@link org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Link}between given ports. And then writes appropriate flow on each port that is covered in that path.
 * @param sourceMac
 * @param sourceNodeConnectorRef
 * @param destMac
 * @param destNodeConnectorRef
 */
@Override public void addBidirectionalMacToMacFlows(MacAddress sourceMac,NodeConnectorRef sourceNodeConnectorRef,MacAddress destMac,NodeConnectorRef destNodeConnectorRef){
  Preconditions.checkNotNull(sourceMac,""String_Node_Str"");
  Preconditions.checkNotNull(sourceNodeConnectorRef,""String_Node_Str"");
  Preconditions.checkNotNull(destMac,""String_Node_Str"");
  Preconditions.checkNotNull(destNodeConnectorRef,""String_Node_Str"");
  if (sourceNodeConnectorRef.equals(destNodeConnectorRef)) {
    _logger.info(""String_Node_Str"");
    return;
  }
  addMacToMacFlow(destMac,sourceMac,sourceNodeConnectorRef);
  addMacToMacFlow(sourceMac,destMac,destNodeConnectorRef);
}","/** 
 * Writes mac-to-mac flow on all ports that are in the path between given source and destination ports. It uses path provided by org.opendaylight.l2switch.loopremover.topology.NetworkGraphService to find a links  {@link org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.topology.Link}between given ports. And then writes appropriate flow on each port that is covered in that path.
 * @param sourceMac
 * @param sourceNodeConnectorRef
 * @param destMac
 * @param destNodeConnectorRef
 */
@Override public void addBidirectionalMacToMacFlows(MacAddress sourceMac,NodeConnectorRef sourceNodeConnectorRef,MacAddress destMac,NodeConnectorRef destNodeConnectorRef){
  Preconditions.checkNotNull(sourceMac,""String_Node_Str"");
  Preconditions.checkNotNull(sourceNodeConnectorRef,""String_Node_Str"");
  Preconditions.checkNotNull(destMac,""String_Node_Str"");
  Preconditions.checkNotNull(destNodeConnectorRef,""String_Node_Str"");
  if (sourceNodeConnectorRef.equals(destNodeConnectorRef)) {
    _logger.info(""String_Node_Str"");
    return;
  }
  addMacToMacFlow(destMac,sourceMac,sourceNodeConnectorRef);
  addMacToMacFlow(sourceMac,destMac,destNodeConnectorRef);
}",0.9363265306122448
135822,"/** 
 * Decode a RawPacket into an EthernetPacket
 * @param packetReceived -- data from wire to deserialize
 * @return
 * @throws org.opendaylight.controller.sal.packet.BufferException
 */
@Override public EthernetPacketReceived decode(PacketReceived packetReceived){
  byte[] data=packetReceived.getPayload();
  EthernetPacketReceivedBuilder builder=new EthernetPacketReceivedBuilder();
  RawPacketBuilder rpb=new RawPacketBuilder().setIngress(packetReceived.getIngress()).setConnectionCookie(packetReceived.getConnectionCookie()).setFlowCookie(packetReceived.getFlowCookie()).setTableId(packetReceived.getTableId()).setPacketInReason(packetReceived.getPacketInReason()).setPayloadOffset(0).setPayloadLength(data.length);
  if (packetReceived.getMatch() != null) {
    rpb.setMatch(new MatchBuilder(packetReceived.getMatch()).build());
  }
  RawPacket rp=rpb.build();
  ArrayList<PacketChain> packetChain=new ArrayList<PacketChain>();
  packetChain.add(new PacketChainBuilder().setPacket(rp).build());
  try {
    EthernetPacketBuilder epBuilder=new EthernetPacketBuilder();
    epBuilder.setDestinationMac(new MacAddress(HexEncode.bytesToHexStringFormat(BitBufferHelper.getBits(data,0,48))));
    epBuilder.setSourceMac(new MacAddress(HexEncode.bytesToHexStringFormat(BitBufferHelper.getBits(data,48,48))));
    Integer nextField=BitBufferHelper.getInt(BitBufferHelper.getBits(data,96,16));
    int extraHeaderBits=0;
    ArrayList<Header8021q> headerList=new ArrayList<Header8021q>();
    while (nextField.equals(ETHERTYPE_8021Q) || nextField.equals(ETHERTYPE_QINQ)) {
      Header8021qBuilder hBuilder=new Header8021qBuilder();
      hBuilder.setTPID(Header8021qType.forValue(nextField));
      byte[] vlanBytes=BitBufferHelper.getBits(data,112 + extraHeaderBits,16);
      hBuilder.setPriorityCode((short)((vlanBytes[0] & 0xff) >> 5));
      hBuilder.setDropEligible(1 == (((vlanBytes[0] & 0xff) & 0x10) >> 4));
      vlanBytes[0]=(byte)(vlanBytes[0] & 0x0F);
      hBuilder.setVlan(new VlanId(BitBufferHelper.getInt(vlanBytes)));
      headerList.add(hBuilder.build());
      nextField=BitBufferHelper.getInt(BitBufferHelper.getBits(data,128 + extraHeaderBits,16));
      extraHeaderBits+=32;
    }
    if (!headerList.isEmpty()) {
      epBuilder.setHeader8021q(headerList);
    }
    if (nextField >= ETHERTYPE_MIN) {
      epBuilder.setEthertype(KnownEtherType.forValue(nextField));
    }
 else     if (nextField <= LENGTH_MAX) {
      epBuilder.setEthernetLength(nextField);
    }
 else {
      _logger.debug(""String_Node_Str"" + nextField);
    }
    int payloadStart=(112 + extraHeaderBits) / NetUtils.NumBitsInAByte;
    int payloadEnd=data.length - 4;
    epBuilder.setPayloadOffset(payloadStart);
    epBuilder.setPayloadLength(payloadEnd - payloadStart);
    epBuilder.setCrc(BitBufferHelper.getLong(BitBufferHelper.getBits(data,(data.length - 4) * NetUtils.NumBitsInAByte,32)));
    packetChain.add(new PacketChainBuilder().setPacket(epBuilder.build()).build());
    builder.setPayload(data);
  }
 catch (  BufferException be) {
    _logger.info(""String_Node_Str"");
  }
  builder.setPacketChain(packetChain);
  return builder.build();
}","/** 
 * Decode a RawPacket into an EthernetPacket
 * @param packetReceived -- data from wire to deserialize
 * @return
 */
@Override public EthernetPacketReceived decode(PacketReceived packetReceived){
  byte[] data=packetReceived.getPayload();
  EthernetPacketReceivedBuilder builder=new EthernetPacketReceivedBuilder();
  RawPacketBuilder rpb=new RawPacketBuilder().setIngress(packetReceived.getIngress()).setConnectionCookie(packetReceived.getConnectionCookie()).setFlowCookie(packetReceived.getFlowCookie()).setTableId(packetReceived.getTableId()).setPacketInReason(packetReceived.getPacketInReason()).setPayloadOffset(0).setPayloadLength(data.length);
  if (packetReceived.getMatch() != null) {
    rpb.setMatch(new MatchBuilder(packetReceived.getMatch()).build());
  }
  RawPacket rp=rpb.build();
  ArrayList<PacketChain> packetChain=new ArrayList<PacketChain>();
  packetChain.add(new PacketChainBuilder().setPacket(rp).build());
  try {
    EthernetPacketBuilder epBuilder=new EthernetPacketBuilder();
    epBuilder.setDestinationMac(new MacAddress(HexEncode.bytesToHexStringFormat(BitBufferHelper.getBits(data,0,48))));
    epBuilder.setSourceMac(new MacAddress(HexEncode.bytesToHexStringFormat(BitBufferHelper.getBits(data,48,48))));
    Integer nextField=BitBufferHelper.getInt(BitBufferHelper.getBits(data,96,16));
    int extraHeaderBits=0;
    ArrayList<Header8021q> headerList=new ArrayList<Header8021q>();
    while (nextField.equals(ETHERTYPE_8021Q) || nextField.equals(ETHERTYPE_QINQ)) {
      Header8021qBuilder hBuilder=new Header8021qBuilder();
      hBuilder.setTPID(Header8021qType.forValue(nextField));
      byte[] vlanBytes=BitBufferHelper.getBits(data,112 + extraHeaderBits,16);
      hBuilder.setPriorityCode((short)((vlanBytes[0] & 0xff) >> 5));
      hBuilder.setDropEligible(1 == (((vlanBytes[0] & 0xff) & 0x10) >> 4));
      vlanBytes[0]=(byte)(vlanBytes[0] & 0x0F);
      hBuilder.setVlan(new VlanId(BitBufferHelper.getInt(vlanBytes)));
      headerList.add(hBuilder.build());
      nextField=BitBufferHelper.getInt(BitBufferHelper.getBits(data,128 + extraHeaderBits,16));
      extraHeaderBits+=32;
    }
    if (!headerList.isEmpty()) {
      epBuilder.setHeader8021q(headerList);
    }
    if (nextField >= ETHERTYPE_MIN) {
      epBuilder.setEthertype(KnownEtherType.forValue(nextField));
    }
 else     if (nextField <= LENGTH_MAX) {
      epBuilder.setEthernetLength(nextField);
    }
 else {
      _logger.debug(""String_Node_Str"" + nextField);
    }
    int payloadStart=(112 + extraHeaderBits) / NetUtils.NumBitsInAByte;
    int payloadEnd=data.length - 4;
    epBuilder.setPayloadOffset(payloadStart);
    epBuilder.setPayloadLength(payloadEnd - payloadStart);
    epBuilder.setCrc(BitBufferHelper.getLong(BitBufferHelper.getBits(data,(data.length - 4) * NetUtils.NumBitsInAByte,32)));
    packetChain.add(new PacketChainBuilder().setPacket(epBuilder.build()).build());
    builder.setPayload(data);
  }
 catch (  BufferException be) {
    _logger.info(""String_Node_Str"");
  }
  builder.setPacketChain(packetChain);
  return builder.build();
}",0.9894196857967296
135823,"/** 
 * Bits are expected to be stored in the input byte array from LSB
 * @param byte[]      - data to set the input byte
 * @param byte[]      - input bytes to be inserted
 * @param startOffset - offset of data[] to start inserting byte from
 * @param numBits     - number of bits of input to be inserted into data[]
 * @return void
 * @throws BufferException when the startOffset and numBits parameters are not congruentwith data and input buffers' size
 */
public static void setBytes(byte[] data,byte[] input,int startOffset,int numBits) throws BufferException {
  checkExceptions(data,startOffset,numBits);
  insertBits(data,input,startOffset,numBits);
}","/** 
 * Bits are expected to be stored in the input byte array from LSB
 * @param data        data to set the input byte
 * @param input       input bytes to be inserted
 * @param startOffset offset of data[] to start inserting byte from
 * @param numBits     number of bits of input to be inserted into data[]
 * @throws BufferException when the startOffset and numBits parameters are not congruentwith data and input buffers' size
 */
public static void setBytes(byte[] data,byte[] input,int startOffset,int numBits) throws BufferException {
  checkExceptions(data,startOffset,numBits);
  insertBits(data,input,startOffset,numBits);
}",0.654320987654321
135824,"/** 
 * Reads the specified number of bits from the passed byte array starting to read from the specified offset The bits read are stored in a byte array which size is dictated by the number of bits to be stored. The bits are stored in the byte array LSB aligned. <p/> Ex. Read 7 bits at offset 10 0         9 10     16 17 0101000010 | 0000101 | 1111001010010101011 will be returned as {0,0,0,0,0,1,0,1}
 * @param byte[] data
 * @param int    startOffset - offset to start fetching bits from data from
 * @param int    numBits - number of bits to be fetched from data
 * @return byte [] - LSB aligned bits
 * @throws BufferException when the startOffset and numBits parameters are not congruentwith the data buffer size
 */
public static byte[] getBits(byte[] data,int startOffset,int numBits) throws BufferException {
  int startByteOffset=0;
  int valfromcurr, valfromnext;
  int extranumBits=numBits % NetUtils.NumBitsInAByte;
  int extraOffsetBits=startOffset % NetUtils.NumBitsInAByte;
  int numBytes=(numBits % NetUtils.NumBitsInAByte != 0) ? 1 + numBits / NetUtils.NumBitsInAByte : numBits / NetUtils.NumBitsInAByte;
  byte[] shiftedBytes=new byte[numBytes];
  startByteOffset=startOffset / NetUtils.NumBitsInAByte;
  byte[] bytes=new byte[numBytes];
  if (numBits == 0) {
    return bytes;
  }
  checkExceptions(data,startOffset,numBits);
  if (extraOffsetBits == 0) {
    if (extranumBits == 0) {
      System.arraycopy(data,startByteOffset,bytes,0,numBytes);
      return bytes;
    }
 else {
      System.arraycopy(data,startByteOffset,bytes,0,numBytes - 1);
      bytes[numBytes - 1]=(byte)((int)data[startByteOffset + numBytes - 1] & getMSBMask(extranumBits));
    }
  }
 else {
    int i;
    for (i=0; i < numBits / NetUtils.NumBitsInAByte; i++) {
      valfromcurr=(data[startByteOffset + i]) & getLSBMask(NetUtils.NumBitsInAByte - extraOffsetBits);
      valfromnext=(data[startByteOffset + i + 1]) & getMSBMask(extraOffsetBits);
      bytes[i]=(byte)(valfromcurr << (extraOffsetBits) | (valfromnext >> (NetUtils.NumBitsInAByte - extraOffsetBits)));
    }
    if (extranumBits != 0) {
      if (extranumBits < (NetUtils.NumBitsInAByte - extraOffsetBits)) {
        valfromnext=(byte)(data[startByteOffset + i] & ((getMSBMask(extranumBits)) >> extraOffsetBits));
        bytes[i]=(byte)(valfromnext << extraOffsetBits);
      }
 else       if (extranumBits == (NetUtils.NumBitsInAByte - extraOffsetBits)) {
        valfromcurr=(data[startByteOffset + i]) & getLSBMask(NetUtils.NumBitsInAByte - extraOffsetBits);
        bytes[i]=(byte)(valfromcurr << extraOffsetBits);
      }
 else {
        valfromcurr=(data[startByteOffset + i]) & getLSBMask(NetUtils.NumBitsInAByte - extraOffsetBits);
        valfromnext=(data[startByteOffset + i + 1]) & (getMSBMask(extranumBits - (NetUtils.NumBitsInAByte - extraOffsetBits)));
        bytes[i]=(byte)(valfromcurr << (extraOffsetBits) | (valfromnext >> (NetUtils.NumBitsInAByte - extraOffsetBits)));
      }
    }
  }
  shiftedBytes=shiftBitsToLSB(bytes,numBits);
  return shiftedBytes;
}","/** 
 * Reads the specified number of bits from the passed byte array starting to read from the specified offset The bits read are stored in a byte array which size is dictated by the number of bits to be stored. The bits are stored in the byte array LSB aligned. <p> Ex. Read 7 bits at offset 10 0         9 10     16 17 0101000010 | 0000101 | 1111001010010101011 will be returned as {0,0,0,0,0,1,0,1}
 * @param data
 * @param startOffset offset to start fetching bits from data from
 * @param numBits number of bits to be fetched from data
 * @return LSB aligned bits
 * @throws BufferException when the startOffset and numBits parameters are not congruentwith the data buffer size
 */
public static byte[] getBits(byte[] data,int startOffset,int numBits) throws BufferException {
  int startByteOffset=0;
  int valfromcurr, valfromnext;
  int extranumBits=numBits % NetUtils.NumBitsInAByte;
  int extraOffsetBits=startOffset % NetUtils.NumBitsInAByte;
  int numBytes=(numBits % NetUtils.NumBitsInAByte != 0) ? 1 + numBits / NetUtils.NumBitsInAByte : numBits / NetUtils.NumBitsInAByte;
  byte[] shiftedBytes=new byte[numBytes];
  startByteOffset=startOffset / NetUtils.NumBitsInAByte;
  byte[] bytes=new byte[numBytes];
  if (numBits == 0) {
    return bytes;
  }
  checkExceptions(data,startOffset,numBits);
  if (extraOffsetBits == 0) {
    if (extranumBits == 0) {
      System.arraycopy(data,startByteOffset,bytes,0,numBytes);
      return bytes;
    }
 else {
      System.arraycopy(data,startByteOffset,bytes,0,numBytes - 1);
      bytes[numBytes - 1]=(byte)((int)data[startByteOffset + numBytes - 1] & getMSBMask(extranumBits));
    }
  }
 else {
    int i;
    for (i=0; i < numBits / NetUtils.NumBitsInAByte; i++) {
      valfromcurr=(data[startByteOffset + i]) & getLSBMask(NetUtils.NumBitsInAByte - extraOffsetBits);
      valfromnext=(data[startByteOffset + i + 1]) & getMSBMask(extraOffsetBits);
      bytes[i]=(byte)(valfromcurr << (extraOffsetBits) | (valfromnext >> (NetUtils.NumBitsInAByte - extraOffsetBits)));
    }
    if (extranumBits != 0) {
      if (extranumBits < (NetUtils.NumBitsInAByte - extraOffsetBits)) {
        valfromnext=(byte)(data[startByteOffset + i] & ((getMSBMask(extranumBits)) >> extraOffsetBits));
        bytes[i]=(byte)(valfromnext << extraOffsetBits);
      }
 else       if (extranumBits == (NetUtils.NumBitsInAByte - extraOffsetBits)) {
        valfromcurr=(data[startByteOffset + i]) & getLSBMask(NetUtils.NumBitsInAByte - extraOffsetBits);
        bytes[i]=(byte)(valfromcurr << extraOffsetBits);
      }
 else {
        valfromcurr=(data[startByteOffset + i]) & getLSBMask(NetUtils.NumBitsInAByte - extraOffsetBits);
        valfromnext=(data[startByteOffset + i + 1]) & (getMSBMask(extranumBits - (NetUtils.NumBitsInAByte - extraOffsetBits)));
        bytes[i]=(byte)(valfromcurr << (extraOffsetBits) | (valfromnext >> (NetUtils.NumBitsInAByte - extraOffsetBits)));
      }
    }
  }
  shiftedBytes=shiftBitsToLSB(bytes,numBits);
  return shiftedBytes;
}",0.9881031064111038
135825,"/** 
 * Bits are expected to be stored in the input byte array from LSB
 * @param byte[]      - data to set the input byte
 * @param byte        - input byte to be inserted
 * @param startOffset - offset of data[] to start inserting byte from
 * @param numBits     - number of bits of input to be inserted into data[]
 * @throws BufferException when the input, startOffset and numBits are not congruentwith the data buffer size
 */
public static void setByte(byte[] data,byte input,int startOffset,int numBits) throws BufferException {
  byte[] inputByteArray=new byte[1];
  Arrays.fill(inputByteArray,0,1,input);
  setBytes(data,inputByteArray,startOffset,numBits);
}","/** 
 * Bits are expected to be stored in the input byte array from LSB
 * @param data        data to set the input byte
 * @param input       byte to be inserted
 * @param startOffset offset in data to start inserting byte from
 * @param numBits     number of bits of input to be inserted into data[]
 * @throws BufferException when the input, startOffset and numBits are not congruentwith the data buffer size
 */
public static void setByte(byte[] data,byte input,int startOffset,int numBits) throws BufferException {
  byte[] inputByteArray=new byte[1];
  Arrays.fill(inputByteArray,0,1,input);
  setBytes(data,inputByteArray,startOffset,numBits);
}",0.9333333333333332
135826,"/** 
 * Returns the first byte from the byte array
 * @param byte[] data
 * @return byte value
 */
public static byte getByte(byte[] data){
  if ((data.length * NetUtils.NumBitsInAByte) > Byte.SIZE) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  return (data[0]);
}","/** 
 * Returns the first byte from the byte array
 * @param data
 * @return byte value
 */
public static byte getByte(byte[] data){
  if ((data.length * NetUtils.NumBitsInAByte) > Byte.SIZE) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  return (data[0]);
}",0.99055330634278
135827,"/** 
 * Returns the short value for the last numBits of the byte array passed. Size of numBits is restricted to Short.SIZE
 * @param byte[] data
 * @param int    - numBits
 * @return short - the short value of byte array
 */
public static short getShort(byte[] data,int numBits){
  if (numBits > Short.SIZE) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  int startOffset=data.length * NetUtils.NumBitsInAByte - numBits;
  byte[] bits=null;
  try {
    bits=BitBufferHelper.getBits(data,startOffset,numBits);
  }
 catch (  BufferException e) {
    logger.error(""String_Node_Str"",e);
  }
  return (short)toNumber(bits,numBits);
}","/** 
 * Returns the short value for the last numBits of the byte array passed. Size of numBits is restricted to Short.SIZE
 * @param data
 * @param numBits
 * @return the short value of byte array
 */
public static short getShort(byte[] data,int numBits){
  if (numBits > Short.SIZE) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  int startOffset=data.length * NetUtils.NumBitsInAByte - numBits;
  byte[] bits=null;
  try {
    bits=BitBufferHelper.getBits(data,startOffset,numBits);
  }
 catch (  BufferException e) {
    logger.error(""String_Node_Str"",e);
  }
  return (short)toNumber(bits,numBits);
}",0.9834254143646408
135828,"/** 
 * Checks for overflow and underflow exceptions
 * @param data
 * @param startOffset
 * @param numBits
 * @throws PacketException when the startOffset and numBits parametersare not congruent with the data buffer's size
 */
public static void checkExceptions(byte[] data,int startOffset,int numBits) throws BufferException {
  int endOffsetByte;
  int startByteOffset;
  endOffsetByte=startOffset / NetUtils.NumBitsInAByte + numBits / NetUtils.NumBitsInAByte + ((numBits % NetUtils.NumBitsInAByte != 0) ? 1 : ((startOffset % NetUtils.NumBitsInAByte != 0) ? 1 : 0));
  startByteOffset=startOffset / NetUtils.NumBitsInAByte;
  if (data == null) {
    throw new BufferException(""String_Node_Str"");
  }
  if ((startOffset < 0) || (startByteOffset >= data.length) || (endOffsetByte > data.length)|| (numBits < 0)|| (numBits > NetUtils.NumBitsInAByte * data.length)) {
    throw new BufferException(""String_Node_Str"" + data.length + ""String_Node_Str""+ startOffset+ ""String_Node_Str""+ numBits);
  }
}","/** 
 * Checks for overflow and underflow exceptions
 * @param data
 * @param startOffset
 * @param numBits
 * @throws BufferException when the startOffset and numBits parametersare not congruent with the data buffer's size
 */
public static void checkExceptions(byte[] data,int startOffset,int numBits) throws BufferException {
  int endOffsetByte;
  int startByteOffset;
  endOffsetByte=startOffset / NetUtils.NumBitsInAByte + numBits / NetUtils.NumBitsInAByte + ((numBits % NetUtils.NumBitsInAByte != 0) ? 1 : ((startOffset % NetUtils.NumBitsInAByte != 0) ? 1 : 0));
  startByteOffset=startOffset / NetUtils.NumBitsInAByte;
  if (data == null) {
    throw new BufferException(""String_Node_Str"");
  }
  if ((startOffset < 0) || (startByteOffset >= data.length) || (endOffsetByte > data.length)|| (numBits < 0)|| (numBits > NetUtils.NumBitsInAByte * data.length)) {
    throw new BufferException(""String_Node_Str"" + data.length + ""String_Node_Str""+ startOffset+ ""String_Node_Str""+ numBits);
  }
}",0.9939819458375124
135829,"/** 
 * Returns the long value for the last numBits of the byte array passed. Size of numBits is restricted to Long.SIZE
 * @param byte[] data
 * @param int    - numBits
 * @return long - the integer value of byte array
 */
public static long getLong(byte[] data,int numBits){
  if (numBits > Long.SIZE) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  if (numBits > data.length * NetUtils.NumBitsInAByte) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  int startOffset=data.length * NetUtils.NumBitsInAByte - numBits;
  byte[] bits=null;
  try {
    bits=BitBufferHelper.getBits(data,startOffset,numBits);
  }
 catch (  BufferException e) {
    logger.error(""String_Node_Str"",e);
  }
  return (long)toNumber(bits,numBits);
}","/** 
 * Returns the long value for the last numBits of the byte array passed. Size of numBits is restricted to Long.SIZE
 * @param data
 * @param numBits
 * @return the integer value of byte array
 */
public static long getLong(byte[] data,int numBits){
  if (numBits > Long.SIZE) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  if (numBits > data.length * NetUtils.NumBitsInAByte) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  int startOffset=data.length * NetUtils.NumBitsInAByte - numBits;
  byte[] bits=null;
  try {
    bits=BitBufferHelper.getBits(data,startOffset,numBits);
  }
 catch (  BufferException e) {
    logger.error(""String_Node_Str"",e);
  }
  return (long)toNumber(bits,numBits);
}",0.9876144318793754
135830,"/** 
 * Returns the int value for the last numBits of the byte array passed. Size of numBits is restricted to Integer.SIZE
 * @param byte[] data
 * @param int    - numBits
 * @return int - the integer value of byte array
 */
public static int getInt(byte[] data,int numBits){
  if (numBits > Integer.SIZE) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  int startOffset=data.length * NetUtils.NumBitsInAByte - numBits;
  byte[] bits=null;
  try {
    bits=BitBufferHelper.getBits(data,startOffset,numBits);
  }
 catch (  BufferException e) {
    logger.error(""String_Node_Str"",e);
  }
  return (int)toNumber(bits,numBits);
}","/** 
 * Returns the int value for the last numBits of the byte array passed. Size of numBits is restricted to Integer.SIZE
 * @param data
 * @param numBits
 * @return the integer value of byte array
 */
public static int getInt(byte[] data,int numBits){
  if (numBits > Integer.SIZE) {
    try {
      throw new BufferException(""String_Node_Str"");
    }
 catch (    BufferException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  int startOffset=data.length * NetUtils.NumBitsInAByte - numBits;
  byte[] bits=null;
  try {
    bits=BitBufferHelper.getBits(data,startOffset,numBits);
  }
 catch (  BufferException e) {
    logger.error(""String_Node_Str"",e);
  }
  return (int)toNumber(bits,numBits);
}",0.984743411927878
135831,"/** 
 * Insert in the data buffer at position dictated by the offset the number of bits specified from the input data byte array. The input byte array has the bits stored starting from the LSB
 * @param byte[] data
 * @param byte[] inputdata
 * @param int    startOffset
 * @param int    numBits
 */
public static void insertBits(byte[] data,byte[] inputdataLSB,int startOffset,int numBits){
  byte[] inputdata=shiftBitsToMSB(inputdataLSB,numBits);
  int numBytes=numBits / NetUtils.NumBitsInAByte;
  int startByteOffset=startOffset / NetUtils.NumBitsInAByte;
  int extraOffsetBits=startOffset % NetUtils.NumBitsInAByte;
  int extranumBits=numBits % NetUtils.NumBitsInAByte;
  int RestBits=numBits % NetUtils.NumBitsInAByte;
  int InputMSBbits=0, InputLSBbits=0;
  int i;
  if (numBits == 0) {
    return;
  }
  if (extraOffsetBits == 0) {
    if (extranumBits == 0) {
      numBytes=numBits / NetUtils.NumBitsInAByte;
      System.arraycopy(inputdata,0,data,startByteOffset,numBytes);
    }
 else {
      System.arraycopy(inputdata,0,data,startByteOffset,numBytes);
      data[startByteOffset + numBytes]=(byte)(data[startByteOffset + numBytes] | (inputdata[numBytes] & getMSBMask(extranumBits)));
    }
  }
 else {
    for (i=0; i < numBytes; i++) {
      if (i != 0)       InputLSBbits=(inputdata[i - 1] & getLSBMask(extraOffsetBits));
      InputMSBbits=(byte)(inputdata[i] & (getMSBMask(NetUtils.NumBitsInAByte - extraOffsetBits)));
      InputMSBbits=(InputMSBbits >= 0) ? InputMSBbits : InputMSBbits + 256;
      data[startByteOffset + i]=(byte)(data[startByteOffset + i] | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)) | (InputMSBbits >> extraOffsetBits));
      InputMSBbits=InputLSBbits=0;
    }
    if (RestBits < (NetUtils.NumBitsInAByte - extraOffsetBits)) {
      if (numBytes != 0)       InputLSBbits=(inputdata[i - 1] & getLSBMask(extraOffsetBits));
      InputMSBbits=(byte)(inputdata[i] & (getMSBMask(RestBits)));
      InputMSBbits=(InputMSBbits >= 0) ? InputMSBbits : InputMSBbits + 256;
      data[startByteOffset + i]=(byte)((data[startByteOffset + i]) | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)) | (InputMSBbits >> extraOffsetBits));
    }
 else     if (RestBits == (NetUtils.NumBitsInAByte - extraOffsetBits)) {
      if (numBytes != 0)       InputLSBbits=(inputdata[i - 1] & getLSBMask(extraOffsetBits));
      InputMSBbits=(byte)(inputdata[i] & (getMSBMask(NetUtils.NumBitsInAByte - extraOffsetBits)));
      InputMSBbits=(InputMSBbits >= 0) ? InputMSBbits : InputMSBbits + 256;
      data[startByteOffset + i]=(byte)(data[startByteOffset + i] | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)) | (InputMSBbits >> extraOffsetBits));
    }
 else {
      if (numBytes != 0)       InputLSBbits=(inputdata[i - 1] & getLSBMask(extraOffsetBits));
      InputMSBbits=(byte)(inputdata[i] & (getMSBMask(NetUtils.NumBitsInAByte - extraOffsetBits)));
      InputMSBbits=(InputMSBbits >= 0) ? InputMSBbits : InputMSBbits + 256;
      data[startByteOffset + i]=(byte)(data[startByteOffset + i] | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)) | (InputMSBbits >> extraOffsetBits));
      InputLSBbits=(inputdata[i] & (getLSBMask(RestBits - (NetUtils.NumBitsInAByte - extraOffsetBits)) << (NetUtils.NumBitsInAByte - RestBits)));
      data[startByteOffset + i + 1]=(byte)(data[startByteOffset + i + 1] | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)));
    }
  }
}","/** 
 * Insert in the data buffer at position dictated by the offset the number of bits specified from the input data byte array. The input byte array has the bits stored starting from the LSB
 * @param data
 * @param inputdataLSB
 * @param startOffset
 * @param numBits
 */
public static void insertBits(byte[] data,byte[] inputdataLSB,int startOffset,int numBits){
  byte[] inputdata=shiftBitsToMSB(inputdataLSB,numBits);
  int numBytes=numBits / NetUtils.NumBitsInAByte;
  int startByteOffset=startOffset / NetUtils.NumBitsInAByte;
  int extraOffsetBits=startOffset % NetUtils.NumBitsInAByte;
  int extranumBits=numBits % NetUtils.NumBitsInAByte;
  int RestBits=numBits % NetUtils.NumBitsInAByte;
  int InputMSBbits=0, InputLSBbits=0;
  int i;
  if (numBits == 0) {
    return;
  }
  if (extraOffsetBits == 0) {
    if (extranumBits == 0) {
      numBytes=numBits / NetUtils.NumBitsInAByte;
      System.arraycopy(inputdata,0,data,startByteOffset,numBytes);
    }
 else {
      System.arraycopy(inputdata,0,data,startByteOffset,numBytes);
      data[startByteOffset + numBytes]=(byte)(data[startByteOffset + numBytes] | (inputdata[numBytes] & getMSBMask(extranumBits)));
    }
  }
 else {
    for (i=0; i < numBytes; i++) {
      if (i != 0)       InputLSBbits=(inputdata[i - 1] & getLSBMask(extraOffsetBits));
      InputMSBbits=(byte)(inputdata[i] & (getMSBMask(NetUtils.NumBitsInAByte - extraOffsetBits)));
      InputMSBbits=(InputMSBbits >= 0) ? InputMSBbits : InputMSBbits + 256;
      data[startByteOffset + i]=(byte)(data[startByteOffset + i] | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)) | (InputMSBbits >> extraOffsetBits));
      InputMSBbits=InputLSBbits=0;
    }
    if (RestBits < (NetUtils.NumBitsInAByte - extraOffsetBits)) {
      if (numBytes != 0)       InputLSBbits=(inputdata[i - 1] & getLSBMask(extraOffsetBits));
      InputMSBbits=(byte)(inputdata[i] & (getMSBMask(RestBits)));
      InputMSBbits=(InputMSBbits >= 0) ? InputMSBbits : InputMSBbits + 256;
      data[startByteOffset + i]=(byte)((data[startByteOffset + i]) | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)) | (InputMSBbits >> extraOffsetBits));
    }
 else     if (RestBits == (NetUtils.NumBitsInAByte - extraOffsetBits)) {
      if (numBytes != 0)       InputLSBbits=(inputdata[i - 1] & getLSBMask(extraOffsetBits));
      InputMSBbits=(byte)(inputdata[i] & (getMSBMask(NetUtils.NumBitsInAByte - extraOffsetBits)));
      InputMSBbits=(InputMSBbits >= 0) ? InputMSBbits : InputMSBbits + 256;
      data[startByteOffset + i]=(byte)(data[startByteOffset + i] | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)) | (InputMSBbits >> extraOffsetBits));
    }
 else {
      if (numBytes != 0)       InputLSBbits=(inputdata[i - 1] & getLSBMask(extraOffsetBits));
      InputMSBbits=(byte)(inputdata[i] & (getMSBMask(NetUtils.NumBitsInAByte - extraOffsetBits)));
      InputMSBbits=(InputMSBbits >= 0) ? InputMSBbits : InputMSBbits + 256;
      data[startByteOffset + i]=(byte)(data[startByteOffset + i] | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)) | (InputMSBbits >> extraOffsetBits));
      InputLSBbits=(inputdata[i] & (getLSBMask(RestBits - (NetUtils.NumBitsInAByte - extraOffsetBits)) << (NetUtils.NumBitsInAByte - RestBits)));
      data[startByteOffset + i + 1]=(byte)(data[startByteOffset + i + 1] | (InputLSBbits << (NetUtils.NumBitsInAByte - extraOffsetBits)));
    }
  }
}",0.9928810111869824
135832,"/** 
 * Accepts a number as input and returns its value in byte form in MSB aligned form example: input = 5000 [1001110001000] bytes = -114, 64 [10011100] [01000000]
 * @param Number input
 * @param int    numBits - the number of bits to be returned
 * @return byte[]
 */
public static byte[] toByteArray(Number input,int numBits){
  Class<? extends Number> dataType=input.getClass();
  short size=0;
  long longValue=input.longValue();
  if (dataType == Short.class) {
    size=Short.SIZE;
  }
 else   if (dataType == Integer.class) {
    size=Integer.SIZE;
  }
 else   if (dataType == Long.class) {
    size=Long.SIZE;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int length=size / NetUtils.NumBitsInAByte;
  byte bytes[]=new byte[length];
  byte[] inputbytes=new byte[length];
  byte shiftedBytes[];
  for (int i=0; i < length; i++) {
    bytes[i]=(byte)((longValue >> (NetUtils.NumBitsInAByte * (length - i - 1))) & ByteMask);
  }
  if ((bytes[0] == 0 && dataType == Long.class) || (bytes[0] == 0 && dataType == Integer.class)) {
    int index=0;
    for (index=0; index < length; ++index) {
      if (bytes[index] != 0) {
        bytes[0]=bytes[index];
        break;
      }
    }
    System.arraycopy(bytes,index,inputbytes,0,length - index);
    Arrays.fill(bytes,length - index + 1,length - 1,(byte)0);
  }
 else {
    System.arraycopy(bytes,0,inputbytes,0,length);
  }
  shiftedBytes=shiftBitsToMSB(inputbytes,numBits);
  return shiftedBytes;
}","/** 
 * Accepts a number as input and returns its value in byte form in MSB aligned form example: input = 5000 [1001110001000] bytes = -114, 64 [10011100] [01000000]
 * @param input
 * @param numBits the number of bits to be returned
 * @return byte[]
 */
public static byte[] toByteArray(Number input,int numBits){
  Class<? extends Number> dataType=input.getClass();
  short size=0;
  long longValue=input.longValue();
  if (dataType == Short.class) {
    size=Short.SIZE;
  }
 else   if (dataType == Integer.class) {
    size=Integer.SIZE;
  }
 else   if (dataType == Long.class) {
    size=Long.SIZE;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int length=size / NetUtils.NumBitsInAByte;
  byte bytes[]=new byte[length];
  byte[] inputbytes=new byte[length];
  byte shiftedBytes[];
  for (int i=0; i < length; i++) {
    bytes[i]=(byte)((longValue >> (NetUtils.NumBitsInAByte * (length - i - 1))) & ByteMask);
  }
  if ((bytes[0] == 0 && dataType == Long.class) || (bytes[0] == 0 && dataType == Integer.class)) {
    int index=0;
    for (index=0; index < length; ++index) {
      if (bytes[index] != 0) {
        bytes[0]=bytes[index];
        break;
      }
    }
    System.arraycopy(bytes,index,inputbytes,0,length - index);
    Arrays.fill(bytes,length - index + 1,length - 1,(byte)0);
  }
 else {
    System.arraycopy(bytes,0,inputbytes,0,length);
  }
  shiftedBytes=shiftBitsToMSB(inputbytes,numBits);
  return shiftedBytes;
}",0.9945872801082544
135833,"/** 
 * It aligns the last numBits bits to the head of the byte array following them with numBits % 8 zero bits. <p/> Example: For inputbytes = [00000111][01110001] and numBits = 12 it returns: shiftedBytes = [01110111][00010000]
 * @param byte[] inputBytes
 * @param int    numBits - number of bits to be left aligned
 * @return byte[]
 */
public static byte[] shiftBitsToMSB(byte[] inputBytes,int numBits){
  int numBitstoShiftBy=0, leadZeroesMSB=8, numEndRestBits=0;
  int size=inputBytes.length;
  byte[] shiftedBytes=new byte[size];
  int i;
  for (i=0; i < Byte.SIZE; i++) {
    if (((byte)(inputBytes[0] & getMSBMask(i + 1))) != 0) {
      leadZeroesMSB=i;
      break;
    }
  }
  if (numBits % NetUtils.NumBitsInAByte == 0) {
    numBitstoShiftBy=0;
  }
 else {
    numBitstoShiftBy=((NetUtils.NumBitsInAByte - (numBits % NetUtils.NumBitsInAByte)) < leadZeroesMSB) ? (NetUtils.NumBitsInAByte - (numBits % NetUtils.NumBitsInAByte)) : leadZeroesMSB;
  }
  if (numBitstoShiftBy == 0) {
    return inputBytes;
  }
  if (numBits < NetUtils.NumBitsInAByte) {
    shiftedBytes[0]=(byte)((inputBytes[0] & getLSBMask(numBits)) << numBitstoShiftBy);
  }
 else {
    numEndRestBits=NetUtils.NumBitsInAByte - (inputBytes.length * NetUtils.NumBitsInAByte - numBits - numBitstoShiftBy);
    for (i=0; i < (size - 1); i++) {
      if ((i + 1) == (size - 1)) {
        if (numEndRestBits > numBitstoShiftBy) {
          shiftedBytes[i]=(byte)((inputBytes[i] << numBitstoShiftBy) | ((inputBytes[i + 1] & getMSBMask(numBitstoShiftBy)) >> (numEndRestBits - numBitstoShiftBy)));
          shiftedBytes[i + 1]=(byte)((inputBytes[i + 1] & getLSBMask(numEndRestBits - numBitstoShiftBy)) << numBitstoShiftBy);
        }
 else         shiftedBytes[i]=(byte)((inputBytes[i] << numBitstoShiftBy) | ((inputBytes[i + 1] & getMSBMask(numEndRestBits)) >> (NetUtils.NumBitsInAByte - numEndRestBits)));
      }
      shiftedBytes[i]=(byte)((inputBytes[i] << numBitstoShiftBy) | (inputBytes[i + 1] & getMSBMask(numBitstoShiftBy)) >> (NetUtils.NumBitsInAByte - numBitstoShiftBy));
    }
  }
  return shiftedBytes;
}","/** 
 * It aligns the last numBits bits to the head of the byte array following them with numBits % 8 zero bits. <p> Example: For inputbytes = [00000111][01110001] and numBits = 12 it returns: shiftedBytes = [01110111][00010000]
 * @param inputBytes
 * @param numBits number of bits to be left aligned
 * @return byte[]
 */
public static byte[] shiftBitsToMSB(byte[] inputBytes,int numBits){
  int numBitstoShiftBy=0, leadZeroesMSB=8, numEndRestBits=0;
  int size=inputBytes.length;
  byte[] shiftedBytes=new byte[size];
  int i;
  for (i=0; i < Byte.SIZE; i++) {
    if (((byte)(inputBytes[0] & getMSBMask(i + 1))) != 0) {
      leadZeroesMSB=i;
      break;
    }
  }
  if (numBits % NetUtils.NumBitsInAByte == 0) {
    numBitstoShiftBy=0;
  }
 else {
    numBitstoShiftBy=((NetUtils.NumBitsInAByte - (numBits % NetUtils.NumBitsInAByte)) < leadZeroesMSB) ? (NetUtils.NumBitsInAByte - (numBits % NetUtils.NumBitsInAByte)) : leadZeroesMSB;
  }
  if (numBitstoShiftBy == 0) {
    return inputBytes;
  }
  if (numBits < NetUtils.NumBitsInAByte) {
    shiftedBytes[0]=(byte)((inputBytes[0] & getLSBMask(numBits)) << numBitstoShiftBy);
  }
 else {
    numEndRestBits=NetUtils.NumBitsInAByte - (inputBytes.length * NetUtils.NumBitsInAByte - numBits - numBitstoShiftBy);
    for (i=0; i < (size - 1); i++) {
      if ((i + 1) == (size - 1)) {
        if (numEndRestBits > numBitstoShiftBy) {
          shiftedBytes[i]=(byte)((inputBytes[i] << numBitstoShiftBy) | ((inputBytes[i + 1] & getMSBMask(numBitstoShiftBy)) >> (numEndRestBits - numBitstoShiftBy)));
          shiftedBytes[i + 1]=(byte)((inputBytes[i + 1] & getLSBMask(numEndRestBits - numBitstoShiftBy)) << numBitstoShiftBy);
        }
 else         shiftedBytes[i]=(byte)((inputBytes[i] << numBitstoShiftBy) | ((inputBytes[i + 1] & getMSBMask(numEndRestBits)) >> (NetUtils.NumBitsInAByte - numEndRestBits)));
      }
      shiftedBytes[i]=(byte)((inputBytes[i] << numBitstoShiftBy) | (inputBytes[i + 1] & getMSBMask(numBitstoShiftBy)) >> (NetUtils.NumBitsInAByte - numBitstoShiftBy));
    }
  }
  return shiftedBytes;
}",0.9925498678202356
135834,"/** 
 * It aligns the first numBits bits to the right end of the byte array preceding them with numBits % 8 zero bits. <p/> Example: For inputbytes = [01110111][00010000] and numBits = 12 it returns: shiftedBytes = [00000111][01110001]
 * @param byte[] inputBytes
 * @param int    numBits - number of bits to be right aligned
 * @return byte[]
 */
public static byte[] shiftBitsToLSB(byte[] inputBytes,int numBits){
  int numBytes=inputBytes.length;
  int numBitstoShift=numBits % NetUtils.NumBitsInAByte;
  byte[] shiftedBytes=new byte[numBytes];
  int inputLsb=0, inputMsb=0;
  if (numBitstoShift == 0) {
    return inputBytes;
  }
  for (int i=1; i < numBytes; i++) {
    inputLsb=inputBytes[i - 1] & getLSBMask(NetUtils.NumBitsInAByte - numBitstoShift);
    inputLsb=(inputLsb < 0) ? (inputLsb + 256) : inputLsb;
    inputMsb=inputBytes[i] & getMSBMask(numBitstoShift);
    inputMsb=(inputBytes[i] < 0) ? (inputBytes[i] + 256) : inputBytes[i];
    shiftedBytes[i]=(byte)((inputLsb << numBitstoShift) | (inputMsb >> (NetUtils.NumBitsInAByte - numBitstoShift)));
  }
  inputMsb=inputBytes[0] & (getMSBMask(numBitstoShift));
  inputMsb=(inputMsb < 0) ? (inputMsb + 256) : inputMsb;
  shiftedBytes[0]=(byte)(inputMsb >> (NetUtils.NumBitsInAByte - numBitstoShift));
  return shiftedBytes;
}","/** 
 * It aligns the first numBits bits to the right end of the byte array preceding them with numBits % 8 zero bits. <p> Example: For inputbytes = [01110111][00010000] and numBits = 12 it returns: shiftedBytes = [00000111][01110001]
 * @param inputBytes
 * @param numBits number of bits to be right aligned
 * @return byte[]
 */
public static byte[] shiftBitsToLSB(byte[] inputBytes,int numBits){
  int numBytes=inputBytes.length;
  int numBitstoShift=numBits % NetUtils.NumBitsInAByte;
  byte[] shiftedBytes=new byte[numBytes];
  int inputLsb=0, inputMsb=0;
  if (numBitstoShift == 0) {
    return inputBytes;
  }
  for (int i=1; i < numBytes; i++) {
    inputLsb=inputBytes[i - 1] & getLSBMask(NetUtils.NumBitsInAByte - numBitstoShift);
    inputLsb=(inputLsb < 0) ? (inputLsb + 256) : inputLsb;
    inputMsb=inputBytes[i] & getMSBMask(numBitstoShift);
    inputMsb=(inputBytes[i] < 0) ? (inputBytes[i] + 256) : inputBytes[i];
    shiftedBytes[i]=(byte)((inputLsb << numBitstoShift) | (inputMsb >> (NetUtils.NumBitsInAByte - numBitstoShift)));
  }
  inputMsb=inputBytes[0] & (getMSBMask(numBitstoShift));
  inputMsb=(inputMsb < 0) ? (inputMsb + 256) : inputMsb;
  shiftedBytes[0]=(byte)(inputMsb >> (NetUtils.NumBitsInAByte - numBitstoShift));
  return shiftedBytes;
}",0.9878953533775868
135835,"/** 
 * Returns the numerical value of the last numBits (LSB bits) of the byte array passed
 * @param byte[] - array
 * @param int    - numBits
 * @return long - numerical value of byte array passed
 */
static public long toNumber(byte[] array,int numBits){
  int length=numBits / NetUtils.NumBitsInAByte;
  int bitsRest=numBits % NetUtils.NumBitsInAByte;
  int startOffset=array.length - length;
  long ret=0;
  int value=0;
  value=array[startOffset - 1] & getLSBMask(bitsRest);
  value=(array[startOffset - 1] < 0) ? (array[startOffset - 1] + 256) : array[startOffset - 1];
  ret=ret | (value << ((array.length - startOffset) * NetUtils.NumBitsInAByte));
  for (int i=startOffset; i < array.length; i++) {
    value=array[i];
    if (value < 0)     value+=256;
    ret=ret | (long)((long)value << ((array.length - i - 1) * NetUtils.NumBitsInAByte));
  }
  return ret;
}","/** 
 * Returns the numerical value of the last numBits (LSB bits) of the byte array passed
 * @param array
 * @param numBits
 * @return numerical value of byte array passed
 */
static public long toNumber(byte[] array,int numBits){
  int length=numBits / NetUtils.NumBitsInAByte;
  int bitsRest=numBits % NetUtils.NumBitsInAByte;
  int startOffset=array.length - length;
  long ret=0;
  int value=0;
  value=array[startOffset - 1] & getLSBMask(bitsRest);
  value=(array[startOffset - 1] < 0) ? (array[startOffset - 1] + 256) : array[startOffset - 1];
  ret=ret | (value << ((array.length - startOffset) * NetUtils.NumBitsInAByte));
  for (int i=startOffset; i < array.length; i++) {
    value=array[i];
    if (value < 0)     value+=256;
    ret=ret | (long)((long)value << ((array.length - i - 1) * NetUtils.NumBitsInAByte));
  }
  return ret;
}",0.985456660849331
135836,"/** 
 * Checks if the test address and mask conflicts with the filter address and mask <p/> For example: testAddress: 172.28.2.23 testMask: 255.255.255.0 filterAddress: 172.28.1.10 testMask: 255.255.255.0 do conflict <p/> testAddress: 172.28.2.23 testMask: 255.255.255.0 filterAddress: 172.28.1.10 testMask: 255.255.0.0 do not conflict <p/> Null parameters are permitted
 * @param testAddress
 * @param filterAddress
 * @param testMask
 * @param filterMask
 * @return
 */
public static boolean inetAddressConflict(InetAddress testAddress,InetAddress filterAddress,InetAddress testMask,InetAddress filterMask){
  if ((testAddress == null) || (filterAddress == null)) {
    return false;
  }
  if (isAny(testAddress) || isAny(filterAddress)) {
    return false;
  }
  int testMaskLen=(testMask == null) ? ((testAddress instanceof Inet4Address) ? 32 : 128) : NetUtils.getSubnetMaskLength(testMask);
  int filterMaskLen=(filterMask == null) ? ((testAddress instanceof Inet4Address) ? 32 : 128) : NetUtils.getSubnetMaskLength(filterMask);
  if (testMaskLen < filterMaskLen) {
    return true;
  }
  InetAddress prefix1=getSubnetPrefix(testAddress,filterMaskLen);
  InetAddress prefix2=getSubnetPrefix(filterAddress,filterMaskLen);
  return (!prefix1.equals(prefix2));
}","/** 
 * Checks if the test address and mask conflicts with the filter address and mask <p> For example: testAddress: 172.28.2.23 testMask: 255.255.255.0 filterAddress: 172.28.1.10 testMask: 255.255.255.0 do conflict <p> testAddress: 172.28.2.23 testMask: 255.255.255.0 filterAddress: 172.28.1.10 testMask: 255.255.0.0 do not conflict <p> Null parameters are permitted
 * @param testAddress
 * @param filterAddress
 * @param testMask
 * @param filterMask
 * @return
 */
public static boolean inetAddressConflict(InetAddress testAddress,InetAddress filterAddress,InetAddress testMask,InetAddress filterMask){
  if ((testAddress == null) || (filterAddress == null)) {
    return false;
  }
  if (isAny(testAddress) || isAny(filterAddress)) {
    return false;
  }
  int testMaskLen=(testMask == null) ? ((testAddress instanceof Inet4Address) ? 32 : 128) : NetUtils.getSubnetMaskLength(testMask);
  int filterMaskLen=(filterMask == null) ? ((testAddress instanceof Inet4Address) ? 32 : 128) : NetUtils.getSubnetMaskLength(filterMask);
  if (testMaskLen < filterMaskLen) {
    return true;
  }
  InetAddress prefix1=getSubnetPrefix(testAddress,filterMaskLen);
  InetAddress prefix2=getSubnetPrefix(filterAddress,filterMaskLen);
  return (!prefix1.equals(prefix2));
}",0.9988118811881188
135837,"/** 
 * Adds links to existing graph or creates new directed graph with given links if graph was not initialized.
 * @param links The links to add.
 */
@Override public synchronized void addLinks(List<Link> links){
  if (links == null || links.isEmpty()) {
    _logger.info(""String_Node_Str"");
    return;
  }
  if (networkGraph == null) {
    networkGraph=new UndirectedSparseGraph<>();
  }
  for (  Link link : links) {
    NodeId sourceNodeId=link.getSource().getSourceNode();
    NodeId destinationNodeId=link.getDestination().getDestNode();
    networkGraph.addVertex(sourceNodeId);
    networkGraph.addVertex(destinationNodeId);
    networkGraph.addEdge(link,sourceNodeId,destinationNodeId);
  }
}","/** 
 * Adds links to existing graph or creates new directed graph with given links if graph was not initialized.
 * @param links The links to add.
 */
@Override public synchronized void addLinks(List<Link> links){
  if (links == null || links.isEmpty()) {
    _logger.info(""String_Node_Str"");
    return;
  }
  if (networkGraph == null) {
    networkGraph=new SparseMultigraph<>();
  }
  for (  Link link : links) {
    if (linkAlreadyAdded(link)) {
      continue;
    }
    NodeId sourceNodeId=link.getSource().getSourceNode();
    NodeId destinationNodeId=link.getDestination().getDestNode();
    networkGraph.addVertex(sourceNodeId);
    networkGraph.addVertex(destinationNodeId);
    networkGraph.addEdge(link,sourceNodeId,destinationNodeId,EdgeType.UNDIRECTED);
  }
}",0.937034529451591
135838,"@Override public void onDataChanged(final AsyncDataChangeEvent<InstanceIdentifier<?>,DataObject> change){
  ExecutorService exec=Executors.newFixedThreadPool(CPUS);
  exec.submit(new Runnable(){
    @Override public void run(){
      if (change == null) {
        log.info(""String_Node_Str"");
        return;
      }
      Map<InstanceIdentifier<?>,DataObject> updatedData=change.getUpdatedData();
      Map<InstanceIdentifier<?>,DataObject> createdData=change.getCreatedData();
      Map<InstanceIdentifier<?>,DataObject> originalData=change.getOriginalData();
      Set<InstanceIdentifier<?>> deletedData=change.getRemovedPaths();
      for (      InstanceIdentifier<?> iid : deletedData) {
        if (iid.getTargetType().equals(Node.class)) {
          Node node=((Node)originalData.get(iid));
          InstanceIdentifier<Node> iiN=(InstanceIdentifier<Node>)iid;
          HostNode hostNode=node.getAugmentation(HostNode.class);
          if (hostNode != null) {
synchronized (hosts) {
              try {
                hosts.removeLocally(iiN);
              }
 catch (              ClassCastException ex) {
              }
            }
          }
        }
 else         if (iid.getTargetType().equals(Link.class)) {
          linkRemoved((InstanceIdentifier<Link>)iid,(Link)originalData.get(iid));
        }
      }
      for (      Map.Entry<InstanceIdentifier<?>,DataObject> entrySet : updatedData.entrySet()) {
        InstanceIdentifier<?> iiD=entrySet.getKey();
        final DataObject dataObject=entrySet.getValue();
        if (dataObject instanceof Addresses) {
          packetReceived((Addresses)dataObject,iiD);
        }
 else         if (dataObject instanceof Node) {
synchronized (hosts) {
            hosts.putLocally((InstanceIdentifier<Node>)iiD,Host.createHost((Node)dataObject));
          }
        }
      }
      for (      Map.Entry<InstanceIdentifier<?>,DataObject> entrySet : createdData.entrySet()) {
        InstanceIdentifier<?> iiD=entrySet.getKey();
        final DataObject dataObject=entrySet.getValue();
        if (dataObject instanceof Addresses) {
          packetReceived((Addresses)dataObject,iiD);
        }
 else         if (dataObject instanceof Node) {
synchronized (hosts) {
            hosts.putLocally((InstanceIdentifier<Node>)iiD,Host.createHost((Node)dataObject));
          }
        }
      }
    }
  }
);
}","@Override public void onDataChanged(final AsyncDataChangeEvent<InstanceIdentifier<?>,DataObject> change){
  exec.submit(new Runnable(){
    @Override public void run(){
      if (change == null) {
        log.info(""String_Node_Str"");
        return;
      }
      Map<InstanceIdentifier<?>,DataObject> updatedData=change.getUpdatedData();
      Map<InstanceIdentifier<?>,DataObject> createdData=change.getCreatedData();
      Map<InstanceIdentifier<?>,DataObject> originalData=change.getOriginalData();
      Set<InstanceIdentifier<?>> deletedData=change.getRemovedPaths();
      for (      InstanceIdentifier<?> iid : deletedData) {
        if (iid.getTargetType().equals(Node.class)) {
          Node node=((Node)originalData.get(iid));
          InstanceIdentifier<Node> iiN=(InstanceIdentifier<Node>)iid;
          HostNode hostNode=node.getAugmentation(HostNode.class);
          if (hostNode != null) {
synchronized (hosts) {
              try {
                hosts.removeLocally(iiN);
              }
 catch (              ClassCastException ex) {
              }
            }
          }
        }
 else         if (iid.getTargetType().equals(Link.class)) {
          linkRemoved((InstanceIdentifier<Link>)iid,(Link)originalData.get(iid));
        }
      }
      for (      Map.Entry<InstanceIdentifier<?>,DataObject> entrySet : updatedData.entrySet()) {
        InstanceIdentifier<?> iiD=entrySet.getKey();
        final DataObject dataObject=entrySet.getValue();
        if (dataObject instanceof Addresses) {
          packetReceived((Addresses)dataObject,iiD);
        }
 else         if (dataObject instanceof Node) {
synchronized (hosts) {
            hosts.putLocally((InstanceIdentifier<Node>)iiD,Host.createHost((Node)dataObject));
          }
        }
      }
      for (      Map.Entry<InstanceIdentifier<?>,DataObject> entrySet : createdData.entrySet()) {
        InstanceIdentifier<?> iiD=entrySet.getKey();
        final DataObject dataObject=entrySet.getValue();
        if (dataObject instanceof Addresses) {
          packetReceived((Addresses)dataObject,iiD);
        }
 else         if (dataObject instanceof Node) {
synchronized (hosts) {
            hosts.putLocally((InstanceIdentifier<Node>)iiD,Host.createHost((Node)dataObject));
          }
        }
      }
    }
  }
);
}",0.9873958555864132
135839,"/** 
 * Add addresses into the MD-SAL data tree
 * @param macAddress       The MacAddress of the new L2Address object
 * @param nodeConnectorRef The NodeConnectorRef of the new L2Address object
 */
public void addAddress(MacAddress macAddress,IpAddress ipAddress,NodeConnectorRef nodeConnectorRef){
  if (macAddress == null || ipAddress == null || nodeConnectorRef == null) {
    return;
  }
  NodeConnectorLock nodeConnectorLock;
synchronized (this) {
    nodeConnectorLock=lockMap.get(nodeConnectorRef);
    if (nodeConnectorLock == null) {
      nodeConnectorLock=new NodeConnectorLock();
      lockMap.put(nodeConnectorRef,nodeConnectorLock);
    }
  }
synchronized (nodeConnectorLock) {
    long now=new Date().getTime();
    final AddressCapableNodeConnectorBuilder acncBuilder=new AddressCapableNodeConnectorBuilder();
    final AddressesBuilder addressBuilder=new AddressesBuilder().setIp(ipAddress).setMac(macAddress).setFirstSeen(now).setLastSeen(now);
    List<Addresses> addresses=null;
    ReadOnlyTransaction readTransaction=dataService.newReadOnlyTransaction();
    NodeConnector nc=null;
    try {
      Optional<NodeConnector> dataObjectOptional=readTransaction.read(LogicalDatastoreType.OPERATIONAL,(InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).get();
      if (dataObjectOptional.isPresent())       nc=(NodeConnector)dataObjectOptional.get();
    }
 catch (    Exception e) {
      _logger.error(""String_Node_Str"",nodeConnectorRef.getValue());
      readTransaction.close();
      throw new RuntimeException(""String_Node_Str"" + nodeConnectorRef,e);
    }
    readTransaction.close();
    if (nc == null) {
      return;
    }
    AddressCapableNodeConnector acnc=(AddressCapableNodeConnector)nc.getAugmentation(AddressCapableNodeConnector.class);
    if (acnc != null && acnc.getAddresses() != null) {
      addresses=acnc.getAddresses();
      for (int i=0; i < addresses.size(); i++) {
        if (addresses.get(i).getIp().equals(ipAddress) && addresses.get(i).getMac().equals(macAddress)) {
          if ((now - addresses.get(i).getLastSeen()) > timestampUpdateInterval) {
            addressBuilder.setFirstSeen(addresses.get(i).getFirstSeen()).setKey(addresses.get(i).getKey());
            addresses.remove(i);
            break;
          }
 else {
            return;
          }
        }
      }
    }
 else {
      addresses=new ArrayList<>();
    }
    if (addressBuilder.getKey() == null) {
      addressBuilder.setKey(new AddressesKey(BigInteger.valueOf(addressKey.getAndIncrement())));
    }
    addresses.add(addressBuilder.build());
    acncBuilder.setAddresses(addresses);
    InstanceIdentifier<AddressCapableNodeConnector> addressCapableNcInstanceId=((InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).augmentation(AddressCapableNodeConnector.class);
    WriteTransaction writeTransaction=dataService.newWriteOnlyTransaction();
    writeTransaction.merge(LogicalDatastoreType.OPERATIONAL,addressCapableNcInstanceId,acncBuilder.build());
    writeTransaction.submit();
  }
}","/** 
 * Add addresses into the MD-SAL data tree
 * @param macAddress       The MacAddress of the new L2Address object
 * @param nodeConnectorRef The NodeConnectorRef of the new L2Address object
 */
public void addAddress(MacAddress macAddress,IpAddress ipAddress,NodeConnectorRef nodeConnectorRef){
  if (macAddress == null || ipAddress == null || nodeConnectorRef == null) {
    return;
  }
  NodeConnectorLock nodeConnectorLock;
synchronized (this) {
    nodeConnectorLock=lockMap.get(nodeConnectorRef);
    if (nodeConnectorLock == null) {
      nodeConnectorLock=new NodeConnectorLock();
      lockMap.put(nodeConnectorRef,nodeConnectorLock);
    }
  }
synchronized (nodeConnectorLock) {
    CheckedFuture<Void,TransactionCommitFailedException> future=futureMap.get(nodeConnectorLock);
    if (future != null) {
      try {
        future.get(2,TimeUnit.SECONDS);
      }
 catch (      InterruptedException|ExecutionException|TimeoutException e) {
        _logger.error(""String_Node_Str"",e);
      }
    }
    long now=new Date().getTime();
    final AddressCapableNodeConnectorBuilder acncBuilder=new AddressCapableNodeConnectorBuilder();
    final AddressesBuilder addressBuilder=new AddressesBuilder().setIp(ipAddress).setMac(macAddress).setFirstSeen(now).setLastSeen(now);
    List<Addresses> addresses=null;
    ReadOnlyTransaction readTransaction=dataService.newReadOnlyTransaction();
    NodeConnector nc=null;
    try {
      Optional<NodeConnector> dataObjectOptional=readTransaction.read(LogicalDatastoreType.OPERATIONAL,(InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).get();
      if (dataObjectOptional.isPresent())       nc=(NodeConnector)dataObjectOptional.get();
    }
 catch (    Exception e) {
      _logger.error(""String_Node_Str"",nodeConnectorRef.getValue());
      readTransaction.close();
      throw new RuntimeException(""String_Node_Str"" + nodeConnectorRef,e);
    }
    readTransaction.close();
    if (nc == null) {
      return;
    }
    AddressCapableNodeConnector acnc=(AddressCapableNodeConnector)nc.getAugmentation(AddressCapableNodeConnector.class);
    if (acnc != null && acnc.getAddresses() != null) {
      addresses=acnc.getAddresses();
      for (int i=0; i < addresses.size(); i++) {
        if (addresses.get(i).getIp().equals(ipAddress) && addresses.get(i).getMac().equals(macAddress)) {
          if ((now - addresses.get(i).getLastSeen()) > timestampUpdateInterval) {
            addressBuilder.setFirstSeen(addresses.get(i).getFirstSeen()).setKey(addresses.get(i).getKey());
            addresses.remove(i);
            break;
          }
 else {
            return;
          }
        }
      }
    }
 else {
      addresses=new ArrayList<>();
    }
    if (addressBuilder.getKey() == null) {
      addressBuilder.setKey(new AddressesKey(BigInteger.valueOf(addressKey.getAndIncrement())));
    }
    addresses.add(addressBuilder.build());
    acncBuilder.setAddresses(addresses);
    InstanceIdentifier<AddressCapableNodeConnector> addressCapableNcInstanceId=((InstanceIdentifier<NodeConnector>)nodeConnectorRef.getValue()).augmentation(AddressCapableNodeConnector.class);
    WriteTransaction writeTransaction=dataService.newWriteOnlyTransaction();
    writeTransaction.merge(LogicalDatastoreType.OPERATIONAL,addressCapableNcInstanceId,acncBuilder.build());
    futureMap.put(nodeConnectorLock,writeTransaction.submit());
  }
}",0.9454714929314898
135840,"@Override public List<Link> getAllLinks(){
  List<Link> allLinks=new ArrayList<>();
  allLinks.addAll(networkGraph.getEdges());
  return allLinks;
}","@Override public List<Link> getAllLinks(){
  List<Link> allLinks=new ArrayList<>();
  if (networkGraph != null) {
    allLinks.addAll(networkGraph.getEdges());
  }
  return allLinks;
}",0.891566265060241
135841,"/** 
 * Forms MST(minimum spanning tree) from network graph and returns links that are not in MST.
 * @return
 */
@Override public synchronized List<Link> getLinksInMst(){
  List<Link> linksInMst=new ArrayList<>();
  PrimMinimumSpanningTree<NodeId,Link> networkMst=new PrimMinimumSpanningTree<>(DelegateTree.<NodeId,Link>getFactory());
  Graph<NodeId,Link> mstGraph=networkMst.transform(networkGraph);
  Collection<Link> mstLinks=mstGraph.getEdges();
  linksInMst.addAll(mstLinks);
  return linksInMst;
}","/** 
 * Forms MST(minimum spanning tree) from network graph and returns links that are not in MST.
 * @return
 */
@Override public synchronized List<Link> getLinksInMst(){
  List<Link> linksInMst=new ArrayList<>();
  if (networkGraph != null) {
    PrimMinimumSpanningTree<NodeId,Link> networkMst=new PrimMinimumSpanningTree<>(DelegateTree.<NodeId,Link>getFactory());
    Graph<NodeId,Link> mstGraph=networkMst.transform(networkGraph);
    Collection<Link> mstLinks=mstGraph.getEdges();
    linksInMst.addAll(mstLinks);
  }
  return linksInMst;
}",0.96
135842,"@Test public void onNodeUpdated_Valid() throws Exception {
  InstanceIdentifier<Node> nodeInstanceIdentifier=InstanceIdentifier.builder(Nodes.class).child(Node.class).toInstance();
  NodeUpdated nodeUpdated=new NodeUpdatedBuilder().setNodeRef(new NodeRef(nodeInstanceIdentifier)).build();
  initialFlowWriter.onNodeUpdated(nodeUpdated);
  Thread.sleep(250);
  verify(salFlowService,times(0)).addFlow(any(AddFlowInput.class));
}","@Test public void onNodeUpdated_Valid() throws Exception {
  InstanceIdentifier<Node> nodeInstanceIdentifier=InstanceIdentifier.builder(Nodes.class).child(Node.class,new NodeKey(new NodeId(""String_Node_Str""))).toInstance();
  NodeUpdated nodeUpdated=new NodeUpdatedBuilder().setNodeRef(new NodeRef(nodeInstanceIdentifier)).build();
  initialFlowWriter.onNodeUpdated(nodeUpdated);
  Thread.sleep(250);
  verify(salFlowService,times(1)).addFlow(any(AddFlowInput.class));
}",0.9498327759197324
135843,"@Test public void onNodeUpdated_Valid() throws Exception {
  InstanceIdentifier<Node> nodeInstanceIdentifier=InstanceIdentifier.builder(Nodes.class).child(Node.class).toInstance();
  NodeUpdated nodeUpdated=new NodeUpdatedBuilder().setNodeRef(new NodeRef(nodeInstanceIdentifier)).build();
  initialFlowWriter.onNodeUpdated(nodeUpdated);
  Thread.sleep(250);
  verify(salFlowService,times(0)).addFlow(any(AddFlowInput.class));
}","@Test public void onNodeUpdated_Valid() throws Exception {
  InstanceIdentifier<Node> nodeInstanceIdentifier=InstanceIdentifier.builder(Nodes.class).child(Node.class,new NodeKey(new NodeId(""String_Node_Str""))).toInstance();
  NodeUpdated nodeUpdated=new NodeUpdatedBuilder().setNodeRef(new NodeRef(nodeInstanceIdentifier)).build();
  initialFlowWriter.onNodeUpdated(nodeUpdated);
  Thread.sleep(250);
  verify(salFlowService,times(1)).addFlow(any(AddFlowInput.class));
}",0.9498327759197324
135844,"/** 
 * Decode an EthernetPacket into an Ipv4Packet
 */
@Override public Ipv6PacketReceived decode(EthernetPacketReceived ethernetPacketReceived){
  Ipv6PacketReceivedBuilder ipv6ReceivedBuilder=new Ipv6PacketReceivedBuilder();
  List<PacketChain> packetChainList=ethernetPacketReceived.getPacketChain();
  EthernetPacket ethernetPacket=(EthernetPacket)packetChainList.get(packetChainList.size() - 1).getPacket();
  int bitOffset=ethernetPacket.getPayloadOffset() * NetUtils.NumBitsInAByte;
  byte[] data=ethernetPacketReceived.getPayload();
  Ipv6PacketBuilder builder=new Ipv6PacketBuilder();
  try {
    builder.setVersion(BitBufferHelper.getShort(BitBufferHelper.getBits(data,bitOffset,4)));
    if (builder.getVersion().intValue() != 6) {
      _logger.debug(""String_Node_Str"" + builder.getVersion());
    }
    builder.setDscp(new Dscp(BitBufferHelper.getShort(BitBufferHelper.getBits(data,bitOffset + 4,6))));
    builder.setEcn(BitBufferHelper.getShort(BitBufferHelper.getBits(data,bitOffset + 10,2)));
    builder.setFlowLabel(BitBufferHelper.getLong(BitBufferHelper.getBits(data,bitOffset + 12,20)));
    builder.setIpv6Length(BitBufferHelper.getInt(BitBufferHelper.getBits(data,bitOffset + 32,16)));
    builder.setNextHeader(KnownIpProtocols.forValue(BitBufferHelper.getInt(BitBufferHelper.getBits(data,bitOffset + 48,8))));
    builder.setHopLimit(BitBufferHelper.getShort(BitBufferHelper.getBits(data,bitOffset + 56,8)));
    builder.setSourceIpv6(Ipv6Address.getDefaultInstance(InetAddress.getByAddress(BitBufferHelper.getBits(data,bitOffset + 64,128)).getHostAddress()));
    builder.setDestinationIpv6(Ipv6Address.getDefaultInstance(InetAddress.getByAddress(BitBufferHelper.getBits(data,bitOffset + 192,128)).getHostAddress()));
    List<ExtensionHeaders> extensionHeaders=new ArrayList<ExtensionHeaders>();
    int extraHeaderBits=0;
    while (builder.getNextHeader() != null && !builder.getNextHeader().equals(KnownIpProtocols.Tcp) && !builder.getNextHeader().equals(KnownIpProtocols.Udp)) {
      int octetLength=BitBufferHelper.getInt(BitBufferHelper.getBits(data,328 + extraHeaderBits + bitOffset,8));
      int start=(336 + extraHeaderBits + bitOffset) / NetUtils.NumBitsInAByte;
      int end=start + 6 + octetLength;
      extensionHeaders.add(new ExtensionHeadersBuilder().setType(builder.getNextHeader()).setLength(octetLength).setData(Arrays.copyOfRange(data,start,end)).build());
      builder.setNextHeader(KnownIpProtocols.forValue(BitBufferHelper.getShort(BitBufferHelper.getBits(data,320 + extraHeaderBits + bitOffset,8))));
      extraHeaderBits+=64 + octetLength * NetUtils.NumBitsInAByte;
    }
    if (!extensionHeaders.isEmpty()) {
      builder.setExtensionHeaders(extensionHeaders);
    }
    int start=(320 + extraHeaderBits + bitOffset) / NetUtils.NumBitsInAByte;
    int end=data.length - 4;
    builder.setPayloadOffset(start);
    builder.setPayloadLength(end - start);
  }
 catch (  BufferException|UnknownHostException e) {
    _logger.debug(""String_Node_Str"",e.getMessage());
  }
  packetChainList.add(new PacketChainBuilder().setPacket(builder.build()).build());
  ipv6ReceivedBuilder.setPacketChain(packetChainList);
  ipv6ReceivedBuilder.setPayload(ethernetPacketReceived.getPayload());
  return ipv6ReceivedBuilder.build();
}","/** 
 * Decode an EthernetPacket into an Ipv4Packet
 */
@Override public Ipv6PacketReceived decode(EthernetPacketReceived ethernetPacketReceived){
  Ipv6PacketReceivedBuilder ipv6ReceivedBuilder=new Ipv6PacketReceivedBuilder();
  List<PacketChain> packetChainList=ethernetPacketReceived.getPacketChain();
  EthernetPacket ethernetPacket=(EthernetPacket)packetChainList.get(packetChainList.size() - 1).getPacket();
  int bitOffset=ethernetPacket.getPayloadOffset() * NetUtils.NumBitsInAByte;
  byte[] data=ethernetPacketReceived.getPayload();
  Ipv6PacketBuilder builder=new Ipv6PacketBuilder();
  try {
    builder.setVersion(BitBufferHelper.getShort(BitBufferHelper.getBits(data,bitOffset,4)));
    if (builder.getVersion().intValue() != 6) {
      _logger.debug(""String_Node_Str"" + builder.getVersion());
    }
    builder.setDscp(new Dscp(BitBufferHelper.getShort(BitBufferHelper.getBits(data,bitOffset + 4,6))));
    builder.setEcn(BitBufferHelper.getShort(BitBufferHelper.getBits(data,bitOffset + 10,2)));
    builder.setFlowLabel(BitBufferHelper.getLong(BitBufferHelper.getBits(data,bitOffset + 12,20)));
    builder.setIpv6Length(BitBufferHelper.getInt(BitBufferHelper.getBits(data,bitOffset + 32,16)));
    builder.setNextHeader(KnownIpProtocols.forValue(BitBufferHelper.getInt(BitBufferHelper.getBits(data,bitOffset + 48,8))));
    builder.setHopLimit(BitBufferHelper.getShort(BitBufferHelper.getBits(data,bitOffset + 56,8)));
    builder.setSourceIpv6(Ipv6Address.getDefaultInstance(InetAddress.getByAddress(BitBufferHelper.getBits(data,bitOffset + 64,128)).getHostAddress()));
    builder.setDestinationIpv6(Ipv6Address.getDefaultInstance(InetAddress.getByAddress(BitBufferHelper.getBits(data,bitOffset + 192,128)).getHostAddress()));
    builder.setPayloadOffset((320 + bitOffset) / NetUtils.NumBitsInAByte);
    builder.setPayloadLength(builder.getIpv6Length());
    List<ExtensionHeaders> extensionHeaders=new ArrayList<ExtensionHeaders>();
    KnownIpProtocols nextHeader=builder.getNextHeader();
    int extHeaderOffset=0;
    while (nextHeader != null && !nextHeader.equals(KnownIpProtocols.Tcp) && !nextHeader.equals(KnownIpProtocols.Udp)) {
      short nextHeaderType=BitBufferHelper.getShort(BitBufferHelper.getBits(data,320 + extHeaderOffset + bitOffset,8));
      nextHeader=KnownIpProtocols.forValue(nextHeaderType);
      int octetLength=BitBufferHelper.getInt(BitBufferHelper.getBits(data,328 + extHeaderOffset + bitOffset,8));
      int start=(336 + extHeaderOffset + bitOffset) / NetUtils.NumBitsInAByte;
      int end=start + 6 + octetLength;
      extensionHeaders.add(new ExtensionHeadersBuilder().setNextHeader(nextHeader).setLength(octetLength).setData(Arrays.copyOfRange(data,start,end)).build());
      extHeaderOffset+=64 + octetLength * NetUtils.NumBitsInAByte;
    }
    if (!extensionHeaders.isEmpty()) {
      builder.setExtensionHeaders(extensionHeaders);
    }
  }
 catch (  BufferException|UnknownHostException e) {
    _logger.debug(""String_Node_Str"",e.getMessage());
  }
  packetChainList.add(new PacketChainBuilder().setPacket(builder.build()).build());
  ipv6ReceivedBuilder.setPacketChain(packetChainList);
  ipv6ReceivedBuilder.setPayload(ethernetPacketReceived.getPayload());
  return ipv6ReceivedBuilder.build();
}",0.8694588810761235
135845,"@Test public void testDecode_ExtensionHeaders() throws Exception {
  byte[] payload={0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,0x01,0x23,0x45,0x67,(byte)0x86,(byte)0xdd,0x60,(byte)0xf0,0x00,0x01,0x00,0x15,0x00,(byte)0x0f,0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,(byte)0xfe,(byte)0xdc,(byte)0xba,(byte)0x98,0x76,0x54,0x32,0x10,(byte)0xfe,(byte)0xdc,(byte)0xba,(byte)0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,0x2b,0x00,(byte)0xab,(byte)0xcd,(byte)0xef,(byte)0x12,(byte)0x34,(byte)0x56,0x11,0x00,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,0x01,0x02,0x03,0x04,0x05,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff};
  NotificationProviderService npServiceMock=Mockito.mock(NotificationProviderService.class);
  ArrayList<PacketChain> packetChainList=new ArrayList<PacketChain>();
  packetChainList.add(new PacketChainBuilder().setPacket(new RawPacketBuilder().build()).build());
  packetChainList.add(new PacketChainBuilder().setPacket(new EthernetPacketBuilder().setPayloadOffset(14).build()).build());
  Ipv6PacketReceived notification=new Ipv6Decoder(npServiceMock).decode(new EthernetPacketReceivedBuilder().setPacketChain(packetChainList).setPayload(payload).build());
  Ipv6Packet ipv6Packet=(Ipv6Packet)notification.getPacketChain().get(2).getPacket();
  assertEquals(6,ipv6Packet.getVersion().intValue());
  assertEquals(3,ipv6Packet.getDscp().getValue().intValue());
  assertEquals(3,ipv6Packet.getEcn().intValue());
  assertEquals(1,ipv6Packet.getFlowLabel().intValue());
  assertEquals(21,ipv6Packet.getIpv6Length().intValue());
  assertEquals(KnownIpProtocols.Udp,ipv6Packet.getNextHeader());
  assertEquals(15,ipv6Packet.getHopLimit().intValue());
  assertEquals(""String_Node_Str"",ipv6Packet.getSourceIpv6().getValue());
  assertEquals(""String_Node_Str"",ipv6Packet.getDestinationIpv6().getValue());
  assertEquals(KnownIpProtocols.Hopopt,ipv6Packet.getExtensionHeaders().get(0).getType());
  assertEquals(0,ipv6Packet.getExtensionHeaders().get(0).getLength().intValue());
  assertTrue(Arrays.equals(ipv6Packet.getExtensionHeaders().get(0).getData(),Arrays.copyOfRange(payload,56,62)));
  assertEquals(KnownIpProtocols.Ipv6Route,ipv6Packet.getExtensionHeaders().get(1).getType());
  assertEquals(0,ipv6Packet.getExtensionHeaders().get(1).getLength().intValue());
  assertTrue(Arrays.equals(ipv6Packet.getExtensionHeaders().get(1).getData(),Arrays.copyOfRange(payload,64,70)));
  assertEquals(70,ipv6Packet.getPayloadOffset().intValue());
  assertEquals(5,ipv6Packet.getPayloadLength().intValue());
  assertTrue(Arrays.equals(payload,notification.getPayload()));
}","@Test public void testDecode_ExtensionHeaders() throws Exception {
  byte[] payload={0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,0x01,0x23,0x45,0x67,(byte)0x86,(byte)0xdd,0x60,(byte)0xf0,0x00,0x01,0x00,0x15,0x00,(byte)0x0f,0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,(byte)0xfe,(byte)0xdc,(byte)0xba,(byte)0x98,0x76,0x54,0x32,0x10,(byte)0xfe,(byte)0xdc,(byte)0xba,(byte)0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,0x2b,0x00,(byte)0xab,(byte)0xcd,(byte)0xef,(byte)0x12,(byte)0x34,(byte)0x56,0x11,0x00,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,0x01,0x02,0x03,0x04,0x05,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff};
  NotificationProviderService npServiceMock=Mockito.mock(NotificationProviderService.class);
  ArrayList<PacketChain> packetChainList=new ArrayList<PacketChain>();
  packetChainList.add(new PacketChainBuilder().setPacket(new RawPacketBuilder().build()).build());
  packetChainList.add(new PacketChainBuilder().setPacket(new EthernetPacketBuilder().setPayloadOffset(14).build()).build());
  Ipv6PacketReceived notification=new Ipv6Decoder(npServiceMock).decode(new EthernetPacketReceivedBuilder().setPacketChain(packetChainList).setPayload(payload).build());
  Ipv6Packet ipv6Packet=(Ipv6Packet)notification.getPacketChain().get(2).getPacket();
  assertEquals(6,ipv6Packet.getVersion().intValue());
  assertEquals(3,ipv6Packet.getDscp().getValue().intValue());
  assertEquals(3,ipv6Packet.getEcn().intValue());
  assertEquals(1,ipv6Packet.getFlowLabel().intValue());
  assertEquals(21,ipv6Packet.getIpv6Length().intValue());
  assertEquals(KnownIpProtocols.Hopopt,ipv6Packet.getNextHeader());
  assertEquals(15,ipv6Packet.getHopLimit().intValue());
  assertEquals(""String_Node_Str"",ipv6Packet.getSourceIpv6().getValue());
  assertEquals(""String_Node_Str"",ipv6Packet.getDestinationIpv6().getValue());
  assertEquals(KnownIpProtocols.Ipv6Route,ipv6Packet.getExtensionHeaders().get(0).getNextHeader());
  assertEquals(0,ipv6Packet.getExtensionHeaders().get(0).getLength().intValue());
  assertTrue(Arrays.equals(ipv6Packet.getExtensionHeaders().get(0).getData(),Arrays.copyOfRange(payload,56,62)));
  assertEquals(KnownIpProtocols.Udp,ipv6Packet.getExtensionHeaders().get(1).getNextHeader());
  assertEquals(0,ipv6Packet.getExtensionHeaders().get(1).getLength().intValue());
  assertTrue(Arrays.equals(ipv6Packet.getExtensionHeaders().get(1).getData(),Arrays.copyOfRange(payload,64,70)));
  assertEquals(54,ipv6Packet.getPayloadOffset().intValue());
  assertEquals(21,ipv6Packet.getPayloadLength().intValue());
  assertTrue(Arrays.equals(payload,notification.getPayload()));
}",0.9730232558139534
135846,"@Test public void testDecode_ExtensionHeader() throws Exception {
  byte[] payload={0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,0x01,0x23,0x45,0x67,(byte)0x86,(byte)0xdd,0x60,(byte)0xf0,0x00,0x01,0x00,0x0d,0x00,(byte)0x0f,0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,(byte)0xfe,(byte)0xdc,(byte)0xba,(byte)0x98,0x76,0x54,0x32,0x10,(byte)0xfe,(byte)0xdc,(byte)0xba,(byte)0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,0x11,0x00,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,0x01,0x02,0x03,0x04,0x05,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff};
  NotificationProviderService npServiceMock=Mockito.mock(NotificationProviderService.class);
  ArrayList<PacketChain> packetChainList=new ArrayList<PacketChain>();
  packetChainList.add(new PacketChainBuilder().setPacket(new RawPacketBuilder().build()).build());
  packetChainList.add(new PacketChainBuilder().setPacket(new EthernetPacketBuilder().setPayloadOffset(14).build()).build());
  Ipv6PacketReceived notification=new Ipv6Decoder(npServiceMock).decode(new EthernetPacketReceivedBuilder().setPacketChain(packetChainList).setPayload(payload).build());
  Ipv6Packet ipv6Packet=(Ipv6Packet)notification.getPacketChain().get(2).getPacket();
  assertEquals(6,ipv6Packet.getVersion().intValue());
  assertEquals(3,ipv6Packet.getDscp().getValue().intValue());
  assertEquals(3,ipv6Packet.getEcn().intValue());
  assertEquals(1,ipv6Packet.getFlowLabel().intValue());
  assertEquals(13,ipv6Packet.getIpv6Length().intValue());
  assertEquals(KnownIpProtocols.Udp,ipv6Packet.getNextHeader());
  assertEquals(15,ipv6Packet.getHopLimit().intValue());
  assertEquals(""String_Node_Str"",ipv6Packet.getSourceIpv6().getValue());
  assertEquals(""String_Node_Str"",ipv6Packet.getDestinationIpv6().getValue());
  assertEquals(KnownIpProtocols.Hopopt,ipv6Packet.getExtensionHeaders().get(0).getType());
  assertEquals(0,ipv6Packet.getExtensionHeaders().get(0).getLength().intValue());
  assertTrue(Arrays.equals(ipv6Packet.getExtensionHeaders().get(0).getData(),Arrays.copyOfRange(payload,56,62)));
  assertEquals(62,ipv6Packet.getPayloadOffset().intValue());
  assertEquals(5,ipv6Packet.getPayloadLength().intValue());
  assertTrue(Arrays.equals(payload,notification.getPayload()));
}","@Test public void testDecode_ExtensionHeader() throws Exception {
  byte[] payload={0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,0x01,0x23,0x45,0x67,(byte)0x86,(byte)0xdd,0x60,(byte)0xf0,0x00,0x01,0x00,0x0d,0x00,(byte)0x0f,0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,(byte)0xfe,(byte)0xdc,(byte)0xba,(byte)0x98,0x76,0x54,0x32,0x10,(byte)0xfe,(byte)0xdc,(byte)0xba,(byte)0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,(byte)0x89,(byte)0xab,(byte)0xcd,(byte)0xef,0x11,0x00,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,0x01,0x02,0x03,0x04,0x05,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff};
  NotificationProviderService npServiceMock=Mockito.mock(NotificationProviderService.class);
  ArrayList<PacketChain> packetChainList=new ArrayList<PacketChain>();
  packetChainList.add(new PacketChainBuilder().setPacket(new RawPacketBuilder().build()).build());
  packetChainList.add(new PacketChainBuilder().setPacket(new EthernetPacketBuilder().setPayloadOffset(14).build()).build());
  Ipv6PacketReceived notification=new Ipv6Decoder(npServiceMock).decode(new EthernetPacketReceivedBuilder().setPacketChain(packetChainList).setPayload(payload).build());
  Ipv6Packet ipv6Packet=(Ipv6Packet)notification.getPacketChain().get(2).getPacket();
  assertEquals(6,ipv6Packet.getVersion().intValue());
  assertEquals(3,ipv6Packet.getDscp().getValue().intValue());
  assertEquals(3,ipv6Packet.getEcn().intValue());
  assertEquals(1,ipv6Packet.getFlowLabel().intValue());
  assertEquals(13,ipv6Packet.getIpv6Length().intValue());
  assertEquals(KnownIpProtocols.Hopopt,ipv6Packet.getNextHeader());
  assertEquals(15,ipv6Packet.getHopLimit().intValue());
  assertEquals(""String_Node_Str"",ipv6Packet.getSourceIpv6().getValue());
  assertEquals(""String_Node_Str"",ipv6Packet.getDestinationIpv6().getValue());
  assertEquals(KnownIpProtocols.Udp,ipv6Packet.getExtensionHeaders().get(0).getNextHeader());
  assertEquals(0,ipv6Packet.getExtensionHeaders().get(0).getLength().intValue());
  assertTrue(Arrays.equals(ipv6Packet.getExtensionHeaders().get(0).getData(),Arrays.copyOfRange(payload,56,62)));
  assertEquals(54,ipv6Packet.getPayloadOffset().intValue());
  assertEquals(13,ipv6Packet.getPayloadLength().intValue());
  assertTrue(Arrays.equals(payload,notification.getPayload()));
}",0.9756202804746494
135847,"/** 
 * Setup the L2Switch.
 * @param consumerContext The context of the L2Switch.
 */
@Override public void onSessionInitialized(BindingAwareBroker.ConsumerContext consumerContext){
  DataBrokerService dataService=consumerContext.<DataBrokerService>getSALService(DataBrokerService.class);
  NetworkGraphService networkGraphService=new NetworkGraphDijkstra();
  FlowWriterService flowWriterService=new FlowWriterServiceImpl(dataService,networkGraphService);
  this.topologyLinkDataChangeHandler=new TopologyLinkDataChangeHandler(dataService,networkGraphService);
  topologyLinkDataChangeHandler.registerAsDataChangeListener();
  PacketProcessingService packetProcessingService=consumerContext.<PacketProcessingService>getRpcService(PacketProcessingService.class);
  PacketDispatcher packetDispatcher=new PacketDispatcher();
  packetDispatcher.setInventoryReader(new InventoryReader(dataService));
  packetDispatcher.setPacketProcessingService(packetProcessingService);
  packetDispatcher.setFlowWriterService(flowWriterService);
  AddressObservationWriter addressObservationWriter=new AddressObservationWriter(dataService);
  AddressObserver addressObserver=new AddressObserver(addressObservationWriter,packetDispatcher);
  NotificationService notificationService=consumerContext.<NotificationService>getSALService(NotificationService.class);
  this.listenerRegistration=notificationService.registerNotificationListener(addressObserver);
}","/** 
 * Setup the L2Switch.
 * @param consumerContext The context of the L2Switch.
 */
@Override public void onSessionInitialized(BindingAwareBroker.ConsumerContext consumerContext){
  DataBroker dataService=consumerContext.<DataBroker>getSALService(DataBroker.class);
  NetworkGraphService networkGraphService=new NetworkGraphDijkstra();
  PacketProcessingService packetProcessingService=consumerContext.<PacketProcessingService>getRpcService(PacketProcessingService.class);
  PacketDispatcher packetDispatcher=new PacketDispatcher();
  packetDispatcher.setInventoryReader(new InventoryReader(dataService));
  packetDispatcher.setPacketProcessingService(packetProcessingService);
  AddressObservationWriter addressObservationWriter=new AddressObservationWriter(dataService);
  AddressObserver addressObserver=new AddressObserver(addressObservationWriter,packetDispatcher);
  NotificationService notificationService=consumerContext.<NotificationService>getSALService(NotificationService.class);
  this.listenerRegistration=notificationService.registerNotificationListener(addressObserver);
}",0.8624505928853755
135848,"/** 
 * Construct an AddressTracker with the specified inputs
 * @param dataService  The DataBrokerService for the AddressTracker
 */
public AddressObservationWriter(DataBrokerService dataService){
  this.dataService=dataService;
}","/** 
 * Construct an AddressTracker with the specified inputs
 * @param dataService The DataBrokerService for the AddressTracker
 */
public AddressObservationWriter(DataBroker dataService){
  this.dataService=dataService;
}",0.9823788546255506
135849,"/** 
 * Add addresses into the MD-SAL data tree
 * @param macAddress  The MacAddress of the new L2Address object
 * @param nodeConnectorRef  The NodeConnectorRef of the new L2Address object
 */
public void addAddress(MacAddress macAddress,IpAddress ipAddress,NodeConnectorRef nodeConnectorRef){
  if (macAddress == null || ipAddress == null || nodeConnectorRef == null) {
    return;
  }
  long now=new Date().getTime();
  final AddressCapableNodeConnectorBuilder acncBuilder=new AddressCapableNodeConnectorBuilder();
  final AddressesBuilder addressBuilder=new AddressesBuilder().setIp(ipAddress).setMac(macAddress).setFirstSeen(now).setLastSeen(now).setKey(new AddressesKey(now));
  List<Addresses> addresses=null;
  NodeConnector nc=(NodeConnector)dataService.readOperationalData(nodeConnectorRef.getValue());
  AddressCapableNodeConnector acnc=(AddressCapableNodeConnector)nc.getAugmentation(AddressCapableNodeConnector.class);
  if (acnc != null && acnc.getAddresses() != null) {
    addresses=acnc.getAddresses();
    for (int i=0; i < addresses.size(); i++) {
      if (addresses.get(i).getIp().equals(ipAddress) && addresses.get(i).getMac().equals(macAddress)) {
        addressBuilder.setFirstSeen(addresses.get(i).getFirstSeen()).setKey(addresses.get(i).getKey());
        addresses.remove(i);
        break;
      }
    }
  }
 else {
    addresses=new ArrayList<>();
  }
  addresses.add(addressBuilder.build());
  acncBuilder.setAddresses(addresses);
  NodeConnectorBuilder ncBuilder=new NodeConnectorBuilder(nc).setKey(nc.getKey()).addAugmentation(AddressCapableNodeConnector.class,acncBuilder.build());
  final DataModificationTransaction it=dataService.beginTransaction();
  it.putOperationalData(nodeConnectorRef.getValue(),ncBuilder.build());
  it.commit();
}","/** 
 * Add addresses into the MD-SAL data tree
 * @param macAddress       The MacAddress of the new L2Address object
 * @param nodeConnectorRef The NodeConnectorRef of the new L2Address object
 */
public void addAddress(MacAddress macAddress,IpAddress ipAddress,NodeConnectorRef nodeConnectorRef){
  if (macAddress == null || ipAddress == null || nodeConnectorRef == null) {
    return;
  }
  NodeConnectorLock nodeConnectorLock;
synchronized (this) {
    nodeConnectorLock=lockMap.get(nodeConnectorRef);
    if (nodeConnectorLock == null) {
      nodeConnectorLock=new NodeConnectorLock();
      lockMap.put(nodeConnectorRef,nodeConnectorLock);
    }
  }
synchronized (nodeConnectorLock) {
    long now=new Date().getTime();
    final AddressCapableNodeConnectorBuilder acncBuilder=new AddressCapableNodeConnectorBuilder();
    final AddressesBuilder addressBuilder=new AddressesBuilder().setIp(ipAddress).setMac(macAddress).setFirstSeen(now).setLastSeen(now).setKey(new AddressesKey(now));
    List<Addresses> addresses=null;
    ReadWriteTransaction readWriteTransaction=dataService.newReadWriteTransaction();
    NodeConnector nc=null;
    try {
      Optional<DataObject> dataObjectOptional=readWriteTransaction.read(LogicalDatastoreType.OPERATIONAL,nodeConnectorRef.getValue()).get();
      if (dataObjectOptional.isPresent())       nc=(NodeConnector)dataObjectOptional.get();
    }
 catch (    Exception e) {
      _logger.error(""String_Node_Str"",nodeConnectorRef.getValue());
      readWriteTransaction.commit();
      throw new RuntimeException(""String_Node_Str"" + nodeConnectorRef,e);
    }
    if (nc == null) {
      readWriteTransaction.commit();
      return;
    }
    AddressCapableNodeConnector acnc=(AddressCapableNodeConnector)nc.getAugmentation(AddressCapableNodeConnector.class);
    if (acnc != null && acnc.getAddresses() != null) {
      addresses=acnc.getAddresses();
      for (int i=0; i < addresses.size(); i++) {
        if (addresses.get(i).getIp().equals(ipAddress) && addresses.get(i).getMac().equals(macAddress)) {
          addressBuilder.setFirstSeen(addresses.get(i).getFirstSeen()).setKey(addresses.get(i).getKey());
          addresses.remove(i);
          break;
        }
      }
    }
 else {
      addresses=new ArrayList<>();
    }
    addresses.add(addressBuilder.build());
    acncBuilder.setAddresses(addresses);
    NodeConnectorBuilder ncBuilder=new NodeConnectorBuilder(nc).setKey(nc.getKey()).addAugmentation(AddressCapableNodeConnector.class,acncBuilder.build());
    readWriteTransaction.put(LogicalDatastoreType.OPERATIONAL,nodeConnectorRef.getValue(),ncBuilder.build());
    readWriteTransaction.commit();
  }
}",0.7187570367034452
135850,"/** 
 * The handler function for IPv4 packets.
 * @param packetReceived  The incoming packet.
 */
@Override public void onIpv4PacketOverEthernetReceived(Ipv4PacketOverEthernetReceived packetReceived){
  addressObservationWriter.addAddress(packetReceived.getEthernetOverRawPacket().getEthernetPacket().getSourceMac(),new IpAddress(packetReceived.getIpv4Packet().getSourceIpv4()),packetReceived.getEthernetOverRawPacket().getRawPacket().getIngress());
  packetDispatcher.sendPacketOut(packetReceived.getPayload(),packetReceived.getEthernetOverRawPacket().getRawPacket().getIngress());
}","/** 
 * The handler function for IPv4 packets.
 * @param packetReceived  The incoming packet.
 */
@Override public void onIpv4PacketOverEthernetReceived(Ipv4PacketOverEthernetReceived packetReceived){
  if (!IPV4_IP_TO_IGNORE.equals(packetReceived.getIpv4Packet().getSourceIpv4().getValue())) {
    addressObservationWriter.addAddress(packetReceived.getEthernetOverRawPacket().getEthernetPacket().getSourceMac(),new IpAddress(packetReceived.getIpv4Packet().getSourceIpv4().getValue().toCharArray()),packetReceived.getEthernetOverRawPacket().getRawPacket().getIngress());
    packetDispatcher.sendPacketOut(packetReceived.getPayload(),packetReceived.getEthernetOverRawPacket().getRawPacket().getIngress());
  }
}",0.901930501930502
135851,"/** 
 * Construct an InventoryService object with the specified inputs.
 * @param dataService  The DataBrokerService associated with the InventoryService.
 */
public InventoryReader(DataBrokerService dataService){
  this.dataService=dataService;
  controllerSwitchConnectors=new HashMap<String,NodeConnectorRef>();
  switchNodeConnectors=new HashMap<String,List<NodeConnectorRef>>();
}","/** 
 * Construct an InventoryService object with the specified inputs.
 * @param dataService The DataBrokerService associated with the InventoryService.
 */
public InventoryReader(DataBroker dataService){
  this.dataService=dataService;
  controllerSwitchConnectors=new HashMap<String,NodeConnectorRef>();
  switchNodeConnectors=new HashMap<String,List<NodeConnectorRef>>();
}",0.989501312335958
135852,"/** 
 * Get the External NodeConnectors of the network, which are the NodeConnectors connected to hosts.
 * @return  The list of external node connectors.
 */
public void readInventory(){
  if (controllerSwitchConnectors.size() > 0 || switchNodeConnectors.size() > 0) {
    return;
  }
  InstanceIdentifier.InstanceIdentifierBuilder<Nodes> nodesInsIdBuilder=InstanceIdentifier.<Nodes>builder(Nodes.class);
  Nodes nodes=(Nodes)dataService.readOperationalData(nodesInsIdBuilder.toInstance());
  if (nodes != null) {
    for (    Node node : nodes.getNode()) {
      ArrayList<NodeConnectorRef> nodeConnectorRefs=new ArrayList<NodeConnectorRef>();
      List<NodeConnector> nodeConnectors=node.getNodeConnector();
      if (nodeConnectors != null) {
        for (        NodeConnector nodeConnector : nodeConnectors) {
          NodeConnectorRef ncRef=new NodeConnectorRef(InstanceIdentifier.<Nodes>builder(Nodes.class).<Node,NodeKey>child(Node.class,node.getKey()).<NodeConnector,NodeConnectorKey>child(NodeConnector.class,nodeConnector.getKey()).toInstance());
          if (nodeConnector.getKey().toString().contains(""String_Node_Str"")) {
            controllerSwitchConnectors.put(node.getId().getValue(),ncRef);
          }
 else {
            nodeConnectorRefs.add(ncRef);
          }
        }
      }
      switchNodeConnectors.put(node.getId().getValue(),nodeConnectorRefs);
    }
  }
}","/** 
 * Get the External NodeConnectors of the network, which are the NodeConnectors connected to hosts.
 * @return The list of external node connectors.
 */
public void readInventory(){
  if (controllerSwitchConnectors.size() > 0 || switchNodeConnectors.size() > 0) {
    return;
  }
  InstanceIdentifier.InstanceIdentifierBuilder<Nodes> nodesInsIdBuilder=InstanceIdentifier.<Nodes>builder(Nodes.class);
  Nodes nodes=null;
  ReadOnlyTransaction readOnlyTransaction=dataService.newReadOnlyTransaction();
  try {
    Optional<DataObject> dataObjectOptional=null;
    dataObjectOptional=readOnlyTransaction.read(LogicalDatastoreType.OPERATIONAL,nodesInsIdBuilder.toInstance()).get();
    if (dataObjectOptional.isPresent())     nodes=(Nodes)dataObjectOptional.get();
  }
 catch (  InterruptedException e) {
    _logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  ExecutionException e) {
    _logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (nodes != null) {
    for (    Node node : nodes.getNode()) {
      ArrayList<NodeConnectorRef> nodeConnectorRefs=new ArrayList<NodeConnectorRef>();
      List<NodeConnector> nodeConnectors=node.getNodeConnector();
      if (nodeConnectors != null) {
        for (        NodeConnector nodeConnector : nodeConnectors) {
          NodeConnectorRef ncRef=new NodeConnectorRef(InstanceIdentifier.<Nodes>builder(Nodes.class).<Node,NodeKey>child(Node.class,node.getKey()).<NodeConnector,NodeConnectorKey>child(NodeConnector.class,nodeConnector.getKey()).toInstance());
          if (nodeConnector.getKey().toString().contains(""String_Node_Str"")) {
            controllerSwitchConnectors.put(node.getId().getValue(),ncRef);
          }
 else {
            nodeConnectorRefs.add(ncRef);
          }
        }
      }
      switchNodeConnectors.put(node.getId().getValue(),nodeConnectorRefs);
    }
  }
}",0.8251579897682817
135853,"private void deriveClauses(){
  boolean selector=false;
  clauses=new LinkedHashSet<>();
  model=grounding.problem().induce();
  if (dataset.size() > 0) {
    if (selector) {
      model.addHide(""String_Node_Str"");
      model.addShow(String.format(""String_Node_Str"",UCL));
      model.addClause(String.format(""String_Node_Str"",UCL));
      int cc=0;
      for (      Clause clause : dataset) {
        cc+=1;
        model.addClause(String.format(""String_Node_Str"",cc));
        model.addClause(String.format(""String_Node_Str"",UCL));
        int ll=0;
        for (        Literal literal : clause) {
          ll+=1;
          model.addClause(String.format(""String_Node_Str"",cc,ll));
        }
      }
    }
 else {
      Map<Integer,StringJoiner> levels=new TreeMap<>();
      StringJoiner minimee=new StringJoiner(""String_Node_Str"");
      int cc=0;
      for (      Clause clause : dataset) {
        cc+=1;
        Atom head=clause.head();
        Clause simple=new Clause(head.get(Atom.ID_ATOM));
        deriveLevel(cc,0,new Literal(false,head),levels);
        String heads=join(head,Atom.ID_TYPES);
        minimee.add(String.format(""String_Node_Str"",cc,head.get(Atom.ID_WEIGHT),head.get(Atom.ID_PRIORITY)));
        deriveLiterals(cc,clause,simple,levels,heads,minimee);
        for (        Atom type : head.get(Atom.ID_ACCESSORS).get(Atom.ID_TYPES)) {
          Literal literal=new Literal(false,type);
          if (!simple.contains(literal))           simple.append(literal);
        }
        clauses.add(simple);
        if (levels.size() > 1)         for (        int lvl : levels.keySet()) {
          model.addClause(String.format(""String_Node_Str"",LEVEL,cc,lvl,levels.get(lvl).toString()));
          model.addConstraint(String.format(""String_Node_Str"",LEVEL,cc,lvl,LEVEL,cc,lvl + 1));
        }
        model.addFact(String.format(""String_Node_Str"",CLAUSE,cc));
      }
      model.addHide(""String_Node_Str"");
      model.addShow(String.format(""String_Node_Str"",UCL));
      model.addMinimize(String.format(""String_Node_Str"",minimee.toString()));
      model.addClause(String.format(""String_Node_Str"",UCL));
    }
  }
}","private void deriveClauses(){
  clauses=new LinkedHashSet<>();
  model=grounding.problem().induce();
  if (dataset.size() > 0) {
    String min=""String_Node_Str"";
    int cc=0;
    for (    Clause clause : dataset) {
      cc+=1;
      String choices=""String_Node_Str"";
      Atom head=clause.head();
      Clause simple=new Clause(head.get(Atom.ID_ATOM));
      for (      Atom term : head.get(Atom.ID_ACCESSORS).get(Atom.ID_TYPES)) {
        Literal type=new Literal(false,term);
        if (!simple.contains(type))         simple.append(type);
      }
      int ll=0;
      for (      Literal literal : clause) {
        ll+=1;
        int lvl=convert(literal.get(Atom.ID_LEVEL).toString());
        Literal desired=new Literal(literal.negated(),literal.get(Atom.ID_ATOM));
        if (!simple.contains(desired))         simple.append(desired);
        for (        Atom term : literal.atom().get(Atom.ID_ACCESSORS).get(Atom.ID_TYPES)) {
          Literal type=new Literal(false,term);
          if (!simple.contains(type))           simple.append(type);
        }
        String vars=combine(literal.atom(),Atom.ID_VARS);
        String types=combine(literal.atom(),Atom.ID_TYPES);
        String uses=String.format(""String_Node_Str"",UCL,cc,ll);
        String tries=String.format(""String_Node_Str"",TCL,cc,ll,vars);
        String level=String.format(""String_Node_Str"",LEVEL,cc,lvl);
        min+=(min.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"") + String.format(""String_Node_Str"",uses,literal.get(Atom.ID_WEIGHT),literal.get(Atom.ID_PRIORITY));
        choices+=""String_Node_Str"" + tries;
        model.addClause(String.format(""String_Node_Str"",tries,uses,types));
        model.addClause(String.format(""String_Node_Str"",tries,uses,types,desired.toString()));
        model.addClause(String.format(""String_Node_Str"",level,uses));
        if (lvl > 0)         model.addConstraint(String.format(""String_Node_Str"",cc,lvl - 1,level));
        model.addFact(String.format(""String_Node_Str"",LITERAL,cc,ll));
      }
      String types=combine(head,Atom.ID_TYPES);
      String uses=String.format(""String_Node_Str"",UCL,cc);
      min+=(min.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"") + String.format(""String_Node_Str"",uses,head.get(Atom.ID_WEIGHT),head.get(Atom.ID_PRIORITY));
      model.addClause(String.format(""String_Node_Str"",UCL,CLAUSE,LITERAL));
      model.addClause(String.format(""String_Node_Str"",LEVEL,cc,UCL,cc));
      model.addClause(String.format(""String_Node_Str"",simple.head().toString(),uses,choices,types));
      model.addFact(String.format(""String_Node_Str"",CLAUSE,cc));
      clauses.add(simple);
    }
    model.addHide(""String_Node_Str"");
    model.addShow(String.format(""String_Node_Str"",UCL));
    model.addClause(String.format(""String_Node_Str"",UCL));
    if (!min.isEmpty())     model.addClause(String.format(""String_Node_Str"",min));
  }
}",0.2940824865511058
135854,"@Override public void syntaxError(Recognizer<?,?> recognizer,Object offendingSymbol,int line,int charPositionInLine,String msg,RecognitionException e){
  if (msg.startsWith(""String_Node_Str"")) {
    msg=msg.substring(11);
    System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),e.getMessage(),line,charPositionInLine));
  }
 else   if (msg.startsWith(""String_Node_Str"")) {
    msg=msg.substring(9);
    System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),e.getMessage(),line,charPositionInLine));
  }
 else   System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),e.getMessage(),line,charPositionInLine));
}","@Override public void syntaxError(Recognizer<?,?> recognizer,Object offendingSymbol,int line,int charPositionInLine,String msg,RecognitionException e){
  if (msg.startsWith(""String_Node_Str"")) {
    msg=msg.substring(11);
    System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),msg,line,charPositionInLine));
  }
 else   if (msg.startsWith(""String_Node_Str"")) {
    msg=msg.substring(9);
    System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),msg,line,charPositionInLine));
  }
 else   System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),msg,line,charPositionInLine));
}",0.9613343442001516
135855,"@Override public void exitGroundMinus1(GroundMinus1Context ctx){
  if (null != ctx)   builders.push(Builder.get(Atom.ARITH_MINUS).append(ctx.groundAtom().getText()));
}","@Override public void exitGroundMinus1(GroundMinus1Context ctx){
  if (null != ctx)   builders.push(Builder.get(""String_Node_Str"" + ctx.groundAtom().getText()));
}",0.8882175226586103
135856,"@Override public void exitGroundPredicate(GroundPredicateContext ctx){
  if (null != ctx) {
    Stack<Atom> atoms=new Stack<>();
    for (int i=0; i < ctx.groundTerm().size(); i++)     atoms.push(builders.pop().build());
    Builder builder=builders.peek();
    while (!atoms.empty())     builder.append(atoms.pop());
  }
}","@Override public void exitGroundPredicate(GroundPredicateContext ctx){
  if (null != ctx) {
    Stack<Atom> atoms=new Stack<>();
    for (int i=0; i < ctx.groundTerm().size(); i++) {
      Atom atom=builders.pop().build();
      String name=atom.name();
      if (0 == atom.arity() && isNegValue(name)) {
        Atom discard=builders.peek().build();
        if (0 == discard.arity() && name.equals(""String_Node_Str"" + discard.name()))         builders.pop();
      }
      atoms.push(atom);
    }
    Builder builder=builders.peek();
    while (!atoms.empty())     builder.append(atoms.pop());
  }
}",0.647887323943662
135857,"@Override public void syntaxError(Recognizer<?,?> recognizer,Object offendingSymbol,int line,int charPositionInLine,String msg,RecognitionException e){
  if (msg.startsWith(""String_Node_Str"")) {
    msg=msg.substring(11);
    System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),e.getMessage(),line,charPositionInLine));
  }
 else   if (msg.startsWith(""String_Node_Str"")) {
    msg=msg.substring(9);
    System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),e.getMessage(),line,charPositionInLine));
  }
 else   System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),e.getMessage(),line,charPositionInLine));
}","@Override public void syntaxError(Recognizer<?,?> recognizer,Object offendingSymbol,int line,int charPositionInLine,String msg,RecognitionException e){
  if (msg.startsWith(""String_Node_Str"")) {
    msg=msg.substring(11);
    System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),msg,line,charPositionInLine));
  }
 else   if (msg.startsWith(""String_Node_Str"")) {
    msg=msg.substring(9);
    System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),msg,line,charPositionInLine));
  }
 else   System.err.println(String.format(""String_Node_Str"",Version.get().getTitle(),msg,line,charPositionInLine));
}",0.9613343442001516
135858,"public void validatePage(boolean switchToErrorPage){
  if (getManagedForm() == null) {
    return;
  }
  DataBindingManager dm=getDataBindingManager();
  IMessageManager mm=getManagedForm().getMessageManager();
  ModelEditor modelEditor=(ModelEditor)getEditor();
  resetAllMessages(false);
  ModuleNode rootModuleNode=SemanticHelper.getRootModuleNode();
  getLookupHelper().resetModelNames(this);
  List<Assignment> constants=(List<Assignment>)constantTable.getInput();
  if (rootModuleNode != null) {
    List<Assignment> toDelete=ModelHelper.mergeConstantLists(constants,ModelHelper.createConstantsList(rootModuleNode));
    if (!toDelete.isEmpty()) {
      SectionPart constantSection=dm.getSection(dm.getSectionForAttribute(MODEL_PARAMETER_CONSTANTS));
      if (constantSection != null) {
        constantSection.markDirty();
      }
    }
    constantTable.setInput(constants);
  }
  String symmetryType=null;
  for (int i=0; i < constants.size(); i++) {
    Assignment constant=(Assignment)constants.get(i);
    List<String> values=Arrays.asList(constant.getParams());
    validateId(MODEL_PARAMETER_CONSTANTS,values,""String_Node_Str"",""String_Node_Str"");
    if (constant.getRight() == null || EMPTY_STRING.equals(constant.getRight())) {
      modelEditor.addErrorMessage(constant.getLabel(),""String_Node_Str"" + constant.getLabel(),this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS)));
      setComplete(false);
      expandSection(dm.getSectionForAttribute(MODEL_PARAMETER_CONSTANTS));
    }
 else {
      if (constant.isSetOfModelValues()) {
        TypedSet modelValuesSet=TypedSet.parseSet(constant.getRight());
        if (constant.isSymmetricalSet()) {
          boolean hasTwoTypes=false;
          String typeString=null;
          if (modelValuesSet.hasType()) {
            typeString=modelValuesSet.getType();
          }
 else {
            for (int j=0; j < modelValuesSet.getValues().length; j++) {
              String thisTypeString=TypedSet.getTypeOfId(modelValuesSet.getValues()[j]);
              if (thisTypeString != null) {
                if (typeString != null && !typeString.equals(thisTypeString)) {
                  hasTwoTypes=true;
                }
 else {
                  typeString=thisTypeString;
                }
              }
            }
          }
          if (hasTwoTypes || (symmetryType != null && typeString != null && !typeString.equals(symmetryType))) {
            modelEditor.addErrorMessage(constant.getLabel(),""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS)));
            setComplete(false);
            expandSection(dm.getSectionForAttribute(MODEL_PARAMETER_CONSTANTS));
          }
 else {
            if (typeString != null) {
              symmetryType=typeString;
            }
          }
        }
        if (modelValuesSet.getValueCount() > 0) {
          List<String> mvList=modelValuesSet.getValuesAsList();
          validateUsage(MODEL_PARAMETER_CONSTANTS,mvList,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
          validateId(MODEL_PARAMETER_CONSTANTS,mvList,""String_Node_Str"",""String_Node_Str"");
          Control widget=UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS));
          for (int j=0; j < mvList.size(); j++) {
            String value=(String)mvList.get(j);
            if (SemanticHelper.isConfigFileKeyword(value)) {
              modelEditor.addErrorMessage(value,""String_Node_Str"" + value + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
              setComplete(false);
            }
          }
        }
 else {
          modelEditor.addErrorMessage(constant.getLabel(),""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS)));
          setComplete(false);
        }
      }
    }
    if (SemanticHelper.isConfigFileKeyword(constant.getLabel())) {
      modelEditor.addErrorMessage(constant.getLabel(),""String_Node_Str"" + constant.getLabel() + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS)));
      setComplete(false);
    }
  }
  for (int i=0; i < constants.size(); i++) {
    Assignment constant=(Assignment)constants.get(i);
    List<String> values=Arrays.asList(constant.getParams());
    validateUsage(MODEL_PARAMETER_CONSTANTS,values,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
  }
  int number=workers.getSelection();
  if (number > Runtime.getRuntime().availableProcessors()) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"" + number + ""String_Node_Str""+ Runtime.getRuntime().availableProcessors()+ ""String_Node_Str"",this.getId(),IMessageProvider.WARNING,UIHelper.getWidget(dm.getAttributeControl(LAUNCH_NUMBER_OF_WORKERS)));
    expandSection(SEC_HOW_TO_RUN);
  }
  try {
    final int defaultMaxHeapSize=TLCUIActivator.getDefault().getPreferenceStore().getInt(ITLCPreferenceConstants.I_TLC_MAXIMUM_HEAP_SIZE_DEFAULT);
    final int legacyValue=getConfig().getAttribute(LAUNCH_MAX_HEAP_SIZE,defaultMaxHeapSize);
    if (legacyValue == 500) {
      getConfig().setAttribute(LAUNCH_MAX_HEAP_SIZE,TLCPreferenceInitializer.MAX_HEAP_SIZE_DEFAULT);
      maxHeapSize.setSelection(TLCPreferenceInitializer.MAX_HEAP_SIZE_DEFAULT);
    }
 else     if (legacyValue >= 100) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"" + legacyValue + ""String_Node_Str"",this.getId(),IMessageProvider.WARNING,maxHeapSize);
      setComplete(false);
      expandSection(SEC_HOW_TO_RUN);
    }
  }
 catch (  CoreException e) {
    TLCUIActivator.getDefault().logWarning(""String_Node_Str"",e);
  }
  int maxHeapSizeValue=maxHeapSize.getSelection();
  double x=maxHeapSizeValue / 100d;
  float y=(float)linearInterpolator.interpolate(x);
  maxHeapSize.setBackground(new Color(Display.getDefault(),new RGB(120 * y,1 - y,1f)));
  updateCheckpoints();
  if (checkpointButton.getSelection()) {
    if (EMPTY_STRING.equals(checkpointIdText.getText())) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(LAUNCH_RECOVER)));
      setComplete(false);
      expandSection(SEC_HOW_TO_RUN);
    }
  }
  if (rootModuleNode != null) {
    if (rootModuleNode.getVariableDecls().length == 0) {
      setHasVariables(false);
      if (!noSpecRadio.getSelection()) {
        setSpecSelection(MODEL_BEHAVIOR_TYPE_NO_SPEC);
        dm.getSection(dm.getSectionForAttribute(MODEL_BEHAVIOR_NO_SPEC)).markDirty();
      }
    }
 else {
      setHasVariables(true);
    }
  }
  Section whatToCheckSection=dm.getSection(SEC_WHAT_TO_CHECK).getSection();
  if (noSpecRadio.getSelection()) {
    whatToCheckSection.setExpanded(false);
    whatToCheckSection.setEnabled(false);
  }
 else {
    whatToCheckSection.setExpanded(true);
    whatToCheckSection.setEnabled(true);
  }
  if (closedFormulaRadio.getSelection() && specSource.getDocument().get().trim().equals(""String_Node_Str"")) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_BEHAVIOR_CLOSED_SPECIFICATION)));
    setComplete(false);
    expandSection(dm.getSectionForAttribute(MODEL_BEHAVIOR_CLOSED_SPECIFICATION));
  }
 else   if (initNextFairnessRadio.getSelection()) {
    String init=initFormulaSource.getDocument().get().trim();
    String next=nextFormulaSource.getDocument().get().trim();
    if (init.equals(""String_Node_Str"")) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_INIT)));
      setComplete(false);
      expandSection(dm.getSectionForAttribute(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_INIT));
    }
    if (next.equals(""String_Node_Str"")) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_NEXT)));
      setComplete(false);
      expandSection(dm.getSectionForAttribute(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_NEXT));
    }
  }
  boolean distributed=this.distributedButton.getSelection();
  this.distributedScriptText.setEnabled(distributed);
  mm.setAutoUpdate(true);
  super.validatePage(switchToErrorPage);
}","public void validatePage(boolean switchToErrorPage){
  if (getManagedForm() == null) {
    return;
  }
  DataBindingManager dm=getDataBindingManager();
  IMessageManager mm=getManagedForm().getMessageManager();
  ModelEditor modelEditor=(ModelEditor)getEditor();
  ModuleNode rootModuleNode=SemanticHelper.getRootModuleNode();
  getLookupHelper().resetModelNames(this);
  List<Assignment> constants=(List<Assignment>)constantTable.getInput();
  if (rootModuleNode != null) {
    List<Assignment> toDelete=ModelHelper.mergeConstantLists(constants,ModelHelper.createConstantsList(rootModuleNode));
    if (!toDelete.isEmpty()) {
      SectionPart constantSection=dm.getSection(dm.getSectionForAttribute(MODEL_PARAMETER_CONSTANTS));
      if (constantSection != null) {
        constantSection.markDirty();
      }
    }
    constantTable.setInput(constants);
  }
  String symmetryType=null;
  for (int i=0; i < constants.size(); i++) {
    Assignment constant=(Assignment)constants.get(i);
    List<String> values=Arrays.asList(constant.getParams());
    validateId(MODEL_PARAMETER_CONSTANTS,values,""String_Node_Str"",""String_Node_Str"");
    if (constant.getRight() == null || EMPTY_STRING.equals(constant.getRight())) {
      modelEditor.addErrorMessage(constant.getLabel(),""String_Node_Str"" + constant.getLabel(),this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS)));
      setComplete(false);
      expandSection(dm.getSectionForAttribute(MODEL_PARAMETER_CONSTANTS));
    }
 else {
      modelEditor.removeErrorMessage(constant.getLabel(),UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS)));
      if (constant.isSetOfModelValues()) {
        TypedSet modelValuesSet=TypedSet.parseSet(constant.getRight());
        if (constant.isSymmetricalSet()) {
          boolean hasTwoTypes=false;
          String typeString=null;
          if (modelValuesSet.hasType()) {
            typeString=modelValuesSet.getType();
          }
 else {
            for (int j=0; j < modelValuesSet.getValues().length; j++) {
              String thisTypeString=TypedSet.getTypeOfId(modelValuesSet.getValues()[j]);
              if (thisTypeString != null) {
                if (typeString != null && !typeString.equals(thisTypeString)) {
                  hasTwoTypes=true;
                }
 else {
                  typeString=thisTypeString;
                }
              }
            }
          }
          if (hasTwoTypes || (symmetryType != null && typeString != null && !typeString.equals(symmetryType))) {
            modelEditor.addErrorMessage(constant.getLabel(),""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS)));
            setComplete(false);
            expandSection(dm.getSectionForAttribute(MODEL_PARAMETER_CONSTANTS));
          }
 else {
            if (typeString != null) {
              symmetryType=typeString;
            }
          }
        }
        if (modelValuesSet.getValueCount() > 0) {
          List<String> mvList=modelValuesSet.getValuesAsList();
          validateUsage(MODEL_PARAMETER_CONSTANTS,mvList,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
          validateId(MODEL_PARAMETER_CONSTANTS,mvList,""String_Node_Str"",""String_Node_Str"");
          Control widget=UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS));
          for (int j=0; j < mvList.size(); j++) {
            String value=(String)mvList.get(j);
            if (SemanticHelper.isConfigFileKeyword(value)) {
              modelEditor.addErrorMessage(value,""String_Node_Str"" + value + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
              setComplete(false);
            }
          }
        }
 else {
          modelEditor.addErrorMessage(constant.getLabel(),""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS)));
          setComplete(false);
        }
      }
    }
    if (SemanticHelper.isConfigFileKeyword(constant.getLabel())) {
      modelEditor.addErrorMessage(constant.getLabel(),""String_Node_Str"" + constant.getLabel() + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_CONSTANTS)));
      setComplete(false);
    }
  }
  for (int i=0; i < constants.size(); i++) {
    Assignment constant=(Assignment)constants.get(i);
    List<String> values=Arrays.asList(constant.getParams());
    validateUsage(MODEL_PARAMETER_CONSTANTS,values,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
  }
  int number=workers.getSelection();
  if (number > Runtime.getRuntime().availableProcessors()) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"" + number + ""String_Node_Str""+ Runtime.getRuntime().availableProcessors()+ ""String_Node_Str"",this.getId(),IMessageProvider.WARNING,UIHelper.getWidget(dm.getAttributeControl(LAUNCH_NUMBER_OF_WORKERS)));
    expandSection(SEC_HOW_TO_RUN);
  }
  try {
    final int defaultMaxHeapSize=TLCUIActivator.getDefault().getPreferenceStore().getInt(ITLCPreferenceConstants.I_TLC_MAXIMUM_HEAP_SIZE_DEFAULT);
    final int legacyValue=getConfig().getAttribute(LAUNCH_MAX_HEAP_SIZE,defaultMaxHeapSize);
    if (legacyValue == 500) {
      getConfig().setAttribute(LAUNCH_MAX_HEAP_SIZE,TLCPreferenceInitializer.MAX_HEAP_SIZE_DEFAULT);
      maxHeapSize.setSelection(TLCPreferenceInitializer.MAX_HEAP_SIZE_DEFAULT);
    }
 else     if (legacyValue >= 100) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"" + legacyValue + ""String_Node_Str"",this.getId(),IMessageProvider.WARNING,maxHeapSize);
      setComplete(false);
      expandSection(SEC_HOW_TO_RUN);
    }
  }
 catch (  CoreException e) {
    TLCUIActivator.getDefault().logWarning(""String_Node_Str"",e);
  }
  int maxHeapSizeValue=maxHeapSize.getSelection();
  double x=maxHeapSizeValue / 100d;
  float y=(float)linearInterpolator.interpolate(x);
  maxHeapSize.setBackground(new Color(Display.getDefault(),new RGB(120 * y,1 - y,1f)));
  updateCheckpoints();
  if (checkpointButton.getSelection()) {
    if (EMPTY_STRING.equals(checkpointIdText.getText())) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(LAUNCH_RECOVER)));
      setComplete(false);
      expandSection(SEC_HOW_TO_RUN);
    }
  }
  if (rootModuleNode != null) {
    if (rootModuleNode.getVariableDecls().length == 0) {
      setHasVariables(false);
      if (!noSpecRadio.getSelection()) {
        setSpecSelection(MODEL_BEHAVIOR_TYPE_NO_SPEC);
        dm.getSection(dm.getSectionForAttribute(MODEL_BEHAVIOR_NO_SPEC)).markDirty();
      }
    }
 else {
      setHasVariables(true);
    }
  }
  Section whatToCheckSection=dm.getSection(SEC_WHAT_TO_CHECK).getSection();
  if (noSpecRadio.getSelection()) {
    whatToCheckSection.setExpanded(false);
    whatToCheckSection.setEnabled(false);
  }
 else {
    whatToCheckSection.setExpanded(true);
    whatToCheckSection.setEnabled(true);
  }
  if (closedFormulaRadio.getSelection() && specSource.getDocument().get().trim().equals(""String_Node_Str"")) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_BEHAVIOR_CLOSED_SPECIFICATION)));
    setComplete(false);
    expandSection(dm.getSectionForAttribute(MODEL_BEHAVIOR_CLOSED_SPECIFICATION));
  }
 else   if (initNextFairnessRadio.getSelection()) {
    String init=initFormulaSource.getDocument().get().trim();
    String next=nextFormulaSource.getDocument().get().trim();
    if (init.equals(""String_Node_Str"")) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_INIT)));
      setComplete(false);
      expandSection(dm.getSectionForAttribute(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_INIT));
    }
    if (next.equals(""String_Node_Str"")) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_NEXT)));
      setComplete(false);
      expandSection(dm.getSectionForAttribute(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_NEXT));
    }
  }
  boolean distributed=this.distributedButton.getSelection();
  this.distributedScriptText.setEnabled(distributed);
  mm.setAutoUpdate(true);
  super.validatePage(switchToErrorPage);
}",0.9908878504672896
135859,"/** 
 * Added 21 Mar 2013 by LL.
 * @param key
 * @param messageText
 * @param pageId
 * @param type
 * @param control
 */
public void removeErrorMessage(Object key,Control control){
  if (control != null) {
    for (int i=0; i < pagesToAdd.length; i++) {
      pagesToAdd[i].getManagedForm().getMessageManager().removeMessage(key,control);
    }
  }
}","/** 
 * This removes the error ""message"" added by the corresponding call to addErrorMessage if it exists.  It does nothing if the ""message   does not exist.  This provides a partial fix to the problem of page validation showing an error when the user has made a mistake, but not removing the error when the user corrects the mistake.  Code that checks for an error and calls addErrorMessage when it is found can call removeErrorMessage when it's not found.  It is only a partial  solution for two reasons: 1. It can't be used where the same error ""message"" can be added in two different places in the code.  Perhaps this can be fixed by splitting such messages into separate ones with  different keys and different messages, it is added, but I haven't  tried this because I don't know where those keys might be used.   If all those places where the error is generated lie in the same call of pageValidate, then error messages generated in  the previous call of pageValidate can be remembered in a field and removed at the beginning of the call. 2. Some of those keys are dynamically created when addErrorMessage is called, and it may be impossible to recompute the keys for which the error messages were previously generated.  Such cases could also be handled by adding a field that remembers what error messages  were added the last time the error was chaecked for.  Added 21 Mar 2013 by LL.
 * @param key the unique message key
 * @param control the control to associate the message with
 */
public void removeErrorMessage(Object key,Control control){
  if (control != null) {
    for (int i=0; i < pagesToAdd.length; i++) {
      pagesToAdd[i].getManagedForm().getMessageManager().removeMessage(key,control);
    }
  }
}",0.2804819277108433
135860,"/** 
 */
public void validatePage(boolean switchToErrorPage){
  if (getManagedForm() == null) {
    return;
  }
  IMessageManager mm=getManagedForm().getMessageManager();
  mm.setAutoUpdate(false);
  ModelEditor modelEditor=(ModelEditor)getEditor();
  setComplete(true);
  getLookupHelper().resetModelNames(this);
  try {
    int dfidDepth=Integer.parseInt(dfidDepthText.getText());
    if (dfidDepth <= 0) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,dfidDepthText);
      setComplete(false);
      expandSection(SEC_LAUNCHING_SETUP);
    }
  }
 catch (  NumberFormatException e) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,dfidDepthText);
    setComplete(false);
    expandSection(SEC_LAUNCHING_SETUP);
  }
  try {
    int simuDepth=Integer.parseInt(simuDepthText.getText());
    if (simuDepth <= 0) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuDepthText);
      setComplete(false);
      expandSection(SEC_LAUNCHING_SETUP);
    }
  }
 catch (  NumberFormatException e) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuDepthText);
    setComplete(false);
    expandSection(SEC_LAUNCHING_SETUP);
  }
  if (!EMPTY_STRING.equals(simuArilText.getText())) {
    try {
      long simuAril=Long.parseLong(simuArilText.getText());
      if (simuAril <= 0) {
        modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuArilText);
        setComplete(false);
      }
    }
 catch (    NumberFormatException e) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuArilText);
      setComplete(false);
      expandSection(SEC_LAUNCHING_SETUP);
    }
  }
  if (!EMPTY_STRING.equals(simuSeedText.getText())) {
    try {
      Long.parseLong(simuSeedText.getText());
    }
 catch (    NumberFormatException e) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuSeedText);
      expandSection(SEC_LAUNCHING_SETUP);
      setComplete(false);
    }
  }
  DataBindingManager dm=getDataBindingManager();
  TypedSet modelValuesSet=TypedSet.parseSet(FormHelper.trimTrailingSpaces(modelValuesSource.getDocument().get()));
  if (modelValuesSet.getValueCount() > 0) {
    List values=modelValuesSet.getValuesAsList();
    validateUsage(MODEL_PARAMETER_MODEL_VALUES,values,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
    validateId(MODEL_PARAMETER_MODEL_VALUES,values,""String_Node_Str"",""String_Node_Str"");
    Control widget=UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_MODEL_VALUES));
    for (int j=0; j < values.size(); j++) {
      String value=(String)values.get(j);
      if (SemanticHelper.isConfigFileKeyword(value)) {
        modelEditor.addErrorMessage(value,""String_Node_Str"" + value + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
        setComplete(false);
      }
    }
  }
  SpecObj specObj=ToolboxHandle.getCurrentSpec().getValidRootModule();
  OpDefNode[] opDefNodes=null;
  if (specObj != null) {
    opDefNodes=specObj.getExternalModuleTable().getRootModule().getOpDefs();
  }
  Hashtable nodeTable=new Hashtable();
  if (opDefNodes != null) {
    for (int j=0; j < opDefNodes.length; j++) {
      String key=opDefNodes[j].getName().toString();
      nodeTable.put(key,opDefNodes[j]);
    }
  }
  Control widget=UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_DEFINITIONS));
  List definitions=(List)definitionsTable.getInput();
  for (int i=0; i < definitions.size(); i++) {
    Assignment definition=(Assignment)definitions.get(i);
    List values=Arrays.asList(definition.getParams());
    validateUsage(MODEL_PARAMETER_DEFINITIONS,values,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
    validateId(MODEL_PARAMETER_DEFINITIONS,values,""String_Node_Str"",""String_Node_Str"");
    if (opDefNodes != null) {
      if (!nodeTable.containsKey(definition.getLabel())) {
        modelEditor.addErrorMessage(definition.getLabel(),""String_Node_Str"" + definition.getLabel().substring(definition.getLabel().lastIndexOf(""String_Node_Str"") + 1) + ""String_Node_Str""+ ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
        setComplete(false);
      }
 else {
        OpDefNode opDefNode=(OpDefNode)nodeTable.get(definition.getLabel());
        if (opDefNode.getSource().getNumberOfArgs() != definition.getParams().length) {
          modelEditor.addErrorMessage(definition.getLabel(),""String_Node_Str"" + opDefNode.getSource().getName() + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
          setComplete(false);
        }
      }
    }
  }
  for (int j=0; j < definitions.size(); j++) {
    Assignment definition=(Assignment)definitions.get(j);
    String label=definition.getLabel();
    if (SemanticHelper.isConfigFileKeyword(label)) {
      modelEditor.addErrorMessage(label,""String_Node_Str"" + label + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
      setComplete(false);
    }
  }
  Control viewWidget=UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_VIEW));
  String viewString=FormHelper.trimTrailingSpaces(viewSource.getDocument().get());
  if (SemanticHelper.containsConfigFileKeyword(viewString)) {
    modelEditor.addErrorMessage(viewString,""String_Node_Str"" + viewString + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,viewWidget);
    setComplete(false);
  }
  mm.setAutoUpdate(true);
  if (!FPSet.isValid(fpBits.getSelection())) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(LAUNCH_FPBITS)));
    setComplete(false);
    expandSection(SEC_HOW_TO_RUN);
  }
  if (!TLCGlobals.isValidSetSize(maxSetSize.getSelection())) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(LAUNCH_MAXSETSIZE)));
    setComplete(false);
    expandSection(SEC_HOW_TO_RUN);
  }
  super.validatePage(switchToErrorPage);
}","/** 
 */
public void validatePage(boolean switchToErrorPage){
  if (getManagedForm() == null) {
    return;
  }
  IMessageManager mm=getManagedForm().getMessageManager();
  mm.setAutoUpdate(false);
  ModelEditor modelEditor=(ModelEditor)getEditor();
  setComplete(true);
  getLookupHelper().resetModelNames(this);
  try {
    int dfidDepth=Integer.parseInt(dfidDepthText.getText());
    if (dfidDepth <= 0) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,dfidDepthText);
      setComplete(false);
      expandSection(SEC_LAUNCHING_SETUP);
    }
 else {
      modelEditor.removeErrorMessage(""String_Node_Str"",dfidDepthText);
    }
    modelEditor.removeErrorMessage(""String_Node_Str"",dfidDepthText);
  }
 catch (  NumberFormatException e) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,dfidDepthText);
    setComplete(false);
    expandSection(SEC_LAUNCHING_SETUP);
  }
  try {
    int simuDepth=Integer.parseInt(simuDepthText.getText());
    if (simuDepth <= 0) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuDepthText);
      setComplete(false);
      expandSection(SEC_LAUNCHING_SETUP);
    }
 else {
      modelEditor.removeErrorMessage(""String_Node_Str"",simuDepthText);
    }
    modelEditor.removeErrorMessage(""String_Node_Str"",simuDepthText);
  }
 catch (  NumberFormatException e) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuDepthText);
    setComplete(false);
    expandSection(SEC_LAUNCHING_SETUP);
  }
  if (!EMPTY_STRING.equals(simuArilText.getText())) {
    try {
      long simuAril=Long.parseLong(simuArilText.getText());
      if (simuAril <= 0) {
        modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuArilText);
        setComplete(false);
      }
 else {
        modelEditor.removeErrorMessage(""String_Node_Str"",simuArilText);
      }
      modelEditor.removeErrorMessage(""String_Node_Str"",simuArilText);
    }
 catch (    NumberFormatException e) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuArilText);
      setComplete(false);
      expandSection(SEC_LAUNCHING_SETUP);
    }
  }
  if (!EMPTY_STRING.equals(simuSeedText.getText())) {
    try {
      Long.parseLong(simuSeedText.getText());
      modelEditor.removeErrorMessage(""String_Node_Str"",simuSeedText);
    }
 catch (    NumberFormatException e) {
      modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,simuSeedText);
      expandSection(SEC_LAUNCHING_SETUP);
      setComplete(false);
    }
  }
  DataBindingManager dm=getDataBindingManager();
  TypedSet modelValuesSet=TypedSet.parseSet(FormHelper.trimTrailingSpaces(modelValuesSource.getDocument().get()));
  if (modelValuesSet.getValueCount() > 0) {
    List values=modelValuesSet.getValuesAsList();
    validateUsage(MODEL_PARAMETER_MODEL_VALUES,values,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
    validateId(MODEL_PARAMETER_MODEL_VALUES,values,""String_Node_Str"",""String_Node_Str"");
    Control widget=UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_MODEL_VALUES));
    for (int j=0; j < values.size(); j++) {
      String value=(String)values.get(j);
      if (SemanticHelper.isConfigFileKeyword(value)) {
        modelEditor.addErrorMessage(value,""String_Node_Str"" + value + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
        setComplete(false);
      }
    }
  }
  SpecObj specObj=ToolboxHandle.getCurrentSpec().getValidRootModule();
  OpDefNode[] opDefNodes=null;
  if (specObj != null) {
    opDefNodes=specObj.getExternalModuleTable().getRootModule().getOpDefs();
  }
  Hashtable nodeTable=new Hashtable();
  if (opDefNodes != null) {
    for (int j=0; j < opDefNodes.length; j++) {
      String key=opDefNodes[j].getName().toString();
      nodeTable.put(key,opDefNodes[j]);
    }
  }
  Control widget=UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_DEFINITIONS));
  List definitions=(List)definitionsTable.getInput();
  for (int i=0; i < definitions.size(); i++) {
    Assignment definition=(Assignment)definitions.get(i);
    List values=Arrays.asList(definition.getParams());
    validateUsage(MODEL_PARAMETER_DEFINITIONS,values,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
    validateId(MODEL_PARAMETER_DEFINITIONS,values,""String_Node_Str"",""String_Node_Str"");
    if (opDefNodes != null) {
      if (!nodeTable.containsKey(definition.getLabel())) {
        modelEditor.addErrorMessage(definition.getLabel(),""String_Node_Str"" + definition.getLabel().substring(definition.getLabel().lastIndexOf(""String_Node_Str"") + 1) + ""String_Node_Str""+ ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
        setComplete(false);
      }
 else {
        OpDefNode opDefNode=(OpDefNode)nodeTable.get(definition.getLabel());
        if (opDefNode.getSource().getNumberOfArgs() != definition.getParams().length) {
          modelEditor.addErrorMessage(definition.getLabel(),""String_Node_Str"" + opDefNode.getSource().getName() + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
          setComplete(false);
        }
      }
    }
  }
  for (int j=0; j < definitions.size(); j++) {
    Assignment definition=(Assignment)definitions.get(j);
    String label=definition.getLabel();
    if (SemanticHelper.isConfigFileKeyword(label)) {
      modelEditor.addErrorMessage(label,""String_Node_Str"" + label + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,widget);
      setComplete(false);
    }
  }
  Control viewWidget=UIHelper.getWidget(dm.getAttributeControl(MODEL_PARAMETER_VIEW));
  String viewString=FormHelper.trimTrailingSpaces(viewSource.getDocument().get());
  if (SemanticHelper.containsConfigFileKeyword(viewString)) {
    modelEditor.addErrorMessage(viewString,""String_Node_Str"" + viewString + ""String_Node_Str"",this.getId(),IMessageProvider.ERROR,viewWidget);
    setComplete(false);
  }
  mm.setAutoUpdate(true);
  if (!FPSet.isValid(fpBits.getSelection())) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(LAUNCH_FPBITS)));
    setComplete(false);
    expandSection(SEC_HOW_TO_RUN);
  }
  if (!TLCGlobals.isValidSetSize(maxSetSize.getSelection())) {
    modelEditor.addErrorMessage(""String_Node_Str"",""String_Node_Str"",this.getId(),IMessageProvider.ERROR,UIHelper.getWidget(dm.getAttributeControl(LAUNCH_MAXSETSIZE)));
    setComplete(false);
    expandSection(SEC_HOW_TO_RUN);
  }
  super.validatePage(switchToErrorPage);
}",0.9589397885705532
135861,"private static void FixMultiprocess(AST.Multiprocess ast,String context) throws PcalFixIDException {
  for (int i=0; i < ast.decls.size(); i++)   FixVarDecl((AST.VarDecl)ast.decls.elementAt(i),""String_Node_Str"");
  Vector procedureNames=new Vector();
  Vector proceduresCalled=new Vector();
  for (int i=0; i < ast.prcds.size(); i++) {
    AST.Procedure prcd=(AST.Procedure)ast.prcds.elementAt(i);
    FixProcedure(prcd,""String_Node_Str"");
    procedureNames.addElement(prcd.name);
    proceduresCalled.addElement(prcd.proceduresCalled);
  }
  int n=procedureNames.size();
  boolean path[][]=new boolean[n][];
  for (int i=0; i < n; i++) {
    path[i]=new boolean[n];
    String nm=(String)procedureNames.elementAt(i);
    for (int j=0; j < n; j++) {
      path[i][j]=(-1 != nameToNum(nm,(Vector)proceduresCalled.elementAt(j)));
    }
  }
  for (int k=0; k < n; k++) {
    for (int i=0; i < n; i++) {
      for (int j=0; j < n; j++) {
        path[i][j]=path[i][j] || (path[i][k] && path[k][j]);
      }
    }
  }
  for (int i=0; i < ast.prcds.size(); i++) {
    AST.Procedure prcd=(AST.Procedure)ast.prcds.elementAt(i);
    Vector pCalled=new Vector();
    for (int j=0; j < n; j++) {
      if (path[i][j]) {
        pCalled.addElement(procedureNames.elementAt(j));
      }
    }
    prcd.proceduresCalled=pCalled;
  }
  for (int i=0; i < ast.procs.size(); i++) {
    AST.Process proc=(AST.Process)ast.procs.elementAt(i);
    FixProcess(proc,""String_Node_Str"");
    Vector pCalled=proc.proceduresCalled;
    for (int j=0; j < pCalled.size(); j++) {
      String pName=(String)pCalled.elementAt(j);
      int pNum=nameToNum(pName,procedureNames);
      if (pNum == -1) {
        PcalDebug.ReportBug(""String_Node_Str"" + pName + ""String_Node_Str"");
      }
      for (int k=0; k < n; k++) {
        if (path[pNum][k]) {
          String callee=(String)procedureNames.elementAt(k);
          if (!InVector(callee,proc.proceduresCalled)) {
            proc.proceduresCalled.addElement(callee);
          }
        }
      }
    }
  }
}","private static void FixMultiprocess(AST.Multiprocess ast,String context) throws PcalFixIDException {
  for (int i=0; i < ast.decls.size(); i++)   FixVarDecl((AST.VarDecl)ast.decls.elementAt(i),""String_Node_Str"");
  Vector procedureNames=new Vector();
  Vector proceduresCalled=new Vector();
  for (int i=0; i < ast.prcds.size(); i++) {
    AST.Procedure prcd=(AST.Procedure)ast.prcds.elementAt(i);
    FixProcedure(prcd,""String_Node_Str"");
    procedureNames.addElement(prcd.name);
    proceduresCalled.addElement(prcd.proceduresCalled);
  }
  int n=procedureNames.size();
  boolean path[][]=new boolean[n][];
  for (int i=0; i < n; i++) {
    path[i]=new boolean[n];
    for (int j=0; j < n; j++) {
      String nm=(String)procedureNames.elementAt(j);
      path[i][j]=(-1 != nameToNum(nm,(Vector)proceduresCalled.elementAt(i)));
    }
  }
  for (int k=0; k < n; k++) {
    for (int i=0; i < n; i++) {
      for (int j=0; j < n; j++) {
        path[i][j]=path[i][j] || (path[i][k] && path[k][j]);
      }
    }
  }
  for (int i=0; i < ast.prcds.size(); i++) {
    AST.Procedure prcd=(AST.Procedure)ast.prcds.elementAt(i);
    Vector pCalled=new Vector();
    for (int j=0; j < n; j++) {
      if (path[i][j]) {
        pCalled.addElement(procedureNames.elementAt(j));
      }
    }
    prcd.proceduresCalled=pCalled;
  }
  for (int i=0; i < ast.procs.size(); i++) {
    AST.Process proc=(AST.Process)ast.procs.elementAt(i);
    FixProcess(proc,""String_Node_Str"");
    Vector pCalled=proc.proceduresCalled;
    for (int j=0; j < pCalled.size(); j++) {
      String pName=(String)pCalled.elementAt(j);
      int pNum=nameToNum(pName,procedureNames);
      if (pNum == -1) {
        PcalDebug.ReportBug(""String_Node_Str"" + pName + ""String_Node_Str"");
      }
      for (int k=0; k < n; k++) {
        if (path[pNum][k]) {
          String callee=(String)procedureNames.elementAt(k);
          if (!InVector(callee,proc.proceduresCalled)) {
            proc.proceduresCalled.addElement(callee);
          }
        }
      }
    }
  }
}",0.9822834645669292
135862,"/** 
 * The process fairness condition written as a formula that begins in column col (Java numbering) and ends with ""\n"". It is formatted to try to extend no further than column  PcalTLAGen.wrapColumn, but no individual formula is split across lines.
 * @param col
 * @return
 */
public StringBuffer format(int col){
  int singleLineWidth=this.singleLineWidth();
  if (fitsAsSingleLine(col)) {
    return this.singleLine(col);
  }
  StringBuffer val=prefixAsStringBuffer(col);
  int prefixWidth=0;
  if (prefix != null && prefix.size() > 0) {
    prefixWidth=((String)prefix.elementAt(prefix.size() - 1)).length();
  }
  int curCol=col + prefixWidth;
  String line=this.bodyFormulas.singleLine();
  if (curCol + line.length() + 3 <= PcalTLAGen.wrapColumn) {
    val.append(""String_Node_Str"" + line);
  }
 else {
    val.append(this.bodyFormulas.multiLine(curCol));
  }
  if (prcdFormulas == null) {
    return val;
  }
  for (int i=0; i < this.prcdFormulas.size(); i++) {
    FormulaPair form=(FormulaPair)this.prcdFormulas.elementAt(i);
    line=form.singleLine();
    val.append(""String_Node_Str"");
    val.append(NSpaces(curCol));
    if (curCol + line.length() + 3 <= PcalTLAGen.wrapColumn) {
      val.append(""String_Node_Str"" + line + ""String_Node_Str"");
    }
 else {
      val.append(form.multiLine(curCol));
    }
  }
  return val;
}","/** 
 * The process fairness condition written as a formula that begins in column col (Java numbering) and ends with ""\n"". It is formatted to try to extend no further than column  PcalTLAGen.wrapColumn, but no individual formula is split across lines.
 * @param col
 * @return
 */
public StringBuffer format(int col){
  int singleLineWidth=this.singleLineWidth();
  if (fitsAsSingleLine(col)) {
    return this.singleLine(col);
  }
  StringBuffer val=prefixAsStringBuffer(col);
  int prefixWidth=0;
  if (prefix != null && prefix.size() > 0) {
    prefixWidth=((String)prefix.elementAt(prefix.size() - 1)).length();
  }
  int curCol=col + prefixWidth;
  String line=this.bodyFormulas.singleLine();
  if (curCol + line.length() + 3 <= PcalTLAGen.wrapColumn) {
    val.append(""String_Node_Str"" + line);
  }
 else {
    val.append(this.bodyFormulas.multiLine(curCol));
  }
  if (prcdFormulas == null) {
    return val;
  }
  for (int i=0; i < this.prcdFormulas.size(); i++) {
    FormulaPair form=(FormulaPair)this.prcdFormulas.elementAt(i);
    line=form.singleLine();
    if (i == 0) {
      val.append(""String_Node_Str"");
    }
    val.append(NSpaces(curCol));
    if (curCol + line.length() + 3 <= PcalTLAGen.wrapColumn) {
      val.append(""String_Node_Str"" + line + ""String_Node_Str"");
    }
 else {
      val.append(form.multiLine(curCol));
    }
  }
  return val;
}",0.9904129793510325
135863,"public static void WriteTeXAlignmentFile(Token[][] spec,Vector preamble,float linewidth){
  OutputFileWriter writer=new OutputFileWriter(Parameters.LaTeXAlignmentFile + ""String_Node_Str"");
  writer.putLine(""String_Node_Str"");
  int i=0;
  while (i < preamble.size()) {
    writer.putLine((String)preamble.elementAt(i));
    i=i + 1;
  }
  ;
  if (linewidth >= 0) {
    writer.putLine(""String_Node_Str"" + Misc.floatToString(linewidth,2) + ""String_Node_Str"");
    writer.putLine(""String_Node_Str"");
  }
  ;
  writer.putLine(""String_Node_Str"");
  writer.putLine(""String_Node_Str"");
  InnerWriteAlignmentFile(spec,writer,false);
}","public static void WriteTeXAlignmentFile(Token[][] spec,Vector preamble,float linewidth){
  OutputFileWriter writer=new OutputFileWriter(Parameters.LaTeXAlignmentFile + ""String_Node_Str"");
  writer.putLine(""String_Node_Str"");
  int i=0;
  while (i < preamble.size()) {
    writer.putLine((String)preamble.elementAt(i));
    i=i + 1;
  }
  ;
  if (linewidth >= 0) {
    writer.putLine(""String_Node_Str"" + Misc.floatToString(linewidth,2) + ""String_Node_Str"");
  }
  ;
  writer.putLine(""String_Node_Str"");
  writer.putLine(""String_Node_Str"");
  writer.putLine(""String_Node_Str"");
  InnerWriteAlignmentFile(spec,writer,false);
}",0.9888
135864,"/** 
 * If nd is a step of a proof--that is, it is an element of the array returned by NonLeafProofNode.getSteps()--then this returns the level number of the proof, which is the i such that the step begins ""<i>"". A little experimentation reveals that the parser turns ""<+>"" or ""<*>"" in the source into ""<i>"" for the appropriate i.
 * @param nd
 * @return
 */
static int stepLevel(SemanticNode nd){
  String stepStr=((SyntaxTreeNode)nd.stn).getHeirs()[0].image.toString();
  String stepNum=stepStr.substring(stepStr.indexOf('<') + 1,stepStr.indexOf('>'));
  return Integer.valueOf(stepNum).intValue();
}","/** 
 * If nd is a step of a proof--that is, it is an element of the array returned by NonLeafProofNode.getSteps()--then this returns the level number of the proof, which is the i such that the step begins ""<i>"". A little experimentation reveals that the parser turns ""<+>"" or ""<*>"" in the source into ""<i>"" for the appropriate i. This method must not be called if nd is a DefStepNode or InstanceNode, since for an unnumbered step (which such a step is likely to be), there is no way to find the level number.  See the comments to the one place where this method is called.
 * @param nd
 * @return
 */
static int stepLevel(SemanticNode nd){
  String stepStr=((SyntaxTreeNode)nd.stn).getHeirs()[0].image.toString();
  String stepNum=stepStr.substring(stepStr.indexOf('<') + 1,stepStr.indexOf('>'));
  return Integer.valueOf(stepNum).intValue();
}",0.8320663441603318
135865,"/** 
 * THE REAL EXECUTE METHOD This method is called by a synchronous job launched in the execute method  to do most of the work of executing the Decompose Proof command.
 * @see org.eclipse.core.commands.IHandler#execute(org.eclipse.core.commands.ExecutionEvent)
 * @return
 * @throws ExecutionException
 */
public Object realExecute() throws ExecutionException {
  Activator.getDefault().logDebug(""String_Node_Str"");
  Vector<SemanticNode> assumes;
  SemanticNode goal;
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] oneline=new String[]{""String_Node_Str""};
  if (this.windowShell != null) {
    if (!this.windowShell.isDisposed()) {
      System.out.println(""String_Node_Str"");
      return null;
    }
  }
  if (existDirtyModules()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Spec spec=Activator.getSpecManager().getSpecLoaded();
  if (spec == null || spec.getStatus() != IParseConstants.PARSED) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  if (editor == null) {
    Activator.getDefault().logDebug(""String_Node_Str"");
    return null;
  }
  editorIFile=((FileEditorInput)editor.getEditorInput()).getFile();
  if (editor.isDirty()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  hasChanged=false;
  chosenSplit=-1;
  needsStepNumber=false;
  andSplitBegin=-1;
  andSplitEnd=-1;
  goalDefinitions=new HashSet<String>();
  assumpDefinitions=new HashSet<String>();
  Location selectedLocation=EditorUtil.getLocationAt(doc,offset,selection.getLength());
  TheoremNode[] allTheorems=moduleNode.getTheorems();
  theorem=null;
  int i=0;
  String moduleFile=moduleNode.stn.getFilename();
  while ((theorem == null) & (i < allTheorems.length)) {
    if (allTheorems[i].stn.getFilename().equals(moduleFile) && EditorUtil.lineLocationContainment(selectedLocation,allTheorems[i].stn.getLocation())) {
      theorem=allTheorems[i];
    }
    i++;
  }
  if (theorem == null) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  this.declaredIdentifiers=ResourceHelper.declaredSymbolsInScope(this.moduleNode,theorem.stn.getLocation());
  step=theorem;
  boolean notDone=true;
  proofLevel=-1;
  proof=step.getProof();
  while (notDone && (proof != null) && (proof instanceof NonLeafProofNode)) {
    LevelNode[] pfsteps=((NonLeafProofNode)proof).getSteps();
    LevelNode foundLevelNode=null;
    i=0;
    proofLevel=stepLevel(pfsteps[0]);
    while ((foundLevelNode == null) && (i < pfsteps.length)) {
      if (EditorUtil.lineLocationContainment(selectedLocation,pfsteps[i].stn.getLocation())) {
        foundLevelNode=pfsteps[i];
        if (!step.isSuffices() && (step.getTheorem() instanceof AssumeProveNode)) {
          SemanticNode[] assumptions=((AssumeProveNode)step.getTheorem()).getAssumes();
          for (int j=0; j < assumptions.length; j++) {
            if (assumptions[j] instanceof NewSymbNode) {
              declaredIdentifiers.add(((NewSymbNode)assumptions[j]).getOpDeclNode().getName().toString());
            }
          }
        }
      }
 else {
        if (pfsteps[i] instanceof TheoremNode) {
          TheoremNode node=(TheoremNode)pfsteps[i];
          if (node.isSuffices() && (node.getTheorem() instanceof AssumeProveNode)) {
            SemanticNode[] assumptions=((AssumeProveNode)node.getTheorem()).getAssumes();
            for (int j=0; j < assumptions.length; j++) {
              if (assumptions[j] instanceof NewSymbNode) {
                declaredIdentifiers.add(((NewSymbNode)assumptions[j]).getOpDeclNode().getName().toString());
              }
            }
          }
        }
        if (pfsteps[i] instanceof DefStepNode) {
          OpDefNode[] defs=((DefStepNode)pfsteps[i]).getDefs();
          for (int j=0; j < defs.length; j++) {
            declaredIdentifiers.add(defs[j].getName().toString());
          }
        }
        if (pfsteps[i] instanceof InstanceNode) {
          ResourceHelper.addDeclaredSymbolsInScope(declaredIdentifiers,((InstanceNode)pfsteps[i]).getModule(),ResourceHelper.infiniteLoc);
        }
      }
      i++;
    }
    if (foundLevelNode == null) {
      notDone=false;
    }
 else     if (!(foundLevelNode instanceof TheoremNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
 else {
      step=(TheoremNode)foundLevelNode;
      proof=step.getProof();
    }
  }
  if (step.isSuffices()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  int level=this.proofLevel;
  if (level < 0) {
    level=0;
  }
  proofLevelString=""String_Node_Str"" + (level + 1) + ""String_Node_Str"";
  SyntaxTreeNode nd=(SyntaxTreeNode)step.stn;
  if (step == theorem) {
    stepNumber=null;
  }
 else {
    stepNumber=nd.getHeirs()[0].image.toString();
    if (stepNumber.indexOf('>') == stepNumber.length() - 1) {
      stepNumber=null;
    }
 else {
      i=stepNumber.indexOf('>') + 1;
      while ((i < stepNumber.length() && (Character.isLetterOrDigit(stepNumber.charAt(i)) || (stepNumber.charAt(i) == '_')))) {
        i++;
      }
      if (i < stepNumber.length()) {
        stepNumber=stepNumber.substring(0,i);
      }
    }
  }
  stepColumn=nd.getLocation().beginColumn();
  if ((proof != null) && !(proof instanceof LeafProofNode)) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  try {
    stepRep=new NodeRepresentation(doc,step);
  }
 catch (  BadLocationException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
  }
  LevelNode thm=step.getTheorem();
  if (thm instanceof AssumeProveNode) {
    hasAssumes=true;
    SemanticNode[] assump=((AssumeProveNode)thm).getAssumes();
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    int rowOfLastNew=-1;
    for (i=0; i < assump.length; i++) {
      if (assump[i] instanceof AssumeProveNode) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      assumes.add(assump[i]);
      NodeRepresentation nodeRep=stepRep.subNodeRep(assump[i],assumeReps,null,null,null);
      if (nodeRep.nodeType == NodeRepresentation.NEW_NODE) {
        Location loc=nodeRep.semanticNode.stn.getLocation();
        if (loc.beginLine() == loc.endLine()) {
          if (loc.beginLine() == rowOfLastNew) {
            assumeReps.elementAt(i - 1).onSameLineAsNext=true;
          }
          rowOfLastNew=loc.beginLine();
        }
 else {
          rowOfLastNew=-1;
        }
      }
 else {
        rowOfLastNew=-1;
      }
      assumeReps.add(nodeRep);
      goal=((AssumeProveNode)thm).getProve();
      if (!(goal instanceof OpApplNode)) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      goalRep=stepRep.subNodeRep(goal,null,null,null,null);
    }
  }
 else {
    hasAssumes=false;
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    if (!(thm instanceof OpApplNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goal=thm;
    UniqueString goalOpName=null;
    if (goal instanceof OpApplNode) {
      goalOpName=((OpApplNode)goal).getOperator().getName();
    }
    if ((goalOpName == null) || (goalOpName == ASTConstants.OP_qed) || (goalOpName == ASTConstants.OP_pfcase)|| (goalOpName == ASTConstants.OP_have)|| (goalOpName == ASTConstants.OP_pick)|| (goalOpName == ASTConstants.OP_witness)|| (goalOpName == ASTConstants.OP_suffices)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goalRep=stepRep.subNodeRep(goal,null,null,null,null);
  }
  editorIFile.setReadOnly(true);
  raiseWindow();
  return null;
}","/** 
 * THE REAL EXECUTE METHOD This method is called by a synchronous job launched in the execute method  to do most of the work of executing the Decompose Proof command.
 * @see org.eclipse.core.commands.IHandler#execute(org.eclipse.core.commands.ExecutionEvent)
 * @return
 * @throws ExecutionException
 */
public Object realExecute() throws ExecutionException {
  Activator.getDefault().logDebug(""String_Node_Str"");
  Vector<SemanticNode> assumes;
  SemanticNode goal;
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] oneline=new String[]{""String_Node_Str""};
  if (this.windowShell != null) {
    if (!this.windowShell.isDisposed()) {
      System.out.println(""String_Node_Str"");
      return null;
    }
  }
  if (existDirtyModules()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Spec spec=Activator.getSpecManager().getSpecLoaded();
  if (spec == null || spec.getStatus() != IParseConstants.PARSED) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  if (editor == null) {
    Activator.getDefault().logDebug(""String_Node_Str"");
    return null;
  }
  editorIFile=((FileEditorInput)editor.getEditorInput()).getFile();
  if (editor.isDirty()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  hasChanged=false;
  chosenSplit=-1;
  needsStepNumber=false;
  andSplitBegin=-1;
  andSplitEnd=-1;
  goalDefinitions=new HashSet<String>();
  assumpDefinitions=new HashSet<String>();
  Location selectedLocation=EditorUtil.getLocationAt(doc,offset,selection.getLength());
  TheoremNode[] allTheorems=moduleNode.getTheorems();
  theorem=null;
  int i=0;
  String moduleFile=moduleNode.stn.getFilename();
  while ((theorem == null) & (i < allTheorems.length)) {
    if (allTheorems[i].stn.getFilename().equals(moduleFile) && EditorUtil.lineLocationContainment(selectedLocation,allTheorems[i].stn.getLocation())) {
      theorem=allTheorems[i];
    }
    i++;
  }
  if (theorem == null) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  this.declaredIdentifiers=ResourceHelper.declaredSymbolsInScope(this.moduleNode,theorem.stn.getLocation());
  step=theorem;
  boolean notDone=true;
  proofLevel=-1;
  proof=step.getProof();
  while (notDone && (proof != null) && (proof instanceof NonLeafProofNode)) {
    LevelNode[] pfsteps=((NonLeafProofNode)proof).getSteps();
    LevelNode foundLevelNode=null;
    i=0;
    while ((foundLevelNode == null) && (i < pfsteps.length)) {
      if ((proofLevel == -1) && !(pfsteps[i] instanceof DefStepNode) && !(pfsteps[i] instanceof InstanceNode)) {
        proofLevel=stepLevel(pfsteps[i]);
      }
      if (EditorUtil.lineLocationContainment(selectedLocation,pfsteps[i].stn.getLocation())) {
        foundLevelNode=pfsteps[i];
        if (!step.isSuffices() && (step.getTheorem() instanceof AssumeProveNode)) {
          SemanticNode[] assumptions=((AssumeProveNode)step.getTheorem()).getAssumes();
          for (int j=0; j < assumptions.length; j++) {
            if (assumptions[j] instanceof NewSymbNode) {
              declaredIdentifiers.add(((NewSymbNode)assumptions[j]).getOpDeclNode().getName().toString());
            }
          }
        }
      }
 else {
        if (pfsteps[i] instanceof TheoremNode) {
          TheoremNode node=(TheoremNode)pfsteps[i];
          if (node.isSuffices() && (node.getTheorem() instanceof AssumeProveNode)) {
            SemanticNode[] assumptions=((AssumeProveNode)node.getTheorem()).getAssumes();
            for (int j=0; j < assumptions.length; j++) {
              if (assumptions[j] instanceof NewSymbNode) {
                declaredIdentifiers.add(((NewSymbNode)assumptions[j]).getOpDeclNode().getName().toString());
              }
            }
          }
        }
        if (pfsteps[i] instanceof DefStepNode) {
          OpDefNode[] defs=((DefStepNode)pfsteps[i]).getDefs();
          for (int j=0; j < defs.length; j++) {
            declaredIdentifiers.add(defs[j].getName().toString());
          }
        }
        if (pfsteps[i] instanceof InstanceNode) {
          ResourceHelper.addDeclaredSymbolsInScope(declaredIdentifiers,((InstanceNode)pfsteps[i]).getModule(),ResourceHelper.infiniteLoc);
        }
      }
      i++;
    }
    if (foundLevelNode == null) {
      notDone=false;
    }
 else     if (!(foundLevelNode instanceof TheoremNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
 else {
      step=(TheoremNode)foundLevelNode;
      proof=step.getProof();
    }
  }
  if (step.isSuffices()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  int level=this.proofLevel;
  if (level < 0) {
    level=0;
  }
  proofLevelString=""String_Node_Str"" + (level + 1) + ""String_Node_Str"";
  SyntaxTreeNode nd=(SyntaxTreeNode)step.stn;
  if (step == theorem) {
    stepNumber=null;
  }
 else {
    stepNumber=nd.getHeirs()[0].image.toString();
    if (stepNumber.indexOf('>') == stepNumber.length() - 1) {
      stepNumber=null;
    }
 else {
      i=stepNumber.indexOf('>') + 1;
      while ((i < stepNumber.length() && (Character.isLetterOrDigit(stepNumber.charAt(i)) || (stepNumber.charAt(i) == '_')))) {
        i++;
      }
      if (i < stepNumber.length()) {
        stepNumber=stepNumber.substring(0,i);
      }
    }
  }
  stepColumn=nd.getLocation().beginColumn();
  if ((proof != null) && !(proof instanceof LeafProofNode)) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  try {
    stepRep=new NodeRepresentation(doc,step);
  }
 catch (  BadLocationException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
  }
  LevelNode thm=step.getTheorem();
  if (thm instanceof AssumeProveNode) {
    hasAssumes=true;
    SemanticNode[] assump=((AssumeProveNode)thm).getAssumes();
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    int rowOfLastNew=-1;
    for (i=0; i < assump.length; i++) {
      if (assump[i] instanceof AssumeProveNode) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      assumes.add(assump[i]);
      NodeRepresentation nodeRep=stepRep.subNodeRep(assump[i],assumeReps,null,null,null);
      if (nodeRep.nodeType == NodeRepresentation.NEW_NODE) {
        Location loc=nodeRep.semanticNode.stn.getLocation();
        if (loc.beginLine() == loc.endLine()) {
          if (loc.beginLine() == rowOfLastNew) {
            assumeReps.elementAt(i - 1).onSameLineAsNext=true;
          }
          rowOfLastNew=loc.beginLine();
        }
 else {
          rowOfLastNew=-1;
        }
      }
 else {
        rowOfLastNew=-1;
      }
      assumeReps.add(nodeRep);
      goal=((AssumeProveNode)thm).getProve();
      if (!(goal instanceof OpApplNode)) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      goalRep=stepRep.subNodeRep(goal,null,null,null,null);
    }
  }
 else {
    hasAssumes=false;
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    if (!(thm instanceof OpApplNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goal=thm;
    UniqueString goalOpName=null;
    if (goal instanceof OpApplNode) {
      goalOpName=((OpApplNode)goal).getOperator().getName();
    }
    if ((goalOpName == null) || (goalOpName == ASTConstants.OP_qed) || (goalOpName == ASTConstants.OP_pfcase)|| (goalOpName == ASTConstants.OP_have)|| (goalOpName == ASTConstants.OP_pick)|| (goalOpName == ASTConstants.OP_witness)|| (goalOpName == ASTConstants.OP_suffices)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goalRep=stepRep.subNodeRep(goal,null,null,null,null);
  }
  editorIFile.setReadOnly(true);
  raiseWindow();
  return null;
}",0.9879503626880882
135866,"/** 
 * @param pfStepVec   The vector to which proof steps should be added.
 * @param childVec    The vector of CASE assumptions' NodeRepresentation objects, which may include OR_DECOMP nodes.
 * @param assumptionsText The assumptions that must be prepended to a each case.
 */
void addCaseProofs(Vector<String[]> pfStepVec,Vector<NodeRepresentation> childVec,String[] assumpArray,String[] proofText){
  int newAssumpCount=assumpArray.length;
  NodeRepresentation lastChildNode=childVec.elementAt(childVec.size() - 1);
  int lenOfChildAssumps=childVec.size();
  if (lastChildNode.nodeType == NodeRepresentation.OR_DECOMP) {
    lenOfChildAssumps--;
  }
  for (int i=0; i < lenOfChildAssumps; i++) {
    newAssumpCount=newAssumpCount + childVec.elementAt(i).primedNodeText().length;
  }
  String[] newAssumpArray=new String[newAssumpCount];
  for (int i=0; i < assumpArray.length; i++) {
    newAssumpArray[i]=assumpArray[i];
  }
  if (lenOfChildAssumps > 0) {
    if (assumpArray.length > 0) {
      newAssumpArray[assumpArray.length - 1]=newAssumpArray[assumpArray.length - 1] + ""String_Node_Str"";
    }
    int idx=assumpArray.length;
    for (int i=0; i < lenOfChildAssumps; i++) {
      String[] assump=childVec.elementAt(i).primedNodeText();
      for (int j=0; j < assump.length; j++) {
        newAssumpArray[idx]=assump[j];
        idx++;
      }
      if (i != lenOfChildAssumps - 1) {
        newAssumpArray[idx - 1]=newAssumpArray[idx - 1] + ""String_Node_Str"";
      }
    }
  }
  if (lastChildNode.nodeType == NodeRepresentation.OR_DECOMP) {
    for (int i=0; i < lastChildNode.children.size(); i++) {
      addCaseProofs(pfStepVec,lastChildNode.children.elementAt(i),newAssumpArray,proofText);
    }
  }
 else {
    String[] step;
    if (newAssumpArray.length == 0) {
      step=prependToStringArray(lastChildNode.primedNodeText(),""String_Node_Str"");
    }
 else {
      step=concatStringArrays(prependToStringArray(newAssumpArray,""String_Node_Str""),prependToStringArray(this.goalRep.primedNodeText(),""String_Node_Str""));
    }
    step=prependToStringArray(step,proofLevelString + (pfStepVec.size() + 1) + STEP_NUMBER_PUNCTUATION+ ""String_Node_Str"");
    if (proofText != null) {
      step=concatStringArrays(step,proofText);
    }
    pfStepVec.add(step);
  }
}","/** 
 * Adds the proofs steps for a CASE decomposition.
 * @param pfStepVec   The vector to which proof steps should be added.
 * @param childVec    The vector of CASE assumptions' NodeRepresentation objects, which may include OR_DECOMP nodes.
 * @param assumpArray The assumptions that must be prepended to each case.
 * @param proofText   The user's proof, or null if none.
 */
void addCaseProofs(Vector<String[]> pfStepVec,Vector<NodeRepresentation> childVec,String[] assumpArray,String[] proofText){
  int newAssumpCount=assumpArray.length;
  NodeRepresentation lastChildNode=childVec.elementAt(childVec.size() - 1);
  int lenOfChildAssumps=childVec.size();
  if (lastChildNode.nodeType == NodeRepresentation.OR_DECOMP) {
    lenOfChildAssumps--;
  }
  for (int i=0; i < lenOfChildAssumps; i++) {
    newAssumpCount=newAssumpCount + childVec.elementAt(i).primedNodeText().length;
  }
  String[] newAssumpArray=new String[newAssumpCount];
  for (int i=0; i < assumpArray.length; i++) {
    newAssumpArray[i]=assumpArray[i];
  }
  if (lenOfChildAssumps > 0) {
    if (assumpArray.length > 0) {
      newAssumpArray[assumpArray.length - 1]=newAssumpArray[assumpArray.length - 1] + ""String_Node_Str"";
    }
    int idx=assumpArray.length;
    for (int i=0; i < lenOfChildAssumps; i++) {
      String[] assump=childVec.elementAt(i).primedNodeText();
      for (int j=0; j < assump.length; j++) {
        newAssumpArray[idx]=assump[j];
        idx++;
      }
      if (i != lenOfChildAssumps - 1) {
        newAssumpArray[idx - 1]=newAssumpArray[idx - 1] + ""String_Node_Str"";
      }
    }
  }
  if (lastChildNode.nodeType == NodeRepresentation.OR_DECOMP) {
    for (int i=0; i < lastChildNode.children.size(); i++) {
      addCaseProofs(pfStepVec,lastChildNode.children.elementAt(i),newAssumpArray,proofText);
    }
  }
 else {
    String[] step;
    if (newAssumpArray.length == 1 && useCaseButton.getSelection()) {
      step=prependToStringArray(lastChildNode.primedNodeText(),""String_Node_Str"");
    }
 else {
      step=concatStringArrays(prependToStringArray(newAssumpArray,""String_Node_Str""),prependToStringArray(this.goalRep.primedNodeText(),""String_Node_Str""));
    }
    step=prependToStringArray(step,proofLevelString + (pfStepVec.size() + 1) + STEP_NUMBER_PUNCTUATION+ ""String_Node_Str"");
    if (proofText != null) {
      step=concatStringArrays(step,proofText);
    }
    pfStepVec.add(step);
  }
}",0.9484008528784648
135867,"/** 
 * THE REAL EXECUTE METHOD This method is called by a synchronous job launched in the execute method  to do most of the work of executing the Decompose Proof command.
 * @see org.eclipse.core.commands.IHandler#execute(org.eclipse.core.commands.ExecutionEvent)
 */
public Object realExecute() throws ExecutionException {
  Activator.getDefault().logDebug(""String_Node_Str"");
  Vector<SemanticNode> assumes;
  SemanticNode goal;
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] oneline=new String[]{""String_Node_Str""};
  if (this.windowShell != null) {
    if (!this.windowShell.isDisposed()) {
      System.out.println(""String_Node_Str"");
      return null;
    }
  }
  boolean proceed=UIHelper.promptUserForDirtyModules();
  if (!proceed) {
    return null;
  }
  if (editor == null) {
    Activator.getDefault().logDebug(""String_Node_Str"");
    return null;
  }
  editorIFile=((FileEditorInput)editor.getEditorInput()).getFile();
  ParseResult parseResult=ResourceHelper.getValidParseResult(editorIFile);
  if (parseResult == null) {
    parseResult=new ModuleParserLauncher().parseModule(editorIFile,new NullProgressMonitor());
  }
  if (existDirtyModules()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Spec spec=Activator.getSpecManager().getSpecLoaded();
  if (spec == null || spec.getStatus() != IParseConstants.PARSED) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  if (editor == null) {
    Activator.getDefault().logDebug(""String_Node_Str"");
    return null;
  }
  editorIFile=((FileEditorInput)editor.getEditorInput()).getFile();
  if (editor.isDirty()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  hasChanged=false;
  chosenSplit=-1;
  needsStepNumber=false;
  andSplitBegin=-1;
  andSplitEnd=-1;
  goalDefinitions=new HashSet<String>();
  assumpDefinitions=new HashSet<String>();
  Location selectedLocation=EditorUtil.getLocationAt(doc,offset,selection.getLength());
  TheoremNode[] allTheorems=moduleNode.getTheorems();
  theorem=null;
  int i=0;
  String moduleFile=moduleNode.stn.getFilename();
  while ((theorem == null) & (i < allTheorems.length)) {
    if (allTheorems[i].stn.getFilename().equals(moduleFile) && EditorUtil.lineLocationContainment(selectedLocation,allTheorems[i].stn.getLocation())) {
      theorem=allTheorems[i];
    }
    i++;
  }
  if (theorem == null) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  step=theorem;
  boolean notDone=true;
  proofLevel=-1;
  proof=step.getProof();
  while (notDone && (proof != null) && (proof instanceof NonLeafProofNode)) {
    LevelNode[] pfsteps=((NonLeafProofNode)proof).getSteps();
    LevelNode foundLevelNode=null;
    i=0;
    proofLevel=stepLevel(pfsteps[0]);
    while ((foundLevelNode == null) && (i < pfsteps.length)) {
      if (EditorUtil.lineLocationContainment(selectedLocation,pfsteps[i].stn.getLocation())) {
        foundLevelNode=pfsteps[i];
      }
      i++;
    }
    if (foundLevelNode == null) {
      notDone=false;
    }
 else     if (!(foundLevelNode instanceof TheoremNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
 else {
      step=(TheoremNode)foundLevelNode;
      proof=step.getProof();
    }
  }
  if (step.isSuffices()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  int level=this.proofLevel;
  if (level < 0) {
    level=0;
  }
  proofLevelString=""String_Node_Str"" + (level + 1) + ""String_Node_Str"";
  SyntaxTreeNode nd=(SyntaxTreeNode)step.stn;
  if (step == theorem) {
    stepNumber=null;
  }
 else {
    stepNumber=nd.getHeirs()[0].image.toString();
    if (stepNumber.indexOf('>') == stepNumber.length() - 1) {
      stepNumber=null;
    }
 else {
      i=stepNumber.indexOf('>') + 1;
      while ((i < stepNumber.length() && (Character.isLetterOrDigit(stepNumber.charAt(i)) || (stepNumber.charAt(i) == '_')))) {
        i++;
      }
      if (i < stepNumber.length()) {
        stepNumber=stepNumber.substring(0,i);
      }
    }
  }
  stepColumn=nd.getLocation().beginColumn();
  if ((proof != null) && !(proof instanceof LeafProofNode)) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  try {
    stepRep=new NodeRepresentation(doc,step);
  }
 catch (  BadLocationException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
  }
  LevelNode thm=step.getTheorem();
  if (thm instanceof AssumeProveNode) {
    hasAssumes=true;
    SemanticNode[] assump=((AssumeProveNode)thm).getAssumes();
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    int rowOfLastNew=-1;
    for (i=0; i < assump.length; i++) {
      if (assump[i] instanceof AssumeProveNode) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      assumes.add(assump[i]);
      NodeRepresentation nodeRep=stepRep.subNodeRep(assump[i],assumeReps,null,null);
      if (nodeRep.nodeType == NodeRepresentation.NEW_NODE) {
        Location loc=nodeRep.semanticNode.stn.getLocation();
        if (loc.beginLine() == loc.endLine()) {
          if (loc.beginLine() == rowOfLastNew) {
            assumeReps.elementAt(i - 1).onSameLineAsNext=true;
          }
          rowOfLastNew=loc.beginLine();
        }
 else {
          rowOfLastNew=-1;
        }
      }
 else {
        rowOfLastNew=-1;
      }
      assumeReps.add(nodeRep);
      goal=((AssumeProveNode)thm).getProve();
      if (!(goal instanceof OpApplNode)) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      goalRep=stepRep.subNodeRep(goal,null,null,null);
    }
  }
 else {
    hasAssumes=false;
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    if (!(thm instanceof OpApplNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goal=thm;
    UniqueString goalOpName=null;
    if (goal instanceof OpApplNode) {
      goalOpName=((OpApplNode)goal).getOperator().getName();
    }
    if ((goalOpName == null) || (goalOpName == ASTConstants.OP_qed) || (goalOpName == ASTConstants.OP_pfcase)|| (goalOpName == ASTConstants.OP_have)|| (goalOpName == ASTConstants.OP_pick)|| (goalOpName == ASTConstants.OP_witness)|| (goalOpName == ASTConstants.OP_suffices)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goalRep=stepRep.subNodeRep(goal,null,null,null);
  }
  editorIFile.setReadOnly(true);
  raiseWindow();
  Activator.getDefault().logDebug(""String_Node_Str"");
  return null;
}","/** 
 * THE REAL EXECUTE METHOD This method is called by a synchronous job launched in the execute method  to do most of the work of executing the Decompose Proof command.
 * @see org.eclipse.core.commands.IHandler#execute(org.eclipse.core.commands.ExecutionEvent)
 */
public Object realExecute() throws ExecutionException {
  Activator.getDefault().logDebug(""String_Node_Str"");
  Vector<SemanticNode> assumes;
  SemanticNode goal;
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] oneline=new String[]{""String_Node_Str""};
  if (this.windowShell != null) {
    if (!this.windowShell.isDisposed()) {
      System.out.println(""String_Node_Str"");
      return null;
    }
  }
  if (existDirtyModules()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Spec spec=Activator.getSpecManager().getSpecLoaded();
  if (spec == null || spec.getStatus() != IParseConstants.PARSED) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  if (editor == null) {
    Activator.getDefault().logDebug(""String_Node_Str"");
    return null;
  }
  editorIFile=((FileEditorInput)editor.getEditorInput()).getFile();
  if (editor.isDirty()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  hasChanged=false;
  chosenSplit=-1;
  needsStepNumber=false;
  andSplitBegin=-1;
  andSplitEnd=-1;
  goalDefinitions=new HashSet<String>();
  assumpDefinitions=new HashSet<String>();
  Location selectedLocation=EditorUtil.getLocationAt(doc,offset,selection.getLength());
  TheoremNode[] allTheorems=moduleNode.getTheorems();
  theorem=null;
  int i=0;
  String moduleFile=moduleNode.stn.getFilename();
  while ((theorem == null) & (i < allTheorems.length)) {
    if (allTheorems[i].stn.getFilename().equals(moduleFile) && EditorUtil.lineLocationContainment(selectedLocation,allTheorems[i].stn.getLocation())) {
      theorem=allTheorems[i];
    }
    i++;
  }
  if (theorem == null) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  step=theorem;
  boolean notDone=true;
  proofLevel=-1;
  proof=step.getProof();
  while (notDone && (proof != null) && (proof instanceof NonLeafProofNode)) {
    LevelNode[] pfsteps=((NonLeafProofNode)proof).getSteps();
    LevelNode foundLevelNode=null;
    i=0;
    proofLevel=stepLevel(pfsteps[0]);
    while ((foundLevelNode == null) && (i < pfsteps.length)) {
      if (EditorUtil.lineLocationContainment(selectedLocation,pfsteps[i].stn.getLocation())) {
        foundLevelNode=pfsteps[i];
      }
      i++;
    }
    if (foundLevelNode == null) {
      notDone=false;
    }
 else     if (!(foundLevelNode instanceof TheoremNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
 else {
      step=(TheoremNode)foundLevelNode;
      proof=step.getProof();
    }
  }
  if (step.isSuffices()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  int level=this.proofLevel;
  if (level < 0) {
    level=0;
  }
  proofLevelString=""String_Node_Str"" + (level + 1) + ""String_Node_Str"";
  SyntaxTreeNode nd=(SyntaxTreeNode)step.stn;
  if (step == theorem) {
    stepNumber=null;
  }
 else {
    stepNumber=nd.getHeirs()[0].image.toString();
    if (stepNumber.indexOf('>') == stepNumber.length() - 1) {
      stepNumber=null;
    }
 else {
      i=stepNumber.indexOf('>') + 1;
      while ((i < stepNumber.length() && (Character.isLetterOrDigit(stepNumber.charAt(i)) || (stepNumber.charAt(i) == '_')))) {
        i++;
      }
      if (i < stepNumber.length()) {
        stepNumber=stepNumber.substring(0,i);
      }
    }
  }
  stepColumn=nd.getLocation().beginColumn();
  if ((proof != null) && !(proof instanceof LeafProofNode)) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  try {
    stepRep=new NodeRepresentation(doc,step);
  }
 catch (  BadLocationException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
  }
  LevelNode thm=step.getTheorem();
  if (thm instanceof AssumeProveNode) {
    hasAssumes=true;
    SemanticNode[] assump=((AssumeProveNode)thm).getAssumes();
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    int rowOfLastNew=-1;
    for (i=0; i < assump.length; i++) {
      if (assump[i] instanceof AssumeProveNode) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      assumes.add(assump[i]);
      NodeRepresentation nodeRep=stepRep.subNodeRep(assump[i],assumeReps,null,null);
      if (nodeRep.nodeType == NodeRepresentation.NEW_NODE) {
        Location loc=nodeRep.semanticNode.stn.getLocation();
        if (loc.beginLine() == loc.endLine()) {
          if (loc.beginLine() == rowOfLastNew) {
            assumeReps.elementAt(i - 1).onSameLineAsNext=true;
          }
          rowOfLastNew=loc.beginLine();
        }
 else {
          rowOfLastNew=-1;
        }
      }
 else {
        rowOfLastNew=-1;
      }
      assumeReps.add(nodeRep);
      goal=((AssumeProveNode)thm).getProve();
      if (!(goal instanceof OpApplNode)) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      goalRep=stepRep.subNodeRep(goal,null,null,null);
    }
  }
 else {
    hasAssumes=false;
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    if (!(thm instanceof OpApplNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goal=thm;
    UniqueString goalOpName=null;
    if (goal instanceof OpApplNode) {
      goalOpName=((OpApplNode)goal).getOperator().getName();
    }
    if ((goalOpName == null) || (goalOpName == ASTConstants.OP_qed) || (goalOpName == ASTConstants.OP_pfcase)|| (goalOpName == ASTConstants.OP_have)|| (goalOpName == ASTConstants.OP_pick)|| (goalOpName == ASTConstants.OP_witness)|| (goalOpName == ASTConstants.OP_suffices)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goalRep=stepRep.subNodeRep(goal,null,null,null);
  }
  editorIFile.setReadOnly(true);
  raiseWindow();
  Activator.getDefault().logDebug(""String_Node_Str"");
  return null;
}",0.3336927611242901
135868,"private void raiseWindow(){
  if ((windowShell != null) && (!windowShell.isDisposed())) {
    location=windowShell.getLocation();
    windowShell.close();
    windowShell.dispose();
  }
  Shell topshell=UIHelper.getShellProvider().getShell();
  windowShell=new Shell(topshell,SWT.CLOSE | SWT.TITLE | SWT.RESIZE);
  windowShell.setText(""String_Node_Str"");
  windowShell.addDisposeListener(new WindowDisposeListener(this));
  Composite shell=new Composite(windowShell,SWT.NONE);
  GridLayout gridLayout=new GridLayout(3,false);
  shell.setLayout(gridLayout);
  Composite topMenu=new Composite(shell,SWT.NONE);
  gridLayout=new GridLayout(4,false);
  gridLayout.marginBottom=0;
  topMenu.setLayout(gridLayout);
  GridData gridData=new GridData();
  gridData.horizontalSpan=3;
  topMenu.setLayoutData(gridData);
  Button replaceButton=new Button(topMenu,SWT.PUSH);
  setupMenuButton(replaceButton,PROVE_BUTTON,""String_Node_Str"");
  replaceButton.setFont(JFaceResources.getFontRegistry().get(JFaceResources.HEADER_FONT));
  replaceButton.setEnabled(hasChanged && (chosenSplit == -1) && (andSplitEnd == -1));
  useSufficesButton=new Button(topMenu,SWT.CHECK);
  setupCheckButton(useSufficesButton,""String_Node_Str"");
  useSufficesButton.setSelection(useSufficesValue);
  subexpressionButton=new Button(topMenu,SWT.CHECK);
  setupCheckButton(subexpressionButton,""String_Node_Str"");
  subexpressionButton.setSelection(subexpressionValue);
  gridData=new GridData();
  gridData.horizontalAlignment=GridData.FILL;
  gridData.grabExcessHorizontalSpace=true;
  subexpressionButton.setLayoutData(gridData);
  Button helpButton=HelpButton.helpButton(topMenu,""String_Node_Str"");
  gridData=new GridData();
  gridData.horizontalIndent=20;
  helpButton.setLayoutData(gridData);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  Label assumeLabel=new Label(shell,SWT.NONE);
  assumeLabel.setText(""String_Node_Str"");
  assumeLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.HEADER_FONT));
  assumeLabel.setLayoutData(gridData);
  if (assumeReps != null) {
    addAssumptionsToComposite(assumeReps,shell);
  }
  gridData=new GridData();
  gridData.horizontalSpan=3;
  assumeLabel=new Label(shell,SWT.NONE);
  assumeLabel.setLayoutData(gridData);
  assumeLabel.setText(""String_Node_Str"");
  assumeLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.HEADER_FONT));
  String labelText=null;
  boolean isProver=false;
  boolean disable=false;
switch (goalRep.nodeSubtype) {
case NodeRepresentation.AND_TYPE:
    labelText=""String_Node_Str"";
  isProver=true;
disable=(chosenSplit != -1) || (andSplitBegin != -1);
break;
case NodeRepresentation.FORALL_TYPE:
labelText=""String_Node_Str"";
break;
case NodeRepresentation.IMPLIES_TYPE:
labelText=""String_Node_Str"";
break;
default :
labelText=null;
}
if (labelText != null) {
Button goalButton=new Button(shell,SWT.PUSH);
setupActionButton(goalButton,goalRep,labelText);
goalButton.setEnabled(!disable);
}
 else {
assumeLabel=new Label(shell,SWT.NONE);
assumeLabel.setText(""String_Node_Str"");
}
Composite comp;
comp=new Composite(shell,SWT.NONE);
gridLayout=new GridLayout(1,false);
comp.setLayout(gridLayout);
if (isProver && !disable) {
assumeLabel=new Label(comp,SWT.NONE);
assumeLabel.setText(""String_Node_Str"");
assumeLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.HEADER_FONT));
}
comp.setSize(0,5);
assumeLabel=new Label(shell,SWT.NONE);
assumeLabel.setText(stringArrayToString(goalRep.primedNodeText()));
gridData=new GridData();
gridData.verticalAlignment=SWT.TOP;
assumeLabel.setLayoutData(gridData);
assumeLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.TEXT_FONT));
shell.pack();
Point shellSize=shell.getSize();
windowShell.pack();
Point windowShellSize=windowShell.getSize();
System.out.println(""String_Node_Str"" + windowShellSize.x + ""String_Node_Str""+ windowShellSize.y);
;
windowShell.update();
if (this.location != null) {
windowShell.setLocation(this.location);
}
windowShell.open();
editorIFile.setReadOnly(true);
}","private void raiseWindow(){
  if ((windowShell != null) && (!windowShell.isDisposed())) {
    location=windowShell.getLocation();
    windowShell.close();
    windowShell.dispose();
  }
  Shell topshell=UIHelper.getShellProvider().getShell();
  windowShell=new Shell(topshell,SWT.CLOSE | SWT.TITLE | SWT.RESIZE);
  windowShell.setText(""String_Node_Str"");
  windowShell.addDisposeListener(new WindowDisposeListener(this));
  Composite shell=new Composite(windowShell,SWT.NONE);
  GridLayout gridLayout=new GridLayout(3,false);
  shell.setLayout(gridLayout);
  Composite topMenu=new Composite(shell,SWT.NONE);
  gridLayout=new GridLayout(5,false);
  gridLayout.marginBottom=0;
  topMenu.setLayout(gridLayout);
  GridData gridData=new GridData();
  gridData.horizontalSpan=3;
  topMenu.setLayoutData(gridData);
  Button replaceButton=new Button(topMenu,SWT.PUSH);
  setupMenuButton(replaceButton,PROVE_BUTTON,""String_Node_Str"");
  replaceButton.setFont(JFaceResources.getFontRegistry().get(JFaceResources.HEADER_FONT));
  replaceButton.setEnabled(hasChanged && (chosenSplit == -1) && (andSplitEnd == -1));
  useSufficesButton=new Button(topMenu,SWT.CHECK);
  setupCheckButton(useSufficesButton,""String_Node_Str"");
  useSufficesButton.setSelection(useSufficesValue);
  useCaseButton=new Button(topMenu,SWT.CHECK);
  setupCheckButton(useCaseButton,""String_Node_Str"");
  useCaseButton.setSelection(useCaseValue);
  subexpressionButton=new Button(topMenu,SWT.CHECK);
  setupCheckButton(subexpressionButton,""String_Node_Str"");
  subexpressionButton.setSelection(subexpressionValue);
  gridData=new GridData();
  gridData.horizontalAlignment=GridData.FILL;
  gridData.grabExcessHorizontalSpace=true;
  subexpressionButton.setLayoutData(gridData);
  Button helpButton=HelpButton.helpButton(topMenu,""String_Node_Str"");
  gridData=new GridData();
  gridData.horizontalIndent=20;
  helpButton.setLayoutData(gridData);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  Label assumeLabel=new Label(shell,SWT.NONE);
  assumeLabel.setText(""String_Node_Str"");
  assumeLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.HEADER_FONT));
  assumeLabel.setLayoutData(gridData);
  if (assumeReps != null) {
    addAssumptionsToComposite(assumeReps,shell);
  }
  gridData=new GridData();
  gridData.horizontalSpan=3;
  assumeLabel=new Label(shell,SWT.NONE);
  assumeLabel.setLayoutData(gridData);
  assumeLabel.setText(""String_Node_Str"");
  assumeLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.HEADER_FONT));
  String labelText=null;
  boolean isProver=false;
  boolean disable=false;
switch (goalRep.nodeSubtype) {
case NodeRepresentation.AND_TYPE:
    labelText=""String_Node_Str"";
  isProver=true;
disable=(chosenSplit != -1) || (andSplitBegin != -1);
break;
case NodeRepresentation.FORALL_TYPE:
labelText=""String_Node_Str"";
break;
case NodeRepresentation.IMPLIES_TYPE:
labelText=""String_Node_Str"";
break;
default :
labelText=null;
}
if (labelText != null) {
Button goalButton=new Button(shell,SWT.PUSH);
setupActionButton(goalButton,goalRep,labelText);
goalButton.setEnabled(!disable);
}
 else {
assumeLabel=new Label(shell,SWT.NONE);
assumeLabel.setText(""String_Node_Str"");
}
Composite comp;
comp=new Composite(shell,SWT.NONE);
gridLayout=new GridLayout(1,false);
comp.setLayout(gridLayout);
if (isProver && !disable) {
assumeLabel=new Label(comp,SWT.NONE);
assumeLabel.setText(""String_Node_Str"");
assumeLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.HEADER_FONT));
}
comp.setSize(0,5);
assumeLabel=new Label(shell,SWT.NONE);
assumeLabel.setText(stringArrayToString(goalRep.primedNodeText()));
gridData=new GridData();
gridData.verticalAlignment=SWT.TOP;
assumeLabel.setLayoutData(gridData);
assumeLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.TEXT_FONT));
shell.pack();
Point shellSize=shell.getSize();
windowShell.pack();
Point windowShellSize=windowShell.getSize();
System.out.println(""String_Node_Str"" + windowShellSize.x + ""String_Node_Str""+ windowShellSize.y);
;
windowShell.update();
if (this.location != null) {
windowShell.setLocation(this.location);
}
windowShell.open();
editorIFile.setReadOnly(true);
}",0.9822038030229155
135869,"/** 
 * Record the state of the top menu's check buttons.
 */
private void readButtons(){
  useSufficesValue=useSufficesButton.getSelection();
  subexpressionValue=subexpressionButton.getSelection();
}","/** 
 * Record the state of the top menu's check buttons.
 */
private void readButtons(){
  useSufficesValue=useSufficesButton.getSelection();
  useCaseValue=useCaseButton.getSelection();
  subexpressionValue=subexpressionButton.getSelection();
}",0.8993288590604027
135870,"void existsAction(NodeRepresentation nodeRep){
  int idx=nodeRep.getParentIndex();
  Vector<NodeRepresentation> parentVec=nodeRep.parentVector;
  Decomposition decomp=nodeRep.decomposition;
  hasChanged=true;
  if (decomp.definedOp != null) {
    goalDefinitions.add(decomp.definedOp);
  }
  if (!nodeRep.isCreated && this.hasAssumes) {
    needsStepNumber=true;
  }
  QuantifierDecomposition qdc=decomposeQuantifier(nodeRep,true);
  parentVec.remove(idx);
  for (int i=0; i < qdc.news.size(); i++) {
    parentVec.add(idx + i,qdc.news.elementAt(i));
  }
  parentVec.add(idx + qdc.news.size(),qdc.body);
  raiseWindow();
}","void existsAction(NodeRepresentation nodeRep){
  int idx=nodeRep.getParentIndex();
  Vector<NodeRepresentation> parentVec=nodeRep.parentVector;
  Decomposition decomp=nodeRep.decomposition;
  hasChanged=true;
  if (decomp.definedOp != null) {
    assumeDefinitions.add(decomp.definedOp);
  }
  if (!nodeRep.isCreated && this.hasAssumes) {
    needsStepNumber=true;
  }
  QuantifierDecomposition qdc=decomposeQuantifier(nodeRep,true);
  parentVec.remove(idx);
  for (int i=0; i < qdc.news.size(); i++) {
    parentVec.add(idx + i,qdc.news.elementAt(i));
  }
  parentVec.add(idx + qdc.news.size(),qdc.body);
  raiseWindow();
}",0.9919743178170144
135871,"/** 
 * Creates the proof, which is a Suffices Only proof if sufficesONly = true, and otherwise is an and-split proof if * isAndProof is true, and a case-split proof otherwise.
 * @param nodeRep
 * @param isAndProof
 * @param sufficesOnly
 */
void makeProof(NodeRepresentation nodeRep,boolean isAndProof,boolean sufficesOnly){
  int proofIndent=PROOF_INDENT;
  String proofIndentString=StringHelper.copyString(""String_Node_Str"",proofIndent);
  String[] assumptionsText=createdAssumptions();
  String[] proofText=null;
  if (this.proof != null) {
    proofText=this.stepRep.subNodeText(this.proof).nodeText;
    proofText=prependToStringArray(proofText,proofIndentString);
    try {
      IRegion proofRegion=EditorUtil.getRegionOf(this.doc,((SyntaxTreeNode)this.proof.stn).getLocation());
      this.doc.replace(proofRegion.getOffset(),proofRegion.getLength(),""String_Node_Str"");
    }
 catch (    BadLocationException e) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  boolean addStepNumber=(stepNumber != null) && this.needsStepNumber;
  String[] sufficesStep=null;
  boolean hasSufficesStep=useSufficesButton.getSelection() && (assumptionsText.length != 0);
  if (hasSufficesStep || sufficesOnly) {
    String sufficesProof=null;
    String[] suffices=prependToStringArray(concatStringArrays(prependToStringArray(assumptionsText,""String_Node_Str""),prependToStringArray(this.goalRep.primedNodeText(),""String_Node_Str"")),proofLevelString + ""String_Node_Str"");
    if (goalDefinitions.isEmpty() && !addStepNumber) {
      if (OBVIOUS_HAS_PROOF) {
        sufficesProof=""String_Node_Str"";
      }
 else {
        sufficesProof=""String_Node_Str"";
      }
    }
 else {
      sufficesProof=""String_Node_Str"";
      if (addStepNumber) {
        sufficesProof=sufficesProof + this.stepNumber + ""String_Node_Str"";
      }
      if (!goalDefinitions.isEmpty()) {
        sufficesProof=sufficesProof + ""String_Node_Str"" + setOfStringsToList(goalDefinitions);
      }
    }
    sufficesStep=concatStringArrays(suffices,new String[]{proofIndentString + sufficesProof});
  }
  String[][] mainProofSteps=null;
  int numberOfSteps=0;
  String proofDef=null;
  if (!sufficesOnly) {
    if (isAndProof) {
      Decomposition decomp=nodeRep.decomposition;
      numberOfSteps=decomp.children.size();
      mainProofSteps=new String[numberOfSteps][];
      proofDef=decomp.definedOp;
      for (int i=0; i < numberOfSteps; i++) {
        NodeRepresentation stepGoalRep=decompositionChildToNodeRep(nodeRep,i,null,null);
        String[] goalArray=stepGoalRep.primedNodeText();
        String[] step;
        if ((sufficesStep == null || assumptionsText == null && assumptionsText.length == 0)) {
          step=concatStringArrays(prependToStringArray(assumptionsText,""String_Node_Str""),prependToStringArray(goalArray,""String_Node_Str""));
        }
 else {
          step=goalArray;
        }
        step=prependToStringArray(step,proofLevelString + (i + 1) + STEP_NUMBER_PUNCTUATION+ ""String_Node_Str"");
        if (proofText != null) {
          step=concatStringArrays(step,proofText);
        }
        mainProofSteps[i]=step;
      }
    }
 else {
      Vector<String[]> pfStepVec=new Vector<String[]>();
      for (int i=0; i < nodeRep.children.size(); i++) {
        Vector<NodeRepresentation> childVec=nodeRep.children.elementAt(i);
        String[] assumpArray;
        if (!hasSufficesStep) {
          assumpArray=new String[assumptionsText.length];
          for (int j=0; j < assumptionsText.length; j++) {
            assumpArray[j]=assumptionsText[j];
          }
        }
 else {
          assumpArray=new String[0];
        }
        addCaseProofs(pfStepVec,childVec,assumpArray,proofText);
      }
      mainProofSteps=new String[pfStepVec.size()][];
      for (int i=0; i < mainProofSteps.length; i++) {
        mainProofSteps[i]=pfStepVec.elementAt(i);
      }
      numberOfSteps=mainProofSteps.length;
    }
  }
  String[] qedStep=new String[2];
  qedStep[0]=proofLevelString;
  if (NUMBER_QED_STEP && (numberOfSteps != 0)) {
    qedStep[0]=qedStep[0] + (numberOfSteps + 1) + STEP_NUMBER_PUNCTUATION;
  }
  qedStep[0]=qedStep[0] + ""String_Node_Str"";
  qedStep[1]=proofIndentString + ""String_Node_Str"" + ((numberOfSteps > 0) ? (proofLevelString + 1) : ""String_Node_Str"");
  for (int i=2; i <= numberOfSteps; i++) {
    qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofLevelString+ i;
  }
  if ((sufficesStep == null) && needsStepNumber) {
    qedStep[1]=qedStep[1] + ""String_Node_Str"" + this.stepNumber;
  }
  boolean hasGoalDefs=(!this.goalDefinitions.isEmpty()) && (sufficesStep == null);
  boolean hasAssumeDefs=!this.assumeDefinitions.isEmpty();
  String goalAndAssumeDefs=(hasGoalDefs ? setOfStringsToList(this.goalDefinitions) : ""String_Node_Str"") + ((hasGoalDefs && hasAssumeDefs) ? ""String_Node_Str"" : ""String_Node_Str"") + (hasAssumeDefs ? setOfStringsToList(this.assumeDefinitions) : ""String_Node_Str"");
  if (sufficesOnly) {
    if (this.proof != null) {
      qedStep=concatStringArrays(new String[]{qedStep[0]},prependToStringArray(proofText,proofIndentString));
    }
 else {
      qedStep[1]=""String_Node_Str"";
    }
  }
 else {
    boolean hasDEF=false;
    if (hasGoalDefs || hasAssumeDefs) {
      hasDEF=true;
      qedStep[1]=qedStep[1] + ""String_Node_Str"" + goalAndAssumeDefs;
    }
    if (proofDef != null) {
      if (hasDEF) {
        qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofDef;
      }
 else {
        qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofDef;
      }
    }
  }
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] completeProof=new String[0];
  if (sufficesStep != null) {
    if (this.BLANK_LINE_BETWEEN_STEPS) {
      completeProof=concatStringArrays(sufficesStep,blankLine);
    }
 else {
      completeProof=sufficesStep;
    }
  }
  if (mainProofSteps != null) {
    completeProof=concatStringArrays(completeProof,mainProofSteps[0]);
    for (int i=1; i < mainProofSteps.length; i++) {
      if (this.BLANK_LINE_BETWEEN_STEPS) {
        completeProof=concatStringArrays(completeProof,concatStringArrays(blankLine,mainProofSteps[i]));
      }
 else {
        completeProof=concatStringArrays(completeProof,mainProofSteps[i]);
      }
    }
    if (this.BLANK_LINE_BETWEEN_STEPS) {
      completeProof=concatStringArrays(completeProof,blankLine);
    }
  }
  completeProof=concatStringArrays(completeProof,qedStep);
  completeProof=prependToStringArray(completeProof,StringHelper.copyString(""String_Node_Str"",this.step.getLocation().beginColumn() - 1 + proofIndent));
  try {
    int nextLineOffset=doc.getLineInformation(this.step.getTheorem().getLocation().endLine()).getOffset();
    this.doc.replace(nextLineOffset,0,stringArrayToString(completeProof) + ""String_Node_Str"");
  }
 catch (  BadLocationException e) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    e.printStackTrace();
  }
  this.windowShell.dispose();
  return;
}","/** 
 * Creates the proof, which is a Suffices Only proof if sufficesONly = true, and otherwise is an and-split proof if * isAndProof is true, and a case-split proof otherwise.
 * @param nodeRep
 * @param isAndProof
 * @param sufficesOnly
 */
void makeProof(NodeRepresentation nodeRep,boolean isAndProof,boolean sufficesOnly){
  int proofIndent=PROOF_INDENT;
  String proofIndentString=StringHelper.copyString(""String_Node_Str"",proofIndent);
  String[] assumptionsText=createdAssumptions();
  String[] proofText=null;
  if (this.proof != null) {
    proofText=this.stepRep.subNodeText(this.proof).nodeText;
    proofText=prependToStringArray(proofText,proofIndentString);
    try {
      IRegion proofRegion=EditorUtil.getRegionOf(this.doc,((SyntaxTreeNode)this.proof.stn).getLocation());
      this.doc.replace(proofRegion.getOffset(),proofRegion.getLength(),""String_Node_Str"");
    }
 catch (    BadLocationException e) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  boolean addStepNumber=(stepNumber != null) && this.needsStepNumber;
  String[] sufficesStep=null;
  boolean hasSufficesStep=useSufficesButton.getSelection() && (assumptionsText.length != 0);
  if (hasSufficesStep || sufficesOnly) {
    String sufficesProof=null;
    String[] suffices=prependToStringArray(concatStringArrays(prependToStringArray(assumptionsText,""String_Node_Str""),prependToStringArray(this.goalRep.primedNodeText(),""String_Node_Str"")),proofLevelString + ""String_Node_Str"");
    if (goalDefinitions.isEmpty() && !addStepNumber) {
      if (OBVIOUS_HAS_PROOF) {
        sufficesProof=""String_Node_Str"";
      }
 else {
        sufficesProof=""String_Node_Str"";
      }
    }
 else {
      sufficesProof=""String_Node_Str"";
      if (addStepNumber) {
        sufficesProof=sufficesProof + this.stepNumber + ""String_Node_Str"";
      }
      if (!goalDefinitions.isEmpty()) {
        sufficesProof=sufficesProof + ""String_Node_Str"" + setOfStringsToList(goalDefinitions);
      }
    }
    sufficesStep=concatStringArrays(suffices,new String[]{proofIndentString + sufficesProof});
  }
  String[][] mainProofSteps=null;
  int numberOfSteps=0;
  String proofDef=null;
  if (!sufficesOnly) {
    if (isAndProof) {
      Decomposition decomp=nodeRep.decomposition;
      numberOfSteps=decomp.children.size();
      mainProofSteps=new String[numberOfSteps][];
      proofDef=decomp.definedOp;
      for (int i=0; i < numberOfSteps; i++) {
        NodeRepresentation stepGoalRep=decompositionChildToNodeRep(nodeRep,i,null,null);
        String[] goalArray=stepGoalRep.primedNodeText();
        String[] step;
        if ((sufficesStep == null && assumptionsText != null && assumptionsText.length != 0)) {
          step=concatStringArrays(prependToStringArray(assumptionsText,""String_Node_Str""),prependToStringArray(goalArray,""String_Node_Str""));
        }
 else {
          step=goalArray;
        }
        step=prependToStringArray(step,proofLevelString + (i + 1) + STEP_NUMBER_PUNCTUATION+ ""String_Node_Str"");
        if (proofText != null) {
          step=concatStringArrays(step,proofText);
        }
        mainProofSteps[i]=step;
      }
    }
 else {
      Vector<String[]> pfStepVec=new Vector<String[]>();
      for (int i=0; i < nodeRep.children.size(); i++) {
        Vector<NodeRepresentation> childVec=nodeRep.children.elementAt(i);
        String[] assumpArray;
        if (!hasSufficesStep) {
          assumpArray=new String[assumptionsText.length];
          for (int j=0; j < assumptionsText.length; j++) {
            assumpArray[j]=assumptionsText[j];
          }
        }
 else {
          assumpArray=new String[0];
        }
        addCaseProofs(pfStepVec,childVec,assumpArray,proofText);
      }
      mainProofSteps=new String[pfStepVec.size()][];
      for (int i=0; i < mainProofSteps.length; i++) {
        mainProofSteps[i]=pfStepVec.elementAt(i);
      }
      numberOfSteps=mainProofSteps.length;
    }
  }
  String[] qedStep=new String[2];
  qedStep[0]=proofLevelString;
  if (NUMBER_QED_STEP && (numberOfSteps != 0)) {
    qedStep[0]=qedStep[0] + (numberOfSteps + 1) + STEP_NUMBER_PUNCTUATION;
  }
  qedStep[0]=qedStep[0] + ""String_Node_Str"";
  qedStep[1]=proofIndentString + ""String_Node_Str"" + ((numberOfSteps > 0) ? (proofLevelString + 1) : ""String_Node_Str"");
  for (int i=2; i <= numberOfSteps; i++) {
    qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofLevelString+ i;
  }
  if ((sufficesStep == null) && needsStepNumber) {
    qedStep[1]=qedStep[1] + ""String_Node_Str"" + this.stepNumber;
  }
  boolean hasGoalDefs=(!this.goalDefinitions.isEmpty()) && (sufficesStep == null);
  boolean hasAssumeDefs=!this.assumeDefinitions.isEmpty();
  String goalAndAssumeDefs=(hasGoalDefs ? setOfStringsToList(this.goalDefinitions) : ""String_Node_Str"") + ((hasGoalDefs && hasAssumeDefs) ? ""String_Node_Str"" : ""String_Node_Str"") + (hasAssumeDefs ? setOfStringsToList(this.assumeDefinitions) : ""String_Node_Str"");
  if (sufficesOnly) {
    if (this.proof != null) {
      qedStep=concatStringArrays(new String[]{qedStep[0]},prependToStringArray(proofText,proofIndentString));
    }
 else {
      qedStep[1]=""String_Node_Str"";
    }
  }
 else {
    boolean hasDEF=false;
    if (hasGoalDefs || hasAssumeDefs) {
      hasDEF=true;
      qedStep[1]=qedStep[1] + ""String_Node_Str"" + goalAndAssumeDefs;
    }
    if (proofDef != null) {
      if (hasDEF) {
        qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofDef;
      }
 else {
        qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofDef;
      }
    }
  }
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] completeProof=new String[0];
  if (sufficesStep != null) {
    if (this.BLANK_LINE_BETWEEN_STEPS) {
      completeProof=concatStringArrays(sufficesStep,blankLine);
    }
 else {
      completeProof=sufficesStep;
    }
  }
  if (mainProofSteps != null) {
    completeProof=concatStringArrays(completeProof,mainProofSteps[0]);
    for (int i=1; i < mainProofSteps.length; i++) {
      if (this.BLANK_LINE_BETWEEN_STEPS) {
        completeProof=concatStringArrays(completeProof,concatStringArrays(blankLine,mainProofSteps[i]));
      }
 else {
        completeProof=concatStringArrays(completeProof,mainProofSteps[i]);
      }
    }
    if (this.BLANK_LINE_BETWEEN_STEPS) {
      completeProof=concatStringArrays(completeProof,blankLine);
    }
  }
  completeProof=concatStringArrays(completeProof,qedStep);
  completeProof=prependToStringArray(completeProof,StringHelper.copyString(""String_Node_Str"",this.step.getLocation().beginColumn() - 1 + proofIndent));
  try {
    int nextLineOffset=doc.getLineInformation(this.step.getTheorem().getLocation().endLine()).getOffset();
    this.doc.replace(nextLineOffset,0,stringArrayToString(completeProof) + ""String_Node_Str"");
  }
 catch (  BadLocationException e) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    e.printStackTrace();
  }
  this.windowShell.dispose();
  return;
}",0.9960563380281692
135872,"void existsAction(NodeRepresentation nodeRep){
  int idx=nodeRep.getParentIndex();
  Vector<NodeRepresentation> parentVec=nodeRep.parentVector;
  Decomposition decomp=nodeRep.decomposition;
  hasChanged=true;
  if (decomp.definedOp != null) {
    goalDefinitions.add(decomp.definedOp);
  }
  if (!nodeRep.isCreated) {
    needsStepNumber=true;
  }
  QuantifierDecomposition qdc=decomposeQuantifier(nodeRep,true);
  parentVec.remove(idx);
  for (int i=0; i < qdc.news.size(); i++) {
    parentVec.add(idx + i,qdc.news.elementAt(i));
  }
  parentVec.add(idx + qdc.news.size(),qdc.body);
  raiseWindow();
}","void existsAction(NodeRepresentation nodeRep){
  int idx=nodeRep.getParentIndex();
  Vector<NodeRepresentation> parentVec=nodeRep.parentVector;
  Decomposition decomp=nodeRep.decomposition;
  hasChanged=true;
  if (decomp.definedOp != null) {
    goalDefinitions.add(decomp.definedOp);
  }
  if (!nodeRep.isCreated && this.hasAssumes) {
    needsStepNumber=true;
  }
  QuantifierDecomposition qdc=decomposeQuantifier(nodeRep,true);
  parentVec.remove(idx);
  for (int i=0; i < qdc.news.size(); i++) {
    parentVec.add(idx + i,qdc.news.elementAt(i));
  }
  parentVec.add(idx + qdc.news.size(),qdc.body);
  raiseWindow();
}",0.9844897959183674
135873,"/** 
 * Creates the proof, which is a Suffices Only proof if sufficesONly = true, and otherwise is an and-split proof if * isAndProof is true, and a case-split proof otherwise.
 * @param nodeRep
 * @param isAndProof
 * @param sufficesOnly
 */
void makeProof(NodeRepresentation nodeRep,boolean isAndProof,boolean sufficesOnly){
  int proofIndent=PROOF_INDENT;
  String proofIndentString=StringHelper.copyString(""String_Node_Str"",proofIndent);
  String[] assumptionsText=createdAssumptions();
  String[] proofText=null;
  if (this.proof != null) {
    proofText=this.stepRep.subNodeText(this.proof).nodeText;
    proofText=prependToStringArray(proofText,proofIndentString);
    try {
      IRegion proofRegion=EditorUtil.getRegionOf(this.doc,((SyntaxTreeNode)this.proof.stn).getLocation());
      this.doc.replace(proofRegion.getOffset(),proofRegion.getLength(),""String_Node_Str"");
    }
 catch (    BadLocationException e) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  boolean addStepNumber=(stepNumber != null) && this.needsStepNumber;
  String[] sufficesStep=null;
  boolean hasSufficesStep=useSufficesButton.getSelection() && (assumptionsText.length != 0);
  if (hasSufficesStep || sufficesOnly) {
    String sufficesProof=null;
    String[] suffices=prependToStringArray(concatStringArrays(prependToStringArray(assumptionsText,""String_Node_Str""),prependToStringArray(this.goalRep.primedNodeText(),""String_Node_Str"")),proofLevelString + ""String_Node_Str"");
    if (goalDefinitions.isEmpty() && !addStepNumber) {
      if (OBVIOUS_HAS_PROOF) {
        sufficesProof=""String_Node_Str"";
      }
 else {
        sufficesProof=""String_Node_Str"";
      }
    }
 else {
      sufficesProof=""String_Node_Str"";
      if (addStepNumber) {
        sufficesProof=sufficesProof + this.stepNumber + ""String_Node_Str"";
      }
      if (!goalDefinitions.isEmpty()) {
        sufficesProof=sufficesProof + ""String_Node_Str"" + setOfStringsToList(goalDefinitions);
      }
    }
    sufficesStep=concatStringArrays(suffices,new String[]{proofIndentString + sufficesProof});
  }
  String[][] mainProofSteps=null;
  int numberOfSteps=0;
  String proofDef=null;
  if (!sufficesOnly) {
    if (isAndProof) {
      Decomposition decomp=nodeRep.decomposition;
      numberOfSteps=decomp.children.size();
      mainProofSteps=new String[numberOfSteps][];
      proofDef=decomp.definedOp;
      for (int i=0; i < numberOfSteps; i++) {
        NodeRepresentation stepGoalRep=decompositionChildToNodeRep(nodeRep,i,null,null);
        String[] goalArray=stepGoalRep.primedNodeText();
        String[] step;
        if ((sufficesStep == null)) {
          step=concatStringArrays(prependToStringArray(assumptionsText,""String_Node_Str""),prependToStringArray(goalArray,""String_Node_Str""));
        }
 else {
          step=goalArray;
        }
        step=prependToStringArray(step,proofLevelString + (i + 1) + STEP_NUMBER_PUNCTUATION+ ""String_Node_Str"");
        if (proofText != null) {
          step=concatStringArrays(step,proofText);
        }
        mainProofSteps[i]=step;
      }
    }
 else {
      Vector<String[]> pfStepVec=new Vector<String[]>();
      for (int i=0; i < nodeRep.children.size(); i++) {
        Vector<NodeRepresentation> childVec=nodeRep.children.elementAt(i);
        String[] assumpArray;
        if (!hasSufficesStep) {
          assumpArray=new String[assumptionsText.length];
          for (int j=0; j < assumptionsText.length; j++) {
            assumpArray[j]=assumptionsText[j];
          }
        }
 else {
          assumpArray=new String[0];
        }
        addCaseProofs(pfStepVec,childVec,assumpArray,proofText);
      }
      mainProofSteps=new String[pfStepVec.size()][];
      for (int i=0; i < mainProofSteps.length; i++) {
        mainProofSteps[i]=pfStepVec.elementAt(i);
      }
      numberOfSteps=mainProofSteps.length;
    }
  }
  String[] qedStep=new String[2];
  qedStep[0]=proofLevelString;
  if (NUMBER_QED_STEP && (numberOfSteps != 0)) {
    qedStep[0]=qedStep[0] + (numberOfSteps + 1) + STEP_NUMBER_PUNCTUATION;
  }
  qedStep[0]=qedStep[0] + ""String_Node_Str"";
  qedStep[1]=proofIndentString + ""String_Node_Str"" + ((numberOfSteps > 0) ? (proofLevelString + 1) : ""String_Node_Str"");
  for (int i=2; i <= numberOfSteps; i++) {
    qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofLevelString+ i;
  }
  if ((sufficesStep == null) && needsStepNumber) {
    qedStep[1]=qedStep[1] + ""String_Node_Str"" + this.stepNumber;
  }
  boolean hasGoalDefs=(!this.goalDefinitions.isEmpty()) && (sufficesStep == null);
  boolean hasAssumeDefs=!this.assumeDefinitions.isEmpty();
  String goalAndAssumeDefs=(hasGoalDefs ? setOfStringsToList(this.goalDefinitions) : ""String_Node_Str"") + ((hasGoalDefs && hasAssumeDefs) ? ""String_Node_Str"" : ""String_Node_Str"") + (hasAssumeDefs ? setOfStringsToList(this.assumeDefinitions) : ""String_Node_Str"");
  if (sufficesOnly) {
    if (this.proof != null) {
      qedStep=concatStringArrays(new String[]{qedStep[0]},prependToStringArray(proofText,proofIndentString));
    }
 else {
      qedStep[1]=""String_Node_Str"";
    }
  }
 else {
    boolean hasDEF=false;
    if (hasGoalDefs || hasAssumeDefs) {
      hasDEF=true;
      qedStep[1]=qedStep[1] + ""String_Node_Str"" + goalAndAssumeDefs;
    }
    if (proofDef != null) {
      if (hasDEF) {
        qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofDef;
      }
 else {
        qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofDef;
      }
    }
  }
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] completeProof=new String[0];
  if (sufficesStep != null) {
    if (this.BLANK_LINE_BETWEEN_STEPS) {
      completeProof=concatStringArrays(sufficesStep,blankLine);
    }
 else {
      completeProof=sufficesStep;
    }
  }
  if (mainProofSteps != null) {
    completeProof=concatStringArrays(completeProof,mainProofSteps[0]);
    for (int i=1; i < mainProofSteps.length; i++) {
      if (this.BLANK_LINE_BETWEEN_STEPS) {
        completeProof=concatStringArrays(completeProof,concatStringArrays(blankLine,mainProofSteps[i]));
      }
 else {
        completeProof=concatStringArrays(completeProof,mainProofSteps[i]);
      }
    }
    if (this.BLANK_LINE_BETWEEN_STEPS) {
      completeProof=concatStringArrays(completeProof,blankLine);
    }
  }
  completeProof=concatStringArrays(completeProof,qedStep);
  completeProof=prependToStringArray(completeProof,StringHelper.copyString(""String_Node_Str"",this.step.getLocation().beginColumn() - 1 + proofIndent));
  try {
    int nextLineOffset=doc.getLineInformation(this.step.getTheorem().getLocation().endLine()).getOffset();
    this.doc.replace(nextLineOffset,0,stringArrayToString(completeProof) + ""String_Node_Str"");
  }
 catch (  BadLocationException e) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    e.printStackTrace();
  }
  this.windowShell.dispose();
  return;
}","/** 
 * Creates the proof, which is a Suffices Only proof if sufficesONly = true, and otherwise is an and-split proof if * isAndProof is true, and a case-split proof otherwise.
 * @param nodeRep
 * @param isAndProof
 * @param sufficesOnly
 */
void makeProof(NodeRepresentation nodeRep,boolean isAndProof,boolean sufficesOnly){
  int proofIndent=PROOF_INDENT;
  String proofIndentString=StringHelper.copyString(""String_Node_Str"",proofIndent);
  String[] assumptionsText=createdAssumptions();
  String[] proofText=null;
  if (this.proof != null) {
    proofText=this.stepRep.subNodeText(this.proof).nodeText;
    proofText=prependToStringArray(proofText,proofIndentString);
    try {
      IRegion proofRegion=EditorUtil.getRegionOf(this.doc,((SyntaxTreeNode)this.proof.stn).getLocation());
      this.doc.replace(proofRegion.getOffset(),proofRegion.getLength(),""String_Node_Str"");
    }
 catch (    BadLocationException e) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  boolean addStepNumber=(stepNumber != null) && this.needsStepNumber;
  String[] sufficesStep=null;
  boolean hasSufficesStep=useSufficesButton.getSelection() && (assumptionsText.length != 0);
  if (hasSufficesStep || sufficesOnly) {
    String sufficesProof=null;
    String[] suffices=prependToStringArray(concatStringArrays(prependToStringArray(assumptionsText,""String_Node_Str""),prependToStringArray(this.goalRep.primedNodeText(),""String_Node_Str"")),proofLevelString + ""String_Node_Str"");
    if (goalDefinitions.isEmpty() && !addStepNumber) {
      if (OBVIOUS_HAS_PROOF) {
        sufficesProof=""String_Node_Str"";
      }
 else {
        sufficesProof=""String_Node_Str"";
      }
    }
 else {
      sufficesProof=""String_Node_Str"";
      if (addStepNumber) {
        sufficesProof=sufficesProof + this.stepNumber + ""String_Node_Str"";
      }
      if (!goalDefinitions.isEmpty()) {
        sufficesProof=sufficesProof + ""String_Node_Str"" + setOfStringsToList(goalDefinitions);
      }
    }
    sufficesStep=concatStringArrays(suffices,new String[]{proofIndentString + sufficesProof});
  }
  String[][] mainProofSteps=null;
  int numberOfSteps=0;
  String proofDef=null;
  if (!sufficesOnly) {
    if (isAndProof) {
      Decomposition decomp=nodeRep.decomposition;
      numberOfSteps=decomp.children.size();
      mainProofSteps=new String[numberOfSteps][];
      proofDef=decomp.definedOp;
      for (int i=0; i < numberOfSteps; i++) {
        NodeRepresentation stepGoalRep=decompositionChildToNodeRep(nodeRep,i,null,null);
        String[] goalArray=stepGoalRep.primedNodeText();
        String[] step;
        if ((sufficesStep == null || assumptionsText == null && assumptionsText.length == 0)) {
          step=concatStringArrays(prependToStringArray(assumptionsText,""String_Node_Str""),prependToStringArray(goalArray,""String_Node_Str""));
        }
 else {
          step=goalArray;
        }
        step=prependToStringArray(step,proofLevelString + (i + 1) + STEP_NUMBER_PUNCTUATION+ ""String_Node_Str"");
        if (proofText != null) {
          step=concatStringArrays(step,proofText);
        }
        mainProofSteps[i]=step;
      }
    }
 else {
      Vector<String[]> pfStepVec=new Vector<String[]>();
      for (int i=0; i < nodeRep.children.size(); i++) {
        Vector<NodeRepresentation> childVec=nodeRep.children.elementAt(i);
        String[] assumpArray;
        if (!hasSufficesStep) {
          assumpArray=new String[assumptionsText.length];
          for (int j=0; j < assumptionsText.length; j++) {
            assumpArray[j]=assumptionsText[j];
          }
        }
 else {
          assumpArray=new String[0];
        }
        addCaseProofs(pfStepVec,childVec,assumpArray,proofText);
      }
      mainProofSteps=new String[pfStepVec.size()][];
      for (int i=0; i < mainProofSteps.length; i++) {
        mainProofSteps[i]=pfStepVec.elementAt(i);
      }
      numberOfSteps=mainProofSteps.length;
    }
  }
  String[] qedStep=new String[2];
  qedStep[0]=proofLevelString;
  if (NUMBER_QED_STEP && (numberOfSteps != 0)) {
    qedStep[0]=qedStep[0] + (numberOfSteps + 1) + STEP_NUMBER_PUNCTUATION;
  }
  qedStep[0]=qedStep[0] + ""String_Node_Str"";
  qedStep[1]=proofIndentString + ""String_Node_Str"" + ((numberOfSteps > 0) ? (proofLevelString + 1) : ""String_Node_Str"");
  for (int i=2; i <= numberOfSteps; i++) {
    qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofLevelString+ i;
  }
  if ((sufficesStep == null) && needsStepNumber) {
    qedStep[1]=qedStep[1] + ""String_Node_Str"" + this.stepNumber;
  }
  boolean hasGoalDefs=(!this.goalDefinitions.isEmpty()) && (sufficesStep == null);
  boolean hasAssumeDefs=!this.assumeDefinitions.isEmpty();
  String goalAndAssumeDefs=(hasGoalDefs ? setOfStringsToList(this.goalDefinitions) : ""String_Node_Str"") + ((hasGoalDefs && hasAssumeDefs) ? ""String_Node_Str"" : ""String_Node_Str"") + (hasAssumeDefs ? setOfStringsToList(this.assumeDefinitions) : ""String_Node_Str"");
  if (sufficesOnly) {
    if (this.proof != null) {
      qedStep=concatStringArrays(new String[]{qedStep[0]},prependToStringArray(proofText,proofIndentString));
    }
 else {
      qedStep[1]=""String_Node_Str"";
    }
  }
 else {
    boolean hasDEF=false;
    if (hasGoalDefs || hasAssumeDefs) {
      hasDEF=true;
      qedStep[1]=qedStep[1] + ""String_Node_Str"" + goalAndAssumeDefs;
    }
    if (proofDef != null) {
      if (hasDEF) {
        qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofDef;
      }
 else {
        qedStep[1]=qedStep[1] + ""String_Node_Str"" + proofDef;
      }
    }
  }
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] completeProof=new String[0];
  if (sufficesStep != null) {
    if (this.BLANK_LINE_BETWEEN_STEPS) {
      completeProof=concatStringArrays(sufficesStep,blankLine);
    }
 else {
      completeProof=sufficesStep;
    }
  }
  if (mainProofSteps != null) {
    completeProof=concatStringArrays(completeProof,mainProofSteps[0]);
    for (int i=1; i < mainProofSteps.length; i++) {
      if (this.BLANK_LINE_BETWEEN_STEPS) {
        completeProof=concatStringArrays(completeProof,concatStringArrays(blankLine,mainProofSteps[i]));
      }
 else {
        completeProof=concatStringArrays(completeProof,mainProofSteps[i]);
      }
    }
    if (this.BLANK_LINE_BETWEEN_STEPS) {
      completeProof=concatStringArrays(completeProof,blankLine);
    }
  }
  completeProof=concatStringArrays(completeProof,qedStep);
  completeProof=prependToStringArray(completeProof,StringHelper.copyString(""String_Node_Str"",this.step.getLocation().beginColumn() - 1 + proofIndent));
  try {
    int nextLineOffset=doc.getLineInformation(this.step.getTheorem().getLocation().endLine()).getOffset();
    this.doc.replace(nextLineOffset,0,stringArrayToString(completeProof) + ""String_Node_Str"");
  }
 catch (  BadLocationException e) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    e.printStackTrace();
  }
  this.windowShell.dispose();
  return;
}",0.9958987413378588
135874,"/** 
 * {@inheritDoc}<p> May be replaced or extended by subclasses. </p>
 */
public ITypedRegion[] computePartitioning(int offset,int length,boolean includeZeroLengthPartitions){
  checkInitialization();
  List list=new ArrayList();
  try {
    int endOffset=offset + length;
    Position[] category=getPositions();
    TypedPosition previous=null, current=null;
    int start, end, gapOffset;
    Position gap=new Position(0);
    int startIndex=getFirstIndexEndingAfterOffset(category,offset);
    int endIndex=getFirstIndexStartingAfterOffset(category,endOffset);
    for (int i=startIndex; i < endIndex; i++) {
      current=(TypedPosition)category[i];
      gapOffset=(previous != null) ? previous.getOffset() + previous.getLength() : 0;
      gap.setOffset(gapOffset);
      gap.setLength(current.getOffset() - gapOffset);
      if ((includeZeroLengthPartitions && overlapsOrTouches(gap,offset,length)) || (gap.getLength() > 0 && gap.overlapsWith(offset,length))) {
        start=Math.max(offset,gapOffset);
        end=Math.min(endOffset,gap.getOffset() + gap.getLength());
        list.add(new TypedRegion(start,end - start,IDocument.DEFAULT_CONTENT_TYPE));
      }
      if (current.overlapsWith(offset,length)) {
        start=Math.max(offset,current.getOffset());
        end=Math.min(endOffset,current.getOffset() + current.getLength());
        list.add(new TypedRegion(start,end - start,current.getType()));
      }
      previous=current;
    }
    if (previous != null) {
      gapOffset=previous.getOffset() + previous.getLength();
      gap.setOffset(gapOffset);
      gap.setLength(fDocument.getLength() - gapOffset);
      if ((includeZeroLengthPartitions && overlapsOrTouches(gap,offset,length)) || (gap.getLength() > 0 && gap.overlapsWith(offset,length))) {
        start=Math.max(offset,gapOffset);
        end=Math.min(endOffset,fDocument.getLength());
        list.add(new TypedRegion(start,end - start,IDocument.DEFAULT_CONTENT_TYPE));
      }
    }
    if (list.isEmpty())     list.add(new TypedRegion(offset,length,IDocument.DEFAULT_CONTENT_TYPE));
  }
 catch (  BadPositionCategoryException ex) {
    clearPositionCache();
  }
catch (  RuntimeException ex) {
    clearPositionCache();
    throw ex;
  }
  TypedRegion[] result=new TypedRegion[list.size()];
  list.toArray(result);
  return result;
}","/** 
 * {@inheritDoc}<p> May be replaced or extended by subclasses. </p>
 */
public ITypedRegion[] computePartitioning(int offset,int length,boolean includeZeroLengthPartitions){
  checkInitialization();
  List list=new ArrayList();
  try {
    int endOffset=offset + length;
    Position[] category=getPositions();
    TypedPosition previous=null, current=null;
    int start, end, gapOffset;
    Position gap=new Position(0);
    int startIndex=getFirstIndexEndingAfterOffset(category,offset);
    int endIndex=getFirstIndexStartingAfterOffset(category,endOffset);
    for (int i=startIndex; i < endIndex; i++) {
      current=(TypedPosition)category[i];
      gapOffset=(previous != null) ? previous.getOffset() + previous.getLength() : 0;
      gap.setOffset(gapOffset);
      if (current.getOffset() >= gapOffset) {
        gap.setLength(current.getOffset() - gapOffset);
      }
 else {
        gap.setLength(0);
      }
      if ((includeZeroLengthPartitions && overlapsOrTouches(gap,offset,length)) || (gap.getLength() > 0 && gap.overlapsWith(offset,length))) {
        start=Math.max(offset,gapOffset);
        end=Math.min(endOffset,gap.getOffset() + gap.getLength());
        list.add(new TypedRegion(start,end - start,IDocument.DEFAULT_CONTENT_TYPE));
      }
      if (current.overlapsWith(offset,length)) {
        start=Math.max(offset,current.getOffset());
        end=Math.min(endOffset,current.getOffset() + current.getLength());
        list.add(new TypedRegion(start,end - start,current.getType()));
      }
      previous=current;
    }
    if (previous != null) {
      gapOffset=previous.getOffset() + previous.getLength();
      gap.setOffset(gapOffset);
      gap.setLength(fDocument.getLength() - gapOffset);
      if ((includeZeroLengthPartitions && overlapsOrTouches(gap,offset,length)) || (gap.getLength() > 0 && gap.overlapsWith(offset,length))) {
        start=Math.max(offset,gapOffset);
        end=Math.min(endOffset,fDocument.getLength());
        list.add(new TypedRegion(start,end - start,IDocument.DEFAULT_CONTENT_TYPE));
      }
    }
    if (list.isEmpty())     list.add(new TypedRegion(offset,length,IDocument.DEFAULT_CONTENT_TYPE));
  }
 catch (  BadPositionCategoryException ex) {
    clearPositionCache();
  }
catch (  RuntimeException ex) {
    clearPositionCache();
    throw ex;
  }
  TypedRegion[] result=new TypedRegion[list.size()];
  list.toArray(result);
  return result;
}",0.9793771043771043
135875,"@Override protected IStatus run(IProgressMonitor monitor){
  try {
    handler.realExecute(theEditor,theSelection);
  }
 catch (  ExecutionException e) {
    e.printStackTrace();
  }
  return null;
}","@Override protected IStatus run(IProgressMonitor monitor){
  return null;
}",0.5474452554744526
135876,"/** 
 * THE REAL EXECUTE METHOD The execute method is called when the user issues a DecomposeProof command.
 * @see org.eclipse.core.commands.IHandler#execute(org.eclipse.core.commands.ExecutionEvent)
 */
public Object realExecute(TLAEditor theEditor,TextSelection theSelection) throws ExecutionException {
  Activator.getDefault().logDebug(""String_Node_Str"");
  Vector<SemanticNode> assumes;
  SemanticNode goal;
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] oneline=new String[]{""String_Node_Str""};
  if (this.windowShell != null) {
    if (!this.windowShell.isDisposed()) {
      System.out.println(""String_Node_Str"");
      return null;
    }
  }
  Activator.getDefault().logDebug(""String_Node_Str"");
  boolean proceed=UIHelper.promptUserForDirtyModules();
  Activator.getDefault().logDebug(""String_Node_Str"");
  if (!proceed) {
    return null;
  }
  editor=theEditor;
  if (editor == null) {
    Activator.getDefault().logDebug(""String_Node_Str"");
    return null;
  }
  editorIFile=((FileEditorInput)editor.getEditorInput()).getFile();
  ParseResult parseResult=ResourceHelper.getValidParseResult(editorIFile);
  if (parseResult == null) {
    parseResult=new ModuleParserLauncher().parseModule(editorIFile,new NullProgressMonitor());
  }
  if (existDirtyModules()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Spec spec=Activator.getSpecManager().getSpecLoaded();
  if (spec == null || spec.getStatus() != IParseConstants.PARSED) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  if (editor == null) {
    Activator.getDefault().logDebug(""String_Node_Str"");
    return null;
  }
  editorIFile=((FileEditorInput)editor.getEditorInput()).getFile();
  if (editor.isDirty()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  hasChanged=false;
  chosenSplit=-1;
  needsStepNumber=false;
  andSplitBegin=-1;
  andSplitEnd=-1;
  assumeDefinitions=new HashSet<String>();
  goalDefinitions=new HashSet<String>();
  doc=editor.getDocumentProvider().getDocument(editor.getEditorInput());
  text=doc.get();
  selection=theSelection;
  offset=selection.getOffset();
  String moduleName=editor.getModuleName();
  moduleNode=ResourceHelper.getModuleNode(moduleName);
  Location selectedLocation=EditorUtil.getLocationAt(doc,offset,selection.getLength());
  TheoremNode[] allTheorems=moduleNode.getTheorems();
  theorem=null;
  int i=0;
  String moduleFile=moduleNode.stn.getFilename();
  while ((theorem == null) & (i < allTheorems.length)) {
    if (allTheorems[i].stn.getFilename().equals(moduleFile) && EditorUtil.lineLocationContainment(selectedLocation,allTheorems[i].stn.getLocation())) {
      theorem=allTheorems[i];
    }
    i++;
  }
  if (theorem == null) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  step=theorem;
  boolean notDone=true;
  proofLevel=-1;
  proof=step.getProof();
  while (notDone && (proof != null) && (proof instanceof NonLeafProofNode)) {
    LevelNode[] pfsteps=((NonLeafProofNode)proof).getSteps();
    LevelNode foundLevelNode=null;
    i=0;
    proofLevel=stepLevel(pfsteps[0]);
    while ((foundLevelNode == null) && (i < pfsteps.length)) {
      if (EditorUtil.lineLocationContainment(selectedLocation,pfsteps[i].stn.getLocation())) {
        foundLevelNode=pfsteps[i];
      }
      i++;
    }
    if (foundLevelNode == null) {
      notDone=false;
    }
 else     if (!(foundLevelNode instanceof TheoremNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
 else {
      step=(TheoremNode)foundLevelNode;
      proof=step.getProof();
    }
  }
  if (step.isSuffices()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  int level=this.proofLevel;
  if (level < 0) {
    level=0;
  }
  proofLevelString=""String_Node_Str"" + (level + 1) + ""String_Node_Str"";
  SyntaxTreeNode nd=(SyntaxTreeNode)step.stn;
  if (step == theorem) {
    stepNumber=null;
  }
 else {
    stepNumber=nd.getHeirs()[0].image.toString();
    if (stepNumber.indexOf('>') == stepNumber.length() - 1) {
      stepNumber=null;
    }
 else {
      i=stepNumber.indexOf('>') + 1;
      while ((i < stepNumber.length() && (Character.isLetterOrDigit(stepNumber.charAt(i)) || (stepNumber.charAt(i) == '_')))) {
        i++;
      }
      if (i < stepNumber.length()) {
        stepNumber=stepNumber.substring(0,i);
      }
    }
  }
  stepColumn=nd.getLocation().beginColumn();
  if ((proof != null) && !(proof instanceof LeafProofNode)) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  try {
    stepRep=new NodeRepresentation(doc,step);
  }
 catch (  BadLocationException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
  }
  LevelNode thm=step.getTheorem();
  if (thm instanceof AssumeProveNode) {
    hasAssumes=true;
    SemanticNode[] assump=((AssumeProveNode)thm).getAssumes();
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    int rowOfLastNew=-1;
    for (i=0; i < assump.length; i++) {
      if (assump[i] instanceof AssumeProveNode) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      assumes.add(assump[i]);
      NodeRepresentation nodeRep=stepRep.subNodeRep(assump[i],assumeReps,null,null);
      if (nodeRep.nodeType == NodeRepresentation.NEW_NODE) {
        Location loc=nodeRep.semanticNode.stn.getLocation();
        if (loc.beginLine() == loc.endLine()) {
          if (loc.beginLine() == rowOfLastNew) {
            assumeReps.elementAt(i - 1).onSameLineAsNext=true;
          }
          rowOfLastNew=loc.beginLine();
        }
 else {
          rowOfLastNew=-1;
        }
      }
 else {
        rowOfLastNew=-1;
      }
      assumeReps.add(nodeRep);
      goal=((AssumeProveNode)thm).getProve();
      if (!(goal instanceof OpApplNode)) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      goalRep=stepRep.subNodeRep(goal,null,null,null);
    }
  }
 else {
    hasAssumes=false;
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    if (!(thm instanceof OpApplNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goal=thm;
    UniqueString goalOpName=null;
    if (goal instanceof OpApplNode) {
      goalOpName=((OpApplNode)goal).getOperator().getName();
    }
    if ((goalOpName == null) || (goalOpName == ASTConstants.OP_qed) || (goalOpName == ASTConstants.OP_pfcase)|| (goalOpName == ASTConstants.OP_have)|| (goalOpName == ASTConstants.OP_pick)|| (goalOpName == ASTConstants.OP_witness)|| (goalOpName == ASTConstants.OP_suffices)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goalRep=stepRep.subNodeRep(goal,null,null,null);
  }
  editorIFile.setReadOnly(true);
  raiseWindow();
  Activator.getDefault().logDebug(""String_Node_Str"");
  return null;
}","/** 
 * THE REAL EXECUTE METHOD The execute method is called when the user issues a DecomposeProof command.
 * @see org.eclipse.core.commands.IHandler#execute(org.eclipse.core.commands.ExecutionEvent)
 */
public Object realExecute() throws ExecutionException {
  Activator.getDefault().logDebug(""String_Node_Str"");
  Vector<SemanticNode> assumes;
  SemanticNode goal;
  String[] blankLine=new String[]{""String_Node_Str""};
  String[] oneline=new String[]{""String_Node_Str""};
  if (this.windowShell != null) {
    if (!this.windowShell.isDisposed()) {
      System.out.println(""String_Node_Str"");
      return null;
    }
  }
  Activator.getDefault().logDebug(""String_Node_Str"");
  boolean proceed=UIHelper.promptUserForDirtyModules();
  Activator.getDefault().logDebug(""String_Node_Str"");
  if (!proceed) {
    return null;
  }
  if (editor == null) {
    Activator.getDefault().logDebug(""String_Node_Str"");
    return null;
  }
  editorIFile=((FileEditorInput)editor.getEditorInput()).getFile();
  ParseResult parseResult=ResourceHelper.getValidParseResult(editorIFile);
  if (parseResult == null) {
    parseResult=new ModuleParserLauncher().parseModule(editorIFile,new NullProgressMonitor());
  }
  if (existDirtyModules()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Spec spec=Activator.getSpecManager().getSpecLoaded();
  if (spec == null || spec.getStatus() != IParseConstants.PARSED) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  if (editor == null) {
    Activator.getDefault().logDebug(""String_Node_Str"");
    return null;
  }
  editorIFile=((FileEditorInput)editor.getEditorInput()).getFile();
  if (editor.isDirty()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  hasChanged=false;
  chosenSplit=-1;
  needsStepNumber=false;
  andSplitBegin=-1;
  andSplitEnd=-1;
  assumeDefinitions=new HashSet<String>();
  goalDefinitions=new HashSet<String>();
  Location selectedLocation=EditorUtil.getLocationAt(doc,offset,selection.getLength());
  TheoremNode[] allTheorems=moduleNode.getTheorems();
  theorem=null;
  int i=0;
  String moduleFile=moduleNode.stn.getFilename();
  while ((theorem == null) & (i < allTheorems.length)) {
    if (allTheorems[i].stn.getFilename().equals(moduleFile) && EditorUtil.lineLocationContainment(selectedLocation,allTheorems[i].stn.getLocation())) {
      theorem=allTheorems[i];
    }
    i++;
  }
  if (theorem == null) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  step=theorem;
  boolean notDone=true;
  proofLevel=-1;
  proof=step.getProof();
  while (notDone && (proof != null) && (proof instanceof NonLeafProofNode)) {
    LevelNode[] pfsteps=((NonLeafProofNode)proof).getSteps();
    LevelNode foundLevelNode=null;
    i=0;
    proofLevel=stepLevel(pfsteps[0]);
    while ((foundLevelNode == null) && (i < pfsteps.length)) {
      if (EditorUtil.lineLocationContainment(selectedLocation,pfsteps[i].stn.getLocation())) {
        foundLevelNode=pfsteps[i];
      }
      i++;
    }
    if (foundLevelNode == null) {
      notDone=false;
    }
 else     if (!(foundLevelNode instanceof TheoremNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
 else {
      step=(TheoremNode)foundLevelNode;
      proof=step.getProof();
    }
  }
  if (step.isSuffices()) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  int level=this.proofLevel;
  if (level < 0) {
    level=0;
  }
  proofLevelString=""String_Node_Str"" + (level + 1) + ""String_Node_Str"";
  SyntaxTreeNode nd=(SyntaxTreeNode)step.stn;
  if (step == theorem) {
    stepNumber=null;
  }
 else {
    stepNumber=nd.getHeirs()[0].image.toString();
    if (stepNumber.indexOf('>') == stepNumber.length() - 1) {
      stepNumber=null;
    }
 else {
      i=stepNumber.indexOf('>') + 1;
      while ((i < stepNumber.length() && (Character.isLetterOrDigit(stepNumber.charAt(i)) || (stepNumber.charAt(i) == '_')))) {
        i++;
      }
      if (i < stepNumber.length()) {
        stepNumber=stepNumber.substring(0,i);
      }
    }
  }
  stepColumn=nd.getLocation().beginColumn();
  if ((proof != null) && !(proof instanceof LeafProofNode)) {
    MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  try {
    stepRep=new NodeRepresentation(doc,step);
  }
 catch (  BadLocationException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
  }
  LevelNode thm=step.getTheorem();
  if (thm instanceof AssumeProveNode) {
    hasAssumes=true;
    SemanticNode[] assump=((AssumeProveNode)thm).getAssumes();
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    int rowOfLastNew=-1;
    for (i=0; i < assump.length; i++) {
      if (assump[i] instanceof AssumeProveNode) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      assumes.add(assump[i]);
      NodeRepresentation nodeRep=stepRep.subNodeRep(assump[i],assumeReps,null,null);
      if (nodeRep.nodeType == NodeRepresentation.NEW_NODE) {
        Location loc=nodeRep.semanticNode.stn.getLocation();
        if (loc.beginLine() == loc.endLine()) {
          if (loc.beginLine() == rowOfLastNew) {
            assumeReps.elementAt(i - 1).onSameLineAsNext=true;
          }
          rowOfLastNew=loc.beginLine();
        }
 else {
          rowOfLastNew=-1;
        }
      }
 else {
        rowOfLastNew=-1;
      }
      assumeReps.add(nodeRep);
      goal=((AssumeProveNode)thm).getProve();
      if (!(goal instanceof OpApplNode)) {
        MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
        return null;
      }
      goalRep=stepRep.subNodeRep(goal,null,null,null);
    }
  }
 else {
    hasAssumes=false;
    assumes=new Vector<SemanticNode>();
    assumeReps=new Vector<NodeRepresentation>();
    if (!(thm instanceof OpApplNode)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goal=thm;
    UniqueString goalOpName=null;
    if (goal instanceof OpApplNode) {
      goalOpName=((OpApplNode)goal).getOperator().getName();
    }
    if ((goalOpName == null) || (goalOpName == ASTConstants.OP_qed) || (goalOpName == ASTConstants.OP_pfcase)|| (goalOpName == ASTConstants.OP_have)|| (goalOpName == ASTConstants.OP_pick)|| (goalOpName == ASTConstants.OP_witness)|| (goalOpName == ASTConstants.OP_suffices)) {
      MessageDialog.openError(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"");
      return null;
    }
    goalRep=stepRep.subNodeRep(goal,null,null,null);
  }
  editorIFile.setReadOnly(true);
  raiseWindow();
  Activator.getDefault().logDebug(""String_Node_Str"");
  return null;
}",0.9787550744248984
135877,"/** 
 * Sent when selection occurs in the control. The default behavior is to do nothing.
 * @param e an event containing information about the selection
 */
public void widgetSelected(SelectionEvent e){
  System.out.println(""String_Node_Str"");
  parent=decomposeHandler.parent;
  decomposeHandler.location=parent.getLocation();
  parent.close();
  if (parent != null) {
    if (parent.isDisposed()) {
      System.out.println(""String_Node_Str"");
    }
 else {
      parent.dispose();
    }
    if (parent == null) {
      System.out.println(""String_Node_Str"");
    }
  }
  raiseWindow(""String_Node_Str"" + decomposeHandler.location.toString());
  exists=true;
}","/** 
 * Sent when selection occurs in the control. The default behavior is to do nothing.
 * @param e an event containing information about the selection
 */
public void widgetSelected(SelectionEvent e){
  System.out.println(""String_Node_Str"");
  windowShell=decomposeHandler.windowShell;
  decomposeHandler.location=windowShell.getLocation();
  windowShell.close();
  if (windowShell != null) {
    if (windowShell.isDisposed()) {
      System.out.println(""String_Node_Str"");
    }
 else {
      windowShell.dispose();
    }
    if (windowShell == null) {
      System.out.println(""String_Node_Str"");
    }
  }
  raiseWindow(""String_Node_Str"" + decomposeHandler.location.toString());
}",0.8878990348923533
135878,"private void raiseWindow(String windowTitle){
  Shell topshell=UIHelper.getShellProvider().getShell();
  parent=new Shell(topshell,SWT.SHELL_TRIM);
  parent.setText(windowTitle);
  Composite shell=new Composite(parent,SWT.NONE);
  GridLayout gridLayout=new GridLayout(3,false);
  shell.setLayout(gridLayout);
  Button closeButton=new Button(shell,SWT.PUSH);
  closeButton.setText(""String_Node_Str"");
  closeButton.addSelectionListener(new MyButtonHandler(this));
  new Button(shell,SWT.PUSH).setText(""String_Node_Str"");
  new Button(shell,SWT.PUSH).setText(""String_Node_Str"");
  Button button4=new Button(shell,SWT.PUSH);
  button4.setText(""String_Node_Str"");
  GridData gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  button4.setLayoutData(gridData);
  Composite comp=new Composite(shell,SWT.NONE);
  GridLayout gl=new GridLayout(1,false);
  gl.marginWidth=0;
  gl.marginHeight=0;
  comp.setLayout(gl);
  Label l1=new Label(comp,SWT.NONE);
  l1.setText(""String_Node_Str"");
  Composite compInner=new Composite(comp,SWT.None);
  GridLayout gin=new GridLayout(2,false);
  gin.marginWidth=0;
  gin.marginHeight=0;
  compInner.setLayout(gin);
  gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  compInner.setLayoutData(gridData);
  Button button7=new Button(compInner,SWT.PUSH);
  button7.setText(""String_Node_Str"");
  gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  button7.setLayoutData(gridData);
  Label l2=new Label(compInner,SWT.NONE);
  l2.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  l2.setLayoutData(gridData);
  gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  comp.setLayoutData(gridData);
  Label l3=new Label(shell,SWT.NONE);
  l3.setText(""String_Node_Str"");
  gridData=new GridData();
  gridData.verticalAlignment=SWT.FILL;
  l3.setLayoutData(gridData);
  shell.pack();
  Point shellSize=shell.getSize();
  ;
  parent.setSize(shellSize.x + 30,shellSize.y + 30);
  System.out.println(""String_Node_Str"" + parent.getLocation().toString());
  System.out.println(""String_Node_Str"" + parent.getSize().toString());
  System.out.println(""String_Node_Str"" + topshell.getLocation().toString());
  System.out.println(""String_Node_Str"" + topshell.getSize().toString());
  parent.update();
  if (this.location != null) {
    parent.setLocation(this.location);
  }
  parent.open();
  System.out.println(""String_Node_Str"");
}","private void raiseWindow(String windowTitle){
  Shell topshell=UIHelper.getShellProvider().getShell();
  windowShell=new Shell(topshell,SWT.SHELL_TRIM);
  windowShell.setText(windowTitle);
  Composite shell=new Composite(windowShell,SWT.NONE);
  GridLayout gridLayout=new GridLayout(3,false);
  shell.setLayout(gridLayout);
  Button closeButton=new Button(shell,SWT.PUSH);
  setupButton(closeButton,MENU,""String_Node_Str"");
  new Button(shell,SWT.PUSH).setText(""String_Node_Str"");
  new Button(shell,SWT.PUSH).setText(""String_Node_Str"");
  Button button4=new Button(shell,SWT.PUSH);
  button4.setText(""String_Node_Str"");
  GridData gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  button4.setLayoutData(gridData);
  Composite comp=new Composite(shell,SWT.NONE);
  GridLayout gl=new GridLayout(1,false);
  gl.marginWidth=0;
  gl.marginHeight=0;
  comp.setLayout(gl);
  Label l1=new Label(comp,SWT.NONE);
  l1.setText(""String_Node_Str"");
  Composite compInner=new Composite(comp,SWT.None);
  GridLayout gin=new GridLayout(2,false);
  gin.marginWidth=0;
  gin.marginHeight=0;
  compInner.setLayout(gin);
  gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  compInner.setLayoutData(gridData);
  Button button7=new Button(compInner,SWT.PUSH);
  button7.setText(""String_Node_Str"");
  gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  button7.setLayoutData(gridData);
  Label l2=new Label(compInner,SWT.NONE);
  l2.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  l2.setLayoutData(gridData);
  gridData=new GridData();
  gridData.verticalAlignment=SWT.TOP;
  comp.setLayoutData(gridData);
  Label l3=new Label(shell,SWT.NONE);
  l3.setText(""String_Node_Str"");
  gridData=new GridData();
  gridData.verticalAlignment=SWT.FILL;
  l3.setLayoutData(gridData);
  shell.pack();
  Point shellSize=shell.getSize();
  ;
  windowShell.setSize(shellSize.x + 30,shellSize.y + 30);
  System.out.println(""String_Node_Str"" + windowShell.getLocation().toString());
  System.out.println(""String_Node_Str"" + windowShell.getSize().toString());
  System.out.println(""String_Node_Str"" + topshell.getLocation().toString());
  System.out.println(""String_Node_Str"" + topshell.getSize().toString());
  windowShell.update();
  if (this.location != null) {
    windowShell.setLocation(this.location);
  }
  windowShell.open();
  System.out.println(""String_Node_Str"");
}",0.9443432503541792
135879,"/** 
 * Constructs and returns the command to launch the prover.
 * @return
 */
private String[] constructCommand(){
  List<String> command=new ArrayList<String>();
  command.add(tlapmPath.toOSString());
  if (toolboxMode) {
    command.add(""String_Node_Str"");
    if (nodeToProve instanceof ModuleNode) {
      command.add(""String_Node_Str"");
      command.add(""String_Node_Str"");
    }
 else {
      int beginLine=getBeginLine(nodeToProve);
      int endLine=getEndLine(nodeToProve);
      command.add(""String_Node_Str"" + beginLine);
      command.add(""String_Node_Str"" + endLine);
    }
  }
  ProverHelper.setThreadsOption(command);
  ProverHelper.setSolverOption(command);
  ProverHelper.setSafeFPOption(command);
  if (checkStatus) {
    command.add(""String_Node_Str"");
  }
  if (options != null) {
    for (int i=0; i < options.length; i++) {
      command.add(options[i]);
    }
  }
  command.add(module.getLocation().toOSString());
  return (String[])command.toArray(new String[command.size()]);
}","/** 
 * Constructs and returns the command to launch the prover.
 * @return
 */
private String[] constructCommand(){
  List<String> command=new ArrayList<String>();
  command.add(tlapmPath.toOSString());
  if (toolboxMode) {
    command.add(""String_Node_Str"");
    if (nodeToProve instanceof ModuleNode) {
      command.add(""String_Node_Str"");
      command.add(""String_Node_Str"");
    }
 else {
      int beginLine=getBeginLine(nodeToProve);
      int endLine=getEndLine(nodeToProve);
      command.add(""String_Node_Str"" + beginLine);
      command.add(""String_Node_Str"" + endLine);
    }
  }
  ProverHelper.setThreadsOption(command);
  ProverHelper.setSolverOption(command);
  ProverHelper.setSafeFPOption(command);
  if (checkStatus) {
    command.add(""String_Node_Str"");
  }
  if (options != null) {
    for (int i=0; i < options.length; i++) {
      command.add(options[i]);
    }
  }
  command.add(module.getLocation().toOSString());
  String[] pathList=Activator.getSpecManager().getSpecLoaded().getTLALibraryPath();
  return (String[])command.toArray(new String[command.size()]);
}",0.938872970391595
135880,"public boolean visit(IResource resource) throws CoreException {
  if (!resource.exists() || !new File(resource.getLocation().toOSString()).exists()) {
    return false;
  }
  if (IResource.PROJECT == resource.getType()) {
    return true;
  }
 else   if (IResource.FILE == resource.getType() && ResourceHelper.isModule(resource)) {
    final IPath fullPath=resource.getFullPath();
    final IDocument document=getDocument(fullPath,LocationKind.NORMALIZE);
    final FindReplaceDocumentAdapter searchAdapter=new FindReplaceDocumentAdapter(document);
    try {
      IRegion matchRegion=searchAdapter.find(0,PCAL_ALGORITHM_DEFINITION,true,true,false,false);
      if (matchRegion == null) {
        matchRegion=searchAdapter.find(0,PCAL_FAIR_ALGORITHM_DEFINITION,true,true,false,false);
      }
      final QualifiedName key=new QualifiedName(Activator.PLUGIN_ID,IPreferenceConstants.CONTAINS_PCAL_ALGORITHM);
      if (matchRegion != null) {
        resource.setSessionProperty(key,Boolean.TRUE);
      }
 else {
        resource.setSessionProperty(key,null);
      }
    }
 catch (    BadLocationException e) {
      throw new CoreException(new Status(Status.ERROR,Activator.PLUGIN_ID,""String_Node_Str"",e));
    }
 finally {
      final ITextFileBufferManager bufferManager=ITextFileBufferManager.DEFAULT;
      bufferManager.disconnect(fullPath,LocationKind.NORMALIZE,new NullProgressMonitor());
    }
  }
  return false;
}","public boolean visit(IResource resource) throws CoreException {
  if (!resource.exists() || !new File(resource.getLocation().toOSString()).exists()) {
    return false;
  }
  if (IResource.PROJECT == resource.getType()) {
    return true;
  }
 else   if (IResource.FILE == resource.getType() && ResourceHelper.isModule(resource)) {
    final IPath fullPath=resource.getFullPath();
    final IDocument document=getDocument(fullPath,LocationKind.NORMALIZE);
    final FindReplaceDocumentAdapter searchAdapter=new FindReplaceDocumentAdapter(document);
    try {
      IRegion matchRegion=null;
      if (document.getLength() != 0) {
        matchRegion=searchAdapter.find(0,PCAL_ALGORITHM_DEFINITION,true,true,false,false);
      }
 else {
        Activator.getDefault().logError(""String_Node_Str"");
      }
      if (matchRegion == null) {
        matchRegion=searchAdapter.find(0,PCAL_FAIR_ALGORITHM_DEFINITION,true,true,false,false);
      }
      final QualifiedName key=new QualifiedName(Activator.PLUGIN_ID,IPreferenceConstants.CONTAINS_PCAL_ALGORITHM);
      if (matchRegion != null) {
        resource.setSessionProperty(key,Boolean.TRUE);
      }
 else {
        resource.setSessionProperty(key,null);
      }
    }
 catch (    BadLocationException e) {
      throw new CoreException(new Status(Status.ERROR,Activator.PLUGIN_ID,""String_Node_Str"",e));
    }
 finally {
      final ITextFileBufferManager bufferManager=ITextFileBufferManager.DEFAULT;
      bufferManager.disconnect(fullPath,LocationKind.NORMALIZE,new NullProgressMonitor());
    }
  }
  return false;
}",0.9502836169502836
135881,"public boolean visit(IResource resource) throws CoreException {
  if (!resource.exists() || !new File(resource.getLocation().toOSString()).exists()) {
    return false;
  }
  if (IResource.PROJECT == resource.getType()) {
    return true;
  }
 else   if (IResource.FILE == resource.getType() && ResourceHelper.isModule(resource)) {
    final IDocument document=getDocument(resource.getFullPath(),LocationKind.NORMALIZE);
    final FindReplaceDocumentAdapter searchAdapter=new FindReplaceDocumentAdapter(document);
    try {
      IRegion matchRegion=searchAdapter.find(0,PCAL_ALGORITHM_DEFINITION,true,true,false,false);
      if (matchRegion == null) {
        matchRegion=searchAdapter.find(0,PCAL_FAIR_ALGORITHM_DEFINITION,true,true,false,false);
      }
      final QualifiedName key=new QualifiedName(Activator.PLUGIN_ID,IPreferenceConstants.CONTAINS_PCAL_ALGORITHM);
      if (matchRegion != null) {
        resource.setSessionProperty(key,Boolean.TRUE);
      }
 else {
        resource.setSessionProperty(key,null);
      }
    }
 catch (    BadLocationException e) {
      throw new CoreException(new Status(Status.ERROR,Activator.PLUGIN_ID,""String_Node_Str"",e));
    }
  }
  return false;
}","public boolean visit(IResource resource) throws CoreException {
  if (!resource.exists() || !new File(resource.getLocation().toOSString()).exists()) {
    return false;
  }
  if (IResource.PROJECT == resource.getType()) {
    return true;
  }
 else   if (IResource.FILE == resource.getType() && ResourceHelper.isModule(resource)) {
    final IPath fullPath=resource.getFullPath();
    final IDocument document=getDocument(fullPath,LocationKind.NORMALIZE);
    final FindReplaceDocumentAdapter searchAdapter=new FindReplaceDocumentAdapter(document);
    try {
      IRegion matchRegion=searchAdapter.find(0,PCAL_ALGORITHM_DEFINITION,true,true,false,false);
      if (matchRegion == null) {
        matchRegion=searchAdapter.find(0,PCAL_FAIR_ALGORITHM_DEFINITION,true,true,false,false);
      }
      final QualifiedName key=new QualifiedName(Activator.PLUGIN_ID,IPreferenceConstants.CONTAINS_PCAL_ALGORITHM);
      if (matchRegion != null) {
        resource.setSessionProperty(key,Boolean.TRUE);
      }
 else {
        resource.setSessionProperty(key,null);
      }
    }
 catch (    BadLocationException e) {
      throw new CoreException(new Status(Status.ERROR,Activator.PLUGIN_ID,""String_Node_Str"",e));
    }
 finally {
      final ITextFileBufferManager bufferManager=ITextFileBufferManager.DEFAULT;
      bufferManager.disconnect(fullPath,LocationKind.NORMALIZE,new NullProgressMonitor());
    }
  }
  return false;
}",0.9032012195121952
135882,"/** 
 * retrieves a new buffered file output stream
 * @param name
 * @return
 */
public static OutputStream newBFOS(String name){
  File file=new File(name);
  if (file != null && file.exists()) {
    try {
      FileOutputStream fos=new FileOutputStream(file);
      return fos;
    }
 catch (    FileNotFoundException e) {
      ToolIO.out.println(""String_Node_Str"");
    }
  }
  return null;
}","/** 
 * retrieves a new buffered file output stream
 * @param name
 * @return
 */
public static OutputStream newBFOS(String name){
  File file=new File(name);
  if (file != null) {
    try {
      FileOutputStream fos=new FileOutputStream(file);
      return fos;
    }
 catch (    FileNotFoundException e) {
      ToolIO.out.println(""String_Node_Str"" + name);
    }
  }
  return null;
}",0.9693877551020408
135883,"/** 
 * Returns true iff  this node and otherNode are both OpDefOrDeclNode objects or both ThmOrAssumpDefNode objects and have the same originallyDefinedInModule field.  Added by LL on 31 Oct 2012.
 * @param otherNode
 * @return
 */
public final boolean sameOriginallyDefinedInModule(SymbolNode otherNode){
  if (this.getClass() == otherNode.getClass()) {
    if (this instanceof OpDefOrDeclNode) {
      return ((OpDefOrDeclNode)this).originallyDefinedInModule == ((OpDefOrDeclNode)otherNode).originallyDefinedInModule;
    }
    if (this instanceof ThmOrAssumpDefNode) {
      return ((ThmOrAssumpDefNode)this).getOriginallyDefinedInModuleNode() == ((ThmOrAssumpDefNode)otherNode).getOriginallyDefinedInModuleNode();
    }
  }
  return false;
}","/** 
 * Returns true iff this node and otherNode are both OpDefOrDeclNode objects or both ThmOrAssumpDefNode objects and have the same originallyDefinedInModule field.  Added by LL on 31 Oct 2012.  Corrected by LL on 1 Nov 2012 by (a) using the originallyDefinedInModule for the source definitions (returned by getSource()), and by adding requirement  that their module of origin has no parameters.  This method is used to check that two instantiations of a definition are the same.  They may not be if the two instantiations of their module have different substitutions for parameters.  To check that the substitutions are the same would be difficult, so we require that the module has no parameters.  This covers the common case when the definitions come from a standard module.
 * @param otherNode
 * @return
 */
public final boolean sameOriginallyDefinedInModule(SymbolNode otherNode){
  if (this.getClass() == otherNode.getClass()) {
    ModuleNode thisModule=null;
    if (this instanceof OpDefNode) {
      OpDefNode thisSrc=((OpDefNode)this).getSource();
      if (thisSrc != ((OpDefNode)otherNode).getSource()) {
        return false;
      }
      thisModule=((OpDefNode)thisSrc).getOriginallyDefinedInModuleNode();
    }
 else     if (this instanceof ThmOrAssumpDefNode) {
      ThmOrAssumpDefNode thisSrc=((ThmOrAssumpDefNode)this).getSource();
      if (thisSrc != ((ThmOrAssumpDefNode)otherNode).getSource()) {
        return false;
      }
      thisModule=((ThmOrAssumpDefNode)thisSrc).getOriginallyDefinedInModuleNode();
    }
 else {
      return false;
    }
    return (thisModule == null) || ((thisModule.getConstantDecls().length == 0) && (thisModule.getVariableDecls().length == 0));
  }
  return false;
}",0.370250606305578
135884,"/** 
 * The following was used for debugging.  It might be useful again, so I'm   keeping it here in as a comment.                                         
 */
public final boolean levelCheck(int itr){
  if (this.levelChecked >= itr)   return this.levelCorrect;
  this.levelChecked=itr;
  this.levelCorrect=true;
  for (int i=0; i < this.operands.length; i++) {
    if (this.operands[i] != null && !this.operands[i].levelCheck(itr)) {
      this.levelCorrect=false;
    }
  }
  for (int i=0; i < this.ranges.length; i++) {
    if (this.ranges[i] != null && !this.ranges[i].levelCheck(itr)) {
      this.levelCorrect=false;
    }
  }
  if (this.operator instanceof OpDefNode) {
    OpDefNode opDef=(OpDefNode)this.operator;
    boolean opDefLevelCheck=opDef.levelCheck(itr);
    for (int i=0; i < this.operands.length; i++) {
      ExprOrOpArgNode opd=this.operands[i];
      if (opd != null) {
        if (opd.getLevel() > opDef.getMaxLevel(i)) {
          if (opDefLevelCheck && opd.levelCheck(itr)) {
            errors.addError(this.stn.getLocation(),""String_Node_Str"" + opDef.getName() + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          this.levelCorrect=false;
        }
        if (opd instanceof OpArgNode && ((OpArgNode)opd).getOp() instanceof OpDefNode) {
          OpDefNode opdDef=(OpDefNode)((OpArgNode)opd).getOp();
          boolean opdDefLevelCheck=opdDef.levelCheck(itr);
          int alen=opdDef.getArity();
          for (int j=0; j < alen; j++) {
            if (opdDef.getMaxLevel(j) < opDef.getMinMaxLevel(i,j)) {
              if (opDefLevelCheck && opd.levelCheck(itr)) {
                errors.addError(this.stn.getLocation(),""String_Node_Str"" + opDef.getName() + ""String_Node_Str""+ ""String_Node_Str""+ (j + 1)+ ""String_Node_Str""+ (i + 1)+ ""String_Node_Str""+ opDef.getMinMaxLevel(i,j)+ ""String_Node_Str"");
              }
              this.levelCorrect=false;
            }
          }
          for (int j=0; j < this.operands.length; j++) {
            for (int k=0; k < alen; k++) {
              if (opDef.getOpLevelCond(i,j,k) && this.operands[j].getLevel() > opdDef.getMaxLevel(k)) {
                if (opd.levelCheck(itr) && this.operands[j].levelCheck(itr)) {
                  errors.addError(this.stn.getLocation(),""String_Node_Str"" + opDef.getName() + ""String_Node_Str""+ (j + 1)+ ""String_Node_Str""+ ""String_Node_Str"");
                }
                this.levelCorrect=false;
              }
            }
          }
        }
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      ExprNode range=this.ranges[i];
      if (range != null) {
        boolean rangeLevelCheck=range.levelCheck(itr);
        if (range.getLevel() > ActionLevel) {
          if (rangeLevelCheck) {
            errors.addError(this.stn.getLocation(),""String_Node_Str"" + opDef.getName() + ""String_Node_Str""+ boundedBoundSymbols[i][0]+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          this.levelCorrect=false;
        }
      }
    }
    this.level=opDef.getLevel();
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null && opDef.getWeight(i) == 1) {
        this.level=Math.max(this.level,this.operands[i].getLevel());
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      this.level=Math.max(this.level,this.ranges[i].getLevel());
    }
    this.levelParams.addAll(opDef.getLevelParams());
    this.allParams.addAll(opDef.getAllParams());
    this.nonLeibnizParams.addAll(opDef.getNonLeibnizParams());
    int ar=opDef.getArity();
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null && opDef.getWeight(i) == 1) {
        this.levelParams.addAll(this.operands[i].getLevelParams());
      }
      ;
      if (this.operands[i] != null) {
        this.allParams.addAll(this.operands[i].getAllParams());
        this.nonLeibnizParams.addAll(this.operands[i].getNonLeibnizParams());
      }
      ;
      int ii=i;
      if (ar == -1) {
        ii=0;
      }
      ;
      if (!opDef.isLeibnizArg[ii]) {
        this.nonLeibnizParams.addAll(this.operands[i].getAllParams());
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      this.levelParams.addAll(this.ranges[i].getLevelParams());
      this.allParams.addAll(this.ranges[i].getAllParams());
      this.nonLeibnizParams.addAll(this.ranges[i].getNonLeibnizParams());
    }
    HashSet allBoundSymbols=new HashSet();
    if (this.unboundedBoundSymbols != null) {
      for (int i=0; i < this.unboundedBoundSymbols.length; i++) {
        allBoundSymbols.add(this.unboundedBoundSymbols[i]);
      }
    }
    ;
    if (this.boundedBoundSymbols != null) {
      for (int i=0; i < this.boundedBoundSymbols.length; i++) {
        if (this.boundedBoundSymbols[i] != null) {
          for (int j=0; j < this.boundedBoundSymbols[i].length; j++) {
            allBoundSymbols.add(this.boundedBoundSymbols[i][j]);
          }
        }
      }
    }
    ;
    Iterator absIter=allBoundSymbols.iterator();
    while (absIter.hasNext()) {
      Object nextBoundSymbol=absIter.next();
      this.levelParams.remove(nextBoundSymbol);
      this.allParams.remove(nextBoundSymbol);
      this.nonLeibnizParams.remove(nextBoundSymbol);
    }
    ;
    this.levelConstraints.putAll(opDef.getLevelConstraints());
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null) {
        if (allBoundSymbols.size() == 0) {
          this.levelConstraints.putAll(this.operands[i].getLevelConstraints());
        }
 else {
          SetOfLevelConstraints lcons=this.operands[i].getLevelConstraints();
          Iterator iter=lcons.keySet().iterator();
          while (iter.hasNext()) {
            SymbolNode param=(SymbolNode)iter.next();
            if (!allBoundSymbols.contains(param)) {
              this.levelConstraints.put(param,lcons.get(param));
            }
          }
        }
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      this.levelConstraints.putAll(this.ranges[i].getLevelConstraints());
    }
    for (int i=0; i < this.operands.length; i++) {
      Integer mlevel=new Integer(opDef.getMaxLevel(i));
      if (this.operands[i] != null) {
        Iterator iter=this.operands[i].getLevelParams().iterator();
        while (iter.hasNext()) {
          this.levelConstraints.put(iter.next(),mlevel);
        }
      }
    }
    for (int i=0; i < this.operands.length; i++) {
      ExprOrOpArgNode opdi=this.operands[i];
      if (opdi != null && opdi instanceof OpArgNode && ((OpArgNode)opdi).getOp() instanceof OpDefNode) {
        OpDefNode argDef=(OpDefNode)((OpArgNode)opdi).getOp();
        argDef.levelCheck(itr);
        int alen=argDef.getArity();
        for (int j=0; j < this.operands.length; j++) {
          for (int k=0; k < alen; k++) {
            if (opDef.getOpLevelCond(i,j,k)) {
              Integer mlevel=new Integer(argDef.getMaxLevel(k));
              Iterator iter=this.operands[j].getLevelParams().iterator();
              while (iter.hasNext()) {
                this.levelConstraints.put(iter.next(),mlevel);
              }
            }
          }
        }
        ;
        if (!argDef.isLeibniz) {
          for (int j=0; j < this.operands.length; j++) {
            for (int k=0; k < alen; k++) {
              if (opDef.getOpLevelCond(i,j,k) && !argDef.isLeibnizArg[k]) {
                this.nonLeibnizParams.addAll(this.operands[j].getAllParams());
              }
            }
          }
          ;
        }
        ;
      }
    }
    HashSet alpSet=opDef.getArgLevelParams();
    Iterator iter=alpSet.iterator();
    while (iter.hasNext()) {
      ArgLevelParam alp=(ArgLevelParam)iter.next();
      ExprOrOpArgNode arg=this.getArg(alp.op);
      if (arg != null && arg instanceof OpArgNode && ((OpArgNode)arg).getOp() instanceof OpDefNode) {
        OpDefNode argDef=(OpDefNode)((OpArgNode)arg).getOp();
        argDef.levelCheck(itr);
        Integer mlevel=new Integer(argDef.getMaxLevel(alp.i));
        this.levelConstraints.put(alp.param,mlevel);
      }
    }
    this.argLevelConstraints.putAll(opDef.getArgLevelConstraints());
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null) {
        this.argLevelConstraints.putAll(this.operands[i].getArgLevelConstraints());
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      this.argLevelConstraints.putAll(this.ranges[i].getArgLevelConstraints());
    }
    for (int i=0; i < this.operands.length; i++) {
      ExprOrOpArgNode opdi=this.operands[i];
      if (opdi != null && opdi instanceof OpArgNode && ((OpArgNode)opdi).getOp().isParam()) {
        SymbolNode opArg=((OpArgNode)opdi).getOp();
        int alen=opArg.getArity();
        for (int j=0; j < alen; j++) {
          ParamAndPosition pap=new ParamAndPosition(opArg,j);
          Integer mlevel=new Integer(opDef.getMinMaxLevel(i,j));
          this.argLevelConstraints.put(pap,mlevel);
        }
        for (int j=0; j < this.operands.length; j++) {
          for (int k=0; k < alen; k++) {
            if (opDef.getOpLevelCond(i,j,k)) {
              ParamAndPosition pap=new ParamAndPosition(opArg,k);
              Integer mlevel=new Integer(this.operands[j].getLevel());
              this.argLevelConstraints.put(pap,mlevel);
            }
          }
        }
      }
    }
    iter=alpSet.iterator();
    while (iter.hasNext()) {
      ArgLevelParam alp=(ArgLevelParam)iter.next();
      ExprOrOpArgNode arg=this.getArg(alp.op);
      if (arg != null) {
        arg.levelCheck(itr);
        ParamAndPosition pap=new ParamAndPosition(alp.op,alp.i);
        this.argLevelConstraints.put(pap,new Integer(arg.getLevel()));
      }
    }
    this.argLevelParams=new HashSet();
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null) {
        if (allBoundSymbols.size() == 0) {
          this.argLevelParams.addAll(this.operands[i].getArgLevelParams());
        }
 else {
          Iterator alpiter=this.operands[i].getArgLevelParams().iterator();
          while (alpiter.hasNext()) {
            ArgLevelParam alp=(ArgLevelParam)alpiter.next();
            if (!allBoundSymbols.contains(alp.param)) {
              this.argLevelParams.add(alp);
            }
          }
          ;
        }
      }
    }
    ;
    for (int i=0; i < this.ranges.length; i++) {
      this.argLevelParams.addAll(this.ranges[i].getArgLevelParams());
    }
    ;
    iter=alpSet.iterator();
    while (iter.hasNext()) {
      ArgLevelParam alp=(ArgLevelParam)iter.next();
      ExprOrOpArgNode arg=this.getArg(alp.op);
      if (arg == null) {
        arg=this.getArg(alp.param);
        if (arg == null) {
          this.argLevelParams.add(alp);
        }
 else {
          arg.levelCheck(itr);
          Iterator iter1=arg.getLevelParams().iterator();
          while (iter1.hasNext()) {
            SymbolNode param=(SymbolNode)iter1.next();
            this.argLevelParams.add(new ArgLevelParam(alp.op,alp.i,param));
          }
        }
      }
 else {
        if (arg instanceof OpArgNode && ((OpArgNode)arg).getOp().isParam()) {
          SymbolNode argOp=((OpArgNode)arg).getOp();
          this.argLevelParams.add(new ArgLevelParam(argOp,alp.i,alp.param));
        }
      }
    }
    for (int i=0; i < this.operands.length; i++) {
      ExprOrOpArgNode opdi=this.operands[i];
      if (opdi != null && opdi instanceof OpArgNode && ((OpArgNode)opdi).getOp().isParam()) {
        SymbolNode opArg=((OpArgNode)opdi).getOp();
        int alen=opArg.getArity();
        for (int j=0; j < this.operands.length; j++) {
          for (int k=0; k < alen; k++) {
            if (opDef.getOpLevelCond(i,j,k)) {
              Iterator iter1=this.operands[j].getLevelParams().iterator();
              while (iter1.hasNext()) {
                SymbolNode param=(SymbolNode)iter1.next();
                this.argLevelParams.add(new ArgLevelParam(opArg,k,param));
              }
            }
          }
        }
      }
    }
  }
 else {
    this.operator.levelCheck(itr);
    this.level=this.operator.getLevel();
    for (int i=0; i < this.operands.length; i++) {
      this.operands[i].levelCheck(itr);
      this.level=Math.max(this.level,this.operands[i].getLevel());
    }
    this.levelParams=new HashSet();
    this.levelParams.add(this.operator);
    this.allParams.add(this.operator);
    for (int i=0; i < this.operands.length; i++) {
      this.levelParams.addAll(this.operands[i].getLevelParams());
      this.allParams.addAll(this.operands[i].getAllParams());
      this.nonLeibnizParams.addAll(this.operands[i].getNonLeibnizParams());
    }
    this.levelConstraints=new SetOfLevelConstraints();
    for (int i=0; i < this.operands.length; i++) {
      this.levelConstraints.putAll(this.operands[i].getLevelConstraints());
    }
    this.argLevelConstraints=new SetOfArgLevelConstraints();
    for (int i=0; i < this.operands.length; i++) {
      this.argLevelConstraints.put(this.operator,i,this.operands[i].getLevel());
      this.argLevelConstraints.putAll(this.operands[i].getArgLevelConstraints());
    }
    this.argLevelParams=new HashSet();
    for (int i=0; i < this.operands.length; i++) {
      HashSet lpSet=this.operands[i].getLevelParams();
      Iterator iter=lpSet.iterator();
      while (iter.hasNext()) {
        SymbolNode param=(SymbolNode)iter.next();
        this.argLevelParams.add(new ArgLevelParam(this.operator,i,param));
      }
      ;
      this.argLevelParams.addAll(this.operands[i].getArgLevelParams());
    }
    ;
  }
  ;
  String opName=this.operator.getName().toString();
  if (opName.equals(""String_Node_Str"")) {
    ExprNode arg=(ExprNode)this.getArgs()[0];
    if ((arg.getLevel() == ActionLevel) && (arg.getKind() == OpApplKind)) {
      if (!((OpApplNode)arg).operator.getName().toString().equals(""String_Node_Str"")) {
        errors.addError(stn.getLocation(),""String_Node_Str"");
      }
    }
  }
  ;
  if (opName.equals(""String_Node_Str"")) {
    ExprNode arg=(ExprNode)this.getArgs()[0];
    if ((arg.getLevel() == ActionLevel) && (arg.getKind() == OpApplKind)) {
      if (!((OpApplNode)arg).operator.getName().toString().equals(""String_Node_Str"")) {
        errors.addError(stn.getLocation(),""String_Node_Str"");
      }
    }
  }
  ;
  if (opName.equals(""String_Node_Str"") || opName.equals(""String_Node_Str"")) {
    if ((this.getArgs()[0].getLevel() == ActionLevel) || (this.getArgs()[1].getLevel() == ActionLevel)) {
      errors.addError(stn.getLocation(),""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  ;
  if ((this.level == TemporalLevel) && (opName.equals(""String_Node_Str"") || opName.equals(""String_Node_Str""))) {
    for (int i=0; i < this.ranges.length; i++) {
      if (this.ranges[i].getLevel() == ActionLevel) {
        errors.addError(this.ranges[i].stn.getLocation(),""String_Node_Str"");
      }
    }
  }
  return this.levelCorrect;
}","/** 
 * The following was used for debugging.  It might be useful again, so I'm   keeping it here in as a comment.                                         
 */
public final boolean levelCheck(int itr){
  if (this.levelChecked >= itr)   return this.levelCorrect;
  this.levelChecked=itr;
  this.levelCorrect=true;
  for (int i=0; i < this.operands.length; i++) {
    if (this.operands[i] != null && !this.operands[i].levelCheck(itr)) {
      this.levelCorrect=false;
    }
  }
  for (int i=0; i < this.ranges.length; i++) {
    if (this.ranges[i] != null && !this.ranges[i].levelCheck(itr)) {
      this.levelCorrect=false;
    }
  }
  if (this.operator instanceof AnyDefNode) {
    AnyDefNode opDef=(AnyDefNode)this.operator;
    boolean opDefLevelCheck=opDef.levelCheck(itr);
    for (int i=0; i < this.operands.length; i++) {
      ExprOrOpArgNode opd=this.operands[i];
      if (opd != null) {
        if (opd.getLevel() > opDef.getMaxLevel(i)) {
          if (opDefLevelCheck && opd.levelCheck(itr)) {
            errors.addError(this.stn.getLocation(),""String_Node_Str"" + opDef.getName() + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          this.levelCorrect=false;
        }
        if (opd instanceof OpArgNode && ((OpArgNode)opd).getOp() instanceof AnyDefNode) {
          AnyDefNode opdDef=(AnyDefNode)((OpArgNode)opd).getOp();
          boolean opdDefLevelCheck=opdDef.levelCheck(itr);
          int alen=opdDef.getArity();
          for (int j=0; j < alen; j++) {
            if (opdDef.getMaxLevel(j) < opDef.getMinMaxLevel(i,j)) {
              if (opDefLevelCheck && opd.levelCheck(itr)) {
                errors.addError(this.stn.getLocation(),""String_Node_Str"" + opDef.getName() + ""String_Node_Str""+ ""String_Node_Str""+ (j + 1)+ ""String_Node_Str""+ (i + 1)+ ""String_Node_Str""+ opDef.getMinMaxLevel(i,j)+ ""String_Node_Str"");
              }
              this.levelCorrect=false;
            }
          }
          for (int j=0; j < this.operands.length; j++) {
            for (int k=0; k < alen; k++) {
              if (opDef.getOpLevelCond(i,j,k) && this.operands[j].getLevel() > opdDef.getMaxLevel(k)) {
                if (opd.levelCheck(itr) && this.operands[j].levelCheck(itr)) {
                  errors.addError(this.stn.getLocation(),""String_Node_Str"" + opDef.getName() + ""String_Node_Str""+ (j + 1)+ ""String_Node_Str""+ ""String_Node_Str"");
                }
                this.levelCorrect=false;
              }
            }
          }
        }
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      ExprNode range=this.ranges[i];
      if (range != null) {
        boolean rangeLevelCheck=range.levelCheck(itr);
        if (range.getLevel() > ActionLevel) {
          if (rangeLevelCheck) {
            errors.addError(this.stn.getLocation(),""String_Node_Str"" + opDef.getName() + ""String_Node_Str""+ boundedBoundSymbols[i][0]+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          this.levelCorrect=false;
        }
      }
    }
    this.level=opDef.getLevel();
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null && opDef.getWeight(i) == 1) {
        this.level=Math.max(this.level,this.operands[i].getLevel());
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      this.level=Math.max(this.level,this.ranges[i].getLevel());
    }
    this.levelParams.addAll(opDef.getLevelParams());
    this.allParams.addAll(opDef.getAllParams());
    this.nonLeibnizParams.addAll(opDef.getNonLeibnizParams());
    int ar=opDef.getArity();
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null && opDef.getWeight(i) == 1) {
        this.levelParams.addAll(this.operands[i].getLevelParams());
      }
      ;
      if (this.operands[i] != null) {
        this.allParams.addAll(this.operands[i].getAllParams());
        this.nonLeibnizParams.addAll(this.operands[i].getNonLeibnizParams());
      }
      ;
      int ii=i;
      if (ar == -1) {
        ii=0;
      }
      ;
      if (!opDef.getIsLeibnizArg()[ii]) {
        this.nonLeibnizParams.addAll(this.operands[i].getAllParams());
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      this.levelParams.addAll(this.ranges[i].getLevelParams());
      this.allParams.addAll(this.ranges[i].getAllParams());
      this.nonLeibnizParams.addAll(this.ranges[i].getNonLeibnizParams());
    }
    HashSet allBoundSymbols=new HashSet();
    if (this.unboundedBoundSymbols != null) {
      for (int i=0; i < this.unboundedBoundSymbols.length; i++) {
        allBoundSymbols.add(this.unboundedBoundSymbols[i]);
      }
    }
    ;
    if (this.boundedBoundSymbols != null) {
      for (int i=0; i < this.boundedBoundSymbols.length; i++) {
        if (this.boundedBoundSymbols[i] != null) {
          for (int j=0; j < this.boundedBoundSymbols[i].length; j++) {
            allBoundSymbols.add(this.boundedBoundSymbols[i][j]);
          }
        }
      }
    }
    ;
    Iterator absIter=allBoundSymbols.iterator();
    while (absIter.hasNext()) {
      Object nextBoundSymbol=absIter.next();
      this.levelParams.remove(nextBoundSymbol);
      this.allParams.remove(nextBoundSymbol);
      this.nonLeibnizParams.remove(nextBoundSymbol);
    }
    ;
    this.levelConstraints.putAll(opDef.getLevelConstraints());
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null) {
        if (allBoundSymbols.size() == 0) {
          this.levelConstraints.putAll(this.operands[i].getLevelConstraints());
        }
 else {
          SetOfLevelConstraints lcons=this.operands[i].getLevelConstraints();
          Iterator iter=lcons.keySet().iterator();
          while (iter.hasNext()) {
            SymbolNode param=(SymbolNode)iter.next();
            if (!allBoundSymbols.contains(param)) {
              this.levelConstraints.put(param,lcons.get(param));
            }
          }
        }
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      this.levelConstraints.putAll(this.ranges[i].getLevelConstraints());
    }
    for (int i=0; i < this.operands.length; i++) {
      Integer mlevel=new Integer(opDef.getMaxLevel(i));
      if (this.operands[i] != null) {
        Iterator iter=this.operands[i].getLevelParams().iterator();
        while (iter.hasNext()) {
          this.levelConstraints.put(iter.next(),mlevel);
        }
      }
    }
    for (int i=0; i < this.operands.length; i++) {
      ExprOrOpArgNode opdi=this.operands[i];
      if (opdi != null && opdi instanceof OpArgNode && ((OpArgNode)opdi).getOp() instanceof AnyDefNode) {
        AnyDefNode argDef=(AnyDefNode)((OpArgNode)opdi).getOp();
        argDef.levelCheck(itr);
        int alen=argDef.getArity();
        for (int j=0; j < this.operands.length; j++) {
          for (int k=0; k < alen; k++) {
            if (opDef.getOpLevelCond(i,j,k)) {
              Integer mlevel=new Integer(argDef.getMaxLevel(k));
              Iterator iter=this.operands[j].getLevelParams().iterator();
              while (iter.hasNext()) {
                this.levelConstraints.put(iter.next(),mlevel);
              }
            }
          }
        }
        ;
        if (!argDef.getIsLeibniz()) {
          for (int j=0; j < this.operands.length; j++) {
            for (int k=0; k < alen; k++) {
              if (opDef.getOpLevelCond(i,j,k) && !argDef.getIsLeibnizArg()[k]) {
                this.nonLeibnizParams.addAll(this.operands[j].getAllParams());
              }
            }
          }
          ;
        }
        ;
      }
    }
    HashSet alpSet=opDef.getArgLevelParams();
    Iterator iter=alpSet.iterator();
    while (iter.hasNext()) {
      ArgLevelParam alp=(ArgLevelParam)iter.next();
      ExprOrOpArgNode arg=this.getArg(alp.op);
      if (arg != null && arg instanceof OpArgNode && ((OpArgNode)arg).getOp() instanceof AnyDefNode) {
        AnyDefNode argDef=(AnyDefNode)((OpArgNode)arg).getOp();
        argDef.levelCheck(itr);
        Integer mlevel=new Integer(argDef.getMaxLevel(alp.i));
        this.levelConstraints.put(alp.param,mlevel);
      }
    }
    this.argLevelConstraints.putAll(opDef.getArgLevelConstraints());
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null) {
        this.argLevelConstraints.putAll(this.operands[i].getArgLevelConstraints());
      }
    }
    for (int i=0; i < this.ranges.length; i++) {
      this.argLevelConstraints.putAll(this.ranges[i].getArgLevelConstraints());
    }
    for (int i=0; i < this.operands.length; i++) {
      ExprOrOpArgNode opdi=this.operands[i];
      if (opdi != null && opdi instanceof OpArgNode && ((OpArgNode)opdi).getOp().isParam()) {
        SymbolNode opArg=((OpArgNode)opdi).getOp();
        int alen=opArg.getArity();
        for (int j=0; j < alen; j++) {
          ParamAndPosition pap=new ParamAndPosition(opArg,j);
          Integer mlevel=new Integer(opDef.getMinMaxLevel(i,j));
          this.argLevelConstraints.put(pap,mlevel);
        }
        for (int j=0; j < this.operands.length; j++) {
          for (int k=0; k < alen; k++) {
            if (opDef.getOpLevelCond(i,j,k)) {
              ParamAndPosition pap=new ParamAndPosition(opArg,k);
              Integer mlevel=new Integer(this.operands[j].getLevel());
              this.argLevelConstraints.put(pap,mlevel);
            }
          }
        }
      }
    }
    iter=alpSet.iterator();
    while (iter.hasNext()) {
      ArgLevelParam alp=(ArgLevelParam)iter.next();
      ExprOrOpArgNode arg=this.getArg(alp.op);
      if (arg != null) {
        arg.levelCheck(itr);
        ParamAndPosition pap=new ParamAndPosition(alp.op,alp.i);
        this.argLevelConstraints.put(pap,new Integer(arg.getLevel()));
      }
    }
    this.argLevelParams=new HashSet();
    for (int i=0; i < this.operands.length; i++) {
      if (this.operands[i] != null) {
        if (allBoundSymbols.size() == 0) {
          this.argLevelParams.addAll(this.operands[i].getArgLevelParams());
        }
 else {
          Iterator alpiter=this.operands[i].getArgLevelParams().iterator();
          while (alpiter.hasNext()) {
            ArgLevelParam alp=(ArgLevelParam)alpiter.next();
            if (!allBoundSymbols.contains(alp.param)) {
              this.argLevelParams.add(alp);
            }
          }
          ;
        }
      }
    }
    ;
    for (int i=0; i < this.ranges.length; i++) {
      this.argLevelParams.addAll(this.ranges[i].getArgLevelParams());
    }
    ;
    iter=alpSet.iterator();
    while (iter.hasNext()) {
      ArgLevelParam alp=(ArgLevelParam)iter.next();
      ExprOrOpArgNode arg=this.getArg(alp.op);
      if (arg == null) {
        arg=this.getArg(alp.param);
        if (arg == null) {
          this.argLevelParams.add(alp);
        }
 else {
          arg.levelCheck(itr);
          Iterator iter1=arg.getLevelParams().iterator();
          while (iter1.hasNext()) {
            SymbolNode param=(SymbolNode)iter1.next();
            this.argLevelParams.add(new ArgLevelParam(alp.op,alp.i,param));
          }
        }
      }
 else {
        if (arg instanceof OpArgNode && ((OpArgNode)arg).getOp().isParam()) {
          SymbolNode argOp=((OpArgNode)arg).getOp();
          this.argLevelParams.add(new ArgLevelParam(argOp,alp.i,alp.param));
        }
      }
    }
    for (int i=0; i < this.operands.length; i++) {
      ExprOrOpArgNode opdi=this.operands[i];
      if (opdi != null && opdi instanceof OpArgNode && ((OpArgNode)opdi).getOp().isParam()) {
        SymbolNode opArg=((OpArgNode)opdi).getOp();
        int alen=opArg.getArity();
        for (int j=0; j < this.operands.length; j++) {
          for (int k=0; k < alen; k++) {
            if (opDef.getOpLevelCond(i,j,k)) {
              Iterator iter1=this.operands[j].getLevelParams().iterator();
              while (iter1.hasNext()) {
                SymbolNode param=(SymbolNode)iter1.next();
                this.argLevelParams.add(new ArgLevelParam(opArg,k,param));
              }
            }
          }
        }
      }
    }
  }
 else {
    this.operator.levelCheck(itr);
    this.level=this.operator.getLevel();
    for (int i=0; i < this.operands.length; i++) {
      this.operands[i].levelCheck(itr);
      this.level=Math.max(this.level,this.operands[i].getLevel());
    }
    this.levelParams=new HashSet();
    this.levelParams.add(this.operator);
    this.allParams.add(this.operator);
    for (int i=0; i < this.operands.length; i++) {
      this.levelParams.addAll(this.operands[i].getLevelParams());
      this.allParams.addAll(this.operands[i].getAllParams());
      this.nonLeibnizParams.addAll(this.operands[i].getNonLeibnizParams());
    }
    this.levelConstraints=new SetOfLevelConstraints();
    for (int i=0; i < this.operands.length; i++) {
      this.levelConstraints.putAll(this.operands[i].getLevelConstraints());
    }
    this.argLevelConstraints=new SetOfArgLevelConstraints();
    for (int i=0; i < this.operands.length; i++) {
      this.argLevelConstraints.put(this.operator,i,this.operands[i].getLevel());
      this.argLevelConstraints.putAll(this.operands[i].getArgLevelConstraints());
    }
    this.argLevelParams=new HashSet();
    for (int i=0; i < this.operands.length; i++) {
      HashSet lpSet=this.operands[i].getLevelParams();
      Iterator iter=lpSet.iterator();
      while (iter.hasNext()) {
        SymbolNode param=(SymbolNode)iter.next();
        this.argLevelParams.add(new ArgLevelParam(this.operator,i,param));
      }
      ;
      this.argLevelParams.addAll(this.operands[i].getArgLevelParams());
    }
    ;
  }
  ;
  String opName=this.operator.getName().toString();
  if (opName.equals(""String_Node_Str"")) {
    ExprNode arg=(ExprNode)this.getArgs()[0];
    if ((arg.getLevel() == ActionLevel) && (arg.getKind() == OpApplKind)) {
      if (!((OpApplNode)arg).operator.getName().toString().equals(""String_Node_Str"")) {
        errors.addError(stn.getLocation(),""String_Node_Str"");
      }
    }
  }
  ;
  if (opName.equals(""String_Node_Str"")) {
    ExprNode arg=(ExprNode)this.getArgs()[0];
    if ((arg.getLevel() == ActionLevel) && (arg.getKind() == OpApplKind)) {
      if (!((OpApplNode)arg).operator.getName().toString().equals(""String_Node_Str"")) {
        errors.addError(stn.getLocation(),""String_Node_Str"");
      }
    }
  }
  ;
  if (opName.equals(""String_Node_Str"") || opName.equals(""String_Node_Str"")) {
    if ((this.getArgs()[0].getLevel() == ActionLevel) || (this.getArgs()[1].getLevel() == ActionLevel)) {
      errors.addError(stn.getLocation(),""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  ;
  if ((this.level == TemporalLevel) && (opName.equals(""String_Node_Str"") || opName.equals(""String_Node_Str""))) {
    for (int i=0; i < this.ranges.length; i++) {
      if (this.ranges[i].getLevel() == ActionLevel) {
        errors.addError(this.ranges[i].stn.getLocation(),""String_Node_Str"");
      }
    }
  }
  return this.levelCorrect;
}",0.9972863412509632
135885,"private final ExprOrOpArgNode getArg(SymbolNode param){
  OpDefNode opDef=(OpDefNode)this.operator;
  FormalParamNode[] formals=opDef.getParams();
  for (int i=0; i < this.operands.length; i++) {
    if (formals[i] == param) {
      return this.operands[i];
    }
  }
  return null;
}","private final ExprOrOpArgNode getArg(SymbolNode param){
  AnyDefNode opDef=(AnyDefNode)this.operator;
  FormalParamNode[] formals=opDef.getParams();
  for (int i=0; i < this.operands.length; i++) {
    if (formals[i] == param) {
      return this.operands[i];
    }
  }
  return null;
}",0.9298245614035088
135886,"/** 
 * The argument spec is the current tokenized specification, generated by the Tokenize method.  If that spec has a C-Syntax PlusCal algorithm, this method turns ""("", "")"", ""{"", and ""}"" tokens that are PlusCal delimiters (rather than parts of an expression) into the corresponding tokens that produce the appropriate TeX output.   A PlusCal ""("" can follow the following: ""macro"" + IDENT ""procedure"" + an IDENT  ""process"" | ""if"" | ""while"" | ""with"" A PlusCal ""{"" other than the initial one can follow the following: a PlusCal ""{"" a PlusCal "")"" ""else"" | ""either"" | ""or"" | ""define"" ""variable[s]"" [<expression> [, | ;]]^+  "";""   PCAL_LABEL This method also removes an extra gray bar that can appear after the algorithm when using the -shade and -noPcalShade options. The isTeX argument is true if this is called for tla2tex.TeX, in  which case the spec can start anywhere inside a PlusCal algorithm.
 * @param spec
 * @param isTeX  true for tla2tex.TeX, false for tla2tex.TLA
 */
public static void FixPlusCal(Token[][] spec,boolean isTeX){
  if (!hasPcal) {
    return;
  }
  if (Parameters.CommentShading && Parameters.NoPlusCalShading && (pcalEnd.line < spec.length)&& (pcalEnd.item < spec[pcalEnd.line].length)) {
    Token tok=pcalEnd.toToken(spec);
    if (tok.type == Token.COMMENT) {
      CommentToken ctok=(CommentToken)tok;
      if (ctok.string.trim().equals(""String_Node_Str"")) {
        int rsubtype=ctok.rsubtype;
        Token[] newline=new Token[spec[pcalEnd.line].length - 1];
        int j=0;
        for (int i=0; i < spec[pcalEnd.line].length; i++) {
          if (i != pcalEnd.item) {
            newline[j]=spec[pcalEnd.line][i];
            j++;
          }
        }
        if (rsubtype == CommentToken.NORMAL) {
          spec[pcalEnd.line]=newline;
        }
 else {
          if (rsubtype == CommentToken.BEGIN_OVERRUN) {
            Token next=spec[pcalEnd.line + 1][0];
            int nextLine=pcalEnd.line + 1;
            while ((next != null) && (next.type == CommentToken.COMMENT) && (((CommentToken)next).rsubtype == CommentToken.OVERRUN)&& (next.string.trim().equals(""String_Node_Str""))) {
              nextLine++;
              if (spec[nextLine + 1].length > 0) {
                next=spec[nextLine][0];
              }
 else {
                next=null;
              }
            }
            if ((next != null) && (next.type == CommentToken.COMMENT) && (next.string.trim().equals(""String_Node_Str""))&& (((CommentToken)next).rsubtype == CommentToken.END_OVERRUN)) {
              spec[pcalEnd.line]=newline;
              for (int i=pcalEnd.line + 1; i < nextLine; i++) {
                spec[i]=new Token[0];
              }
              newline=new Token[spec[nextLine].length - 1];
              System.arraycopy(spec[nextLine],1,newline,0,spec[nextLine].length - 1);
              spec[nextLine]=newline;
            }
          }
        }
      }
    }
  }
  if (!isCSyntax) {
    return;
  }
  Position pos=pcalStart;
  if (!isTeX) {
    while ((pos != null) && ((pos.toToken(spec).type != Token.BUILTIN) || (!pos.toToken(spec).string.equals(""String_Node_Str"")))) {
      pos=nextTokenPos(pos,spec);
    }
  }
  if (pos != null) {
    pos=ProcessPcalBrace(pos,spec,isTeX);
  }
  while (isTeX && (pos != null)) {
    pos=ProcessPcalBrace(pos,spec,isTeX);
  }
}","/** 
 * The argument spec is the current tokenized specification, generated by the Tokenize method.  If that spec has a C-Syntax PlusCal algorithm, this method turns ""("", "")"", ""{"", and ""}"" tokens that are PlusCal delimiters (rather than parts of an expression) into the corresponding tokens that produce the appropriate TeX output.   A PlusCal ""("" can follow the following: ""macro"" + IDENT ""procedure"" + an IDENT  ""process"" | ""if"" | ""while"" | ""with"" A PlusCal ""{"" other than the initial one can follow the following: a PlusCal ""{"" a PlusCal "")"" ""else"" | ""either"" | ""or"" | ""define"" ""variable[s]"" [<expression> [, | ;]]^+  "";""   PCAL_LABEL This method also removes an extra gray bar that can appear after the algorithm when using the -shade and -noPcalShade options. The isTeX argument is true if this is called for tla2tex.TeX, in  which case the spec can start anywhere inside a PlusCal algorithm.
 * @param spec
 * @param isTeX  true for tla2tex.TeX, false for tla2tex.TLA
 */
public static void FixPlusCal(Token[][] spec,boolean isTeX){
  if (!hasPcal) {
    return;
  }
  if (Parameters.CommentShading && Parameters.NoPlusCalShading && (pcalEnd.line < spec.length)&& (pcalEnd.item < spec[pcalEnd.line].length)) {
    Token tok=pcalEnd.toToken(spec);
    if (tok.type == Token.COMMENT) {
      CommentToken ctok=(CommentToken)tok;
      if (ctok.string.trim().equals(""String_Node_Str"")) {
        int rsubtype=ctok.rsubtype;
        Token[] newline=new Token[spec[pcalEnd.line].length - 1];
        int j=0;
        for (int i=0; i < spec[pcalEnd.line].length; i++) {
          if (i != pcalEnd.item) {
            newline[j]=spec[pcalEnd.line][i];
            j++;
          }
        }
        if (rsubtype == CommentToken.NORMAL) {
          spec[pcalEnd.line]=newline;
        }
 else {
          if (rsubtype == CommentToken.BEGIN_OVERRUN) {
            Token next=spec[pcalEnd.line + 1][0];
            int nextLine=pcalEnd.line + 1;
            while ((next != null) && (next.type == CommentToken.COMMENT) && (((CommentToken)next).rsubtype == CommentToken.OVERRUN)&& (next.string.trim().equals(""String_Node_Str""))) {
              nextLine++;
              if (spec[nextLine + 1].length > 0) {
                next=spec[nextLine][0];
              }
 else {
                next=null;
              }
            }
            if ((next != null) && (next.type == CommentToken.COMMENT) && (next.string.trim().equals(""String_Node_Str""))&& (((CommentToken)next).rsubtype == CommentToken.END_OVERRUN)) {
              spec[pcalEnd.line]=newline;
              for (int i=pcalEnd.line + 1; i < nextLine; i++) {
                spec[i]=new Token[0];
              }
              newline=new Token[spec[nextLine].length - 1];
              System.arraycopy(spec[nextLine],1,newline,0,spec[nextLine].length - 1);
              spec[nextLine]=newline;
            }
          }
        }
      }
    }
  }
  if (!isCSyntax) {
    return;
  }
  Position pos=pcalStart;
  boolean beginningOfAlgorithm=!isTeX;
  if (isTeX && pos != null) {
    String firstString=pos.toToken(spec).string;
    if (firstString.equals(""String_Node_Str"") || firstString.equals(""String_Node_Str"")) {
      beginningOfAlgorithm=true;
    }
  }
  if (beginningOfAlgorithm) {
    while ((pos != null) && ((pos.toToken(spec).type != Token.BUILTIN) || (!pos.toToken(spec).string.equals(""String_Node_Str"")))) {
      pos=nextTokenPos(pos,spec);
    }
  }
  if (pos != null) {
    pos=ProcessPcalBrace(pos,spec,isTeX);
  }
  while (isTeX && (pos != null)) {
    pos=ProcessPcalBrace(pos,spec,isTeX);
  }
}",0.9603485838779956
135887,"public static Token[][] Tokenize(CharReader charReader,int mode){
  vspec=new Vector(1000,1000);
  reader=charReader;
  nextChar=reader.getNextChar();
  hasPcal=false;
  isCSyntax=false;
  pcalStart=null;
  pcalEnd=null;
  inPcal=false;
  canBeLabel=false;
  pseudoCom=false;
  ORCom=false;
  int braceDepth=0;
switch (mode) {
case MODULE:
    state=PROLOG;
  break;
case TLA:
state=START;
break;
case PLUSCAL:
state=START;
hasPcal=true;
pcalStart=new Position(0,0);
inPcal=true;
canBeLabel=true;
isCSyntax=true;
break;
case P_PLUSCAL:
state=START;
hasPcal=true;
pcalStart=new Position(0,0);
inPcal=true;
canBeLabel=true;
break;
default :
Debug.ReportBug(""String_Node_Str"");
}
;
while (state != DONE) {
switch (state) {
case START:
if (Misc.IsSpace(nextChar)) {
skipNextChar();
gotoStart();
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
state=ID;
}
 else if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM_OR_ID;
}
 else if (nextChar == '\\') {
addNextChar();
state=BS;
}
 else if (nextChar == '-') {
addNextChar();
state=DASH1;
}
 else if (nextChar == '=') {
addNextChar();
state=EQ1;
}
 else if (nextChar == '(') {
skipNextChar();
state=LEFT_PAREN;
}
 else if (nextChar == '""') {
skipNextChar();
state=STRING;
}
 else if (nextChar == '\n') {
skipNextChar();
startNewLine();
gotoStart();
}
 else if (BuiltInSymbols.IsBuiltInPrefix(""String_Node_Str"" + nextChar,inPcal)) {
addNextChar();
if (!(inPcal && (mode == MODULE))) {
state=BUILT_IN;
}
 else if (token.equals(""String_Node_Str"") && (nextChar == ')')) {
pcalEnd=getNextTokenPosition();
inPcal=false;
token=""String_Node_Str"";
gotoStart();
}
 else if (isCSyntax) {
if (token.equals(""String_Node_Str"")) {
TokenOut(Token.BUILTIN);
canBeLabel=true;
braceDepth++;
gotoStart();
}
 else if (token.equals(""String_Node_Str"")) {
TokenOut(Token.BUILTIN);
braceDepth--;
if (braceDepth != 0) {
gotoStart();
}
 else {
col=ncol;
inPcal=false;
cdepth=1;
pcalEnd=getNextTokenPosition();
pseudoCom=true;
state=COMMENT;
}
}
 else {
state=BUILT_IN;
}
}
 else {
state=BUILT_IN;
}
}
 else if (nextChar == '\t') {
if (mode == MODULE) {
Debug.ReportError(""String_Node_Str"");
}
;
state=DONE;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
;
break;
case ID:
if ((token.length() == 3) && (token.equals(""String_Node_Str"") || token.equals(""String_Node_Str""))) {
TokenOut(Token.BUILTIN);
gotoStart();
}
 else if (Misc.IsLetter(nextChar) || Misc.IsDigit(nextChar)) {
addNextChar();
}
 else if (BuiltInSymbols.IsBuiltInSymbol(token,inPcal)) {
if (token.equals(""String_Node_Str"")) {
mdepth=mdepth + 1;
}
 else if (inPcal && token.equals(""String_Node_Str"") && !isCSyntax&& (mode == MODULE)) {
TokenOut(Token.BUILTIN);
col=ncol;
pcalEnd=getNextTokenPosition();
cdepth=1;
inPcal=false;
pseudoCom=true;
state=COMMENT;
}
 else {
boolean cbl=inPcal && BuiltInSymbols.CanPrecedeLabel(token);
TokenOut(Token.BUILTIN);
canBeLabel=cbl;
gotoStart();
}
}
 else if (inPcal && canBeLabel) {
token1=token;
col1=col;
state=ID_OR_PCAL_LABEL;
}
 else {
TokenOut(Token.IDENT);
gotoStart();
}
;
break;
case ID_OR_PCAL_LABEL:
while (Misc.IsSpace(nextChar)) {
addNextChar();
}
if (nextChar == ':') {
addNextChar();
if ((nextChar != '=') && (nextChar != ':')) {
token1=token;
state=PCAL_LABEL;
}
 else {
reader.backspace();
ncol--;
nextChar=':';
token=token1;
TokenOut(Token.IDENT);
gotoStart();
}
}
 else {
token=token1;
TokenOut(Token.IDENT);
gotoStart();
}
break;
case PCAL_LABEL:
while (Misc.IsSpace(nextChar)) {
addNextChar();
}
if ((nextChar == '+') || (nextChar == '-')) {
addNextChar();
TokenOut(Token.PCAL_LABEL);
gotoStart();
}
 else {
token=token1;
TokenOut(Token.PCAL_LABEL);
gotoStart();
}
break;
case NUM_OR_ID:
if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM_OR_ID;
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
state=ID;
}
 else {
TokenOut(Token.NUMBER);
gotoStart();
}
break;
case BS:
if ((nextChar == 'b') || (nextChar == 'B') || (nextChar == 'o')|| (nextChar == 'O')|| (nextChar == 'h')|| (nextChar == 'H')) {
addNextChar();
state=NUM_OR_BI;
}
 else if (Misc.IsLetter(nextChar)) {
state=BSBUILT_IN;
}
 else if (nextChar == '*') {
skipNextChar();
token=""String_Node_Str"";
state=LINE_COMMENT;
}
 else {
state=BUILT_IN;
}
break;
case NUM_OR_BI:
if (Misc.IsDigit(nextChar)) {
state=NUM;
}
 else {
state=BSBUILT_IN;
}
;
break;
case NUM:
if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM;
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
if (token.charAt(0) == '\\') {
TokenizingError(""String_Node_Str"");
}
 else {
state=ID;
}
;
}
 else {
TokenOut(Token.NUMBER);
gotoStart();
}
break;
case BSBUILT_IN:
if (Misc.IsLetter(nextChar) && (nextChar != '_')) {
addNextChar();
state=BSBUILT_IN;
}
 else if (BuiltInSymbols.IsBuiltInSymbol(token)) {
TokenOut(Token.BUILTIN);
gotoStart();
}
 else {
TokenizingError(""String_Node_Str"");
}
;
break;
case BUILT_IN:
if (BuiltInSymbols.IsBuiltInPrefix(token + nextChar,inPcal)) {
addNextChar();
}
 else {
if (!BuiltInSymbols.IsBuiltInSymbol(token,inPcal)) {
reader.backspace();
while (!BuiltInSymbols.IsBuiltInSymbol(token,inPcal)) {
reader.backspace();
if (token.length() == 0) {
TokenizingError(""String_Node_Str"");
}
;
token=token.substring(0,token.length() - 1);
}
;
nextChar=reader.getNextChar();
}
;
boolean saved=BuiltInSymbols.CanPrecedeLabel(token);
TokenOut(Token.BUILTIN);
canBeLabel=saved;
gotoStart();
}
break;
case DASH1:
if (nextChar == '-') {
addNextChar();
state=DASH2;
}
 else {
state=BUILT_IN;
}
break;
case DASH2:
if (nextChar == '-') {
addNextChar();
state=DASH3;
}
 else {
state=BUILT_IN;
}
break;
case DASH3:
if (nextChar == '-') {
addNextChar();
state=DASHES;
}
 else {
TokenizingError(""String_Node_Str"");
}
break;
case DASHES:
if (nextChar == '-') {
addNextChar();
state=DASHES;
}
 else {
TokenOut(Token.DASHES);
gotoStart();
}
break;
case EQ1:
if (nextChar == '=') {
addNextChar();
state=EQ2;
}
 else {
state=BUILT_IN;
}
break;
case EQ2:
if (nextChar == '=') {
addNextChar();
state=EQ3;
}
 else {
state=BUILT_IN;
}
break;
case EQ3:
if (nextChar == '=') {
addNextChar();
state=EQS;
}
 else {
TokenizingError(""String_Node_Str"");
}
break;
case EQS:
if (nextChar == '=') {
addNextChar();
state=EQS;
}
 else {
mdepth=mdepth - 1;
TokenOut(Token.END_MODULE);
if ((mdepth > 0) || (mode == TLA)) {
gotoStart();
}
 else if (mdepth == 0) {
state=EPILOG;
}
 else {
Debug.ReportError(""String_Node_Str"" + (reader.getLineNumber() + 1));
}
}
break;
case LEFT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=1;
state=COMMENT;
}
 else {
token=""String_Node_Str"";
state=BUILT_IN;
}
break;
case STRING:
if (nextChar == '\\') {
addNextChar();
state=ESC_STRING;
}
 else if (nextChar == '""') {
skipNextChar();
TokenOut(Token.STRING);
gotoStart();
}
 else if (BuiltInSymbols.IsStringChar(nextChar)) {
addNextChar();
state=STRING;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
break;
case ESC_STRING:
if ((nextChar == '\""') || (nextChar == '\\') || (nextChar == 't')|| (nextChar == 'n')|| (nextChar == 'f')|| (nextChar == 'r')) {
addNextChar();
state=STRING;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
break;
case LINE_COMMENT:
if (nextChar == '(') {
skipNextChar();
state=LINE_COM_PAREN;
}
 else if ((nextChar == '*') && (cdepth > 0)) {
skipNextChar();
state=LINE_COM_STAR;
}
 else if ((nextChar == '\n') || (nextChar == '\t')) {
CommentTokenOut(CommentToken.LINE);
cdepth=0;
gotoStart();
}
 else {
if (cdepth == 0) {
addNextChar();
}
 else {
skipNextChar();
}
;
state=LINE_COMMENT;
}
break;
case LINE_COM_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=LINE_COMMENT;
}
 else {
if (cdepth == 0) {
token=token + ""String_Node_Str"";
}
;
state=LINE_COMMENT;
}
break;
case LINE_COM_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
Debug.Assert(cdepth >= 0,""String_Node_Str"");
state=LINE_COMMENT;
}
 else {
if (cdepth == 0) {
token=token + ""String_Node_Str"";
}
;
state=LINE_COMMENT;
}
break;
case COMMENT:
if (nextChar == '*') {
skipNextChar();
state=COMMENT_STAR;
}
 else if (nextChar == '(') {
skipNextChar();
state=COMMENT_PAREN;
}
 else if (nextChar == '\n') {
CommentTokenOut(CommentToken.BEGIN_OVERRUN);
skipNextChar();
startNewLine();
state=OR_COMMENT;
}
 else if (nextChar == '\t') {
Debug.ReportError(""String_Node_Str"");
}
 else if ((nextChar == '-') && (cdepth == 1) && (mode == MODULE)&& !hasPcal) {
token1=token;
col1=col;
token=""String_Node_Str"";
col=ncol;
ORCom=false;
addNextChar();
state=C_DASH;
}
 else {
if (cdepth == 1) {
addNextChar();
}
 else {
skipNextChar();
}
;
}
break;
case COMMENT_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
if (cdepth == 0) {
CommentTokenOut(CommentToken.NORMAL);
gotoStart();
}
 else {
state=COMMENT;
}
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=COMMENT;
}
break;
case C_DASH:
if (nextChar == '-') {
addNextChar();
state=C_DASH_DASH;
}
 else {
token=token1 + token;
col=col1;
addNextChar();
state=COMMENT;
}
break;
case C_DASH_DASH:
while (Misc.IsLetter(nextChar)) {
addNextChar();
}
boolean isAlgorithm=token.equals(""String_Node_Str"");
if (isAlgorithm || token.equals(""String_Node_Str"")) {
if (!Misc.isBlank(token1)) {
pseudoCom=true;
token2=token;
col2=col;
token=token1;
col=col1;
CommentTokenOut(ORCom ? CommentToken.END_OVERRUN : CommentToken.NORMAL);
token=token2;
col=col2;
}
hasPcal=true;
pcalStart=getNextTokenPosition();
TokenOut(Token.BUILTIN);
SkipSpaceAndNewlines();
if (isAlgorithm) {
state=GET_ALG_NAME;
}
 else {
state=GET_ALG_TOKEN;
}
}
 else {
token=token1 + token;
col=col1;
state=COMMENT;
}
break;
case GET_ALG_TOKEN:
while (Misc.IsLetter(nextChar)) {
addNextChar();
}
if (token.equals(""String_Node_Str"")) {
TokenOut(Token.BUILTIN);
SkipSpaceAndNewlines();
state=GET_ALG_NAME;
}
 else {
pcalEnd=getNextTokenPosition();
pseudoCom=true;
state=COMMENT;
}
break;
case GET_ALG_NAME:
while (Misc.IsLetter(nextChar) || Misc.IsDigit(nextChar)) {
addNextChar();
}
if (Misc.hasLetter(token)) {
TokenOut(Token.IDENT);
SkipSpaceAndNewlines();
isCSyntax=(nextChar == '{');
cdepth=0;
inPcal=true;
braceDepth=0;
gotoStart();
}
 else {
pcalEnd=getNextTokenPosition();
pseudoCom=true;
state=COMMENT;
}
break;
case COMMENT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=COMMENT;
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=COMMENT;
}
break;
case OR_COMMENT:
if (nextChar == '*') {
skipNextChar();
state=OR_COMMENT_STAR;
}
 else if (nextChar == '(') {
skipNextChar();
state=OR_COMMENT_PAREN;
}
 else if (nextChar == '\n') {
CommentTokenOut(CommentToken.OVERRUN);
skipNextChar();
startNewLine();
state=OR_COMMENT;
}
 else if ((nextChar == '-') && (cdepth == 1) && (mode == MODULE)&& !hasPcal) {
token1=token;
col1=col;
token=""String_Node_Str"";
col=ncol;
ORCom=true;
addNextChar();
state=C_DASH;
}
 else if (nextChar == '\t') {
Debug.ReportError(""String_Node_Str"");
}
 else {
if (cdepth == 1) {
addNextChar();
}
 else {
skipNextChar();
}
;
}
break;
case OR_COMMENT_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
Debug.Assert(cdepth >= 0);
if (cdepth == 0) {
CommentTokenOut(CommentToken.END_OVERRUN);
gotoStart();
}
 else {
state=OR_COMMENT;
}
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=OR_COMMENT;
}
break;
case OR_COMMENT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=OR_COMMENT;
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=OR_COMMENT;
}
break;
case PROLOG:
if (nextChar == '-') {
token1=token;
col1=col;
col=ncol;
token=""String_Node_Str"";
skipNextChar();
state=PROLOG_DASH;
}
 else if (nextChar == '\n') {
TokenOut(Token.PROLOG);
skipNextChar();
startNewLine();
}
 else if (nextChar == '\t') {
Debug.ReportError(""String_Node_Str"");
}
 else {
addNextChar();
}
break;
case PROLOG_DASH:
Debug.Assert(token.length() <= 3);
if (nextChar == '-') {
addNextChar();
if (token.length() == 4) {
state=PROLOG_DASHES;
}
 else {
}
;
}
 else {
token=token1 + token;
col=col1;
state=PROLOG;
}
break;
case PROLOG_DASHES:
if (nextChar == '-') {
addNextChar();
}
 else {
token2=token;
col2=col;
token=""String_Node_Str"";
col=ncol;
state=PROLOG_SPACES;
}
break;
case PROLOG_SPACES:
if (nextChar == ' ') {
addNextChar();
}
 else if (Misc.IsLetter(nextChar)) {
token3=token;
col3=ncol;
token=""String_Node_Str"";
state=PROLOG_ID;
}
 else {
token=token1 + token2;
col=col1;
state=PROLOG;
}
break;
case PROLOG_ID:
if (Misc.IsLetter(nextChar)) {
addNextChar();
}
 else if (token.equals(""String_Node_Str"")) {
token=token1;
col=col1;
TokenOut(Token.PROLOG);
token=token2;
col=col2;
TokenOut(Token.DASHES);
token=""String_Node_Str"";
col=col3;
TokenOut(Token.BUILTIN);
token=""String_Node_Str"";
mdepth=1;
gotoStart();
}
 else {
token=token1 + token2 + token3;
col=col1;
state=PROLOG;
}
break;
case EPILOG:
if (nextChar == '\n') {
TokenOut(Token.EPILOG);
skipNextChar();
startNewLine();
}
 else if (nextChar == '\t') {
TokenOut(Token.EPILOG);
state=DONE;
}
 else {
addNextChar();
}
break;
default :
Debug.ReportBug(""String_Node_Str"");
}
;
}
;
if (hasPcal) {
if (pcalEnd == null) {
pcalEnd=new Position(Integer.MAX_VALUE,0);
}
}
return vspecToArray();
}","public static Token[][] Tokenize(CharReader charReader,int mode){
  vspec=new Vector(1000,1000);
  reader=charReader;
  nextChar=reader.getNextChar();
  hasPcal=false;
  isCSyntax=false;
  pcalStart=null;
  pcalEnd=null;
  inPcal=false;
  canBeLabel=false;
  pseudoCom=false;
  ORCom=false;
  int braceDepth=0;
switch (mode) {
case MODULE:
    state=PROLOG;
  break;
case TLA:
state=START;
break;
case PLUSCAL:
state=START;
hasPcal=true;
pcalStart=new Position(0,0);
inPcal=true;
canBeLabel=true;
isCSyntax=true;
break;
case P_PLUSCAL:
state=START;
hasPcal=true;
pcalStart=new Position(0,0);
inPcal=true;
canBeLabel=true;
break;
default :
Debug.ReportBug(""String_Node_Str"");
}
;
while (state != DONE) {
switch (state) {
case START:
if (Misc.IsSpace(nextChar)) {
skipNextChar();
gotoStart();
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
state=ID;
}
 else if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM_OR_ID;
}
 else if (nextChar == '\\') {
addNextChar();
state=BS;
}
 else if (nextChar == '-') {
addNextChar();
state=DASH1;
}
 else if (nextChar == '=') {
addNextChar();
state=EQ1;
}
 else if (nextChar == '(') {
skipNextChar();
state=LEFT_PAREN;
}
 else if (nextChar == '""') {
skipNextChar();
state=STRING;
}
 else if (nextChar == '\n') {
skipNextChar();
startNewLine();
gotoStart();
}
 else if (BuiltInSymbols.IsBuiltInPrefix(""String_Node_Str"" + nextChar,inPcal)) {
addNextChar();
if (!(inPcal && (mode == MODULE))) {
state=BUILT_IN;
}
 else if (token.equals(""String_Node_Str"") && (nextChar == ')')) {
pcalEnd=getNextTokenPosition();
inPcal=false;
token=""String_Node_Str"";
gotoStart();
}
 else if (isCSyntax) {
if (token.equals(""String_Node_Str"")) {
TokenOut(Token.BUILTIN);
canBeLabel=true;
braceDepth++;
gotoStart();
}
 else if (token.equals(""String_Node_Str"")) {
TokenOut(Token.BUILTIN);
braceDepth--;
if (braceDepth != 0) {
gotoStart();
}
 else {
col=ncol;
inPcal=false;
cdepth=1;
pcalEnd=getNextTokenPosition();
pseudoCom=true;
state=COMMENT;
}
}
 else {
state=BUILT_IN;
}
}
 else {
state=BUILT_IN;
}
}
 else if (nextChar == '\t') {
if (mode == MODULE) {
Debug.ReportError(""String_Node_Str"");
}
;
state=DONE;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
;
break;
case ID:
if ((token.length() == 3) && (token.equals(""String_Node_Str"") || token.equals(""String_Node_Str""))) {
TokenOut(Token.BUILTIN);
gotoStart();
}
 else if (Misc.IsLetter(nextChar) || Misc.IsDigit(nextChar)) {
addNextChar();
}
 else if (BuiltInSymbols.IsBuiltInSymbol(token,inPcal)) {
if (token.equals(""String_Node_Str"")) {
mdepth=mdepth + 1;
TokenOut(Token.BUILTIN);
gotoStart();
}
 else if (inPcal && token.equals(""String_Node_Str"") && !isCSyntax&& (mode == MODULE)) {
TokenOut(Token.BUILTIN);
col=ncol;
pcalEnd=getNextTokenPosition();
cdepth=1;
inPcal=false;
pseudoCom=true;
state=COMMENT;
}
 else {
boolean cbl=inPcal && BuiltInSymbols.CanPrecedeLabel(token);
TokenOut(Token.BUILTIN);
canBeLabel=cbl;
gotoStart();
}
}
 else if (inPcal && canBeLabel) {
token1=token;
col1=col;
state=ID_OR_PCAL_LABEL;
}
 else {
TokenOut(Token.IDENT);
gotoStart();
}
;
break;
case ID_OR_PCAL_LABEL:
while (Misc.IsSpace(nextChar)) {
addNextChar();
}
if (nextChar == ':') {
addNextChar();
if ((nextChar != '=') && (nextChar != ':')) {
token1=token;
state=PCAL_LABEL;
}
 else {
reader.backspace();
ncol--;
nextChar=':';
token=token1;
TokenOut(Token.IDENT);
gotoStart();
}
}
 else {
token=token1;
TokenOut(Token.IDENT);
gotoStart();
}
break;
case PCAL_LABEL:
while (Misc.IsSpace(nextChar)) {
addNextChar();
}
if ((nextChar == '+') || (nextChar == '-')) {
addNextChar();
TokenOut(Token.PCAL_LABEL);
gotoStart();
}
 else {
token=token1;
TokenOut(Token.PCAL_LABEL);
gotoStart();
}
break;
case NUM_OR_ID:
if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM_OR_ID;
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
state=ID;
}
 else {
TokenOut(Token.NUMBER);
gotoStart();
}
break;
case BS:
if ((nextChar == 'b') || (nextChar == 'B') || (nextChar == 'o')|| (nextChar == 'O')|| (nextChar == 'h')|| (nextChar == 'H')) {
addNextChar();
state=NUM_OR_BI;
}
 else if (Misc.IsLetter(nextChar)) {
state=BSBUILT_IN;
}
 else if (nextChar == '*') {
skipNextChar();
token=""String_Node_Str"";
state=LINE_COMMENT;
}
 else {
state=BUILT_IN;
}
break;
case NUM_OR_BI:
if (Misc.IsDigit(nextChar)) {
state=NUM;
}
 else {
state=BSBUILT_IN;
}
;
break;
case NUM:
if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM;
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
if (token.charAt(0) == '\\') {
TokenizingError(""String_Node_Str"");
}
 else {
state=ID;
}
;
}
 else {
TokenOut(Token.NUMBER);
gotoStart();
}
break;
case BSBUILT_IN:
if (Misc.IsLetter(nextChar) && (nextChar != '_')) {
addNextChar();
state=BSBUILT_IN;
}
 else if (BuiltInSymbols.IsBuiltInSymbol(token)) {
TokenOut(Token.BUILTIN);
gotoStart();
}
 else {
TokenizingError(""String_Node_Str"");
}
;
break;
case BUILT_IN:
if (BuiltInSymbols.IsBuiltInPrefix(token + nextChar,inPcal)) {
addNextChar();
}
 else {
if (!BuiltInSymbols.IsBuiltInSymbol(token,inPcal)) {
reader.backspace();
while (!BuiltInSymbols.IsBuiltInSymbol(token,inPcal)) {
reader.backspace();
if (token.length() == 0) {
TokenizingError(""String_Node_Str"");
}
;
token=token.substring(0,token.length() - 1);
}
;
nextChar=reader.getNextChar();
}
;
boolean saved=BuiltInSymbols.CanPrecedeLabel(token);
TokenOut(Token.BUILTIN);
canBeLabel=saved;
gotoStart();
}
break;
case DASH1:
if (nextChar == '-') {
addNextChar();
state=DASH2;
}
 else {
state=BUILT_IN;
}
break;
case DASH2:
if (nextChar == '-') {
addNextChar();
state=DASH3;
}
 else {
state=BUILT_IN;
}
break;
case DASH3:
if (nextChar == '-') {
addNextChar();
state=DASHES;
}
 else {
TokenizingError(""String_Node_Str"");
}
break;
case DASHES:
if (nextChar == '-') {
addNextChar();
state=DASHES;
}
 else {
TokenOut(Token.DASHES);
gotoStart();
}
break;
case EQ1:
if (nextChar == '=') {
addNextChar();
state=EQ2;
}
 else {
state=BUILT_IN;
}
break;
case EQ2:
if (nextChar == '=') {
addNextChar();
state=EQ3;
}
 else {
state=BUILT_IN;
}
break;
case EQ3:
if (nextChar == '=') {
addNextChar();
state=EQS;
}
 else {
TokenizingError(""String_Node_Str"");
}
break;
case EQS:
if (nextChar == '=') {
addNextChar();
state=EQS;
}
 else {
mdepth=mdepth - 1;
TokenOut(Token.END_MODULE);
if ((mdepth > 0) || (mode == TLA)) {
gotoStart();
}
 else if (mdepth == 0) {
state=EPILOG;
}
 else {
Debug.ReportError(""String_Node_Str"" + (reader.getLineNumber() + 1));
}
}
break;
case LEFT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=1;
state=COMMENT;
}
 else {
token=""String_Node_Str"";
state=BUILT_IN;
}
break;
case STRING:
if (nextChar == '\\') {
addNextChar();
state=ESC_STRING;
}
 else if (nextChar == '""') {
skipNextChar();
TokenOut(Token.STRING);
gotoStart();
}
 else if (BuiltInSymbols.IsStringChar(nextChar)) {
addNextChar();
state=STRING;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
break;
case ESC_STRING:
if ((nextChar == '\""') || (nextChar == '\\') || (nextChar == 't')|| (nextChar == 'n')|| (nextChar == 'f')|| (nextChar == 'r')) {
addNextChar();
state=STRING;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
break;
case LINE_COMMENT:
if (nextChar == '(') {
skipNextChar();
state=LINE_COM_PAREN;
}
 else if ((nextChar == '*') && (cdepth > 0)) {
skipNextChar();
state=LINE_COM_STAR;
}
 else if ((nextChar == '\n') || (nextChar == '\t')) {
CommentTokenOut(CommentToken.LINE);
cdepth=0;
gotoStart();
}
 else {
if (cdepth == 0) {
addNextChar();
}
 else {
skipNextChar();
}
;
state=LINE_COMMENT;
}
break;
case LINE_COM_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=LINE_COMMENT;
}
 else {
if (cdepth == 0) {
token=token + ""String_Node_Str"";
}
;
state=LINE_COMMENT;
}
break;
case LINE_COM_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
Debug.Assert(cdepth >= 0,""String_Node_Str"");
state=LINE_COMMENT;
}
 else {
if (cdepth == 0) {
token=token + ""String_Node_Str"";
}
;
state=LINE_COMMENT;
}
break;
case COMMENT:
if (nextChar == '*') {
skipNextChar();
state=COMMENT_STAR;
}
 else if (nextChar == '(') {
skipNextChar();
state=COMMENT_PAREN;
}
 else if (nextChar == '\n') {
CommentTokenOut(CommentToken.BEGIN_OVERRUN);
skipNextChar();
startNewLine();
state=OR_COMMENT;
}
 else if (nextChar == '\t') {
Debug.ReportError(""String_Node_Str"");
}
 else if ((nextChar == '-') && (cdepth == 1) && (mode == MODULE)&& !hasPcal) {
token1=token;
col1=col;
token=""String_Node_Str"";
col=ncol;
ORCom=false;
addNextChar();
state=C_DASH;
}
 else {
if (cdepth == 1) {
addNextChar();
}
 else {
skipNextChar();
}
;
}
break;
case COMMENT_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
if (cdepth == 0) {
CommentTokenOut(CommentToken.NORMAL);
gotoStart();
}
 else {
state=COMMENT;
}
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=COMMENT;
}
break;
case C_DASH:
if (nextChar == '-') {
addNextChar();
state=C_DASH_DASH;
}
 else {
token=token1 + token;
col=col1;
addNextChar();
state=COMMENT;
}
break;
case C_DASH_DASH:
while (Misc.IsLetter(nextChar)) {
addNextChar();
}
boolean isAlgorithm=token.equals(""String_Node_Str"");
if (isAlgorithm || token.equals(""String_Node_Str"")) {
if (!Misc.isBlank(token1)) {
pseudoCom=true;
token2=token;
col2=col;
token=token1;
col=col1;
CommentTokenOut(ORCom ? CommentToken.END_OVERRUN : CommentToken.NORMAL);
token=token2;
col=col2;
}
hasPcal=true;
pcalStart=getNextTokenPosition();
TokenOut(Token.BUILTIN);
SkipSpaceAndNewlines();
if (isAlgorithm) {
state=GET_ALG_NAME;
}
 else {
state=GET_ALG_TOKEN;
}
}
 else {
token=token1 + token;
col=col1;
state=COMMENT;
}
break;
case GET_ALG_TOKEN:
while (Misc.IsLetter(nextChar)) {
addNextChar();
}
if (token.equals(""String_Node_Str"")) {
TokenOut(Token.BUILTIN);
SkipSpaceAndNewlines();
state=GET_ALG_NAME;
}
 else {
pcalEnd=getNextTokenPosition();
pseudoCom=true;
state=COMMENT;
}
break;
case GET_ALG_NAME:
while (Misc.IsLetter(nextChar) || Misc.IsDigit(nextChar)) {
addNextChar();
}
if (Misc.hasLetter(token)) {
TokenOut(Token.IDENT);
SkipSpaceAndNewlines();
isCSyntax=(nextChar == '{');
cdepth=0;
inPcal=true;
braceDepth=0;
gotoStart();
}
 else {
pcalEnd=getNextTokenPosition();
pseudoCom=true;
state=COMMENT;
}
break;
case COMMENT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=COMMENT;
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=COMMENT;
}
break;
case OR_COMMENT:
if (nextChar == '*') {
skipNextChar();
state=OR_COMMENT_STAR;
}
 else if (nextChar == '(') {
skipNextChar();
state=OR_COMMENT_PAREN;
}
 else if (nextChar == '\n') {
CommentTokenOut(CommentToken.OVERRUN);
skipNextChar();
startNewLine();
state=OR_COMMENT;
}
 else if ((nextChar == '-') && (cdepth == 1) && (mode == MODULE)&& !hasPcal) {
token1=token;
col1=col;
token=""String_Node_Str"";
col=ncol;
ORCom=true;
addNextChar();
state=C_DASH;
}
 else if (nextChar == '\t') {
Debug.ReportError(""String_Node_Str"");
}
 else {
if (cdepth == 1) {
addNextChar();
}
 else {
skipNextChar();
}
;
}
break;
case OR_COMMENT_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
Debug.Assert(cdepth >= 0);
if (cdepth == 0) {
CommentTokenOut(CommentToken.END_OVERRUN);
gotoStart();
}
 else {
state=OR_COMMENT;
}
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=OR_COMMENT;
}
break;
case OR_COMMENT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=OR_COMMENT;
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=OR_COMMENT;
}
break;
case PROLOG:
if (nextChar == '-') {
token1=token;
col1=col;
col=ncol;
token=""String_Node_Str"";
skipNextChar();
state=PROLOG_DASH;
}
 else if (nextChar == '\n') {
TokenOut(Token.PROLOG);
skipNextChar();
startNewLine();
}
 else if (nextChar == '\t') {
Debug.ReportError(""String_Node_Str"");
}
 else {
addNextChar();
}
break;
case PROLOG_DASH:
Debug.Assert(token.length() <= 3);
if (nextChar == '-') {
addNextChar();
if (token.length() == 4) {
state=PROLOG_DASHES;
}
 else {
}
;
}
 else {
token=token1 + token;
col=col1;
state=PROLOG;
}
break;
case PROLOG_DASHES:
if (nextChar == '-') {
addNextChar();
}
 else {
token2=token;
col2=col;
token=""String_Node_Str"";
col=ncol;
state=PROLOG_SPACES;
}
break;
case PROLOG_SPACES:
if (nextChar == ' ') {
addNextChar();
}
 else if (Misc.IsLetter(nextChar)) {
token3=token;
col3=ncol;
token=""String_Node_Str"";
state=PROLOG_ID;
}
 else {
token=token1 + token2;
col=col1;
state=PROLOG;
}
break;
case PROLOG_ID:
if (Misc.IsLetter(nextChar)) {
addNextChar();
}
 else if (token.equals(""String_Node_Str"")) {
token=token1;
col=col1;
TokenOut(Token.PROLOG);
token=token2;
col=col2;
TokenOut(Token.DASHES);
token=""String_Node_Str"";
col=col3;
TokenOut(Token.BUILTIN);
token=""String_Node_Str"";
mdepth=1;
gotoStart();
}
 else {
token=token1 + token2 + token3;
col=col1;
state=PROLOG;
}
break;
case EPILOG:
if (nextChar == '\n') {
TokenOut(Token.EPILOG);
skipNextChar();
startNewLine();
}
 else if (nextChar == '\t') {
TokenOut(Token.EPILOG);
state=DONE;
}
 else {
addNextChar();
}
break;
default :
Debug.ReportBug(""String_Node_Str"");
}
;
}
;
if (hasPcal) {
if (pcalEnd == null) {
pcalEnd=new Position(Integer.MAX_VALUE,0);
}
}
return vspecToArray();
}",0.9985445074306726
135888,"/** 
 * The argument spec is the current tokenized specification, generated by the Tokenize method.  If that spec has a C-Syntax PlusCal algorithm, this method turns ""("", "")"", ""{"", and ""}"" tokens that are PlusCal delimiters (rather than parts of an expression) into the corresponding tokens that produce the appropriate TeX output.   A PlusCal ""("" can follow the following: ""macro"" + IDENT ""procedure"" + an IDENT  ""process"" | ""if"" | ""while"" | ""with"" A PlusCal ""{"" other than the initial one can follow the following: a PlusCal ""{"" a PlusCal "")"" ""else"" | ""either"" | ""or"" | ""define"" ""variable[s]"" [<expression> [, | ;]]^+  "";""   PCAL_LABEL This method also removes an extra gray bar that can appear after the algorithm when using the -shade and -noPcalShade options. The isTeX argument is true if this is called for tla2tex.TeX, in  which case the spec can start anywhere inside a PlusCal algorithm.
 * @param spec
 * @param isTeX  true for tla2tex.TeX, false for tla2tex.TLA
 */
public static void FixPlusCal(Token[][] spec,boolean isTeX){
  if (!hasPcal) {
    return;
  }
  if (Parameters.CommentShading && Parameters.NoPlusCalShading && (pcalEnd.line < spec.length)&& (pcalEnd.item < spec[pcalEnd.line].length)) {
    Token tok=pcalEnd.toToken(spec);
    if (tok.type == Token.COMMENT) {
      CommentToken ctok=(CommentToken)tok;
      if (ctok.string.trim().equals(""String_Node_Str"")) {
        int rsubtype=ctok.rsubtype;
        Token[] newline=new Token[spec[pcalEnd.line].length - 1];
        int j=0;
        for (int i=0; i < spec[pcalEnd.line].length; i++) {
          if (i != pcalEnd.item) {
            newline[j]=spec[pcalEnd.line][i];
            j++;
          }
        }
        if (rsubtype == CommentToken.NORMAL) {
          spec[pcalEnd.line]=newline;
        }
 else {
          if (rsubtype == CommentToken.BEGIN_OVERRUN) {
            Token next=spec[pcalEnd.line + 1][0];
            int nextLine=pcalEnd.line + 1;
            while ((next != null) && (next.type == CommentToken.COMMENT) && (((CommentToken)next).rsubtype == CommentToken.OVERRUN)&& (next.string.trim().equals(""String_Node_Str""))) {
              nextLine++;
              if (spec[nextLine + 1].length > 0) {
                next=spec[nextLine][0];
              }
 else {
                next=null;
              }
            }
            if ((next != null) && (next.type == CommentToken.COMMENT) && (next.string.trim().equals(""String_Node_Str""))&& (((CommentToken)next).rsubtype == CommentToken.END_OVERRUN)) {
              spec[pcalEnd.line]=newline;
              for (int i=pcalEnd.line + 1; i < nextLine; i++) {
                spec[i]=new Token[0];
              }
              newline=new Token[spec[nextLine].length - 1];
              System.arraycopy(spec[nextLine],1,newline,0,spec[nextLine].length - 1);
              spec[nextLine]=newline;
            }
          }
        }
      }
    }
  }
  if (!isCSyntax) {
    return;
  }
  Position pos=pcalStart;
  if (!isTeX) {
    while ((pos != null) && ((pos.toToken(spec).type != Token.BUILTIN) || (!pos.toToken(spec).string.equals(""String_Node_Str"")))) {
      pos=nextTokenPos(pos,spec);
    }
  }
  if (pos != null) {
    pos=ProcessPcalBrace(pos,spec,isTeX);
    System.out.println(""String_Node_Str"" + pos.toString());
  }
  while (isTeX && (pos != null)) {
    pos=ProcessPcalBrace(pos,spec,isTeX);
  }
}","/** 
 * The argument spec is the current tokenized specification, generated by the Tokenize method.  If that spec has a C-Syntax PlusCal algorithm, this method turns ""("", "")"", ""{"", and ""}"" tokens that are PlusCal delimiters (rather than parts of an expression) into the corresponding tokens that produce the appropriate TeX output.   A PlusCal ""("" can follow the following: ""macro"" + IDENT ""procedure"" + an IDENT  ""process"" | ""if"" | ""while"" | ""with"" A PlusCal ""{"" other than the initial one can follow the following: a PlusCal ""{"" a PlusCal "")"" ""else"" | ""either"" | ""or"" | ""define"" ""variable[s]"" [<expression> [, | ;]]^+  "";""   PCAL_LABEL This method also removes an extra gray bar that can appear after the algorithm when using the -shade and -noPcalShade options. The isTeX argument is true if this is called for tla2tex.TeX, in  which case the spec can start anywhere inside a PlusCal algorithm.
 * @param spec
 * @param isTeX  true for tla2tex.TeX, false for tla2tex.TLA
 */
public static void FixPlusCal(Token[][] spec,boolean isTeX){
  if (!hasPcal) {
    return;
  }
  if (Parameters.CommentShading && Parameters.NoPlusCalShading && (pcalEnd.line < spec.length)&& (pcalEnd.item < spec[pcalEnd.line].length)) {
    Token tok=pcalEnd.toToken(spec);
    if (tok.type == Token.COMMENT) {
      CommentToken ctok=(CommentToken)tok;
      if (ctok.string.trim().equals(""String_Node_Str"")) {
        int rsubtype=ctok.rsubtype;
        Token[] newline=new Token[spec[pcalEnd.line].length - 1];
        int j=0;
        for (int i=0; i < spec[pcalEnd.line].length; i++) {
          if (i != pcalEnd.item) {
            newline[j]=spec[pcalEnd.line][i];
            j++;
          }
        }
        if (rsubtype == CommentToken.NORMAL) {
          spec[pcalEnd.line]=newline;
        }
 else {
          if (rsubtype == CommentToken.BEGIN_OVERRUN) {
            Token next=spec[pcalEnd.line + 1][0];
            int nextLine=pcalEnd.line + 1;
            while ((next != null) && (next.type == CommentToken.COMMENT) && (((CommentToken)next).rsubtype == CommentToken.OVERRUN)&& (next.string.trim().equals(""String_Node_Str""))) {
              nextLine++;
              if (spec[nextLine + 1].length > 0) {
                next=spec[nextLine][0];
              }
 else {
                next=null;
              }
            }
            if ((next != null) && (next.type == CommentToken.COMMENT) && (next.string.trim().equals(""String_Node_Str""))&& (((CommentToken)next).rsubtype == CommentToken.END_OVERRUN)) {
              spec[pcalEnd.line]=newline;
              for (int i=pcalEnd.line + 1; i < nextLine; i++) {
                spec[i]=new Token[0];
              }
              newline=new Token[spec[nextLine].length - 1];
              System.arraycopy(spec[nextLine],1,newline,0,spec[nextLine].length - 1);
              spec[nextLine]=newline;
            }
          }
        }
      }
    }
  }
  if (!isCSyntax) {
    return;
  }
  Position pos=pcalStart;
  if (!isTeX) {
    while ((pos != null) && ((pos.toToken(spec).type != Token.BUILTIN) || (!pos.toToken(spec).string.equals(""String_Node_Str"")))) {
      pos=nextTokenPos(pos,spec);
    }
  }
  if (pos != null) {
    pos=ProcessPcalBrace(pos,spec,isTeX);
  }
  while (isTeX && (pos != null)) {
    pos=ProcessPcalBrace(pos,spec,isTeX);
  }
}",0.9910179640718564
135889,"/** 
 * {@inheritDoc}<p> May be extended by subclasses. </p>
 */
public IRegion documentChanged2(DocumentEvent e){
  if (!fIsInitialized)   return null;
  try {
    Assert.isTrue(e.getDocument() == fDocument);
    Position[] category=getPositions();
    IRegion line=fDocument.getLineInformationOfOffset(e.getOffset());
    int reparseStart=line.getOffset();
    if ((pcalStartOffset != -1) && (reparseStart < pcalStartOffset + pcalStartLength) && (pcalStartCommentOffset < reparseStart)) {
      reparseStart=pcalStartCommentOffset;
    }
 else     if ((pcalEndCommentOffset != -1) && (reparseStart < pcalEndCommentOffset + pcalEndCommentLength) && (pcalEndCommentOffset < reparseStart)) {
      reparseStart=pcalEndCommentOffset;
    }
    int newLength=e.getText() == null ? 0 : e.getText().length();
    int partitionStart=-1;
    String contentType=null;
    int first=fDocument.computeIndexInCategory(fPositionCategory,reparseStart);
    if (first > 0) {
      TypedPosition partition=(TypedPosition)category[first - 1];
      if (partition.includes(reparseStart)) {
        partitionStart=partition.getOffset();
        contentType=partition.getType();
        if (e.getOffset() == partition.getOffset() + partition.getLength())         reparseStart=partitionStart;
        --first;
      }
 else       if (reparseStart == e.getOffset() && reparseStart == partition.getOffset() + partition.getLength()) {
        partitionStart=partition.getOffset();
        contentType=partition.getType();
        reparseStart=partitionStart;
        --first;
      }
 else {
        partitionStart=partition.getOffset() + partition.getLength();
        contentType=IDocument.DEFAULT_CONTENT_TYPE;
      }
    }
    int pcalMode=BEFORE_PCAL;
    if (((pcalStartOffset != -1) && (pcalStartOffset <= reparseStart)) && ((pcalEndCommentOffset == -1) || (reparseStart < pcalEndCommentOffset + pcalEndCommentLength))) {
      pcalMode=IN_PCAL;
    }
 else     if ((pcalEndCommentOffset != -1) && (pcalEndCommentOffset + pcalEndCommentLength <= reparseStart)) {
      pcalMode=AFTER_PCAL;
    }
    fPositionUpdater.update(e);
    for (int i=first; i < category.length; i++) {
      Position p=category[i];
      if (p.isDeleted) {
        rememberDeletedOffset(e.getOffset());
        break;
      }
    }
    clearPositionCache();
    category=getPositions();
    fScanner.setPartialRange(fDocument,reparseStart,fDocument.getLength() - reparseStart,contentType,partitionStart,pcalMode);
    int behindLastScannedPosition=reparseStart;
    IToken token=fScanner.nextToken();
    int Delta=newLength - e.getLength();
    boolean prevPcal=(pcalStartCommentOffset != -1);
    int prevAfterPcal=0;
    if (prevPcal) {
      if (pcalEndCommentOffset == -1) {
        prevAfterPcal=Integer.MAX_VALUE;
      }
 else {
        int tmp=pcalEndCommentOffset + pcalEndCommentLength;
        if (e.getOffset() <= tmp) {
          prevAfterPcal=tmp + Delta;
        }
 else {
          prevAfterPcal=tmp;
        }
      }
    }
    pcalStartCommentOffset=convertOffset(pcalStartCommentOffset,pcalStartOffset - pcalStartCommentOffset,e.getOffset(),e.getLength(),newLength);
    pcalStartOffset=convertOffset(pcalStartOffset,pcalStartLength,e.getOffset(),e.getLength(),newLength);
    pcalEndCommentOffset=convertOffset(pcalEndCommentOffset,pcalEndCommentLength,e.getOffset(),e.getLength(),newLength);
    int state;
    boolean canStop;
    if (pcalMode == BEFORE_PCAL) {
      canStop=(!prevPcal) || ((pcalStartCommentOffset != -1) && (pcalStartOffset != -1)) || (reparseStart >= prevAfterPcal);
      state=SEEK_ALGORITHM;
    }
 else     if (pcalMode == AFTER_PCAL) {
      canStop=true;
      state=AFTER_ALGORITHM;
    }
 else {
      canStop=(pcalEndCommentOffset != -1);
      state=IN_ALGORITHM;
    }
    while (!token.isEOF()) {
      contentType=getTokenContentType(token);
      if (!isSupportedContentType(contentType)) {
        if ((state == IN_ALGORITHM) || (state == START_ALGORITHM)) {
          contentType=TLAPartitionScanner.TLA_PCAL;
        }
 else {
          token=fScanner.nextToken();
          continue;
        }
      }
      int start=fScanner.getTokenOffset();
      int length=fScanner.getTokenLength();
      behindLastScannedPosition=start + length;
      int lastScannedPosition=behindLastScannedPosition - 1;
switch (state) {
case SEEK_ALGORITHM:
        if (contentType.equals(TLAPartitionScanner.TLA_START_PCAL_COMMENT)) {
          pcalStartCommentOffset=start;
          pcalStartOffset=behindLastScannedPosition;
          contentType=TLAPartitionScanner.TLA_MULTI_LINE_COMMENT;
          state=START_ALGORITHM;
        }
 else         if (contentType.equals(TLAPartitionScanner.TLA_END_PCAL_COMMENT)) {
          System.out.println(""String_Node_Str"");
        }
 else {
          canStop=canStop || (behindLastScannedPosition >= prevAfterPcal);
        }
      break;
case START_ALGORITHM:
    pcalStartLength=length;
  canStop=(pcalEndCommentOffset != -1);
state=IN_ALGORITHM;
if (pcalStartOffset != start) {
System.out.println(""String_Node_Str"");
}
if (!contentType.equals(TLAPartitionScanner.TLA_PCAL)) {
System.out.println(""String_Node_Str"");
}
break;
case IN_ALGORITHM:
if (contentType.equals(TLAPartitionScanner.TLA_END_PCAL_COMMENT)) {
canStop=(behindLastScannedPosition >= prevAfterPcal);
pcalEndCommentOffset=start;
pcalEndCommentLength=length;
contentType=TLAPartitionScanner.TLA_MULTI_LINE_COMMENT;
state=AFTER_ALGORITHM;
}
 else if (contentType.equals(TLAPartitionScanner.TLA_START_PCAL_COMMENT)) {
System.out.println(""String_Node_Str"");
}
break;
case AFTER_ALGORITHM:
if (contentType.equals(TLAPartitionScanner.TLA_START_PCAL_COMMENT) || contentType.equals(TLAPartitionScanner.TLA_END_PCAL_COMMENT)) {
System.out.println(""String_Node_Str"");
}
canStop=canStop || (behindLastScannedPosition >= prevAfterPcal);
break;
default :
System.out.println(""String_Node_Str"");
}
while (first < category.length) {
TypedPosition p=(TypedPosition)category[first];
if (lastScannedPosition >= p.offset + p.length || (p.overlapsWith(start,length) && (!fDocument.containsPosition(fPositionCategory,start,length) || !contentType.equals(p.getType())))) {
rememberRegion(p.offset,p.length);
fDocument.removePosition(fPositionCategory,p);
++first;
}
 else break;
}
if (fDocument.containsPosition(fPositionCategory,start,length)) {
if ((lastScannedPosition >= e.getOffset() + newLength) && canStop) {
return createRegion();
}
++first;
}
 else {
try {
fDocument.addPosition(fPositionCategory,new TypedPosition(start,length,contentType));
rememberRegion(start,length);
}
 catch (BadPositionCategoryException x) {
}
catch (BadLocationException x) {
}
}
token=fScanner.nextToken();
}
switch (state) {
case SEEK_ALGORITHM:
pcalStartCommentOffset=-1;
pcalStartOffset=-1;
pcalEndCommentOffset=-1;
break;
case START_ALGORITHM:
System.out.println(""String_Node_Str"");
break;
case IN_ALGORITHM:
pcalEndCommentOffset=-1;
break;
}
first=fDocument.computeIndexInCategory(fPositionCategory,behindLastScannedPosition);
clearPositionCache();
category=getPositions();
TypedPosition p;
while (first < category.length) {
p=(TypedPosition)category[first++];
fDocument.removePosition(fPositionCategory,p);
rememberRegion(p.offset,p.length);
}
}
 catch (BadPositionCategoryException x) {
}
catch (BadLocationException x) {
}
 finally {
clearPositionCache();
}
return createRegion();
}","/** 
 * {@inheritDoc}<p> May be extended by subclasses. </p>
 */
public IRegion documentChanged2(DocumentEvent e){
  if (!fIsInitialized)   return null;
  try {
    Assert.isTrue(e.getDocument() == fDocument);
    Position[] category=getPositions();
    IRegion line=fDocument.getLineInformationOfOffset(e.getOffset());
    int reparseStart=line.getOffset();
    if ((pcalStartOffset != -1) && (reparseStart < pcalStartOffset + pcalStartLength) && (pcalStartCommentOffset < reparseStart)) {
      reparseStart=pcalStartCommentOffset;
    }
 else     if ((pcalEndCommentOffset != -1) && (reparseStart < pcalEndCommentOffset + pcalEndCommentLength) && (pcalEndCommentOffset < reparseStart)) {
      reparseStart=pcalEndCommentOffset;
    }
    int newLength=e.getText() == null ? 0 : e.getText().length();
    int partitionStart=-1;
    String contentType=null;
    int first=fDocument.computeIndexInCategory(fPositionCategory,reparseStart);
    if (first > 0) {
      TypedPosition partition=(TypedPosition)category[first - 1];
      if (partition.includes(reparseStart)) {
        partitionStart=partition.getOffset();
        contentType=partition.getType();
        if (e.getOffset() == partition.getOffset() + partition.getLength())         reparseStart=partitionStart;
        --first;
      }
 else       if (reparseStart == e.getOffset() && reparseStart == partition.getOffset() + partition.getLength()) {
        partitionStart=partition.getOffset();
        contentType=partition.getType();
        reparseStart=partitionStart;
        --first;
      }
 else {
        partitionStart=partition.getOffset() + partition.getLength();
        contentType=IDocument.DEFAULT_CONTENT_TYPE;
      }
    }
    int pcalMode=BEFORE_PCAL;
    if (((pcalStartOffset != -1) && (pcalStartOffset <= reparseStart)) && ((pcalEndCommentOffset == -1) || (reparseStart < pcalEndCommentOffset + pcalEndCommentLength))) {
      pcalMode=IN_PCAL;
    }
 else     if ((pcalEndCommentOffset != -1) && (pcalEndCommentOffset + pcalEndCommentLength <= reparseStart)) {
      pcalMode=AFTER_PCAL;
    }
    fPositionUpdater.update(e);
    for (int i=first; i < category.length; i++) {
      Position p=category[i];
      if (p.isDeleted) {
        rememberDeletedOffset(e.getOffset());
        break;
      }
    }
    clearPositionCache();
    category=getPositions();
    fScanner.setPartialRange(fDocument,reparseStart,fDocument.getLength() - reparseStart,contentType,partitionStart,pcalMode);
    int behindLastScannedPosition=reparseStart;
    IToken token=fScanner.nextToken();
    int Delta=newLength - e.getLength();
    boolean prevPcal=(pcalStartCommentOffset != -1);
    int prevAfterPcal=0;
    if (prevPcal) {
      if (pcalEndCommentOffset == -1) {
        prevAfterPcal=Integer.MAX_VALUE;
      }
 else {
        int tmp=pcalEndCommentOffset + pcalEndCommentLength;
        if (e.getOffset() <= tmp) {
          prevAfterPcal=tmp + Delta;
        }
 else {
          prevAfterPcal=tmp;
        }
      }
    }
    pcalStartCommentOffset=convertOffset(pcalStartCommentOffset,pcalStartOffset - pcalStartCommentOffset,e.getOffset(),e.getLength(),newLength);
    pcalStartOffset=convertOffset(pcalStartOffset,pcalStartLength,e.getOffset(),e.getLength(),newLength);
    pcalEndCommentOffset=convertOffset(pcalEndCommentOffset,pcalEndCommentLength,e.getOffset(),e.getLength(),newLength);
    int state;
    boolean canStop;
    if (pcalMode == BEFORE_PCAL) {
      canStop=(!prevPcal) || ((pcalStartCommentOffset != -1) && (pcalStartOffset != -1)) || (reparseStart >= prevAfterPcal);
      state=SEEK_ALGORITHM;
    }
 else     if (pcalMode == AFTER_PCAL) {
      canStop=true;
      state=AFTER_ALGORITHM;
    }
 else {
      canStop=(pcalEndCommentOffset != -1);
      state=IN_ALGORITHM;
    }
    while (!token.isEOF()) {
      contentType=getTokenContentType(token);
      if (!isSupportedContentType(contentType)) {
        if ((state == IN_ALGORITHM) || (state == START_ALGORITHM)) {
          contentType=TLAPartitionScanner.TLA_PCAL;
        }
 else {
          token=fScanner.nextToken();
          continue;
        }
      }
      int start=fScanner.getTokenOffset();
      int length=fScanner.getTokenLength();
      behindLastScannedPosition=start + length;
      int lastScannedPosition=behindLastScannedPosition - 1;
switch (state) {
case SEEK_ALGORITHM:
        if (contentType.equals(TLAPartitionScanner.TLA_START_PCAL_COMMENT)) {
          pcalStartCommentOffset=start;
          pcalStartOffset=behindLastScannedPosition;
          contentType=TLAPartitionScanner.TLA_MULTI_LINE_COMMENT;
          state=START_ALGORITHM;
        }
 else         if (contentType.equals(TLAPartitionScanner.TLA_END_PCAL_COMMENT)) {
          System.out.println(""String_Node_Str"");
        }
 else {
          canStop=canStop || (behindLastScannedPosition >= prevAfterPcal);
        }
      break;
case START_ALGORITHM:
    pcalStartLength=length;
  canStop=(pcalEndCommentOffset != -1);
state=IN_ALGORITHM;
if (pcalStartOffset != start) {
System.out.println(""String_Node_Str"");
}
if (!contentType.equals(TLAPartitionScanner.TLA_PCAL)) {
System.out.println(""String_Node_Str"");
}
break;
case IN_ALGORITHM:
if (contentType.equals(TLAPartitionScanner.TLA_END_PCAL_COMMENT)) {
canStop=(behindLastScannedPosition >= prevAfterPcal);
pcalEndCommentOffset=start;
pcalEndCommentLength=length;
contentType=TLAPartitionScanner.TLA_MULTI_LINE_COMMENT;
state=AFTER_ALGORITHM;
}
 else if (contentType.equals(TLAPartitionScanner.TLA_START_PCAL_COMMENT)) {
System.out.println(""String_Node_Str"");
}
break;
case AFTER_ALGORITHM:
if (contentType.equals(TLAPartitionScanner.TLA_START_PCAL_COMMENT) || contentType.equals(TLAPartitionScanner.TLA_END_PCAL_COMMENT)) {
System.out.println(""String_Node_Str"");
}
canStop=canStop || (behindLastScannedPosition >= prevAfterPcal);
break;
default :
System.out.println(""String_Node_Str"");
}
while (first < category.length) {
TypedPosition p=(TypedPosition)category[first];
if (lastScannedPosition >= p.offset + p.length || (p.overlapsWith(start,length) && (!fDocument.containsPosition(fPositionCategory,start,length) || !contentType.equals(p.getType())))) {
rememberRegion(p.offset,p.length);
fDocument.removePosition(fPositionCategory,p);
++first;
}
 else break;
}
if (fDocument.containsPosition(fPositionCategory,start,length)) {
if ((lastScannedPosition >= e.getOffset() + newLength) && canStop) {
finishScan(state);
return createRegion();
}
++first;
}
 else {
try {
fDocument.addPosition(fPositionCategory,new TypedPosition(start,length,contentType));
rememberRegion(start,length);
}
 catch (BadPositionCategoryException x) {
}
catch (BadLocationException x) {
}
}
token=fScanner.nextToken();
}
finishScan(state);
first=fDocument.computeIndexInCategory(fPositionCategory,behindLastScannedPosition);
clearPositionCache();
category=getPositions();
TypedPosition p;
while (first < category.length) {
p=(TypedPosition)category[first++];
fDocument.removePosition(fPositionCategory,p);
rememberRegion(p.offset,p.length);
}
}
 catch (BadPositionCategoryException x) {
}
catch (BadLocationException x) {
}
 finally {
clearPositionCache();
}
return createRegion();
}",0.9812826864849986
135890,"/** 
 * get partitions  
 */
protected void calculatePositions(){
  try {
    IDocumentExtension3 extension=(IDocumentExtension3)document;
    ITypedRegion[] partitions=extension.computePartitioning(TLAPartitionScanner.TLA_PARTITIONING,0,document.getLength(),false);
    for (int i=0; i < partitions.length; i++) {
      IRegion lineOnPartitionStart=document.getLineInformationOfOffset(partitions[i].getOffset());
      if ((partitions[i].getType().equals(TLAPartitionScanner.TLA_MULTI_LINE_COMMENT) || partitions[i].getType().equals(TLAPartitionScanner.TLA_PCAL)) && partitions[i].getLength() > lineOnPartitionStart.getLength()) {
        positions.add(new Position(partitions[i].getOffset(),partitions[i].getLength()));
      }
    }
  }
 catch (  BadLocationException e) {
    e.printStackTrace();
  }
catch (  BadPartitioningException e) {
    e.printStackTrace();
  }
}","/** 
 * get partitions  
 */
protected void calculatePositions(){
  try {
    IDocumentExtension3 extension=(IDocumentExtension3)document;
    ITypedRegion[] partitions=extension.computePartitioning(TLAPartitionScanner.TLA_PARTITIONING,0,document.getLength(),false);
    for (int i=0; i < partitions.length; i++) {
      IRegion lineOnPartitionStart=document.getLineInformationOfOffset(partitions[i].getOffset());
      if ((partitions[i].getType().equals(TLAPartitionScanner.TLA_MULTI_LINE_COMMENT)) && partitions[i].getLength() > lineOnPartitionStart.getLength()) {
        positions.add(new Position(partitions[i].getOffset(),partitions[i].getLength()));
      }
    }
  }
 catch (  BadLocationException e) {
    e.printStackTrace();
  }
catch (  BadPartitioningException e) {
    e.printStackTrace();
  }
}",0.9619952494061758
135891,"/** 
 * @param args
 */
public static void runTranslation(String[] args){
  long startTime=Debug.now();
  ToolIO.out.println(version);
  GetArguments(args);
  Starting(""String_Node_Str"");
  BuiltInSymbols.Initialize();
  Finished(""String_Node_Str"");
  FileCharReader testlr=new FileCharReader(Parameters.TLAInputFile);
  Starting(""String_Node_Str"");
  Token[][] spec=TokenizeSpec.Tokenize(testlr,TokenizeSpec.MODULE);
  Token.FindPfStepTokens(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  TokenizeSpec.FixPlusCal(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  CommentToken.ProcessComments(spec);
  Finished(""String_Node_Str"");
  Debug.print2DArray(spec,""String_Node_Str"");
  Starting(""String_Node_Str"");
  FormatComments.Initialize();
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  FindAlignments.FindAlignments(spec);
  Finished(""String_Node_Str"");
  if (Parameters.TLAOut) {
    WriteTLAFile.Write(spec,Parameters.TLAOutFile);
    ToolIO.out.println(""String_Node_Str"" + Parameters.TLAOutFile);
  }
  ;
  Starting(""String_Node_Str"");
  LaTeXOutput.WriteAlignmentFile(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  LaTeXOutput.RunLaTeX(Parameters.LaTeXAlignmentFile);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  LaTeXOutput.SetDimensions(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  LaTeXOutput.WriteLaTeXFile(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  LaTeXOutput.RunLaTeX(Parameters.LaTeXOutputFile);
  Finished(""String_Node_Str"");
  ToolIO.out.println(""String_Node_Str"" + Parameters.LatexOutputExt + ""String_Node_Str""+ Parameters.LaTeXOutputFile+ ""String_Node_Str""+ Parameters.LatexOutputExt+ ((Parameters.MetaDir.equals(""String_Node_Str"")) ? ""String_Node_Str"" : ""String_Node_Str"" + Parameters.MetaDir)+ ""String_Node_Str"");
  if (Parameters.PSOutput) {
    Starting(""String_Node_Str"");
    MakePSFile();
    Finished(""String_Node_Str"");
    ToolIO.out.println(""String_Node_Str"" + Parameters.LaTeXOutputFile + ""String_Node_Str""+ Parameters.LaTeXOutputFile+ ""String_Node_Str"");
  }
  if (!Parameters.MetaDir.equals(""String_Node_Str"")) {
    try {
      FileUtil.copyFile(LaTeXOutput.prependMetaDirToFileName(Parameters.LaTeXOutputFile + ""String_Node_Str"" + Parameters.LatexOutputExt),Parameters.TLAInputFile.substring(0,Parameters.TLAInputFile.length() - ""String_Node_Str"".length()) + Parameters.LatexOutputExt);
    }
 catch (    IOException e) {
      Debug.ReportError(""String_Node_Str"" + e.getMessage());
    }
  }
  Debug.printElapsedTime(startTime,""String_Node_Str"");
}","/** 
 * @param args
 */
public static void runTranslation(String[] args){
  long startTime=Debug.now();
  ToolIO.out.println(version);
  GetArguments(args);
  Starting(""String_Node_Str"");
  BuiltInSymbols.Initialize();
  Finished(""String_Node_Str"");
  FileCharReader testlr=new FileCharReader(Parameters.TLAInputFile);
  Starting(""String_Node_Str"");
  Token[][] spec=TokenizeSpec.Tokenize(testlr,TokenizeSpec.MODULE);
  Token.FindPfStepTokens(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  TokenizeSpec.FixPlusCal(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  CommentToken.ProcessComments(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  FormatComments.Initialize();
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  FindAlignments.FindAlignments(spec);
  Finished(""String_Node_Str"");
  if (Parameters.TLAOut) {
    WriteTLAFile.Write(spec,Parameters.TLAOutFile);
    ToolIO.out.println(""String_Node_Str"" + Parameters.TLAOutFile);
  }
  ;
  Starting(""String_Node_Str"");
  LaTeXOutput.WriteAlignmentFile(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  LaTeXOutput.RunLaTeX(Parameters.LaTeXAlignmentFile);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  LaTeXOutput.SetDimensions(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  LaTeXOutput.WriteLaTeXFile(spec);
  Finished(""String_Node_Str"");
  Starting(""String_Node_Str"");
  LaTeXOutput.RunLaTeX(Parameters.LaTeXOutputFile);
  Finished(""String_Node_Str"");
  ToolIO.out.println(""String_Node_Str"" + Parameters.LatexOutputExt + ""String_Node_Str""+ Parameters.LaTeXOutputFile+ ""String_Node_Str""+ Parameters.LatexOutputExt+ ((Parameters.MetaDir.equals(""String_Node_Str"")) ? ""String_Node_Str"" : ""String_Node_Str"" + Parameters.MetaDir)+ ""String_Node_Str"");
  if (Parameters.PSOutput) {
    Starting(""String_Node_Str"");
    MakePSFile();
    Finished(""String_Node_Str"");
    ToolIO.out.println(""String_Node_Str"" + Parameters.LaTeXOutputFile + ""String_Node_Str""+ Parameters.LaTeXOutputFile+ ""String_Node_Str"");
  }
  if (!Parameters.MetaDir.equals(""String_Node_Str"")) {
    try {
      FileUtil.copyFile(LaTeXOutput.prependMetaDirToFileName(Parameters.LaTeXOutputFile + ""String_Node_Str"" + Parameters.LatexOutputExt),Parameters.TLAInputFile.substring(0,Parameters.TLAInputFile.length() - ""String_Node_Str"".length()) + Parameters.LatexOutputExt);
    }
 catch (    IOException e) {
      Debug.ReportError(""String_Node_Str"" + e.getMessage());
    }
  }
  Debug.printElapsedTime(startTime,""String_Node_Str"");
}",0.9912113106610624
135892,"/** 
 * The argument spec is the current tokenized specification, generated by the Tokenize method.  If that spec has a C-Syntax PlusCal algorithm, this method turns ""("", "")"", ""{"", and ""}"" tokens that are PlusCal delimiters (rather than parts of an expression) into the corresponding tokens that produce the appropriate TeX output.   A PlusCal ""("" can follow the following: ""macro"" + IDENT ""procedure"" + an IDENT  ""process"" | ""if"" | ""while"" | ""with"" A PlusCal ""{"" other than the initial one can follow the following: a PlusCal ""{"" a PlusCal "")"" ""else"" | ""either"" | ""or"" | ""define"" ""variable[s]"" [<expression> [, | ;]]^+  "";""   PCAL_LABEL
 * @param spec
 */
public static void FixPlusCal(Token[][] spec){
  if ((!hasPcal) || (!isCSyntax)) {
    return;
  }
  Position pos=pcalStart;
  while ((pos != null) && ((pos.toToken(spec).type != Token.BUILTIN) || (!pos.toToken(spec).string.equals(""String_Node_Str"")))) {
    pos=nextTokenPos(pos,spec);
  }
  if (pos != null) {
    ProcessPcalBrace(pos,spec);
  }
}","/** 
 * The argument spec is the current tokenized specification, generated by the Tokenize method.  If that spec has a C-Syntax PlusCal algorithm, this method turns ""("", "")"", ""{"", and ""}"" tokens that are PlusCal delimiters (rather than parts of an expression) into the corresponding tokens that produce the appropriate TeX output.   A PlusCal ""("" can follow the following: ""macro"" + IDENT ""procedure"" + an IDENT  ""process"" | ""if"" | ""while"" | ""with"" A PlusCal ""{"" other than the initial one can follow the following: a PlusCal ""{"" a PlusCal "")"" ""else"" | ""either"" | ""or"" | ""define"" ""variable[s]"" [<expression> [, | ;]]^+  "";""   PCAL_LABEL This method also removes an extra gray bar that can appear after the algorithm when using the -shade and -noPcalShade options.
 * @param spec
 */
public static void FixPlusCal(Token[][] spec){
  if (!hasPcal) {
    return;
  }
  if (Parameters.CommentShading && Parameters.NoPlusCalShading && (pcalEnd.line < spec.length)&& (pcalEnd.item < spec[pcalEnd.line].length)) {
    Token tok=pcalEnd.toToken(spec);
    if (tok.type == Token.COMMENT) {
      CommentToken ctok=(CommentToken)tok;
      if (ctok.string.trim().equals(""String_Node_Str"")) {
        int rsubtype=ctok.rsubtype;
        Token[] newline=new Token[spec[pcalEnd.line].length - 1];
        int j=0;
        for (int i=0; i < spec[pcalEnd.line].length; i++) {
          if (i != pcalEnd.item) {
            newline[j]=spec[pcalEnd.line][i];
            j++;
          }
        }
        if (rsubtype == CommentToken.NORMAL) {
          spec[pcalEnd.line]=newline;
        }
 else {
          if (rsubtype == CommentToken.BEGIN_OVERRUN) {
            Token next=spec[pcalEnd.line + 1][0];
            int nextLine=pcalEnd.line + 1;
            while ((next != null) && (next.type == CommentToken.COMMENT) && (((CommentToken)next).rsubtype == CommentToken.OVERRUN)&& (next.string.trim().equals(""String_Node_Str""))) {
              nextLine++;
              if (spec[nextLine + 1].length > 0) {
                next=spec[nextLine][0];
              }
 else {
                next=null;
              }
            }
            if ((next != null) && (next.type == CommentToken.COMMENT) && (next.string.trim().equals(""String_Node_Str""))&& (((CommentToken)next).rsubtype == CommentToken.END_OVERRUN)) {
              spec[pcalEnd.line]=newline;
              for (int i=pcalEnd.line + 1; i < nextLine; i++) {
                spec[i]=new Token[0];
              }
              newline=new Token[spec[nextLine].length - 1];
              System.arraycopy(spec[nextLine],1,newline,0,spec[nextLine].length - 1);
              spec[nextLine]=newline;
            }
          }
        }
      }
    }
  }
  if (!isCSyntax) {
    return;
  }
  Position pos=pcalStart;
  while ((pos != null) && ((pos.toToken(spec).type != Token.BUILTIN) || (!pos.toToken(spec).string.equals(""String_Node_Str"")))) {
    pos=nextTokenPos(pos,spec);
  }
  if (pos != null) {
    ProcessPcalBrace(pos,spec);
  }
}",0.5021297920320722
135893,"/** 
 * This is called with parenthesize = true only during the initial parsing  phase (the execution of ParseAlgorithm.getAlgorithm).  It is called with  parenthesize = false by: PcalFixIDs.FixExpr : replaces the string of an IDENT token with a new one to perform renaming in case of name conflicts. PcalTLAGen.AddSubscriptsToExpr: adds the primes and ""[self]"" subscripts to variables when needed.
 * @param exprs
 * @param strs
 * @param parenthesize
 * @throws TLAExprException
 */
public void substituteForAll(Vector exprs,Vector strs,boolean parenthesize) throws TLAExprException {
  int i=0;
  while (i < exprs.size()) {
    TLAExpr exp=(TLAExpr)exprs.elementAt(i);
    String st=(String)strs.elementAt(i);
    substituteFor(exp,st,parenthesize);
    i=i + 1;
  }
  ;
  return;
}","/** 
 * @param exprs
 * @param strs
 * @param parenthesize
 * @throws TLAExprException
 */
public void substituteForAll(Vector exprs,Vector strs,boolean parenthesize) throws TLAExprException {
  TLAExpr[] expArray=new TLAExpr[exprs.size()];
  String[] strArray=new String[strs.size()];
  IntPair[] nextArray=new IntPair[expArray.length];
  for (int i=0; i < nextArray.length; i++) {
    expArray[i]=(TLAExpr)exprs.elementAt(i);
    strArray[i]=(String)strs.elementAt(i);
    nextArray[i]=findNextInstanceIn(strArray[i],new IntPair(0,0));
  }
  boolean notDone=true;
  while (notDone) {
    IntPair nextPos=null;
    int nextIdx=-1;
    for (int i=0; i < nextArray.length; i++) {
      IntPair pos=nextArray[i];
      if (pos != null) {
        if (nextPos == null) {
          nextPos=pos;
          nextIdx=i;
        }
 else         if ((pos.one < nextPos.one) || ((pos.one == nextPos.one) && (pos.two < nextPos.two))) {
          nextPos=pos;
          nextIdx=i;
        }
      }
    }
    if (nextPos == null) {
      notDone=false;
    }
 else {
      IntPair afterNextPos=stepCoord(nextPos,1);
      IntPair newPos=substituteAt(expArray[nextIdx],nextPos,parenthesize);
      nextArray[nextIdx]=(newPos == null) ? null : findNextInstanceIn(strArray[nextIdx],newPos);
      for (int i=0; i < nextArray.length; i++) {
        if ((i != nextIdx) && (nextArray[i] != null)) {
          Debug.Assert(newPos != null,""String_Node_Str"");
          if (afterNextPos.one == newPos.one) {
            if (nextArray[i].one == nextPos.one) {
              nextArray[i].two=nextArray[i].two + (newPos.two - afterNextPos.two);
              Debug.Assert(nextArray[i].two > nextPos.two,""String_Node_Str"");
            }
          }
 else {
            if (nextArray[i].one == nextPos.one) {
              nextArray[i].one=nextArray[i].one + (newPos.one - afterNextPos.one);
              Debug.Assert(nextArray[i].two > nextPos.two,""String_Node_Str"");
              nextArray[i].two=nextArray[i].two + (newPos.two - afterNextPos.two);
            }
 else {
              nextArray[i].one=nextArray[i].one + (newPos.one - afterNextPos.one);
            }
          }
        }
      }
    }
  }
  return;
}",0.0476350218047635
135894,"/** 
 * @return the collisions
 */
public long getCollisions(){
  return collisions;
}","/** 
 * @return the collisions
 */
public long getCollisions(){
  return collisions == 0 ? 1 : collisions;
}",0.8865979381443299
135895,"/** 
 * Returns the error message for printError(EC.GENERAL, cause, throwable)
 * @param cause
 * @param throwable
 * @return
 */
public static String ECGeneralMsg(String cause,Throwable throwable){
  String msg=""String_Node_Str"" + throwable.getClass().getName();
  if (throwable.getMessage() != null) {
    msg=msg + ""String_Node_Str"" + throwable.getMessage();
  }
  msg=msg + ""String_Node_Str"";
  if (cause.equals(""String_Node_Str"")) {
    msg=msg + ""String_Node_Str"";
  }
 else {
    msg=msg + ""String_Node_Str"" + cause+ ""String_Node_Str"";
  }
  return msg;
}","/** 
 * Returns the error message for printError(EC.GENERAL, cause, throwable) Created by LL on 7 April 2012.   Modified by LL on 24 April 2012 because, for some errors, throwable.getMessage() contains a nested error message, and the Toolbox's code for parsing TLC output apparently cannot handle a nested error message containing text before and after it.  So I put all the additional message text before throwable.getMessage().
 * @param cause
 * @param throwable
 * @return
 */
public static String ECGeneralMsg(String cause,Throwable throwable){
  String msg=""String_Node_Str"";
  msg=msg + ""String_Node_Str"";
  if (cause.equals(""String_Node_Str"")) {
    msg=msg + ""String_Node_Str"";
  }
 else {
    msg=msg + ""String_Node_Str"" + cause+ ""String_Node_Str"";
  }
  msg=msg + ""String_Node_Str"" + throwable.getClass().getName();
  if (throwable.getMessage() != null) {
    msg=msg + ""String_Node_Str"" + throwable.getMessage();
  }
  return msg;
}",0.4926958831341301
135896,"public Object execute(ExecutionEvent event) throws ExecutionException {
  Spec spec=ToolboxHandle.getCurrentSpec();
  if (spec == null) {
    return null;
  }
  String oldModuleName=spec.getModuleToShow();
  if (oldModuleName != null) {
    IResource resource=ResourceHelper.getResourceByModuleName(oldModuleName);
    if (resource != null) {
      try {
        resource.deleteMarkers(SHOW_USE_MARKER_TYPE,false,99);
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
      spec.setMarkersToShow(null);
    }
  }
  TLAEditor tlaEditor=EditorUtil.getTLAEditorWithFocus();
  if (tlaEditor == null) {
    return null;
  }
  String moduleName=tlaEditor.getModuleName();
  ModuleNode moduleNode=ResourceHelper.getModuleNode(moduleName);
  if (moduleNode == null) {
    return null;
  }
  TokenSpec currentTokenSpec=TokenSpec.findCurrentTokenSpec();
  if (currentTokenSpec == null || currentTokenSpec.resolvedSymbol == null) {
    return null;
  }
  SymbolNode resolvedSymbol=currentTokenSpec.resolvedSymbol;
  String[] tempModuleNames=ResourceHelper.getModuleNames();
  int numberOfModulesUsedIn=0;
  SemanticNode[][] tempUsesArray=new SemanticNode[tempModuleNames.length][];
  for (int i=0; i < tempModuleNames.length; i++) {
    tempUsesArray[i]=ResourceHelper.getUsesOfSymbol(resolvedSymbol,ResourceHelper.getModuleNode(tempModuleNames[i]));
    if ((tempUsesArray[i] != null) && (tempUsesArray[i].length > 0)) {
      numberOfModulesUsedIn++;
    }
  }
  if (numberOfModulesUsedIn == 0) {
    MessageDialog.openWarning(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + resolvedSymbol.getName());
    return null;
  }
  SemanticNode[][] usesArray=new SemanticNode[numberOfModulesUsedIn][];
  String[] moduleNames=new String[numberOfModulesUsedIn];
  int j=0;
  for (int i=0; i < tempModuleNames.length; i++) {
    if ((tempUsesArray[i] != null) && (tempUsesArray[i].length > 0)) {
      usesArray[j]=tempUsesArray[i];
      moduleNames[j]=tempModuleNames[i];
      j++;
    }
  }
  j=-1;
  for (int i=0; i < moduleNames.length; i++) {
    if (moduleName.equals(moduleNames[i])) {
      j=i;
      break;
    }
  }
  if (j > 0) {
    SemanticNode[] savedUses=usesArray[j];
    for (int i=j - 1; i > -1; i--) {
      usesArray[i + 1]=usesArray[i];
      moduleNames[i + 1]=moduleNames[i];
    }
    usesArray[0]=savedUses;
    moduleNames[0]=moduleName;
  }
  String moduleToShow=null;
  if (moduleNames.length > 1) {
    Shell parent=UIHelper.getShellProvider().getShell();
    ShowUsesPopupDialog popup=new ShowUsesPopupDialog(parent,moduleNames,usesArray);
    popup.open();
  }
 else {
    moduleToShow=moduleName;
    spec.setModuleToShow(moduleToShow);
    int moduleIndex=-1;
    for (int i=0; i < moduleNames.length; i++) {
      if (moduleNames[i].equals(moduleToShow)) {
        moduleIndex=i;
        break;
      }
    }
    if (moduleIndex < 0) {
      Activator.logDebug(""String_Node_Str"" + ""String_Node_Str"");
      return null;
    }
    SemanticNode[] uses=usesArray[moduleIndex];
    setUseMarkers(uses,moduleName,spec);
  }
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  Spec spec=ToolboxHandle.getCurrentSpec();
  if (spec == null) {
    return null;
  }
  String oldModuleName=spec.getModuleToShow();
  if (oldModuleName != null) {
    IResource resource=ResourceHelper.getResourceByModuleName(oldModuleName);
    if (resource != null) {
      try {
        resource.deleteMarkers(SHOW_USE_MARKER_TYPE,false,99);
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
      spec.setMarkersToShow(null);
    }
  }
  TLAEditor tlaEditor=EditorUtil.getTLAEditorWithFocus();
  if (tlaEditor == null) {
    return null;
  }
  String moduleName=tlaEditor.getModuleName();
  ModuleNode moduleNode=ResourceHelper.getModuleNode(moduleName);
  if (moduleNode == null) {
    return null;
  }
  TokenSpec currentTokenSpec=TokenSpec.findCurrentTokenSpec();
  if (currentTokenSpec == null || currentTokenSpec.resolvedSymbol == null) {
    return null;
  }
  SymbolNode resolvedSymbol=currentTokenSpec.resolvedSymbol;
  String[] tempModuleNames=ResourceHelper.getModuleNames();
  int numberOfModulesUsedIn=0;
  SemanticNode[][] tempUsesArray=new SemanticNode[tempModuleNames.length][];
  for (int i=0; i < tempModuleNames.length; i++) {
    tempUsesArray[i]=ResourceHelper.getUsesOfSymbol(resolvedSymbol,ResourceHelper.getModuleNode(tempModuleNames[i]));
    if ((tempUsesArray[i] != null) && (tempUsesArray[i].length > 0)) {
      numberOfModulesUsedIn++;
    }
  }
  if (numberOfModulesUsedIn == 0) {
    MessageDialog.openWarning(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"" + resolvedSymbol.getName());
    return null;
  }
  SemanticNode[][] usesArray=new SemanticNode[numberOfModulesUsedIn][];
  String[] moduleNames=new String[numberOfModulesUsedIn];
  int j=0;
  for (int i=0; i < tempModuleNames.length; i++) {
    if ((tempUsesArray[i] != null) && (tempUsesArray[i].length > 0)) {
      usesArray[j]=tempUsesArray[i];
      moduleNames[j]=tempModuleNames[i];
      j++;
    }
  }
  j=-1;
  for (int i=0; i < moduleNames.length; i++) {
    if (moduleName.equals(moduleNames[i])) {
      j=i;
      break;
    }
  }
  if (j > 0) {
    SemanticNode[] savedUses=usesArray[j];
    for (int i=j - 1; i > -1; i--) {
      usesArray[i + 1]=usesArray[i];
      moduleNames[i + 1]=moduleNames[i];
    }
    usesArray[0]=savedUses;
    moduleNames[0]=moduleName;
  }
  String moduleToShow=null;
  if (moduleNames.length > 1) {
    Shell parent=UIHelper.getShellProvider().getShell();
    ShowUsesPopupDialog popup=new ShowUsesPopupDialog(parent,moduleNames,usesArray);
    popup.open();
  }
 else {
    moduleName=moduleNames[0];
    moduleToShow=moduleName;
    spec.setModuleToShow(moduleToShow);
    int moduleIndex=-1;
    for (int i=0; i < moduleNames.length; i++) {
      if (moduleNames[i].equals(moduleToShow)) {
        moduleIndex=i;
        break;
      }
    }
    if (moduleIndex < 0) {
      Activator.logDebug(""String_Node_Str"" + ""String_Node_Str"");
      return null;
    }
    SemanticNode[] uses=usesArray[moduleIndex];
    setUseMarkers(uses,moduleName,spec);
  }
  return null;
}",0.9950407934730444
135897,"/** 
 * The inner recursive method used by get UsesOfSymbol.  It appends all the appropriate OpApplNodes  to <code>found</code>. Note: modified by LL on 14 Sep 2010 so a subexpression name like  Foo!1!(a) will be returned as a use of Foo.  This is introduces another case to be handled when trying to extract the symbol's occurrence from the  OpApplNode containing the symbol.  This is the one case in which the symbol is not really the operator of the OpApplNode.
 * @param symbol
 * @param node
 * @param found
 * @return
 */
private static void innerGetUsesOfSymbol(SymbolNode symbol,SemanticNode node,Vector<SemanticNode> found){
  SymbolNode[] defs=null;
  if (node instanceof OpApplNode) {
    OpApplNode oan=(OpApplNode)node;
    if (sourceEquals(oan.getOperator(),symbol) || ((oan.subExpressionOf != null) && sourceEquals(oan.subExpressionOf,symbol))) {
      found.add(node);
    }
  }
 else   if ((node instanceof OpArgNode) && sourceEquals(((OpArgNode)node).getOp(),symbol)) {
    found.add(node);
  }
 else {
    if (node instanceof LeafProofNode) {
      defs=((LeafProofNode)node).getDefs();
    }
 else     if (node instanceof UseOrHideNode) {
      defs=((UseOrHideNode)node).defs;
    }
    if (defs != null) {
      UniqueString defStr=UniqueString.uniqueStringOf(""String_Node_Str"");
      int defIdx=-1;
      SyntaxTreeNode stn=((SyntaxTreeNode)node.stn);
      if (stn.getKind() == SyntaxTreeConstants.N_ProofStep) {
        if (stn.getHeirs().length > 1) {
          stn=stn.getHeirs()[1];
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
      for (int i=0; i < stn.getHeirs().length; i++) {
        SyntaxTreeNode nd=stn.getHeirs()[i];
        if (nd.image == defStr) {
          defIdx=i;
          break;
        }
      }
      if (defIdx != -1) {
        for (int i=0; i < defs.length; i++) {
          if (sourceEquals(defs[i],symbol)) {
            if (defIdx + 2 * i + 1 < stn.getHeirs().length) {
              found.add(new NewSymbNode(null,null,stn.getHeirs()[defIdx + 2 * i + 1]));
            }
 else {
              System.out.println(""String_Node_Str"");
            }
          }
        }
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
  SemanticNode[] children=node.getChildren();
  if (children == null) {
    return;
  }
  for (int i=0; i < children.length; i++) {
    final SemanticNode sn=children[i];
    if (sn != null) {
      if (node.getLocation().source().equals(sn.getLocation().source())) {
        innerGetUsesOfSymbol(symbol,sn,found);
      }
    }
  }
  return;
}","/** 
 * The inner recursive method used by get UsesOfSymbol.  It appends all the appropriate OpApplNodes  to <code>found</code>. Note: modified by LL on 14 Sep 2010 so a subexpression name like  Foo!1!(a) will be returned as a use of Foo.  This is introduces another case to be handled when trying to extract the symbol's occurrence from the  OpApplNode containing the symbol.  This is the one case in which the symbol is not really the operator of the OpApplNode.
 * @param symbol
 * @param node
 * @param found
 * @return
 */
private static void innerGetUsesOfSymbol(SymbolNode symbol,SemanticNode node,Vector<SemanticNode> found){
  SymbolNode[] defs=null;
  if (node instanceof OpApplNode) {
    OpApplNode oan=(OpApplNode)node;
    if (sourceEquals(oan.getOperator(),symbol) || ((oan.subExpressionOf != null) && sourceEquals(oan.subExpressionOf,symbol))) {
      found.add(node);
    }
  }
 else   if ((node instanceof OpArgNode) && sourceEquals(((OpArgNode)node).getOp(),symbol)) {
    found.add(node);
  }
 else {
    if (node instanceof LeafProofNode) {
      defs=((LeafProofNode)node).getDefs();
    }
 else     if (node instanceof UseOrHideNode) {
      defs=((UseOrHideNode)node).defs;
    }
    if (defs != null && defs.length != 0) {
      UniqueString defStr=UniqueString.uniqueStringOf(""String_Node_Str"");
      int defIdx=-1;
      SyntaxTreeNode stn=((SyntaxTreeNode)node.stn);
      if (stn.getKind() == SyntaxTreeConstants.N_ProofStep) {
        if (stn.getHeirs().length > 1) {
          stn=stn.getHeirs()[1];
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
      for (int i=0; i < stn.getHeirs().length; i++) {
        SyntaxTreeNode nd=stn.getHeirs()[i];
        if (nd.image == defStr) {
          defIdx=i;
          break;
        }
      }
      if (defIdx != -1) {
        for (int i=0; i < defs.length; i++) {
          if (sourceEquals(defs[i],symbol)) {
            if (defIdx + 2 * i + 1 < stn.getHeirs().length) {
              found.add(new NewSymbNode(null,null,stn.getHeirs()[defIdx + 2 * i + 1]));
            }
 else {
              System.out.println(""String_Node_Str"");
            }
          }
        }
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
  SemanticNode[] children=node.getChildren();
  if (children == null) {
    return;
  }
  for (int i=0; i < children.length; i++) {
    final SemanticNode sn=children[i];
    if (sn != null) {
      if (node.getLocation().source().equals(sn.getLocation().source())) {
        innerGetUsesOfSymbol(symbol,sn,found);
      }
    }
  }
  return;
}",0.9961523662947288
135898,"public static Vector ExpandMacroCall(AST.MacroCall call,Vector macros) throws ParseAlgorithmException {
  AST.Macro macroDef=null;
  int i=0;
  while (i < macros.size()) {
    AST.Macro md=(AST.Macro)macros.elementAt(i);
    if (md.name.equals(call.name)) {
      macroDef=md;
    }
    ;
    i=i + 1;
  }
  ;
  if (macroDef == null) {
    throw new ParseAlgorithmException(""String_Node_Str"" + call.name + ""String_Node_Str""+ call.location());
  }
  ;
  int numOfArgs=call.args.size();
  if (macroDef.params.size() != numOfArgs) {
    throw new ParseAlgorithmException(""String_Node_Str"" + call.name + ""String_Node_Str""+ ""String_Node_Str""+ call.location());
  }
  ;
  Vector result=SubstituteInStmtSeq(macroDef.body,call.args,macroDef.params,call.line,call.col);
  if (result.size() > 0) {
    AST first=(AST)result.elementAt(0);
    first.lbl=call.lbl;
    first.lblLocation=call.lblLocation;
  }
  ;
  return result;
}","public static Vector ExpandMacroCall(AST.MacroCall call,Vector macros) throws ParseAlgorithmException {
  AST.Macro macroDef=null;
  int i=0;
  while (i < macros.size()) {
    AST.Macro md=(AST.Macro)macros.elementAt(i);
    if (md.name.equals(call.name)) {
      macroDef=md;
    }
    ;
    i=i + 1;
  }
  ;
  if (macroDef == null) {
    throw new ParseAlgorithmException(""String_Node_Str"" + call.name + ""String_Node_Str""+ call.location());
  }
  ;
  int numOfArgs=call.args.size();
  if (macroDef.params.size() != numOfArgs) {
    throw new ParseAlgorithmException(""String_Node_Str"" + call.name + ""String_Node_Str""+ ""String_Node_Str""+ call.location());
  }
  ;
  Vector result=SubstituteInStmtSeq(macroDef.body,call.args,macroDef.params,call.line,call.col);
  if (result.size() > 0) {
    AST first=(AST)result.elementAt(0);
    first.lbl=call.lbl;
    first.lblLocation=call.lblLocation;
    Region callOrigin=call.getOrigin();
    if (callOrigin != null) {
      first.macroOriginBegin=callOrigin.getBegin();
      AST last=(AST)result.elementAt(result.size() - 1);
      last.macroOriginEnd=callOrigin.getEnd();
    }
  }
  ;
  return result;
}",0.8694390715667312
135899,"/** 
 */
private void GenLabeledStmt(AST.LabeledStmt ast,String context) throws PcalTLAGenException {
  String actionName=ast.label;
  if (ParseAlgorithm.omitPC) {
    actionName=currentProcName;
  }
  StringBuffer sb=new StringBuffer(actionName);
  Changed c=new Changed(vars);
  if (mp && (context.equals(""String_Node_Str"") || selfIsSelf)) {
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  int col=sb.length();
  kludgeToFixPCHandlingBug=col;
  sb.append(""String_Node_Str"");
  kludgeToFixPCHandlingBug=kludgeToFixPCHandlingBug + 3;
  int defStartLine=tlacode.size();
  int colAfterAnd=sb.length();
  addLeftParen(ast.getOrigin());
  for (int i=0; i < ast.stmts.size(); i++) {
    GenStmt((AST)ast.stmts.elementAt(i),c,context,sb.toString(),sb.length());
    sb=new StringBuffer(NSpaces(col));
    sb.append(""String_Node_Str"");
  }
  Vector unc=c.Unchanged(wrapColumn - col - ""String_Node_Str"".length());
  if (c.NumUnchanged() > 1) {
    sb=new StringBuffer(NSpaces(col));
    sb.append(""String_Node_Str"");
    int here=sb.length();
    sb.append((String)unc.elementAt(0));
    for (int i=1; i < unc.size(); i++) {
      addOneLineOfTLA(sb.toString());
      sb=new StringBuffer(NSpaces(here));
      sb.append((String)unc.elementAt(i));
    }
    sb.append(""String_Node_Str"");
    addOneTokenToTLA(sb.toString());
  }
 else   if (c.NumUnchanged() == 1) {
    if (c.Unchanged().length() > 5) {
      addOneTokenToTLA(NSpaces(col) + ""String_Node_Str"" + c.Unchanged());
    }
 else {
      addOneTokenToTLA(NSpaces(col) + ""String_Node_Str"" + c.Unchanged()+ ""String_Node_Str""+ c.Unchanged());
    }
  }
 else {
    if (ast.stmts.size() == 1) {
      for (int i=defStartLine; i < tlacode.size(); i++) {
        String line=(String)tlacode.elementAt(i);
        if (i == defStartLine) {
          tlacode.setElementAt(line.substring(0,colAfterAnd - 3) + line.substring(colAfterAnd,line.length()),i);
          shiftMappingVectorTokensLeft(i,colAfterAnd,3);
        }
 else {
          if (line.length() > 3) {
            tlacode.setElementAt(line.substring(3,line.length()),i);
            shiftMappingVectorTokensLeft(i,colAfterAnd,3);
          }
        }
      }
    }
  }
  addRightParen(ast.getOrigin());
  addOneLineOfTLA(""String_Node_Str"");
}","/** 
 */
private void GenLabeledStmt(AST.LabeledStmt ast,String context) throws PcalTLAGenException {
  String actionName=ast.label;
  if (ParseAlgorithm.omitPC) {
    actionName=currentProcName;
  }
  StringBuffer sb=new StringBuffer(actionName);
  Changed c=new Changed(vars);
  if (mp && (context.equals(""String_Node_Str"") || selfIsSelf)) {
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  int col=sb.length();
  kludgeToFixPCHandlingBug=col;
  sb.append(""String_Node_Str"");
  kludgeToFixPCHandlingBug=kludgeToFixPCHandlingBug + 3;
  int defStartLine=tlacode.size();
  int colAfterAnd=sb.length();
  PCalLocation macroBeginLeft=null;
  PCalLocation macroEndRight=null;
  boolean nonNullNotFound=true;
  for (int i=0; i < ast.stmts.size(); i++) {
    AST stmt=(AST)ast.stmts.elementAt(i);
    if (stmt.getOrigin() != null) {
      if (nonNullNotFound) {
        nonNullNotFound=false;
        macroBeginLeft=stmt.macroOriginBegin;
      }
      macroEndRight=stmt.macroOriginEnd;
    }
  }
  addLeftParenV(ast,macroBeginLeft);
  for (int i=0; i < ast.stmts.size(); i++) {
    GenStmt((AST)ast.stmts.elementAt(i),c,context,sb.toString(),sb.length());
    sb=new StringBuffer(NSpaces(col));
    sb.append(""String_Node_Str"");
  }
  Vector unc=c.Unchanged(wrapColumn - col - ""String_Node_Str"".length());
  if (c.NumUnchanged() > 1) {
    sb=new StringBuffer(NSpaces(col));
    sb.append(""String_Node_Str"");
    int here=sb.length();
    sb.append((String)unc.elementAt(0));
    for (int i=1; i < unc.size(); i++) {
      addOneLineOfTLA(sb.toString());
      sb=new StringBuffer(NSpaces(here));
      sb.append((String)unc.elementAt(i));
    }
    sb.append(""String_Node_Str"");
    addOneTokenToTLA(sb.toString());
  }
 else   if (c.NumUnchanged() == 1) {
    if (c.Unchanged().length() > 5) {
      addOneTokenToTLA(NSpaces(col) + ""String_Node_Str"" + c.Unchanged());
    }
 else {
      addOneTokenToTLA(NSpaces(col) + ""String_Node_Str"" + c.Unchanged()+ ""String_Node_Str""+ c.Unchanged());
    }
  }
 else {
    if (ast.stmts.size() == 1) {
      for (int i=defStartLine; i < tlacode.size(); i++) {
        String line=(String)tlacode.elementAt(i);
        if (i == defStartLine) {
          tlacode.setElementAt(line.substring(0,colAfterAnd - 3) + line.substring(colAfterAnd,line.length()),i);
          shiftMappingVectorTokensLeft(i,colAfterAnd,3);
        }
 else {
          if (line.length() > 3) {
            tlacode.setElementAt(line.substring(3,line.length()),i);
            shiftMappingVectorTokensLeft(i,colAfterAnd,3);
          }
        }
      }
    }
  }
  addRightParenV(ast,macroEndRight);
  addOneLineOfTLA(""String_Node_Str"");
}",0.7373532982598139
135900,"private static Vector ExplodeWhile(AST.LabeledStmt ast,String next) throws PcalTranslateException {
  Vector result=new Vector();
  AST.While w=(AST.While)ast.stmts.elementAt(0);
  AST.LabeledStmt newast=new AST.LabeledStmt();
  PCalLocation newastBeginLoc=ast.getOrigin().getBegin();
  PCalLocation whileBeginLoc=w.getOrigin().getBegin();
  PCalLocation whileBeginUnlabDoLoc=(w.unlabDo.size() != 0) ? ((AST)w.unlabDo.elementAt(0)).getOrigin().getBegin() : w.test.getOrigin().getEnd();
  PCalLocation whileEndUnlabDoLoc=(w.unlabDo.size() != 0) ? ((AST)w.unlabDo.elementAt(w.unlabDo.size() - 1)).getOrigin().getEnd() : w.test.getOrigin().getEnd();
  PCalLocation whileEndLoc=(w.labDo.size() != 0) ? w.getOrigin().getEnd() : whileEndUnlabDoLoc;
  newast.setOrigin(new Region(newastBeginLoc,whileEndLoc));
  newast.col=ast.col;
  newast.line=ast.line;
  newast.label=ast.label;
  newast.stmts=new Vector();
  if (!ParseAlgorithm.omitPC) {
    newast.stmts.addElement(CheckPC(ast.label));
  }
  AST.LabeledStmt firstLS=(w.labDo.size() == 0) ? null : (AST.LabeledStmt)w.labDo.elementAt(0);
  String unlabDoNext=(firstLS == null) ? ast.label : firstLS.label;
  Vector pair1=CopyAndExplodeLastStmtWithGoto((Vector)w.unlabDo.clone(),unlabDoNext);
  Vector rest=(Vector)ast.stmts.clone();
  rest.remove(0);
  Vector pair2=CopyAndExplodeLastStmtWithGoto(rest,next);
  if (IsTRUE(w.test))   newast.stmts.addAll((Vector)pair1.elementAt(0));
 else {
    AST.If ifS=new AST.If();
    ifS.test=w.test;
    ifS.Then=(Vector)pair1.elementAt(0);
    ifS.Else=(Vector)pair2.elementAt(0);
    ifS.setOrigin(new Region(whileBeginLoc,whileEndLoc));
    newast.stmts.addElement(ifS);
  }
  result.addElement(newast);
  for (int i=0; i < w.labDo.size(); i++) {
    AST.LabeledStmt nextLS=(w.labDo.size() > i + 1) ? (AST.LabeledStmt)w.labDo.elementAt(i + 1) : null;
    String nextLSL=(nextLS == null) ? ast.label : nextLS.label;
    result.addAll(ExplodeLabeledStmt(firstLS,nextLSL));
    firstLS=nextLS;
  }
  result.addAll((Vector)pair1.elementAt(1));
  if (!IsTRUE(w.test))   result.addAll((Vector)pair2.elementAt(1));
  return result;
}","private static Vector ExplodeWhile(AST.LabeledStmt ast,String next) throws PcalTranslateException {
  Vector result=new Vector();
  AST.While w=(AST.While)ast.stmts.elementAt(0);
  AST.LabeledStmt newast=new AST.LabeledStmt();
  PCalLocation newastBeginLoc=ast.getOrigin().getBegin();
  PCalLocation whileBeginLoc=w.getOrigin().getBegin();
  PCalLocation whileBeginUnlabDoLoc=(w.unlabDo.size() != 0) ? ((AST)w.unlabDo.elementAt(0)).getOrigin().getBegin() : w.test.getOrigin().getEnd();
  PCalLocation whileEndUnlabDoLoc=(w.unlabDo.size() != 0) ? ((AST)w.unlabDo.elementAt(w.unlabDo.size() - 1)).getOrigin().getEnd() : w.test.getOrigin().getEnd();
  PCalLocation whileEndLoc=(ast.stmts.size() != 1) ? ast.getOrigin().getEnd() : whileEndUnlabDoLoc;
  newast.setOrigin(new Region(newastBeginLoc,whileEndLoc));
  newast.col=ast.col;
  newast.line=ast.line;
  newast.label=ast.label;
  newast.stmts=new Vector();
  if (!ParseAlgorithm.omitPC) {
    newast.stmts.addElement(CheckPC(ast.label));
  }
  AST.LabeledStmt firstLS=(w.labDo.size() == 0) ? null : (AST.LabeledStmt)w.labDo.elementAt(0);
  String unlabDoNext=(firstLS == null) ? ast.label : firstLS.label;
  Vector pair1=CopyAndExplodeLastStmtWithGoto((Vector)w.unlabDo.clone(),unlabDoNext);
  Vector rest=(Vector)ast.stmts.clone();
  rest.remove(0);
  Vector pair2=CopyAndExplodeLastStmtWithGoto(rest,next);
  if (IsTRUE(w.test))   newast.stmts.addAll((Vector)pair1.elementAt(0));
 else {
    AST.If ifS=new AST.If();
    ifS.test=w.test;
    ifS.Then=(Vector)pair1.elementAt(0);
    ifS.Else=(Vector)pair2.elementAt(0);
    ifS.setOrigin(new Region(whileBeginLoc,whileEndLoc));
    newast.stmts.addElement(ifS);
  }
  result.addElement(newast);
  for (int i=0; i < w.labDo.size(); i++) {
    AST.LabeledStmt nextLS=(w.labDo.size() > i + 1) ? (AST.LabeledStmt)w.labDo.elementAt(i + 1) : null;
    String nextLSL=(nextLS == null) ? ast.label : nextLS.label;
    result.addAll(ExplodeLabeledStmt(firstLS,nextLSL));
    firstLS=nextLS;
  }
  result.addAll((Vector)pair1.elementAt(1));
  if (!IsTRUE(w.test))   result.addAll((Vector)pair2.elementAt(1));
  return result;
}",0.9948064211520302
135901,"private void ExtractProcedure(AST.Procedure ast,String context){
  if (!InsertProc(ast))   errorReport=errorReport + ""String_Node_Str"" + ast.name+ ""String_Node_Str""+ ast.col+ ""String_Node_Str""+ ast.line;
  boolean b=InsertSym(PROCEDURE,ast.name,context,""String_Node_Str"",ast.line,ast.col);
  for (int i=0; i < ast.decls.size(); i++)   ExtractPVarDecl((AST.PVarDecl)ast.decls.elementAt(i),ast.name);
  for (int i=0; i < ast.params.size(); i++)   ExtractParamDecl((AST.PVarDecl)ast.params.elementAt(i),ast.name);
  for (int i=0; i < ast.body.size(); i++)   ExtractLabeledStmt((AST.LabeledStmt)ast.body.elementAt(i),ast.name,""String_Node_Str"");
}","private void ExtractProcedure(AST.Procedure ast,String context){
  if (!InsertProc(ast))   errorReport=errorReport + ""String_Node_Str"" + ast.name+ ""String_Node_Str""+ ast.line+ ""String_Node_Str""+ ast.col;
  boolean b=InsertSym(PROCEDURE,ast.name,context,""String_Node_Str"",ast.line,ast.col);
  for (int i=0; i < ast.decls.size(); i++)   ExtractPVarDecl((AST.PVarDecl)ast.decls.elementAt(i),ast.name);
  for (int i=0; i < ast.params.size(); i++)   ExtractParamDecl((AST.PVarDecl)ast.params.elementAt(i),ast.name);
  for (int i=0; i < ast.body.size(); i++)   ExtractLabeledStmt((AST.LabeledStmt)ast.body.elementAt(i),ast.name,""String_Node_Str"");
}",0.989113530326594
135902,"private void ExtractProcess(AST.Process ast,String context){
  boolean b;
  if (!InsertProcess(ast))   errorReport=errorReport + ""String_Node_Str"" + ast.name+ ""String_Node_Str""+ ast.col+ ""String_Node_Str""+ ast.line;
  b=InsertSym(PROCESS,ast.name,context,""String_Node_Str"",ast.line,ast.col);
  for (int i=0; i < ast.decls.size(); i++)   ExtractVarDecl((AST.VarDecl)ast.decls.elementAt(i),ast.name);
  for (int i=0; i < ast.body.size(); i++)   ExtractLabeledStmt((AST.LabeledStmt)ast.body.elementAt(i),ast.name,""String_Node_Str"");
}","private void ExtractProcess(AST.Process ast,String context){
  boolean b;
  if (!InsertProcess(ast))   errorReport=errorReport + ""String_Node_Str"" + ast.name+ ""String_Node_Str""+ ast.line+ ""String_Node_Str""+ ast.col;
  b=InsertSym(PROCESS,ast.name,context,""String_Node_Str"",ast.line,ast.col);
  for (int i=0; i < ast.decls.size(); i++)   ExtractVarDecl((AST.VarDecl)ast.decls.elementAt(i),ast.name);
  for (int i=0; i < ast.body.size(); i++)   ExtractLabeledStmt((AST.LabeledStmt)ast.body.elementAt(i),ast.name,""String_Node_Str"");
}",0.9868173258003766
135903,"protected Assignment doEditFormula(Assignment formula){
  Assert.isNotNull(formula);
  AssignmentWizard wizard=new AssignmentWizard(getSection().getText(),getSection().getDescription(),(Assignment)formula,AssignmentWizard.SHOW_OPTION,AssignmentWizardPage.CONSTANT_WIZARD_ID,AssignmentWizardPage.CONSTANT_TYPING_WIZARD_ID);
  WizardDialog dialog=new WizardDialog(getTableViewer().getTable().getShell(),wizard);
  dialog.setHelpAvailable(true);
  if (Window.OK == dialog.open()) {
    return wizard.getFormula();
  }
 else {
    return null;
  }
}","protected Assignment doEditFormula(Assignment formula){
  Assert.isNotNull(formula);
  AssignmentWizard wizard=new AssignmentWizard(getSection().getText(),getSection().getDescription(),(Assignment)formula,AssignmentWizard.SHOW_OPTION,AssignmentWizardPage.CONSTANT_WIZARD_ID,AssignmentWizardPage.CONSTANT_TYPING_WIZARD_ID);
  WizardDialog dialog=new WizardDialog(getTableViewer().getTable().getShell(),wizard);
  wizard.setWizardDialog(dialog);
  dialog.setHelpAvailable(true);
  if (Window.OK == dialog.open()) {
    return wizard.getFormula();
  }
 else {
    return null;
  }
}",0.9697508896797152
135904,"protected Assignment doEditFormula(Assignment formula){
  if (formula == null) {
    String[] names=null;
    Object input=this.getTableViewer().getInput();
    if ((input != null) && (input instanceof Vector)) {
      Vector inputVec=(Vector)input;
      names=new String[inputVec.size()];
      for (int i=0; i < names.length; i++) {
        Object next=inputVec.elementAt(i);
        if ((next != null) && (next instanceof Assignment)) {
          Assignment nextAss=(Assignment)next;
          names[i]=nextAss.getLabel();
        }
 else {
          names[i]=""String_Node_Str"";
        }
      }
    }
 else {
      names=new String[0];
    }
    FilteredDefinitionSelectionDialog definitionSelection=new FilteredDefinitionSelectionDialog(this.getSection().getShell(),false,ToolboxHandle.getCurrentSpec().getValidRootModule(),names);
    definitionSelection.setTitle(""String_Node_Str"");
    definitionSelection.setMessage(""String_Node_Str"");
    definitionSelection.setInitialPattern(""String_Node_Str"");
    if (Window.OK == definitionSelection.open()) {
      OpDefNode result=(OpDefNode)(definitionSelection.getResult())[0];
      formula=new Assignment(result.getName().toString(),Assignment.getArrayOfEmptyStrings(result.getSource().getNumberOfArgs()),""String_Node_Str"");
    }
 else {
      return null;
    }
  }
  OpDefNode opDefNode=(OpDefNode)ModelHelper.getOpDefNode(formula.getLabel());
  if (opDefNode != null && opDefNode.getSource().getNumberOfArgs() != formula.getParams().length) {
    String[] newParams=new String[opDefNode.getSource().getNumberOfArgs()];
    for (int i=0; i < newParams.length; i++) {
      newParams[i]=""String_Node_Str"";
    }
    formula.setParams(newParams);
  }
  AssignmentWizard wizard=new AssignmentWizard(getSection().getText(),getSection().getDescription(),(Assignment)formula,AssignmentWizard.SHOW_MODEL_VALUE_OPTION,AssignmentWizardPage.DEF_OVERRIDE_WIZARD_ID,""String_Node_Str"");
  WizardDialog dialog=new WizardDialog(getTableViewer().getTable().getShell(),wizard);
  dialog.setHelpAvailable(true);
  if (Window.OK == dialog.open()) {
    return wizard.getFormula();
  }
 else {
    return null;
  }
}","protected Assignment doEditFormula(Assignment formula){
  if (formula == null) {
    String[] names=null;
    Object input=this.getTableViewer().getInput();
    if ((input != null) && (input instanceof Vector)) {
      Vector inputVec=(Vector)input;
      names=new String[inputVec.size()];
      for (int i=0; i < names.length; i++) {
        Object next=inputVec.elementAt(i);
        if ((next != null) && (next instanceof Assignment)) {
          Assignment nextAss=(Assignment)next;
          names[i]=nextAss.getLabel();
        }
 else {
          names[i]=""String_Node_Str"";
        }
      }
    }
 else {
      names=new String[0];
    }
    FilteredDefinitionSelectionDialog definitionSelection=new FilteredDefinitionSelectionDialog(this.getSection().getShell(),false,ToolboxHandle.getCurrentSpec().getValidRootModule(),names);
    definitionSelection.setTitle(""String_Node_Str"");
    definitionSelection.setMessage(""String_Node_Str"");
    definitionSelection.setInitialPattern(""String_Node_Str"");
    if (Window.OK == definitionSelection.open()) {
      OpDefNode result=(OpDefNode)(definitionSelection.getResult())[0];
      formula=new Assignment(result.getName().toString(),Assignment.getArrayOfEmptyStrings(result.getSource().getNumberOfArgs()),""String_Node_Str"");
    }
 else {
      return null;
    }
  }
  OpDefNode opDefNode=(OpDefNode)ModelHelper.getOpDefNode(formula.getLabel());
  if (opDefNode != null && opDefNode.getSource().getNumberOfArgs() != formula.getParams().length) {
    String[] newParams=new String[opDefNode.getSource().getNumberOfArgs()];
    for (int i=0; i < newParams.length; i++) {
      newParams[i]=""String_Node_Str"";
    }
    formula.setParams(newParams);
  }
  AssignmentWizard wizard=new AssignmentWizard(getSection().getText(),getSection().getDescription(),(Assignment)formula,AssignmentWizard.SHOW_MODEL_VALUE_OPTION,AssignmentWizardPage.DEF_OVERRIDE_WIZARD_ID,""String_Node_Str"");
  WizardDialog dialog=new WizardDialog(getTableViewer().getTable().getShell(),wizard);
  wizard.setWizardDialog(dialog);
  dialog.setHelpAvailable(true);
  if (Window.OK == dialog.open()) {
    return wizard.getFormula();
  }
 else {
    return null;
  }
}",0.9921731123388582
135905,"public void dispose(){
  String rightSide=FormHelper.trimTrailingSpaces(source.getDocument().get());
  if (optionModelValue != null && optionSetModelValues != null) {
    this.getAssignment().setModelValue(optionModelValue.getSelection() || optionSetModelValues.getSelection());
    if (optionModelValue.getSelection()) {
      this.getAssignment().setRight(this.getAssignment().getLabel());
    }
 else     if (optionSetModelValues.getSelection()) {
      TypedSet set=TypedSet.parseSet(rightSide);
      this.getAssignment().setSymmetric(flagSymmetricalSet.getSelection());
      this.getAssignment().setRight(set.toString());
    }
 else {
      this.getAssignment().setRight(rightSide);
    }
  }
 else   if (optionModelValue != null) {
    this.getAssignment().setModelValue(optionModelValue.getSelection());
    if (optionModelValue.getSelection()) {
      this.getAssignment().setRight(this.getAssignment().getLabel());
    }
 else {
      this.getAssignment().setRight(rightSide);
    }
  }
 else {
    this.getAssignment().setRight(rightSide);
  }
  if (paramComposite.hasParameters()) {
    this.getAssignment().setParams(paramComposite.getValues());
  }
  super.dispose();
}","public void dispose(){
  final AssignmentWizard wizard=(AssignmentWizard)getWizard();
  if (wizard.getWizardDialogReturnCode() == org.eclipse.jface.window.Window.CANCEL) {
    super.dispose();
    return;
  }
  String rightSide=FormHelper.trimTrailingSpaces(source.getDocument().get());
  if (optionModelValue != null && optionSetModelValues != null) {
    this.getAssignment().setModelValue(optionModelValue.getSelection() || optionSetModelValues.getSelection());
    if (optionModelValue.getSelection()) {
      this.getAssignment().setRight(this.getAssignment().getLabel());
    }
 else     if (optionSetModelValues.getSelection()) {
      TypedSet set=TypedSet.parseSet(rightSide);
      this.getAssignment().setSymmetric(flagSymmetricalSet.getSelection());
      this.getAssignment().setRight(set.toString());
    }
 else {
      this.getAssignment().setRight(rightSide);
    }
  }
 else   if (optionModelValue != null) {
    this.getAssignment().setModelValue(optionModelValue.getSelection());
    if (optionModelValue.getSelection()) {
      this.getAssignment().setRight(this.getAssignment().getLabel());
    }
 else {
      this.getAssignment().setRight(rightSide);
    }
  }
 else {
    this.getAssignment().setRight(rightSide);
  }
  if (paramComposite.hasParameters()) {
    this.getAssignment().setParams(paramComposite.getValues());
  }
  super.dispose();
}",0.9272300469483568
135906,"/** 
 * The following method goes through all the nodes to set their            tool-specific fields.  It was modified on 1 May 2007 so it would find   the nodes in the body of a Lambda expression.  Obviously, if new        semantic node types are added, this method will have to be modified.    Less obviously, if a tool wants to call TLC on a specification that     was not all created inside a module, then this method may need to be    modified so TLC finds thos nodes not part of the module.                * Yuan claims that this is the only method in TLC that has to find all    the nodes in such a way.                                               
 */
private final void processConstants(SemanticNode expr){
switch (expr.getKind()) {
case ModuleKind:
{
      ModuleNode expr1=(ModuleNode)expr;
      OpDefNode[] opDefs=expr1.getOpDefs();
      for (int i=0; i < opDefs.length; i++) {
        Object def=opDefs[i].getToolObject(TLCGlobals.ToolId);
        if (def instanceof OpDefNode) {
          this.processConstants(((OpDefNode)def).getBody());
        }
        this.processConstants(opDefs[i].getBody());
      }
      ModuleNode[] imods=expr1.getInnerModules();
      for (int i=0; i < imods.length; i++) {
        this.processConstants(imods[i]);
      }
      AssumeNode[] assumps=expr1.getAssumptions();
      for (int i=0; i < assumps.length; i++) {
        this.processConstants(assumps[i]);
      }
      TheoremNode[] thms=expr1.getTheorems();
      for (int i=0; i < thms.length; i++) {
        this.processConstants(thms[i]);
      }
      return;
    }
case OpApplKind:
{
    OpApplNode expr1=(OpApplNode)expr;
    SymbolNode opNode=expr1.getOperator();
    Object val=this.defns.get(opNode.getName());
    if (val != null) {
      opNode.setToolObject(TLCGlobals.ToolId,val);
    }
 else {
      SemanticNode[] args=expr1.getArgs();
      for (int i=0; i < args.length; i++) {
        if (args[i] != null) {
          this.processConstants(args[i]);
        }
      }
      ExprNode[] bnds=expr1.getBdedQuantBounds();
      for (int i=0; i < bnds.length; i++) {
        this.processConstants(bnds[i]);
      }
    }
    return;
  }
case LetInKind:
{
  LetInNode expr1=(LetInNode)expr;
  OpDefNode[] letDefs=expr1.getLets();
  for (int i=0; i < letDefs.length; i++) {
    this.processConstants(letDefs[i].getBody());
  }
  this.processConstants(expr1.getBody());
  return;
}
case SubstInKind:
{
SubstInNode expr1=(SubstInNode)expr;
Subst[] subs=expr1.getSubsts();
for (int i=0; i < subs.length; i++) {
  this.processConstants(subs[i].getExpr());
}
this.processConstants(expr1.getBody());
return;
}
case APSubstInKind:
{
APSubstInNode expr1=(APSubstInNode)expr;
Subst[] subs=expr1.getSubsts();
for (int i=0; i < subs.length; i++) {
this.processConstants(subs[i].getExpr());
}
this.processConstants(expr1.getBody());
return;
}
case NumeralKind:
{
NumeralNode expr1=(NumeralNode)expr;
IntValue val=IntValue.gen(expr1.val());
expr1.setToolObject(TLCGlobals.ToolId,val);
return;
}
case DecimalKind:
{
DecimalNode expr1=(DecimalNode)expr;
Assert.fail(EC.TLC_CANT_HANDLE_REAL_NUMBERS,expr1.toString());
return;
}
case StringKind:
{
StringNode expr1=(StringNode)expr;
StringValue val=new StringValue(expr1.getRep());
expr1.setToolObject(TLCGlobals.ToolId,val);
return;
}
case AssumeKind:
{
AssumeNode expr1=(AssumeNode)expr;
this.processConstants(expr1.getAssume());
return;
}
case TheoremKind:
{
TheoremNode expr1=(TheoremNode)expr;
this.processConstants(expr1.getTheorem());
return;
}
case OpArgKind:
{
SymbolNode opArgNode=((OpArgNode)expr).getOp();
if (opArgNode.getKind() == UserDefinedOpKind) {
this.processConstants(((OpDefNode)opArgNode).getBody());
}
return;
}
case LabelKind:
{
LabelNode expr1=(LabelNode)expr;
this.processConstants(expr1.getBody());
}
}
}","/** 
 * The following method goes through all the nodes to set their            tool-specific fields.  It was modified on 1 May 2007 so it would find   the nodes in the body of a Lambda expression.  Obviously, if new        semantic node types are added, this method will have to be modified.    Less obviously, if a tool wants to call TLC on a specification that     was not all created inside a module, then this method may need to be    modified so TLC finds thos nodes not part of the module.                * Yuan claims that this is the only method in TLC that has to find all    the nodes in such a way.                                               
 */
private final void processConstants(SemanticNode expr){
switch (expr.getKind()) {
case ModuleKind:
{
      ModuleNode expr1=(ModuleNode)expr;
      OpDefNode[] opDefs=expr1.getOpDefs();
      for (int i=0; i < opDefs.length; i++) {
        Object def=opDefs[i].getToolObject(TLCGlobals.ToolId);
        if (def instanceof OpDefNode) {
          this.processConstants(((OpDefNode)def).getBody());
        }
        this.processConstants(opDefs[i].getBody());
      }
      ModuleNode[] imods=expr1.getInnerModules();
      for (int i=0; i < imods.length; i++) {
        this.processConstants(imods[i]);
      }
      AssumeNode[] assumps=expr1.getAssumptions();
      for (int i=0; i < assumps.length; i++) {
        this.processConstants(assumps[i]);
      }
      TheoremNode[] thms=expr1.getTheorems();
      for (int i=0; i < thms.length; i++) {
        this.processConstants(thms[i]);
      }
      return;
    }
case OpApplKind:
{
    OpApplNode expr1=(OpApplNode)expr;
    SymbolNode opNode=expr1.getOperator();
    Object val=this.defns.get(opNode.getName());
    if (val != null) {
      opNode.setToolObject(TLCGlobals.ToolId,val);
    }
 else {
      SemanticNode[] args=expr1.getArgs();
      for (int i=0; i < args.length; i++) {
        if (args[i] != null) {
          this.processConstants(args[i]);
        }
      }
      ExprNode[] bnds=expr1.getBdedQuantBounds();
      for (int i=0; i < bnds.length; i++) {
        this.processConstants(bnds[i]);
      }
    }
    return;
  }
case LetInKind:
{
  LetInNode expr1=(LetInNode)expr;
  OpDefNode[] letDefs=expr1.getLets();
  for (int i=0; i < letDefs.length; i++) {
    this.processConstants(letDefs[i].getBody());
  }
  this.processConstants(expr1.getBody());
  return;
}
case SubstInKind:
{
SubstInNode expr1=(SubstInNode)expr;
Subst[] subs=expr1.getSubsts();
for (int i=0; i < subs.length; i++) {
  this.processConstants(subs[i].getExpr());
}
this.processConstants(expr1.getBody());
return;
}
case APSubstInKind:
{
APSubstInNode expr1=(APSubstInNode)expr;
Subst[] subs=expr1.getSubsts();
for (int i=0; i < subs.length; i++) {
this.processConstants(subs[i].getExpr());
}
this.processConstants(expr1.getBody());
return;
}
case NumeralKind:
{
NumeralNode expr1=(NumeralNode)expr;
IntValue val=IntValue.gen(expr1.val());
if (expr1.bigVal() != null) {
Assert.fail(EC.TLC_INTEGER_TOO_BIG,expr1.toString());
return;
}
expr1.setToolObject(TLCGlobals.ToolId,val);
return;
}
case DecimalKind:
{
DecimalNode expr1=(DecimalNode)expr;
Assert.fail(EC.TLC_CANT_HANDLE_REAL_NUMBERS,expr1.toString());
return;
}
case StringKind:
{
StringNode expr1=(StringNode)expr;
StringValue val=new StringValue(expr1.getRep());
expr1.setToolObject(TLCGlobals.ToolId,val);
return;
}
case AssumeKind:
{
AssumeNode expr1=(AssumeNode)expr;
this.processConstants(expr1.getAssume());
return;
}
case TheoremKind:
{
TheoremNode expr1=(TheoremNode)expr;
this.processConstants(expr1.getTheorem());
return;
}
case OpArgKind:
{
SymbolNode opArgNode=((OpArgNode)expr).getOp();
if (opArgNode.getKind() == UserDefinedOpKind) {
this.processConstants(((OpDefNode)opArgNode).getBody());
}
return;
}
case LabelKind:
{
LabelNode expr1=(LabelNode)expr;
this.processConstants(expr1.getBody());
}
}
}",0.98773166275124
135907,"/** 
 * From name, prepend path elements to try to find the actual file intended, and use the resulting fully-qualified name to initialize  the File.  The first fully-qualified name that refers to a file that actually exists is the File returned; but if none exists, the last one tried is returned  anyway.  Hence, the File object returned does not necessarily represent a file that actually exists in the file system.
 * @param module name, used as basis of path name to the file that should contain it
 */
private final File locate(String name){
  String prefix=""String_Node_Str"";
  File sourceFile=null;
  int idx=0;
  while (true) {
    if ((idx == 0) && (ToolIO.getUserDir() != null)) {
      sourceFile=new File(ToolIO.getUserDir(),name);
    }
 else {
      if (prefix.startsWith(""String_Node_Str"")) {
        ClassLoader cl=ClassLoader.getSystemClassLoader();
        InputStream is=cl.getResourceAsStream(STANDARD_MODULES + name);
        if (is != null) {
          try {
            sourceFile=new File(TMPDIR + File.separator + name);
            sourceFile.deleteOnExit();
            FileOutputStream fos=new FileOutputStream(sourceFile);
            byte buf[]=new byte[1024];
            int len;
            while ((len=is.read(buf)) > 0) {
              fos.write(buf,0,len);
            }
            fos.close();
            is.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
 else {
        sourceFile=new File(prefix + name);
      }
    }
    if (sourceFile.exists())     break;
    if (idx >= libraryPaths.length)     break;
    prefix=libraryPaths[idx++];
  }
  return sourceFile;
}","/** 
 * From name, prepend path elements to try to find the actual file intended, and use the resulting fully-qualified name to initialize  the File.  The first fully-qualified name that refers to a file that actually exists is the File returned; but if none exists, the last one tried is returned  anyway.  Hence, the File object returned does not necessarily represent a file that actually exists in the file system.
 * @param module name, used as basis of path name to the file that should contain it
 */
private final File locate(String name){
  String prefix=""String_Node_Str"";
  File sourceFile=null;
  int idx=0;
  while (true) {
    if ((idx == 0) && (ToolIO.getUserDir() != null)) {
      sourceFile=new File(ToolIO.getUserDir(),name);
    }
 else {
      if (isInJar(prefix)) {
        InputStream is=cl.getResourceAsStream(STANDARD_MODULES + name);
        if (is != null) {
          try {
            sourceFile=new File(TMPDIR + File.separator + name);
            sourceFile.deleteOnExit();
            FileOutputStream fos=new FileOutputStream(sourceFile);
            byte buf[]=new byte[1024];
            int len;
            while ((len=is.read(buf)) > 0) {
              fos.write(buf,0,len);
            }
            fos.close();
            is.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
 else {
        sourceFile=new File(prefix + name);
      }
    }
    if (sourceFile.exists())     break;
    if (idx >= libraryPaths.length)     break;
    prefix=libraryPaths[idx++];
  }
  return sourceFile;
}",0.9706959706959708
135908,"private static String getInstallationBasePath(){
  ClassLoader cl=ClassLoader.getSystemClassLoader();
  final URL url=cl.getResource(""String_Node_Str"");
  final String path=url.toString();
  try {
    if (!path.startsWith(""String_Node_Str"")) {
      final URI uri=new URI(path);
      return new File(uri).getAbsolutePath();
    }
  }
 catch (  URISyntaxException e) {
    System.err.println(path);
    e.printStackTrace();
  }
catch (  IllegalArgumentException e) {
    System.err.println(path);
    e.printStackTrace();
  }
  return path;
}","private static String getInstallationBasePath(){
  final URL url=cl.getResource(""String_Node_Str"");
  final String path=url.toString();
  try {
    if (!isInJar(path)) {
      final URI uri=new URI(path);
      return new File(uri).getAbsolutePath();
    }
  }
 catch (  URISyntaxException e) {
    System.err.println(path);
    e.printStackTrace();
  }
catch (  IllegalArgumentException e) {
    System.err.println(path);
    e.printStackTrace();
  }
  return path;
}",0.902970297029703
135909,"public void paintControl(PaintEvent event){
  StateSpaceInformationItem[] ssInfo=resultPage.getStateSpaceInformation();
  if (ssInfo.length < 2) {
    return;
  }
  long[] data=new long[ssInfo.length + 1];
  long[] times=new long[ssInfo.length + 1];
  data[0]=0;
  times[0]=0;
  long startTime=resultPage.startTime;
  System.out.println(""String_Node_Str"" + (ssInfo[0].getTime().getTime() - startTime));
  if (startTime > ssInfo[0].getTime().getTime() - 1000) {
    startTime=ssInfo[0].getTime().getTime() - 1000;
  }
  for (int i=1; i < data.length; i++) {
switch (columnNumber) {
case StateSpaceLabelProvider.COL_TIME:
      data[i]=i - 1;
    break;
case StateSpaceLabelProvider.COL_DIAMETER:
  data[i]=ssInfo[i - 1].getDiameter();
break;
case StateSpaceLabelProvider.COL_FOUND:
data[i]=ssInfo[i - 1].getFoundStates();
break;
case StateSpaceLabelProvider.COL_DISTINCT:
data[i]=ssInfo[i - 1].getDistinctStates();
break;
case StateSpaceLabelProvider.COL_LEFT:
data[i]=ssInfo[i - 1].getLeftStates();
break;
default :
return;
}
times[i]=ssInfo[i - 1].getTime().getTime() - startTime;
}
if (data == null) {
return;
}
Rectangle rect=shell.getClientArea();
long maxData=0;
for (int i=0; i < data.length; i++) {
if (data[i] > maxData) {
maxData=data[i];
}
}
long maxTime=times[times.length - 1];
if (maxTime > 0) {
int[] pointArray=new int[2 * data.length];
for (int i=0; i < data.length; i++) {
pointArray[2 * i]=(int)((times[i] * rect.width) / maxTime);
pointArray[(2 * i) + 1]=(int)(rect.height - ((data[i] * rect.height) / maxData));
}
event.gc.drawPolyline(pointArray);
}
String stringTime=""String_Node_Str"";
long unreportedTime=maxTime;
long days=maxTime / (1000 * 60 * 60* 24);
if (days > 0) {
unreportedTime=unreportedTime - days * (1000 * 60 * 60* 24);
stringTime=stringTime + days + ((days == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
}
long hours=unreportedTime / (1000 * 60 * 60);
if (hours > 0) {
unreportedTime=unreportedTime - hours * (1000 * 60 * 60);
stringTime=stringTime + hours + ((hours == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
}
unreportedTime=(unreportedTime + (1000 * 26)) / (1000 * 60);
stringTime=stringTime + unreportedTime + ((unreportedTime == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
event.gc.drawString(stringTime,0,0);
event.gc.drawString(""String_Node_Str"" + data[data.length - 1],0,15);
if (maxData != data[data.length - 1]) {
event.gc.drawString(""String_Node_Str"" + maxData,0,30);
}
}","public void paintControl(PaintEvent event){
  StateSpaceInformationItem[] ssInfo=resultPage.getStateSpaceInformation();
  if (ssInfo.length < 2) {
    return;
  }
  long[] data=new long[ssInfo.length + 1];
  long[] times=new long[ssInfo.length + 1];
  data[0]=0;
  times[0]=0;
  long startTime=resultPage.startTime;
  System.out.println(""String_Node_Str"" + (ssInfo[0].getTime().getTime() - startTime));
  if (startTime > ssInfo[0].getTime().getTime() - 1000) {
    startTime=ssInfo[0].getTime().getTime() - 1000;
  }
  for (int i=1; i < data.length; i++) {
switch (columnNumber) {
case StateSpaceLabelProvider.COL_TIME:
      data[i]=i - 1;
    break;
case StateSpaceLabelProvider.COL_DIAMETER:
  data[i]=ssInfo[i - 1].getDiameter();
break;
case StateSpaceLabelProvider.COL_FOUND:
data[i]=ssInfo[i - 1].getFoundStates();
break;
case StateSpaceLabelProvider.COL_DISTINCT:
data[i]=ssInfo[i - 1].getDistinctStates();
break;
case StateSpaceLabelProvider.COL_LEFT:
data[i]=ssInfo[i - 1].getLeftStates();
break;
default :
return;
}
times[i]=ssInfo[i - 1].getTime().getTime() - startTime;
}
if (data == null) {
return;
}
Rectangle rect=shell.getClientArea();
long maxData=0;
for (int i=0; i < data.length; i++) {
if (data[i] > maxData) {
maxData=data[i];
}
}
long maxTime=times[times.length - 1];
if (maxTime > 0) {
long maxDataVal=maxData;
if (maxDataVal == 0) {
maxDataVal=1;
}
int[] pointArray=new int[2 * data.length];
for (int i=0; i < data.length; i++) {
pointArray[2 * i]=(int)((times[i] * rect.width) / maxTime);
pointArray[(2 * i) + 1]=(int)(rect.height - ((data[i] * rect.height) / maxDataVal));
}
event.gc.drawPolyline(pointArray);
}
String stringTime=""String_Node_Str"";
long unreportedTime=maxTime;
long days=maxTime / (1000 * 60 * 60* 24);
if (days > 0) {
unreportedTime=unreportedTime - days * (1000 * 60 * 60* 24);
stringTime=stringTime + days + ((days == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
}
long hours=unreportedTime / (1000 * 60 * 60);
if (hours > 0) {
unreportedTime=unreportedTime - hours * (1000 * 60 * 60);
stringTime=stringTime + hours + ((hours == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
}
unreportedTime=(unreportedTime + (1000 * 26)) / (1000 * 60);
stringTime=stringTime + unreportedTime + ((unreportedTime == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
event.gc.drawString(stringTime,0,0);
event.gc.drawString(""String_Node_Str"" + data[data.length - 1],0,15);
if (maxData != data[data.length - 1]) {
event.gc.drawString(""String_Node_Str"" + maxData,0,30);
}
}",0.98644547845438
135910,"/** 
 * Much of the stuff in this run() method was copied, without much understanding from Snippet245.java in the Eclipse examples.
 */
public void run(){
  String title=getGraphTitle(columnNumber,resultPage);
  Display display=UIHelper.getCurrentDisplay();
  boolean shellExists=false;
  Shell theShell=null;
  Shell[] shells=display.getShells();
  for (int i=0; i < shells.length; i++) {
    if (shells[i].getText().equals(title)) {
      theShell=shells[i];
      shellExists=true;
      break;
    }
  }
  if (!shellExists) {
    theShell=new Shell(display,SWT.SHELL_TRIM);
  }
  final Shell shell=theShell;
  shell.setText(title);
  shell.setActive();
  if (shellExists) {
    shell.redraw();
    shell.update();
  }
 else {
    shell.addPaintListener(new PaintListener(){
      public void paintControl(      PaintEvent event){
        StateSpaceInformationItem[] ssInfo=resultPage.getStateSpaceInformation();
        if (ssInfo.length < 2) {
          return;
        }
        long[] data=new long[ssInfo.length + 1];
        long[] times=new long[ssInfo.length + 1];
        data[0]=0;
        times[0]=0;
        long startTime=resultPage.startTime;
        System.out.println(""String_Node_Str"" + (ssInfo[0].getTime().getTime() - startTime));
        if (startTime > ssInfo[0].getTime().getTime() - 1000) {
          startTime=ssInfo[0].getTime().getTime() - 1000;
        }
        for (int i=1; i < data.length; i++) {
switch (columnNumber) {
case StateSpaceLabelProvider.COL_TIME:
            data[i]=i - 1;
          break;
case StateSpaceLabelProvider.COL_DIAMETER:
        data[i]=ssInfo[i - 1].getDiameter();
      break;
case StateSpaceLabelProvider.COL_FOUND:
    data[i]=ssInfo[i - 1].getFoundStates();
  break;
case StateSpaceLabelProvider.COL_DISTINCT:
data[i]=ssInfo[i - 1].getDistinctStates();
break;
case StateSpaceLabelProvider.COL_LEFT:
data[i]=ssInfo[i - 1].getLeftStates();
break;
default :
return;
}
times[i]=ssInfo[i - 1].getTime().getTime() - startTime;
}
if (data == null) {
return;
}
Rectangle rect=shell.getClientArea();
long maxData=0;
for (int i=0; i < data.length; i++) {
if (data[i] > maxData) {
maxData=data[i];
}
}
long maxTime=times[times.length - 1];
if (maxTime > 0) {
int[] pointArray=new int[2 * data.length];
for (int i=0; i < data.length; i++) {
pointArray[2 * i]=(int)((times[i] * rect.width) / maxTime);
pointArray[(2 * i) + 1]=(int)(rect.height - ((data[i] * rect.height) / maxData));
}
event.gc.drawPolyline(pointArray);
}
String stringTime=""String_Node_Str"";
long unreportedTime=maxTime;
long days=maxTime / (1000 * 60 * 60* 24);
if (days > 0) {
unreportedTime=unreportedTime - days * (1000 * 60 * 60* 24);
stringTime=stringTime + days + ((days == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
}
long hours=unreportedTime / (1000 * 60 * 60);
if (hours > 0) {
unreportedTime=unreportedTime - hours * (1000 * 60 * 60);
stringTime=stringTime + hours + ((hours == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
}
unreportedTime=(unreportedTime + (1000 * 26)) / (1000 * 60);
stringTime=stringTime + unreportedTime + ((unreportedTime == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
event.gc.drawString(stringTime,0,0);
event.gc.drawString(""String_Node_Str"" + data[data.length - 1],0,15);
if (maxData != data[data.length - 1]) {
event.gc.drawString(""String_Node_Str"" + maxData,0,30);
}
}
}
);
}
;
if (!shellExists) {
shell.setBounds(100 + 30 * columnNumber,100 + 30 * columnNumber,400,300);
}
shell.open();
}","/** 
 * Much of the stuff in this run() method was copied, without much understanding from Snippet245.java in the Eclipse examples.
 */
public void run(){
  String title=getGraphTitle(columnNumber,resultPage);
  Display display=UIHelper.getCurrentDisplay();
  boolean shellExists=false;
  Shell theShell=null;
  Shell[] shells=display.getShells();
  for (int i=0; i < shells.length; i++) {
    if (shells[i].getText().equals(title)) {
      theShell=shells[i];
      shellExists=true;
      break;
    }
  }
  if (!shellExists) {
    theShell=new Shell(display,SWT.SHELL_TRIM);
  }
  final Shell shell=theShell;
  shell.setText(title);
  shell.setActive();
  if (shellExists) {
    shell.redraw();
    shell.update();
  }
 else {
    shell.addPaintListener(new PaintListener(){
      public void paintControl(      PaintEvent event){
        StateSpaceInformationItem[] ssInfo=resultPage.getStateSpaceInformation();
        if (ssInfo.length < 2) {
          return;
        }
        long[] data=new long[ssInfo.length + 1];
        long[] times=new long[ssInfo.length + 1];
        data[0]=0;
        times[0]=0;
        long startTime=resultPage.startTime;
        System.out.println(""String_Node_Str"" + (ssInfo[0].getTime().getTime() - startTime));
        if (startTime > ssInfo[0].getTime().getTime() - 1000) {
          startTime=ssInfo[0].getTime().getTime() - 1000;
        }
        for (int i=1; i < data.length; i++) {
switch (columnNumber) {
case StateSpaceLabelProvider.COL_TIME:
            data[i]=i - 1;
          break;
case StateSpaceLabelProvider.COL_DIAMETER:
        data[i]=ssInfo[i - 1].getDiameter();
      break;
case StateSpaceLabelProvider.COL_FOUND:
    data[i]=ssInfo[i - 1].getFoundStates();
  break;
case StateSpaceLabelProvider.COL_DISTINCT:
data[i]=ssInfo[i - 1].getDistinctStates();
break;
case StateSpaceLabelProvider.COL_LEFT:
data[i]=ssInfo[i - 1].getLeftStates();
break;
default :
return;
}
times[i]=ssInfo[i - 1].getTime().getTime() - startTime;
}
if (data == null) {
return;
}
Rectangle rect=shell.getClientArea();
long maxData=0;
for (int i=0; i < data.length; i++) {
if (data[i] > maxData) {
maxData=data[i];
}
}
long maxTime=times[times.length - 1];
if (maxTime > 0) {
long maxDataVal=maxData;
if (maxDataVal == 0) {
maxDataVal=1;
}
int[] pointArray=new int[2 * data.length];
for (int i=0; i < data.length; i++) {
pointArray[2 * i]=(int)((times[i] * rect.width) / maxTime);
pointArray[(2 * i) + 1]=(int)(rect.height - ((data[i] * rect.height) / maxDataVal));
}
event.gc.drawPolyline(pointArray);
}
String stringTime=""String_Node_Str"";
long unreportedTime=maxTime;
long days=maxTime / (1000 * 60 * 60* 24);
if (days > 0) {
unreportedTime=unreportedTime - days * (1000 * 60 * 60* 24);
stringTime=stringTime + days + ((days == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
}
long hours=unreportedTime / (1000 * 60 * 60);
if (hours > 0) {
unreportedTime=unreportedTime - hours * (1000 * 60 * 60);
stringTime=stringTime + hours + ((hours == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
}
unreportedTime=(unreportedTime + (1000 * 26)) / (1000 * 60);
stringTime=stringTime + unreportedTime + ((unreportedTime == 1) ? (""String_Node_Str"") : (""String_Node_Str""));
event.gc.drawString(stringTime,0,0);
event.gc.drawString(""String_Node_Str"" + data[data.length - 1],0,15);
if (maxData != data[data.length - 1]) {
event.gc.drawString(""String_Node_Str"" + maxData,0,30);
}
}
}
);
}
;
if (!shellExists) {
shell.setBounds(100 + 30 * columnNumber,100 + 30 * columnNumber,400,300);
}
shell.open();
}",0.9904189904189904
135911,"/** 
 * Prints to standard error the string (v1 + ""  "" + v2), and returns the value v2.
 */
public static Value Print(Value v1,Value v2){
  ToolIO.out.println(Value.ppr(v1.toString()) + ""String_Node_Str"" + Value.ppr(v2.toString()));
  return v2;
}","/** 
 * Prints to standard error the string (v1 + ""  "" + v2), and returns the value v2.   Modified on 22 June 2011 by LL to call deepNormalize() on the values before printing.  This fixes the same bug that caused PrintT({""a"", ""a""}) to print {""a"", ""a""} instead of {""a""}.  For safety, the values are copied before normalizing, thought that's probably not necessary.
 */
public static Value Print(Value v1,Value v2){
  Value v1c=v1.deepCopy();
  Value v2c=v2.deepCopy();
  v1c.deepNormalize();
  v2c.deepNormalize();
  ToolIO.out.println(Value.ppr(v1c.toString()) + ""String_Node_Str"" + Value.ppr(v2c.toString()));
  return v2;
}",0.5665137614678899
135912,"/** 
 * Prints to standard error the string v1. Always returns TRUE.
 */
public static Value PrintT(Value v1){
  ToolIO.out.println(Value.ppr(v1.toString()));
  return ValTrue;
}","/** 
 * Prints to standard error the string v1. Always returns TRUE. Modified on 22 June 2011 by LL.  See comment on the Print method
 */
public static Value PrintT(Value v1){
  Value v1c=v1.deepCopy();
  v1c.deepNormalize();
  ToolIO.out.println(Value.ppr(v1c.toString()));
  return ValTrue;
}",0.7542372881355932
135913,"/** 
 * Factory method Creates a new specification, the underlying IProject link the root file
 * @param name the name of the specification
 * @param rootFilename the path to the root file name
 * @param importExisting
 */
public static Spec createNewSpec(String name,String rootFilename,boolean importExisting){
  IProject project=ResourceHelper.getProject(name,rootFilename,true,importExisting);
  PreferenceStoreHelper.storeRootFilename(project,rootFilename);
  Spec spec=new Spec(project);
  spec.setLastModified();
  return spec;
}","/** 
 * Factory method Creates a new specification, the underlying IProject link the root file
 * @param name the name of the specification
 * @param rootFilename the path to the root file name 
 * @param importExisting Note: when importing an existing spec, the contents of the .toolbox directory needs to be fixed because it contains absolute path names, which may be incorrect if the spec was moved from someplace else.  Here are the files that seem to need changing: .toolbox/.project : <location> entries .toolbox/.setting/... .prefs  : ProjectRootFile entry. Experiment shows that the rootFilename argument contains the complete path name, from which one could extract the path names of those files and then rewrite them as needed.
 */
public static Spec createNewSpec(String name,String rootFilename,boolean importExisting){
  IProject project=ResourceHelper.getProject(name,rootFilename,true,importExisting);
  PreferenceStoreHelper.storeRootFilename(project,rootFilename);
  Spec spec=new Spec(project);
  spec.setLastModified();
  return spec;
}",0.6737900691389064
135914,"/** 
 * This boolean equals while inside a call to GetMacro.  It is used to   flag an error if a label appears within a macro.                     
 * @throws ParseAlgorithmException 
 */
public static String GetLabel() throws ParseAlgorithmException {
  String nextLabel=""String_Node_Str"";
  if (IsLabelNext()) {
    nextLabel=GetAlgToken();
    if (inGetMacro) {
      ParsingError(""String_Node_Str"");
    }
    ;
    if (nextLabel.equals(""String_Node_Str"")) {
      ParsingError(""String_Node_Str"");
    }
    ;
    if (nextLabel.equals(""String_Node_Str"")) {
      ParsingError(""String_Node_Str"");
    }
    ;
    GobbleThis(""String_Node_Str"");
    hasLabel=true;
    allLabels.put(nextLabel,""String_Node_Str"");
    if (PeekAtAlgToken(1).equals(""String_Node_Str"")) {
      GobbleThis(""String_Node_Str"");
      plusLabels.addElement(nextLabel);
    }
 else {
      if (PeekAtAlgToken(1).equals(""String_Node_Str"")) {
        GobbleThis(""String_Node_Str"");
        minusLabels.addElement(nextLabel);
      }
    }
  }
  ;
  return nextLabel;
}","/** 
 * This boolean equals while inside a call to GetMacro.  It is used to   flag an error if a label appears within a macro.                     
 * @throws ParseAlgorithmException 
 */
public static String GetLabel() throws ParseAlgorithmException {
  String nextLabel=""String_Node_Str"";
  if (IsLabelNext()) {
    nextLabel=GetAlgToken();
    if (inGetMacro) {
      ParsingError(""String_Node_Str"");
    }
    ;
    if (nextLabel.equals(""String_Node_Str"")) {
      ParsingError(""String_Node_Str"");
    }
    ;
    if (nextLabel.equals(""String_Node_Str"")) {
      ParsingError(""String_Node_Str"");
    }
    ;
    GobbleThis(""String_Node_Str"");
    hasLabel=true;
    allLabels.put(nextLabel,""String_Node_Str"");
    if (PeekAtAlgToken(1).equals(""String_Node_Str"")) {
      GobbleThis(""String_Node_Str"");
      plusLabels.addElement(nextLabel);
      omitPC=false;
    }
 else {
      if (PeekAtAlgToken(1).equals(""String_Node_Str"")) {
        GobbleThis(""String_Node_Str"");
        minusLabels.addElement(nextLabel);
        omitPC=false;
      }
    }
  }
  ;
  return nextLabel;
}",0.980244590780809
135915,"public static TLAExpr InnerTokenize(PcalCharReader charReader,boolean isExpr) throws TokenizerException {
  int mode=TLA;
  ncol=charReader.getColumnNumber();
  col=ncol;
  parseExpression=isExpr;
  prevToken=""String_Node_Str"";
  vspec=new Vector(1000,1000);
  reader=charReader;
  linev=new Vector();
  token=""String_Node_Str"";
  nextChar=reader.getNextChar();
  parenDepth=0;
  inQuantifier=false;
switch (mode) {
case MODULE:
    state=PROLOG;
  break;
case TLA:
state=START;
break;
default :
PcalDebug.ReportBug(""String_Node_Str"");
}
;
exprEnd=false;
while ((state != DONE) && !exprEnd) {
switch (state) {
case START:
if (Misc.IsSpace(nextChar)) {
skipNextChar();
gotoStart();
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
state=ID;
}
 else if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM_OR_ID;
}
 else if (nextChar == '\\') {
addNextChar();
state=BS;
}
 else if (nextChar == '-') {
addNextChar();
state=DASH1;
}
 else if (nextChar == '=') {
addNextChar();
state=EQ1;
}
 else if (nextChar == '(') {
skipNextChar();
state=LEFT_PAREN;
}
 else if (nextChar == '""') {
skipNextChar();
state=STRING;
}
 else if (nextChar == '\n') {
skipNextChar();
startNewLine();
gotoStart();
}
 else if (PcalBuiltInSymbols.IsBuiltInPrefix(""String_Node_Str"" + nextChar)) {
addNextChar();
state=BUILT_IN;
}
 else if (nextChar == '\t') {
if (mode == MODULE) {
throw new TokenizerException(""String_Node_Str"");
}
;
state=DONE;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
;
break;
case ID:
if ((token.length() == 3) && (token.equals(""String_Node_Str"") || token.equals(""String_Node_Str""))) {
TokenOut(Token.BUILTIN);
gotoStart();
}
 else if (Misc.IsLetter(nextChar) || Misc.IsDigit(nextChar)) {
addNextChar();
}
 else if (PcalBuiltInSymbols.IsBuiltInSymbol(token)) {
if (token.equals(""String_Node_Str"")) {
mdepth=mdepth + 1;
}
TokenOut(Token.BUILTIN);
gotoStart();
}
 else {
TokenOut(Token.IDENT);
gotoStart();
}
;
break;
case NUM_OR_ID:
if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM_OR_ID;
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
state=ID;
}
 else {
TokenOut(Token.NUMBER);
gotoStart();
}
break;
case BS:
if ((nextChar == 'b') || (nextChar == 'B') || (nextChar == 'o')|| (nextChar == 'O')|| (nextChar == 'h')|| (nextChar == 'H')) {
addNextChar();
state=NUM_OR_BI;
}
 else if (Misc.IsLetter(nextChar)) {
state=BSBUILT_IN;
}
 else if (nextChar == '*') {
skipNextChar();
token=""String_Node_Str"";
state=LINE_COMMENT;
}
 else {
state=BUILT_IN;
}
break;
case NUM_OR_BI:
if (Misc.IsDigit(nextChar)) {
state=NUM;
}
 else {
state=BSBUILT_IN;
}
;
break;
case NUM:
if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM;
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
if (token.charAt(0) == '\\') {
TokenizingError(""String_Node_Str"");
}
 else {
state=ID;
}
;
}
 else {
TokenOut(Token.NUMBER);
gotoStart();
}
break;
case BSBUILT_IN:
if (Misc.IsLetter(nextChar) && (nextChar != '_')) {
addNextChar();
state=BSBUILT_IN;
}
 else if (PcalBuiltInSymbols.IsBuiltInSymbol(token)) {
TokenOut(Token.BUILTIN);
gotoStart();
}
 else {
TokenizingError(""String_Node_Str"");
}
;
break;
case BUILT_IN:
if (PcalBuiltInSymbols.IsBuiltInPrefix(token + nextChar)) {
addNextChar();
}
 else {
if (!PcalBuiltInSymbols.IsBuiltInSymbol(token)) {
reader.backspace();
while (!PcalBuiltInSymbols.IsBuiltInSymbol(token)) {
reader.backspace();
if (token.length() == 0) {
TokenizingError(""String_Node_Str"");
}
;
token=token.substring(0,token.length() - 1);
}
;
nextChar=reader.getNextChar();
}
;
TokenOut(Token.BUILTIN);
gotoStart();
}
break;
case DASH1:
if (nextChar == '-') {
addNextChar();
state=DASH2;
}
 else {
state=BUILT_IN;
}
break;
case DASH2:
if (nextChar == '-') {
addNextChar();
state=DASH3;
}
 else {
state=BUILT_IN;
}
break;
case DASH3:
if (nextChar == '-') {
addNextChar();
state=DASHES;
}
 else {
TokenizingError(""String_Node_Str"");
}
break;
case DASHES:
if (nextChar == '-') {
addNextChar();
state=DASHES;
}
 else {
TokenOut(Token.DASHES);
gotoStart();
}
break;
case EQ1:
if (nextChar == '=') {
addNextChar();
state=EQ2;
}
 else {
state=BUILT_IN;
}
break;
case EQ2:
if (nextChar == '=') {
addNextChar();
state=EQ3;
}
 else {
state=BUILT_IN;
}
break;
case EQ3:
if (nextChar == '=') {
addNextChar();
state=EQS;
}
 else {
TokenizingError(""String_Node_Str"");
}
break;
case EQS:
if (nextChar == '=') {
addNextChar();
state=EQS;
}
 else {
mdepth=mdepth - 1;
TokenOut(Token.END_MODULE);
if ((mdepth > 0) || (mode == TLA)) {
gotoStart();
}
 else if (mdepth == 0) {
state=EPILOG;
}
 else {
throw new TokenizerException(""String_Node_Str"" + (reader.getLineNumber() + 1));
}
}
break;
case LEFT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=1;
state=COMMENT;
}
 else {
token=""String_Node_Str"";
state=BUILT_IN;
}
break;
case STRING:
if (nextChar == '\\') {
addNextChar();
state=ESC_STRING;
}
 else if (nextChar == '""') {
skipNextChar();
TokenOut(Token.STRING);
gotoStart();
}
 else if (PcalBuiltInSymbols.IsStringChar(nextChar)) {
addNextChar();
state=STRING;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
break;
case ESC_STRING:
if ((nextChar == '\""') || (nextChar == '\\') || (nextChar == 't')|| (nextChar == 'n')|| (nextChar == 'f')|| (nextChar == 'r')) {
addNextChar();
state=STRING;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
break;
case LINE_COMMENT:
if (nextChar == '(') {
skipNextChar();
state=LINE_COM_PAREN;
}
 else if ((nextChar == '*') && (cdepth > 0)) {
skipNextChar();
state=LINE_COM_STAR;
}
 else if ((nextChar == '\n') || (nextChar == '\t')) {
CommentTokenOut();
cdepth=0;
gotoStart();
}
 else {
if (cdepth == 0) {
addNextChar();
}
 else {
skipNextChar();
}
;
state=LINE_COMMENT;
}
break;
case LINE_COM_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=LINE_COMMENT;
}
 else {
if (cdepth == 0) {
token=token + ""String_Node_Str"";
}
;
state=LINE_COMMENT;
}
break;
case LINE_COM_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
PcalDebug.Assert(cdepth >= 0,""String_Node_Str"");
state=LINE_COMMENT;
}
 else {
if (cdepth == 0) {
token=token + ""String_Node_Str"";
}
;
state=LINE_COMMENT;
}
break;
case COMMENT:
if (nextChar == '*') {
skipNextChar();
state=COMMENT_STAR;
}
 else if (nextChar == '(') {
skipNextChar();
state=COMMENT_PAREN;
}
 else if (nextChar == '\n') {
CommentTokenOut();
skipNextChar();
startNewLine();
state=OR_COMMENT;
}
 else if (nextChar == '\t') {
throw new TokenizerException(""String_Node_Str"");
}
 else {
if (cdepth == 1) {
addNextChar();
}
 else {
skipNextChar();
}
;
}
break;
case COMMENT_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
if (cdepth == 0) {
CommentTokenOut();
gotoStart();
}
 else {
state=COMMENT;
}
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=COMMENT;
}
break;
case COMMENT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=COMMENT;
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=COMMENT;
}
break;
case OR_COMMENT:
if (nextChar == '*') {
skipNextChar();
state=OR_COMMENT_STAR;
}
 else if (nextChar == '(') {
skipNextChar();
state=OR_COMMENT_PAREN;
}
 else if (nextChar == '\n') {
CommentTokenOut();
skipNextChar();
startNewLine();
state=OR_COMMENT;
}
 else if (nextChar == '\t') {
throw new TokenizerException(""String_Node_Str"");
}
 else {
if (cdepth == 1) {
addNextChar();
}
 else {
skipNextChar();
}
;
}
break;
case OR_COMMENT_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
PcalDebug.Assert(cdepth >= 0);
if (cdepth == 0) {
CommentTokenOut();
gotoStart();
}
 else {
state=OR_COMMENT;
}
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=OR_COMMENT;
}
break;
case OR_COMMENT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=OR_COMMENT;
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=OR_COMMENT;
}
break;
case PROLOG:
if (nextChar == '-') {
token1=token;
col1=col;
col=ncol;
token=""String_Node_Str"";
skipNextChar();
state=PROLOG_DASH;
}
 else if (nextChar == '\n') {
TokenOut(Token.PROLOG);
skipNextChar();
startNewLine();
}
 else if (nextChar == '\t') {
throw new TokenizerException(""String_Node_Str"");
}
 else {
addNextChar();
}
break;
case PROLOG_DASH:
PcalDebug.Assert(token.length() <= 3);
if (nextChar == '-') {
addNextChar();
if (token.length() == 4) {
state=PROLOG_DASHES;
}
 else {
}
;
}
 else {
token=token1 + token;
col=col1;
state=PROLOG;
}
break;
case PROLOG_DASHES:
if (nextChar == '-') {
addNextChar();
}
 else {
token2=token;
col2=col;
token=""String_Node_Str"";
col=ncol;
state=PROLOG_SPACES;
}
break;
case PROLOG_SPACES:
if (nextChar == ' ') {
addNextChar();
}
 else if (Misc.IsLetter(nextChar)) {
token3=token;
col3=ncol;
token=""String_Node_Str"";
state=PROLOG_ID;
}
 else {
token=token1 + token2;
col=col1;
state=PROLOG;
}
break;
case PROLOG_ID:
if (Misc.IsLetter(nextChar)) {
addNextChar();
}
 else if (token.equals(""String_Node_Str"")) {
token=token1;
col=col1;
TokenOut(Token.PROLOG);
token=token2;
col=col2;
TokenOut(Token.DASHES);
token=""String_Node_Str"";
col=col3;
TokenOut(Token.BUILTIN);
token=""String_Node_Str"";
mdepth=1;
gotoStart();
}
 else {
token=token1 + token2 + token3;
col=col1;
state=PROLOG;
}
break;
case EPILOG:
if (nextChar == '\n') {
TokenOut(Token.EPILOG);
skipNextChar();
startNewLine();
}
 else if (nextChar == '\t') {
TokenOut(Token.EPILOG);
state=DONE;
}
 else {
addNextChar();
}
break;
default :
PcalDebug.ReportBug(""String_Node_Str"");
}
;
}
;
if (nextChar != '\n') {
reader.backspace();
}
;
TLAExpr rval=new TLAExpr(vspec);
rval.normalize();
return rval;
}","public static TLAExpr InnerTokenize(PcalCharReader charReader,boolean isExpr) throws TokenizerException {
  int mode=TLA;
  ncol=charReader.getColumnNumber();
  col=ncol;
  parseExpression=isExpr;
  prevToken=""String_Node_Str"";
  vspec=new Vector(1000,1000);
  reader=charReader;
  linev=new Vector();
  token=""String_Node_Str"";
  nextChar=reader.getNextChar();
  parenDepth=0;
  inQuantifier=false;
switch (mode) {
case MODULE:
    state=PROLOG;
  break;
case TLA:
state=START;
break;
default :
PcalDebug.ReportBug(""String_Node_Str"");
}
;
exprEnd=false;
while ((state != DONE) && !exprEnd) {
switch (state) {
case START:
if (Misc.IsSpace(nextChar)) {
skipNextChar();
gotoStart();
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
state=ID;
}
 else if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM_OR_ID;
}
 else if (nextChar == '\\') {
addNextChar();
state=BS;
}
 else if (nextChar == '-') {
addNextChar();
state=DASH1;
}
 else if (nextChar == '=') {
addNextChar();
state=EQ1;
}
 else if (nextChar == '(') {
skipNextChar();
state=LEFT_PAREN;
}
 else if (nextChar == '""') {
skipNextChar();
state=STRING;
}
 else if (nextChar == '\n') {
skipNextChar();
startNewLine();
gotoStart();
}
 else if (PcalBuiltInSymbols.IsBuiltInPrefix(""String_Node_Str"" + nextChar)) {
addNextChar();
state=BUILT_IN;
}
 else if (nextChar == '\t') {
if (mode == MODULE) {
throw new TokenizerException(""String_Node_Str"");
}
;
state=DONE;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
;
break;
case ID:
if ((token.length() == 3) && (token.equals(""String_Node_Str"") || token.equals(""String_Node_Str""))) {
TokenOut(Token.BUILTIN);
gotoStart();
}
 else if (Misc.IsLetter(nextChar) || Misc.IsDigit(nextChar)) {
addNextChar();
}
 else if (PcalBuiltInSymbols.IsBuiltInSymbol(token)) {
if (token.equals(""String_Node_Str"")) {
mdepth=mdepth + 1;
}
TokenOut(Token.BUILTIN);
gotoStart();
}
 else {
TokenOut(Token.IDENT);
gotoStart();
}
;
break;
case NUM_OR_ID:
if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM_OR_ID;
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
state=ID;
}
 else {
TokenOut(Token.NUMBER);
gotoStart();
}
break;
case BS:
if ((nextChar == 'b') || (nextChar == 'B') || (nextChar == 'o')|| (nextChar == 'O')|| (nextChar == 'h')|| (nextChar == 'H')) {
addNextChar();
state=NUM_OR_BI;
}
 else if (Misc.IsLetter(nextChar)) {
state=BSBUILT_IN;
}
 else if (nextChar == '*') {
skipNextChar();
token=""String_Node_Str"";
state=LINE_COMMENT;
}
 else {
state=BUILT_IN;
}
break;
case NUM_OR_BI:
if (Misc.IsDigit(nextChar)) {
state=NUM;
}
 else {
state=BSBUILT_IN;
}
;
break;
case NUM:
if (Misc.IsDigit(nextChar)) {
addNextChar();
state=NUM;
}
 else if (Misc.IsLetter(nextChar)) {
addNextChar();
if (token.charAt(0) == '\\') {
TokenizingError(""String_Node_Str"");
}
 else {
state=ID;
}
;
}
 else {
TokenOut(Token.NUMBER);
gotoStart();
}
break;
case BSBUILT_IN:
if (Misc.IsLetter(nextChar) && (nextChar != '_')) {
addNextChar();
state=BSBUILT_IN;
}
 else if (PcalBuiltInSymbols.IsBuiltInSymbol(token)) {
TokenOut(Token.BUILTIN);
gotoStart();
}
 else {
TokenizingError(""String_Node_Str"");
}
;
break;
case BUILT_IN:
if (PcalBuiltInSymbols.IsBuiltInPrefix(token + nextChar)) {
addNextChar();
}
 else {
if (!PcalBuiltInSymbols.IsBuiltInSymbol(token)) {
reader.backspace();
while (!PcalBuiltInSymbols.IsBuiltInSymbol(token)) {
reader.backspace();
if (token.length() == 0) {
TokenizingError(""String_Node_Str"");
}
;
token=token.substring(0,token.length() - 1);
}
;
skipNextChar();
}
;
TokenOut(Token.BUILTIN);
gotoStart();
}
break;
case DASH1:
if (nextChar == '-') {
addNextChar();
state=DASH2;
}
 else {
state=BUILT_IN;
}
break;
case DASH2:
if (nextChar == '-') {
addNextChar();
state=DASH3;
}
 else {
state=BUILT_IN;
}
break;
case DASH3:
if (nextChar == '-') {
addNextChar();
state=DASHES;
}
 else {
TokenizingError(""String_Node_Str"");
}
break;
case DASHES:
if (nextChar == '-') {
addNextChar();
state=DASHES;
}
 else {
TokenOut(Token.DASHES);
gotoStart();
}
break;
case EQ1:
if (nextChar == '=') {
addNextChar();
state=EQ2;
}
 else {
state=BUILT_IN;
}
break;
case EQ2:
if (nextChar == '=') {
addNextChar();
state=EQ3;
}
 else {
state=BUILT_IN;
}
break;
case EQ3:
if (nextChar == '=') {
addNextChar();
state=EQS;
}
 else {
TokenizingError(""String_Node_Str"");
}
break;
case EQS:
if (nextChar == '=') {
addNextChar();
state=EQS;
}
 else {
mdepth=mdepth - 1;
TokenOut(Token.END_MODULE);
if ((mdepth > 0) || (mode == TLA)) {
gotoStart();
}
 else if (mdepth == 0) {
state=EPILOG;
}
 else {
throw new TokenizerException(""String_Node_Str"" + (reader.getLineNumber() + 1));
}
}
break;
case LEFT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=1;
state=COMMENT;
}
 else {
token=""String_Node_Str"";
state=BUILT_IN;
}
break;
case STRING:
if (nextChar == '\\') {
addNextChar();
state=ESC_STRING;
}
 else if (nextChar == '""') {
skipNextChar();
TokenOut(Token.STRING);
gotoStart();
}
 else if (PcalBuiltInSymbols.IsStringChar(nextChar)) {
addNextChar();
state=STRING;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
break;
case ESC_STRING:
if ((nextChar == '\""') || (nextChar == '\\') || (nextChar == 't')|| (nextChar == 'n')|| (nextChar == 'f')|| (nextChar == 'r')) {
addNextChar();
state=STRING;
}
 else {
addNextChar();
TokenizingError(""String_Node_Str"");
}
break;
case LINE_COMMENT:
if (nextChar == '(') {
skipNextChar();
state=LINE_COM_PAREN;
}
 else if ((nextChar == '*') && (cdepth > 0)) {
skipNextChar();
state=LINE_COM_STAR;
}
 else if ((nextChar == '\n') || (nextChar == '\t')) {
CommentTokenOut();
cdepth=0;
gotoStart();
}
 else {
if (cdepth == 0) {
addNextChar();
}
 else {
skipNextChar();
}
;
state=LINE_COMMENT;
}
break;
case LINE_COM_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=LINE_COMMENT;
}
 else {
if (cdepth == 0) {
token=token + ""String_Node_Str"";
}
;
state=LINE_COMMENT;
}
break;
case LINE_COM_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
PcalDebug.Assert(cdepth >= 0,""String_Node_Str"");
state=LINE_COMMENT;
}
 else {
if (cdepth == 0) {
token=token + ""String_Node_Str"";
}
;
state=LINE_COMMENT;
}
break;
case COMMENT:
if (nextChar == '*') {
skipNextChar();
state=COMMENT_STAR;
}
 else if (nextChar == '(') {
skipNextChar();
state=COMMENT_PAREN;
}
 else if (nextChar == '\n') {
CommentTokenOut();
skipNextChar();
startNewLine();
state=OR_COMMENT;
}
 else if (nextChar == '\t') {
throw new TokenizerException(""String_Node_Str"");
}
 else {
if (cdepth == 1) {
addNextChar();
}
 else {
skipNextChar();
}
;
}
break;
case COMMENT_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
if (cdepth == 0) {
CommentTokenOut();
gotoStart();
}
 else {
state=COMMENT;
}
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=COMMENT;
}
break;
case COMMENT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=COMMENT;
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=COMMENT;
}
break;
case OR_COMMENT:
if (nextChar == '*') {
skipNextChar();
state=OR_COMMENT_STAR;
}
 else if (nextChar == '(') {
skipNextChar();
state=OR_COMMENT_PAREN;
}
 else if (nextChar == '\n') {
CommentTokenOut();
skipNextChar();
startNewLine();
state=OR_COMMENT;
}
 else if (nextChar == '\t') {
throw new TokenizerException(""String_Node_Str"");
}
 else {
if (cdepth == 1) {
addNextChar();
}
 else {
skipNextChar();
}
;
}
break;
case OR_COMMENT_STAR:
if (nextChar == ')') {
skipNextChar();
cdepth=cdepth - 1;
PcalDebug.Assert(cdepth >= 0);
if (cdepth == 0) {
CommentTokenOut();
gotoStart();
}
 else {
state=OR_COMMENT;
}
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=OR_COMMENT;
}
break;
case OR_COMMENT_PAREN:
if (nextChar == '*') {
skipNextChar();
cdepth=cdepth + 1;
state=OR_COMMENT;
}
 else {
if (cdepth == 1) {
token=token + ""String_Node_Str"";
}
;
state=OR_COMMENT;
}
break;
case PROLOG:
if (nextChar == '-') {
token1=token;
col1=col;
col=ncol;
token=""String_Node_Str"";
skipNextChar();
state=PROLOG_DASH;
}
 else if (nextChar == '\n') {
TokenOut(Token.PROLOG);
skipNextChar();
startNewLine();
}
 else if (nextChar == '\t') {
throw new TokenizerException(""String_Node_Str"");
}
 else {
addNextChar();
}
break;
case PROLOG_DASH:
PcalDebug.Assert(token.length() <= 3);
if (nextChar == '-') {
addNextChar();
if (token.length() == 4) {
state=PROLOG_DASHES;
}
 else {
}
;
}
 else {
token=token1 + token;
col=col1;
state=PROLOG;
}
break;
case PROLOG_DASHES:
if (nextChar == '-') {
addNextChar();
}
 else {
token2=token;
col2=col;
token=""String_Node_Str"";
col=ncol;
state=PROLOG_SPACES;
}
break;
case PROLOG_SPACES:
if (nextChar == ' ') {
addNextChar();
}
 else if (Misc.IsLetter(nextChar)) {
token3=token;
col3=ncol;
token=""String_Node_Str"";
state=PROLOG_ID;
}
 else {
token=token1 + token2;
col=col1;
state=PROLOG;
}
break;
case PROLOG_ID:
if (Misc.IsLetter(nextChar)) {
addNextChar();
}
 else if (token.equals(""String_Node_Str"")) {
token=token1;
col=col1;
TokenOut(Token.PROLOG);
token=token2;
col=col2;
TokenOut(Token.DASHES);
token=""String_Node_Str"";
col=col3;
TokenOut(Token.BUILTIN);
token=""String_Node_Str"";
mdepth=1;
gotoStart();
}
 else {
token=token1 + token2 + token3;
col=col1;
state=PROLOG;
}
break;
case EPILOG:
if (nextChar == '\n') {
TokenOut(Token.EPILOG);
skipNextChar();
startNewLine();
}
 else if (nextChar == '\t') {
TokenOut(Token.EPILOG);
state=DONE;
}
 else {
addNextChar();
}
break;
default :
PcalDebug.ReportBug(""String_Node_Str"");
}
;
}
;
if (nextChar != '\n') {
reader.backspace();
}
;
TLAExpr rval=new TLAExpr(vspec);
rval.normalize();
return rval;
}",0.9987895373927688
135916,"private static int CommandLineError(String msg){
  ToolIO.out.println(""String_Node_Str"" + msg + ""String_Node_Str"");
  ToolIO.out.println(""String_Node_Str"");
  return STATUS_EXIT_WITH_ERRORS;
}","private static int CommandLineError(String msg){
  PcalDebug.reportError(""String_Node_Str"" + msg + ""String_Node_Str"");
  return STATUS_EXIT_WITH_ERRORS;
}",0.7861271676300579
135917,"/** 
 */
private void GenLabeledStmt(AST.LabeledStmt ast,String context) throws PcalTLAGenException {
  StringBuffer sb=new StringBuffer(ast.label);
  Changed c=new Changed(vars);
  if (mp && (context.equals(""String_Node_Str"") || self.equals(""String_Node_Str"")))   sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  int col=sb.length();
  if (ast.stmts.size() > 1)   sb.append(""String_Node_Str"");
  for (int i=0; i < ast.stmts.size(); i++) {
    GenStmt((AST)ast.stmts.elementAt(i),c,context,sb.toString(),sb.length());
    sb=new StringBuffer(NSpaces(col));
    sb.append(""String_Node_Str"");
  }
  Vector unc=c.Unchanged(wrapColumn - col - ""String_Node_Str"".length());
  if (c.NumUnchanged() > 1) {
    sb=new StringBuffer(NSpaces(col));
    sb.append(""String_Node_Str"");
    int here=sb.length();
    sb.append((String)unc.elementAt(0));
    for (int i=1; i < unc.size(); i++) {
      tlacode.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(here));
      sb.append((String)unc.elementAt(i));
    }
    sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
  }
 else   if (c.NumUnchanged() == 1)   tlacode.addElement(NSpaces(col) + ""String_Node_Str"" + c.Unchanged());
  tlacode.addElement(""String_Node_Str"");
}","/** 
 */
private void GenLabeledStmt(AST.LabeledStmt ast,String context) throws PcalTLAGenException {
  StringBuffer sb=new StringBuffer(ast.label);
  Changed c=new Changed(vars);
  if (mp && (context.equals(""String_Node_Str"") || selfIsSelf)) {
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  int col=sb.length();
  kludgeToFixPCHandlingBug=col;
  if (ast.stmts.size() > 1) {
    sb.append(""String_Node_Str"");
    kludgeToFixPCHandlingBug=kludgeToFixPCHandlingBug + 3;
  }
  for (int i=0; i < ast.stmts.size(); i++) {
    GenStmt((AST)ast.stmts.elementAt(i),c,context,sb.toString(),sb.length());
    sb=new StringBuffer(NSpaces(col));
    sb.append(""String_Node_Str"");
  }
  Vector unc=c.Unchanged(wrapColumn - col - ""String_Node_Str"".length());
  if (c.NumUnchanged() > 1) {
    sb=new StringBuffer(NSpaces(col));
    sb.append(""String_Node_Str"");
    int here=sb.length();
    sb.append((String)unc.elementAt(0));
    for (int i=1; i < unc.size(); i++) {
      tlacode.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(here));
      sb.append((String)unc.elementAt(i));
    }
    sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
  }
 else   if (c.NumUnchanged() == 1)   tlacode.addElement(NSpaces(col) + ""String_Node_Str"" + c.Unchanged());
  tlacode.addElement(""String_Node_Str"");
}",0.8961790814357391
135918,"/** 
 * @param ast
 * @param c
 * @param context
 * @param prefix
 * @param col
 * @throws PcalTLAGenException
 */
private void GenAssign(AST.Assign ast,Changed c,String context,String prefix,int col) throws PcalTLAGenException {
  Changed cThis=new Changed(c);
  StringBuffer sb=new StringBuffer();
  Vector vlines=new Vector();
  ast.ass=SortSass(ast.ass);
  int i=0;
  int numAssigns=0;
  while (i < ast.ass.size()) {
    int iFirst=i;
    AST.SingleAssign sF=(AST.SingleAssign)ast.ass.elementAt(i);
    int iLast=i;
    AST.SingleAssign sL=(AST.SingleAssign)ast.ass.elementAt(i);
    while (iLast < ast.ass.size() && sF.lhs.var.equals(sL.lhs.var)) {
      iLast=iLast + 1;
      if (iLast < ast.ass.size())       sL=(AST.SingleAssign)ast.ass.elementAt(iLast);
    }
    iLast=iLast - 1;
    if (cThis.Set(sF.lhs.var) > 1 || (iLast - iFirst > 0 && EmptyExpr(sF.lhs.sub)))     throw new PcalTLAGenException(""String_Node_Str"" + sF.lhs.var,ast);
    numAssigns=numAssigns + 1;
    Vector lines=new Vector();
    if (iFirst == iLast) {
      AST.SingleAssign sass=sF;
      TLAExpr sub=AddSubscriptsToExpr(sass.lhs.sub,SubExpr(Self(context)),c);
      TLAExpr rhs=AddSubscriptsToExpr(sass.rhs,SubExpr(Self(context)),c);
      if (mp && (sass.lhs.var.equals(""String_Node_Str"") || IsProcedureVar(sass.lhs.var) || IsProcessSetVar(sass.lhs.var)|| sass.lhs.var.equals(""String_Node_Str""))) {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int wrapCol=sb.length() + 2;
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        if (sb.length() + prefix.length() > ssWrapColumn) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(wrapCol));
        }
        sb.append(""String_Node_Str"");
        sb.append(self);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=sub.toStringVector();
        if (sv.size() > 0) {
          sb.append((String)sv.elementAt(0));
          for (int v=1; v < sv.size(); v++) {
            lines.addElement(sb.toString());
            sb=new StringBuffer(NSpaces(here));
            sb.append((String)sv.elementAt(v));
          }
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        lines.addElement(sb.toString());
        sb=new StringBuffer();
      }
 else       if (!EmptyExpr(sass.lhs.sub)) {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=sub.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        lines.addElement(sb.toString());
        sb=new StringBuffer();
      }
 else {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=Parenthesize(rhs.toStringVector());
        for (int v=0; v < sv.size(); v++) {
          sb.append((String)sv.elementAt(v));
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
        }
        sb=new StringBuffer();
      }
    }
 else {
      AST.SingleAssign sass=sF;
      sb.append(sass.lhs.var);
      sb.append(""String_Node_Str"");
      sb.append(sass.lhs.var);
      sb.append(""String_Node_Str"");
      int cc=sb.length();
      boolean subscript=(mp && (IsProcedureVar(sass.lhs.var) || IsProcessSetVar(sass.lhs.var)));
      while (iFirst <= iLast) {
        sass=(AST.SingleAssign)ast.ass.elementAt(iFirst);
        TLAExpr sub=AddSubscriptsToExpr(sass.lhs.sub,SubExpr(Self(context)),c);
        TLAExpr rhs=AddSubscriptsToExpr(sass.rhs,SubExpr(Self(context)),c);
        sb.append(""String_Node_Str"");
        if (subscript) {
          sb.append(""String_Node_Str"" + Self(context) + ""String_Node_Str"");
        }
        int here=sb.length();
        Vector sv=sub.toStringVector();
        if (sv.size() > 0) {
          sb.append((String)sv.elementAt(0));
          for (int v=1; v < sv.size(); v++) {
            lines.addElement(sb.toString());
            sb=new StringBuffer(NSpaces(here));
            sb.append((String)sv.elementAt(v));
          }
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(((iFirst == iLast) ? ""String_Node_Str"" : ""String_Node_Str""));
        lines.addElement(sb.toString());
        sb=new StringBuffer();
        if (iFirst < iLast)         AddSpaces(sb,cc);
        iFirst=iFirst + 1;
      }
    }
    vlines.addElement(lines);
    i=iLast + 1;
  }
  c.Merge(cThis);
  sb=new StringBuffer(prefix);
  col=sb.length();
  if (numAssigns > 1)   sb.append(""String_Node_Str"");
  if (vlines.size() > 0) {
    for (int v1=0; v1 < vlines.size(); v1++) {
      Vector vl=(Vector)vlines.elementAt(v1);
      for (int v2=0; v2 < vl.size(); v2++) {
        sb.append((String)vl.elementAt(v2));
        tlacode.addElement(sb.toString());
        sb=new StringBuffer(NSpaces(col));
        if ((v1 > 0 || numAssigns > 1) && (v2 != vl.size() - 1))         sb.append(""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
    }
  }
}","/** 
 * @param ast
 * @param c
 * @param context
 * @param prefix
 * @param col
 * @throws PcalTLAGenException
 */
private void GenAssign(AST.Assign ast,Changed c,String context,String prefix,int col) throws PcalTLAGenException {
  Changed cThis=new Changed(c);
  StringBuffer sb=new StringBuffer();
  Vector vlines=new Vector();
  ast.ass=SortSass(ast.ass);
  int i=0;
  int numAssigns=0;
  while (i < ast.ass.size()) {
    int iFirst=i;
    AST.SingleAssign sF=(AST.SingleAssign)ast.ass.elementAt(i);
    int iLast=i;
    AST.SingleAssign sL=(AST.SingleAssign)ast.ass.elementAt(i);
    while (iLast < ast.ass.size() && sF.lhs.var.equals(sL.lhs.var)) {
      iLast=iLast + 1;
      if (iLast < ast.ass.size())       sL=(AST.SingleAssign)ast.ass.elementAt(iLast);
    }
    iLast=iLast - 1;
    if (cThis.Set(sF.lhs.var) > 1 || (iLast - iFirst > 0 && EmptyExpr(sF.lhs.sub)))     throw new PcalTLAGenException(""String_Node_Str"" + sF.lhs.var,ast);
    numAssigns=numAssigns + 1;
    Vector lines=new Vector();
    if (iFirst == iLast) {
      AST.SingleAssign sass=sF;
      TLAExpr sub=AddSubscriptsToExpr(sass.lhs.sub,SubExpr(Self(context)),c);
      TLAExpr rhs=AddSubscriptsToExpr(sass.rhs,SubExpr(Self(context)),c);
      if (mp && (sass.lhs.var.equals(""String_Node_Str"") || IsProcedureVar(sass.lhs.var) || IsProcessSetVar(sass.lhs.var)|| sass.lhs.var.equals(""String_Node_Str""))) {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int wrapCol=sb.length() + 2;
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        Vector selfAsSV=self.toStringVector();
        if ((sb.length() + prefix.length() > ssWrapColumn) && (selfAsSV.size() == 0)) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(wrapCol));
        }
        sb.append(""String_Node_Str"");
        int here=sb.length();
        for (int idx=0; idx < selfAsSV.size(); idx++) {
          if (idx > 0) {
            sb.append(""String_Node_Str"");
            sb.append(NSpaces(here + kludgeToFixPCHandlingBug));
          }
          sb.append((String)selfAsSV.elementAt(idx));
        }
        sb.append(""String_Node_Str"");
        here=here + ((String)selfAsSV.elementAt(selfAsSV.size() - 1)).length() + 1;
        Vector sv=sub.toStringVector();
        if (sv.size() > 0) {
          sb.append((String)sv.elementAt(0));
          for (int v=1; v < sv.size(); v++) {
            lines.addElement(sb.toString());
            sb=new StringBuffer(NSpaces(here));
            sb.append((String)sv.elementAt(v));
          }
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        lines.addElement(sb.toString());
        sb=new StringBuffer();
      }
 else       if (!EmptyExpr(sass.lhs.sub)) {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=sub.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        lines.addElement(sb.toString());
        sb=new StringBuffer();
      }
 else {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=Parenthesize(rhs.toStringVector());
        for (int v=0; v < sv.size(); v++) {
          sb.append((String)sv.elementAt(v));
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
        }
        sb=new StringBuffer();
      }
    }
 else {
      AST.SingleAssign sass=sF;
      sb.append(sass.lhs.var);
      sb.append(""String_Node_Str"");
      sb.append(sass.lhs.var);
      sb.append(""String_Node_Str"");
      int cc=sb.length();
      boolean subscript=(mp && (IsProcedureVar(sass.lhs.var) || IsProcessSetVar(sass.lhs.var)));
      while (iFirst <= iLast) {
        sass=(AST.SingleAssign)ast.ass.elementAt(iFirst);
        TLAExpr sub=AddSubscriptsToExpr(sass.lhs.sub,SubExpr(Self(context)),c);
        TLAExpr rhs=AddSubscriptsToExpr(sass.rhs,SubExpr(Self(context)),c);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        if (subscript) {
          Vector selfAsSV=Self(context).toStringVector();
          for (int idx=0; idx < selfAsSV.size(); idx++) {
            String start=""String_Node_Str"";
            if (idx == 0) {
              sb.append(""String_Node_Str"");
            }
 else {
              sb.append(""String_Node_Str"");
              sb.append(NSpaces(here + 1));
            }
            sb.append((String)selfAsSV.elementAt(idx));
          }
          sb.append(""String_Node_Str"");
          here=here + ((String)selfAsSV.elementAt(selfAsSV.size() - 1)).length() + 2;
        }
        Vector sv=sub.toStringVector();
        if (sv.size() > 0) {
          sb.append((String)sv.elementAt(0));
          for (int v=1; v < sv.size(); v++) {
            lines.addElement(sb.toString());
            sb=new StringBuffer(NSpaces(here));
            sb.append((String)sv.elementAt(v));
          }
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(((iFirst == iLast) ? ""String_Node_Str"" : ""String_Node_Str""));
        lines.addElement(sb.toString());
        sb=new StringBuffer();
        if (iFirst < iLast)         AddSpaces(sb,cc);
        iFirst=iFirst + 1;
      }
    }
    vlines.addElement(lines);
    i=iLast + 1;
  }
  c.Merge(cThis);
  sb=new StringBuffer(prefix);
  col=sb.length();
  if (numAssigns > 1)   sb.append(""String_Node_Str"");
  if (vlines.size() > 0) {
    for (int v1=0; v1 < vlines.size(); v1++) {
      Vector vl=(Vector)vlines.elementAt(v1);
      for (int v2=0; v2 < vl.size(); v2++) {
        sb.append((String)vl.elementAt(v2));
        tlacode.addElement(sb.toString());
        sb=new StringBuffer(NSpaces(col));
        if ((v1 > 0 || numAssigns > 1) && (v2 != vl.size() - 1))         sb.append(""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
    }
  }
}",0.919987968115506
135919,"/** 
 */
private String Self(String context){
  String s=null;
  if (mp) {
    if (context.equals(""String_Node_Str""))     s=""String_Node_Str"";
 else     s=self;
  }
  return s;
}","/** 
 */
private TLAExpr Self(String context){
  TLAExpr s=null;
  if (mp) {
    if (context.equals(""String_Node_Str""))     s=selfAsExpr();
 else     s=self;
  }
  return s;
}",0.8611898016997167
135920,"/** 
 */
private void GenNext(){
  Vector nextS=new Vector();
  StringBuffer sb=new StringBuffer();
  int max, col;
  max=wrapColumn - (""String_Node_Str"".length());
  for (int i=0; i < nextStep.size(); i++) {
    String a=(String)nextStep.elementAt(i);
    if (a.length() + ""String_Node_Str"".length() + sb.length() > max) {
      nextS.addElement(sb.toString());
      sb=new StringBuffer();
    }
    if (sb.length() > 0)     sb.append(""String_Node_Str"");
    sb.append(a);
  }
  if (sb.length() > 0)   nextS.addElement(sb.toString());
  Vector nextSS=new Vector();
  String nextSSstart=""String_Node_Str"";
  sb=new StringBuffer();
  max=wrapColumn - (""String_Node_Str"".length());
  if (mp && st.procs.size() > 0) {
    for (int i=0; i < st.procs.size(); i++) {
      PcalSymTab.ProcedureEntry p=(PcalSymTab.ProcedureEntry)st.procs.elementAt(i);
      if ((p.name.length() + ""String_Node_Str"".length() + sb.length()) > max) {
        nextSS.addElement(sb.toString());
        sb=new StringBuffer();
      }
      if (sb.length() > 0)       sb.append(""String_Node_Str"");
      sb.append(p.name);
      sb.append(""String_Node_Str"");
    }
    if (sb.length() > 0)     nextSS.addElement(sb.toString() + ""String_Node_Str"");
  }
  Vector nextSSP=new Vector();
  if (mp && st.processes.size() > 0)   for (int i=0; i < st.processes.size(); i++) {
    PcalSymTab.ProcessEntry p=(PcalSymTab.ProcessEntry)st.processes.elementAt(i);
    if (p.isEq)     continue;
    Vector vec=new Vector();
    sb=new StringBuffer();
    sb.append(""String_Node_Str"");
    Vector sv=p.id.toStringVector();
    col=sb.length();
    sb.append((String)sv.elementAt(0));
    for (int j=1; j < sv.size(); j++) {
      vec.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(col));
      sb.append((String)sv.elementAt(j));
    }
    sb.append(""String_Node_Str"");
    sb.append(p.name);
    sb.append(""String_Node_Str"");
    vec.addElement(sb.toString());
    nextSSP.addElement(vec);
  }
  sb=new StringBuffer(""String_Node_Str"");
  col=sb.length() + 2;
  for (int i=0; i < nextS.size(); i++) {
    sb.append((String)nextS.elementAt(i));
    tlacode.addElement(sb.toString());
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (nextSS.size() > 0) {
    sb.append(nextSSstart);
    int col2=sb.length();
    if (nextSS.size() > 1)     sb.append(""String_Node_Str"");
    for (int i=0; i < nextSS.size(); i++) {
      sb.append((String)nextSS.elementAt(i));
      tlacode.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(col2) + ""String_Node_Str"");
    }
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (nextSSP.size() > 0)   for (int i=0; i < nextSSP.size(); i++) {
    Vector v=(Vector)nextSSP.elementAt(i);
    for (int j=0; j < v.size(); j++) {
      String line=(String)v.elementAt(j);
      sb.append(line);
      tlacode.addElement(sb.toString());
      if ((nextSS.size() == 0) && (i == 0)) {
        sb=new StringBuffer(NSpaces(col - 2));
      }
 else {
        sb=new StringBuffer(NSpaces(col + 4));
      }
    }
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (!PcalParams.NoDoneDisjunct) {
    sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
    sb=new StringBuffer(NSpaces(col + 4));
    if (mp)     sb.append(""String_Node_Str"" + ""String_Node_Str"");
 else     sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
  }
  ;
  tlacode.addElement(""String_Node_Str"");
}","/** 
 */
private void GenNext(){
  Vector nextS=new Vector();
  StringBuffer sb=new StringBuffer();
  int max, col;
  max=wrapColumn - (""String_Node_Str"".length());
  for (int i=0; i < nextStep.size(); i++) {
    String a=(String)nextStep.elementAt(i);
    if (a.length() + ""String_Node_Str"".length() + sb.length() > max) {
      nextS.addElement(sb.toString());
      sb=new StringBuffer();
    }
    if (sb.length() > 0)     sb.append(""String_Node_Str"");
    sb.append(a);
  }
  if (sb.length() > 0)   nextS.addElement(sb.toString());
  Vector nextSS=new Vector();
  String nextSSstart=""String_Node_Str"";
  sb=new StringBuffer();
  max=wrapColumn - (""String_Node_Str"".length());
  if (mp && st.procs.size() > 0) {
    for (int i=0; i < st.procs.size(); i++) {
      PcalSymTab.ProcedureEntry p=(PcalSymTab.ProcedureEntry)st.procs.elementAt(i);
      if ((p.name.length() + ""String_Node_Str"".length() + sb.length()) > max) {
        nextSS.addElement(sb.toString());
        sb=new StringBuffer();
      }
      if (sb.length() > 0)       sb.append(""String_Node_Str"");
      sb.append(p.name);
      sb.append(""String_Node_Str"");
    }
    if (sb.length() > 0)     nextSS.addElement(sb.toString() + ""String_Node_Str"");
  }
  Vector nextSSP=new Vector();
  if (mp && st.processes.size() > 0)   for (int i=0; i < st.processes.size(); i++) {
    PcalSymTab.ProcessEntry p=(PcalSymTab.ProcessEntry)st.processes.elementAt(i);
    if (p.isEq)     continue;
    Vector vec=new Vector();
    sb=new StringBuffer();
    sb.append(""String_Node_Str"");
    Vector sv=p.id.toStringVector();
    col=sb.length();
    sb.append((String)sv.elementAt(0));
    for (int j=1; j < sv.size(); j++) {
      vec.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(col));
      sb.append((String)sv.elementAt(j));
    }
    sb.append(""String_Node_Str"");
    sb.append(p.name);
    sb.append(""String_Node_Str"");
    vec.addElement(sb.toString());
    nextSSP.addElement(vec);
  }
  sb=new StringBuffer(""String_Node_Str"");
  col=sb.length() + 2;
  for (int i=0; i < nextS.size(); i++) {
    sb.append((String)nextS.elementAt(i));
    tlacode.addElement(sb.toString());
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (nextSS.size() > 0) {
    sb.append(nextSSstart);
    int col2=sb.length();
    if (nextSS.size() > 1)     sb.append(""String_Node_Str"");
    for (int i=0; i < nextSS.size(); i++) {
      sb.append((String)nextSS.elementAt(i));
      tlacode.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(col2) + ""String_Node_Str"");
    }
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (nextSSP.size() > 0)   for (int i=0; i < nextSSP.size(); i++) {
    Vector v=(Vector)nextSSP.elementAt(i);
    for (int j=0; j < v.size(); j++) {
      String line=(String)v.elementAt(j);
      sb.append(line);
      tlacode.addElement(sb.toString());
      if ((nextS.size() == 0) && (nextSS.size() == 0) && (i == 0)) {
        sb=new StringBuffer(NSpaces(col - 2));
      }
 else {
        sb=new StringBuffer(NSpaces(col + 4));
      }
    }
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (!PcalParams.NoDoneDisjunct) {
    sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
    sb=new StringBuffer(NSpaces(col + 4));
    if (mp)     sb.append(""String_Node_Str"" + ""String_Node_Str"");
 else     sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
  }
  ;
  tlacode.addElement(""String_Node_Str"");
}",0.996396136658498
135921,"/** 
 */
private static TLAExpr SubExpr(String sub){
  TLAExpr expr=new TLAExpr();
  if (sub != null) {
    expr.addLine();
    expr.addToken(new TLAToken(""String_Node_Str"",0,TLAToken.BUILTIN));
    expr.addTokenOffset(new TLAToken(sub,0,TLAToken.IDENT),0);
    expr.addTokenOffset(new TLAToken(""String_Node_Str"",0,TLAToken.BUILTIN),0);
    MakeExprPretty(expr);
    expr.normalize();
    return expr;
  }
 else   return null;
}","/** 
 * Given an expression, makes it into a subscript expr.  It is called    only with argument Self(context), which means that it is called       only for a single subscript.                                          * If string is null, then returns null.                                
 */
private static TLAExpr SubExpr(TLAExpr sub){
  if (sub != null) {
    TLAExpr expr=sub.cloneAndNormalize();
    for (int i=0; i < expr.tokens.size(); i++) {
      Vector tokenVec=(Vector)expr.tokens.elementAt(i);
      for (int j=0; j < tokenVec.size(); j++) {
        TLAToken tok=(TLAToken)tokenVec.elementAt(j);
        tok.column=tok.column + 1;
      }
      if (i == 0) {
        tokenVec.insertElementAt(new TLAToken(""String_Node_Str"",0,TLAToken.BUILTIN),0);
      }
    }
    expr.addTokenOffset(new TLAToken(""String_Node_Str"",0,TLAToken.BUILTIN),0);
    return expr;
  }
 else {
    return null;
  }
}",0.3513513513513513
135922,"private void GenProcess(AST.Process ast,String context) throws PcalTLAGenException {
  StringBuffer ns=new StringBuffer();
  Vector nsV=new Vector();
  boolean isSet=true;
  if (ast.isEq) {
    self=""String_Node_Str"";
    Vector sv=ast.id.toStringVector();
    for (int v=0; v < sv.size(); v++)     self=self + ((String)sv.elementAt(v));
    isSet=false;
  }
 else   self=""String_Node_Str"";
  int nsC=ast.name.length() + ((isSet) ? ""String_Node_Str"".length() : 0) + ""String_Node_Str"".length();
  if (isSet) {
    nextStepSelf.addElement(ast.name + ""String_Node_Str"");
  }
 else   nextStep.addElement(ast.name);
  for (int i=0; i < ast.body.size(); i++) {
    AST.LabeledStmt stmt=(AST.LabeledStmt)ast.body.elementAt(i);
    if ((ns.length() + stmt.label.length() + ""String_Node_Str"".length()+ ((isSet) ? ""String_Node_Str"".length() : 0)) > wrapColumn - nsC - ""String_Node_Str"".length()) {
      nsV.addElement(ns.toString());
      ns=new StringBuffer();
    }
    if (ns.length() > 0)     ns.append(""String_Node_Str"");
    ns.append(stmt.label);
    if (isSet)     ns.append(""String_Node_Str"");
    GenLabeledStmt(stmt,""String_Node_Str"");
  }
  nsV.addElement(ns.toString());
  ns=new StringBuffer();
  ns.append(ast.name);
  if (isSet)   ns.append(""String_Node_Str"");
  ns.append(""String_Node_Str"");
  ns.append((String)nsV.elementAt(0));
  tlacode.addElement(ns.toString());
  for (int i=1; i < nsV.size(); i++) {
    ns=new StringBuffer(NSpaces(nsC + 2));
    ns.append(""String_Node_Str"");
    ns.append((String)nsV.elementAt(i));
    tlacode.addElement(ns.toString());
  }
  tlacode.addElement(""String_Node_Str"");
}","private void GenProcess(AST.Process ast,String context) throws PcalTLAGenException {
  StringBuffer ns=new StringBuffer();
  Vector nsV=new Vector();
  boolean isSet=true;
  if (ast.isEq) {
    self=ast.id;
    selfIsSelf=false;
    isSet=false;
  }
 else {
    self=selfAsExpr();
    selfIsSelf=true;
  }
  int nsC=ast.name.length() + ((isSet) ? ""String_Node_Str"".length() : 0) + ""String_Node_Str"".length();
  if (isSet) {
    nextStepSelf.addElement(ast.name + ""String_Node_Str"");
  }
 else   nextStep.addElement(ast.name);
  for (int i=0; i < ast.body.size(); i++) {
    AST.LabeledStmt stmt=(AST.LabeledStmt)ast.body.elementAt(i);
    if ((ns.length() + stmt.label.length() + ""String_Node_Str"".length()+ ((isSet) ? ""String_Node_Str"".length() : 0)) > wrapColumn - nsC - ""String_Node_Str"".length()) {
      nsV.addElement(ns.toString());
      ns=new StringBuffer();
    }
    if (ns.length() > 0)     ns.append(""String_Node_Str"");
    ns.append(stmt.label);
    if (isSet)     ns.append(""String_Node_Str"");
    GenLabeledStmt(stmt,""String_Node_Str"");
  }
  nsV.addElement(ns.toString());
  ns=new StringBuffer();
  ns.append(ast.name);
  if (isSet)   ns.append(""String_Node_Str"");
  ns.append(""String_Node_Str"");
  ns.append((String)nsV.elementAt(0));
  tlacode.addElement(ns.toString());
  for (int i=1; i < nsV.size(); i++) {
    ns=new StringBuffer(NSpaces(nsC + 2));
    ns.append(""String_Node_Str"");
    ns.append((String)nsV.elementAt(i));
    tlacode.addElement(ns.toString());
  }
  tlacode.addElement(""String_Node_Str"");
}",0.2067871868062163
135923,"private void GenProcedure(AST.Procedure ast,String context) throws PcalTLAGenException {
  StringBuffer ns=new StringBuffer();
  Vector nsV=new Vector();
  int nsC=ast.name.length() + ((mp) ? ""String_Node_Str"".length() : 0) + ""String_Node_Str"".length();
  if (mp) {
    self=""String_Node_Str"";
    nextStepSelf.addElement(ast.name + ""String_Node_Str"");
  }
 else {
    nextStep.addElement(ast.name);
  }
  for (int i=0; i < ast.body.size(); i++) {
    AST.LabeledStmt stmt=(AST.LabeledStmt)ast.body.elementAt(i);
    if ((ns.length() + stmt.label.length() + ""String_Node_Str"".length()+ ((mp) ? ""String_Node_Str"".length() : 0)) > wrapColumn - nsC - ""String_Node_Str"".length()) {
      nsV.addElement(ns.toString());
      ns=new StringBuffer();
    }
    if (ns.length() > 0)     ns.append(""String_Node_Str"");
    ns.append(stmt.label);
    if (mp)     ns.append(""String_Node_Str"");
    GenLabeledStmt(stmt,""String_Node_Str"");
  }
  nsV.addElement(ns.toString());
  ns=new StringBuffer();
  ns.append(ast.name);
  if (mp)   ns.append(""String_Node_Str"");
  ns.append(""String_Node_Str"");
  ns.append((String)nsV.elementAt(0));
  tlacode.addElement(ns.toString());
  for (int i=1; i < nsV.size(); i++) {
    ns=new StringBuffer(NSpaces(nsC + 2));
    ns.append(""String_Node_Str"");
    ns.append((String)nsV.elementAt(i));
    tlacode.addElement(ns.toString());
  }
  tlacode.addElement(""String_Node_Str"");
}","private void GenProcedure(AST.Procedure ast,String context) throws PcalTLAGenException {
  StringBuffer ns=new StringBuffer();
  Vector nsV=new Vector();
  int nsC=ast.name.length() + ((mp) ? ""String_Node_Str"".length() : 0) + ""String_Node_Str"".length();
  if (mp) {
    self=selfAsExpr();
    selfIsSelf=true;
    nextStepSelf.addElement(ast.name + ""String_Node_Str"");
  }
 else {
    nextStep.addElement(ast.name);
  }
  for (int i=0; i < ast.body.size(); i++) {
    AST.LabeledStmt stmt=(AST.LabeledStmt)ast.body.elementAt(i);
    if ((ns.length() + stmt.label.length() + ""String_Node_Str"".length()+ ((mp) ? ""String_Node_Str"".length() : 0)) > wrapColumn - nsC - ""String_Node_Str"".length()) {
      nsV.addElement(ns.toString());
      ns=new StringBuffer();
    }
    if (ns.length() > 0)     ns.append(""String_Node_Str"");
    ns.append(stmt.label);
    if (mp)     ns.append(""String_Node_Str"");
    GenLabeledStmt(stmt,""String_Node_Str"");
  }
  nsV.addElement(ns.toString());
  ns=new StringBuffer();
  ns.append(ast.name);
  if (mp)   ns.append(""String_Node_Str"");
  ns.append(""String_Node_Str"");
  ns.append((String)nsV.elementAt(0));
  tlacode.addElement(ns.toString());
  for (int i=1; i < nsV.size(); i++) {
    ns=new StringBuffer(NSpaces(nsC + 2));
    ns.append(""String_Node_Str"");
    ns.append((String)nsV.elementAt(i));
    tlacode.addElement(ns.toString());
  }
  tlacode.addElement(""String_Node_Str"");
}",0.9822820694542878
135924,"/** 
 * The processing method
 */
public void process(){
  ToolIO.cleanToolObjects(TLCGlobals.ToolId);
  try {
    if (fromChkpt != null) {
      UniqueString.internTbl.recover(fromChkpt);
    }
    if (cleanup && fromChkpt == null) {
      FileUtil.deleteDir(TLCGlobals.metaRoot,true);
    }
    FP64.Init(fpIndex);
    if (isSimulate) {
      RandomGenerator rng=new RandomGenerator();
      if (noSeed) {
        seed=rng.nextLong();
        rng.setSeed(seed);
      }
 else {
        rng.setSeed(seed,aril);
      }
      MP.printMessage(EC.TLC_MODE_SIMU,String.valueOf(seed));
      Simulator simulator=new Simulator(mainFile,configFile,null,deadlock,traceDepth,Long.MAX_VALUE,rng,seed,true,resolver,specObj);
      MP.printMessage(EC.TLC_STARTING);
      instance=simulator;
      simulator.simulate();
    }
 else {
      MP.printMessage(EC.TLC_MODE_MC);
      AbstractChecker mc=null;
      if (TLCGlobals.DFIDMax == -1) {
        mc=new ModelChecker(mainFile,configFile,dumpFile,deadlock,fromChkpt,resolver,specObj,fpMemSize);
        TLCGlobals.mainChecker=(ModelChecker)mc;
      }
 else {
        mc=new DFIDModelChecker(mainFile,configFile,dumpFile,deadlock,fromChkpt,true,resolver,specObj);
      }
      MP.printMessage(EC.TLC_STARTING);
      instance=mc;
      mc.modelCheck();
    }
  }
 catch (  Throwable e) {
    if (e instanceof StackOverflowError) {
      System.gc();
      MP.printError(EC.SYSTEM_STACK_OVERFLOW,e);
    }
 else     if (e instanceof OutOfMemoryError) {
      System.gc();
      MP.printError(EC.SYSTEM_OUT_OF_MEMORY,e);
    }
 else     if (e instanceof RuntimeException) {
      MP.printError(EC.GENERAL,e,false);
    }
 else {
      MP.printError(EC.GENERAL,e);
    }
  }
 finally {
    MP.printMessage(EC.TLC_FINISHED);
    MP.flush();
  }
}","/** 
 * The processing method
 */
public void process(){
  ToolIO.cleanToolObjects(TLCGlobals.ToolId);
  try {
    if (fromChkpt != null) {
      UniqueString.internTbl.recover(fromChkpt);
    }
    if (cleanup && fromChkpt == null) {
      FileUtil.deleteDir(TLCGlobals.metaRoot,true);
    }
    FP64.Init(fpIndex);
    if (isSimulate) {
      RandomGenerator rng=new RandomGenerator();
      if (noSeed) {
        seed=rng.nextLong();
        rng.setSeed(seed);
      }
 else {
        rng.setSeed(seed,aril);
      }
      MP.printMessage(EC.TLC_MODE_SIMU,String.valueOf(seed));
      Simulator simulator=new Simulator(mainFile,configFile,null,deadlock,traceDepth,Long.MAX_VALUE,rng,seed,true,resolver,specObj);
      instance=simulator;
      simulator.simulate();
    }
 else {
      MP.printMessage(EC.TLC_MODE_MC);
      AbstractChecker mc=null;
      if (TLCGlobals.DFIDMax == -1) {
        mc=new ModelChecker(mainFile,configFile,dumpFile,deadlock,fromChkpt,resolver,specObj,fpMemSize);
        TLCGlobals.mainChecker=(ModelChecker)mc;
      }
 else {
        mc=new DFIDModelChecker(mainFile,configFile,dumpFile,deadlock,fromChkpt,true,resolver,specObj);
      }
      instance=mc;
      mc.modelCheck();
    }
  }
 catch (  Throwable e) {
    if (e instanceof StackOverflowError) {
      System.gc();
      MP.printError(EC.SYSTEM_STACK_OVERFLOW,e);
    }
 else     if (e instanceof OutOfMemoryError) {
      System.gc();
      MP.printError(EC.SYSTEM_OUT_OF_MEMORY,e);
    }
 else     if (e instanceof RuntimeException) {
      MP.printError(EC.GENERAL,e,false);
    }
 else {
      MP.printError(EC.GENERAL,e);
    }
  }
 finally {
    MP.printMessage(EC.TLC_FINISHED);
    MP.flush();
  }
}",0.9770642201834864
135925,"/** 
 * Processes the specification and collects information to be used by tools. The processing tries to use any customized module (Java class) to override the corresponding TLA+ module.
 */
protected final void processSpec(SpecObj spec){
  if (spec == null) {
    spec=new SpecObj(this.rootFile,resolver);
    if (TLCGlobals.tool) {
      MP.printMessage(EC.TLC_SANY_START);
    }
    try {
      SANY.frontEndMain(spec,this.rootFile,ToolIO.out);
    }
 catch (    FrontEndException e) {
      Assert.fail(EC.TLC_PARSING_FAILED2,e);
    }
    if (TLCGlobals.tool) {
      MP.printMessage(EC.TLC_SANY_END);
    }
  }
  if (!spec.initErrors.isSuccess() || !spec.parseErrors.isSuccess() || !spec.semanticErrors.isSuccess()) {
    Assert.fail(EC.TLC_PARSING_FAILED);
  }
  this.moduleTbl=spec.getExternalModuleTable();
  UniqueString rootName=UniqueString.uniqueStringOf(this.rootFile);
  this.rootModule=this.moduleTbl.getModuleNode(rootName);
  OpDeclNode[] varDecls=this.rootModule.getVariableDecls();
  this.variablesNodes=new OpDeclNode[varDecls.length];
  UniqueString[] varNames=new UniqueString[varDecls.length];
  for (int i=0; i < varDecls.length; i++) {
    this.variablesNodes[i]=varDecls[i];
    varNames[i]=varDecls[i].getName();
    varNames[i].setLoc(i);
  }
  TLCState.setVariables(this.variablesNodes);
  UniqueString.setVariableCount(varDecls.length);
  this.defns.setDefnCount(varDecls.length);
  this.defns.put(""String_Node_Str"",ValTrue);
  this.defns.put(""String_Node_Str"",ValFalse);
  Value[] elems=new Value[2];
  elems[0]=ValFalse;
  elems[1]=ValTrue;
  this.defns.put(""String_Node_Str"",new SetEnumValue(elems,true));
  Class stringModule=this.tlaClass.loadClass(""String_Node_Str"");
  if (stringModule == null) {
    Assert.fail(EC.TLC_STRING_MODULE_NOT_FOUND);
  }
  Method[] ms=stringModule.getDeclaredMethods();
  for (int i=0; i < ms.length; i++) {
    int mod=ms[i].getModifiers();
    if (Modifier.isStatic(mod)) {
      String name=TLARegistry.mapName(ms[i].getName());
      int acnt=ms[i].getParameterTypes().length;
      MethodValue mv=new MethodValue(ms[i]);
      Value val=(acnt == 0) ? mv.apply(EmptyArgs,EvalControl.Clear) : mv;
      this.defns.put(name,val);
    }
  }
  ModuleNode[] mods=this.moduleTbl.getModuleNodes();
  HashSet modSet=new HashSet();
  for (int i=0; i < mods.length; i++) {
    this.processConstants(mods[i]);
    modSet.add(mods[i].getName().toString());
  }
  AssumeNode[] assumes=this.rootModule.getAssumptions();
  this.assumptions=new ExprNode[assumes.length];
  this.assumptionIsAxiom=new boolean[assumes.length];
  for (int i=0; i < assumes.length; i++) {
    this.assumptions[i]=assumes[i].getAssume();
    this.assumptionIsAxiom[i]=assumes[i].getIsAxiom();
  }
  Hashtable constants=this.initializeConstants();
  Hashtable overrides=this.config.getOverrides();
  OpDeclNode[] rootConsts=this.rootModule.getConstantDecls();
  for (int i=0; i < rootConsts.length; i++) {
    UniqueString name=rootConsts[i].getName();
    Object val=constants.get(name.toString());
    if (val == null && !overrides.containsKey(name.toString())) {
      Assert.fail(EC.TLC_CONFIG_VALUE_NOT_ASSIGNED_TO_CONSTANT_PARAM,name.toString());
    }
    rootConsts[i].setToolObject(TLCGlobals.ToolId,val);
    this.defns.put(name,val);
  }
  OpDefNode[] rootOpDefs=this.rootModule.getOpDefs();
  for (int i=0; i < rootOpDefs.length; i++) {
    UniqueString name=rootOpDefs[i].getName();
    Object val=constants.get(name.toString());
    if (val == null) {
      this.defns.put(name,rootOpDefs[i]);
    }
 else {
      rootOpDefs[i].setToolObject(TLCGlobals.ToolId,val);
      this.defns.put(name,val);
    }
  }
  Hashtable modConstants=this.initializeModConstants();
  for (int i=0; i < mods.length; i++) {
    UniqueString modName=mods[i].getName();
    Hashtable mConsts=(Hashtable)modConstants.get(modName.toString());
    if (mConsts != null) {
      OpDefNode[] opDefs=mods[i].getOpDefs();
      for (int j=0; j < opDefs.length; j++) {
        UniqueString name=opDefs[j].getName();
        Object val=mConsts.get(name.toString());
        if (val != null) {
          opDefs[j].getBody().setToolObject(TLCGlobals.ToolId,val);
        }
      }
    }
  }
  for (int i=0; i < mods.length; i++) {
    UniqueString modName=mods[i].getName();
    Class userModule=this.tlaClass.loadClass(modName.toString());
    if (userModule != null) {
      Hashtable javaDefs=new Hashtable();
      Method[] mds=userModule.getDeclaredMethods();
      for (int j=0; j < mds.length; j++) {
        int mdf=mds[j].getModifiers();
        if (Modifier.isPublic(mdf) && Modifier.isStatic(mdf)) {
          String name=TLARegistry.mapName(mds[j].getName());
          UniqueString uname=UniqueString.uniqueStringOf(name);
          int acnt=mds[j].getParameterTypes().length;
          MethodValue mv=new MethodValue(mds[j]);
          boolean isConstant=(acnt == 0) && Modifier.isFinal(mdf);
          Value val=isConstant ? mv.apply(EmptyArgs,EvalControl.Clear) : mv;
          javaDefs.put(uname,val);
        }
      }
      OpDefNode[] opDefs=mods[i].getOpDefs();
      for (int j=0; j < opDefs.length; j++) {
        UniqueString uname=opDefs[j].getName();
        Object val=javaDefs.get(uname);
        if (val != null) {
          opDefs[j].getBody().setToolObject(TLCGlobals.ToolId,val);
          this.defns.put(uname,val);
        }
      }
    }
  }
  HashSet overriden=new HashSet();
  for (int i=0; i < rootConsts.length; i++) {
    UniqueString lhs=rootConsts[i].getName();
    String rhs=(String)overrides.get(lhs.toString());
    if (rhs != null) {
      if (overrides.containsKey(rhs)) {
        Assert.fail(EC.TLC_CONFIG_RHS_ID_APPEARED_AFTER_LHS_ID,rhs);
      }
      Object myVal=this.defns.get(rhs);
      if (myVal == null) {
        Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION,new String[]{lhs.toString(),rhs});
      }
      rootConsts[i].setToolObject(TLCGlobals.ToolId,myVal);
      this.defns.put(lhs,myVal);
      overriden.add(lhs.toString());
    }
  }
  for (int i=0; i < rootOpDefs.length; i++) {
    UniqueString lhs=rootOpDefs[i].getName();
    String rhs=(String)overrides.get(lhs.toString());
    if (rhs != null) {
      if (overrides.containsKey(rhs)) {
        Assert.fail(EC.TLC_CONFIG_RHS_ID_APPEARED_AFTER_LHS_ID,rhs);
      }
      Object myVal=this.defns.get(rhs);
      if (myVal == null) {
        Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION,new String[]{lhs.toString(),rhs});
      }
      if ((myVal instanceof OpDefNode) && rootOpDefs[i].getNumberOfArgs() != ((OpDefNode)myVal).getNumberOfArgs()) {
        Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION_NUMBER_OF_ARGS,new String[]{lhs.toString(),rhs});
      }
      rootOpDefs[i].setToolObject(TLCGlobals.ToolId,myVal);
      this.defns.put(lhs,myVal);
      overriden.add(lhs.toString());
    }
  }
  Enumeration keys=overrides.keys();
  while (keys.hasMoreElements()) {
    Object key=keys.nextElement();
    if (!overriden.contains(key)) {
      Assert.fail(EC.TLC_CONFIG_ID_DOES_NOT_APPEAR_IN_SPEC,key.toString());
    }
  }
  Hashtable modOverrides=this.config.getModOverrides();
  for (int i=0; i < mods.length; i++) {
    UniqueString modName=mods[i].getName();
    Hashtable mDefs=(Hashtable)modOverrides.get(modName.toString());
    HashSet modOverriden=new HashSet();
    if (mDefs != null) {
      OpDefNode[] opDefs=mods[i].getOpDefs();
      for (int j=0; j < opDefs.length; j++) {
        UniqueString lhs=opDefs[j].getName();
        String rhs=(String)mDefs.get(lhs.toString());
        if (rhs != null) {
          if (mDefs.containsKey(rhs)) {
            Assert.fail(EC.TLC_CONFIG_RHS_ID_APPEARED_AFTER_LHS_ID,rhs);
          }
          Object myVal=this.defns.get(rhs);
          if (myVal == null) {
            Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION,new String[]{lhs.toString(),rhs});
          }
          if ((myVal instanceof OpDefNode) && opDefs[j].getNumberOfArgs() != ((OpDefNode)myVal).getNumberOfArgs()) {
            Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION_NUMBER_OF_ARGS,new String[]{lhs.toString(),rhs});
          }
          opDefs[j].getBody().setToolObject(TLCGlobals.ToolId,myVal);
          modOverriden.add(lhs.toString());
        }
      }
      Enumeration mkeys=mDefs.keys();
      while (mkeys.hasMoreElements()) {
        Object mkey=mkeys.nextElement();
        if (!modOverriden.contains(mkey)) {
          Assert.fail(EC.TLC_CONFIG_ID_DOES_NOT_APPEAR_IN_SPEC,mkey.toString());
        }
      }
    }
  }
  Enumeration modKeys=modOverrides.keys();
  while (modKeys.hasMoreElements()) {
    Object modName=modKeys.nextElement();
    if (!modSet.contains(modName)) {
      Assert.fail(EC.TLC_NO_MODULES,modName.toString());
    }
  }
}","/** 
 * Processes the specification and collects information to be used by tools. The processing tries to use any customized module (Java class) to override the corresponding TLA+ module.
 */
protected final void processSpec(SpecObj spec){
  if (spec == null) {
    spec=new SpecObj(this.rootFile,resolver);
    if (TLCGlobals.tool) {
      MP.printMessage(EC.TLC_SANY_START);
    }
    try {
      SANY.frontEndMain(spec,this.rootFile,ToolIO.out);
    }
 catch (    FrontEndException e) {
      Assert.fail(EC.TLC_PARSING_FAILED2,e);
    }
    if (TLCGlobals.tool) {
      MP.printMessage(EC.TLC_SANY_END);
    }
    MP.printMessage(EC.TLC_STARTING);
  }
  if (!spec.initErrors.isSuccess() || !spec.parseErrors.isSuccess() || !spec.semanticErrors.isSuccess()) {
    Assert.fail(EC.TLC_PARSING_FAILED);
  }
  this.moduleTbl=spec.getExternalModuleTable();
  UniqueString rootName=UniqueString.uniqueStringOf(this.rootFile);
  this.rootModule=this.moduleTbl.getModuleNode(rootName);
  OpDeclNode[] varDecls=this.rootModule.getVariableDecls();
  this.variablesNodes=new OpDeclNode[varDecls.length];
  UniqueString[] varNames=new UniqueString[varDecls.length];
  for (int i=0; i < varDecls.length; i++) {
    this.variablesNodes[i]=varDecls[i];
    varNames[i]=varDecls[i].getName();
    varNames[i].setLoc(i);
  }
  TLCState.setVariables(this.variablesNodes);
  UniqueString.setVariableCount(varDecls.length);
  this.defns.setDefnCount(varDecls.length);
  this.defns.put(""String_Node_Str"",ValTrue);
  this.defns.put(""String_Node_Str"",ValFalse);
  Value[] elems=new Value[2];
  elems[0]=ValFalse;
  elems[1]=ValTrue;
  this.defns.put(""String_Node_Str"",new SetEnumValue(elems,true));
  Class stringModule=this.tlaClass.loadClass(""String_Node_Str"");
  if (stringModule == null) {
    Assert.fail(EC.TLC_STRING_MODULE_NOT_FOUND);
  }
  Method[] ms=stringModule.getDeclaredMethods();
  for (int i=0; i < ms.length; i++) {
    int mod=ms[i].getModifiers();
    if (Modifier.isStatic(mod)) {
      String name=TLARegistry.mapName(ms[i].getName());
      int acnt=ms[i].getParameterTypes().length;
      MethodValue mv=new MethodValue(ms[i]);
      Value val=(acnt == 0) ? mv.apply(EmptyArgs,EvalControl.Clear) : mv;
      this.defns.put(name,val);
    }
  }
  ModuleNode[] mods=this.moduleTbl.getModuleNodes();
  HashSet modSet=new HashSet();
  for (int i=0; i < mods.length; i++) {
    this.processConstants(mods[i]);
    modSet.add(mods[i].getName().toString());
  }
  AssumeNode[] assumes=this.rootModule.getAssumptions();
  this.assumptions=new ExprNode[assumes.length];
  this.assumptionIsAxiom=new boolean[assumes.length];
  for (int i=0; i < assumes.length; i++) {
    this.assumptions[i]=assumes[i].getAssume();
    this.assumptionIsAxiom[i]=assumes[i].getIsAxiom();
  }
  Hashtable constants=this.initializeConstants();
  Hashtable overrides=this.config.getOverrides();
  OpDeclNode[] rootConsts=this.rootModule.getConstantDecls();
  for (int i=0; i < rootConsts.length; i++) {
    UniqueString name=rootConsts[i].getName();
    Object val=constants.get(name.toString());
    if (val == null && !overrides.containsKey(name.toString())) {
      Assert.fail(EC.TLC_CONFIG_VALUE_NOT_ASSIGNED_TO_CONSTANT_PARAM,name.toString());
    }
    rootConsts[i].setToolObject(TLCGlobals.ToolId,val);
    this.defns.put(name,val);
  }
  OpDefNode[] rootOpDefs=this.rootModule.getOpDefs();
  for (int i=0; i < rootOpDefs.length; i++) {
    UniqueString name=rootOpDefs[i].getName();
    Object val=constants.get(name.toString());
    if (val == null) {
      this.defns.put(name,rootOpDefs[i]);
    }
 else {
      rootOpDefs[i].setToolObject(TLCGlobals.ToolId,val);
      this.defns.put(name,val);
    }
  }
  Hashtable modConstants=this.initializeModConstants();
  for (int i=0; i < mods.length; i++) {
    UniqueString modName=mods[i].getName();
    Hashtable mConsts=(Hashtable)modConstants.get(modName.toString());
    if (mConsts != null) {
      OpDefNode[] opDefs=mods[i].getOpDefs();
      for (int j=0; j < opDefs.length; j++) {
        UniqueString name=opDefs[j].getName();
        Object val=mConsts.get(name.toString());
        if (val != null) {
          opDefs[j].getBody().setToolObject(TLCGlobals.ToolId,val);
        }
      }
    }
  }
  for (int i=0; i < mods.length; i++) {
    UniqueString modName=mods[i].getName();
    Class userModule=this.tlaClass.loadClass(modName.toString());
    if (userModule != null) {
      Hashtable javaDefs=new Hashtable();
      Method[] mds=userModule.getDeclaredMethods();
      for (int j=0; j < mds.length; j++) {
        int mdf=mds[j].getModifiers();
        if (Modifier.isPublic(mdf) && Modifier.isStatic(mdf)) {
          String name=TLARegistry.mapName(mds[j].getName());
          UniqueString uname=UniqueString.uniqueStringOf(name);
          int acnt=mds[j].getParameterTypes().length;
          MethodValue mv=new MethodValue(mds[j]);
          boolean isConstant=(acnt == 0) && Modifier.isFinal(mdf);
          Value val=isConstant ? mv.apply(EmptyArgs,EvalControl.Clear) : mv;
          javaDefs.put(uname,val);
        }
      }
      OpDefNode[] opDefs=mods[i].getOpDefs();
      for (int j=0; j < opDefs.length; j++) {
        UniqueString uname=opDefs[j].getName();
        Object val=javaDefs.get(uname);
        if (val != null) {
          opDefs[j].getBody().setToolObject(TLCGlobals.ToolId,val);
          this.defns.put(uname,val);
        }
      }
    }
  }
  HashSet overriden=new HashSet();
  for (int i=0; i < rootConsts.length; i++) {
    UniqueString lhs=rootConsts[i].getName();
    String rhs=(String)overrides.get(lhs.toString());
    if (rhs != null) {
      if (overrides.containsKey(rhs)) {
        Assert.fail(EC.TLC_CONFIG_RHS_ID_APPEARED_AFTER_LHS_ID,rhs);
      }
      Object myVal=this.defns.get(rhs);
      if (myVal == null) {
        Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION,new String[]{lhs.toString(),rhs});
      }
      rootConsts[i].setToolObject(TLCGlobals.ToolId,myVal);
      this.defns.put(lhs,myVal);
      overriden.add(lhs.toString());
    }
  }
  for (int i=0; i < rootOpDefs.length; i++) {
    UniqueString lhs=rootOpDefs[i].getName();
    String rhs=(String)overrides.get(lhs.toString());
    if (rhs != null) {
      if (overrides.containsKey(rhs)) {
        Assert.fail(EC.TLC_CONFIG_RHS_ID_APPEARED_AFTER_LHS_ID,rhs);
      }
      Object myVal=this.defns.get(rhs);
      if (myVal == null) {
        Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION,new String[]{lhs.toString(),rhs});
      }
      if ((myVal instanceof OpDefNode) && rootOpDefs[i].getNumberOfArgs() != ((OpDefNode)myVal).getNumberOfArgs()) {
        Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION_NUMBER_OF_ARGS,new String[]{lhs.toString(),rhs});
      }
      rootOpDefs[i].setToolObject(TLCGlobals.ToolId,myVal);
      this.defns.put(lhs,myVal);
      overriden.add(lhs.toString());
    }
  }
  Enumeration keys=overrides.keys();
  while (keys.hasMoreElements()) {
    Object key=keys.nextElement();
    if (!overriden.contains(key)) {
      Assert.fail(EC.TLC_CONFIG_ID_DOES_NOT_APPEAR_IN_SPEC,key.toString());
    }
  }
  Hashtable modOverrides=this.config.getModOverrides();
  for (int i=0; i < mods.length; i++) {
    UniqueString modName=mods[i].getName();
    Hashtable mDefs=(Hashtable)modOverrides.get(modName.toString());
    HashSet modOverriden=new HashSet();
    if (mDefs != null) {
      OpDefNode[] opDefs=mods[i].getOpDefs();
      for (int j=0; j < opDefs.length; j++) {
        UniqueString lhs=opDefs[j].getName();
        String rhs=(String)mDefs.get(lhs.toString());
        if (rhs != null) {
          if (mDefs.containsKey(rhs)) {
            Assert.fail(EC.TLC_CONFIG_RHS_ID_APPEARED_AFTER_LHS_ID,rhs);
          }
          Object myVal=this.defns.get(rhs);
          if (myVal == null) {
            Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION,new String[]{lhs.toString(),rhs});
          }
          if ((myVal instanceof OpDefNode) && opDefs[j].getNumberOfArgs() != ((OpDefNode)myVal).getNumberOfArgs()) {
            Assert.fail(EC.TLC_CONFIG_WRONG_SUBSTITUTION_NUMBER_OF_ARGS,new String[]{lhs.toString(),rhs});
          }
          opDefs[j].getBody().setToolObject(TLCGlobals.ToolId,myVal);
          modOverriden.add(lhs.toString());
        }
      }
      Enumeration mkeys=mDefs.keys();
      while (mkeys.hasMoreElements()) {
        Object mkey=mkeys.nextElement();
        if (!modOverriden.contains(mkey)) {
          Assert.fail(EC.TLC_CONFIG_ID_DOES_NOT_APPEAR_IN_SPEC,mkey.toString());
        }
      }
    }
  }
  Enumeration modKeys=modOverrides.keys();
  while (modKeys.hasMoreElements()) {
    Object modName=modKeys.nextElement();
    if (!modSet.contains(modName)) {
      Assert.fail(EC.TLC_NO_MODULES,modName.toString());
    }
  }
}",0.9978270814272644
135926,"/** 
 */
private void GenAssign(AST.Assign ast,Changed c,String context,String prefix,int col) throws PcalTLAGenException {
  Changed cThis=new Changed(c);
  StringBuffer sb=new StringBuffer();
  Vector vlines=new Vector();
  ast.ass=SortSass(ast.ass);
  int i=0;
  int numAssigns=0;
  while (i < ast.ass.size()) {
    int iFirst=i;
    AST.SingleAssign sF=(AST.SingleAssign)ast.ass.elementAt(i);
    int iLast=i;
    AST.SingleAssign sL=(AST.SingleAssign)ast.ass.elementAt(i);
    while (iLast < ast.ass.size() && sF.lhs.var.equals(sL.lhs.var)) {
      iLast=iLast + 1;
      if (iLast < ast.ass.size())       sL=(AST.SingleAssign)ast.ass.elementAt(iLast);
    }
    iLast=iLast - 1;
    if (cThis.Set(sF.lhs.var) > 1 || (iLast - iFirst > 0 && EmptyExpr(sF.lhs.sub)))     throw new PcalTLAGenException(""String_Node_Str"" + sF.lhs.var,ast);
    numAssigns=numAssigns + 1;
    Vector lines=new Vector();
    if (iFirst == iLast) {
      AST.SingleAssign sass=sF;
      TLAExpr sub=AddSubscriptsToExpr(sass.lhs.sub,SubExpr(Self(context)),c);
      TLAExpr rhs=AddSubscriptsToExpr(sass.rhs,SubExpr(Self(context)),c);
      if (mp && (sass.lhs.var.equals(""String_Node_Str"") || IsProcedureVar(sass.lhs.var) || IsProcessSetVar(sass.lhs.var)|| sass.lhs.var.equals(""String_Node_Str""))) {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int wrapCol=sb.length() + 2;
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        if (sb.length() + prefix.length() > ssWrapColumn) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(wrapCol));
        }
        sb.append(""String_Node_Str"");
        sb.append(self);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=sub.toStringVector();
        if (sv.size() > 0) {
          sb.append((String)sv.elementAt(0));
          for (int v=1; v < sv.size(); v++) {
            lines.addElement(sb.toString());
            sb=new StringBuffer(NSpaces(here));
            sb.append((String)sv.elementAt(v));
          }
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        lines.addElement(sb.toString());
        sb=new StringBuffer();
      }
 else       if (!EmptyExpr(sass.lhs.sub)) {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=sub.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        lines.addElement(sb.toString());
        sb=new StringBuffer();
      }
 else {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=Parenthesize(rhs.toStringVector());
        for (int v=0; v < sv.size(); v++) {
          sb.append((String)sv.elementAt(v));
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
        }
        sb=new StringBuffer();
      }
    }
 else {
      AST.SingleAssign sass=sF;
      sb.append(sass.lhs.var);
      sb.append(""String_Node_Str"");
      sb.append(sass.lhs.var);
      sb.append(""String_Node_Str"");
      int cc=sb.length();
      boolean subscript=(mp && (IsProcedureVar(sass.lhs.var) || IsProcessSetVar(sass.lhs.var)));
      while (iFirst <= iLast) {
        sass=(AST.SingleAssign)ast.ass.elementAt(iFirst);
        TLAExpr sub=AddSubscriptsToExpr(sass.lhs.sub,SubExpr(Self(context)),c);
        TLAExpr rhs=AddSubscriptsToExpr(sass.rhs,SubExpr(Self(context)),c);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        if (subscript)         sb.append(""String_Node_Str"" + Self(context) + ""String_Node_Str"");
        Vector sv=sub.toStringVector();
        if (sv.size() > 0) {
          sb.append((String)sv.elementAt(0));
          for (int v=1; v < sv.size(); v++) {
            lines.addElement(sb.toString());
            sb=new StringBuffer(NSpaces(here));
            sb.append((String)sv.elementAt(v));
          }
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(((iFirst == iLast) ? ""String_Node_Str"" : ""String_Node_Str""));
        lines.addElement(sb.toString());
        sb=new StringBuffer();
        if (iFirst < iLast)         AddSpaces(sb,cc);
        iFirst=iFirst + 1;
      }
    }
    vlines.addElement(lines);
    i=iLast + 1;
  }
  c.Merge(cThis);
  sb=new StringBuffer(prefix);
  col=sb.length();
  if (numAssigns > 1)   sb.append(""String_Node_Str"");
  if (vlines.size() > 0) {
    for (int v1=0; v1 < vlines.size(); v1++) {
      Vector vl=(Vector)vlines.elementAt(v1);
      for (int v2=0; v2 < vl.size(); v2++) {
        sb.append((String)vl.elementAt(v2));
        tlacode.addElement(sb.toString());
        sb=new StringBuffer(NSpaces(col));
        if ((v1 > 0 || numAssigns > 1) && (v2 != vl.size() - 1))         sb.append(""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
    }
  }
}","/** 
 * @param ast
 * @param c
 * @param context
 * @param prefix
 * @param col
 * @throws PcalTLAGenException
 */
private void GenAssign(AST.Assign ast,Changed c,String context,String prefix,int col) throws PcalTLAGenException {
  Changed cThis=new Changed(c);
  StringBuffer sb=new StringBuffer();
  Vector vlines=new Vector();
  ast.ass=SortSass(ast.ass);
  int i=0;
  int numAssigns=0;
  while (i < ast.ass.size()) {
    int iFirst=i;
    AST.SingleAssign sF=(AST.SingleAssign)ast.ass.elementAt(i);
    int iLast=i;
    AST.SingleAssign sL=(AST.SingleAssign)ast.ass.elementAt(i);
    while (iLast < ast.ass.size() && sF.lhs.var.equals(sL.lhs.var)) {
      iLast=iLast + 1;
      if (iLast < ast.ass.size())       sL=(AST.SingleAssign)ast.ass.elementAt(iLast);
    }
    iLast=iLast - 1;
    if (cThis.Set(sF.lhs.var) > 1 || (iLast - iFirst > 0 && EmptyExpr(sF.lhs.sub)))     throw new PcalTLAGenException(""String_Node_Str"" + sF.lhs.var,ast);
    numAssigns=numAssigns + 1;
    Vector lines=new Vector();
    if (iFirst == iLast) {
      AST.SingleAssign sass=sF;
      TLAExpr sub=AddSubscriptsToExpr(sass.lhs.sub,SubExpr(Self(context)),c);
      TLAExpr rhs=AddSubscriptsToExpr(sass.rhs,SubExpr(Self(context)),c);
      if (mp && (sass.lhs.var.equals(""String_Node_Str"") || IsProcedureVar(sass.lhs.var) || IsProcessSetVar(sass.lhs.var)|| sass.lhs.var.equals(""String_Node_Str""))) {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int wrapCol=sb.length() + 2;
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        if (sb.length() + prefix.length() > ssWrapColumn) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(wrapCol));
        }
        sb.append(""String_Node_Str"");
        sb.append(self);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=sub.toStringVector();
        if (sv.size() > 0) {
          sb.append((String)sv.elementAt(0));
          for (int v=1; v < sv.size(); v++) {
            lines.addElement(sb.toString());
            sb=new StringBuffer(NSpaces(here));
            sb.append((String)sv.elementAt(v));
          }
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        lines.addElement(sb.toString());
        sb=new StringBuffer();
      }
 else       if (!EmptyExpr(sass.lhs.sub)) {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=sub.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(""String_Node_Str"");
        lines.addElement(sb.toString());
        sb=new StringBuffer();
      }
 else {
        sb.append(sass.lhs.var);
        sb.append(""String_Node_Str"");
        int here=sb.length();
        Vector sv=Parenthesize(rhs.toStringVector());
        for (int v=0; v < sv.size(); v++) {
          sb.append((String)sv.elementAt(v));
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
        }
        sb=new StringBuffer();
      }
    }
 else {
      AST.SingleAssign sass=sF;
      sb.append(sass.lhs.var);
      sb.append(""String_Node_Str"");
      sb.append(sass.lhs.var);
      sb.append(""String_Node_Str"");
      int cc=sb.length();
      boolean subscript=(mp && (IsProcedureVar(sass.lhs.var) || IsProcessSetVar(sass.lhs.var)));
      while (iFirst <= iLast) {
        sass=(AST.SingleAssign)ast.ass.elementAt(iFirst);
        TLAExpr sub=AddSubscriptsToExpr(sass.lhs.sub,SubExpr(Self(context)),c);
        TLAExpr rhs=AddSubscriptsToExpr(sass.rhs,SubExpr(Self(context)),c);
        sb.append(""String_Node_Str"");
        if (subscript) {
          sb.append(""String_Node_Str"" + Self(context) + ""String_Node_Str"");
        }
        int here=sb.length();
        Vector sv=sub.toStringVector();
        if (sv.size() > 0) {
          sb.append((String)sv.elementAt(0));
          for (int v=1; v < sv.size(); v++) {
            lines.addElement(sb.toString());
            sb=new StringBuffer(NSpaces(here));
            sb.append((String)sv.elementAt(v));
          }
        }
        sb.append(""String_Node_Str"");
        here=sb.length();
        sv=rhs.toStringVector();
        sb.append((String)sv.elementAt(0));
        for (int v=1; v < sv.size(); v++) {
          lines.addElement(sb.toString());
          sb=new StringBuffer(NSpaces(here));
          sb.append((String)sv.elementAt(v));
        }
        sb.append(((iFirst == iLast) ? ""String_Node_Str"" : ""String_Node_Str""));
        lines.addElement(sb.toString());
        sb=new StringBuffer();
        if (iFirst < iLast)         AddSpaces(sb,cc);
        iFirst=iFirst + 1;
      }
    }
    vlines.addElement(lines);
    i=iLast + 1;
  }
  c.Merge(cThis);
  sb=new StringBuffer(prefix);
  col=sb.length();
  if (numAssigns > 1)   sb.append(""String_Node_Str"");
  if (vlines.size() > 0) {
    for (int v1=0; v1 < vlines.size(); v1++) {
      Vector vl=(Vector)vlines.elementAt(v1);
      for (int v2=0; v2 < vl.size(); v2++) {
        sb.append((String)vl.elementAt(v2));
        tlacode.addElement(sb.toString());
        sb=new StringBuffer(NSpaces(col));
        if ((v1 > 0 || numAssigns > 1) && (v2 != vl.size() - 1))         sb.append(""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
    }
  }
}",0.985372988785958
135927,"/** 
 */
private void GenNext(){
  Vector nextS=new Vector();
  StringBuffer sb=new StringBuffer();
  int max, col;
  max=wrapColumn - (""String_Node_Str"".length());
  for (int i=0; i < nextStep.size(); i++) {
    String a=(String)nextStep.elementAt(i);
    if (a.length() + ""String_Node_Str"".length() + sb.length() > max) {
      nextS.addElement(sb.toString());
      sb=new StringBuffer();
    }
    if (sb.length() > 0)     sb.append(""String_Node_Str"");
    sb.append(a);
  }
  if (sb.length() > 0)   nextS.addElement(sb.toString());
  Vector nextSS=new Vector();
  String nextSSstart=""String_Node_Str"";
  sb=new StringBuffer();
  max=wrapColumn - (""String_Node_Str"".length());
  if (mp && st.procs.size() > 0) {
    for (int i=0; i < st.procs.size(); i++) {
      PcalSymTab.ProcedureEntry p=(PcalSymTab.ProcedureEntry)st.procs.elementAt(i);
      if ((p.name.length() + ""String_Node_Str"".length() + sb.length()) > max) {
        nextSS.addElement(sb.toString());
        sb=new StringBuffer();
      }
      if (sb.length() > 0)       sb.append(""String_Node_Str"");
      sb.append(p.name);
      sb.append(""String_Node_Str"");
    }
    if (sb.length() > 0)     nextSS.addElement(sb.toString() + ""String_Node_Str"");
  }
  Vector nextSSP=new Vector();
  if (mp && st.processes.size() > 0)   for (int i=0; i < st.processes.size(); i++) {
    PcalSymTab.ProcessEntry p=(PcalSymTab.ProcessEntry)st.processes.elementAt(i);
    if (p.isEq)     continue;
    Vector vec=new Vector();
    sb=new StringBuffer();
    sb.append(""String_Node_Str"");
    Vector sv=p.id.toStringVector();
    col=sb.length();
    sb.append((String)sv.elementAt(0));
    for (int j=1; j < sv.size(); j++) {
      vec.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(col));
      sb.append((String)sv.elementAt(j));
    }
    sb.append(""String_Node_Str"");
    sb.append(p.name);
    sb.append(""String_Node_Str"");
    vec.addElement(sb.toString());
    nextSSP.addElement(vec);
  }
  sb=new StringBuffer(""String_Node_Str"");
  col=sb.length() + 2;
  for (int i=0; i < nextS.size(); i++) {
    sb.append((String)nextS.elementAt(i));
    tlacode.addElement(sb.toString());
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (nextSS.size() > 0) {
    sb.append(nextSSstart);
    int col2=sb.length();
    if (nextSS.size() > 1)     sb.append(""String_Node_Str"");
    for (int i=0; i < nextSS.size(); i++) {
      sb.append((String)nextSS.elementAt(i));
      tlacode.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(col2) + ""String_Node_Str"");
    }
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (nextSSP.size() > 0)   for (int i=0; i < nextSSP.size(); i++) {
    Vector v=(Vector)nextSSP.elementAt(i);
    for (int j=0; j < v.size(); j++) {
      String line=(String)v.elementAt(j);
      sb.append(line);
      tlacode.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(col + 4));
    }
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (!PcalParams.NoDoneDisjunct) {
    sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
    sb=new StringBuffer(NSpaces(col + 4));
    if (mp)     sb.append(""String_Node_Str"" + ""String_Node_Str"");
 else     sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
  }
  ;
  tlacode.addElement(""String_Node_Str"");
}","/** 
 */
private void GenNext(){
  Vector nextS=new Vector();
  StringBuffer sb=new StringBuffer();
  int max, col;
  max=wrapColumn - (""String_Node_Str"".length());
  for (int i=0; i < nextStep.size(); i++) {
    String a=(String)nextStep.elementAt(i);
    if (a.length() + ""String_Node_Str"".length() + sb.length() > max) {
      nextS.addElement(sb.toString());
      sb=new StringBuffer();
    }
    if (sb.length() > 0)     sb.append(""String_Node_Str"");
    sb.append(a);
  }
  if (sb.length() > 0)   nextS.addElement(sb.toString());
  Vector nextSS=new Vector();
  String nextSSstart=""String_Node_Str"";
  sb=new StringBuffer();
  max=wrapColumn - (""String_Node_Str"".length());
  if (mp && st.procs.size() > 0) {
    for (int i=0; i < st.procs.size(); i++) {
      PcalSymTab.ProcedureEntry p=(PcalSymTab.ProcedureEntry)st.procs.elementAt(i);
      if ((p.name.length() + ""String_Node_Str"".length() + sb.length()) > max) {
        nextSS.addElement(sb.toString());
        sb=new StringBuffer();
      }
      if (sb.length() > 0)       sb.append(""String_Node_Str"");
      sb.append(p.name);
      sb.append(""String_Node_Str"");
    }
    if (sb.length() > 0)     nextSS.addElement(sb.toString() + ""String_Node_Str"");
  }
  Vector nextSSP=new Vector();
  if (mp && st.processes.size() > 0)   for (int i=0; i < st.processes.size(); i++) {
    PcalSymTab.ProcessEntry p=(PcalSymTab.ProcessEntry)st.processes.elementAt(i);
    if (p.isEq)     continue;
    Vector vec=new Vector();
    sb=new StringBuffer();
    sb.append(""String_Node_Str"");
    Vector sv=p.id.toStringVector();
    col=sb.length();
    sb.append((String)sv.elementAt(0));
    for (int j=1; j < sv.size(); j++) {
      vec.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(col));
      sb.append((String)sv.elementAt(j));
    }
    sb.append(""String_Node_Str"");
    sb.append(p.name);
    sb.append(""String_Node_Str"");
    vec.addElement(sb.toString());
    nextSSP.addElement(vec);
  }
  sb=new StringBuffer(""String_Node_Str"");
  col=sb.length() + 2;
  for (int i=0; i < nextS.size(); i++) {
    sb.append((String)nextS.elementAt(i));
    tlacode.addElement(sb.toString());
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (nextSS.size() > 0) {
    sb.append(nextSSstart);
    int col2=sb.length();
    if (nextSS.size() > 1)     sb.append(""String_Node_Str"");
    for (int i=0; i < nextSS.size(); i++) {
      sb.append((String)nextSS.elementAt(i));
      tlacode.addElement(sb.toString());
      sb=new StringBuffer(NSpaces(col2) + ""String_Node_Str"");
    }
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (nextSSP.size() > 0)   for (int i=0; i < nextSSP.size(); i++) {
    Vector v=(Vector)nextSSP.elementAt(i);
    for (int j=0; j < v.size(); j++) {
      String line=(String)v.elementAt(j);
      sb.append(line);
      tlacode.addElement(sb.toString());
      if ((nextSS.size() == 0) && (i == 0)) {
        sb=new StringBuffer(NSpaces(col - 2));
      }
 else {
        sb=new StringBuffer(NSpaces(col + 4));
      }
    }
    sb=new StringBuffer(NSpaces(col) + ""String_Node_Str"");
  }
  if (!PcalParams.NoDoneDisjunct) {
    sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
    sb=new StringBuffer(NSpaces(col + 4));
    if (mp)     sb.append(""String_Node_Str"" + ""String_Node_Str"");
 else     sb.append(""String_Node_Str"");
    tlacode.addElement(sb.toString());
  }
  ;
  tlacode.addElement(""String_Node_Str"");
}",0.9804267844002944
135928,"/** 
 * Looks for line and column number in str starting at idx, and returns a 3-element array val with val[0] = the line number and val[1] = the column number, and val[2] the index at the end of the column number. It returns -1 for a number it doesn't find, and may leave val[3] off the end of the array. It works (but of course finds nothing if idx >= str.length(). This is a kludge that assumes that the line number is preceded either by "" line "" or by ""line "" that begins the error message, and that the column number is preceded by either "" column "" or "" col "".
 */
private static final int[] findLineAndColumn(final int idx,final String message){
  int[] val={-1,-1,message.length()};
  int beginIndex=message.indexOf(""String_Node_Str"",idx);
  int offset=5;
  if (beginIndex != idx) {
    beginIndex=-1;
  }
  if (beginIndex == -1) {
    beginIndex=message.indexOf(""String_Node_Str"",idx);
    offset=6;
  }
  if (beginIndex != -1) {
    beginIndex=beginIndex + offset;
    while ((beginIndex < message.length()) && !Character.isDigit(message.charAt(beginIndex))) {
      beginIndex++;
    }
    int endIndex=beginIndex + 1;
    while ((endIndex < message.length()) && Character.isDigit(message.charAt(endIndex))) {
      endIndex++;
    }
    if (beginIndex < message.length()) {
      val[0]=Integer.parseInt(message.substring(beginIndex,endIndex));
      beginIndex=message.indexOf(""String_Node_Str"",endIndex);
      int colOffset=0;
      if (beginIndex != -1) {
        colOffset=8;
      }
      int otherIndex=message.indexOf(""String_Node_Str"",endIndex);
      if ((otherIndex != -1) && ((beginIndex == -1) || (otherIndex < beginIndex))) {
        beginIndex=otherIndex;
        colOffset=5;
      }
      if (beginIndex != -1) {
        beginIndex=beginIndex + colOffset;
        while ((beginIndex < message.length()) && !Character.isDigit(message.charAt(beginIndex))) {
          beginIndex++;
        }
        endIndex=beginIndex + 1;
        while ((endIndex < message.length()) && Character.isDigit(message.charAt(endIndex))) {
          endIndex++;
        }
        if (beginIndex < message.length()) {
          val[1]=Integer.parseInt(message.substring(beginIndex,endIndex));
          val[2]=endIndex;
        }
      }
    }
  }
  return val;
}","/** 
 * Looks for line and column number in str starting at idx, and returns a 3-element array val with val[0] = the line number and val[1] = the column number, and val[2] the index at the end of the column number. It returns -1 for a number it doesn't find, and may leave val[3] off the end of the array. It works (but of course finds nothing if idx >= str.length(). This is a kludge that assumes that the line number is preceded either by "" line "" or by ""line "" that begins the error message, and that the column number is preceded by either "" column "" or "" col "". Bug found on 17 Oct 2010:  On some errors, SANY returns an error message with location line 2147483647, col 2147483647 to line -2147483648, col -2147483648 One such error is caused by BY DEF Foo.x' in a proof.  Such a line or column number produces a java.lang.NumberFormatException when Integer.parseInt is called to parse it.  Perhaps this should be fixed in SANY.   However, even if that were to be fixed, it seems like a good idea to catch the  exception here in case there are other cases in which SANY produces a malformed location.  So this was done by LL on 17 Oct 2010.  The fix is to return values of -1 when an exception is thrown, hoping that the comment is accurate and the return value of -1 is expected by the caller.
 */
private static final int[] findLineAndColumn(final int idx,final String message){
  int[] val={-1,-1,message.length()};
  int beginIndex=message.indexOf(""String_Node_Str"",idx);
  int offset=5;
  if (beginIndex != idx) {
    beginIndex=-1;
  }
  if (beginIndex == -1) {
    beginIndex=message.indexOf(""String_Node_Str"",idx);
    offset=6;
  }
  if (beginIndex != -1) {
    beginIndex=beginIndex + offset;
    while ((beginIndex < message.length()) && !Character.isDigit(message.charAt(beginIndex))) {
      beginIndex++;
    }
    int endIndex=beginIndex + 1;
    while ((endIndex < message.length()) && Character.isDigit(message.charAt(endIndex))) {
      endIndex++;
    }
    if (beginIndex < message.length()) {
      try {
        val[0]=Integer.parseInt(message.substring(beginIndex,endIndex));
      }
 catch (      Exception e) {
        val[0]=-1;
      }
      beginIndex=message.indexOf(""String_Node_Str"",endIndex);
      int colOffset=0;
      if (beginIndex != -1) {
        colOffset=8;
      }
      int otherIndex=message.indexOf(""String_Node_Str"",endIndex);
      if ((otherIndex != -1) && ((beginIndex == -1) || (otherIndex < beginIndex))) {
        beginIndex=otherIndex;
        colOffset=5;
      }
      if (beginIndex != -1) {
        beginIndex=beginIndex + colOffset;
        while ((beginIndex < message.length()) && !Character.isDigit(message.charAt(beginIndex))) {
          beginIndex++;
        }
        endIndex=beginIndex + 1;
        while ((endIndex < message.length()) && Character.isDigit(message.charAt(endIndex))) {
          endIndex++;
        }
        if (beginIndex < message.length()) {
          try {
            val[1]=Integer.parseInt(message.substring(beginIndex,endIndex));
          }
 catch (          Exception e) {
            val[1]=-1;
          }
          val[2]=endIndex;
        }
      }
    }
  }
  return val;
}",0.8331191481549477
135929,"private static void setUseMarkers(OpApplNode[] uses,String moduleName,Spec spec){
  Location[] locations=new Location[uses.length];
  for (int i=0; i < locations.length; i++) {
    SyntaxTreeNode stn=(SyntaxTreeNode)uses[i].stn;
switch (stn.getKind()) {
case N_OpApplication:
      stn=(SyntaxTreeNode)stn.heirs()[0];
    break;
case N_InfixExpr:
case N_PostfixExpr:
  stn=(SyntaxTreeNode)stn.heirs()[1];
break;
case N_GeneralId:
break;
default :
System.out.println(""String_Node_Str"" + stn.getKind() + ""String_Node_Str"");
}
locations[i]=stn.getLocation();
}
Arrays.sort(locations,new LocationComparator());
UIHelper.jumpToLocation(locations[0]);
spec.setCurrentSelection(0);
IResource resource=ResourceHelper.getResourceByModuleName(spec.getModuleToShow());
if (resource == null) {
System.out.println(""String_Node_Str"");
return;
}
try {
resource.deleteMarkers(SHOW_USE_MARKER_TYPE,false,99);
spec.setMarkersToShow(null);
IMarker[] markersToShow=new IMarker[locations.length];
for (int i=0; i < markersToShow.length; i++) {
IRegion iregion=AdapterFactory.locationToRegion(locations[i]);
IMarker marker;
marker=resource.createMarker(SHOW_USE_MARKER_TYPE);
Map markerAttributes=new HashMap(2);
markerAttributes.put(IMarker.CHAR_START,new Integer(iregion.getOffset()));
markerAttributes.put(IMarker.CHAR_END,new Integer(iregion.getOffset() + iregion.getLength()));
marker.setAttributes(markerAttributes);
markersToShow[i]=marker;
}
spec.setMarkersToShow(markersToShow);
}
 catch (CoreException e) {
e.printStackTrace();
}
}","private static void setUseMarkers(OpApplNode[] uses,String moduleName,Spec spec){
  Location[] locations=new Location[uses.length];
  for (int i=0; i < locations.length; i++) {
    SyntaxTreeNode stn=(SyntaxTreeNode)uses[i].stn;
switch (stn.getKind()) {
case N_OpApplication:
      stn=(SyntaxTreeNode)stn.heirs()[0];
    break;
case N_InfixExpr:
case N_PostfixExpr:
  stn=(SyntaxTreeNode)stn.heirs()[1];
break;
case N_GeneralId:
if (uses[i].subExpressionOf != null) {
while (stn.getKind() > NULL_ID && stn.heirs() != null && stn.heirs().length > 0) {
  stn=(SyntaxTreeNode)stn.heirs()[0];
}
}
break;
default :
System.out.println(""String_Node_Str"" + stn.getKind() + ""String_Node_Str"");
}
locations[i]=stn.getLocation();
}
Arrays.sort(locations,new LocationComparator());
UIHelper.jumpToLocation(locations[0]);
spec.setCurrentSelection(0);
IResource resource=ResourceHelper.getResourceByModuleName(spec.getModuleToShow());
if (resource == null) {
System.out.println(""String_Node_Str"");
return;
}
try {
resource.deleteMarkers(SHOW_USE_MARKER_TYPE,false,99);
spec.setMarkersToShow(null);
IMarker[] markersToShow=new IMarker[locations.length];
for (int i=0; i < markersToShow.length; i++) {
IRegion iregion=AdapterFactory.locationToRegion(locations[i]);
IMarker marker;
marker=resource.createMarker(SHOW_USE_MARKER_TYPE);
Map markerAttributes=new HashMap(2);
markerAttributes.put(IMarker.CHAR_START,new Integer(iregion.getOffset()));
markerAttributes.put(IMarker.CHAR_END,new Integer(iregion.getOffset() + iregion.getLength()));
marker.setAttributes(markerAttributes);
markersToShow[i]=marker;
}
spec.setMarkersToShow(markersToShow);
}
 catch (CoreException e) {
e.printStackTrace();
}
}",0.9487820112429732
135930,"/** 
 * On 21 June 2010 LL discovered the following bug.  For a proof-step number of the form ""<2>3."", the token in the syntax tree contains the ""."".  This seems to be a reasonable place to fix it by returning just the ""<2>3"" and its location.
 * @param location
 * @return
 */
public static StringAndLocation getTokenAtLocation(Location location){
  TLAEditor editor=EditorUtil.getTLAEditorWithFocus();
  if (editor == null) {
    return null;
  }
  IFile moduleFile=((FileEditorInput)editor.getEditorInput()).getFile();
  if (editor.isDirty()) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  ParseResult parseResult=ResourceHelper.getValidParseResult(moduleFile);
  if ((parseResult == null) || (parseResult.getStatus() != IParseConstants.PARSED)) {
    return null;
  }
  String moduleName=ResourceHelper.getModuleName(moduleFile);
  ModuleNode module=parseResult.getSpecObj().getExternalModuleTable().getModuleNode(UniqueString.uniqueStringOf(moduleName));
  if (module == null) {
    return null;
  }
  SyntaxTreeNode stn=(SyntaxTreeNode)module.stn;
  if (!locationContainment(location,stn.getLocation())) {
    return null;
  }
  StringAndLocation stl=innerGetCurrentToken(stn,location);
  if (stl == null) {
    return null;
  }
  if ((stl.string.charAt(0) == '<') && (stl.string.indexOf('.') != -1)) {
    Location loc=stl.location;
    stl=new StringAndLocation(stl.string.substring(0,stl.string.indexOf('.')),new Location(UniqueString.uniqueStringOf(loc.source()),loc.beginLine(),loc.beginColumn(),loc.endLine(),loc.beginColumn() + stl.string.indexOf('.')));
  }
  return stl;
}","/** 
 * On 21 June 2010 LL discovered the following bug.  For a proof-step number of the form ""<2>3."", the token in the syntax tree contains the ""."".  This seems to be a reasonable place to fix it by returning just the ""<2>3"" and its location.  Apparently, it has been fixed here.
 * @param location
 * @return
 */
public static StringAndLocation getTokenAtLocation(Location location){
  TLAEditor editor=EditorUtil.getTLAEditorWithFocus();
  if (editor == null) {
    return null;
  }
  IFile moduleFile=((FileEditorInput)editor.getEditorInput()).getFile();
  if (editor.isDirty()) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  ParseResult parseResult=ResourceHelper.getValidParseResult(moduleFile);
  if ((parseResult == null) || (parseResult.getStatus() != IParseConstants.PARSED)) {
    return null;
  }
  String moduleName=ResourceHelper.getModuleName(moduleFile);
  ModuleNode module=parseResult.getSpecObj().getExternalModuleTable().getModuleNode(UniqueString.uniqueStringOf(moduleName));
  if (module == null) {
    return null;
  }
  SyntaxTreeNode stn=(SyntaxTreeNode)module.stn;
  if (!locationContainment(location,stn.getLocation())) {
    return null;
  }
  StringAndLocation stl=innerGetCurrentToken(stn,location);
  if (stl == null) {
    return null;
  }
  if ((stl.string.charAt(0) == '<') && (stl.string.indexOf('.') != -1)) {
    Location loc=stl.location;
    stl=new StringAndLocation(stl.string.substring(0,stl.string.indexOf('.')),new Location(UniqueString.uniqueStringOf(loc.source()),loc.beginLine(),loc.beginColumn(),loc.endLine(),loc.beginColumn() + stl.string.indexOf('.')));
  }
  return stl;
}",0.9886258837995696
135931,"/** 
 * Returns the token containing the current selection, or null if there is none.  A token here means a TLA+ token except that a name like Foo!bar!x is considered to be a single token.  It returns null if the file is not parsed or the editor is dirty (so there is no useful information in the parse tree) or if there is no token contained within the indicated region.
 * @return
 */
public static StringAndLocation getCurrentToken(){
  Location location=getCurrentLocation();
  if (location == null) {
    return null;
  }
  return getTokenAtLocation(location);
}","/** 
 * Returns the token containing the current selection, or null if there is none.  A token here means a TLA+ token except that a name like Foo!bar!x is considered to be a single token.  It returns null if the file is not parsed or the editor is dirty (so there is no useful information in the parse tree) or if there is no token contained within the indicated region. THIS METHOD DOES NOT SEEM TO BE USED.
 * @return
 */
public static StringAndLocation getCurrentToken(){
  Location location=getCurrentLocation();
  if (location == null) {
    return null;
  }
  return getTokenAtLocation(location);
}",0.9675767918088736
135932,"/** 
 * The inner recursive method used by get UsesOfSymbol.  It appends all the appropriate OpApplNodes  to <code>found</code>.
 * @param symbol
 * @param node
 * @param found
 * @return
 */
private static void innerGetUsesOfSymbol(SymbolNode symbol,SemanticNode node,Vector found){
  if ((node instanceof OpApplNode) && (((OpApplNode)node).getOperator() == symbol)) {
    found.add(node);
  }
  SemanticNode[] children=node.getChildren();
  if (children == null) {
    return;
  }
  for (int i=0; i < children.length; i++) {
    if (node.getLocation().source().equals(children[i].getLocation().source())) {
      innerGetUsesOfSymbol(symbol,children[i],found);
    }
  }
  return;
}","/** 
 * The inner recursive method used by get UsesOfSymbol.  It appends all the appropriate OpApplNodes  to <code>found</code>. Note: modified by LL on 14 Sep 2010 so a subexpression name like  Foo!1!(a) will be returned as a use of Foo.  This is introduces another case to be handled when trying to extract the symbol's occurrence from the  OpApplNode containing the symbol.  This is the one case in which the symbol is not really the operator of the OpApplNode.
 * @param symbol
 * @param node
 * @param found
 * @return
 */
private static void innerGetUsesOfSymbol(SymbolNode symbol,SemanticNode node,Vector found){
  if ((node instanceof OpApplNode) && ((((OpApplNode)node).getOperator() == symbol) || ((OpApplNode)node).subExpressionOf == symbol)) {
    found.add(node);
  }
  SemanticNode[] children=node.getChildren();
  if (children == null) {
    return;
  }
  for (int i=0; i < children.length; i++) {
    if (node.getLocation().source().equals(children[i].getLocation().source())) {
      innerGetUsesOfSymbol(symbol,children[i],found);
    }
  }
  return;
}",0.7799315849486887
135933,"private final void belchDEF(){
  Token previousT=initPreviewToken();
  Token currentT=getNextPreviewToken(previousT);
  previousT.next=null;
  Token nextT=getNextPreviewToken(currentT);
  currentT.next=previousT;
  while (nextT.kind != EOF && nextT.kind != THEOREM && nextT.kind != PROPOSITION && nextT.kind != ASSUME && nextT.kind != ASSUMPTION && nextT.kind != END_MODULE) {
    if (currentT.kind == DEF) {
      Token t=previousT;
      if (t.kind == RBR || t.kind == RSB) {
        int depth=1;
        while (t.next != null) {
          t=t.next;
          if ((t.kind == LBR || t.kind == LSB) && depth == 1)           break;
          if ((t.kind == LBR || t.kind == LSB) && depth > 1)           depth--;
          if ((t.kind == RBR || t.kind == RSB))           depth++;
        }
        if (t.next == null)         break;
 else         if (t.next.kind == IDENTIFIER)         t=t.next;
      }
 else       if (t.kind == IDENTIFIER) {
        Token identifier=t;
        if (isOp(t.next) && !isPostfixOp(t.next)) {
          t=t.next;
          if (t.next.kind == SUBSTITUTE)           t=identifier;
 else           if (isInfixOp(t))           t=t.next;
        }
      }
 else {
        if (isOp(t)) {
          t=t.next;
        }
      }
      if ((t.next == null) || (t.next.kind != DEFBREAK)) {
        Token i=new Token();
        i.kind=DEFBREAK;
        i.image=""String_Node_Str"";
        i.beginLine=t.beginLine;
        i.beginColumn=t.beginColumn;
        i.endLine=t.endLine;
        i.endColumn=t.endColumn;
        i.next=t.next;
        t.next=i;
      }
      ;
      break;
    }
 else {
      previousT=currentT;
      currentT=nextT;
      nextT=getNextPreviewToken(currentT);
      currentT.next=previousT;
    }
  }
  while (previousT != null) {
    currentT.next=nextT;
    nextT=currentT;
    currentT=previousT;
    previousT=currentT.next;
  }
  currentT.next=nextT;
}","private final void belchDEF(){
  Token previousT=initPreviewToken();
  Token currentT=getNextPreviewToken(previousT);
  previousT.next=null;
  Token nextT=getNextPreviewToken(currentT);
  currentT.next=previousT;
  while (nextT.kind != EOF && nextT.kind != THEOREM && nextT.kind != PROPOSITION && nextT.kind != ASSUMPTION && nextT.kind != END_MODULE) {
    if (currentT.kind == DEF) {
      Token t=previousT;
      if (t.kind == RBR || t.kind == RSB) {
        int depth=1;
        while (t.next != null) {
          t=t.next;
          if ((t.kind == LBR || t.kind == LSB) && depth == 1)           break;
          if ((t.kind == LBR || t.kind == LSB) && depth > 1)           depth--;
          if ((t.kind == RBR || t.kind == RSB))           depth++;
        }
        if (t.next == null)         break;
 else         if (t.next.kind == IDENTIFIER)         t=t.next;
      }
 else       if (t.kind == IDENTIFIER) {
        Token identifier=t;
        if (isOp(t.next) && !isPostfixOp(t.next)) {
          t=t.next;
          if (t.next.kind == SUBSTITUTE)           t=identifier;
 else           if (isInfixOp(t))           t=t.next;
        }
      }
 else {
        if (isOp(t)) {
          t=t.next;
        }
      }
      if ((t.next == null) || (t.next.kind != DEFBREAK)) {
        Token i=new Token();
        i.kind=DEFBREAK;
        i.image=""String_Node_Str"";
        i.beginLine=t.beginLine;
        i.beginColumn=t.beginColumn;
        i.endLine=t.endLine;
        i.endColumn=t.endColumn;
        i.next=t.next;
        t.next=i;
      }
      ;
      break;
    }
 else {
      previousT=currentT;
      currentT=nextT;
      nextT=getNextPreviewToken(currentT);
      currentT.next=previousT;
    }
  }
  while (previousT != null) {
    currentT.next=nextT;
    nextT=currentT;
    currentT=previousT;
    previousT=currentT.next;
  }
  currentT.next=nextT;
}",0.9936440677966102
135934,"public static Value CombineFcn(Value f1,Value f2){
  FcnRcdValue fcn1=FcnRcdValue.convert(f1);
  FcnRcdValue fcn2=FcnRcdValue.convert(f2);
  if (fcn1 == null) {
    throw new EvalException(EC.TLC_MODULE_ARGUMENT_ERROR,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Value.ppr(f1.toString())});
  }
  if (fcn2 == null) {
    throw new EvalException(EC.TLC_MODULE_ARGUMENT_ERROR,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Value.ppr(f2.toString())});
  }
  ValueVec dom=new ValueVec();
  ValueVec vals=new ValueVec();
  Value[] vals1=fcn1.values;
  Value[] vals2=fcn2.values;
  Value[] dom1=fcn1.domain;
  if (dom1 == null) {
    IntervalValue intv1=fcn1.intv;
    for (int i=intv1.low; i <= intv1.high; i++) {
      dom.addElement(IntValue.gen(i));
      vals.addElement(vals1[i]);
    }
  }
 else {
    for (int i=0; i < dom1.length; i++) {
      dom.addElement(dom1[i]);
      vals.addElement(vals1[i]);
    }
  }
  int len1=dom.size();
  Value[] dom2=fcn2.domain;
  if (dom2 == null) {
    IntervalValue intv2=fcn2.intv;
    for (int i=intv2.low; i <= intv2.high; i++) {
      Value val=IntValue.gen(i);
      boolean found=false;
      for (int j=0; j < len1; j++) {
        if (val.equals(dom.elementAt(j))) {
          found=true;
          break;
        }
      }
      if (!found) {
        dom.addElement(val);
        vals.addElement(vals2[i]);
      }
    }
  }
 else {
    for (int i=0; i < dom2.length; i++) {
      Value val=dom2[i];
      boolean found=false;
      for (int j=0; j < len1; j++) {
        if (val.equals(dom.elementAt(j))) {
          found=true;
          break;
        }
      }
      if (!found) {
        dom.addElement(val);
        vals.addElement(vals2[i]);
      }
    }
  }
  Value[] domain=new Value[dom.size()];
  Value[] values=new Value[dom.size()];
  for (int i=0; i < domain.length; i++) {
    domain[i]=dom.elementAt(i);
    values[i]=vals.elementAt(i);
  }
  return new FcnRcdValue(domain,values,false);
}","public static Value CombineFcn(Value f1,Value f2){
  FcnRcdValue fcn1=FcnRcdValue.convert(f1);
  FcnRcdValue fcn2=FcnRcdValue.convert(f2);
  if (fcn1 == null) {
    throw new EvalException(EC.TLC_MODULE_ARGUMENT_ERROR,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Value.ppr(f1.toString())});
  }
  if (fcn2 == null) {
    throw new EvalException(EC.TLC_MODULE_ARGUMENT_ERROR,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Value.ppr(f2.toString())});
  }
  ValueVec dom=new ValueVec();
  ValueVec vals=new ValueVec();
  Value[] vals1=fcn1.values;
  Value[] vals2=fcn2.values;
  Value[] dom1=fcn1.domain;
  if (dom1 == null) {
    IntervalValue intv1=fcn1.intv;
    for (int i=intv1.low; i <= intv1.high; i++) {
      dom.addElement(IntValue.gen(i));
      vals.addElement(vals1[i - intv1.low]);
    }
  }
 else {
    for (int i=0; i < dom1.length; i++) {
      dom.addElement(dom1[i]);
      vals.addElement(vals1[i]);
    }
  }
  int len1=dom.size();
  Value[] dom2=fcn2.domain;
  if (dom2 == null) {
    IntervalValue intv2=fcn2.intv;
    for (int i=intv2.low; i <= intv2.high; i++) {
      Value val=IntValue.gen(i);
      boolean found=false;
      for (int j=0; j < len1; j++) {
        if (val.equals(dom.elementAt(j))) {
          found=true;
          break;
        }
      }
      if (!found) {
        dom.addElement(val);
        vals.addElement(vals2[i]);
      }
    }
  }
 else {
    for (int i=0; i < dom2.length; i++) {
      Value val=dom2[i];
      boolean found=false;
      for (int j=0; j < len1; j++) {
        if (val.equals(dom.elementAt(j))) {
          found=true;
          break;
        }
      }
      if (!found) {
        dom.addElement(val);
        vals.addElement(vals2[i]);
      }
    }
  }
  Value[] domain=new Value[dom.size()];
  Value[] values=new Value[dom.size()];
  for (int i=0; i < domain.length; i++) {
    domain[i]=dom.elementAt(i);
    values[i]=vals.elementAt(i);
  }
  return new FcnRcdValue(domain,values,false);
}",0.997002997002997
135935,"/** 
 * Returns the content for the end of the module
 * @return
 */
public static StringBuffer getModuleClosingTag(){
  StringBuffer buffer=new StringBuffer();
  buffer.append(StringHelper.copyString(""String_Node_Str"",Activator.getDefault().getPreferenceStore().getInt(EditorPreferencePage.EDITOR_RIGHT_MARGIN))).append(modificationHistory).append(StringHelper.newline).append(""String_Node_Str"").append(new Date()).append(""String_Node_Str"").append(System.getProperty(""String_Node_Str"")).append(StringHelper.newline);
  return buffer;
}","/** 
 * Returns the content for the end of the module
 * @return
 */
public static StringBuffer getModuleClosingTag(){
  StringBuffer buffer=new StringBuffer();
  buffer.append(StringHelper.copyString(""String_Node_Str"",Activator.getDefault().getPreferenceStore().getInt(EditorPreferencePage.EDITOR_RIGHT_MARGIN))).append(""String_Node_Str"" + modificationHistory).append(StringHelper.newline).append(""String_Node_Str"").append(new Date()).append(""String_Node_Str"").append(System.getProperty(""String_Node_Str"")).append(StringHelper.newline);
  return buffer;
}",0.9816849816849816
135936,"private static void setUseMarkers(OpApplNode[] uses,String moduleName,Spec spec){
  Location[] locations=new Location[uses.length];
  for (int i=0; i < locations.length; i++) {
    SyntaxTreeNode stn=(SyntaxTreeNode)uses[i].stn;
switch (stn.getKind()) {
case N_OpApplication:
      stn=(SyntaxTreeNode)stn.heirs()[0];
    break;
case N_InfixExpr:
case N_PostfixExpr:
  stn=(SyntaxTreeNode)stn.heirs()[1];
break;
case N_GeneralId:
if (uses[i].subExpressionOf != null) {
while (stn.getKind() > NULL_ID && stn.heirs() != null && stn.heirs().length > 0) {
  stn=(SyntaxTreeNode)stn.heirs()[0];
}
}
break;
default :
System.out.println(""String_Node_Str"" + stn.getKind() + ""String_Node_Str"");
}
locations[i]=stn.getLocation();
}
Arrays.sort(locations,new LocationComparator());
UIHelper.jumpToLocation(locations[0]);
spec.setCurrentSelection(0);
IResource resource=ResourceHelper.getResourceByModuleName(spec.getModuleToShow());
if (resource == null) {
System.out.println(""String_Node_Str"");
return;
}
try {
resource.deleteMarkers(SHOW_USE_MARKER_TYPE,false,99);
spec.setMarkersToShow(null);
IMarker[] markersToShow=new IMarker[locations.length];
for (int i=0; i < markersToShow.length; i++) {
IRegion iregion=AdapterFactory.locationToRegion(locations[i]);
IMarker marker;
marker=resource.createMarker(SHOW_USE_MARKER_TYPE);
Map markerAttributes=new HashMap(2);
markerAttributes.put(IMarker.CHAR_START,new Integer(iregion.getOffset()));
markerAttributes.put(IMarker.CHAR_END,new Integer(iregion.getOffset() + iregion.getLength()));
marker.setAttributes(markerAttributes);
markersToShow[i]=marker;
}
spec.setMarkersToShow(markersToShow);
}
 catch (CoreException e) {
e.printStackTrace();
}
}","/** 
 * TODO: This method has the following minor bug.  When Foo is defined in module M, which is instantiated by  I == INSTANCE M, then when one of the OpApplNodes in uses represents a subexpression name like I!Foo!2, then just the ""I"" rather than the ""I!Foo"" is marked.  This is pretty harmless and is probably not worth fixing.
 * @param uses
 * @param moduleName
 * @param spec
 */
private static void setUseMarkers(OpApplNode[] uses,String moduleName,Spec spec){
  Location[] locations=new Location[uses.length];
  for (int i=0; i < locations.length; i++) {
    SyntaxTreeNode stn=(SyntaxTreeNode)uses[i].stn;
switch (stn.getKind()) {
case N_OpApplication:
      stn=(SyntaxTreeNode)stn.heirs()[0];
    break;
case N_InfixExpr:
case N_PostfixExpr:
  stn=(SyntaxTreeNode)stn.heirs()[1];
break;
case N_GeneralId:
if (uses[i].subExpressionOf != null && uses[i].subExpressionOf != uses[i].getOperator()) {
while (stn.getKind() > NULL_ID && stn.heirs() != null && stn.heirs().length > 0) {
  stn=(SyntaxTreeNode)stn.heirs()[0];
}
}
break;
default :
System.out.println(""String_Node_Str"" + stn.getKind() + ""String_Node_Str"");
}
locations[i]=stn.getLocation();
}
Arrays.sort(locations,new LocationComparator());
UIHelper.jumpToLocation(locations[0]);
spec.setCurrentSelection(0);
IResource resource=ResourceHelper.getResourceByModuleName(spec.getModuleToShow());
if (resource == null) {
System.out.println(""String_Node_Str"");
return;
}
try {
resource.deleteMarkers(SHOW_USE_MARKER_TYPE,false,99);
spec.setMarkersToShow(null);
IMarker[] markersToShow=new IMarker[locations.length];
for (int i=0; i < markersToShow.length; i++) {
IRegion iregion=AdapterFactory.locationToRegion(locations[i]);
IMarker marker;
marker=resource.createMarker(SHOW_USE_MARKER_TYPE);
Map markerAttributes=new HashMap(2);
markerAttributes.put(IMarker.CHAR_START,new Integer(iregion.getOffset()));
markerAttributes.put(IMarker.CHAR_END,new Integer(iregion.getOffset() + iregion.getLength()));
marker.setAttributes(markerAttributes);
markersToShow[i]=marker;
}
spec.setMarkersToShow(markersToShow);
}
 catch (CoreException e) {
e.printStackTrace();
}
}",0.8848580441640379
135937,"/** 
 * This method is called by eclipse when the user presses OK. The current state of the dialog is saved in preferences so that it can be restored next time, and the PM is launched with the selected options.
 */
protected void okPressed(){
  IPreferenceStore store=ProverUIActivator.getDefault().getPreferenceStore();
  store.setValue(EXTRA_OPTIONS_KEY,extraOptionsText.getText());
  store.setValue(TOOLBOX_MODE_KEY,toolboxMode.getSelection());
  store.setValue(ISATOOL_KEY,isatool.getSelection());
  store.setValue(STATUS_CHECK_KEY,noProving.getSelection());
  store.setValue(ISACHECK_KEY,isacheck.getSelection());
  store.setValue(NOISA_KEY,noisa.getSelection());
  store.setValue(PARANOID_KEY,paranoid.getSelection());
  store.setValue(FP_NORMAL_KEY,fpNormal.getSelection());
  store.setValue(FP_FORGET_ALL_KEY,fpForgetAll.getSelection());
  store.setValue(FP_FORGET_CURRENT_KEY,fpForgetCurrent.getSelection());
  ArrayList command=new ArrayList();
  if (isatool.getSelection()) {
    command.add(ITLAPMOptions.ISAPROVE);
  }
 else   if (isacheck.getSelection()) {
    command.add(ITLAPMOptions.ISACHECK);
  }
  if (fpForgetAll.getSelection()) {
    command.add(ITLAPMOptions.FORGET_ALL);
  }
 else   if (fpForgetCurrent.getSelection()) {
    command.add(ITLAPMOptions.FORGET_CURRENT);
  }
  if (paranoid.isEnabled() && paranoid.getSelection()) {
    command.add(ITLAPMOptions.PARANOID);
  }
  ProverHelper.setThreadsOption(command);
  ProverHelper.setSolverOption(command);
  ProverHelper.setSafeFPOption(command);
  String[] extraOptions=extraOptionsText.getText().trim().split(""String_Node_Str"");
  for (int i=0; i < extraOptions.length; i++) {
    command.add(extraOptions[i]);
  }
  TLAEditor editor=EditorUtil.getActiveTLAEditor();
  Assert.isNotNull(editor,""String_Node_Str"");
  ProverJob proverJob=new ProverJob(((FileEditorInput)editor.getEditorInput()).getFile(),((ITextSelection)editor.getSelectionProvider().getSelection()).getOffset(),noProving.getSelection(),(String[])command.toArray(new String[command.size()]),toolboxMode.getSelection());
  proverJob.setUser(true);
  proverJob.schedule();
  super.okPressed();
}","/** 
 * This method is called by eclipse when the user presses OK. The current state of the dialog is saved in preferences so that it can be restored next time, and the PM is launched with the selected options.
 */
protected void okPressed(){
  IPreferenceStore store=ProverUIActivator.getDefault().getPreferenceStore();
  store.setValue(EXTRA_OPTIONS_KEY,extraOptionsText.getText());
  store.setValue(TOOLBOX_MODE_KEY,toolboxMode.getSelection());
  store.setValue(ISATOOL_KEY,isatool.getSelection());
  store.setValue(STATUS_CHECK_KEY,noProving.getSelection());
  store.setValue(ISACHECK_KEY,isacheck.getSelection());
  store.setValue(NOISA_KEY,noisa.getSelection());
  store.setValue(PARANOID_KEY,paranoid.getSelection());
  store.setValue(FP_NORMAL_KEY,fpNormal.getSelection());
  store.setValue(FP_FORGET_ALL_KEY,fpForgetAll.getSelection());
  store.setValue(FP_FORGET_CURRENT_KEY,fpForgetCurrent.getSelection());
  ArrayList command=new ArrayList();
  if (isatool.getSelection()) {
    command.add(ITLAPMOptions.ISAPROVE);
  }
 else   if (isacheck.getSelection()) {
    command.add(ITLAPMOptions.ISACHECK);
  }
  if (fpForgetAll.getSelection()) {
    command.add(ITLAPMOptions.FORGET_ALL);
  }
 else   if (fpForgetCurrent.getSelection()) {
    command.add(ITLAPMOptions.FORGET_CURRENT);
  }
  if (paranoid.isEnabled() && paranoid.getSelection()) {
    command.add(ITLAPMOptions.PARANOID);
  }
  ProverHelper.setThreadsOption(command);
  ProverHelper.setSolverOption(command);
  ProverHelper.setSafeFPOption(command);
  String[] extraOptions=extraOptionsText.getText().trim().split(""String_Node_Str"");
  for (int i=0; i < extraOptions.length; i++) {
    if (!extraOptions[i].equals(""String_Node_Str"")) {
      command.add(extraOptions[i]);
    }
  }
  TLAEditor editor=EditorUtil.getActiveTLAEditor();
  Assert.isNotNull(editor,""String_Node_Str"");
  ProverJob proverJob=new ProverJob(((FileEditorInput)editor.getEditorInput()).getFile(),((ITextSelection)editor.getSelectionProvider().getSelection()).getOffset(),noProving.getSelection(),(String[])command.toArray(new String[command.size()]),toolboxMode.getSelection());
  proverJob.setUser(true);
  proverJob.schedule();
  super.okPressed();
}",0.979224376731302
135938,"/** 
 * Performs processing for the error and the error trace produced after a run of the trace explorer. This method does the following to a trace: 1.) Changes the names of the variables corresponding to trace explorer expressions to the actual expressions. 2.) It also shifts the values of expressions of level 2. For an expressions of level 2 (expression with primed variables), the value in state x becomes the original value in state x+1. The value in the final state of such expressions is equal to ""--"". 3.) Changes the state labels ""<Action ... in module TE> State (num = 3)"" to the state labels of the original trace. The goal is to have no reference to module TE. 4.) Puts the variables representing the trace explorer expressions before the actual variables in each state. 5.) Removes any extra states produced by the trace explorer. This can sometimes occur when evaluating expressions for a looping (""Back to state"") trace and for a stuttering trace. This can be illustrated by an example. Consider the following trace: <Initial predicate> <State num 1> x=0 <Action ...> <State num 2> x=1 <Back to state 1> The user wants to evaluate the following expression: x' >= x The toolbox uses the following as init and next: Init == /\ x=0 /\ __trace_var_213123 = ""--"" Next == \/ /\ x=0 /\ x'=1 /\ __trace_var_213123' = (x'>=x) \/ /\ x=1 /\ x'=0 /\ __trace_var_213123' = (x'>=x) We check the following property: prop_23432 == ~([]<>(x=1)/\[]<>(x=0)) This produces the following trace: <Initial predicate> <State num 1> x=0 __trace_var_213123 = ""--"" <Action ...> <State num 2> x=1 __trace_var_213123 = TRUE <Action ...> <State num 3> x=0 __trace_var_213123 = FALSE <Back to state 2> Note the additional state with x=0 and __trace_var_213123 = FALSE. We shift the values for expressions with primed variables up by one state, so this extra state is necessary for producing the value for the expression ""x' >= x"" in the second state of the trace (In non-looping traces, there is no value for the expression in the final state, so we simply assign it the value ""--"".) The processing by this method eliminates this extra state but uses the value for __trace_var_213123, so that the following trace can be displayed to the user: <Initial predicate> <State num 1> x=0 (x' >= x)    =     TRUE <Action ...> <State num 2> x=1 (x' >= x)    =    FALSE <Back to state 1> 6.) If the trace explorer ran successfully, this method replaces the error message associated with the trace produced by the trace explorer with the error message produced by the last run of model checking on the model for which the trace explorer was run.
 */
private void processTraceForTraceExplorer(){
  TLCError originalErrorWithTrace=TraceExplorerHelper.getErrorOfOriginalTrace(getConfig());
  if (originalErrorWithTrace == null) {
    getErrors().clear();
    return;
  }
  List originalTrace=originalErrorWithTrace.getStates();
  Assert.isNotNull(originalTrace,""String_Node_Str"");
  Iterator it=getErrors().iterator();
  while (it.hasNext()) {
    TLCError error=(TLCError)it.next();
    if (error.hasTrace()) {
      int errorCode=error.getErrorCode();
      if (errorCode == EC.TLC_DEADLOCK_REACHED || errorCode == EC.TLC_TEMPORAL_PROPERTY_VIOLATED || errorCode == EC.TLC_INVARIANT_VIOLATED_BEHAVIOR || errorCode == EC.TLC_INVARIANT_VIOLATED_INITIAL) {
        error.setErrorCode(originalErrorWithTrace.getErrorCode());
        error.setMessage(originalErrorWithTrace.getMessage());
        error.setCause(originalErrorWithTrace.getCause());
      }
 else {
        error.setMessage(TE_ERROR_HEADER + error.getMessage());
      }
      Comparator varComparator=new Comparator(){
        public int compare(        Object arg0,        Object arg1){
          TLCVariable var0=(TLCVariable)arg0;
          TLCVariable var1=(TLCVariable)arg1;
          if ((var0.isTraceExplorerVar() && var1.isTraceExplorerVar()) || (!var0.isTraceExplorerVar() && !var1.isTraceExplorerVar())) {
            return var0.getName().compareTo(var1.getName());
          }
 else           if (var0.isTraceExplorerVar()) {
            return -1;
          }
 else {
            return 1;
          }
        }
      }
;
      List newTrace=error.getStates();
      Iterator newTraceIt=newTrace.iterator();
      Iterator originalTraceIt=originalTrace.iterator();
      TLCState currentStateNewTrace=(TLCState)newTraceIt.next();
      TLCState nextStateNewTrace=null;
      TLCState currentStateOriginalTrace=(TLCState)originalTraceIt.next();
      while (newTraceIt.hasNext() && originalTraceIt.hasNext()) {
        currentStateNewTrace.setLabel(currentStateOriginalTrace.getLabel());
        currentStateNewTrace.setLocation(currentStateOriginalTrace.getModuleLocation());
        nextStateNewTrace=(TLCState)newTraceIt.next();
        TLCVariable[] currentStateNewTraceVariables=currentStateNewTrace.getVariables();
        TLCVariable[] nextStateNewTraceVariables=nextStateNewTrace.getVariables();
        for (int i=0; i < currentStateNewTraceVariables.length; i++) {
          String variableName=currentStateNewTraceVariables[i].getName();
          if (!nextStateNewTrace.isBackToState() && !nextStateNewTrace.isStuttering()) {
            Assert.isTrue(variableName.equals(nextStateNewTraceVariables[i].getName()),""String_Node_Str"");
          }
          TraceExpressionInformationHolder traceExpressionData=(TraceExpressionInformationHolder)traceExpressionDataTable.get(variableName.trim());
          if (traceExpressionData != null) {
            if (!nextStateNewTrace.isBackToState() && !nextStateNewTrace.isStuttering() && traceExpressionData.getLevel() == 2) {
              currentStateNewTraceVariables[i].setValue(nextStateNewTraceVariables[i].getValue());
            }
            currentStateNewTraceVariables[i].setName(traceExpressionData.getExpression());
            currentStateNewTraceVariables[i].setTraceExplorerVar(true);
          }
        }
        Arrays.sort(currentStateNewTraceVariables,varComparator);
        currentStateNewTrace=nextStateNewTrace;
        currentStateOriginalTrace=(TLCState)originalTraceIt.next();
      }
      if ((currentStateOriginalTrace.isBackToState() || currentStateOriginalTrace.isStuttering()) && newTrace.size() >= originalTrace.size()) {
        newTrace.subList(originalTrace.size() - 1,newTrace.size()).clear();
      }
      Assert.isTrue(newTrace.size() <= originalTrace.size(),""String_Node_Str"");
      TLCState finalStateOriginalTrace=(TLCState)originalTrace.get(originalTrace.size() - 1);
      if (newTrace.size() < originalTrace.size() - 1 || (!finalStateOriginalTrace.isStuttering() && !finalStateOriginalTrace.isBackToState())) {
        TLCState finalStateNewTrace=(TLCState)newTrace.get(newTrace.size() - 1);
        TLCState samePositionOriginalTrace=(TLCState)originalTrace.get(newTrace.size() - 1);
        finalStateNewTrace.setLabel(samePositionOriginalTrace.getLabel());
        finalStateNewTrace.setLocation(samePositionOriginalTrace.getModuleLocation());
        TLCVariable[] finalStateNewTraceVariables=finalStateNewTrace.getVariables();
        for (int i=0; i < finalStateNewTraceVariables.length; i++) {
          TraceExpressionInformationHolder traceExpressionData=(TraceExpressionInformationHolder)traceExpressionDataTable.get(finalStateNewTraceVariables[i].getName().trim());
          if (traceExpressionData != null) {
            if (traceExpressionData.getLevel() == 2) {
              finalStateNewTraceVariables[i].setValue(TLCVariableValue.parseValue(""String_Node_Str""));
            }
            finalStateNewTraceVariables[i].setName(traceExpressionData.getExpression());
            finalStateNewTraceVariables[i].setTraceExplorerVar(true);
          }
        }
        Arrays.sort(finalStateNewTraceVariables,varComparator);
      }
 else       if (finalStateOriginalTrace.isBackToState()) {
        error.addState(TLCState.BACK_TO_STATE(finalStateOriginalTrace.getStateNumber(),ModelHelper.getModelName(getConfig().getFile())));
      }
 else {
        error.addState(TLCState.STUTTERING_STATE(finalStateOriginalTrace.getStateNumber(),ModelHelper.getModelName(getConfig().getFile())));
      }
    }
 else {
      error.setMessage(TE_ERROR_HEADER + error.getMessage());
    }
  }
}","/** 
 * Performs processing for the error and the error trace produced after a run of the trace explorer. This method does the following to a trace: 1.) Changes the names of the variables corresponding to trace explorer expressions to the actual expressions. 2.) It also shifts the values of expressions of level 2. For an expressions of level 2 (expression with primed variables), the value in state x becomes the original value in state x+1. The value in the final state of such expressions is equal to ""--"". 3.) Changes the state labels ""<Action ... in module TE> State (num = 3)"" to the state labels of the original trace. The goal is to have no reference to module TE. 4.) Puts the variables representing the trace explorer expressions before the actual variables in each state. 5.) Removes any extra states produced by the trace explorer. This can sometimes occur when evaluating expressions for a looping (""Back to state"") trace and for a stuttering trace. This can be illustrated by an example. Consider the following trace: <Initial predicate> <State num 1> x=0 <Action ...> <State num 2> x=1 <Back to state 1> The user wants to evaluate the following expression: x' >= x The toolbox uses the following as init and next: Init == /\ x=0 /\ __trace_var_213123 = ""--"" Next == \/ /\ x=0 /\ x'=1 /\ __trace_var_213123' = (x'>=x) \/ /\ x=1 /\ x'=0 /\ __trace_var_213123' = (x'>=x) We check the following property: prop_23432 == ~([]<>(x=1)/\[]<>(x=0)) This produces the following trace: <Initial predicate> <State num 1> x=0 __trace_var_213123 = ""--"" <Action ...> <State num 2> x=1 __trace_var_213123 = TRUE <Action ...> <State num 3> x=0 __trace_var_213123 = FALSE <Back to state 2> Note the additional state with x=0 and __trace_var_213123 = FALSE. We shift the values for expressions with primed variables up by one state, so this extra state is necessary for producing the value for the expression ""x' >= x"" in the second state of the trace (In non-looping traces, there is no value for the expression in the final state, so we simply assign it the value ""--"".) The processing by this method eliminates this extra state but uses the value for __trace_var_213123, so that the following trace can be displayed to the user: <Initial predicate> <State num 1> x=0 (x' >= x)    =     TRUE <Action ...> <State num 2> x=1 (x' >= x)    =    FALSE <Back to state 1> 6.) If the trace explorer ran successfully, this method changes several attributes of the error trace produced by the trace explorer. It changes the following three attributes: - error message - error code - cause It sets these attributes equal to those attributes for the error trace produced by the last run of model checking on the model for which the trace explorer was run. 7.) If the run of the trace explorer was successful, then we set the list of errors for this data provider in the following way : - Copy the list of errors from the original run of TLC. - In the copied list, replace the original trace error with the new trace error created by the successful run of the trace explorer.
 */
private void processTraceForTraceExplorer(){
  TLCError originalErrorWithTrace=TraceExplorerHelper.getErrorOfOriginalTrace(getConfig());
  if (originalErrorWithTrace == null) {
    getErrors().clear();
    return;
  }
  TLCError successfulTEError=null;
  List originalTrace=originalErrorWithTrace.getStates();
  Assert.isNotNull(originalTrace,""String_Node_Str"");
  Iterator it=getErrors().iterator();
  while (it.hasNext()) {
    TLCError error=(TLCError)it.next();
    if (error.hasTrace()) {
      int errorCode=error.getErrorCode();
      if (errorCode == EC.TLC_DEADLOCK_REACHED || errorCode == EC.TLC_TEMPORAL_PROPERTY_VIOLATED || errorCode == EC.TLC_INVARIANT_VIOLATED_BEHAVIOR || errorCode == EC.TLC_INVARIANT_VIOLATED_INITIAL) {
        error.setErrorCode(originalErrorWithTrace.getErrorCode());
        error.setMessage(originalErrorWithTrace.getMessage());
        error.setCause(originalErrorWithTrace.getCause());
        successfulTEError=error;
      }
 else {
        error.setMessage(TE_ERROR_HEADER + error.getMessage());
      }
      Comparator varComparator=new Comparator(){
        public int compare(        Object arg0,        Object arg1){
          TLCVariable var0=(TLCVariable)arg0;
          TLCVariable var1=(TLCVariable)arg1;
          if ((var0.isTraceExplorerVar() && var1.isTraceExplorerVar()) || (!var0.isTraceExplorerVar() && !var1.isTraceExplorerVar())) {
            return var0.getName().compareTo(var1.getName());
          }
 else           if (var0.isTraceExplorerVar()) {
            return -1;
          }
 else {
            return 1;
          }
        }
      }
;
      List newTrace=error.getStates();
      Iterator newTraceIt=newTrace.iterator();
      Iterator originalTraceIt=originalTrace.iterator();
      TLCState currentStateNewTrace=(TLCState)newTraceIt.next();
      TLCState nextStateNewTrace=null;
      TLCState currentStateOriginalTrace=(TLCState)originalTraceIt.next();
      while (newTraceIt.hasNext() && originalTraceIt.hasNext()) {
        currentStateNewTrace.setLabel(currentStateOriginalTrace.getLabel());
        currentStateNewTrace.setLocation(currentStateOriginalTrace.getModuleLocation());
        nextStateNewTrace=(TLCState)newTraceIt.next();
        TLCVariable[] currentStateNewTraceVariables=currentStateNewTrace.getVariables();
        TLCVariable[] nextStateNewTraceVariables=nextStateNewTrace.getVariables();
        for (int i=0; i < currentStateNewTraceVariables.length; i++) {
          String variableName=currentStateNewTraceVariables[i].getName();
          if (!nextStateNewTrace.isBackToState() && !nextStateNewTrace.isStuttering()) {
            Assert.isTrue(variableName.equals(nextStateNewTraceVariables[i].getName()),""String_Node_Str"");
          }
          TraceExpressionInformationHolder traceExpressionData=(TraceExpressionInformationHolder)traceExpressionDataTable.get(variableName.trim());
          if (traceExpressionData != null) {
            if (!nextStateNewTrace.isBackToState() && !nextStateNewTrace.isStuttering() && traceExpressionData.getLevel() == 2) {
              currentStateNewTraceVariables[i].setValue(nextStateNewTraceVariables[i].getValue());
            }
            currentStateNewTraceVariables[i].setName(traceExpressionData.getExpression());
            currentStateNewTraceVariables[i].setTraceExplorerVar(true);
          }
        }
        Arrays.sort(currentStateNewTraceVariables,varComparator);
        currentStateNewTrace=nextStateNewTrace;
        currentStateOriginalTrace=(TLCState)originalTraceIt.next();
      }
      if ((currentStateOriginalTrace.isBackToState() || currentStateOriginalTrace.isStuttering()) && newTrace.size() >= originalTrace.size()) {
        newTrace.subList(originalTrace.size() - 1,newTrace.size()).clear();
      }
      Assert.isTrue(newTrace.size() <= originalTrace.size(),""String_Node_Str"");
      TLCState finalStateOriginalTrace=(TLCState)originalTrace.get(originalTrace.size() - 1);
      if (newTrace.size() < originalTrace.size() - 1 || (!finalStateOriginalTrace.isStuttering() && !finalStateOriginalTrace.isBackToState())) {
        TLCState finalStateNewTrace=(TLCState)newTrace.get(newTrace.size() - 1);
        TLCState samePositionOriginalTrace=(TLCState)originalTrace.get(newTrace.size() - 1);
        finalStateNewTrace.setLabel(samePositionOriginalTrace.getLabel());
        finalStateNewTrace.setLocation(samePositionOriginalTrace.getModuleLocation());
        TLCVariable[] finalStateNewTraceVariables=finalStateNewTrace.getVariables();
        for (int i=0; i < finalStateNewTraceVariables.length; i++) {
          TraceExpressionInformationHolder traceExpressionData=(TraceExpressionInformationHolder)traceExpressionDataTable.get(finalStateNewTraceVariables[i].getName().trim());
          if (traceExpressionData != null) {
            if (traceExpressionData.getLevel() == 2) {
              finalStateNewTraceVariables[i].setValue(TLCVariableValue.parseValue(""String_Node_Str""));
            }
            finalStateNewTraceVariables[i].setName(traceExpressionData.getExpression());
            finalStateNewTraceVariables[i].setTraceExplorerVar(true);
          }
        }
        Arrays.sort(finalStateNewTraceVariables,varComparator);
      }
 else       if (finalStateOriginalTrace.isBackToState()) {
        error.addState(TLCState.BACK_TO_STATE(finalStateOriginalTrace.getStateNumber(),ModelHelper.getModelName(getConfig().getFile())));
      }
 else {
        error.addState(TLCState.STUTTERING_STATE(finalStateOriginalTrace.getStateNumber(),ModelHelper.getModelName(getConfig().getFile())));
      }
    }
 else {
      error.setMessage(TE_ERROR_HEADER + error.getMessage());
    }
  }
  if (successfulTEError != null) {
    List originalErrors=TLCOutputSourceRegistry.getModelCheckSourceRegistry().getProvider(getConfig()).getErrors();
    List newErrors=new LinkedList();
    Iterator iterator=originalErrors.iterator();
    while (iterator.hasNext()) {
      Object next=iterator.next();
      if (next == originalErrorWithTrace) {
        newErrors.add(successfulTEError);
      }
 else {
        newErrors.add(next);
      }
    }
    setErrors(newErrors);
  }
}",0.9373533955031752
135939,"/** 
 * Creates a new   {@link WarningMessage} from the {@link Set}of   {@link Entry} where the key of each {@link Entry} is the fieldname and the value is the field value string as output by the TLAPM. This method expects the only field to have the name ""msg"".
 * @param fieldPairs
 * @param moduleName
 * @return
 */
public static WarningMessage getWarningMessage(Set fieldPairs,String moduleName){
  WarningMessage message=new WarningMessage();
  for (Iterator it=fieldPairs.iterator(); it.hasNext(); ) {
    Map.Entry nextEntry=(Map.Entry)it.next();
    String fieldName=(String)nextEntry.getKey();
    String fieldValue=(String)nextEntry.getValue();
    if (fieldName != null && fieldValue != null) {
      if (fieldName.equals(LOC_FIELD)) {
        message.message=fieldValue;
      }
 else {
        ProverUIActivator.logDebug(""String_Node_Str"" + fieldName + ""String_Node_Str"");
      }
    }
  }
  return message;
}","/** 
 * Creates a new   {@link WarningMessage} from the {@link Set}of   {@link Entry} where the key of each {@link Entry} is the fieldname and the value is the field value string as output by the TLAPM. This method expects the only field to have the name ""msg"".
 * @param fieldPairs
 * @param moduleName
 * @return
 */
public static WarningMessage getWarningMessage(Set fieldPairs,String moduleName){
  WarningMessage message=new WarningMessage();
  for (Iterator it=fieldPairs.iterator(); it.hasNext(); ) {
    Map.Entry nextEntry=(Map.Entry)it.next();
    String fieldName=(String)nextEntry.getKey();
    String fieldValue=(String)nextEntry.getValue();
    if (fieldName != null && fieldValue != null) {
      if (fieldName.equals(MSG_FIELD)) {
        message.message=fieldValue;
      }
 else {
        ProverUIActivator.logDebug(""String_Node_Str"" + fieldName + ""String_Node_Str"");
      }
    }
  }
  return message;
}",0.9967497291440952
135940,"public void run(IProgressMonitor monitor) throws CoreException {
  Position curPosition=EditorUtil.getMarkerPosition(sanyMarker);
  int newCharStart;
  int newCharEnd;
  if (curPosition != null) {
    newCharStart=curPosition.getOffset();
    newCharEnd=curPosition.getOffset() + curPosition.getLength();
  }
 else {
    newCharStart=sanyMarker.getAttribute(IMarker.CHAR_START,0);
    newCharEnd=sanyMarker.getAttribute(IMarker.CHAR_END,0);
  }
  IMarker[] existingMarkers=module.findMarkers(ProverHelper.STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
  for (int i=0; i < existingMarkers.length; i++) {
    IMarker existingMarker=existingMarkers[i];
    int existingCharStart=existingMarker.getAttribute(IMarker.CHAR_START,-1);
    int existingCharEnd=existingMarker.getAttribute(IMarker.CHAR_END,-1);
    if (existingCharStart < newCharEnd && existingCharEnd > newCharStart) {
      existingMarker.delete();
    }
  }
  if (markerType != null) {
    Map markerAttributes=new HashMap(2);
    markerAttributes.put(IMarker.CHAR_START,new Integer(newCharStart));
    markerAttributes.put(IMarker.CHAR_END,new Integer(newCharEnd));
    markerAttributes.put(IMarker.LINE_NUMBER,new Integer(stringToLoc(sanyMarker.getAttribute(SANY_LOC_ATR,""String_Node_Str"")).beginLine()));
    IMarker newMarker=module.createMarker(markerType);
    newMarker.setAttributes(markerAttributes);
  }
}","public void run(){
  MessageDialog.openWarning(UIHelper.getShellProvider().getShell(),""String_Node_Str"",message.getMessage());
}",0.113031914893617
135941,"/** 
 * Processes a warning message from the tlapm. This simply displays a warning to the user.
 * @param message
 */
public static void processWarningMessage(WarningMessage message){
  MessageDialog.openWarning(UIHelper.getShellProvider().getShell(),""String_Node_Str"",message.getMessage());
}","/** 
 * Processes a warning message from the tlapm. This simply displays a warning to the user.
 * @param message
 */
public static void processWarningMessage(final WarningMessage message){
  UIHelper.runUIAsync(new Runnable(){
    public void run(){
      MessageDialog.openWarning(UIHelper.getShellProvider().getShell(),""String_Node_Str"",message.getMessage());
    }
  }
);
}",0.7970149253731343
135942,"/** 
 * Updates the obligation with information from the message. In particular, this updates the state of the obligation and set the pretty printed form of the obligation if that information is in the message. If the state of this obligation changes because of the message, this method updates the status of the parent.
 * @param message
 */
public void updateObligation(ObligationStatusMessage message){
  this.obligationString=message.getObString();
  if (message.getBackend() != null && message.getStatus() != null) {
    proverStatuses.put(message.getBackend(),message.getStatus());
  }
  int oldState=getObligationState();
  int newState=ProverHelper.getIntFromStringStatus(message.getStatus(),oldState,message.getBackend());
  if (oldState != newState) {
    obState=newState;
    parent.updateStatus();
  }
}","/** 
 * Updates the obligation with information from the message. In particular, this updates the state of the obligation and set the pretty printed form of the obligation if that information is in the message. If the state of this obligation changes because of the message, this method updates the status of the parent.
 * @param message
 */
public void updateObligation(ObligationStatusMessage message){
  if (this.obligationString == null || this.obligationString.isEmpty()) {
    this.obligationString=message.getObString();
  }
  if (message.getBackend() != null && message.getStatus() != null) {
    proverStatuses.put(message.getBackend(),message.getStatus());
  }
  int oldState=getObligationState();
  int newState=ProverHelper.getIntFromStringStatus(message.getStatus(),oldState,message.getBackend());
  if (oldState != newState) {
    obState=newState;
    parent.updateStatus();
  }
}",0.9287383177570092
135943,"/** 
 * Adds the information from the obligation status to the view. If there is already an item with information of the same obligation as the status, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(ObligationStatus status){
  int id=status.getId();
  if (id != -1) {
    InterestingObligationExpandItem item=(InterestingObligationExpandItem)items.get(new Integer(id));
    if (!ProverHelper.isInterestingObligation(status)) {
      if (item != null) {
        removeItem(item);
      }
      return;
    }
    if (item == null) {
      item=new InterestingObligationExpandItem(bar,SWT.None,0,id);
      ;
      Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
      GridLayout gl=new GridLayout(1,true);
      gl.marginWidth=0;
      gl.marginHeight=0;
      oblWidget.setLayout(gl);
      Button stopButton=new Button(oblWidget,SWT.PUSH);
      stopButton.setText(""String_Node_Str"");
      stopButton.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
      stopButton.setData(status.getObMarker());
      stopButton.addSelectionListener(stopObListener);
      item.setButton(stopButton);
      SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
      viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
      viewer.configure(new ObligationSourceViewerConfiguration());
      viewer.getControl().setFont(JFaceResources.getTextFont());
      fontListener.addControl(viewer.getControl());
      viewers.put(item,viewer);
      item.setControl(oblWidget);
      item.setExpanded(true);
      item.setData(status.getObMarker());
      viewer.getTextWidget().setData(status.getObMarker());
      oblWidget.setData(status.getObMarker());
      item.addListener(SWT.MouseDown,obClickListener);
      viewer.getTextWidget().addListener(SWT.MouseDown,obClickListener);
      oblWidget.addListener(SWT.MouseDown,obClickListener);
      items.put(new Integer(id),item);
    }
    item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status.getProverStatusString());
    item.getButton().setEnabled(ProverHelper.isBeingProvedObligation(status));
    SourceViewer viewer=(SourceViewer)viewers.get(item);
    Assert.isNotNull(viewer,""String_Node_Str"");
    String oblString=status.getObligationString();
    if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !oblString.isEmpty()) {
      viewer.setDocument(new Document(oblString.trim()));
      item.setHeight(item.getControl().computeSize(SWT.DEFAULT,SWT.DEFAULT,true).y);
    }
 else     if (oblString.isEmpty() && (viewer.getDocument() == null || viewer.getDocument().get().isEmpty())) {
      viewer.setDocument(new Document(""String_Node_Str""));
      item.setHeight(100);
    }
  }
}","/** 
 * Adds the information from the obligation status to the view. If there is already an item with information of the same obligation as the status, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(ObligationStatus status){
  int id=status.getId();
  if (id != -1) {
    InterestingObligationExpandItem item=(InterestingObligationExpandItem)items.get(new Integer(id));
    if (!ProverHelper.isInterestingObligation(status)) {
      if (item != null) {
        removeItem(item);
      }
      return;
    }
    if (item == null) {
      item=new InterestingObligationExpandItem(bar,SWT.None,0,id);
      ;
      Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
      GridLayout gl=new GridLayout(1,true);
      gl.marginWidth=0;
      gl.marginHeight=0;
      oblWidget.setLayout(gl);
      Button stopButton=new Button(oblWidget,SWT.PUSH);
      stopButton.setText(""String_Node_Str"");
      stopButton.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
      stopButton.setData(status.getObMarker());
      stopButton.addSelectionListener(stopObListener);
      item.setButton(stopButton);
      SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
      viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
      viewer.configure(new ObligationSourceViewerConfiguration());
      viewer.getControl().setFont(JFaceResources.getTextFont());
      fontListener.addControl(viewer.getControl());
      viewers.put(item,viewer);
      item.setControl(oblWidget);
      item.setExpanded(true);
      item.setData(status.getObMarker());
      viewer.getTextWidget().setData(status.getObMarker());
      oblWidget.setData(status.getObMarker());
      item.addListener(SWT.MouseDown,obClickListener);
      viewer.getTextWidget().addListener(SWT.MouseDown,obClickListener);
      oblWidget.addListener(SWT.MouseDown,obClickListener);
      items.put(new Integer(id),item);
    }
    item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status.getProverStatusString());
    item.getButton().setEnabled(ProverHelper.isBeingProvedObligation(status));
    SourceViewer viewer=(SourceViewer)viewers.get(item);
    Assert.isNotNull(viewer,""String_Node_Str"");
    String oblString=status.getObligationString();
    Assert.isNotNull(oblString,""String_Node_Str"" + status);
    if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !oblString.isEmpty()) {
      viewer.setDocument(new Document(oblString.trim()));
      item.setHeight(item.getControl().computeSize(SWT.DEFAULT,SWT.DEFAULT,true).y);
    }
 else     if (oblString.isEmpty() && (viewer.getDocument() == null || viewer.getDocument().get().isEmpty())) {
      viewer.setDocument(new Document(""String_Node_Str""));
      item.setHeight(100);
    }
  }
}",0.9894142554693014
135944,"public void setEnabled(Object context){
  setBaseEnabled(setFields());
  resetFields();
}","public void setEnabled(Object context){
  setBaseEnabled(setFields(false));
}",0.8674698795180723
135945,"private boolean setFields(){
  TLAEditor editor;
  editor=EditorUtil.getTLAEditorWithFocus();
  if (editor == null) {
    return false;
  }
  doc=editor.getDocumentProvider().getDocument(editor.getEditorInput());
  text=doc.get();
  selectionProvider=editor.getSelectionProvider();
  selection=(TextSelection)selectionProvider.getSelection();
  node=EditorUtil.getCurrentTheoremNode();
  if (node == null) {
    return false;
  }
  ProofNode pf=node.getProof();
  if (pf instanceof NonLeafProofNode) {
    pfNode=(NonLeafProofNode)pf;
  }
 else {
    pfNode=null;
    return false;
  }
  return true;
}","private boolean setFields(boolean reallySet){
  TLAEditor editor;
  editor=EditorUtil.getTLAEditorWithFocus();
  if (editor == null) {
    return false;
  }
  IDocument doc=editor.getDocumentProvider().getDocument(editor.getEditorInput());
  String text=doc.get();
  ISelectionProvider selectionProvider=editor.getSelectionProvider();
  TextSelection selection=(TextSelection)selectionProvider.getSelection();
  TheoremNode node=EditorUtil.getCurrentTheoremNode();
  if (node == null) {
    return false;
  }
  ProofNode pf=node.getProof();
  if (pf instanceof NonLeafProofNode) {
    pfNode=(NonLeafProofNode)pf;
  }
 else {
    return false;
  }
  if (reallySet) {
    this.doc=doc;
    this.text=text;
    this.selectionProvider=selectionProvider;
    this.selection=selection;
    this.node=node;
  }
  return true;
}",0.7308503162333099
135946,"public Object execute(ExecutionEvent event) throws ExecutionException {
  if (!setFields()) {
    return null;
  }
  try {
    Location stepLoc=null;
    LevelNode[] steps=pfNode.getSteps();
    ArrayList replace=new ArrayList(15);
    int stepNumber=1;
    for (int i=0; i < steps.length; i++) {
      UniqueString uname=null;
      if (steps[i] instanceof TheoremNode) {
        ProofNode stepPf=((TheoremNode)steps[i]).getProof();
        if ((stepPf != null) && (stepPf instanceof LeafProofNode)) {
          Location leafPfLoc=stepPf.getLocation();
          stepLoc=leafPfLoc;
          IRegion ir=AdapterFactory.locationToRegion(doc,leafPfLoc);
          String leafPfStr=doc.get(ir.getOffset(),ir.getLength());
          if (leafPfStr.indexOf(""String_Node_Str"") > -1) {
            displayRenumberError(""String_Node_Str"");
            return null;
          }
        }
        uname=((TheoremNode)steps[i]).getName();
      }
 else       if (steps[i] instanceof DefStepNode) {
        uname=((DefStepNode)steps[i]).getStepNumber();
      }
 else       if (steps[i] instanceof UseOrHideNode) {
        uname=((UseOrHideNode)steps[i]).getStepName();
      }
 else       if (steps[i] instanceof InstanceNode) {
        uname=((InstanceNode)steps[i]).getStepName();
      }
      if (uname != null) {
        String oldName=uname.toString();
        String newName=oldName.substring(0,oldName.indexOf('>') + 1) + stepNumber;
        stepNumber++;
        replace.add(new StringReplacement(oldName,newName));
      }
    }
    StringReplacement[] replaceArray=new StringReplacement[replace.size()];
    for (int i=0; i < replaceArray.length; i++) {
      replaceArray[i]=(StringReplacement)replace.get(i);
    }
    Arrays.sort(replaceArray);
    IRegion pfRegion=AdapterFactory.locationToRegion(doc,pfNode.getLocation());
    int startRegion=pfRegion.getOffset();
    int endRegion=startRegion + pfRegion.getLength();
    ArrayList replacementOffsets=new ArrayList(40);
    for (int i=0; i < replaceArray.length; i++) {
      int searchFrom=startRegion;
      int nextInsert=0;
      boolean done=false;
      String oldString=replaceArray[i].oldStr;
      while (!done) {
        int nextFound=text.indexOf(oldString,searchFrom);
        if ((nextFound == -1) || !(nextFound < endRegion)) {
          done=true;
        }
 else {
          while ((nextInsert < replacementOffsets.size()) && (((IntPair)replacementOffsets.get(nextInsert)).one < nextFound)) {
            nextInsert++;
          }
          if ((nextInsert == replacementOffsets.size()) || (((IntPair)replacementOffsets.get(nextInsert)).one != nextFound)) {
            replacementOffsets.add(nextInsert,new IntPair(nextFound,i));
            nextInsert++;
          }
          searchFrom=nextFound + 1;
        }
      }
    }
    for (int i=replacementOffsets.size() - 1; i > -1; i--) {
      IntPair pair=(IntPair)replacementOffsets.get(i);
      StringReplacement rep=replaceArray[pair.two];
      doc.replace(pair.one,rep.oldStr.length(),rep.newStr);
    }
  }
 catch (  BadLocationException e) {
  }
  resetFields();
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  if (!setFields(true)) {
    return null;
  }
  try {
    Location stepLoc=null;
    LevelNode[] steps=pfNode.getSteps();
    ArrayList replace=new ArrayList(15);
    int stepNumber=1;
    for (int i=0; i < steps.length; i++) {
      UniqueString uname=null;
      if (steps[i] instanceof TheoremNode) {
        ProofNode stepPf=((TheoremNode)steps[i]).getProof();
        if ((stepPf != null) && (stepPf instanceof LeafProofNode)) {
          Location leafPfLoc=stepPf.getLocation();
          stepLoc=leafPfLoc;
          IRegion ir=AdapterFactory.locationToRegion(doc,leafPfLoc);
          String leafPfStr=doc.get(ir.getOffset(),ir.getLength());
          if (leafPfStr.indexOf(""String_Node_Str"") > -1) {
            displayRenumberError(""String_Node_Str"");
            return null;
          }
        }
        uname=((TheoremNode)steps[i]).getName();
      }
 else       if (steps[i] instanceof DefStepNode) {
        uname=((DefStepNode)steps[i]).getStepNumber();
      }
 else       if (steps[i] instanceof UseOrHideNode) {
        uname=((UseOrHideNode)steps[i]).getStepName();
      }
 else       if (steps[i] instanceof InstanceNode) {
        uname=((InstanceNode)steps[i]).getStepName();
      }
      if (uname != null) {
        String oldName=uname.toString();
        String newName=oldName.substring(0,oldName.indexOf('>') + 1) + stepNumber;
        stepNumber++;
        replace.add(new StringReplacement(oldName,newName));
      }
    }
    StringReplacement[] replaceArray=new StringReplacement[replace.size()];
    for (int i=0; i < replaceArray.length; i++) {
      replaceArray[i]=(StringReplacement)replace.get(i);
    }
    Arrays.sort(replaceArray);
    IRegion pfRegion=AdapterFactory.locationToRegion(doc,pfNode.getLocation());
    int startRegion=pfRegion.getOffset();
    int endRegion=startRegion + pfRegion.getLength();
    ArrayList replacementOffsets=new ArrayList(40);
    for (int i=0; i < replaceArray.length; i++) {
      int searchFrom=startRegion;
      int nextInsert=0;
      boolean done=false;
      String oldString=replaceArray[i].oldStr;
      while (!done) {
        int nextFound=text.indexOf(oldString,searchFrom);
        if ((nextFound == -1) || !(nextFound < endRegion)) {
          done=true;
        }
 else {
          while ((nextInsert < replacementOffsets.size()) && (((IntPair)replacementOffsets.get(nextInsert)).one < nextFound)) {
            nextInsert++;
          }
          if ((nextInsert == replacementOffsets.size()) || (((IntPair)replacementOffsets.get(nextInsert)).one != nextFound)) {
            replacementOffsets.add(nextInsert,new IntPair(nextFound,i));
            nextInsert++;
          }
          searchFrom=nextFound + 1;
        }
      }
    }
    for (int i=replacementOffsets.size() - 1; i > -1; i--) {
      IntPair pair=(IntPair)replacementOffsets.get(i);
      StringReplacement rep=replaceArray[pair.two];
      doc.replace(pair.one,rep.oldStr.length(),rep.newStr);
    }
  }
 catch (  BadLocationException e) {
  }
  resetFields();
  return null;
}",0.9993575329264376
135947,"/** 
 * Returns the   {@link IMarker} containing attributes about theobligation. The attributes {@link ProverHelper#OBLIGATION_ID}should always be present. However, for dummy missing and omitted obligations, the id is meaningless.
 * @return
 */
public IMarker getObMarker(){
  return obMarker;
}","/** 
 * Returns the   {@link IMarker} containing attributes about theobligation. The attributes {@link ProverHelper#OBLIGATION_ID}should always be present. This marker will be null for dummy obligations.
 * @return
 */
public IMarker getObMarker(){
  return obMarker;
}",0.8353982300884956
135948,"/** 
 * Create an obligation with the parent step, the marker for the obligation, and initial state. The parent step can be null if the parent is to be set later using  {@link #setParent(StepTuple)}. Calls   {@link #setState(long)} on the initialState
 * @param parent the parent step of the obligation. Can be nullif the parent is to be set later using  {@link #setParent(StepTuple)}.
 * @param obMarker the marker for this obligationwhich should already have the attributes {@link ProverHelper#OBLIGATION_ID} set.
 * @param initialState the initial state of the obligation. See{@link ColorPredicate} for an explanation of obligation states.
 * @param location the location of the obligation as reported by tlapm
 * @param id the id of the obligation as given by tlapm
 */
public ObligationStatus(StepTuple parent,IMarker obMarker,int initialState,Location location,int id){
  this.parent=parent;
  this.proverStatuses=new HashMap();
  this.obState=initialState;
  this.id=id;
  this.location=location;
}","/** 
 * Create an obligation with the parent step, the marker for the obligation, and initial state. The parent step can be null if the parent is to be set later using  {@link #setParent(StepTuple)}. Calls   {@link #setState(long)} on the initialState
 * @param parent the parent step of the obligation. Can be nullif the parent is to be set later using  {@link #setParent(StepTuple)}.
 * @param obMarker the marker for this obligationwhich should already have the attributes {@link ProverHelper#OBLIGATION_ID} set. Can be null if thisis a dummy obligation because the marker is never used.
 * @param initialState the initial state of the obligation. See{@link ColorPredicate} for an explanation of obligation states.
 * @param location the location of the obligation as reported by tlapm
 * @param id the id of the obligation as given by tlapm
 */
public ObligationStatus(StepTuple parent,IMarker obMarker,int initialState,Location location,int id){
  this.parent=parent;
  this.proverStatuses=new HashMap();
  this.obState=initialState;
  this.id=id;
  this.location=location;
  this.obMarker=obMarker;
}",0.9521553765987684
135949,"/** 
 * Process the obligation message. If the status of the message is not  {@link #TO_BE_PROVED} then it creates a marker for that obligationby calling  {@link #createObligationMarker(ObligationStatusMessage)}. Else, it prepares the necessary data structure for computing proof step statuses. The proverJob is the instance of   {@link ProverJob} used to launch the proverand passed to listeners of TLAPM output for that launch. It provides access to information about launch parameters and other useful data structures.
 * @param message
 * @param nodeToProve the step or module on which the prover was launched
 */
public static void processObligationMessage(ObligationStatusMessage message,final ProverJob proverJob){
  if (message.getStatus().equals(TO_BE_PROVED)) {
    if (proverJob.noToBeProved) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      proverJob.noToBeProved=false;
    }
    proverJob.getObMessageList().add(message);
  }
 else {
    if (proverJob.isToBeProvedOnly()) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      IWorkspaceRunnable runnable=new IWorkspaceRunnable(){
        public void run(        IProgressMonitor monitor) throws CoreException {
          for (Iterator it=proverJob.getObMessageList().iterator(); it.hasNext(); ) {
            ObligationStatusMessage message=(ObligationStatusMessage)it.next();
            IMarker obMarker=createObligationMarker(message.getID(),message.getLocation());
            ObligationStatus obStatus=new ObligationStatus(null,obMarker,ColorPredicate.TO_BE_PROVED_STATE,message.getLocation(),0);
            proverJob.getObsMap().put(new Integer(message.getID()),obStatus);
          }
        }
      }
;
      try {
        proverJob.module.getWorkspace().run(runnable,null,IWorkspace.AVOID_UPDATE,null);
      }
 catch (      CoreException e) {
        ProverUIActivator.logError(""String_Node_Str"",e);
      }
      proverJob.setToBeProvedOnly(false);
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
    }
    final ObligationStatus obStatus=(ObligationStatus)proverJob.getObsMap().get(new Integer(message.getID()));
    if (obStatus.getParent() == null) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      for (Iterator it=proverJob.getObs().iterator(); it.hasNext(); ) {
        ObligationStatus obligation=(ObligationStatus)it.next();
        int searchLine=obligation.getTLAPMLocation().beginLine();
        while (true) {
          StepTuple stepTuple=(StepTuple)proverJob.getLeafStepMap().get(new Integer(searchLine));
          if (stepTuple != null) {
            obligation.setParent(stepTuple);
            stepTuple.addChild(obligation);
            break;
          }
          searchLine--;
        }
      }
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
    }
    obStatus.updateObligation(message);
    UIHelper.runUIAsync(new Runnable(){
      public void run(){
        ObligationsView.updateObligationView(obStatus);
      }
    }
);
  }
}","/** 
 * Process the obligation message. If the status of the message is not  {@link #TO_BE_PROVED} then it creates a marker for that obligationby calling  {@link #createObligationMarker(ObligationStatusMessage)}. Else, it prepares the necessary data structure for computing proof step statuses. The proverJob is the instance of   {@link ProverJob} used to launch the proverand passed to listeners of TLAPM output for that launch. It provides access to information about launch parameters and other useful data structures.
 * @param message
 * @param nodeToProve the step or module on which the prover was launched
 */
public static void processObligationMessage(ObligationStatusMessage message,final ProverJob proverJob){
  if (message.getStatus().equals(TO_BE_PROVED)) {
    if (proverJob.noToBeProved) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      proverJob.noToBeProved=false;
    }
    proverJob.getObMessageList().add(message);
  }
 else {
    if (proverJob.isToBeProvedOnly()) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      IWorkspaceRunnable runnable=new IWorkspaceRunnable(){
        public void run(        IProgressMonitor monitor) throws CoreException {
          for (Iterator it=proverJob.getObMessageList().iterator(); it.hasNext(); ) {
            ObligationStatusMessage message=(ObligationStatusMessage)it.next();
            IMarker obMarker=createObligationMarker(message.getID(),message.getLocation());
            ObligationStatus obStatus=new ObligationStatus(null,obMarker,ColorPredicate.TO_BE_PROVED_STATE,message.getLocation(),message.getID());
            proverJob.getObsMap().put(new Integer(message.getID()),obStatus);
          }
        }
      }
;
      try {
        proverJob.module.getWorkspace().run(runnable,null,IWorkspace.AVOID_UPDATE,null);
      }
 catch (      CoreException e) {
        ProverUIActivator.logError(""String_Node_Str"",e);
      }
      proverJob.setToBeProvedOnly(false);
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
    }
    final ObligationStatus obStatus=(ObligationStatus)proverJob.getObsMap().get(new Integer(message.getID()));
    if (obStatus.getParent() == null) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      for (Iterator it=proverJob.getObs().iterator(); it.hasNext(); ) {
        ObligationStatus obligation=(ObligationStatus)it.next();
        int searchLine=obligation.getTLAPMLocation().beginLine();
        while (true) {
          StepTuple stepTuple=(StepTuple)proverJob.getLeafStepMap().get(new Integer(searchLine));
          if (stepTuple != null) {
            obligation.setParent(stepTuple);
            stepTuple.addChild(obligation);
            break;
          }
          searchLine--;
        }
      }
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
    }
    obStatus.updateObligation(message);
    UIHelper.runUIAsync(new Runnable(){
      public void run(){
        ObligationsView.updateObligationView(obStatus);
      }
    }
);
  }
}",0.9974042829331604
135950,"/** 
 * Creates a SANY marker for levelNode if it is a   {@link TheoremNode} or a {@link UseOrHideNode}. If it has a proof, this method recursively calls it self on all children. The SANY location attribute for these markers is a string representation of the location of the node if it is a   {@link UseOrHideNode} and the string representation of the location of the node{@link TheoremNode#getTheorem()} if it is a {@link TheoremNode}. The methods   {@link #locToString(Location)} and {@link #stringToLoc(String)} convert from{@link Location} to Strings and back.See  {@link ProverHelper#SANY_MARKER} for a description ofthese markers. Creates and returns the  {@link StepTuple} for levelNode if levelNode is an instance of{@link UseOrHideNode} or {@link TheoremNode}. Sets the marker for this tuple. Returns null otherwise. If levelNode is a   {@link TheoremNode} then it sets levelNodeas the parent of all non-null  {@link StepTuple}s returned by calling this method on its children. The proverJob is the instance of   {@link ProverJob} used to launch the proverand passed to listeners of TLAPM output for that launch. It provides access to information about launch parameters and other useful data structures.
 * @param theoremNode
 * @throws CoreException 
 */
public static StepTuple prepareTreeForProverLaunch(LevelNode levelNode,IResource module,ProverJob proverJob) throws CoreException {
  if (levelNode == null) {
    return null;
  }
  if (levelNode instanceof UseOrHideNode || levelNode instanceof TheoremNode) {
    IMarker marker=module.createMarker(SANY_MARKER);
    Location locForAttr;
    if (levelNode instanceof UseOrHideNode) {
      locForAttr=levelNode.getLocation();
    }
 else {
      TheoremNode theoremNode=(TheoremNode)levelNode;
      Location beginLoc=theoremNode.getLocation();
      Location statementLoc=theoremNode.getTheorem().getLocation();
      locForAttr=new Location(UniqueString.uniqueStringOf(statementLoc.source()),beginLoc.beginLine(),beginLoc.beginColumn(),statementLoc.endLine(),statementLoc.endColumn());
    }
    marker.setAttribute(SANY_LOC_ATR,locToString(locForAttr));
    IRegion locRegion=AdapterFactory.locationToRegion(locForAttr);
    marker.setAttribute(IMarker.CHAR_START,locRegion.getOffset());
    marker.setAttribute(IMarker.CHAR_END,locRegion.getOffset() + locRegion.getLength());
    StepTuple stepTuple=new StepTuple(proverJob);
    stepTuple.setSanyMarker(marker);
    if (levelNode instanceof TheoremNode) {
      TheoremNode theoremNode=(TheoremNode)levelNode;
      ProofNode proof=theoremNode.getProof();
      if (proof != null) {
        if (proof instanceof NonLeafProofNode) {
          NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
          LevelNode[] steps=nonLeafProof.getSteps();
          marker.setAttribute(SANY_IS_LEAF_ATR,steps.length == 0);
          for (int i=0; i < steps.length; i++) {
            StepTuple childTuple=prepareTreeForProverLaunch(steps[i],module,proverJob);
            if (childTuple != null) {
              childTuple.setParent(stepTuple);
              stepTuple.addChild(childTuple);
            }
          }
        }
 else {
          marker.setAttribute(SANY_IS_LEAF_ATR,true);
          LeafProofNode leafProof=(LeafProofNode)proof;
          if (leafProof.getOmitted()) {
            stepTuple.addChild(new ObligationStatus(stepTuple,createObligationMarker(-1,theoremNode.getLocation()),ColorPredicate.NUMBER_OF_OMITTED_STATE,theoremNode.getLocation(),0));
          }
        }
      }
 else {
        marker.setAttribute(SANY_IS_LEAF_ATR,true);
        LevelNode assertion=theoremNode.getTheorem();
        boolean shouldHaveProof=true;
        if (assertion instanceof OpApplNode) {
          OpApplNode opApplAss=(OpApplNode)assertion;
          String name=opApplAss.getOperator().getName().toString();
          if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str""))           shouldHaveProof=false;
        }
        if (shouldHaveProof) {
          stepTuple.addChild(new ObligationStatus(stepTuple,createObligationMarker(-1,theoremNode.getLocation()),ColorPredicate.NUMBER_OF_MISSING_STATE,theoremNode.getLocation(),0));
        }
      }
    }
 else {
      marker.setAttribute(SANY_IS_LEAF_ATR,true);
    }
    if (marker.getAttribute(SANY_IS_LEAF_ATR,false)) {
      proverJob.getLeafStepMap().put(new Integer(locForAttr.beginLine()),stepTuple);
    }
    return stepTuple;
  }
  return null;
}","/** 
 * Creates a SANY marker for levelNode if it is a   {@link TheoremNode} or a {@link UseOrHideNode}. If it has a proof, this method recursively calls it self on all children. The SANY location attribute for these markers is a string representation of the location of the node if it is a   {@link UseOrHideNode} and the string representation of the location of the node{@link TheoremNode#getTheorem()} if it is a {@link TheoremNode}. The methods   {@link #locToString(Location)} and {@link #stringToLoc(String)} convert from{@link Location} to Strings and back.See  {@link ProverHelper#SANY_MARKER} for a description ofthese markers. Creates and returns the  {@link StepTuple} for levelNode if levelNode is an instance of{@link UseOrHideNode} or {@link TheoremNode}. Sets the marker for this tuple. Returns null otherwise. If levelNode is a   {@link TheoremNode} then it sets levelNodeas the parent of all non-null  {@link StepTuple}s returned by calling this method on its children. The proverJob is the instance of   {@link ProverJob} used to launch the proverand passed to listeners of TLAPM output for that launch. It provides access to information about launch parameters and other useful data structures.
 * @param theoremNode
 * @throws CoreException 
 */
public static StepTuple prepareTreeForProverLaunch(LevelNode levelNode,IResource module,ProverJob proverJob) throws CoreException {
  if (levelNode == null) {
    return null;
  }
  if (levelNode instanceof UseOrHideNode || levelNode instanceof TheoremNode) {
    IMarker marker=module.createMarker(SANY_MARKER);
    Location locForAttr;
    if (levelNode instanceof UseOrHideNode) {
      locForAttr=levelNode.getLocation();
    }
 else {
      TheoremNode theoremNode=(TheoremNode)levelNode;
      Location beginLoc=theoremNode.getLocation();
      Location statementLoc=theoremNode.getTheorem().getLocation();
      locForAttr=new Location(UniqueString.uniqueStringOf(statementLoc.source()),beginLoc.beginLine(),beginLoc.beginColumn(),statementLoc.endLine(),statementLoc.endColumn());
    }
    marker.setAttribute(SANY_LOC_ATR,locToString(locForAttr));
    IRegion locRegion=AdapterFactory.locationToRegion(locForAttr);
    marker.setAttribute(IMarker.CHAR_START,locRegion.getOffset());
    marker.setAttribute(IMarker.CHAR_END,locRegion.getOffset() + locRegion.getLength());
    StepTuple stepTuple=new StepTuple(proverJob);
    stepTuple.setSanyMarker(marker);
    if (levelNode instanceof TheoremNode) {
      TheoremNode theoremNode=(TheoremNode)levelNode;
      ProofNode proof=theoremNode.getProof();
      if (proof != null) {
        if (proof instanceof NonLeafProofNode) {
          NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
          LevelNode[] steps=nonLeafProof.getSteps();
          marker.setAttribute(SANY_IS_LEAF_ATR,steps.length == 0);
          for (int i=0; i < steps.length; i++) {
            StepTuple childTuple=prepareTreeForProverLaunch(steps[i],module,proverJob);
            if (childTuple != null) {
              childTuple.setParent(stepTuple);
              stepTuple.addChild(childTuple);
            }
          }
        }
 else {
          marker.setAttribute(SANY_IS_LEAF_ATR,true);
          LeafProofNode leafProof=(LeafProofNode)proof;
          if (leafProof.getOmitted()) {
            stepTuple.addChild(new ObligationStatus(stepTuple,createObligationMarker(-1,theoremNode.getLocation()),ColorPredicate.NUMBER_OF_OMITTED_STATE,theoremNode.getLocation(),-1));
          }
        }
      }
 else {
        marker.setAttribute(SANY_IS_LEAF_ATR,true);
        LevelNode assertion=theoremNode.getTheorem();
        boolean shouldHaveProof=true;
        if (assertion instanceof OpApplNode) {
          OpApplNode opApplAss=(OpApplNode)assertion;
          String name=opApplAss.getOperator().getName().toString();
          if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str""))           shouldHaveProof=false;
        }
        if (shouldHaveProof) {
          stepTuple.addChild(new ObligationStatus(stepTuple,createObligationMarker(-1,theoremNode.getLocation()),ColorPredicate.NUMBER_OF_MISSING_STATE,theoremNode.getLocation(),-1));
        }
      }
    }
 else {
      marker.setAttribute(SANY_IS_LEAF_ATR,true);
    }
    if (marker.getAttribute(SANY_IS_LEAF_ATR,false)) {
      proverJob.getLeafStepMap().put(new Integer(locForAttr.beginLine()),stepTuple);
    }
    return stepTuple;
  }
  return null;
}",0.9993309545049064
135951,"/** 
 * Process the obligation message. If the status of the message is not  {@link #TO_BE_PROVED} then it creates a marker for that obligationby calling  {@link #createObligationMarker(ObligationStatusMessage)}. Else, it prepares the necessary data structure for computing proof step statuses. The proverJob is the instance of   {@link ProverJob} used to launch the proverand passed to listeners of TLAPM output for that launch. It provides access to information about launch parameters and other useful data structures.
 * @param message
 * @param nodeToProve the step or module on which the prover was launched
 */
public static void processObligationMessage(ObligationStatusMessage message,final ProverJob proverJob){
  if (message.getStatus().equals(TO_BE_PROVED)) {
    if (proverJob.noToBeProved) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      proverJob.noToBeProved=false;
    }
    proverJob.getObMessageList().add(message);
  }
 else {
    if (proverJob.isToBeProvedOnly()) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      IWorkspaceRunnable runnable=new IWorkspaceRunnable(){
        public void run(        IProgressMonitor monitor) throws CoreException {
          for (Iterator it=proverJob.getObMessageList().iterator(); it.hasNext(); ) {
            ObligationStatusMessage message=(ObligationStatusMessage)it.next();
            IMarker obMarker=createObligationMarker(message.getID(),message.getLocation());
            ObligationStatus obStatus=new ObligationStatus(null,obMarker,ColorPredicate.TO_BE_PROVED_STATE,message.getLocation(),message.getID());
            proverJob.getObsMap().put(new Integer(message.getID()),obStatus);
          }
        }
      }
;
      try {
        proverJob.module.getWorkspace().run(runnable,null,IWorkspace.AVOID_UPDATE,null);
      }
 catch (      CoreException e) {
        ProverUIActivator.logError(""String_Node_Str"",e);
      }
      proverJob.setToBeProvedOnly(false);
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
    }
    final ObligationStatus obStatus=(ObligationStatus)proverJob.getObsMap().get(new Integer(message.getID()));
    if (obStatus.getParent() == null) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      for (Iterator it=proverJob.getObs().iterator(); it.hasNext(); ) {
        ObligationStatus obligation=(ObligationStatus)it.next();
        int searchLine=obligation.getTLAPMLocation().beginLine();
        while (true) {
          StepTuple stepTuple=(StepTuple)proverJob.getLeafStepMap().get(new Integer(searchLine));
          if (stepTuple != null) {
            obligation.setParent(stepTuple);
            stepTuple.addChild(obligation);
            break;
          }
          searchLine--;
        }
      }
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
    }
    obStatus.updateObligation(message);
    UIHelper.runUIAsync(new Runnable(){
      public void run(){
        ObligationsView.updateObligationView(obStatus);
      }
    }
);
  }
}","/** 
 * Process the obligation message. If the status of the message is not  {@link #TO_BE_PROVED} then it creates a marker for that obligationby calling  {@link #createObligationMarker(ObligationStatusMessage)}. Else, it prepares the necessary data structure for computing proof step statuses. The proverJob is the instance of   {@link ProverJob} used to launch the proverand passed to listeners of TLAPM output for that launch. It provides access to information about launch parameters and other useful data structures.
 * @param message
 * @param nodeToProve the step or module on which the prover was launched
 */
public static void processObligationMessage(ObligationStatusMessage message,final ProverJob proverJob){
  if (message.getStatus().equals(TO_BE_PROVED)) {
    if (proverJob.noToBeProved) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      proverJob.noToBeProved=false;
    }
    proverJob.getObMessageList().add(message);
  }
 else {
    if (proverJob.isToBeProvedOnly()) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      IWorkspaceRunnable runnable=new IWorkspaceRunnable(){
        public void run(        IProgressMonitor monitor) throws CoreException {
          for (Iterator it=proverJob.getObMessageList().iterator(); it.hasNext(); ) {
            ObligationStatusMessage message=(ObligationStatusMessage)it.next();
            IMarker obMarker=createObligationMarker(message.getID(),message.getLocation());
            ObligationStatus obStatus=new ObligationStatus(null,obMarker,ColorPredicate.TO_BE_PROVED_STATE,message.getLocation(),message.getID());
            proverJob.getObsMap().put(new Integer(message.getID()),obStatus);
          }
        }
      }
;
      try {
        proverJob.getModule().getWorkspace().run(runnable,null,IWorkspace.AVOID_UPDATE,null);
      }
 catch (      CoreException e) {
        ProverUIActivator.logError(""String_Node_Str"",e);
      }
      proverJob.setToBeProvedOnly(false);
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
    }
    final ObligationStatus obStatus=(ObligationStatus)proverJob.getObsMap().get(new Integer(message.getID()));
    if (obStatus.getParent() == null) {
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
      for (Iterator it=proverJob.getObs().iterator(); it.hasNext(); ) {
        ObligationStatus obligation=(ObligationStatus)it.next();
        int searchLine=obligation.getTLAPMLocation().beginLine();
        while (true) {
          StepTuple stepTuple=(StepTuple)proverJob.getLeafStepMap().get(new Integer(searchLine));
          if (stepTuple != null) {
            obligation.setParent(stepTuple);
            stepTuple.addChild(obligation);
            break;
          }
          searchLine--;
        }
      }
      System.out.println(""String_Node_Str"" + System.currentTimeMillis());
    }
    obStatus.updateObligation(message);
    UIHelper.runUIAsync(new Runnable(){
      public void run(){
        ObligationsView.updateObligationView(obStatus);
      }
    }
);
  }
}",0.9972505256348052
135952,"/** 
 * Returns the   {@link Collection} of {@link ObligationStatus}s from the most recent run of the prover. Returns null if the prover has not yet been launched during this instance of the toolbox.
 * @return
 */
public static ObligationStatus[] getObligationStatuses(){
  if (ProverJob.getLastJob() == null) {
    return null;
  }
  Collection statuses=ProverJob.getLastJob().getObsMap().values();
  return (ObligationStatus[])statuses.toArray(new ObligationStatus[statuses.size()]);
}","/** 
 * Returns the   {@link Collection} of {@link ObligationStatus}s from the most recent run of the prover if the most recent run of the prover is on the current spec. Returns null if the prover has not yet been launched during this instance of the toolbox or if the most recent run of the prover is not on the current spec.
 * @return
 */
public static ObligationStatus[] getObligationStatuses(){
  if (ProverJob.getLastJob() == null) {
    return null;
  }
  ProverJob lastJob=ProverJob.getLastJob();
  if (ToolboxHandle.getCurrentSpec() == null || !lastJob.getModule().getProject().equals(ToolboxHandle.getCurrentSpec().getProject())) {
    return null;
  }
  Collection statuses=lastJob.getObsMap().values();
  return (ObligationStatus[])statuses.toArray(new ObligationStatus[statuses.size()]);
}",0.7271317829457364
135953,"/** 
 * Fills the obligation view with information from the most recent launch of the prover.
 */
private void fillFromCurrentSpec(){
  ObligationStatus[] statuses=ProverHelper.getObligationStatuses();
  if (statuses != null) {
    for (int i=0; i < statuses.length; i++) {
      updateItem(statuses[i]);
    }
  }
}","/** 
 * Fills the obligation view with information from the most recent launch of the prover on the current spec if the most recent launch of the prover was on the current spec. Otherwise, does nothing.
 */
private void fillFromCurrentSpec(){
  ObligationStatus[] statuses=ProverHelper.getObligationStatuses();
  if (statuses != null) {
    for (int i=0; i < statuses.length; i++) {
      updateItem(statuses[i]);
    }
  }
}",0.8529014844804319
135954,"/** 
 * Returns the most prover job that led to the most recent successful launch of the prover.
 */
public static ProverJob getLastJob(){
  return lastJob;
}","/** 
 * Returns the most prover job that led to the most recent launch of the prover.
 */
public static ProverJob getLastJob(){
  return lastJob;
}",0.9639344262295082
135955,"/** 
 * Removes the item from the view, performing necessary cleanup.
 * @param item
 */
private void removeItem(ExpandItem item){
  fontListener.removeControl(((SourceViewer)viewers.get(item)).getControl());
  Integer id=new Integer(((IMarker)item.getData()).getAttribute(ProverHelper.OBLIGATION_ID,-1));
  items.remove(id);
  item.getControl().dispose();
  item.dispose();
}","/** 
 * Removes the item from the view, performing necessary cleanup.
 * @param item
 */
private void removeItem(InterestingObligationExpandItem item){
  fontListener.removeControl(((SourceViewer)viewers.get(item)).getControl());
  items.remove(new Integer(item.getId()));
  item.getControl().dispose();
  item.dispose();
}",0.7296137339055794
135956,"/** 
 * Adds the information from the obligation status to the view. If there is already an item with information of the same obligation as the status, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(ObligationStatus status){
  int id=status.getId();
  if (id != -1) {
    InterestingObligationExpandItem item=(InterestingObligationExpandItem)items.get(new Integer(id));
    if (!ProverHelper.isInterestingObligation(status)) {
      if (item != null) {
        removeItem(item);
      }
      return;
    }
    if (item == null) {
      item=new InterestingObligationExpandItem(bar,SWT.None,0);
      ;
      Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
      GridLayout gl=new GridLayout(1,true);
      gl.marginWidth=0;
      gl.marginHeight=0;
      oblWidget.setLayout(gl);
      Button stopButton=new Button(oblWidget,SWT.PUSH);
      stopButton.setText(""String_Node_Str"");
      stopButton.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
      stopButton.setData(status.getObMarker());
      stopButton.addSelectionListener(stopObListener);
      item.setButton(stopButton);
      SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
      viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
      viewer.configure(new ObligationSourceViewerConfiguration());
      viewer.getControl().setFont(JFaceResources.getTextFont());
      fontListener.addControl(viewer.getControl());
      viewers.put(item,viewer);
      item.setControl(oblWidget);
      item.setExpanded(true);
      item.setData(status.getObMarker());
      viewer.getTextWidget().setData(status.getObMarker());
      oblWidget.setData(status.getObMarker());
      item.addListener(SWT.MouseDown,obClickListener);
      viewer.getTextWidget().addListener(SWT.MouseDown,obClickListener);
      oblWidget.addListener(SWT.MouseDown,obClickListener);
      items.put(new Integer(id),item);
    }
    item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status.getProverStatusString());
    item.getButton().setEnabled(ProverHelper.isBeingProvedObligation(status));
    SourceViewer viewer=(SourceViewer)viewers.get(item);
    Assert.isNotNull(viewer,""String_Node_Str"");
    String oblString=status.getObligationString();
    if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !oblString.isEmpty()) {
      viewer.setDocument(new Document(oblString.trim()));
      item.setHeight(item.getControl().computeSize(SWT.DEFAULT,SWT.DEFAULT,true).y);
    }
 else     if (oblString.isEmpty() && (viewer.getDocument() == null || viewer.getDocument().get().isEmpty())) {
      viewer.setDocument(new Document(""String_Node_Str""));
      item.setHeight(100);
    }
  }
}","/** 
 * Adds the information from the obligation status to the view. If there is already an item with information of the same obligation as the status, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(ObligationStatus status){
  int id=status.getId();
  if (id != -1) {
    InterestingObligationExpandItem item=(InterestingObligationExpandItem)items.get(new Integer(id));
    if (!ProverHelper.isInterestingObligation(status)) {
      if (item != null) {
        removeItem(item);
      }
      return;
    }
    if (item == null) {
      item=new InterestingObligationExpandItem(bar,SWT.None,0,id);
      ;
      Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
      GridLayout gl=new GridLayout(1,true);
      gl.marginWidth=0;
      gl.marginHeight=0;
      oblWidget.setLayout(gl);
      Button stopButton=new Button(oblWidget,SWT.PUSH);
      stopButton.setText(""String_Node_Str"");
      stopButton.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
      stopButton.setData(status.getObMarker());
      stopButton.addSelectionListener(stopObListener);
      item.setButton(stopButton);
      SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
      viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
      viewer.configure(new ObligationSourceViewerConfiguration());
      viewer.getControl().setFont(JFaceResources.getTextFont());
      fontListener.addControl(viewer.getControl());
      viewers.put(item,viewer);
      item.setControl(oblWidget);
      item.setExpanded(true);
      item.setData(status.getObMarker());
      viewer.getTextWidget().setData(status.getObMarker());
      oblWidget.setData(status.getObMarker());
      item.addListener(SWT.MouseDown,obClickListener);
      viewer.getTextWidget().addListener(SWT.MouseDown,obClickListener);
      oblWidget.addListener(SWT.MouseDown,obClickListener);
      items.put(new Integer(id),item);
    }
    item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status.getProverStatusString());
    item.getButton().setEnabled(ProverHelper.isBeingProvedObligation(status));
    SourceViewer viewer=(SourceViewer)viewers.get(item);
    Assert.isNotNull(viewer,""String_Node_Str"");
    String oblString=status.getObligationString();
    if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !oblString.isEmpty()) {
      viewer.setDocument(new Document(oblString.trim()));
      item.setHeight(item.getControl().computeSize(SWT.DEFAULT,SWT.DEFAULT,true).y);
    }
 else     if (oblString.isEmpty() && (viewer.getDocument() == null || viewer.getDocument().get().isEmpty())) {
      viewer.setDocument(new Document(""String_Node_Str""));
      item.setHeight(100);
    }
  }
}",0.9994647636039252
135957,"public InterestingObligationExpandItem(ExpandBar parent,int style,int index){
  super(parent,style,index);
}","/** 
 * Creates an expand bar item for the obligation with the given id. The parent style and index are the arguments used for the constructor   {@link ExpandItem#ExpandItem(ExpandBar,int,int)}.
 */
public InterestingObligationExpandItem(ExpandBar parent,int style,int index,int id){
  super(parent,style,index);
  this.id=id;
}",0.4954128440366973
135958,"/** 
 * This method must be run from a UI thread. Used to refresh the obligation view if it is currently open. If the view is not currently open, this method does nothing. If the view is currently open, this takes the following two steps: 1.) Removes all items from the expand bar for this view. 2.) Retrieve all obligation statuses by calling   {@link ProverHelper#getObligationStatuses()}. Fills the view with information from these statuses. 3.) If there are no interesting obligations in the view after steps 1 and 2, then the view is hidden.
 */
public static void refreshObligationView(){
  ObligationsView oblView=(ObligationsView)UIHelper.findView(VIEW_ID);
  if (oblView != null) {
    ExpandItem[] expandItems=oblView.bar.getItems();
    for (int i=0; i < expandItems.length; i++) {
      oblView.removeItem(expandItems[i]);
    }
    oblView.fillFromCurrentSpec();
    if (oblView.isEmpty()) {
      UIHelper.getActivePage().hideView(oblView);
    }
  }
}","/** 
 * This method must be run from a UI thread. Used to refresh the obligation view if it is currently open. If the view is not currently open, this method does nothing. If the view is currently open, this takes the following two steps: 1.) Removes all items from the expand bar for this view. 2.) Retrieve all obligation statuses by calling   {@link ProverHelper#getObligationStatuses()}. Fills the view with information from these statuses. 3.) If there are no interesting obligations in the view after steps 1 and 2, then the view is hidden.
 */
public static void refreshObligationView(){
  ObligationsView oblView=(ObligationsView)UIHelper.findView(VIEW_ID);
  if (oblView != null) {
    ExpandItem[] expandItems=oblView.bar.getItems();
    for (int i=0; i < expandItems.length; i++) {
      oblView.removeItem((InterestingObligationExpandItem)expandItems[i]);
    }
    oblView.fillFromCurrentSpec();
    if (oblView.isEmpty()) {
      UIHelper.getActivePage().hideView(oblView);
    }
  }
}",0.983206106870229
135959,"/** 
 * This method makes sure pairs of annotation types corresponding to a given logical color are always bound to the same physical color. See the documentation for this class to read more about this.
 */
public void propertyChange(PropertyChangeEvent event){
  if (event.getProperty().contains(COLOR_PREF_KEY_PREFIX) && event.getProperty().endsWith(""String_Node_Str"")) {
    int colorNum=getNumFromMainColorPref(event.getProperty());
    PreferenceConverter.setValue(getPreferenceStore(),getPartnerColorPrefName(colorNum),(RGB)event.getNewValue());
  }
  super.propertyChange(event);
}","/** 
 * This method makes sure pairs of annotation types corresponding to a given logical color are always bound to the same physical color. When the color preference is changed for the key which is bound to the color field editors for this page, this method sets the value for the partner key to be the same. See the documentation for this class to read more about this.
 */
public void propertyChange(PropertyChangeEvent event){
  if (event.getProperty().contains(COLOR_PREF_KEY_PREFIX) && event.getProperty().endsWith(""String_Node_Str"")) {
    int colorNum=getNumFromMainColorPref(event.getProperty());
    IPreferenceStore store=getPreferenceStore();
    String partnerPrefName=getPartnerColorPrefName(colorNum);
    String newValue=getPreferenceStore().getString(event.getProperty());
    if (store.getDefaultString(partnerPrefName).equals(newValue)) {
      store.setToDefault(partnerPrefName);
    }
 else {
      getPreferenceStore().setValue(partnerPrefName,newValue);
    }
  }
  super.propertyChange(event);
}",0.6131840796019901
135960,"private final void unboxComment() throws org.eclipse.jface.text.BadLocationException {
  if ((offset > 2) && (text.charAt(offset) == ')')) {
    offset--;
  }
  if ((offset > 1) && (text.charAt(offset) == '*')) {
    offset--;
  }
  String errorMsg=""String_Node_Str"";
  int startOffset=text.lastIndexOf(""String_Node_Str"",offset);
  int endOffset=text.indexOf(""String_Node_Str"",offset) + 3;
  if ((startOffset < 0) || (endOffset < 0)) {
    displayNotInBoxedCommentError(errorMsg);
    return;
  }
  int startIndent=startOffset - doc.getLineOffset(doc.getLineOfOffset(startOffset));
  int asteriskLength=RightMargin - startIndent - 1;
  String asterisks=StringHelper.copyString(""String_Node_Str"",asteriskLength);
  int beginLine=doc.getLineOfOffset(startOffset);
  int endLine=doc.getLineOfOffset(endOffset);
  if (beginLine == endLine) {
    if (text.substring(startOffset + 1,endOffset - 1).equals(StringHelper.copyString(""String_Node_Str"",endOffset - startOffset - 2))) {
      displayNotInBoxedCommentError(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      displayNotInBoxedCommentError(errorMsg);
    }
    return;
  }
  StringBuffer buffer=new StringBuffer(endOffset - startOffset - 6 * (endLine - beginLine));
  buffer.append(asterisks);
  buffer.append(StringHelper.newline);
  for (int i=beginLine + 1; i < endLine; i++) {
    IRegion lineInfo=doc.getLineInformation(i);
    String currentLine=doc.get(lineInfo.getOffset(),lineInfo.getLength());
    int beginTokenIndex=currentLine.indexOf(""String_Node_Str"");
    int endTokenIndex=currentLine.indexOf(""String_Node_Str"");
    if ((!(beginTokenIndex < 0)) && (!(beginTokenIndex > endTokenIndex))) {
      buffer.append(StringHelper.trimEnd(currentLine.substring(beginTokenIndex + 3,endTokenIndex)));
      buffer.append(StringHelper.newline);
    }
 else {
      buffer.append(currentLine);
      buffer.append(StringHelper.newline);
    }
  }
  buffer.append(StringHelper.copyString(""String_Node_Str"",startIndent));
  buffer.append(asterisks);
  doc.replace(startOffset + 1,endOffset - 2 - startOffset,buffer.toString());
  return;
}","private final void unboxComment() throws org.eclipse.jface.text.BadLocationException {
  if ((offset > 2) && (text.charAt(offset) == ')')) {
    offset--;
  }
  if ((offset > 1) && (text.charAt(offset) == '*')) {
    offset--;
  }
  String errorMsg=""String_Node_Str"";
  int startOffset=text.lastIndexOf(""String_Node_Str"",offset);
  int endOffset=text.indexOf(""String_Node_Str"",offset) + 3;
  if ((startOffset < 0) || (endOffset < 0)) {
    displayNotInBoxedCommentError(errorMsg);
    return;
  }
  int startIndent=startOffset - doc.getLineOffset(doc.getLineOfOffset(startOffset));
  int asteriskLength=RightMargin - startIndent - 1;
  String asterisks=StringHelper.copyString(""String_Node_Str"",asteriskLength);
  int beginLine=doc.getLineOfOffset(startOffset);
  int endLine=doc.getLineOfOffset(endOffset);
  if (beginLine == endLine) {
    if (text.substring(startOffset + 1,endOffset - 1).equals(StringHelper.copyString(""String_Node_Str"",endOffset - startOffset - 2))) {
      displayNotInBoxedCommentError(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      displayNotInBoxedCommentError(errorMsg);
    }
    return;
  }
  StringBuffer buffer=null;
  int bufferSize=endOffset - startOffset - 6 * (endLine - beginLine);
  if (bufferSize > 0) {
    buffer=new StringBuffer(bufferSize);
  }
 else {
    buffer=new StringBuffer();
  }
  buffer.append(asterisks);
  buffer.append(StringHelper.newline);
  for (int i=beginLine + 1; i < endLine; i++) {
    IRegion lineInfo=doc.getLineInformation(i);
    String currentLine=doc.get(lineInfo.getOffset(),lineInfo.getLength());
    int beginTokenIndex=currentLine.indexOf(""String_Node_Str"");
    int endTokenIndex=currentLine.indexOf(""String_Node_Str"");
    if ((!(beginTokenIndex < 0)) && (!(beginTokenIndex > endTokenIndex))) {
      buffer.append(StringHelper.trimEnd(currentLine.substring(beginTokenIndex + 3,endTokenIndex)));
      buffer.append(StringHelper.newline);
    }
 else {
      buffer.append(currentLine);
      buffer.append(StringHelper.newline);
    }
  }
  buffer.append(StringHelper.copyString(""String_Node_Str"",startIndent));
  buffer.append(asterisks);
  doc.replace(startOffset + 1,endOffset - 2 - startOffset,buffer.toString());
  return;
}",0.948367677703172
135961,"public void run(IProgressMonitor monitor) throws CoreException {
  IMarker newMarker=module.createMarker(markerType);
  Map markerAttributes=new HashMap(2);
  Position curPosition=EditorUtil.getMarkerPosition(sanyMarker);
  int newCharStart;
  int newCharEnd;
  if (curPosition != null) {
    newCharStart=curPosition.getOffset();
    newCharEnd=curPosition.getOffset() + curPosition.getLength();
  }
 else {
    newCharStart=sanyMarker.getAttribute(IMarker.CHAR_START,0);
    newCharEnd=sanyMarker.getAttribute(IMarker.CHAR_END,0);
  }
  IMarker[] existingMarkers=module.findMarkers(ProverHelper.STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
  for (int i=0; i < existingMarkers.length; i++) {
    IMarker existingMarker=existingMarkers[i];
    int existingCharStart=existingMarker.getAttribute(IMarker.CHAR_START,-1);
    int existingCharEnd=existingMarker.getAttribute(IMarker.CHAR_END,-1);
    if (existingCharStart < newCharEnd && existingCharEnd > newCharStart) {
      existingMarker.delete();
    }
  }
  markerAttributes.put(IMarker.CHAR_START,new Integer(newCharStart));
  markerAttributes.put(IMarker.CHAR_END,new Integer(newCharEnd));
  markerAttributes.put(IMarker.LINE_NUMBER,new Integer(stringToLoc(sanyMarker.getAttribute(SANY_LOC_ATR,""String_Node_Str"")).beginLine()));
  newMarker.setAttributes(markerAttributes);
}","public void run(IProgressMonitor monitor) throws CoreException {
  Position curPosition=EditorUtil.getMarkerPosition(sanyMarker);
  int newCharStart;
  int newCharEnd;
  if (curPosition != null) {
    newCharStart=curPosition.getOffset();
    newCharEnd=curPosition.getOffset() + curPosition.getLength();
  }
 else {
    newCharStart=sanyMarker.getAttribute(IMarker.CHAR_START,0);
    newCharEnd=sanyMarker.getAttribute(IMarker.CHAR_END,0);
  }
  IMarker[] existingMarkers=module.findMarkers(ProverHelper.STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
  for (int i=0; i < existingMarkers.length; i++) {
    IMarker existingMarker=existingMarkers[i];
    int existingCharStart=existingMarker.getAttribute(IMarker.CHAR_START,-1);
    int existingCharEnd=existingMarker.getAttribute(IMarker.CHAR_END,-1);
    if (existingCharStart < newCharEnd && existingCharEnd > newCharStart) {
      existingMarker.delete();
    }
  }
  if (markerType != null) {
    Map markerAttributes=new HashMap(2);
    markerAttributes.put(IMarker.CHAR_START,new Integer(newCharStart));
    markerAttributes.put(IMarker.CHAR_END,new Integer(newCharEnd));
    markerAttributes.put(IMarker.LINE_NUMBER,new Integer(stringToLoc(sanyMarker.getAttribute(SANY_LOC_ATR,""String_Node_Str"")).beginLine()));
    IMarker newMarker=module.createMarker(markerType);
    newMarker.setAttributes(markerAttributes);
  }
}",0.9158050221565732
135962,"/** 
 * Converts the status string to the correct marker type. The status string should be one of :   {@link StepStatusMessage#CHECKED}{@link StepStatusMessage#CHECKING_FAILED}{@link StepStatusMessage.MISSING_PROOFS}{@link StepStatusMessage.OMITTED}{@link StepStatusMessage.PROVED}{@link StepStatusMessage.PROVING_FAILED}{@link StepStatusMessage.BEING_PROVED}If the input is not one of these, this method will return null. The marker type for proving failed steps is different depending on whether it is a leaf step or not.
 * @param status
 * @param isLeafStep true iff the status is for a leaf step (a step with nochildren or with a leaf proof).
 * @return
 */
public static String statusStringToMarkerType(String status,boolean isLeafStep){
  if (status.equals(StepStatusMessage.CHECKED)) {
    return STEP_CHECKED_MARKER;
  }
 else   if (status.equals(StepStatusMessage.CHECKING_FAILED)) {
    return STEP_CHECKING_FAILED_MARKER;
  }
 else   if (status.equals(StepStatusMessage.MISSING_PROOFS)) {
    return STEP_MISSING_MARKER;
  }
 else   if (status.equals(StepStatusMessage.OMITTED)) {
    return STEP_OMITTED_MARKER;
  }
 else   if (status.equals(StepStatusMessage.PROVED)) {
    return STEP_PROVED_MARKER;
  }
 else   if (status.equals(StepStatusMessage.PROVING_FAILED)) {
    if (isLeafStep) {
      return STEP_LEAF_FAILED;
    }
 else {
      return STEP_PROVING_FAILED_MARKER;
    }
  }
 else   if (status.equals(StepStatusMessage.BEING_PROVED)) {
    return STEP_BEING_PROVED_MARKER;
  }
  return null;
}","/** 
 * Converts the status string to the correct marker type. The status string should be one of :   {@link StepStatusMessage#CHECKED}{@link StepStatusMessage#CHECKING_FAILED}{@link StepStatusMessage.MISSING_PROOFS}{@link StepStatusMessage.OMITTED}{@link StepStatusMessage.PROVED}{@link StepStatusMessage.PROVING_FAILED}{@link StepStatusMessage.BEING_PROVED}If status is not one of these, this method will return null. If status is null, this method returns null. The marker type for proving failed steps is different depending on whether it is a leaf step or not.
 * @param status
 * @param isLeafStep true iff the status is for a leaf step (a step with nochildren or with a leaf proof).
 * @return
 */
public static String statusStringToMarkerType(String status,boolean isLeafStep){
  if (status == null) {
    return null;
  }
  if (status.equals(StepStatusMessage.CHECKED)) {
    return STEP_CHECKED_MARKER;
  }
 else   if (status.equals(StepStatusMessage.CHECKING_FAILED)) {
    return STEP_CHECKING_FAILED_MARKER;
  }
 else   if (status.equals(StepStatusMessage.MISSING_PROOFS)) {
    return STEP_MISSING_MARKER;
  }
 else   if (status.equals(StepStatusMessage.OMITTED)) {
    return STEP_OMITTED_MARKER;
  }
 else   if (status.equals(StepStatusMessage.PROVED)) {
    return STEP_PROVED_MARKER;
  }
 else   if (status.equals(StepStatusMessage.PROVING_FAILED)) {
    if (isLeafStep) {
      return STEP_LEAF_FAILED;
    }
 else {
      return STEP_PROVING_FAILED_MARKER;
    }
  }
 else   if (status.equals(StepStatusMessage.BEING_PROVED)) {
    return STEP_BEING_PROVED_MARKER;
  }
  return null;
}",0.9503682356708292
135963,"/** 
 * Creates a new marker at the current location of sanyMarker indicating the status given by status. If status is not a known type (the method  {@link #statusStringToMarkerType(String,boolean)} returns null) then this printssome debugging message and returns. If sanyMarker is null, this also prints some debugging message and returns. If status is null, this method just returns without doing anything.
 * @param sanyMarker
 * @param status
 */
public static void newStepStatusMarker(final IMarker sanyMarker,String status){
  if (status == null) {
    return;
  }
  if (sanyMarker == null) {
    ProverUIActivator.logDebug(""String_Node_Str"");
    return;
  }
  try {
    final IResource module=sanyMarker.getResource();
    final String markerType=statusStringToMarkerType(status,sanyMarker.getAttribute(SANY_IS_LEAF_ATR,false));
    if (markerType == null) {
      ProverUIActivator.logDebug(""String_Node_Str"" + status);
      return;
    }
    IWorkspaceRunnable runnable=new IWorkspaceRunnable(){
      public void run(      IProgressMonitor monitor) throws CoreException {
        IMarker newMarker=module.createMarker(markerType);
        Map markerAttributes=new HashMap(2);
        Position curPosition=EditorUtil.getMarkerPosition(sanyMarker);
        int newCharStart;
        int newCharEnd;
        if (curPosition != null) {
          newCharStart=curPosition.getOffset();
          newCharEnd=curPosition.getOffset() + curPosition.getLength();
        }
 else {
          newCharStart=sanyMarker.getAttribute(IMarker.CHAR_START,0);
          newCharEnd=sanyMarker.getAttribute(IMarker.CHAR_END,0);
        }
        IMarker[] existingMarkers=module.findMarkers(ProverHelper.STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
        for (int i=0; i < existingMarkers.length; i++) {
          IMarker existingMarker=existingMarkers[i];
          int existingCharStart=existingMarker.getAttribute(IMarker.CHAR_START,-1);
          int existingCharEnd=existingMarker.getAttribute(IMarker.CHAR_END,-1);
          if (existingCharStart < newCharEnd && existingCharEnd > newCharStart) {
            existingMarker.delete();
          }
        }
        markerAttributes.put(IMarker.CHAR_START,new Integer(newCharStart));
        markerAttributes.put(IMarker.CHAR_END,new Integer(newCharEnd));
        markerAttributes.put(IMarker.LINE_NUMBER,new Integer(stringToLoc(sanyMarker.getAttribute(SANY_LOC_ATR,""String_Node_Str"")).beginLine()));
        newMarker.setAttributes(markerAttributes);
      }
    }
;
    module.getWorkspace().run(runnable,null,IWorkspace.AVOID_UPDATE,null);
  }
 catch (  CoreException e) {
    ProverUIActivator.logError(""String_Node_Str"",e);
  }
}","/** 
 * Creates a new marker at the current location of sanyMarker indicating the status given by status. If status is not a known type (the method  {@link #statusStringToMarkerType(String,boolean)} returns null) then this printssome debugging message and returns. If sanyMarker is null, this also prints some debugging message and returns. If status is null, this method removes any step status markers that overlap with sanyMarker. A null status means that no color should be shown on the editor.
 * @param sanyMarker
 * @param status
 */
public static void newStepStatusMarker(final IMarker sanyMarker,String status){
  if (sanyMarker == null) {
    ProverUIActivator.logDebug(""String_Node_Str"");
    return;
  }
  try {
    final IResource module=sanyMarker.getResource();
    final String markerType=statusStringToMarkerType(status,sanyMarker.getAttribute(SANY_IS_LEAF_ATR,false));
    IWorkspaceRunnable runnable=new IWorkspaceRunnable(){
      public void run(      IProgressMonitor monitor) throws CoreException {
        Position curPosition=EditorUtil.getMarkerPosition(sanyMarker);
        int newCharStart;
        int newCharEnd;
        if (curPosition != null) {
          newCharStart=curPosition.getOffset();
          newCharEnd=curPosition.getOffset() + curPosition.getLength();
        }
 else {
          newCharStart=sanyMarker.getAttribute(IMarker.CHAR_START,0);
          newCharEnd=sanyMarker.getAttribute(IMarker.CHAR_END,0);
        }
        IMarker[] existingMarkers=module.findMarkers(ProverHelper.STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
        for (int i=0; i < existingMarkers.length; i++) {
          IMarker existingMarker=existingMarkers[i];
          int existingCharStart=existingMarker.getAttribute(IMarker.CHAR_START,-1);
          int existingCharEnd=existingMarker.getAttribute(IMarker.CHAR_END,-1);
          if (existingCharStart < newCharEnd && existingCharEnd > newCharStart) {
            existingMarker.delete();
          }
        }
        if (markerType != null) {
          Map markerAttributes=new HashMap(2);
          markerAttributes.put(IMarker.CHAR_START,new Integer(newCharStart));
          markerAttributes.put(IMarker.CHAR_END,new Integer(newCharEnd));
          markerAttributes.put(IMarker.LINE_NUMBER,new Integer(stringToLoc(sanyMarker.getAttribute(SANY_LOC_ATR,""String_Node_Str"")).beginLine()));
          IMarker newMarker=module.createMarker(markerType);
          newMarker.setAttributes(markerAttributes);
        }
      }
    }
;
    module.getWorkspace().run(runnable,null,IWorkspace.AVOID_UPDATE,null);
  }
 catch (  CoreException e) {
    ProverUIActivator.logError(""String_Node_Str"",e);
  }
}",0.8954833893243748
135964,"/** 
 * Called when there is a new parse result broadcast by  {@link ParseResultBroadcaster}. Updates the folding structure of the proofs in the editor if the parse result points to the   {@link ModuleNode} representingthe file in the editor for this class.
 */
public void newParseResult(ParseResult parseResult){
  if (!parseResult.getParsedResource().getLocation().removeLastSegments(1).equals(((FileEditorInput)editor.getEditorInput()).getFile().getLocation().removeLastSegments(1))) {
    return;
  }
  String moduleName=ResourceHelper.getModuleName(((FileEditorInput)editor.getEditorInput()).getFile());
  if (editor == null) {
    Activator.logDebug(""String_Node_Str"");
    return;
  }
 else   if (editor.getEditorInput() == null) {
    Activator.logDebug(""String_Node_Str"");
    return;
  }
  if (editor.isDirty() || parseResult.getParserCalled() < documentLastModified || parseResult.getParserCalled() < ((FileEditorInput)editor.getEditorInput()).getFile().getLocalTimeStamp()) {
    return;
  }
  SpecObj specObj=parseResult.getSpecObj();
  if (specObj == null) {
    return;
  }
  Assert.isNotNull(specObj.getExternalModuleTable());
  ModuleNode moduleNode=specObj.getExternalModuleTable().getModuleNode(UniqueString.uniqueStringOf(moduleName));
  if (moduleNode == null) {
    return;
  }
  canPerformFoldingCommands=false;
  HashMap additions=new HashMap();
  Vector foldsInCurrentTree=new Vector();
  TheoremNode[] theorems=moduleNode.getTheorems();
  for (int i=0; i < theorems.length; i++) {
    TheoremNode theoremNode=theorems[i];
    try {
      if (theoremNode.getLocation().source().equals(moduleName)) {
        computeProofFoldPositions(theoremNode,additions,foldsInCurrentTree,foldPositions);
      }
    }
 catch (    BadLocationException e) {
      Activator.logError(""String_Node_Str"" + moduleName,e);
    }
  }
  Annotation[] deletions=new ProjectionAnnotation[foldPositions.size()];
  int i=0;
  for (Iterator it=foldPositions.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    proofPosition.remove(document);
    deletions[i]=proofPosition.getAnnotation();
  }
  foldPositions=foldsInCurrentTree;
  editor.modifyProjectionAnnotations(deletions,additions,null);
  int currentOffset=-1;
  boolean isSorted=true;
  for (Iterator it=foldPositions.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    if (proofPosition.getOffset() >= currentOffset) {
      currentOffset=proofPosition.getOffset();
    }
 else {
      isSorted=false;
      break;
    }
  }
  if (!isSorted) {
    Collections.sort(foldPositions,new Comparator(){
      public int compare(      Object arg0,      Object arg1){
        if (arg0 instanceof TLAProofPosition && arg1 instanceof TLAProofPosition) {
          return ((TLAProofPosition)arg0).getOffset() - ((TLAProofPosition)arg1).getOffset();
        }
 else {
          return 0;
        }
      }
    }
);
  }
  canPerformFoldingCommands=true;
}","/** 
 * Called when there is a new parse result broadcast by  {@link ParseResultBroadcaster}. Updates the folding structure of the proofs in the editor if the parse result points to the   {@link ModuleNode} representingthe file in the editor for this class.
 */
public void newParseResult(ParseResult parseResult){
  if (!parseResult.getParsedResource().getLocation().removeLastSegments(1).equals(((FileEditorInput)editor.getEditorInput()).getFile().getLocation().removeLastSegments(1))) {
    return;
  }
  String moduleName=ResourceHelper.getModuleName(((FileEditorInput)editor.getEditorInput()).getFile());
  if (editor == null) {
    Activator.logDebug(""String_Node_Str"");
    return;
  }
 else   if (editor.getEditorInput() == null) {
    Activator.logDebug(""String_Node_Str"");
    return;
  }
  if (editor.isDirty() || parseResult.getParserCalled() < documentLastModified || parseResult.getParserCalled() < ((FileEditorInput)editor.getEditorInput()).getFile().getLocalTimeStamp()) {
    return;
  }
  SpecObj specObj=parseResult.getSpecObj();
  if (specObj == null || (parseResult.getParseErrors() != null && parseResult.getParseErrors().isFailure()) || (parseResult.getSemanticErrors() != null && parseResult.getSemanticErrors().isFailure())) {
    return;
  }
  Assert.isNotNull(specObj.getExternalModuleTable());
  ModuleNode moduleNode=specObj.getExternalModuleTable().getModuleNode(UniqueString.uniqueStringOf(moduleName));
  if (moduleNode == null) {
    return;
  }
  canPerformFoldingCommands=false;
  HashMap additions=new HashMap();
  Vector foldsInCurrentTree=new Vector();
  TheoremNode[] theorems=moduleNode.getTheorems();
  for (int i=0; i < theorems.length; i++) {
    TheoremNode theoremNode=theorems[i];
    try {
      if (theoremNode.getLocation().source().equals(moduleName)) {
        computeProofFoldPositions(theoremNode,additions,foldsInCurrentTree,foldPositions);
      }
    }
 catch (    BadLocationException e) {
      Activator.logError(""String_Node_Str"" + moduleName,e);
    }
  }
  Annotation[] deletions=new ProjectionAnnotation[foldPositions.size()];
  int i=0;
  for (Iterator it=foldPositions.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    proofPosition.remove(document);
    deletions[i]=proofPosition.getAnnotation();
  }
  foldPositions=foldsInCurrentTree;
  editor.modifyProjectionAnnotations(deletions,additions,null);
  int currentOffset=-1;
  boolean isSorted=true;
  for (Iterator it=foldPositions.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    if (proofPosition.getOffset() >= currentOffset) {
      currentOffset=proofPosition.getOffset();
    }
 else {
      isSorted=false;
      break;
    }
  }
  if (!isSorted) {
    Collections.sort(foldPositions,new Comparator(){
      public int compare(      Object arg0,      Object arg1){
        if (arg0 instanceof TLAProofPosition && arg1 instanceof TLAProofPosition) {
          return ((TLAProofPosition)arg0).getOffset() - ((TLAProofPosition)arg1).getOffset();
        }
 else {
          return 0;
        }
      }
    }
);
  }
  canPerformFoldingCommands=true;
}",0.971103896103896
135965,"public void run(){
  ObligationsView.refreshObligationView();
}","public void run(){
  if (nodeToProve != null) {
    module=(IFile)ResourceHelper.getResourceByModuleName(nodeToProve.getLocation().source());
    return;
  }
  TLAEditor editor=EditorUtil.getTLAEditorWithFocus();
  Assert.isNotNull(editor,""String_Node_Str"");
  module=((FileEditorInput)editor.getEditorInput()).getFile();
  ParseResult parseResult=ResourceHelper.getValidParseResult(module);
  if (parseResult == null) {
    parseResult=new ModuleParserLauncher().parseModule(module,new NullProgressMonitor());
  }
  if (parseResult.getStatus() != IParseConstants.PARSED) {
    return;
  }
  String moduleName=ResourceHelper.getModuleName(module);
  IDocument document=editor.getDocumentProvider().getDocument(editor.getEditorInput());
  nodeToProve=ResourceHelper.getPfStepOrUseHideFromMod(parseResult,moduleName,(ITextSelection)editor.getSelectionProvider().getSelection(),document);
  if (nodeToProve == null) {
    nodeToProve=parseResult.getSpecObj().getExternalModuleTable().getModuleNode(UniqueString.uniqueStringOf(moduleName));
    return;
  }
}",0.0447627573858549
135966,"/** 
 * Constructor. 
 * @param module the {@link IFile} pointing to the module on which the prover is beinglaunched
 * @param checkStatus true iff the prover should be launched for status checkingonly, not proving.
 * @param node the node on which the prover should be launched. If the prover is to belaunched on the entire module, then this should be an instance of  {@link ModuleNode}. Else it should be an instance of   {@link TheoremNode} or {@link UseOrHideNode} representingthe step.
 * @param checkProofs true iff proofs should be checked. Should not be setto true if checkStatus is also set to true.
 */
public ProverJob(IFile module,boolean checkStatus,LevelNode node,boolean checkProofs){
  super(""String_Node_Str"" + (node instanceof ModuleNode ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ module.getName()+ (node instanceof ModuleNode ? ""String_Node_Str"" : ""String_Node_Str"" + getBeginLine(node) + ""String_Node_Str""+ getEndLine(node)));
  this.module=module;
  this.checkStatus=checkStatus;
  this.nodeToProve=node;
  this.checkProofs=checkProofs;
  Assert.isTrue(Platform.isRunning(),""String_Node_Str"");
  this.tlapmPath=new Path(""String_Node_Str"");
  if (Platform.getOS().equals(Platform.OS_WIN32)) {
    IPath defaultPath=new Path(""String_Node_Str"");
    if (defaultPath.toFile().exists()) {
      this.tlapmPath=defaultPath;
    }
  }
 else   if (Platform.getOS().equals(Platform.OS_MACOSX) || Platform.getOS().equals(Platform.OS_LINUX)) {
    IPath defaultPath=new Path(""String_Node_Str"");
    if (defaultPath.toFile().exists()) {
      this.tlapmPath=defaultPath;
    }
  }
 else {
  }
  this.cygwinPath=new Path(""String_Node_Str"");
  this.launch=new Launch(null,""String_Node_Str"",null);
}","/** 
 * Constructor. This constructor sets the appropriate scheduling rule for this job, so there is no need to call   {@link #setRule(org.eclipse.core.runtime.jobs.ISchedulingRule)}.
 * @param checkStatus true iff the prover should be launched for status checkingonly, not proving.
 * @param node the node on which the prover should be launched. If the prover is to belaunched on the entire module, then this should be an instance of  {@link ModuleNode}. Else it should be an instance of   {@link TheoremNode} or {@link UseOrHideNode} representingthe step. If this argument is null, then the prover will be launched on the active selection, where the active selection is a step if the caret is at a step, and the entire module if the caret is not at a step.
 * @param checkProofs true iff proofs should be checked. Should not be setto true if checkStatus is also set to true.
 */
public ProverJob(boolean checkStatus,LevelNode node,boolean checkProofs){
  super(""String_Node_Str"");
  this.checkStatus=checkStatus;
  this.nodeToProve=node;
  this.checkProofs=checkProofs;
  setRule(new ProverJobRule());
  Assert.isTrue(Platform.isRunning(),""String_Node_Str"");
  this.tlapmPath=new Path(""String_Node_Str"");
  if (Platform.getOS().equals(Platform.OS_WIN32)) {
    IPath defaultPath=new Path(""String_Node_Str"");
    if (defaultPath.toFile().exists()) {
      this.tlapmPath=defaultPath;
    }
  }
 else   if (Platform.getOS().equals(Platform.OS_MACOSX) || Platform.getOS().equals(Platform.OS_LINUX)) {
    IPath defaultPath=new Path(""String_Node_Str"");
    if (defaultPath.toFile().exists()) {
      this.tlapmPath=defaultPath;
    }
  }
 else {
  }
  this.cygwinPath=new Path(""String_Node_Str"");
  this.launch=new Launch(null,""String_Node_Str"",null);
}",0.739568345323741
135967,"/** 
 * Constructor taking the path to the module for which there is output, the monitor that can be used to report information about progress, and the description of the prover launch. This contains information about the parameters used to launch the prover.
 * @param moduleFile
 * @param monitor
 * @param description the description of the prover launch. Contains information aboutthe parameters used to launch the prover.
 */
public void initializeSink(IFile moduleFile,ProverLaunchDescription description,IProgressMonitor monitor){
  currentMessageBuffer=new StringBuilder();
  this.moduleFile=moduleFile;
  this.monitor=monitor;
  this.description=description;
}","/** 
 * Constructor taking the path to the module for which there is output, the monitor that can be used to report information about progress, and the description of the prover launch. This contains information about the parameters used to launch the prover.
 * @param moduleFile
 * @param monitor
 * @param description the description of the prover launch. Contains information aboutthe parameters used to launch the prover.
 */
public void initializeSink(IFile moduleFile,ProverLaunchDescription description,IProgressMonitor monitor){
  currentSearchTextBuffer=new StringBuilder();
  this.moduleFile=moduleFile;
  this.monitor=monitor;
  this.description=description;
}",0.9873228933631618
135968,"/** 
 * Called to stream text into this parser. This method creates instances of   {@link TLAPMMessage} andprocess them according to their type.  
 * @param text
 * @throws BadLocationException
 */
public void appendText(String text){
  String searchText=text;
  while (!searchText.isEmpty()) {
    if (inMessage) {
      int endTagIndex=searchText.indexOf(END_TAG);
      if (endTagIndex != -1) {
        inMessage=false;
        currentMessageBuffer.append(searchText.substring(0,endTagIndex));
        TLAPMMessage data=TLAPMMessage.parseMessage(currentMessageBuffer.toString(),moduleFile.getLocation().removeFileExtension().lastSegment());
        if (data != null) {
          if (data instanceof ObligationStatusMessage) {
            ProverHelper.processObligationMessage((ObligationStatusMessage)data,description.getLevelNode());
            if (ProverHelper.isObligationFinished((ObligationStatusMessage)data,description)) {
              monitor.worked(1);
            }
          }
 else           if (data instanceof ObligationNumberMessage) {
            ObligationNumberMessage numMessage=(ObligationNumberMessage)data;
            monitor.beginTask(""String_Node_Str"" + numMessage.getCount() + ""String_Node_Str"",numMessage.getCount());
          }
 else           if (data instanceof StepStatusMessage) {
            ProverHelper.newStepStatusMessage((StepStatusMessage)data,description.isStatusCheck());
          }
        }
        searchText=searchText.substring(endTagIndex + END_TAG.length(),searchText.length());
      }
 else {
        currentMessageBuffer.append(searchText);
        searchText=""String_Node_Str"";
      }
    }
 else {
      int startTagIndex=searchText.indexOf(START_TAG);
      if (startTagIndex != -1) {
        inMessage=true;
        searchText=searchText.substring(startTagIndex + START_TAG.length(),searchText.length());
        currentMessageBuffer=new StringBuilder();
      }
 else {
        searchText=""String_Node_Str"";
      }
    }
  }
}","/** 
 * Called to stream text into this parser. This method creates instances of   {@link TLAPMMessage} andprocess them according to their type. See the comments within the method for the parsing algorithm.
 * @param text
 * @throws BadLocationException
 */
public void appendText(String text){
  currentSearchTextBuffer.append(text);
  int tagIndex=-1;
  if (inMessage) {
    tagIndex=currentSearchTextBuffer.indexOf(END_TAG);
  }
 else {
    tagIndex=currentSearchTextBuffer.indexOf(START_TAG);
  }
  while (tagIndex != -1) {
    if (inMessage) {
      TLAPMMessage data=TLAPMMessage.parseMessage(currentSearchTextBuffer.substring(0,tagIndex),moduleFile.getLocation().removeFileExtension().lastSegment());
      currentSearchTextBuffer.replace(0,tagIndex + END_TAG.length(),""String_Node_Str"");
      inMessage=false;
      if (data != null) {
        if (data instanceof ObligationStatusMessage) {
          ProverHelper.processObligationMessage((ObligationStatusMessage)data,description.getLevelNode());
          if (ProverHelper.isObligationFinished((ObligationStatusMessage)data,description)) {
            monitor.worked(1);
          }
        }
 else         if (data instanceof ObligationNumberMessage) {
          ObligationNumberMessage numMessage=(ObligationNumberMessage)data;
          monitor.beginTask(""String_Node_Str"" + numMessage.getCount() + ""String_Node_Str"",numMessage.getCount());
        }
 else         if (data instanceof StepStatusMessage) {
          ProverHelper.newStepStatusMessage((StepStatusMessage)data,description.isStatusCheck());
        }
      }
    }
 else {
      currentSearchTextBuffer.replace(0,tagIndex + START_TAG.length(),""String_Node_Str"");
      inMessage=true;
    }
    if (inMessage) {
      tagIndex=currentSearchTextBuffer.indexOf(END_TAG);
    }
 else {
      tagIndex=currentSearchTextBuffer.indexOf(START_TAG);
    }
  }
}",0.2975975200206665
135969,"/** 
 * Creates an error without any replacement of text from the error message reported by TLC.
 */
protected TLCError createError(TLCRegion tlcRegion,IDocument tlcOutputDocument){
  TLCError topError=new TLCError();
  if (tlcRegion instanceof TLCRegionContainer) {
    TLCRegionContainer container=(TLCRegionContainer)tlcRegion;
    ITypedRegion[] regions=container.getSubRegions();
    Assert.isTrue(regions.length < 3,""String_Node_Str"");
    for (int i=0; i < regions.length; i++) {
      if (regions[i] instanceof TLCRegion) {
        TLCError cause=createError((TLCRegion)regions[i],tlcOutputDocument);
        topError.setCause(cause);
      }
 else {
        try {
          topError.setMessage(tlcOutputDocument.get(tlcRegion.getOffset(),tlcRegion.getLength()));
          topError.setErrorCode(tlcRegion.getMessageCode());
        }
 catch (        BadLocationException e) {
          TLCUIActivator.logError(""String_Node_Str"",e);
        }
      }
    }
  }
  return topError;
}","/** 
 * Creates an error without any replacement of text from the error message reported by TLC. This overrides the method in TLCModelLaunchDataProvider because that method does a lot of work to search for Strings such as inv_2354234343434 in the error message and replace them with the actual invariant from the MC.tla file. The user should never see anything from the TE file, so this work is unnecessary for the trace explorer. <br>This is a factory method
 * @param tlcRegion a region marking the error information in the document
 * @param message the message represented by the region
 * @return the TLC Error representing the error
 */
protected TLCError createError(TLCRegion tlcRegion,String message){
  TLCError topError=new TLCError();
  if (tlcRegion instanceof TLCRegionContainer) {
    TLCRegionContainer container=(TLCRegionContainer)tlcRegion;
    ITypedRegion[] regions=container.getSubRegions();
    Assert.isTrue(regions.length < 3,""String_Node_Str"");
    for (int i=0; i < regions.length; i++) {
      if (regions[i] instanceof TLCRegion) {
        TLCError cause=createError((TLCRegion)regions[i],message);
        topError.setCause(cause);
      }
 else {
        topError.setMessage(message);
        topError.setErrorCode(tlcRegion.getMessageCode());
      }
    }
  }
  return topError;
}",0.6238053866203301
135970,"private final ProofNode generateProof(TreeNode stn,ModuleNode cm) throws AbortException {
  int numberOfPops=0;
  if (stn.getKind() == N_TerminalProof) {
    return generateLeafProof(stn,cm);
  }
  ;
  Context pfCtxt=new Context(moduleTable,errors);
  symbolTable.pushContext(pfCtxt);
  TreeNode heirs[]=stn.heirs();
  int offset=0;
  if (heirs[0].getKind() == TLAplusParserConstants.PROOF) {
    offset=1;
  }
  ;
  LevelNode[] steps=new LevelNode[heirs.length - offset];
  Vector iVec=new Vector();
  boolean prevIsInfix=false;
  ExprNode prevRHS=null;
  for (int i=offset; i < heirs.length; i++) {
    boolean isAssumeProve=false;
    boolean isSuffices=false;
    Context assumeContext=null;
    boolean isPick=false;
    Context pickContext=null;
    TreeNode pfStepSTN=heirs[i];
    TreeNode stepNumSTN=pfStepSTN.heirs()[0];
    TreeNode stepBodySTN=pfStepSTN.heirs()[1];
    TreeNode stepPfSTN=null;
    if (pfStepSTN.heirs().length > 2) {
      stepPfSTN=pfStepSTN.heirs()[2];
    }
    ;
    LevelNode pfNumNode=null;
    boolean makePfNumNode=true;
    UniqueString stepNum=null;
switch (stepNumSTN.getKind()) {
case TLAplusParserConstants.ProofImplicitStepLexeme:
case TLAplusParserConstants.ProofStepLexeme:
      stepNum=stepNumSTN.getUS();
    break;
case TLAplusParserConstants.ProofStepDotLexeme:
  String stNum=stepNumSTN.getUS().toString();
stepNum=UniqueString.uniqueStringOf(stNum.substring(0,stNum.indexOf(""String_Node_Str"")));
break;
default :
makePfNumNode=false;
break;
}
;
if (stepNum != null) {
pushLS();
}
;
ThmOrAssumpDefNode tadn=null;
if (stepNum != null) {
tadn=new ThmOrAssumpDefNode(stepNum,stepNumSTN);
}
;
int stepKind=stepBodySTN.getKind();
if (stepKind != N_AssertStep) {
prevIsInfix=false;
}
;
switch (stepKind) {
case N_DefStep:
TreeNode[] defSTNs=stepBodySTN.heirs();
int defOffSet=0;
if (defSTNs[0].getKind() == DEFINE) {
defOffSet=1;
}
;
OpDefNode[] defs=new OpDefNode[defSTNs.length - defOffSet];
for (int j=defOffSet; j < defSTNs.length; j++) {
TreeNode defSTN=defSTNs[j];
;
Vector vec=new Vector();
switch (defSTN.getKind()) {
case N_FunctionDefinition:
processFunction(defSTN,vec,cm);
break;
case N_ModuleDefinition:
Vector defsVec=new Vector();
vec.addElement(processModuleDefinition(defSTN,defsVec,iVec,cm));
break;
case N_OperatorDefinition:
processOperator(defSTN,vec,cm);
break;
}
;
defs[j - defOffSet]=(OpDefNode)vec.elementAt(0);
}
;
pfNumNode=new DefStepNode(stepBodySTN,stepNum,defs);
steps[i - offset]=pfNumNode;
break;
case N_UseOrHide:
UseOrHideNode uohn=generateUseOrHide(stepBodySTN,cm);
uohn.stn=pfStepSTN;
uohn.setStepName(stepNum);
if (uohn.facts.length + uohn.defs.length == 0) {
errors.addError(stepBodySTN.getLocation(),""String_Node_Str"");
}
;
uohn.factCheck();
pfNumNode=uohn;
steps[i - offset]=pfNumNode;
break;
case N_NonLocalInstance:
InstanceNode inst=generateInstance(stepBodySTN,cm,false);
inst.setStepName(stepNum);
pfNumNode=inst;
steps[i - offset]=pfNumNode;
break;
default :
makePfNumNode=false;
TreeNode[] bodyHeirs=stepBodySTN.heirs();
LevelNode body=null;
UniqueString op=null;
ExprNode[] args;
switch (stepBodySTN.getKind()) {
case N_AssertStep:
int bodyNext=0;
if (bodyHeirs[0].getKind() == TLAplusParserConstants.SUFFICES) {
bodyNext=1;
isSuffices=true;
}
;
if (bodyHeirs[bodyNext].getKind() == N_AssumeProve) {
isAssumeProve=true;
symbolTable.pushContext(new Context(moduleTable,errors));
currentGoal=tadn;
body=generateAssumeProve(bodyHeirs[bodyNext],cm);
if (isSuffices) {
((AssumeProveNode)body).setSuffices();
}
;
currentGoal=null;
assumeContext=symbolTable.getContext();
symbolTable.popContext();
prevIsInfix=false;
}
 else {
TreeNode curExpr=bodyHeirs[bodyNext];
if (isSuffices) {
args=new ExprNode[1];
args[0]=generateExpression(curExpr,cm);
body=new OpApplNode(OP_suffices,args,stepBodySTN,cm);
}
 else {
SyntaxTreeNode curLHS=null;
if (curExpr.getKind() == N_InfixExpr) {
curLHS=(SyntaxTreeNode)curExpr.heirs()[0];
}
;
if (prevIsInfix && (curLHS != null) && (curLHS.heirs().length > 0)&& (((SyntaxTreeNode)curLHS.heirs()[0]).heirs().length == 0)&& (curLHS.heirs()).length > 1 && (curLHS.heirs()[1].getKind() == IDENTIFIER) && (curLHS.heirs()[1].getUS() == AtUS)) {
TreeNode[] children=curExpr.heirs();
GenID genID=generateGenID(children[1],cm);
ExprNode[] sns=new ExprNode[2];
SymbolNode opn=symbolTable.resolveSymbol(Operators.resolveSynonym(genID.getCompoundIDUS()));
if (opn == null) {
errors.addError(curExpr.getLocation(),""String_Node_Str"" + genID.getCompoundIDUS() + ""String_Node_Str"");
return null;
}
;
sns[1]=generateExpression(children[2],cm);
ExprNode[] nopArgs=new ExprNode[1];
nopArgs[0]=prevRHS;
sns[0]=new OpApplNode(OP_nop,nopArgs,curLHS,cm);
body=new OpApplNode(opn,sns,curExpr,cm);
}
 else {
body=generateExpression(curExpr,cm);
}
;
prevIsInfix=false;
if ((curLHS != null) && (body != null) && (body.getKind() == OpApplKind)&& (((OpApplNode)body).getArgs().length > 1)) {
prevIsInfix=true;
prevRHS=(ExprNode)((OpApplNode)body).getArgs()[1];
}
}
}
;
break;
case N_HaveStep:
case N_CaseStep:
if (stepBodySTN.getKind() == N_HaveStep) {
op=OP_have;
}
 else {
op=OP_pfcase;
}
;
args=new ExprNode[1];
args[0]=generateExpression(bodyHeirs[1],cm);
body=new OpApplNode(op,args,stepBodySTN,cm);
break;
case N_TakeStep:
case N_PickStep:
if (stepBodySTN.getKind() == N_TakeStep) {
op=OP_take;
}
 else {
op=OP_pick;
isPick=true;
symbolTable.pushContext(new Context(moduleTable,errors));
}
;
if (bodyHeirs[1].getKind() == N_QuantBound) {
int quants=1;
int nextTok=2;
while ((nextTok < bodyHeirs.length) && (bodyHeirs[nextTok].getKind() == TLAplusParserConstants.COMMA)) {
quants++;
nextTok=nextTok + 2;
}
;
FormalParamNode[][] params=new FormalParamNode[quants][0];
boolean[] bt=new boolean[quants];
ExprNode[] paramBounds=new ExprNode[quants];
processQuantBoundArgs(bodyHeirs,1,params,bt,paramBounds,cm);
if (isPick) {
pickContext=symbolTable.getContext();
nextTok++;
args=new ExprNode[1];
pushFormalParams(flattenParams(params));
args[0]=generateExpression(bodyHeirs[nextTok],cm);
popFormalParams();
symbolTable.popContext();
}
 else {
args=new ExprNode[0];
}
;
body=new OpApplNode(op,null,args,params,bt,paramBounds,stepBodySTN,cm);
}
 else {
int ids=1;
while ((2 * ids < bodyHeirs.length) && (bodyHeirs[2 * ids].getKind() == TLAplusParserConstants.COMMA)) {
ids++;
}
;
FormalParamNode[] params=new FormalParamNode[ids];
for (int j=0; j < ids; j++) {
params[j]=new FormalParamNode(bodyHeirs[2 * j + 1].getUS(),0,bodyHeirs[2 * j + 1],symbolTable,cm);
}
;
if (isPick) {
pickContext=symbolTable.getContext();
pushFormalParams(params);
args=new ExprNode[1];
args[0]=generateExpression(bodyHeirs[2 * ids + 1],cm);
popFormalParams();
symbolTable.popContext();
}
 else {
args=new ExprNode[0];
}
;
body=new OpApplNode(op,args,params,stepBodySTN,cm);
}
;
break;
case N_WitnessStep:
int ids=1;
while ((2 * ids < bodyHeirs.length) && (bodyHeirs[2 * ids].getKind() == TLAplusParserConstants.COMMA)) {
ids++;
}
;
args=new ExprNode[ids];
for (int j=0; j < ids; j++) {
args[j]=generateExpression(bodyHeirs[2 * j + 1],cm);
}
;
body=new OpApplNode(OP_witness,args,stepBodySTN,cm);
break;
case N_QEDStep:
args=new ExprNode[0];
body=new OpApplNode(OP_qed,args,stepBodySTN,cm);
break;
default :
errors.addAbort(stn.getLocation(),""String_Node_Str"" + heirs[i].getKind());
break;
}
;
if (stepNum != null) {
tadn.construct(true,body,cm,symbolTable,null);
tadn.setLabels(popLabelNodeSet());
if (isSuffices) {
tadn.setSuffices();
}
;
}
;
ProofNode proof=null;
if (stepPfSTN != null) {
if (isAssumeProve && !isSuffices) {
symbolTable.pushContext(assumeContext);
}
;
proof=generateProof(stepPfSTN,cm);
if (isAssumeProve && !isSuffices) {
symbolTable.popContext();
}
;
}
;
if (isAssumeProve && isSuffices) {
numberOfPops++;
symbolTable.pushContext(assumeContext);
}
;
if (isAssumeProve) {
((AssumeProveNode)body).inProof=false;
}
;
TheoremNode thm=new TheoremNode(stepBodySTN,body,cm,proof,tadn);
thm.stn=pfStepSTN;
thm.suffices=isSuffices;
steps[i - offset]=thm;
}
;
if (makePfNumNode) {
OpDefNode nodeMadeOnlyToBePutInSymbolTable=new OpDefNode(stepNum,pfNumNode,cm,symbolTable,pfStepSTN);
nodeMadeOnlyToBePutInSymbolTable.setLabels(popLabelNodeSet());
}
if (isPick) {
Enumeration e=pickContext.content();
while (e.hasMoreElements()) {
SymbolNode sym=((Context.Pair)(e.nextElement())).getSymbol();
symbolTable.addSymbol(sym.getName(),sym);
}
}
}
;
InstanceNode[] insts=new InstanceNode[iVec.size()];
for (int i=0; i < insts.length; i++) {
insts[i]=(InstanceNode)iVec.elementAt(i);
}
;
for (int i=0; i < numberOfPops; i++) {
symbolTable.popContext();
}
;
symbolTable.popContext();
return new NonLeafProofNode(stn,steps,insts,pfCtxt);
}","private final ProofNode generateProof(TreeNode stn,ModuleNode cm) throws AbortException {
  int numberOfPops=0;
  if (stn.getKind() == N_TerminalProof) {
    return generateLeafProof(stn,cm);
  }
  ;
  Context pfCtxt=new Context(moduleTable,errors);
  symbolTable.pushContext(pfCtxt);
  TreeNode heirs[]=stn.heirs();
  int offset=0;
  if (heirs[0].getKind() == TLAplusParserConstants.PROOF) {
    offset=1;
  }
  ;
  LevelNode[] steps=new LevelNode[heirs.length - offset];
  Vector iVec=new Vector();
  boolean prevIsInfix=false;
  ExprNode prevRHS=null;
  for (int i=offset; i < heirs.length; i++) {
    boolean isAssumeProve=false;
    boolean isSuffices=false;
    Context assumeContext=null;
    boolean isPick=false;
    Context pickContext=null;
    TreeNode pfStepSTN=heirs[i];
    TreeNode stepNumSTN=pfStepSTN.heirs()[0];
    TreeNode stepBodySTN=pfStepSTN.heirs()[1];
    TreeNode stepPfSTN=null;
    if (pfStepSTN.heirs().length > 2) {
      stepPfSTN=pfStepSTN.heirs()[2];
    }
    ;
    LevelNode pfNumNode=null;
    boolean makePfNumNode=true;
    UniqueString stepNum=null;
switch (stepNumSTN.getKind()) {
case TLAplusParserConstants.ProofImplicitStepLexeme:
case TLAplusParserConstants.ProofStepLexeme:
      stepNum=stepNumSTN.getUS();
    break;
case TLAplusParserConstants.ProofStepDotLexeme:
  String stNum=stepNumSTN.getUS().toString();
stepNum=UniqueString.uniqueStringOf(stNum.substring(0,stNum.indexOf(""String_Node_Str"")));
break;
default :
makePfNumNode=false;
break;
}
;
if (stepNum != null) {
pushLS();
}
;
ThmOrAssumpDefNode tadn=null;
if (stepNum != null) {
tadn=new ThmOrAssumpDefNode(stepNum,stepNumSTN);
}
;
int stepKind=stepBodySTN.getKind();
if (stepKind != N_AssertStep) {
prevIsInfix=false;
}
;
switch (stepKind) {
case N_DefStep:
TreeNode[] defSTNs=stepBodySTN.heirs();
int defOffSet=0;
if (defSTNs[0].getKind() == DEFINE) {
defOffSet=1;
}
;
OpDefNode[] defs=new OpDefNode[defSTNs.length - defOffSet];
for (int j=defOffSet; j < defSTNs.length; j++) {
TreeNode defSTN=defSTNs[j];
;
Vector vec=new Vector();
switch (defSTN.getKind()) {
case N_FunctionDefinition:
processFunction(defSTN,vec,cm);
break;
case N_ModuleDefinition:
Vector defsVec=new Vector();
vec.addElement(processModuleDefinition(defSTN,defsVec,iVec,cm));
break;
case N_OperatorDefinition:
processOperator(defSTN,vec,cm);
break;
}
;
defs[j - defOffSet]=(OpDefNode)vec.elementAt(0);
}
;
pfNumNode=new DefStepNode(stepBodySTN,stepNum,defs);
steps[i - offset]=pfNumNode;
break;
case N_UseOrHide:
UseOrHideNode uohn=generateUseOrHide(stepBodySTN,cm);
uohn.stn=pfStepSTN;
uohn.setStepName(stepNum);
if (uohn.facts.length + uohn.defs.length == 0) {
errors.addError(stepBodySTN.getLocation(),""String_Node_Str"");
}
;
uohn.factCheck();
pfNumNode=uohn;
steps[i - offset]=pfNumNode;
break;
case N_NonLocalInstance:
InstanceNode inst=generateInstance(stepBodySTN,cm,false);
inst.setStepName(stepNum);
pfNumNode=inst;
steps[i - offset]=pfNumNode;
break;
default :
makePfNumNode=false;
TreeNode[] bodyHeirs=stepBodySTN.heirs();
LevelNode body=null;
UniqueString op=null;
ExprNode[] args;
switch (stepBodySTN.getKind()) {
case N_AssertStep:
int bodyNext=0;
if (bodyHeirs[0].getKind() == TLAplusParserConstants.SUFFICES) {
bodyNext=1;
isSuffices=true;
}
;
if (bodyHeirs[bodyNext].getKind() == N_AssumeProve) {
isAssumeProve=true;
symbolTable.pushContext(new Context(moduleTable,errors));
currentGoal=tadn;
body=generateAssumeProve(bodyHeirs[bodyNext],cm);
if (isSuffices) {
((AssumeProveNode)body).setSuffices();
}
;
currentGoal=null;
assumeContext=symbolTable.getContext();
symbolTable.popContext();
prevIsInfix=false;
}
 else {
TreeNode curExpr=bodyHeirs[bodyNext];
if (isSuffices) {
args=new ExprNode[1];
args[0]=generateExpression(curExpr,cm);
body=new OpApplNode(OP_suffices,args,stepBodySTN,cm);
}
 else {
SyntaxTreeNode curLHS=null;
if (curExpr.getKind() == N_InfixExpr) {
curLHS=(SyntaxTreeNode)curExpr.heirs()[0];
}
;
if (prevIsInfix && (curLHS != null) && (curLHS.heirs().length > 0)&& (((SyntaxTreeNode)curLHS.heirs()[0]).heirs().length == 0)&& (curLHS.heirs()).length > 1 && (curLHS.heirs()[1].getKind() == IDENTIFIER) && (curLHS.heirs()[1].getUS() == AtUS)) {
TreeNode[] children=curExpr.heirs();
GenID genID=generateGenID(children[1],cm);
ExprNode[] sns=new ExprNode[2];
SymbolNode opn=symbolTable.resolveSymbol(Operators.resolveSynonym(genID.getCompoundIDUS()));
if (opn == null) {
errors.addError(curExpr.getLocation(),""String_Node_Str"" + genID.getCompoundIDUS() + ""String_Node_Str"");
return null;
}
;
sns[1]=generateExpression(children[2],cm);
ExprNode[] nopArgs=new ExprNode[1];
nopArgs[0]=prevRHS;
sns[0]=new OpApplNode(OP_nop,nopArgs,curLHS,cm);
body=new OpApplNode(opn,sns,curExpr,cm);
}
 else {
body=generateExpression(curExpr,cm);
}
;
prevIsInfix=false;
if ((curLHS != null) && (body != null) && (body.getKind() == OpApplKind)&& (((OpApplNode)body).getArgs().length > 1)) {
prevIsInfix=true;
prevRHS=(ExprNode)((OpApplNode)body).getArgs()[1];
}
}
}
;
break;
case N_HaveStep:
case N_CaseStep:
if (stepBodySTN.getKind() == N_HaveStep) {
op=OP_have;
}
 else {
op=OP_pfcase;
}
;
args=new ExprNode[1];
args[0]=generateExpression(bodyHeirs[1],cm);
body=new OpApplNode(op,args,stepBodySTN,cm);
break;
case N_TakeStep:
case N_PickStep:
if (stepBodySTN.getKind() == N_TakeStep) {
op=OP_take;
}
 else {
op=OP_pick;
isPick=true;
symbolTable.pushContext(new Context(moduleTable,errors));
}
;
if (bodyHeirs[1].getKind() == N_QuantBound) {
int quants=1;
int nextTok=2;
while ((nextTok < bodyHeirs.length) && (bodyHeirs[nextTok].getKind() == TLAplusParserConstants.COMMA)) {
quants++;
nextTok=nextTok + 2;
}
;
FormalParamNode[][] params=new FormalParamNode[quants][0];
boolean[] bt=new boolean[quants];
ExprNode[] paramBounds=new ExprNode[quants];
processQuantBoundArgs(bodyHeirs,1,params,bt,paramBounds,cm);
if (isPick) {
pickContext=symbolTable.getContext();
nextTok++;
args=new ExprNode[1];
pushFormalParams(flattenParams(params));
args[0]=generateExpression(bodyHeirs[nextTok],cm);
popFormalParams();
symbolTable.popContext();
}
 else {
args=new ExprNode[0];
}
;
body=new OpApplNode(op,null,args,params,bt,paramBounds,stepBodySTN,cm);
}
 else {
int ids=1;
while ((2 * ids < bodyHeirs.length) && (bodyHeirs[2 * ids].getKind() == TLAplusParserConstants.COMMA)) {
ids++;
}
;
FormalParamNode[] params=new FormalParamNode[ids];
for (int j=0; j < ids; j++) {
params[j]=new FormalParamNode(bodyHeirs[2 * j + 1].getUS(),0,bodyHeirs[2 * j + 1],symbolTable,cm);
}
;
if (isPick) {
pickContext=symbolTable.getContext();
pushFormalParams(params);
args=new ExprNode[1];
args[0]=generateExpression(bodyHeirs[2 * ids + 1],cm);
popFormalParams();
symbolTable.popContext();
}
 else {
args=new ExprNode[0];
}
;
body=new OpApplNode(op,args,params,stepBodySTN,cm);
}
;
break;
case N_WitnessStep:
int ids=1;
while ((2 * ids < bodyHeirs.length) && (bodyHeirs[2 * ids].getKind() == TLAplusParserConstants.COMMA)) {
ids++;
}
;
args=new ExprNode[ids];
for (int j=0; j < ids; j++) {
args[j]=generateExpression(bodyHeirs[2 * j + 1],cm);
}
;
body=new OpApplNode(OP_witness,args,stepBodySTN,cm);
break;
case N_QEDStep:
args=new ExprNode[0];
body=new OpApplNode(OP_qed,args,stepBodySTN,cm);
break;
default :
errors.addAbort(stn.getLocation(),""String_Node_Str"" + heirs[i].getKind());
break;
}
;
if (stepNum != null) {
tadn.construct(true,body,cm,symbolTable,null);
tadn.setLabels(popLabelNodeSet());
if (isSuffices) {
tadn.setSuffices();
}
;
}
;
ProofNode proof=null;
if (stepPfSTN != null) {
if (isAssumeProve && !isSuffices) {
symbolTable.pushContext(assumeContext);
}
;
proof=generateProof(stepPfSTN,cm);
if (isAssumeProve && !isSuffices) {
symbolTable.popContext();
}
;
}
;
if (isAssumeProve && isSuffices) {
numberOfPops++;
symbolTable.pushContext(assumeContext);
}
;
if (isAssumeProve) {
((AssumeProveNode)body).inProof=false;
}
;
TheoremNode thm=new TheoremNode(stepBodySTN,body,cm,proof,tadn);
thm.stn=pfStepSTN;
thm.suffices=isSuffices;
steps[i - offset]=thm;
}
;
if (makePfNumNode) {
OpDefNode nodeMadeOnlyToBePutInSymbolTable=new OpDefNode(stepNum,pfNumNode,cm,symbolTable,pfStepSTN);
nodeMadeOnlyToBePutInSymbolTable.setLabels(popLabelNodeSet());
}
if (isPick) {
Enumeration e=pickContext.content();
while (e.hasMoreElements()) {
SymbolNode sym=((Context.Pair)(e.nextElement())).getSymbol();
symbolTable.addSymbol(sym.getName(),sym);
}
}
}
;
InstanceNode[] insts=new InstanceNode[iVec.size()];
for (int i=0; i < insts.length; i++) {
insts[i]=(InstanceNode)iVec.elementAt(i);
}
;
for (int i=0; i < numberOfPops; i++) {
Context topContext=symbolTable.getContext();
Enumeration e=topContext.content();
while (e.hasMoreElements()) {
SymbolNode sym=((Context.Pair)(e.nextElement())).getSymbol();
pfCtxt.addSymbolToContext(sym.getName(),sym);
}
symbolTable.popContext();
}
;
symbolTable.popContext();
return new NonLeafProofNode(stn,steps,insts,pfCtxt);
}",0.9852561528311627
135971,"/** 
 * Returns the   {@link LevelNode} in the tree rooted at levelNode that is the innermoststep such that lineNum is between the begin and end lines of the step or its proof. If there is more than one step or proof on lineNum, then this method returns the step that is first on lineNum (or whose proof is first on lineNum). Returns null if no such node found. Assumes that levelNode is one of {@link UseOrHideNode}{@link InstanceNode}{@link TheoremNode}{@link DefStepNode}If that is not true, this method returns null. In this example: line 10: <2>1. X line 11: \* The following proof is simple line 12:    <3>1. Y line 13:       OBVIOUS <3>2. Z if lineNum = 10, this method returns <2>1. If lineNum = 11, this method again returns <2>1. If lineNum = 12, this method returns <3>1. If lineNum = 13, this method again returns <3>1.
 * @param levelNode
 * @param lineNum
 * @return
 */
public static LevelNode getLevelNodeFromTree(LevelNode levelNode,int lineNum){
  int nodeBeginLine=levelNode.getLocation().beginLine();
  int nodeEndLine=0;
  if (levelNode instanceof TheoremNode) {
    nodeEndLine=((TheoremNode)levelNode).getTheorem().getLocation().endLine();
  }
 else   if (levelNode instanceof UseOrHideNode || levelNode instanceof InstanceNode || levelNode instanceof DefStepNode) {
    nodeEndLine=levelNode.getLocation().endLine();
  }
 else {
    return null;
  }
  if (nodeBeginLine <= lineNum && nodeEndLine >= lineNum) {
    return levelNode;
  }
  if (levelNode instanceof TheoremNode) {
    TheoremNode theoremNode=(TheoremNode)levelNode;
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      Location proofLoc=proof.getLocation();
      if (lineNum >= nodeBeginLine && lineNum <= proofLoc.endLine()) {
        if (proof instanceof NonLeafProofNode) {
          NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
          LevelNode[] steps=nonLeafProof.getSteps();
          for (int i=0; i < steps.length; i++) {
            LevelNode node=getLevelNodeFromTree(steps[i],lineNum);
            if (node != null) {
              return node;
            }
          }
          return levelNode;
        }
 else {
          return levelNode;
        }
      }
    }
  }
  return null;
}","/** 
 * Returns the   {@link LevelNode} in the tree rooted at levelNode that is the innermoststep such that lineNum is between the begin line of the step and the end line of the proof if there is a proof or the begin and end lines of the step if there is no proof. If there is more than one step or proof on lineNum, then this method returns the step that is first on lineNum (or whose proof is first on lineNum). Returns null if no such node found. Assumes that levelNode is one of {@link UseOrHideNode}{@link InstanceNode}{@link TheoremNode}{@link DefStepNode}If that is not true, this method returns null. In this example: line 10: <2>1. X line 11: \* The following proof is simple line 12:    <3>1. Y line 13:       OBVIOUS <3>2. Z if lineNum = 10, this method returns <2>1. If lineNum = 11, this method again returns <2>1. If lineNum = 12, this method returns <3>1. If lineNum = 13, this method again returns <3>1.
 * @param levelNode
 * @param lineNum
 * @return
 */
public static LevelNode getLevelNodeFromTree(LevelNode levelNode,int lineNum){
  int nodeBeginLine=levelNode.getLocation().beginLine();
  int nodeEndLine=0;
  if (levelNode instanceof TheoremNode) {
    nodeEndLine=((TheoremNode)levelNode).getTheorem().getLocation().endLine();
  }
 else   if (levelNode instanceof UseOrHideNode || levelNode instanceof InstanceNode || levelNode instanceof DefStepNode) {
    nodeEndLine=levelNode.getLocation().endLine();
  }
 else {
    return null;
  }
  if (nodeBeginLine <= lineNum && nodeEndLine >= lineNum) {
    return levelNode;
  }
  if (levelNode instanceof TheoremNode) {
    TheoremNode theoremNode=(TheoremNode)levelNode;
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      Location proofLoc=proof.getLocation();
      if (lineNum >= nodeEndLine && lineNum <= proofLoc.endLine()) {
        if (proof instanceof NonLeafProofNode) {
          NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
          LevelNode[] steps=nonLeafProof.getSteps();
          for (int i=0; i < steps.length; i++) {
            LevelNode node=getLevelNodeFromTree(steps[i],lineNum);
            if (node != null) {
              return node;
            }
          }
          return levelNode;
        }
 else {
          return levelNode;
        }
      }
    }
  }
  return null;
}",0.964726631393298
135972,"/** 
 * If parseResult's status is not equal to PARSED, returns null.  Else, it tries to find a   {@link LevelNode}representing a proof step or a top level USE/HIDE node in module moduleName ""at"" the point textSelection.  More precisely, the caret is at a LevelNode if the level node is the innermost proof step or USE/HIDE node whose step or proof contains the line with the caret and that is first on the line containing the caret. That is, if there is more than one proof and/or step on the line with the caret, this method returns the first on the line. The method assumes that document is the document for the module.
 * @param parseResult
 * @param moduleName
 * @param textSelection
 * @param document
 * @return
 */
public static LevelNode getPfStepOrUseHideFromMod(ParseResult parseResult,String moduleName,ITextSelection textSelection,IDocument document){
  try {
    if ((parseResult == null) || (parseResult.getStatus() != IParseConstants.PARSED)) {
      return null;
    }
    ModuleNode module=parseResult.getSpecObj().getExternalModuleTable().getModuleNode(UniqueString.uniqueStringOf(moduleName));
    if (module == null) {
      return null;
    }
    LevelNode[] topLevelNodes=module.getTopLevel();
    for (int i=0; i < topLevelNodes.length; i++) {
      if (topLevelNodes[i].getLocation().source().equals(moduleName)) {
        LevelNode node=getLevelNodeFromTree(topLevelNodes[i],document.getLineOfOffset(textSelection.getOffset()) + 1);
        if (node != null) {
          return node;
        }
      }
    }
  }
 catch (  BadLocationException e) {
    Activator.logError(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * If parseResult's status is not equal to PARSED, returns null.  Else, it tries to find a   {@link LevelNode}representing a proof step or a top level USE/HIDE node in module moduleName ""at"" the point textSelection.  More precisely, the caret is at a LevelNode if the level node is the innermost proof step or USE/HIDE node whose step or proof contains the line with the caret and that is first on the line containing the caret. That is, if there is more than one proof and/or step on the line with the caret, this method returns the first on the line. The method assumes that document is the document for the module. Returns null if no step is found.
 * @param parseResult
 * @param moduleName
 * @param textSelection
 * @param document
 * @return
 */
public static LevelNode getPfStepOrUseHideFromMod(ParseResult parseResult,String moduleName,ITextSelection textSelection,IDocument document){
  try {
    if ((parseResult == null) || (parseResult.getStatus() != IParseConstants.PARSED)) {
      return null;
    }
    ModuleNode module=parseResult.getSpecObj().getExternalModuleTable().getModuleNode(UniqueString.uniqueStringOf(moduleName));
    return getPfStepOrUseHideFromModuleNode(module,document.getLineOfOffset(textSelection.getOffset()) + 1);
  }
 catch (  BadLocationException e) {
    Activator.logError(""String_Node_Str"",e);
  }
  return null;
}",0.8591408591408591
135973,"/** 
 * Creates a SANY marker for levelNode if it is a   {@link TheoremNode} or a {@link UseOrHideNode}. If it has a proof, this method recursively calls it self on all children. The SANY location attribute for these markers is a string representation of the location of the node if it is a   {@link UseOrHideNode} and the string representation of the location of the node{@link TheoremNode#getTheorem()} if it is a {@link TheoremNode}. The methods   {@link #locToString(Location)} and {@link #stringToLoc(String)} convert from{@link Location} to Strings and back.See  {@link ProverHelper#SANY_MARKER} for a description ofthese markers.
 * @param theoremNode
 * @throws CoreException 
 */
public static void createSANYMarkersForTree(LevelNode levelNode,IResource module) throws CoreException {
  if (levelNode == null) {
    return;
  }
  if (levelNode instanceof UseOrHideNode || levelNode instanceof TheoremNode) {
    IMarker marker=module.createMarker(SANY_MARKER);
    if (levelNode instanceof UseOrHideNode) {
      marker.setAttribute(SANY_LOC_ATR,locToString(levelNode.getLocation()));
    }
 else {
      marker.setAttribute(SANY_LOC_ATR,locToString(((TheoremNode)levelNode).getTheorem().getLocation()));
    }
  }
  if (levelNode instanceof TheoremNode) {
    TheoremNode theoremNode=(TheoremNode)levelNode;
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      if (proof instanceof NonLeafProofNode) {
        NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
        LevelNode[] steps=nonLeafProof.getSteps();
        for (int i=0; i < steps.length; i++) {
          if (steps[i] instanceof TheoremNode) {
            createSANYMarkersForTree((TheoremNode)steps[i],module);
          }
        }
      }
    }
  }
}","/** 
 * Creates a SANY marker for levelNode if it is a   {@link TheoremNode} or a {@link UseOrHideNode}. If it has a proof, this method recursively calls it self on all children. The SANY location attribute for these markers is a string representation of the location of the node if it is a   {@link UseOrHideNode} and the string representation of the location of the node{@link TheoremNode#getTheorem()} if it is a {@link TheoremNode}. The methods   {@link #locToString(Location)} and {@link #stringToLoc(String)} convert from{@link Location} to Strings and back.See  {@link ProverHelper#SANY_MARKER} for a description ofthese markers.
 * @param theoremNode
 * @throws CoreException 
 */
public static void createSANYMarkersForTree(LevelNode levelNode,IResource module) throws CoreException {
  if (levelNode == null) {
    return;
  }
  if (levelNode instanceof UseOrHideNode || levelNode instanceof TheoremNode) {
    IMarker marker=module.createMarker(SANY_MARKER);
    Location locForAttr;
    if (levelNode instanceof UseOrHideNode) {
      locForAttr=levelNode.getLocation();
    }
 else {
      locForAttr=((TheoremNode)levelNode).getTheorem().getLocation();
    }
    marker.setAttribute(SANY_LOC_ATR,locToString(locForAttr));
    IRegion locRegion=AdapterFactory.locationToRegion(locForAttr);
    marker.setAttribute(IMarker.CHAR_START,locRegion.getOffset());
    marker.setAttribute(IMarker.CHAR_END,locRegion.getOffset() + locRegion.getLength() - 1);
  }
  if (levelNode instanceof TheoremNode) {
    TheoremNode theoremNode=(TheoremNode)levelNode;
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      if (proof instanceof NonLeafProofNode) {
        NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
        LevelNode[] steps=nonLeafProof.getSteps();
        for (int i=0; i < steps.length; i++) {
          createSANYMarkersForTree(steps[i],module);
        }
      }
    }
  }
}",0.8510754151919412
135974,"/** 
 * Parses the location string returned by the prover into an instance of   {@link Location}. Null if parsing is unsuccessful.
 * @param locString
 * @return
 */
protected static Location parseLocation(String locString,String moduleName){
  try {
    String[] coordinates=locString.split(""String_Node_Str"");
    Assert.isTrue(coordinates.length >= 4,""String_Node_Str"" + locString);
    return new Location(UniqueString.uniqueStringOf(moduleName),Integer.parseInt(coordinates[0]),Integer.parseInt(coordinates[1]),Integer.parseInt(coordinates[2]),Integer.parseInt(coordinates[3]));
  }
 catch (  NumberFormatException e) {
    ProverUIActivator.logError(""String_Node_Str"" + locString,e);
  }
  return null;
}","/** 
 * Parses the location string returned by the prover into an instance of   {@link Location}. Null if parsing is unsuccessful.
 * @param locString
 * @return
 */
protected static Location parseLocation(String locString,String moduleName){
  try {
    String[] coordinates=locString.split(""String_Node_Str"");
    Assert.isTrue(coordinates.length >= 4,""String_Node_Str"" + locString);
    return new Location(UniqueString.uniqueStringOf(moduleName),Integer.parseInt(coordinates[0]),Integer.parseInt(coordinates[1]),Integer.parseInt(coordinates[2]),Integer.parseInt(coordinates[3]) - 1);
  }
 catch (  NumberFormatException e) {
    ProverUIActivator.logError(""String_Node_Str"" + locString,e);
  }
  return null;
}",0.9971910112359552
135975,"/** 
 * Creates a SANY marker for levelNode if it is a   {@link TheoremNode} or a {@link UseOrHideNode}. If it has a proof, this method recursively calls it self on all children. The SANY location attribute for these markers is a string representation of the location of the node if it is a   {@link UseOrHideNode} and the string representation of the location of the node{@link TheoremNode#getTheorem()} if it is a {@link TheoremNode}. The methods   {@link #locToString(Location)} and {@link #stringToLoc(String)} convert from{@link Location} to Strings and back.See  {@link ProverHelper#SANY_MARKER} for a description ofthese markers.
 * @param theoremNode
 * @throws CoreException 
 */
public static void createSANYMarkersForTree(LevelNode levelNode,IResource module) throws CoreException {
  if (levelNode == null) {
    return;
  }
  if (levelNode instanceof UseOrHideNode || levelNode instanceof TheoremNode) {
    IMarker marker=module.createMarker(SANY_MARKER);
    Location locForAttr;
    if (levelNode instanceof UseOrHideNode) {
      locForAttr=levelNode.getLocation();
    }
 else {
      locForAttr=((TheoremNode)levelNode).getTheorem().getLocation();
    }
    marker.setAttribute(SANY_LOC_ATR,locToString(locForAttr));
    IRegion locRegion=AdapterFactory.locationToRegion(locForAttr);
    marker.setAttribute(IMarker.CHAR_START,locRegion.getOffset());
    marker.setAttribute(IMarker.CHAR_END,locRegion.getOffset() + locRegion.getLength() - 1);
  }
  if (levelNode instanceof TheoremNode) {
    TheoremNode theoremNode=(TheoremNode)levelNode;
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      if (proof instanceof NonLeafProofNode) {
        NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
        LevelNode[] steps=nonLeafProof.getSteps();
        for (int i=0; i < steps.length; i++) {
          createSANYMarkersForTree(steps[i],module);
        }
      }
    }
  }
}","/** 
 * Creates a SANY marker for levelNode if it is a   {@link TheoremNode} or a {@link UseOrHideNode}. If it has a proof, this method recursively calls it self on all children. The SANY location attribute for these markers is a string representation of the location of the node if it is a   {@link UseOrHideNode} and the string representation of the location of the node{@link TheoremNode#getTheorem()} if it is a {@link TheoremNode}. The methods   {@link #locToString(Location)} and {@link #stringToLoc(String)} convert from{@link Location} to Strings and back.See  {@link ProverHelper#SANY_MARKER} for a description ofthese markers.
 * @param theoremNode
 * @throws CoreException 
 */
public static void createSANYMarkersForTree(LevelNode levelNode,IResource module) throws CoreException {
  if (levelNode == null) {
    return;
  }
  if (levelNode instanceof UseOrHideNode || levelNode instanceof TheoremNode) {
    IMarker marker=module.createMarker(SANY_MARKER);
    Location locForAttr;
    if (levelNode instanceof UseOrHideNode) {
      locForAttr=levelNode.getLocation();
    }
 else {
      locForAttr=((TheoremNode)levelNode).getTheorem().getLocation();
    }
    marker.setAttribute(SANY_LOC_ATR,locToString(locForAttr));
    IRegion locRegion=AdapterFactory.locationToRegion(locForAttr);
    marker.setAttribute(IMarker.CHAR_START,locRegion.getOffset());
    marker.setAttribute(IMarker.CHAR_END,locRegion.getOffset() + locRegion.getLength());
  }
  if (levelNode instanceof TheoremNode) {
    TheoremNode theoremNode=(TheoremNode)levelNode;
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      if (proof instanceof NonLeafProofNode) {
        NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
        LevelNode[] steps=nonLeafProof.getSteps();
        for (int i=0; i < steps.length; i++) {
          createSANYMarkersForTree(steps[i],module);
        }
      }
    }
  }
}",0.9989572471324296
135976,"/** 
 * Removes or modifies status markers so that no markers appear on any of the lines from the begin line to the end line of the root. Any markers that are only on those lines are deleted. Any markers that overlap with those lines are shortened so that they do not overlap. If root is a TheoremNode with a proof, then the begin line is root.getLocation().beginLine() and the end line is root.getProof().getLocation().endLine(). For all other cases, the begin line is root.getLocation().beginLine() and the end line is root.getLocation().endLine().
 * @param module
 * @param root
 */
public static void removeStatusFromTree(IFile module,LevelNode root){
  try {
    IDocument document=ResourceHelper.getDocFromFile(module);
    int beginLine=root.getLocation().beginLine() - 1;
    int endLine=root.getLocation().endLine() - 1;
    if (root instanceof TheoremNode && ((TheoremNode)root).getProof() != null) {
      endLine=((TheoremNode)root).getProof().getLocation().endLine() - 1;
    }
    int treeBeginChar=document.getLineOffset(beginLine);
    int treeEndChar=document.getLineOffset(endLine) + document.getLineLength(endLine) - 1;
    IMarker[] markers=module.findMarkers(STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
    for (int i=0; i < markers.length; i++) {
      IMarker oldMarker=markers[i];
      int markerStartChar=oldMarker.getAttribute(IMarker.CHAR_START,-1);
      int markerEndChar=oldMarker.getAttribute(IMarker.CHAR_END,-1);
      if (markerStartChar >= treeBeginChar && markerEndChar <= treeEndChar) {
        oldMarker.delete();
      }
 else       if (markerStartChar < treeBeginChar && markerEndChar >= treeBeginChar && markerEndChar <= treeEndChar) {
        IMarker newMarker=module.createMarker(oldMarker.getType());
        newMarker.setAttribute(IMarker.CHAR_START,markerStartChar);
        newMarker.setAttribute(IMarker.CHAR_END,treeBeginChar - 1);
        oldMarker.delete();
      }
 else       if (markerStartChar < treeBeginChar && markerEndChar > treeEndChar) {
        IMarker beforeMarker=module.createMarker(oldMarker.getType());
        beforeMarker.setAttribute(IMarker.CHAR_START,markerStartChar);
        beforeMarker.setAttribute(IMarker.CHAR_END,treeBeginChar - 1);
        IMarker afterMarker=module.createMarker(oldMarker.getType());
        afterMarker.setAttribute(IMarker.CHAR_START,treeEndChar + 1);
        afterMarker.setAttribute(IMarker.CHAR_END,markerEndChar);
        oldMarker.delete();
      }
 else       if (markerStartChar >= treeBeginChar && markerStartChar <= treeEndChar && markerEndChar > treeEndChar) {
        IMarker newMarker=module.createMarker(oldMarker.getType());
        newMarker.setAttribute(IMarker.CHAR_START,treeEndChar + 1);
        newMarker.setAttribute(IMarker.CHAR_END,markerEndChar);
        oldMarker.delete();
      }
    }
  }
 catch (  CoreException e) {
    ProverUIActivator.logError(""String_Node_Str"" + root,e);
  }
catch (  BadLocationException e) {
    ProverUIActivator.logError(""String_Node_Str"" + root,e);
  }
}","/** 
 * Removes or modifies status markers so that no markers appear on any of the lines from the begin line to the end line of the root. Any markers that are only on those lines are deleted. Any markers that overlap with those lines are shortened so that they do not overlap. If root is a TheoremNode with a proof, then the begin line is root.getLocation().beginLine() and the end line is root.getProof().getLocation().endLine(). For all other cases, the begin line is root.getLocation().beginLine() and the end line is root.getLocation().endLine().
 * @param module
 * @param root
 */
public static void removeStatusFromTree(IFile module,LevelNode root){
  try {
    IDocument document=ResourceHelper.getDocFromFile(module);
    int beginLine=root.getLocation().beginLine() - 1;
    int endLine=root.getLocation().endLine() - 1;
    if (root instanceof TheoremNode && ((TheoremNode)root).getProof() != null) {
      endLine=((TheoremNode)root).getProof().getLocation().endLine() - 1;
    }
    int treeBeginChar=document.getLineOffset(beginLine);
    int treeEndChar=document.getLineOffset(endLine) + document.getLineLength(endLine);
    IMarker[] markers=module.findMarkers(STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
    for (int i=0; i < markers.length; i++) {
      IMarker oldMarker=markers[i];
      int markerStartChar=oldMarker.getAttribute(IMarker.CHAR_START,-1);
      int markerEndChar=oldMarker.getAttribute(IMarker.CHAR_END,-1);
      if (markerStartChar >= treeBeginChar && markerEndChar <= treeEndChar) {
        oldMarker.delete();
      }
 else       if (markerStartChar < treeBeginChar && markerEndChar >= treeBeginChar && markerEndChar <= treeEndChar) {
        IMarker newMarker=module.createMarker(oldMarker.getType());
        newMarker.setAttribute(IMarker.CHAR_START,markerStartChar);
        newMarker.setAttribute(IMarker.CHAR_END,treeBeginChar - 1);
        oldMarker.delete();
      }
 else       if (markerStartChar < treeBeginChar && markerEndChar > treeEndChar) {
        IMarker beforeMarker=module.createMarker(oldMarker.getType());
        beforeMarker.setAttribute(IMarker.CHAR_START,markerStartChar);
        beforeMarker.setAttribute(IMarker.CHAR_END,treeBeginChar - 1);
        IMarker afterMarker=module.createMarker(oldMarker.getType());
        afterMarker.setAttribute(IMarker.CHAR_START,treeEndChar + 1);
        afterMarker.setAttribute(IMarker.CHAR_END,markerEndChar);
        oldMarker.delete();
      }
 else       if (markerStartChar >= treeBeginChar && markerStartChar <= treeEndChar && markerEndChar > treeEndChar) {
        IMarker newMarker=module.createMarker(oldMarker.getType());
        newMarker.setAttribute(IMarker.CHAR_START,treeEndChar + 1);
        newMarker.setAttribute(IMarker.CHAR_END,markerEndChar);
        oldMarker.delete();
      }
    }
  }
 catch (  CoreException e) {
    ProverUIActivator.logError(""String_Node_Str"" + root,e);
  }
catch (  BadLocationException e) {
    ProverUIActivator.logError(""String_Node_Str"" + root,e);
  }
}",0.9993362097577164
135977,"/** 
 * Installs a new marker on the obligation in the message or updates the existing marker on that obligation (if there is one) with the information contained in message. The message location should be for a module in the currently opened spec. If no such module exists, this method returns null. Returns the marker created or updated.
 * @param message must not be null
 */
public static IMarker newObligationStatus(ObligationStatusMessage message){
  Location location=message.getLocation();
  IResource module=ResourceHelper.getResourceByModuleName(location.source());
  if (module != null && module instanceof IFile && module.exists()) {
    FileEditorInput fileEditorInput=new FileEditorInput((IFile)module);
    FileDocumentProvider fileDocumentProvider=new FileDocumentProvider();
    try {
      IMarker[] markers=module.findMarkers(OBLIGATION_MARKER,false,IResource.DEPTH_ZERO);
      IMarker marker=null;
      for (int i=0; i < markers.length; i++) {
        if (markers[i].getAttribute(OBLIGATION_ID,-1) == message.getID()) {
          marker=markers[i];
          break;
        }
      }
      if (marker == null) {
        marker=module.createMarker(OBLIGATION_MARKER);
        marker.setAttribute(OBLIGATION_ID,message.getID());
      }
      marker.setAttribute(OBLIGATION_METHOD,message.getMethod());
      marker.setAttribute(OBLIGATION_STATUS,message.getStatus());
      marker.setAttribute(OBLIGATION_STRING,message.getObString());
      fileDocumentProvider.connect(fileEditorInput);
      IDocument document=fileDocumentProvider.getDocument(fileEditorInput);
      IRegion obRegion=AdapterFactory.locationToRegion(document,location);
      marker.setAttribute(IMarker.CHAR_START,obRegion.getOffset());
      marker.setAttribute(IMarker.CHAR_END,obRegion.getOffset() + obRegion.getLength() - 1);
      return marker;
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
 finally {
      fileDocumentProvider.disconnect(fileEditorInput);
    }
  }
  return null;
}","/** 
 * Installs a new marker on the obligation in the message or updates the existing marker on that obligation (if there is one) with the information contained in message. The message location should be for a module in the currently opened spec. If no such module exists, this method returns null. Returns the marker created or updated.
 * @param message must not be null
 */
public static IMarker newObligationStatus(ObligationStatusMessage message){
  Location location=message.getLocation();
  IResource module=ResourceHelper.getResourceByModuleName(location.source());
  if (module != null && module instanceof IFile && module.exists()) {
    FileEditorInput fileEditorInput=new FileEditorInput((IFile)module);
    FileDocumentProvider fileDocumentProvider=new FileDocumentProvider();
    try {
      IMarker[] markers=module.findMarkers(OBLIGATION_MARKER,false,IResource.DEPTH_ZERO);
      IMarker marker=null;
      for (int i=0; i < markers.length; i++) {
        if (markers[i].getAttribute(OBLIGATION_ID,-1) == message.getID()) {
          marker=markers[i];
          break;
        }
      }
      if (marker == null) {
        marker=module.createMarker(OBLIGATION_MARKER);
        marker.setAttribute(OBLIGATION_ID,message.getID());
      }
      marker.setAttribute(OBLIGATION_METHOD,message.getMethod());
      marker.setAttribute(OBLIGATION_STATUS,message.getStatus());
      marker.setAttribute(OBLIGATION_STRING,message.getObString());
      fileDocumentProvider.connect(fileEditorInput);
      IDocument document=fileDocumentProvider.getDocument(fileEditorInput);
      IRegion obRegion=AdapterFactory.locationToRegion(document,location);
      marker.setAttribute(IMarker.CHAR_START,obRegion.getOffset());
      marker.setAttribute(IMarker.CHAR_END,obRegion.getOffset() + obRegion.getLength());
      return marker;
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
 finally {
      fileDocumentProvider.disconnect(fileEditorInput);
    }
  }
  return null;
}",0.9990352146647372
135978,"/** 
 * Should be called to update the status of a proof step. Searches for an existing SANY marker with the same location as the status. If found, replaces this marker with the appropriate step status marker. If a SANY marker is not found, this is a bug and will be printed out on the console.
 * @param status
 */
public static void newStepStatus(ProofStepStatus status){
  if (status == null) {
    return;
  }
  Location location=status.getLocation();
  IResource module=ResourceHelper.getResourceByModuleName(location.source());
  if (module != null && module instanceof IFile && module.exists()) {
    IMarker sanyMarker=findSANYMarker(module,location);
    try {
      IMarker newMarker=module.createMarker(statusStringToMarkerType(status.getStatus()));
      Map markerAttributes=new HashMap(2);
      int newCharStart;
      int newCharEnd;
      if (sanyMarker != null) {
        newCharStart=sanyMarker.getAttribute(IMarker.CHAR_START,0);
        newCharEnd=sanyMarker.getAttribute(IMarker.CHAR_END,0);
      }
 else {
        ProverUIActivator.logDebug(""String_Node_Str"" + location + ""String_Node_Str"");
        IRegion messageRegion=AdapterFactory.locationToRegion(location);
        newCharStart=messageRegion.getOffset();
        newCharEnd=messageRegion.getOffset() + messageRegion.getLength() - 1;
      }
      IMarker[] existingMarkers=module.findMarkers(ProverHelper.STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
      for (int i=0; i < existingMarkers.length; i++) {
        IMarker existingMarker=existingMarkers[i];
        int existingCharStart=existingMarker.getAttribute(IMarker.CHAR_START,-1);
        int existingCharEnd=existingMarker.getAttribute(IMarker.CHAR_END,-1);
        if (existingCharStart < newCharEnd && existingCharEnd > newCharStart) {
          existingMarker.delete();
        }
      }
      markerAttributes.put(IMarker.CHAR_START,new Integer(newCharStart));
      markerAttributes.put(IMarker.CHAR_END,new Integer(newCharEnd));
      newMarker.setAttributes(markerAttributes);
    }
 catch (    CoreException e) {
      ProverUIActivator.logError(""String_Node_Str"",e);
    }
  }
 else {
    ProverUIActivator.logDebug(""String_Node_Str"" + ""String_Node_Str"" + status.getStatus() + ""String_Node_Str""+ location);
  }
}","/** 
 * Should be called to update the status of a proof step. Searches for an existing SANY marker with the same location as the status. If found, replaces this marker with the appropriate step status marker. If a SANY marker is not found, this is a bug and will be printed out on the console.
 * @param status
 */
public static void newStepStatus(ProofStepStatus status){
  if (status == null) {
    return;
  }
  Location location=status.getLocation();
  IResource module=ResourceHelper.getResourceByModuleName(location.source());
  if (module != null && module instanceof IFile && module.exists()) {
    IMarker sanyMarker=findSANYMarker(module,location);
    try {
      String markerType=statusStringToMarkerType(status.getStatus());
      if (markerType == null) {
        ProverUIActivator.logDebug(""String_Node_Str"" + status.getStatus());
        return;
      }
      IMarker newMarker=module.createMarker(markerType);
      Map markerAttributes=new HashMap(2);
      int newCharStart;
      int newCharEnd;
      if (sanyMarker != null) {
        newCharStart=sanyMarker.getAttribute(IMarker.CHAR_START,0);
        newCharEnd=sanyMarker.getAttribute(IMarker.CHAR_END,0);
      }
 else {
        ProverUIActivator.logDebug(""String_Node_Str"" + location + ""String_Node_Str"");
        IRegion messageRegion=AdapterFactory.locationToRegion(location);
        newCharStart=messageRegion.getOffset();
        newCharEnd=messageRegion.getOffset() + messageRegion.getLength();
      }
      IMarker[] existingMarkers=module.findMarkers(ProverHelper.STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
      for (int i=0; i < existingMarkers.length; i++) {
        IMarker existingMarker=existingMarkers[i];
        int existingCharStart=existingMarker.getAttribute(IMarker.CHAR_START,-1);
        int existingCharEnd=existingMarker.getAttribute(IMarker.CHAR_END,-1);
        if (existingCharStart < newCharEnd && existingCharEnd > newCharStart) {
          existingMarker.delete();
        }
      }
      markerAttributes.put(IMarker.CHAR_START,new Integer(newCharStart));
      markerAttributes.put(IMarker.CHAR_END,new Integer(newCharEnd));
      newMarker.setAttributes(markerAttributes);
    }
 catch (    CoreException e) {
      ProverUIActivator.logError(""String_Node_Str"",e);
    }
  }
 else {
    ProverUIActivator.logDebug(""String_Node_Str"" + ""String_Node_Str"" + status.getStatus() + ""String_Node_Str""+ location);
  }
}",0.9326226012793176
135979,"/** 
 * Called when there is a new parse result broadcast by  {@link ParseResultBroadcaster}. Updates the folding structure of the proofs in the editor.
 */
public void newParseResult(ParseResult parseResult){
  String moduleName=ResourceHelper.getModuleName(((FileEditorInput)editor.getEditorInput()).getFile());
  if (editor == null) {
    Activator.logDebug(""String_Node_Str"");
    return;
  }
 else   if (editor.getEditorInput() == null) {
    Activator.logDebug(""String_Node_Str"");
    return;
  }
  if (editor.isDirty() || parseResult.getParserCalled() < documentLastModified || parseResult.getParserCalled() < ((FileEditorInput)editor.getEditorInput()).getFile().getLocalTimeStamp()) {
    return;
  }
  SpecObj specObj=parseResult.getSpecObj();
  if (specObj == null) {
    return;
  }
  Assert.isNotNull(specObj.getExternalModuleTable());
  ModuleNode moduleNode=specObj.getExternalModuleTable().getModuleNode(UniqueString.uniqueStringOf(moduleName));
  if (moduleNode == null) {
    return;
  }
  canPerformFoldingCommands=false;
  HashMap additions=new HashMap();
  Vector foldsInCurrentTree=new Vector();
  TheoremNode[] theorems=moduleNode.getTheorems();
  for (int i=0; i < theorems.length; i++) {
    TheoremNode theoremNode=theorems[i];
    try {
      if (theoremNode.getLocation().source().equals(moduleName)) {
        computeProofFoldPositions(theoremNode,additions,foldsInCurrentTree,foldPositions);
      }
    }
 catch (    BadLocationException e) {
      Activator.logError(""String_Node_Str"" + moduleName,e);
    }
  }
  Annotation[] deletions=new ProjectionAnnotation[foldPositions.size()];
  int i=0;
  for (Iterator it=foldPositions.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    proofPosition.remove(document);
    deletions[i]=proofPosition.getAnnotation();
  }
  foldPositions=foldsInCurrentTree;
  editor.modifyProjectionAnnotations(deletions,additions,null);
  int currentOffset=-1;
  boolean isSorted=true;
  for (Iterator it=foldPositions.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    if (proofPosition.getOffset() >= currentOffset) {
      currentOffset=proofPosition.getOffset();
    }
 else {
      isSorted=false;
      break;
    }
  }
  if (!isSorted) {
    Collections.sort(foldPositions,new Comparator(){
      public int compare(      Object arg0,      Object arg1){
        if (arg0 instanceof TLAProofPosition && arg1 instanceof TLAProofPosition) {
          return ((TLAProofPosition)arg0).getOffset() - ((TLAProofPosition)arg1).getOffset();
        }
 else {
          return 0;
        }
      }
    }
);
  }
  canPerformFoldingCommands=true;
}","/** 
 * Called when there is a new parse result broadcast by  {@link ParseResultBroadcaster}. Updates the folding structure of the proofs in the editor if the parse result points to the   {@link ModuleNode} representingthe file in the editor for this class.
 */
public void newParseResult(ParseResult parseResult){
  if (!parseResult.getParsedResource().getLocation().removeLastSegments(1).equals(((FileEditorInput)editor.getEditorInput()).getFile().getLocation().removeLastSegments(1))) {
    return;
  }
  String moduleName=ResourceHelper.getModuleName(((FileEditorInput)editor.getEditorInput()).getFile());
  if (editor == null) {
    Activator.logDebug(""String_Node_Str"");
    return;
  }
 else   if (editor.getEditorInput() == null) {
    Activator.logDebug(""String_Node_Str"");
    return;
  }
  if (editor.isDirty() || parseResult.getParserCalled() < documentLastModified || parseResult.getParserCalled() < ((FileEditorInput)editor.getEditorInput()).getFile().getLocalTimeStamp()) {
    return;
  }
  SpecObj specObj=parseResult.getSpecObj();
  if (specObj == null) {
    return;
  }
  Assert.isNotNull(specObj.getExternalModuleTable());
  ModuleNode moduleNode=specObj.getExternalModuleTable().getModuleNode(UniqueString.uniqueStringOf(moduleName));
  if (moduleNode == null) {
    return;
  }
  canPerformFoldingCommands=false;
  HashMap additions=new HashMap();
  Vector foldsInCurrentTree=new Vector();
  TheoremNode[] theorems=moduleNode.getTheorems();
  for (int i=0; i < theorems.length; i++) {
    TheoremNode theoremNode=theorems[i];
    try {
      if (theoremNode.getLocation().source().equals(moduleName)) {
        computeProofFoldPositions(theoremNode,additions,foldsInCurrentTree,foldPositions);
      }
    }
 catch (    BadLocationException e) {
      Activator.logError(""String_Node_Str"" + moduleName,e);
    }
  }
  Annotation[] deletions=new ProjectionAnnotation[foldPositions.size()];
  int i=0;
  for (Iterator it=foldPositions.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    proofPosition.remove(document);
    deletions[i]=proofPosition.getAnnotation();
  }
  foldPositions=foldsInCurrentTree;
  editor.modifyProjectionAnnotations(deletions,additions,null);
  int currentOffset=-1;
  boolean isSorted=true;
  for (Iterator it=foldPositions.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    if (proofPosition.getOffset() >= currentOffset) {
      currentOffset=proofPosition.getOffset();
    }
 else {
      isSorted=false;
      break;
    }
  }
  if (!isSorted) {
    Collections.sort(foldPositions,new Comparator(){
      public int compare(      Object arg0,      Object arg1){
        if (arg0 instanceof TLAProofPosition && arg1 instanceof TLAProofPosition) {
          return ((TLAProofPosition)arg0).getOffset() - ((TLAProofPosition)arg1).getOffset();
        }
 else {
          return 0;
        }
      }
    }
);
  }
  canPerformFoldingCommands=true;
}",0.94794231445656
135980,"/** 
 * Draw the fields Its helpful to know what the standard SWT widgets look like. Pictures can be found at http://www.eclipse.org/swt/widgets/ Layouts are used throughout this method. A good explanation of layouts is given in the article http://www.eclipse.org/articles/article.php?file=Article-Understanding-Layouts/index.html
 */
protected void createBodyContent(IManagedForm managedForm){
  int sectionFlags=Section.TITLE_BAR | Section.DESCRIPTION | Section.TREE_NODE| Section.EXPANDED| SWT.WRAP;
  int textFieldFlags=SWT.MULTI | SWT.V_SCROLL | SWT.READ_ONLY| SWT.FULL_SELECTION| SWT.WRAP;
  FormToolkit toolkit=managedForm.getToolkit();
  Composite body=managedForm.getForm().getBody();
  TableWrapLayout layout=new TableWrapLayout();
  layout.numColumns=1;
  body.setLayout(layout);
  TableWrapData twd;
  Section section;
  GridData gd;
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,sectionFlags & ~Section.DESCRIPTION,getExpansionListener());
  twd=new TableWrapData(TableWrapData.FILL);
  twd.colspan=1;
  section.setLayoutData(twd);
  Composite generalArea=(Composite)section.getClient();
  generalArea.setLayout(new GridLayout());
  Composite statusComposite=toolkit.createComposite(generalArea);
  statusComposite.setLayout(new GridLayout(2,false));
  this.startTimestampText=FormHelper.createTextLeft(""String_Node_Str"",statusComposite,toolkit);
  this.startTimestampText.setEditable(false);
  this.finishTimestampText=FormHelper.createTextLeft(""String_Node_Str"",statusComposite,toolkit);
  this.finishTimestampText.setEditable(false);
  this.lastCheckpointTimeText=FormHelper.createTextLeft(""String_Node_Str"",statusComposite,toolkit);
  this.lastCheckpointTimeText.setEditable(false);
  this.currentStatusText=FormHelper.createTextLeft(""String_Node_Str"",statusComposite,toolkit);
  this.currentStatusText.setEditable(false);
  this.currentStatusText.setText(TLCModelLaunchDataProvider.NOT_RUNNING);
  this.errorStatusHyperLink=FormHelper.createHyperlinkLeft(""String_Node_Str"",statusComposite,toolkit);
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,(sectionFlags | Section.COMPACT) & ~Section.DESCRIPTION,getExpansionListener());
  twd=new TableWrapData(TableWrapData.FILL);
  twd.colspan=1;
  section.setLayoutData(twd);
  Composite statArea=(Composite)section.getClient();
  RowLayout rowLayout=new RowLayout(SWT.HORIZONTAL);
  statArea.setLayout(rowLayout);
  createAndSetupStateSpace(""String_Node_Str"",statArea,toolkit);
  createAndSetupCoverage(""String_Node_Str"",statArea,toolkit);
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,sectionFlags & ~Section.DESCRIPTION,getExpansionListener());
  Composite resultArea=(Composite)section.getClient();
  GridLayout gLayout=new GridLayout(2,false);
  gLayout.marginHeight=0;
  resultArea.setLayout(gLayout);
  Composite expressionComposite=toolkit.createComposite(resultArea);
  expressionComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,false,false));
  gLayout=new GridLayout(1,false);
  gLayout.marginHeight=0;
  gLayout.marginBottom=5;
  expressionComposite.setLayout(gLayout);
  toolkit.createLabel(expressionComposite,""String_Node_Str"");
  expressionEvalInput=FormHelper.createFormsSourceViewer(toolkit,expressionComposite,textFieldFlags);
  Composite valueComposite=toolkit.createComposite(resultArea);
  valueComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  valueComposite.setLayout(gLayout);
  toolkit.createLabel(valueComposite,""String_Node_Str"");
  expressionEvalResult=FormHelper.createFormsOutputViewer(toolkit,valueComposite,textFieldFlags);
  gd=new GridData(SWT.FILL,SWT.FILL,true,false);
  gd.minimumWidth=500;
  gd.heightHint=80;
  expressionEvalResult.getTextWidget().setLayoutData(gd);
  gd=new GridData(SWT.FILL,SWT.FILL,false,false);
  gd.widthHint=500;
  gd.heightHint=80;
  expressionEvalInput.getTextWidget().setLayoutData(gd);
  expressionEvalResult.getTextWidget().setFont(JFaceResources.getTextFont());
  expressionEvalInput.getTextWidget().setFont(JFaceResources.getTextFont());
  toolkit.paintBordersFor(expressionComposite);
  toolkit.paintBordersFor(valueComposite);
  ValidateableSectionPart calculatorSectionPart=new ValidateableSectionPart(section,this,SEC_EXPRESSION);
  managedForm.addPart(calculatorSectionPart);
  expressionEvalInput.getTextWidget().addModifyListener(new DirtyMarkingListener(calculatorSectionPart,false));
  getDataBindingManager().bindAttribute(MODEL_EXPRESSION_EVAL,expressionEvalInput,calculatorSectionPart);
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,sectionFlags,getExpansionListener());
  Composite outputArea=(Composite)section.getClient();
  outputArea.setLayout(new GridLayout());
  userOutput=FormHelper.createFormsOutputViewer(toolkit,outputArea,textFieldFlags);
  gd=new GridData(SWT.FILL,SWT.LEFT,true,false);
  gd.heightHint=300;
  gd.minimumWidth=300;
  userOutput.getControl().setLayoutData(gd);
  userOutput.getControl().setFont(JFaceResources.getFont(ITLCPreferenceConstants.I_TLC_OUTPUT_FONT));
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,sectionFlags & ~Section.DESCRIPTION,getExpansionListener());
  section.setExpanded(false);
  Composite progressArea=(Composite)section.getClient();
  progressArea=(Composite)section.getClient();
  progressArea.setLayout(new GridLayout());
  progressOutput=FormHelper.createFormsOutputViewer(toolkit,progressArea,textFieldFlags);
  gd=new GridData(SWT.FILL,SWT.LEFT,true,false);
  gd.heightHint=300;
  gd.minimumWidth=300;
  progressOutput.getControl().setLayoutData(gd);
  progressOutput.getControl().setFont(JFaceResources.getFont(ITLCPreferenceConstants.I_TLC_OUTPUT_FONT));
  Vector controls=new Vector();
  controls.add(userOutput.getControl());
  controls.add(progressOutput.getControl());
  fontChangeListener=new FontPreferenceChangeListener(controls,ITLCPreferenceConstants.I_TLC_OUTPUT_FONT);
  JFaceResources.getFontRegistry().addListener(fontChangeListener);
}","/** 
 * Draw the fields Its helpful to know what the standard SWT widgets look like. Pictures can be found at http://www.eclipse.org/swt/widgets/ Layouts are used throughout this method. A good explanation of layouts is given in the article http://www.eclipse.org/articles/article.php?file=Article-Understanding-Layouts/index.html
 */
protected void createBodyContent(IManagedForm managedForm){
  int sectionFlags=Section.TITLE_BAR | Section.DESCRIPTION | Section.TREE_NODE| Section.EXPANDED| SWT.WRAP;
  int textFieldFlags=SWT.MULTI | SWT.V_SCROLL | SWT.READ_ONLY| SWT.FULL_SELECTION| SWT.WRAP;
  FormToolkit toolkit=managedForm.getToolkit();
  Composite body=managedForm.getForm().getBody();
  TableWrapLayout layout=new TableWrapLayout();
  layout.numColumns=1;
  body.setLayout(layout);
  TableWrapData twd;
  Section section;
  GridData gd;
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,sectionFlags & ~Section.DESCRIPTION,getExpansionListener());
  twd=new TableWrapData(TableWrapData.FILL);
  twd.colspan=1;
  section.setLayoutData(twd);
  Composite generalArea=(Composite)section.getClient();
  generalArea.setLayout(new GridLayout());
  Composite statusComposite=toolkit.createComposite(generalArea);
  statusComposite.setLayout(new GridLayout(2,false));
  this.startTimestampText=FormHelper.createTextLeft(""String_Node_Str"",statusComposite,toolkit);
  this.startTimestampText.setEditable(false);
  this.finishTimestampText=FormHelper.createTextLeft(""String_Node_Str"",statusComposite,toolkit);
  this.finishTimestampText.setEditable(false);
  this.lastCheckpointTimeText=FormHelper.createTextLeft(""String_Node_Str"",statusComposite,toolkit);
  this.lastCheckpointTimeText.setEditable(false);
  this.currentStatusText=FormHelper.createTextLeft(""String_Node_Str"",statusComposite,toolkit);
  this.currentStatusText.setEditable(false);
  this.currentStatusText.setText(TLCModelLaunchDataProvider.NOT_RUNNING);
  this.errorStatusHyperLink=FormHelper.createHyperlinkLeft(""String_Node_Str"",statusComposite,toolkit);
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,(sectionFlags | Section.COMPACT) & ~Section.DESCRIPTION,getExpansionListener());
  twd=new TableWrapData(TableWrapData.FILL);
  twd.colspan=1;
  section.setLayoutData(twd);
  Composite statArea=(Composite)section.getClient();
  RowLayout rowLayout=new RowLayout(SWT.HORIZONTAL);
  statArea.setLayout(rowLayout);
  createAndSetupStateSpace(""String_Node_Str"",statArea,toolkit);
  createAndSetupCoverage(""String_Node_Str"",statArea,toolkit);
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,sectionFlags & ~Section.DESCRIPTION,getExpansionListener());
  Composite resultArea=(Composite)section.getClient();
  GridLayout gLayout=new GridLayout(2,false);
  gLayout.marginHeight=0;
  resultArea.setLayout(gLayout);
  Composite expressionComposite=toolkit.createComposite(resultArea);
  expressionComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,false,false));
  gLayout=new GridLayout(1,false);
  gLayout.marginHeight=0;
  gLayout.marginBottom=5;
  expressionComposite.setLayout(gLayout);
  toolkit.createLabel(expressionComposite,""String_Node_Str"");
  expressionEvalInput=FormHelper.createFormsSourceViewer(toolkit,expressionComposite,textFieldFlags);
  Composite valueComposite=toolkit.createComposite(resultArea);
  valueComposite.setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,false));
  valueComposite.setLayout(gLayout);
  toolkit.createLabel(valueComposite,""String_Node_Str"");
  expressionEvalResult=FormHelper.createFormsOutputViewer(toolkit,valueComposite,textFieldFlags);
  gd=new GridData(SWT.FILL,SWT.FILL,true,false);
  gd.minimumWidth=500;
  gd.heightHint=80;
  expressionEvalResult.getTextWidget().setLayoutData(gd);
  gd=new GridData(SWT.FILL,SWT.FILL,false,false);
  gd.widthHint=500;
  gd.heightHint=80;
  expressionEvalInput.getTextWidget().setLayoutData(gd);
  expressionEvalResult.getTextWidget().setFont(JFaceResources.getTextFont());
  expressionEvalInput.getTextWidget().setFont(JFaceResources.getTextFont());
  toolkit.paintBordersFor(expressionComposite);
  toolkit.paintBordersFor(valueComposite);
  ValidateableSectionPart calculatorSectionPart=new ValidateableSectionPart(section,this,SEC_EXPRESSION);
  managedForm.addPart(calculatorSectionPart);
  expressionEvalInput.getTextWidget().addModifyListener(new DirtyMarkingListener(calculatorSectionPart,false));
  getDataBindingManager().bindAttribute(MODEL_EXPRESSION_EVAL,expressionEvalInput,calculatorSectionPart);
  getDataBindingManager().bindSection(calculatorSectionPart,SEC_EXPRESSION,getId());
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,sectionFlags,getExpansionListener());
  Composite outputArea=(Composite)section.getClient();
  outputArea.setLayout(new GridLayout());
  userOutput=FormHelper.createFormsOutputViewer(toolkit,outputArea,textFieldFlags);
  gd=new GridData(SWT.FILL,SWT.LEFT,true,false);
  gd.heightHint=300;
  gd.minimumWidth=300;
  userOutput.getControl().setLayoutData(gd);
  userOutput.getControl().setFont(JFaceResources.getFont(ITLCPreferenceConstants.I_TLC_OUTPUT_FONT));
  section=FormHelper.createSectionComposite(body,""String_Node_Str"",""String_Node_Str"",toolkit,sectionFlags & ~Section.DESCRIPTION,getExpansionListener());
  section.setExpanded(false);
  Composite progressArea=(Composite)section.getClient();
  progressArea=(Composite)section.getClient();
  progressArea.setLayout(new GridLayout());
  progressOutput=FormHelper.createFormsOutputViewer(toolkit,progressArea,textFieldFlags);
  gd=new GridData(SWT.FILL,SWT.LEFT,true,false);
  gd.heightHint=300;
  gd.minimumWidth=300;
  progressOutput.getControl().setLayoutData(gd);
  progressOutput.getControl().setFont(JFaceResources.getFont(ITLCPreferenceConstants.I_TLC_OUTPUT_FONT));
  Vector controls=new Vector();
  controls.add(userOutput.getControl());
  controls.add(progressOutput.getControl());
  fontChangeListener=new FontPreferenceChangeListener(controls,ITLCPreferenceConstants.I_TLC_OUTPUT_FONT);
  JFaceResources.getFontRegistry().addListener(fontChangeListener);
}",0.9930967270364656
135981,"/** 
 * Computes the regions that will be hidden when the fold at this position is collapsed. The following is from an email from Leslie. It starts by explaining how comments should be used and folded in proofs and ends by describing the folding rule. In proofs, there are two ways I can think of for using comments: - At the beginning of a proof to explain the proof.  For example: <2>3. x > 0 (********************************************************************) (* We prove y >0 and x \geq y by using Finagle's theorem and step   *) (* <1>3.                                                            *) (********************************************************************) <3>1. ... - As an informal leaf proof.  For example: <2>3. x > 0 (*********************************************************************) (* This follows by simple algebra from <2>1 and <1>3, but I'm not    *) (* going to bother trying to convince this stupid prover that it     *) (* does.                                                             *) (*********************************************************************) <2>4. ... In this case, I will also want to add a PROOF OMITTED to tell the prover that I didn't just forget about this proof step. We can handle both these cases by the following rule, where the PROOF OMITTED follows the comment in the second case: When hiding a proof, hide everything from the (line following the) end of the statement being proved to the end of the proof.
 */
public IRegion[] computeProjectionRegions(IDocument document) throws BadLocationException {
  int firstLine=document.getLineOfOffset(positionOfStatement.getOffset() + positionOfStatement.getLength()) + 1;
  int lastLine=document.getLineOfOffset(positionOfProof.getOffset() + positionOfProof.getLength());
  if (firstLine > lastLine) {
    return null;
  }
  int firstLineOffset=document.getLineOffset(firstLine);
  IRegion lastLineInfo=document.getLineInformation(lastLine);
  IRegion toFold=alignRegion(new Region(firstLineOffset,lastLineInfo.getOffset() + lastLineInfo.getLength() - firstLineOffset),document);
  if (toFold != null) {
    return new IRegion[]{toFold};
  }
  return null;
}","/** 
 * Computes the regions that will be hidden when the fold at this position is collapsed. The following is from an email from Leslie. It starts by explaining how comments should be used and folded in proofs and ends by describing the folding rule. In proofs, there are two ways I can think of for using comments: - At the beginning of a proof to explain the proof.  For example: <2>3. x > 0 (********************************************************************) (* We prove y >0 and x \geq y by using Finagle's theorem and step   *) (* <1>3.                                                            *) (********************************************************************) <3>1. ... - As an informal leaf proof.  For example: <2>3. x > 0 (*********************************************************************) (* This follows by simple algebra from <2>1 and <1>3, but I'm not    *) (* going to bother trying to convince this stupid prover that it     *) (* does.                                                             *) (*********************************************************************) <2>4. ... In this case, I will also want to add a PROOF OMITTED to tell the prover that I didn't just forget about this proof step. We can handle both these cases by the following rule, where the PROOF OMITTED follows the comment in the second case: When hiding a proof, hide everything from the (line following the) end of the statement being proved to the end of the proof.
 */
public IRegion[] computeProjectionRegions(IDocument document) throws BadLocationException {
  int firstLine=document.getLineOfOffset(positionOfStatement.getOffset() + positionOfStatement.getLength()) + 1;
  int lastLine=document.getLineOfOffset(positionOfProof.getOffset() + positionOfProof.getLength());
  if (firstLine > lastLine) {
    return null;
  }
  int firstLineOffset=document.getLineOffset(firstLine);
  IRegion lastLineInfo=document.getLineInformation(lastLine);
  IRegion toFold=alignRegion(new Region(firstLineOffset,lastLineInfo.getOffset() + lastLineInfo.getLength() - firstLineOffset),document);
  length=toFold.getOffset() + toFold.getLength() - offset;
  if (toFold != null) {
    return new IRegion[]{toFold};
  }
  return null;
}",0.9866182807892946
135982,"/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          removeItem(item);
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
        viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
        viewer.configure(new ObligationSourceViewerConfiguration());
        viewer.getControl().setFont(JFaceResources.getTextFont());
        fontListener.addControl(viewer.getControl());
        viewers.put(item,viewer);
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
      SourceViewer viewer=(SourceViewer)viewers.get(item);
      Assert.isNotNull(viewer,""String_Node_Str"");
      String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
      if (viewer.getDocument() == null && !oblString.isEmpty()) {
        viewer.setDocument(new Document(oblString.trim()));
        StyledText text=viewer.getTextWidget();
        ScrollBar hBar=text.getHorizontalBar();
        item.setHeight(text.getLineHeight() * text.getLineCount() + (hBar != null ? hBar.getSize().y : 0));
      }
 else {
        viewer.setDocument(new Document(""String_Node_Str""));
        item.setHeight(100);
      }
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}","/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          removeItem(item);
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
        viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
        viewer.configure(new ObligationSourceViewerConfiguration());
        viewer.getControl().setFont(JFaceResources.getTextFont());
        fontListener.addControl(viewer.getControl());
        viewers.put(item,viewer);
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
      SourceViewer viewer=(SourceViewer)viewers.get(item);
      Assert.isNotNull(viewer,""String_Node_Str"");
      String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
      if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !oblString.isEmpty()) {
        viewer.setDocument(new Document(oblString.trim()));
        StyledText text=viewer.getTextWidget();
        ScrollBar hBar=text.getHorizontalBar();
        item.setHeight(text.getLineHeight() * text.getLineCount() + (hBar != null ? hBar.getSize().y : 0));
      }
 else {
        viewer.setDocument(new Document(""String_Node_Str""));
        item.setHeight(100);
      }
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}",0.9909782416416062
135983,"/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          removeItem(item);
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
        viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
        viewer.configure(new ObligationSourceViewerConfiguration());
        viewer.getControl().setFont(JFaceResources.getTextFont());
        fontListener.addControl(viewer.getControl());
        viewers.put(item,viewer);
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
      SourceViewer viewer=(SourceViewer)viewers.get(item);
      Assert.isNotNull(viewer,""String_Node_Str"");
      String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
      if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !oblString.isEmpty()) {
        viewer.setDocument(new Document(oblString.trim()));
        StyledText text=viewer.getTextWidget();
        ScrollBar hBar=text.getHorizontalBar();
        item.setHeight(text.getLineHeight() * text.getLineCount() + (hBar != null ? hBar.getSize().y : 0));
      }
 else {
        viewer.setDocument(new Document(""String_Node_Str""));
        item.setHeight(100);
      }
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}","/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          removeItem(item);
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
        viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
        viewer.configure(new ObligationSourceViewerConfiguration());
        viewer.getControl().setFont(JFaceResources.getTextFont());
        fontListener.addControl(viewer.getControl());
        viewers.put(item,viewer);
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
      SourceViewer viewer=(SourceViewer)viewers.get(item);
      Assert.isNotNull(viewer,""String_Node_Str"");
      String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
      if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !oblString.isEmpty()) {
        viewer.setDocument(new Document(oblString.trim()));
        StyledText text=viewer.getTextWidget();
        ScrollBar hBar=text.getHorizontalBar();
        item.setHeight(text.getLineHeight() * text.getLineCount() + (hBar != null ? hBar.getSize().y : 0));
      }
 else       if (oblString.isEmpty()) {
        viewer.setDocument(new Document(""String_Node_Str""));
        item.setHeight(100);
      }
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}",0.9945945945945946
135984,"/** 
 * Refreshes the editor. This currently just involves checking if the prover is running on the module. If it is, the editor is set to be read only. If it isn't, the editor is set to be editable.
 */
private void refresh(){
  if (getSourceViewer() != null) {
    getSourceViewer().setEditable(!EditorUtil.isReadOnly(((FileEditorInput)getEditorInput()).getFile()));
  }
}","/** 
 * Refreshes the editor. This currently just involves checking if the resource has been marked read-only by   {@link EditorUtil#setReadOnly(org.eclipse.core.resources.IResource,boolean)}. If it is, the editor is set to be read only. If it isn't, the editor is set to be editable.
 */
private void refresh(){
  if (getSourceViewer() != null) {
    getSourceViewer().setEditable(!EditorUtil.isReadOnly(((FileEditorInput)getEditorInput()).getFile()));
  }
}",0.8259303721488596
135985,"public void createPartControl(Composite parent){
  super.createPartControl(parent);
  ProjectionViewer viewer=(ProjectionViewer)getSourceViewer();
  projectionSupport=new ProjectionSupport(viewer,getAnnotationAccess(),getSharedColors());
  projectionSupport.addSummarizableAnnotationType(""String_Node_Str"");
  projectionSupport.addSummarizableAnnotationType(""String_Node_Str"");
  projectionSupport.install();
  viewer.doOperation(ProjectionViewer.TOGGLE);
  this.annotationModel=viewer.getProjectionAnnotationModel();
  this.visualAnnotationModel=viewer.getAnnotationModel();
  this.proofStructureProvider=new TLAProofFoldingStructureProvider(this);
}","public void createPartControl(Composite parent){
  super.createPartControl(parent);
  ProjectionViewer viewer=(ProjectionViewer)getSourceViewer();
  projectionSupport=new ProjectionSupport(viewer,getAnnotationAccess(),getSharedColors());
  projectionSupport.addSummarizableAnnotationType(""String_Node_Str"");
  projectionSupport.addSummarizableAnnotationType(""String_Node_Str"");
  projectionSupport.install();
  viewer.doOperation(ProjectionViewer.TOGGLE);
  this.annotationModel=viewer.getProjectionAnnotationModel();
  this.visualAnnotationModel=viewer.getAnnotationModel();
  this.proofStructureProvider=new TLAProofFoldingStructureProvider(this);
  refresh();
}",0.9901140684410646
135986,"/** 
 * Added by LL on 30 Jan 2006.                                           * Generate TLA+ for the `either' statement.  This performs the same     sort of hackery as for the `if' statement, necessitated by the        design flaw commented on above.                                      
 */
private void GenEither(AST.Either ast,Changed c,String context,String prefix,int col) throws PcalTLAGenException {
  Changed allC=new Changed(c);
  Changed[] cOrs=new Changed[ast.ors.size()];
  int[] ucLocs=new int[ast.ors.size()];
  StringBuffer sb=new StringBuffer(prefix);
  int prefixIndent=sb.length();
  sb.append(""String_Node_Str"");
  int here=sb.length();
  for (int i=0; i < ast.ors.size(); i++) {
    if (i != 0) {
      sb=new StringBuffer(NSpaces(prefixIndent) + ""String_Node_Str"");
    }
    ;
    sb.append(""String_Node_Str"");
    Vector orClause=(Vector)ast.ors.elementAt(i);
    Changed cC=new Changed(c);
    for (int j=0; j < orClause.size(); j++) {
      GenStmt((AST)orClause.elementAt(j),cC,context,sb.toString(),here);
      sb=new StringBuffer(NSpaces(here) + ""String_Node_Str"");
    }
    ;
    cOrs[i]=cC;
    allC.Merge(cC);
    ucLocs[i]=tlacode.size();
    tlacode.addElement(""String_Node_Str"");
  }
  ;
  int i=ast.ors.size();
  while (i > 0) {
    i=i - 1;
    tlacode.removeElementAt(ucLocs[i]);
    int numUnchanged=cOrs[i].NumUnchanged(allC);
    String NotChanged=cOrs[i].Unchanged(allC);
    if (numUnchanged > 1) {
      tlacode.insertElementAt(NSpaces(here) + ""String_Node_Str"" + NotChanged+ ""String_Node_Str"",ucLocs[i]);
    }
 else     if (numUnchanged == 1) {
      tlacode.insertElementAt(NSpaces(here) + ""String_Node_Str"" + NotChanged,ucLocs[i]);
    }
  }
  ;
  c.Merge(allC);
}","/** 
 * Added by LL on 30 Jan 2006.                                           * Generate TLA+ for the `either' statement.  This performs the same     sort of hackery as for the `if' statement, necessitated by the        design flaw commented on above.                                      
 */
private void GenEither(AST.Either ast,Changed c,String context,String prefix,int col) throws PcalTLAGenException {
  Changed allC=new Changed(c);
  Changed[] cOrs=new Changed[ast.ors.size()];
  int[] ucLocs=new int[ast.ors.size()];
  StringBuffer sb=new StringBuffer(prefix);
  int prefixIndent=sb.length();
  sb.append(""String_Node_Str"");
  int here=sb.length();
  for (int i=0; i < ast.ors.size(); i++) {
    if (i != 0) {
      sb=new StringBuffer(NSpaces(prefixIndent) + ""String_Node_Str"");
    }
    ;
    sb.append(""String_Node_Str"");
    Vector orClause=(Vector)ast.ors.elementAt(i);
    Changed cC=new Changed(c);
    for (int j=0; j < orClause.size(); j++) {
      GenStmt((AST)orClause.elementAt(j),cC,context,sb.toString(),here + 3);
      sb=new StringBuffer(NSpaces(here) + ""String_Node_Str"");
    }
    ;
    cOrs[i]=cC;
    allC.Merge(cC);
    ucLocs[i]=tlacode.size();
    tlacode.addElement(""String_Node_Str"");
  }
  ;
  int i=ast.ors.size();
  while (i > 0) {
    i=i - 1;
    tlacode.removeElementAt(ucLocs[i]);
    int numUnchanged=cOrs[i].NumUnchanged(allC);
    String NotChanged=cOrs[i].Unchanged(allC);
    if (numUnchanged > 1) {
      tlacode.insertElementAt(NSpaces(here) + ""String_Node_Str"" + NotChanged+ ""String_Node_Str"",ucLocs[i]);
    }
 else     if (numUnchanged == 1) {
      tlacode.insertElementAt(NSpaces(here) + ""String_Node_Str"" + NotChanged,ucLocs[i]);
    }
  }
  ;
  c.Merge(allC);
}",0.9988351776354106
135987,"/** 
 * Modified by LL on 2 Feb 2006 to add line and column numbers to the    newly created statements for error reporting.                        
 */
private static Vector ExplodeReturn(AST.Return ast,String next) throws PcalTranslateException {
  Vector result=new Vector();
  if (ast.from == null) {
    throw new PcalTranslateException(""String_Node_Str"",ast);
  }
  ;
  int from=st.FindProc(ast.from);
  PcalSymTab.ProcedureEntry pe=(PcalSymTab.ProcedureEntry)st.procs.elementAt(from);
  PcalDebug.Assert(from < st.procs.size());
  AST.Assign ass=new AST.Assign();
  ass.line=ast.line;
  ass.col=ast.col;
  AST.SingleAssign sass=new AST.SingleAssign();
  sass.line=ast.line;
  sass.col=ast.col;
  TLAExpr expr=new TLAExpr();
  sass.lhs.var=""String_Node_Str"";
  sass.lhs.sub=new TLAExpr();
  expr.addLine();
  expr.addToken(IdentToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.addToken(AddedToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.addToken(IdentToken(""String_Node_Str""));
  expr.normalize();
  sass.rhs=expr;
  ass.ass=Singleton(sass);
  result.addElement(ass);
  for (int i=0; i < pe.decls.size(); i++) {
    AST.PVarDecl decl=(AST.PVarDecl)pe.decls.elementAt(i);
    ass=new AST.Assign();
    ass.line=ast.line;
    ass.col=ast.col;
    sass=new AST.SingleAssign();
    sass.line=ast.line;
    sass.col=ast.col;
    expr=new TLAExpr();
    sass.lhs.var=decl.var;
    sass.lhs.sub=new TLAExpr();
    expr.addLine();
    expr.addToken(IdentToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(AddedToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(IdentToken(decl.var));
    expr.normalize();
    sass.rhs=expr;
    ass.ass=Singleton(sass);
    result.addElement(ass);
  }
  for (int i=0; i < pe.params.size(); i++) {
    AST.PVarDecl decl=(AST.PVarDecl)pe.params.elementAt(i);
    ass=new AST.Assign();
    ass.line=ast.line;
    ass.col=ast.col;
    sass=new AST.SingleAssign();
    sass.line=ast.line;
    sass.col=ast.col;
    expr=new TLAExpr();
    sass.lhs.var=decl.var;
    sass.lhs.sub=new TLAExpr();
    expr.addLine();
    expr.addToken(IdentToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(AddedToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(IdentToken(decl.var));
    expr.normalize();
    sass.rhs=expr;
    ass.ass=Singleton(sass);
    result.addElement(ass);
  }
  ass=new AST.Assign();
  ass.line=ast.line;
  ass.col=ast.col;
  sass=new AST.SingleAssign();
  sass.line=ast.line;
  sass.col=ast.col;
  expr=new TLAExpr();
  sass.lhs.var=""String_Node_Str"";
  sass.lhs.sub=new TLAExpr();
  expr.addLine();
  expr.addToken(IdentToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.addToken(AddedToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.normalize();
  sass.rhs=expr;
  ass.ass=Singleton(sass);
  result.addElement(ass);
  return result;
}","/** 
 * Modified by LL on 2 Feb 2006 to add line and column numbers to the    newly created statements for error reporting.                        
 */
private static Vector ExplodeReturn(AST.Return ast,String next) throws PcalTranslateException {
  Vector result=new Vector();
  int from=st.FindProc(ast.from);
  PcalSymTab.ProcedureEntry pe=(PcalSymTab.ProcedureEntry)st.procs.elementAt(from);
  PcalDebug.Assert(from < st.procs.size());
  AST.Assign ass=new AST.Assign();
  ass.line=ast.line;
  ass.col=ast.col;
  AST.SingleAssign sass=new AST.SingleAssign();
  sass.line=ast.line;
  sass.col=ast.col;
  TLAExpr expr=new TLAExpr();
  sass.lhs.var=""String_Node_Str"";
  sass.lhs.sub=new TLAExpr();
  expr.addLine();
  expr.addToken(IdentToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.addToken(AddedToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.addToken(IdentToken(""String_Node_Str""));
  expr.normalize();
  sass.rhs=expr;
  ass.ass=Singleton(sass);
  result.addElement(ass);
  for (int i=0; i < pe.decls.size(); i++) {
    AST.PVarDecl decl=(AST.PVarDecl)pe.decls.elementAt(i);
    ass=new AST.Assign();
    ass.line=ast.line;
    ass.col=ast.col;
    sass=new AST.SingleAssign();
    sass.line=ast.line;
    sass.col=ast.col;
    expr=new TLAExpr();
    sass.lhs.var=decl.var;
    sass.lhs.sub=new TLAExpr();
    expr.addLine();
    expr.addToken(IdentToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(AddedToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(IdentToken(decl.var));
    expr.normalize();
    sass.rhs=expr;
    ass.ass=Singleton(sass);
    result.addElement(ass);
  }
  for (int i=0; i < pe.params.size(); i++) {
    AST.PVarDecl decl=(AST.PVarDecl)pe.params.elementAt(i);
    ass=new AST.Assign();
    ass.line=ast.line;
    ass.col=ast.col;
    sass=new AST.SingleAssign();
    sass.line=ast.line;
    sass.col=ast.col;
    expr=new TLAExpr();
    sass.lhs.var=decl.var;
    sass.lhs.sub=new TLAExpr();
    expr.addLine();
    expr.addToken(IdentToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(AddedToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(BuiltInToken(""String_Node_Str""));
    expr.addToken(IdentToken(decl.var));
    expr.normalize();
    sass.rhs=expr;
    ass.ass=Singleton(sass);
    result.addElement(ass);
  }
  ass=new AST.Assign();
  ass.line=ast.line;
  ass.col=ast.col;
  sass=new AST.SingleAssign();
  sass.line=ast.line;
  sass.col=ast.col;
  expr=new TLAExpr();
  sass.lhs.var=""String_Node_Str"";
  sass.lhs.sub=new TLAExpr();
  expr.addLine();
  expr.addToken(IdentToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.addToken(AddedToken(""String_Node_Str""));
  expr.addToken(BuiltInToken(""String_Node_Str""));
  expr.normalize();
  sass.rhs=expr;
  ass.ass=Singleton(sass);
  result.addElement(ass);
  return result;
}",0.9851724676135476
135988,"/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          removeItem(item);
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
        viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
        viewer.configure(new ObligationSourceViewerConfiguration());
        viewer.getControl().setFont(JFaceResources.getTextFont());
        fontListener.addControl(viewer.getControl());
        viewers.put(item,viewer);
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
      SourceViewer viewer=(SourceViewer)viewers.get(item);
      Assert.isNotNull(viewer,""String_Node_Str"");
      String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
      if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !oblString.isEmpty()) {
        viewer.setDocument(new Document(oblString.trim()));
        StyledText text=viewer.getTextWidget();
        ScrollBar hBar=text.getHorizontalBar();
        item.setHeight(text.getLineHeight() * text.getLineCount() + (hBar != null ? hBar.getSize().y : 0));
      }
 else       if (oblString.isEmpty()) {
        viewer.setDocument(new Document(""String_Node_Str""));
        item.setHeight(100);
      }
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}","/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          removeItem(item);
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
        viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
        viewer.configure(new ObligationSourceViewerConfiguration());
        viewer.getControl().setFont(JFaceResources.getTextFont());
        fontListener.addControl(viewer.getControl());
        viewers.put(item,viewer);
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
      SourceViewer viewer=(SourceViewer)viewers.get(item);
      Assert.isNotNull(viewer,""String_Node_Str"");
      String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
      if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !oblString.isEmpty()) {
        viewer.setDocument(new Document(oblString.trim()));
        StyledText text=viewer.getTextWidget();
        ScrollBar hBar=text.getHorizontalBar();
        item.setHeight(text.getLineHeight() * text.getLineCount() + (hBar != null ? hBar.getSize().y : 0));
      }
 else       if (oblString.isEmpty() && (viewer.getDocument() == null || viewer.getDocument().get().isEmpty())) {
        viewer.setDocument(new Document(""String_Node_Str""));
        item.setHeight(100);
      }
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}",0.9873287671232877
135989,"private int[] detectLocation(String message){
  String LINE=""String_Node_Str"";
  String COLUMN=""String_Node_Str"";
  int lineStarts=message.indexOf(LINE);
  int lineEnds=message.indexOf(COLUMN);
  if (lineStarts != -1 && lineEnds != -1) {
    String line=message.substring(lineStarts + LINE.length(),lineEnds);
    String column=message.substring(lineEnds + COLUMN.length());
    int lineNumber=-1;
    int columnNumber=-1;
    try {
      lineNumber=Integer.parseInt(line);
    }
 catch (    NumberFormatException e) {
    }
    try {
      columnNumber=Integer.parseInt(column);
    }
 catch (    NumberFormatException e) {
    }
    return new int[]{lineNumber,columnNumber,lineNumber,columnNumber + 1};
  }
  return new int[]{-1,-1,-1,-1};
}","private int[] detectLocation(String message){
  String LINE=""String_Node_Str"";
  String COLUMN=""String_Node_Str"";
  int lineStarts=message.indexOf(LINE);
  int lineEnds=message.indexOf(COLUMN);
  if (lineStarts != -1 && lineEnds != -1) {
    String line=message.substring(lineStarts + LINE.length(),lineEnds);
    String afterColumnString=message.substring(lineEnds + COLUMN.length());
    Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(afterColumnString);
    Assert.isTrue(matcher.find(),""String_Node_Str"" + message);
    String column=matcher.group().trim();
    int lineNumber=-1;
    int columnNumber=-1;
    try {
      lineNumber=Integer.parseInt(line);
    }
 catch (    NumberFormatException e) {
    }
    try {
      columnNumber=Integer.parseInt(column);
    }
 catch (    NumberFormatException e) {
    }
    return new int[]{lineNumber,columnNumber,lineNumber,columnNumber + 1};
  }
  return new int[]{-1,-1,-1,-1};
}",0.8749259039715471
135990,"/** 
 * Processes the command line arguments This method changes values of public static variables of the   {@link PcalParams} SZ: This will cause problems, due to the fact that the PCalParams are static. Any initialization should overwrite the previous, which is currently NOT the case Should be re-factored to non-static access to the properties
 * @return status of processing. the status  {@link trans#STATUS_OK} indicates that no errors has been detected.the status  {@link trans#STATUS_EXIT_WITHOUT_ERROR} indicates that no errors has been found but translationshould not be started (e.G -help call) the status  {@link trans#STATUS_EXIT_WITH_ERRORS} indicates errors Change made on 9 December 2009 for pcal-file input.  This procedure is called a second time if there is pcal-file input with an options statement. It will be the second call iff  {@link PcalParams#optionsInFile} equals true.The second call should have a dummy extra argument in place of the  command-line's file-name argument.
 */
static int parseAndProcessArguments(String[] args){
  boolean inFile=PcalParams.optionsInFile;
  boolean notInFile=!inFile;
  boolean firstFairness=inFile;
  int nextArg=0;
  int maxArg=args.length - 1;
  if (maxArg < 0) {
    return CommandLineError(""String_Node_Str"");
  }
  if (notInFile && (args[maxArg].length() != 0) && (args[maxArg].charAt(0) == '-')) {
    if (OutputHelpMessage()) {
      return STATUS_EXIT_WITHOUT_ERROR;
    }
 else {
      return STATUS_EXIT_WITH_ERRORS;
    }
  }
  while (nextArg < maxArg) {
    String option=args[nextArg];
    if (notInFile && option.equals(""String_Node_Str"")) {
      if (OutputHelpMessage()) {
        return STATUS_EXIT_WITHOUT_ERROR;
      }
 else {
        return STATUS_EXIT_WITH_ERRORS;
      }
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.WriteASTFlag=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.SpecOption=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.SpecFile=args[nextArg];
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.MyspecOption=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.SpecFile=args[nextArg];
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.Spec2Option=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
      ;
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.SpecFile=args[nextArg];
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.Myspec2Option=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
      ;
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.SpecFile=args[nextArg];
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.Debug=true;
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      PcalParams.CheckTermination=true;
    }
 else     if (option.equals(""String_Node_Str"")) {
      PcalParams.Nocfg=true;
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      if (firstFairness) {
        PcalParams.FairnessOption=""String_Node_Str"";
        firstFairness=false;
      }
      if (!PcalParams.FairnessOption.equals(""String_Node_Str"")) {
        return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
      }
      PcalParams.FairnessOption=""String_Node_Str"";
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      if (firstFairness) {
        PcalParams.FairnessOption=""String_Node_Str"";
        firstFairness=false;
      }
      if (!PcalParams.FairnessOption.equals(""String_Node_Str"")) {
        return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
      }
      PcalParams.FairnessOption=""String_Node_Str"";
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      if (firstFairness) {
        PcalParams.FairnessOption=""String_Node_Str"";
        firstFairness=false;
      }
      if (!PcalParams.FairnessOption.equals(""String_Node_Str"")) {
        return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
      }
      PcalParams.FairnessOption=""String_Node_Str"";
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      if (firstFairness) {
        PcalParams.FairnessOption=""String_Node_Str"";
        firstFairness=false;
      }
      if (!PcalParams.FairnessOption.equals(""String_Node_Str"")) {
        return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
      }
      PcalParams.FairnessOption=""String_Node_Str"";
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      PcalParams.LabelFlag=true;
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.ReportLabelsFlag=true;
      PcalParams.LabelFlag=true;
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.LabelRoot=args[nextArg];
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      if (!PcalParams.ProcessVersion(args[nextArg])) {
        return CommandLineError(""String_Node_Str"");
      }
    }
 else     if (option.equals(""String_Node_Str"")) {
      nextArg=nextArg + 1;
      try {
        if (nextArg == maxArg) {
          throw new NumberFormatException();
        }
        PcalParams.SpecFile=args[nextArg];
        int a=new Integer(""String_Node_Str"").intValue();
        if (a < 60) {
          throw new NumberFormatException();
        }
        PcalTLAGen.wrapColumn=a;
        PcalTLAGen.ssWrapColumn=a - 33;
      }
 catch (      Exception e) {
        return CommandLineError(""String_Node_Str"");
      }
    }
 else {
      if (notInFile) {
        return CommandLineError(""String_Node_Str"" + option);
      }
 else {
        return CommandLineError(""String_Node_Str"" + option);
      }
    }
    ;
    nextArg=nextArg + 1;
  }
  if (nextArg > maxArg) {
    return CommandLineError(""String_Node_Str"");
  }
  if (inFile) {
    return STATUS_OK;
  }
  File file=new File(args[maxArg]);
  boolean hasExtension=false;
  if (file.getName().lastIndexOf(""String_Node_Str"") == -1) {
    PcalParams.TLAInputFile=file.getPath();
  }
 else {
    if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
      hasExtension=true;
    }
 else {
      return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (hasExtension) {
    PcalParams.TLAInputFile=file.getPath().substring(0,file.getPath().lastIndexOf(""String_Node_Str""));
    if (!file.exists()) {
      return CommandLineError(""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
    }
  }
 else {
    file=new File(PcalParams.TLAInputFile + ""String_Node_Str"");
    if (!file.exists()) {
      return CommandLineError(""String_Node_Str"" + PcalParams.TLAInputFile + ""String_Node_Str""+ file.getPath()+ ""String_Node_Str"");
    }
  }
  if (PcalParams.FairnessOption.equals(""String_Node_Str"")) {
    PcalParams.FairnessOption=""String_Node_Str"";
  }
 else {
    if (PcalParams.CheckTermination && PcalParams.FairnessOption.equals(""String_Node_Str"")) {
      PcalParams.FairnessOption=""String_Node_Str"";
    }
  }
  return STATUS_OK;
}","/** 
 * Processes the command line arguments This method changes values of public static variables of the   {@link PcalParams} SZ: This will cause problems, due to the fact that the PCalParams are static. Any initialization should overwrite the previous, which is currently NOT the case Should be re-factored to non-static access to the properties
 * @return status of processing. the status  {@link trans#STATUS_OK} indicates that no errors has been detected.the status  {@link trans#STATUS_EXIT_WITHOUT_ERROR} indicates that no errors has been found but translationshould not be started (e.G -help call) the status  {@link trans#STATUS_EXIT_WITH_ERRORS} indicates errors Change made on 9 December 2009 for pcal-file input.  This procedure is called a second time if there is pcal-file input with an options statement. It will be the second call iff  {@link PcalParams#optionsInFile} equals true.The second call should have a dummy extra argument in place of the  command-line's file-name argument.
 */
static int parseAndProcessArguments(String[] args){
  boolean inFile=PcalParams.optionsInFile;
  boolean notInFile=!inFile;
  boolean firstFairness=inFile;
  boolean explicitNof=false;
  int nextArg=0;
  int maxArg=args.length - 1;
  if (maxArg < 0) {
    return CommandLineError(""String_Node_Str"");
  }
  if (notInFile && (args[maxArg].length() != 0) && (args[maxArg].charAt(0) == '-')) {
    if (OutputHelpMessage()) {
      return STATUS_EXIT_WITHOUT_ERROR;
    }
 else {
      return STATUS_EXIT_WITH_ERRORS;
    }
  }
  while (nextArg < maxArg) {
    String option=args[nextArg];
    if (notInFile && option.equals(""String_Node_Str"")) {
      if (OutputHelpMessage()) {
        return STATUS_EXIT_WITHOUT_ERROR;
      }
 else {
        return STATUS_EXIT_WITH_ERRORS;
      }
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.WriteASTFlag=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.SpecOption=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.SpecFile=args[nextArg];
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.MyspecOption=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.SpecFile=args[nextArg];
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.Spec2Option=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
      ;
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.SpecFile=args[nextArg];
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.Myspec2Option=true;
      if (CheckForConflictingSpecOptions()) {
        return STATUS_EXIT_WITH_ERRORS;
      }
      ;
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.SpecFile=args[nextArg];
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.Debug=true;
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      PcalParams.CheckTermination=true;
    }
 else     if (option.equals(""String_Node_Str"")) {
      PcalParams.Nocfg=true;
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      if (firstFairness) {
        PcalParams.FairnessOption=""String_Node_Str"";
        firstFairness=false;
      }
      if (!PcalParams.FairnessOption.equals(""String_Node_Str"")) {
        return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
      }
      PcalParams.FairnessOption=""String_Node_Str"";
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      if (firstFairness) {
        PcalParams.FairnessOption=""String_Node_Str"";
        firstFairness=false;
      }
      if (!PcalParams.FairnessOption.equals(""String_Node_Str"")) {
        return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
      }
      PcalParams.FairnessOption=""String_Node_Str"";
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      if (firstFairness) {
        PcalParams.FairnessOption=""String_Node_Str"";
        firstFairness=false;
      }
      if (!PcalParams.FairnessOption.equals(""String_Node_Str"")) {
        return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
      }
      PcalParams.FairnessOption=""String_Node_Str"";
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      if (firstFairness) {
        PcalParams.FairnessOption=""String_Node_Str"";
        firstFairness=false;
      }
      if (!PcalParams.FairnessOption.equals(""String_Node_Str"")) {
        return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
      }
      PcalParams.FairnessOption=""String_Node_Str"";
      explicitNof=true;
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      PcalParams.LabelFlag=true;
    }
 else     if (notInFile && option.equals(""String_Node_Str"")) {
      PcalParams.ReportLabelsFlag=true;
      PcalParams.LabelFlag=true;
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      PcalParams.LabelRoot=args[nextArg];
    }
 else     if (option.equals(""String_Node_Str"") || (inFile && option.equals(""String_Node_Str""))) {
      nextArg=nextArg + 1;
      if (nextArg == maxArg) {
        return CommandLineError(""String_Node_Str"");
      }
      if (!PcalParams.ProcessVersion(args[nextArg])) {
        return CommandLineError(""String_Node_Str"");
      }
    }
 else     if (option.equals(""String_Node_Str"")) {
      nextArg=nextArg + 1;
      try {
        if (nextArg == maxArg) {
          throw new NumberFormatException();
        }
        PcalParams.SpecFile=args[nextArg];
        int a=new Integer(""String_Node_Str"").intValue();
        if (a < 60) {
          throw new NumberFormatException();
        }
        PcalTLAGen.wrapColumn=a;
        PcalTLAGen.ssWrapColumn=a - 33;
      }
 catch (      Exception e) {
        return CommandLineError(""String_Node_Str"");
      }
    }
 else {
      if (notInFile) {
        return CommandLineError(""String_Node_Str"" + option);
      }
 else {
        return CommandLineError(""String_Node_Str"" + option);
      }
    }
    ;
    nextArg=nextArg + 1;
  }
  if (nextArg > maxArg) {
    return CommandLineError(""String_Node_Str"");
  }
  if (PcalParams.FairnessOption.equals(""String_Node_Str"")) {
    PcalParams.FairnessOption=""String_Node_Str"";
  }
  if (PcalParams.CheckTermination && PcalParams.FairnessOption.equals(""String_Node_Str"") && !explicitNof) {
    PcalParams.FairnessOption=""String_Node_Str"";
  }
  if (inFile) {
    return STATUS_OK;
  }
  File file=new File(args[maxArg]);
  boolean hasExtension=false;
  if (file.getName().lastIndexOf(""String_Node_Str"") == -1) {
    PcalParams.TLAInputFile=file.getPath();
  }
 else {
    if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
      hasExtension=true;
    }
 else {
      return CommandLineError(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (hasExtension) {
    PcalParams.TLAInputFile=file.getPath().substring(0,file.getPath().lastIndexOf(""String_Node_Str""));
    if (!file.exists()) {
      return CommandLineError(""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
    }
  }
 else {
    file=new File(PcalParams.TLAInputFile + ""String_Node_Str"");
    if (!file.exists()) {
      return CommandLineError(""String_Node_Str"" + PcalParams.TLAInputFile + ""String_Node_Str""+ file.getPath()+ ""String_Node_Str"");
    }
  }
  return STATUS_OK;
}",0.9642709502155554
135991,"/** 
 * For all   {@link TheoremNode} in the tree rooted at theoremNode,this returns the  {@link TheoremNode} that is first on the linecontaining the caret, or null if none satisfy that criteria.
 * @param theoremNode
 * @return
 */
public static TheoremNode getStepWithCaret(TheoremNode theoremNode,int caretOffset,IDocument document){
  try {
    int nodeBeginLine;
    int nodeEndLine;
    if (theoremNode.getDef() != null) {
      nodeBeginLine=theoremNode.getDef().getLocation().beginLine();
    }
 else {
      nodeBeginLine=theoremNode.getTheorem().getLocation().beginLine();
    }
    nodeEndLine=theoremNode.getTheorem().getLocation().endLine();
    int caretLine=document.getLineOfOffset(caretOffset) + 1;
    if (nodeBeginLine <= caretLine && nodeEndLine >= caretLine) {
      return theoremNode;
    }
    ThmOrAssumpDefNode defNode=theoremNode.getDef();
    if (defNode != null) {
    }
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      Location proofLoc=proof.getLocation();
      if (caretLine >= proofLoc.beginColumn() && caretLine <= proofLoc.endLine()) {
        if (proof instanceof NonLeafProofNode) {
          NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
          LevelNode[] steps=nonLeafProof.getSteps();
          for (int i=0; i < steps.length; i++) {
            if (steps[i] instanceof TheoremNode) {
              TheoremNode node=getStepWithCaret((TheoremNode)steps[i],caretOffset,document);
              if (node != null) {
                return node;
              }
            }
          }
        }
      }
    }
  }
 catch (  BadLocationException e) {
    Activator.logError(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * For all   {@link TheoremNode} in the tree rooted at theoremNode,this returns the  {@link TheoremNode} that is first on the linecontaining the caret, or null if none satisfy that criteria.
 * @param theoremNode
 * @return
 */
public static TheoremNode getStepWithCaret(TheoremNode theoremNode,int caretOffset,IDocument document){
  try {
    int nodeBeginLine=theoremNode.getLocation().beginLine();
    int nodeEndLine=theoremNode.getTheorem().getLocation().endLine();
    int caretLine=document.getLineOfOffset(caretOffset) + 1;
    if (nodeBeginLine <= caretLine && nodeEndLine >= caretLine) {
      return theoremNode;
    }
    ThmOrAssumpDefNode defNode=theoremNode.getDef();
    if (defNode != null) {
    }
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      Location proofLoc=proof.getLocation();
      if (caretLine >= proofLoc.beginColumn() && caretLine <= proofLoc.endLine()) {
        if (proof instanceof NonLeafProofNode) {
          NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
          LevelNode[] steps=nonLeafProof.getSteps();
          for (int i=0; i < steps.length; i++) {
            if (steps[i] instanceof TheoremNode) {
              TheoremNode node=getStepWithCaret((TheoremNode)steps[i],caretOffset,document);
              if (node != null) {
                return node;
              }
            }
          }
        }
      }
    }
  }
 catch (  BadLocationException e) {
    Activator.logError(""String_Node_Str"",e);
  }
  return null;
}",0.6720748829953198
135992,"/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          removeItem(item);
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.WRAP);
        viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
        viewer.configure(new ObligationSourceViewerConfiguration());
        viewer.getControl().setFont(JFaceResources.getTextFont());
        fontListener.addControl(viewer.getControl());
        viewers.put(item,viewer);
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
      SourceViewer viewer=(SourceViewer)viewers.get(item);
      Assert.isNotNull(viewer,""String_Node_Str"");
      String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
      if (viewer.getDocument() == null && !oblString.isEmpty()) {
        viewer.setDocument(new Document(oblString.trim()));
        StyledText text=viewer.getTextWidget();
        item.setHeight(text.getLineHeight() * text.getLineCount());
      }
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}","/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void updateItem(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          removeItem(item);
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);
        viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
        viewer.configure(new ObligationSourceViewerConfiguration());
        viewer.getControl().setFont(JFaceResources.getTextFont());
        fontListener.addControl(viewer.getControl());
        viewers.put(item,viewer);
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
      SourceViewer viewer=(SourceViewer)viewers.get(item);
      Assert.isNotNull(viewer,""String_Node_Str"");
      String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
      if (viewer.getDocument() == null && !oblString.isEmpty()) {
        viewer.setDocument(new Document(oblString.trim()));
        StyledText text=viewer.getTextWidget();
        ScrollBar hBar=text.getHorizontalBar();
        item.setHeight(text.getLineHeight() * text.getLineCount() + (hBar != null ? hBar.getSize().y : 0));
      }
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}",0.9792374480936202
135993,"/** 
 * Computes the   {@link TLAProofPosition} for the {@link TheoremNode} and for any subproofs. For each proof in tree representedby theoremNode, this determines if a matching fold exists in previousFolds. If one does exist, it is removed from previous folds. If one does not exist, a new  {@link TLAProofPosition} is created for the proofand is added to additions. Any  {@link TLAProofPosition} that is added to additions or removed from previousFolds is addedto foldsInCurrentTree.
 * @param theoremNode
 * @throws BadLocationException 
 */
private void computeProofFoldPositions(TheoremNode theoremNode,HashMap additions,List foldsInCurrentTree,List previousFolds) throws BadLocationException {
  if (theoremNode.getProof() == null) {
    return;
  }
  IRegion theoremStatementRegion=AdapterFactory.locationToRegion(document,theoremNode.getTheorem().getLocation());
  ProofNode proofNode=theoremNode.getProof();
  IRegion proofNodeRegion=AdapterFactory.locationToRegion(document,proofNode.getLocation());
  if (document.getLineOfOffset(theoremStatementRegion.getOffset() + theoremStatementRegion.getLength()) == document.getLineOfOffset(proofNodeRegion.getOffset() + proofNodeRegion.getLength())) {
    return;
  }
  TLAProofPosition matchingPosition=null;
  for (Iterator it=previousFolds.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    if (proofPosition.isSamePosition(proofNodeRegion,document)) {
      matchingPosition=proofPosition;
      foldsInCurrentTree.add(matchingPosition);
      it.remove();
      break;
    }
  }
  if (matchingPosition == null) {
    matchingPosition=new TLAProofPosition(proofNodeRegion.getOffset(),proofNodeRegion.getLength(),theoremStatementRegion.getOffset(),theoremStatementRegion.getLength(),new ProjectionAnnotation(),document);
    additions.put(matchingPosition.getAnnotation(),matchingPosition);
    foldsInCurrentTree.add(matchingPosition);
  }
  if (proofNode instanceof NonLeafProofNode) {
    NonLeafProofNode nonLeafProofNode=(NonLeafProofNode)proofNode;
    LevelNode[] steps=nonLeafProofNode.getSteps();
    for (int i=0; i < steps.length; i++) {
      if (steps[i] instanceof TheoremNode) {
        computeProofFoldPositions((TheoremNode)steps[i],additions,foldsInCurrentTree,previousFolds);
      }
    }
  }
}","/** 
 * Computes the   {@link TLAProofPosition} for the {@link TheoremNode} and for any subproofs. For each proof in tree representedby theoremNode, this determines if a matching fold exists in previousFolds. If one does exist, it is removed from previous folds. If one does not exist, a new  {@link TLAProofPosition} is created for the proofand is added to additions. Any  {@link TLAProofPosition} that is added to additions or removed from previousFolds is addedto foldsInCurrentTree.
 * @param theoremNode
 * @throws BadLocationException 
 */
private void computeProofFoldPositions(TheoremNode theoremNode,HashMap additions,List foldsInCurrentTree,List previousFolds) throws BadLocationException {
  if (theoremNode.getProof() == null) {
    return;
  }
  IRegion theoremStatementRegion=AdapterFactory.locationToRegion(document,theoremNode.getTheorem().getLocation());
  IRegion theoremRegion=AdapterFactory.locationToRegion(document,theoremNode.getLocation());
  ProofNode proofNode=theoremNode.getProof();
  IRegion proofNodeRegion=AdapterFactory.locationToRegion(document,proofNode.getLocation());
  if (document.getLineOfOffset(theoremStatementRegion.getOffset() + theoremStatementRegion.getLength()) == document.getLineOfOffset(proofNodeRegion.getOffset() + proofNodeRegion.getLength())) {
    return;
  }
  TLAProofPosition matchingPosition=null;
  for (Iterator it=previousFolds.iterator(); it.hasNext(); ) {
    TLAProofPosition proofPosition=(TLAProofPosition)it.next();
    if (proofPosition.isSamePosition(proofNodeRegion,document)) {
      matchingPosition=proofPosition;
      foldsInCurrentTree.add(matchingPosition);
      it.remove();
      break;
    }
  }
  if (matchingPosition == null) {
    matchingPosition=new TLAProofPosition(proofNodeRegion.getOffset(),proofNodeRegion.getLength(),theoremRegion.getOffset(),theoremStatementRegion.getOffset() + theoremStatementRegion.getLength() - theoremRegion.getOffset(),new ProjectionAnnotation(),document);
    additions.put(matchingPosition.getAnnotation(),matchingPosition);
    foldsInCurrentTree.add(matchingPosition);
  }
  if (proofNode instanceof NonLeafProofNode) {
    NonLeafProofNode nonLeafProofNode=(NonLeafProofNode)proofNode;
    LevelNode[] steps=nonLeafProofNode.getSteps();
    for (int i=0; i < steps.length; i++) {
      if (steps[i] instanceof TheoremNode) {
        computeProofFoldPositions((TheoremNode)steps[i],additions,foldsInCurrentTree,previousFolds);
      }
    }
  }
}",0.9454317374033032
135994,"/** 
 * Constructor for the position. For the offset and length for the proof and statement, first obtain the   {@link Location} from the syntax tree. For the proof, usethe location returned by  {@link ProofNode#getLocation()}, where the   {@link ProofNode} is obtained by {@link TheoremNode#getProof()}. For the statement, use the location returned by   {@link LevelNode#getLocation()}  for the {@link LevelNode} returned by {@link TheoremNode#getTheorem()}. To convert from the 4-int   {@link Location} to the offset and length, use {@link AdapterFactory#locationToRegion(IDocument,Location)} andthen use the offset and length for the returned region.
 * @param initProofOffset initial offset of the proof
 * @param initProofLength initial length of the proof
 * @param initStatementOffset initial offset of the statement of the theorem or stepfor which this is a proof
 * @param initStatementLength initial length of the statement of the theorem or stepfor which this is a proof
 * @param annotation {@link ProjectionAnnotation} that should be at this position
 * @param document
 */
public TLAProofPosition(int initProofOffset,int initProofLength,int initStatementOffset,int initStatementLength,ProjectionAnnotation annotation,IDocument document){
  IRegion region=alignRegion(new Region(initStatementOffset,initProofOffset + initProofLength - initStatementOffset),document);
  offset=region.getOffset();
  length=region.getLength();
  positionOfStatement=new Position(initStatementOffset,initStatementLength);
  positionOfProof=new Position(initProofOffset,initProofLength);
  this.annotation=annotation;
  try {
    document.addPosition(positionOfProof);
    document.addPosition(positionOfStatement);
  }
 catch (  BadLocationException e) {
    Activator.logError(""String_Node_Str"" + this,e);
  }
}","/** 
 * Constructor for the position. For the offset and length for the proof and statement, first obtain the   {@link Location} from the syntax tree. For the proof, usethe location returned by  {@link ProofNode#getLocation()}, where the   {@link ProofNode} is obtained by {@link TheoremNode#getProof()}. For initTheoremOffset, use the beginning of the location returned by   {@link TheoremNode#getLocation()}. For the end of the statement, use the end of the location returned by   {@link LevelNode#getLocation()} for the  {@link LevelNode} returned by {@link TheoremNode#getTheorem()}. To convert from the 4-int   {@link Location} to the offset and length, use {@link AdapterFactory#locationToRegion(IDocument,Location)} andthen use the offset and length for the returned region.
 * @param initProofOffset initial offset of the proof
 * @param initProofLength initial length of the proof
 * @param initTheoremOffset initial offset of the theorem or stepfor which this is a proof
 * @param initLengthToEndOfStatement initial length from initTheoremOffset to the end ofthe statement of the theorem
 * @param annotation {@link ProjectionAnnotation} that should be at this position
 * @param document
 */
public TLAProofPosition(int initProofOffset,int initProofLength,int initTheoremOffset,int initLengthToEndOfStatement,ProjectionAnnotation annotation,IDocument document){
  IRegion region=alignRegion(new Region(initTheoremOffset,initProofOffset + initProofLength - initTheoremOffset),document);
  offset=region.getOffset();
  length=region.getLength();
  positionOfStatement=new Position(initTheoremOffset,initLengthToEndOfStatement);
  positionOfProof=new Position(initProofOffset,initProofLength);
  this.annotation=annotation;
  try {
    document.addPosition(positionOfProof);
    document.addPosition(positionOfStatement);
  }
 catch (  BadLocationException e) {
    Activator.logError(""String_Node_Str"" + this,e);
  }
}",0.7706323687031083
135995,"/** 
 * This method is called when the TLC Model Checker / New Model command  is executed.  The last thing it does is call the Eclipse magic that calls the appropriate methods to open the model pages.  Thus, any initial settings of values in the model is done here by setting the appropriate attributes of the model.
 */
public Object execute(ExecutionEvent event) throws ExecutionException {
  String parameter=event.getParameter(PARAM_SPEC_NAME);
  Spec spec=null;
  if (parameter != null) {
    spec=ToolboxHandle.getSpecByName(parameter);
  }
 else {
    spec=ToolboxHandle.getCurrentSpec();
  }
  if (spec == null) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  IProject specProject=spec.getProject();
  SpecObj specObject=spec.getRootModule();
  if (specObject == null) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  ILaunchManager launchManager=DebugPlugin.getDefault().getLaunchManager();
  ILaunchConfigurationType launchConfigurationType=launchManager.getLaunchConfigurationType(TLCModelLaunchDelegate.LAUNCH_CONFIGURATION_TYPE);
  modelName=ModelHelper.constructModelName(specProject);
  IInputValidator modelNameInputValidator=new ModelNameValidator(specProject);
  final InputDialog dialog=new InputDialog(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"",modelName,modelNameInputValidator);
  dialog.setBlockOnOpen(true);
  UIHelper.runUISync(new Runnable(){
    public void run(){
      int open=dialog.open();
switch (open) {
case Window.OK:
        modelName=dialog.getValue();
      break;
case Window.CANCEL:
    modelName=null;
}
}
}
);
if (modelName == null) {
return null;
}
ModuleNode moduleNode=specObject.getExternalModuleTable().getRootModule();
List constants=ModelHelper.createConstantsList(moduleNode);
Iterator iter=constants.iterator();
boolean done=false;
while ((!done) && iter.hasNext()) {
Assignment assign=(Assignment)iter.next();
if (assign.getLabel().equals(""String_Node_Str"")) {
assign.setRight(""String_Node_Str"");
done=true;
}
}
try {
ILaunchConfigurationWorkingCopy launchCopy=launchConfigurationType.newInstance(specProject,specProject.getName() + ""String_Node_Str"" + modelName);
launchCopy.setAttribute(SPEC_NAME,spec.getName());
launchCopy.setAttribute(MODEL_NAME,modelName);
if (constants.size() == 0) {
launchCopy.setAttribute(MODEL_PARAMETER_CONSTANTS,(List)null);
}
 else {
launchCopy.setAttribute(MODEL_PARAMETER_CONSTANTS,ModelHelper.serializeAssignmentList(constants));
}
OpDefNode[] defs=moduleNode.getOpDefs();
boolean foundSpec=false;
boolean foundInit=false;
boolean foundNext=false;
boolean foundTermination=false;
for (int i=0; i < defs.length; i++) {
if (defs[i].getName().toString().equals(""String_Node_Str"") && (defs[i].getLevel() == LevelNode.TemporalLevel)) {
  foundSpec=true;
}
 else if (defs[i].getName().toString().equals(""String_Node_Str"") && (defs[i].getLevel() == LevelNode.VariableLevel)) {
  foundInit=true;
}
 else if (defs[i].getName().toString().equals(""String_Node_Str"") && (defs[i].getLevel() == LevelNode.ActionLevel)) {
  foundNext=true;
}
 else if (defs[i].getName().toString().equals(""String_Node_Str"") && (defs[i].getLevel() == LevelNode.TemporalLevel)) {
  foundTermination=true;
}
}
if (foundSpec) {
launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_CLOSED_SPECIFICATION,""String_Node_Str"");
launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_SPEC_TYPE,IModelConfigurationDefaults.MODEL_BEHAVIOR_TYPE_SPEC_CLOSED);
if (foundTermination) {
  Vector vec=new Vector();
  launchCopy.setAttribute(MODEL_PROPERTIES_EXPAND,""String_Node_Str"");
  vec.add(""String_Node_Str"");
  launchCopy.setAttribute(IModelConfigurationConstants.MODEL_CORRECTNESS_PROPERTIES,vec);
}
}
 else if (foundInit && foundNext) {
launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_INIT,""String_Node_Str"");
launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_NEXT,""String_Node_Str"");
launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_SPEC_TYPE,IModelConfigurationDefaults.MODEL_BEHAVIOR_TYPE_SPEC_INIT_NEXT);
}
ILaunchConfiguration launchSaved=launchCopy.doSave();
HashMap parameters=new HashMap();
parameters.put(OpenModelHandler.PARAM_MODEL_NAME,modelName);
UIHelper.runCommand(OpenModelHandler.COMMAND_ID,parameters);
return launchSaved;
}
 catch (CoreException e) {
TLCUIActivator.logError(""String_Node_Str"",e);
}
return null;
}","/** 
 * This method is called when the TLC Model Checker / New Model command  is executed.  The last thing it does is call the Eclipse magic that calls the appropriate methods to open the model pages.  Thus, any initial settings of values in the model is done here by setting the appropriate attributes of the model.
 */
public Object execute(ExecutionEvent event) throws ExecutionException {
  String parameter=event.getParameter(PARAM_SPEC_NAME);
  Spec spec=null;
  if (parameter != null) {
    spec=ToolboxHandle.getSpecByName(parameter);
  }
 else {
    spec=ToolboxHandle.getCurrentSpec();
  }
  if (spec == null) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  IProject specProject=spec.getProject();
  SpecObj specObject=spec.getRootModule();
  if (specObject == null) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  ILaunchManager launchManager=DebugPlugin.getDefault().getLaunchManager();
  ILaunchConfigurationType launchConfigurationType=launchManager.getLaunchConfigurationType(TLCModelLaunchDelegate.LAUNCH_CONFIGURATION_TYPE);
  modelName=ModelHelper.constructModelName(specProject);
  IInputValidator modelNameInputValidator=new ModelNameValidator(specProject);
  final InputDialog dialog=new InputDialog(UIHelper.getShellProvider().getShell(),""String_Node_Str"",""String_Node_Str"",modelName,modelNameInputValidator);
  dialog.setBlockOnOpen(true);
  UIHelper.runUISync(new Runnable(){
    public void run(){
      int open=dialog.open();
switch (open) {
case Window.OK:
        modelName=dialog.getValue();
      break;
case Window.CANCEL:
    modelName=null;
}
}
}
);
if (modelName == null) {
return null;
}
ModuleNode moduleNode=specObject.getExternalModuleTable().getRootModule();
List constants=ModelHelper.createConstantsList(moduleNode);
Iterator iter=constants.iterator();
boolean done=false;
while ((!done) && iter.hasNext()) {
Assignment assign=(Assignment)iter.next();
if (assign.getLabel().equals(""String_Node_Str"") && (assign.getParams().length == 0)) {
assign.setRight(""String_Node_Str"");
done=true;
}
}
try {
ILaunchConfigurationWorkingCopy launchCopy=launchConfigurationType.newInstance(specProject,specProject.getName() + ""String_Node_Str"" + modelName);
launchCopy.setAttribute(SPEC_NAME,spec.getName());
launchCopy.setAttribute(MODEL_NAME,modelName);
if (constants.size() == 0) {
launchCopy.setAttribute(MODEL_PARAMETER_CONSTANTS,(List)null);
}
 else {
launchCopy.setAttribute(MODEL_PARAMETER_CONSTANTS,ModelHelper.serializeAssignmentList(constants));
}
OpDefNode[] defs=moduleNode.getOpDefs();
boolean foundSpec=false;
boolean foundInit=false;
boolean foundNext=false;
boolean foundTermination=false;
for (int i=0; i < defs.length; i++) {
if (defs[i].getNumberOfArgs() == 0) {
  if (defs[i].getName().toString().equals(""String_Node_Str"") && (defs[i].getLevel() == LevelNode.TemporalLevel)) {
    foundSpec=true;
  }
 else   if (defs[i].getName().toString().equals(""String_Node_Str"") && (defs[i].getLevel() == LevelNode.VariableLevel)) {
    foundInit=true;
  }
 else   if (defs[i].getName().toString().equals(""String_Node_Str"") && (defs[i].getLevel() == LevelNode.ActionLevel)) {
    foundNext=true;
  }
 else   if (defs[i].getName().toString().equals(""String_Node_Str"") && (defs[i].getLevel() == LevelNode.TemporalLevel)) {
    foundTermination=true;
  }
}
}
if (foundSpec) {
launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_CLOSED_SPECIFICATION,""String_Node_Str"");
launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_SPEC_TYPE,IModelConfigurationDefaults.MODEL_BEHAVIOR_TYPE_SPEC_CLOSED);
if (foundTermination) {
  Vector vec=new Vector();
  launchCopy.setAttribute(MODEL_PROPERTIES_EXPAND,""String_Node_Str"");
  vec.add(""String_Node_Str"");
  launchCopy.setAttribute(IModelConfigurationConstants.MODEL_CORRECTNESS_PROPERTIES,vec);
}
}
 else if (foundInit || foundNext) {
launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_SPEC_TYPE,IModelConfigurationDefaults.MODEL_BEHAVIOR_TYPE_SPEC_INIT_NEXT);
if (foundInit) {
  launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_INIT,""String_Node_Str"");
}
if (foundNext) {
  launchCopy.setAttribute(IModelConfigurationConstants.MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_NEXT,""String_Node_Str"");
}
}
ILaunchConfiguration launchSaved=launchCopy.doSave();
HashMap parameters=new HashMap();
parameters.put(OpenModelHandler.PARAM_MODEL_NAME,modelName);
UIHelper.runCommand(OpenModelHandler.COMMAND_ID,parameters);
return launchSaved;
}
 catch (CoreException e) {
TLCUIActivator.logError(""String_Node_Str"",e);
}
return null;
}",0.9197625851835568
135996,"/** 
 * For all   {@link TheoremNode} in the tree rooted at theoremNode,this returns the  {@link TheoremNode} that is first on the linecontaining the caret, or null if none satisfy that criteria.
 * @param theoremNode
 * @return
 */
public static TheoremNode getStepWithCaret(TheoremNode theoremNode,int caretOffset,IDocument document){
  try {
    Location stepLoc=theoremNode.getTheorem().getLocation();
    int caretLine=document.getLineOfOffset(caretOffset) + 1;
    if (stepLoc.beginLine() <= caretLine && stepLoc.endLine() >= caretLine) {
      return theoremNode;
    }
    ThmOrAssumpDefNode defNode=theoremNode.getDef();
    if (defNode != null) {
    }
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      Location proofLoc=proof.getLocation();
      if (caretLine >= proofLoc.beginColumn() && caretLine <= proofLoc.endLine()) {
        if (proof instanceof NonLeafProofNode) {
          NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
          LevelNode[] steps=nonLeafProof.getSteps();
          for (int i=0; i < steps.length; i++) {
            if (steps[i] instanceof TheoremNode) {
              TheoremNode node=getStepWithCaret((TheoremNode)steps[i],caretOffset,document);
              if (node != null) {
                return node;
              }
            }
          }
        }
      }
    }
  }
 catch (  BadLocationException e) {
    Activator.logError(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * For all   {@link TheoremNode} in the tree rooted at theoremNode,this returns the  {@link TheoremNode} that is first on the linecontaining the caret, or null if none satisfy that criteria.
 * @param theoremNode
 * @return
 */
public static TheoremNode getStepWithCaret(TheoremNode theoremNode,int caretOffset,IDocument document){
  try {
    int nodeBeginLine;
    int nodeEndLine;
    if (theoremNode.getDef() != null) {
      nodeBeginLine=theoremNode.getDef().getLocation().beginLine();
    }
 else {
      nodeBeginLine=theoremNode.getTheorem().getLocation().beginLine();
    }
    nodeEndLine=theoremNode.getTheorem().getLocation().endLine();
    int caretLine=document.getLineOfOffset(caretOffset) + 1;
    if (nodeBeginLine <= caretLine && nodeEndLine >= caretLine) {
      return theoremNode;
    }
    ThmOrAssumpDefNode defNode=theoremNode.getDef();
    if (defNode != null) {
    }
    ProofNode proof=theoremNode.getProof();
    if (proof != null) {
      Location proofLoc=proof.getLocation();
      if (caretLine >= proofLoc.beginColumn() && caretLine <= proofLoc.endLine()) {
        if (proof instanceof NonLeafProofNode) {
          NonLeafProofNode nonLeafProof=(NonLeafProofNode)proof;
          LevelNode[] steps=nonLeafProof.getSteps();
          for (int i=0; i < steps.length; i++) {
            if (steps[i] instanceof TheoremNode) {
              TheoremNode node=getStepWithCaret((TheoremNode)steps[i],caretOffset,document);
              if (node != null) {
                return node;
              }
            }
          }
        }
      }
    }
  }
 catch (  BadLocationException e) {
    Activator.logError(""String_Node_Str"",e);
  }
  return null;
}",0.8916428344455036
135997,"/** 
 * Installs a new marker on the obligation in the message or updates the existing marker on that obligation (if there is one) with the information contained in message. The message location should be for a module in the currently opened spec. If no such module exists, this method returns null. Returns the marker created or updated.
 * @param message must not be null
 */
public static IMarker newObligationStatus(ObligationStatusMessage message){
  Location location=message.getLocation();
  IResource module=ResourceHelper.getResourceByModuleName(location.source());
  if (module != null && module instanceof IFile && module.exists()) {
    FileEditorInput fileEditorInput=new FileEditorInput((IFile)module);
    FileDocumentProvider fileDocumentProvider=new FileDocumentProvider();
    try {
      IMarker[] markers=module.findMarkers(ProverHelper.OBLIGATION_MARKER,false,IResource.DEPTH_ZERO);
      for (int i=0; i < markers.length; i++) {
        if (markers[i].getAttribute(ProverHelper.OBLIGATION_ID,-1) == message.getID()) {
          markers[i].setAttribute(ProverHelper.OBLIGATION_STATUS,message.getStatus());
          markers[i].setAttribute(ProverHelper.OBLIGATION_METHOD,message.getMethod());
          return markers[i];
        }
      }
      IMarker marker=module.createMarker(ProverHelper.OBLIGATION_MARKER);
      marker.setAttribute(ProverHelper.OBLIGATION_ID,message.getID());
      marker.setAttribute(ProverHelper.OBLIGATION_METHOD,message.getMethod());
      marker.setAttribute(ProverHelper.OBLIGATION_STATUS,message.getStatus());
      marker.setAttribute(ProverHelper.OBLIGATION_STRING,message.getObString());
      fileDocumentProvider.connect(fileEditorInput);
      IDocument document=fileDocumentProvider.getDocument(fileEditorInput);
      IRegion obRegion=AdapterFactory.locationToRegion(document,location);
      marker.setAttribute(IMarker.CHAR_START,obRegion.getOffset());
      marker.setAttribute(IMarker.CHAR_END,obRegion.getOffset() + obRegion.getLength());
      return marker;
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
 finally {
      fileDocumentProvider.disconnect(fileEditorInput);
    }
  }
  return null;
}","/** 
 * Installs a new marker on the obligation in the message or updates the existing marker on that obligation (if there is one) with the information contained in message. The message location should be for a module in the currently opened spec. If no such module exists, this method returns null. Returns the marker created or updated.
 * @param message must not be null
 */
public static IMarker newObligationStatus(ObligationStatusMessage message){
  Location location=message.getLocation();
  IResource module=ResourceHelper.getResourceByModuleName(location.source());
  if (module != null && module instanceof IFile && module.exists()) {
    FileEditorInput fileEditorInput=new FileEditorInput((IFile)module);
    FileDocumentProvider fileDocumentProvider=new FileDocumentProvider();
    try {
      IMarker[] markers=module.findMarkers(ProverHelper.OBLIGATION_MARKER,false,IResource.DEPTH_ZERO);
      for (int i=0; i < markers.length; i++) {
        if (markers[i].getAttribute(ProverHelper.OBLIGATION_ID,-1) == message.getID()) {
          markers[i].setAttribute(ProverHelper.OBLIGATION_STATUS,message.getStatus());
          markers[i].setAttribute(ProverHelper.OBLIGATION_METHOD,message.getMethod());
          return markers[i];
        }
      }
      IMarker marker=module.createMarker(ProverHelper.OBLIGATION_MARKER);
      marker.setAttribute(ProverHelper.OBLIGATION_ID,message.getID());
      marker.setAttribute(ProverHelper.OBLIGATION_METHOD,message.getMethod());
      marker.setAttribute(ProverHelper.OBLIGATION_STATUS,message.getStatus());
      marker.setAttribute(ProverHelper.OBLIGATION_STRING,message.getObString());
      fileDocumentProvider.connect(fileEditorInput);
      IDocument document=fileDocumentProvider.getDocument(fileEditorInput);
      IRegion obRegion=AdapterFactory.locationToRegion(document,location);
      marker.setAttribute(IMarker.CHAR_START,obRegion.getOffset());
      marker.setAttribute(IMarker.CHAR_END,obRegion.getOffset() + obRegion.getLength() - 1);
      return marker;
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
 finally {
      fileDocumentProvider.disconnect(fileEditorInput);
    }
  }
  return null;
}",0.9991158267020336
135998,"public ObligationsView(){
  items=new HashMap();
}","public ObligationsView(){
  items=new HashMap();
  viewers=new HashMap();
}",0.8
135999,"/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void newMarker(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          item.getControl().dispose();
          item.dispose();
          items.remove(new Integer(id));
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.WRAP);
        StyledText text=viewer.getTextWidget();
        String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
        viewer.setDocument(new Document(oblString.trim()));
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        item.setHeight(text.getLineHeight() * text.getLineCount());
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}","/** 
 * Adds the information from the marker to the view. Should be a marker of type   {@link ProverHelper#OBLIGATION_METHOD}. If there is already an item with information of the same obligation as the marker, that item is updated. If no such item exists, a new one is created.
 */
private void newMarker(IMarker marker){
  try {
    Assert.isTrue(marker.getType().equals(ProverHelper.OBLIGATION_MARKER),""String_Node_Str"");
    int id=marker.getAttribute(ProverHelper.OBLIGATION_ID,-1);
    if (id != -1) {
      ExpandItem item=(ExpandItem)items.get(new Integer(id));
      if (!ProverHelper.isInterestingObligation(marker)) {
        if (item != null) {
          item.getControl().dispose();
          item.dispose();
          items.remove(new Integer(id));
        }
        return;
      }
      if (item == null) {
        item=new ExpandItem(bar,SWT.None,0);
        Composite oblWidget=new Composite(bar,SWT.LINE_SOLID);
        GridLayout gl=new GridLayout(1,true);
        gl.marginWidth=0;
        gl.marginHeight=0;
        oblWidget.setLayout(gl);
        SourceViewer viewer=new SourceViewer(oblWidget,null,SWT.READ_ONLY | SWT.MULTI | SWT.WRAP);
        viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL,SWT.FILL,true,true));
        viewers.put(item,viewer);
        item.setControl(oblWidget);
        item.setExpanded(true);
        item.setData(marker);
        viewer.getTextWidget().setData(marker);
        oblWidget.setData(marker);
        item.addListener(SWT.MouseDown,listener);
        viewer.getTextWidget().addListener(SWT.MouseDown,listener);
        oblWidget.addListener(SWT.MouseDown,listener);
        items.put(new Integer(id),item);
      }
      String status=marker.getAttribute(ProverHelper.OBLIGATION_STATUS,""String_Node_Str"");
      String method=marker.getAttribute(ProverHelper.OBLIGATION_METHOD,""String_Node_Str"");
      item.setText(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ method);
      SourceViewer viewer=(SourceViewer)viewers.get(item);
      Assert.isNotNull(viewer,""String_Node_Str"");
      String oblString=marker.getAttribute(ProverHelper.OBLIGATION_STRING,""String_Node_Str"");
      if (viewer.getDocument() == null && !oblString.isEmpty()) {
        viewer.setDocument(new Document(oblString.trim()));
        StyledText text=viewer.getTextWidget();
        System.out.println(viewer.getDocument().get());
        System.out.println(""String_Node_Str"" + text.getLineCount());
        item.setHeight(text.getLineHeight() * text.getLineCount());
      }
    }
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
}",0.8052489064778171
136000,"/** 
 * Should be called to update the status of a proof step. Does nothing if status is null.
 * @param status
 */
public static void newStepStatus(ProofStepStatus status){
  if (status == null) {
    return;
  }
  Location location=status.getLocation();
  IResource module=ResourceHelper.getResourceByModuleName(location.source());
  if (module != null && module instanceof IFile && module.exists()) {
    FileEditorInput fileEditorInput=new FileEditorInput((IFile)module);
    FileDocumentProvider fileDocumentProvider=new FileDocumentProvider();
    try {
      fileDocumentProvider.connect(fileEditorInput);
      IDocument document=fileDocumentProvider.getDocument(fileEditorInput);
      IMarker newMarker=module.createMarker(statusStringToMarkerType(status.getStatus()));
      Map markerAttributes=new HashMap(2);
      IRegion stepRegion=AdapterFactory.locationToRegion(document,location);
      markerAttributes.put(IMarker.CHAR_START,new Integer(stepRegion.getOffset()));
      markerAttributes.put(IMarker.CHAR_END,new Integer(stepRegion.getOffset() + stepRegion.getLength()));
      newMarker.setAttributes(markerAttributes);
      IMarker[] existingMarkers=module.findMarkers(STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
      for (int i=0; i < existingMarkers.length; i++) {
        IMarker existingMarker=existingMarkers[i];
        int startChar=existingMarker.getAttribute(IMarker.CHAR_START,-1);
        int endChar=existingMarker.getAttribute(IMarker.CHAR_END,-1);
        if (stepRegion.getOffset() < startChar && stepRegion.getLength() + stepRegion.getOffset() > endChar) {
          existingMarker.delete();
        }
      }
    }
 catch (    CoreException e) {
      ProverUIActivator.logError(""String_Node_Str"" + ""String_Node_Str"" + status.getStatus() + ""String_Node_Str""+ location,e);
    }
catch (    BadLocationException e) {
      ProverUIActivator.logError(""String_Node_Str"" + ""String_Node_Str"" + status.getStatus() + ""String_Node_Str""+ location,e);
    }
 finally {
      fileDocumentProvider.disconnect(fileEditorInput);
    }
  }
 else {
    ProverUIActivator.logDebug(""String_Node_Str"" + ""String_Node_Str"" + status.getStatus() + ""String_Node_Str""+ location);
  }
}","/** 
 * Should be called to update the status of a proof step. Does nothing if status is null.
 * @param status
 */
public static void newStepStatus(ProofStepStatus status){
  if (status == null) {
    return;
  }
  Location location=status.getLocation();
  IResource module=ResourceHelper.getResourceByModuleName(location.source());
  if (module != null && module instanceof IFile && module.exists()) {
    FileEditorInput fileEditorInput=new FileEditorInput((IFile)module);
    FileDocumentProvider fileDocumentProvider=new FileDocumentProvider();
    try {
      fileDocumentProvider.connect(fileEditorInput);
      IDocument document=fileDocumentProvider.getDocument(fileEditorInput);
      IMarker newMarker=module.createMarker(statusStringToMarkerType(status.getStatus()));
      Map markerAttributes=new HashMap(2);
      IRegion stepRegion=AdapterFactory.locationToRegion(document,location);
      markerAttributes.put(IMarker.CHAR_START,new Integer(stepRegion.getOffset()));
      markerAttributes.put(IMarker.CHAR_END,new Integer(stepRegion.getOffset() + stepRegion.getLength() - 1));
      newMarker.setAttributes(markerAttributes);
      IMarker[] existingMarkers=module.findMarkers(STEP_STATUS_MARKER,true,IResource.DEPTH_ZERO);
      for (int i=0; i < existingMarkers.length; i++) {
        IMarker existingMarker=existingMarkers[i];
        int startChar=existingMarker.getAttribute(IMarker.CHAR_START,-1);
        int endChar=existingMarker.getAttribute(IMarker.CHAR_END,-1);
        if (stepRegion.getOffset() < startChar && stepRegion.getLength() + stepRegion.getOffset() > endChar) {
          existingMarker.delete();
        }
      }
    }
 catch (    CoreException e) {
      ProverUIActivator.logError(""String_Node_Str"" + ""String_Node_Str"" + status.getStatus() + ""String_Node_Str""+ location,e);
    }
catch (    BadLocationException e) {
      ProverUIActivator.logError(""String_Node_Str"" + ""String_Node_Str"" + status.getStatus() + ""String_Node_Str""+ location,e);
    }
 finally {
      fileDocumentProvider.disconnect(fileEditorInput);
    }
  }
 else {
    ProverUIActivator.logDebug(""String_Node_Str"" + ""String_Node_Str"" + status.getStatus() + ""String_Node_Str""+ location);
  }
}",0.999092558983666
