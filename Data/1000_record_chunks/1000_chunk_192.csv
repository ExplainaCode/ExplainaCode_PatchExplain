record_number,buggy_code,fixed_code,code_similarity
191001,"@VisibleForTesting public RecentsTaskLoadPlan(Context context,SystemServicesProxy ssp){
  mContext=context;
  mSystemServicesProxy=ssp;
}","/** 
 * Package level ctor 
 */
RecentsTaskLoadPlan(Context context){
  mContext=context;
}",0.5701754385964912
191002,"@Override public void start(){
  sDebugFlags=new RecentsDebugFlags(mContext);
  sSystemServicesProxy=SystemServicesProxy.getInstance(mContext);
  sTaskLoader=new RecentsTaskLoader(mContext);
  sConfiguration=new RecentsConfiguration(mContext);
  UiModeManager uiModeManager=(UiModeManager)mContext.getSystemService(Context.UI_MODE_SERVICE);
  if (uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION) {
    mImpl=new RecentsTvImpl(mContext);
  }
 else {
    mImpl=new RecentsImpl(mContext);
  }
  if (""String_Node_Str"".equals(Build.TYPE) || ""String_Node_Str"".equals(Build.TYPE)) {
    String cnStr=SystemProperties.get(RECENTS_OVERRIDE_SYSPROP_KEY);
    if (!cnStr.isEmpty()) {
      mOverrideRecentsPackageName=cnStr;
    }
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sSystemServicesProxy,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sTaskLoader,EVENT_BUS_PRIORITY);
  final int processUser=sSystemServicesProxy.getProcessUser();
  if (sSystemServicesProxy.isSystemUser(processUser)) {
    mSystemToUserCallbacks=new RecentsSystemUser(mContext,mImpl);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    mContext.registerReceiverAsUser(mSystemUserUnlockedReceiver,UserHandle.SYSTEM,filter,null,null);
  }
 else {
    registerWithSystemUser();
  }
  putComponent(Recents.class,this);
  long lastVisibleTaskActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,-1);
  if (lastVisibleTaskActiveTime != -1) {
    long uptime=SystemClock.elapsedRealtime();
    Settings.Secure.putLongForUser(mContext.getContentResolver(),Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,uptime - Math.max(0,System.currentTimeMillis() - lastVisibleTaskActiveTime),processUser);
    Prefs.remove(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME);
  }
}","@Override public void start(){
  sDebugFlags=new RecentsDebugFlags(mContext);
  sSystemServicesProxy=SystemServicesProxy.getInstance(mContext);
  sTaskLoader=new RecentsTaskLoader(mContext);
  sConfiguration=new RecentsConfiguration(mContext);
  UiModeManager uiModeManager=(UiModeManager)mContext.getSystemService(Context.UI_MODE_SERVICE);
  if (uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION) {
    mImpl=new RecentsTvImpl(mContext);
  }
 else {
    mImpl=new RecentsImpl(mContext);
  }
  if (""String_Node_Str"".equals(Build.TYPE) || ""String_Node_Str"".equals(Build.TYPE)) {
    String cnStr=SystemProperties.get(RECENTS_OVERRIDE_SYSPROP_KEY);
    if (!cnStr.isEmpty()) {
      mOverrideRecentsPackageName=cnStr;
    }
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sSystemServicesProxy,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sTaskLoader,EVENT_BUS_PRIORITY);
  final int processUser=sSystemServicesProxy.getProcessUser();
  if (sSystemServicesProxy.isSystemUser(processUser)) {
    mSystemToUserCallbacks=new RecentsSystemUser(mContext,mImpl);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    mContext.registerReceiverAsUser(mSystemUserUnlockedReceiver,UserHandle.SYSTEM,filter,null,null);
  }
 else {
    registerWithSystemUser();
  }
  putComponent(Recents.class,this);
}",0.8532690569448629
191003,"@Override public void dump(String prefix,FileDescriptor fd,PrintWriter writer,String[] args){
  super.dump(prefix,fd,writer,args);
  EventBus.getDefault().dump(prefix,writer);
  Recents.getTaskLoader().dump(prefix,writer);
  ContentResolver cr=getContentResolver();
  long lastPersistUptime=Settings.Secure.getLong(cr,Settings.Secure.TASK_PERSISTER_LAST_WRITE_UPTIME,0);
  long lastVisibleTaskActiveUptime=Settings.Secure.getLongForUser(cr,Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,SystemClock.elapsedRealtime(),Recents.getSystemServices().getCurrentUser());
  String id=Integer.toHexString(System.identityHashCode(this));
  writer.print(prefix);
  writer.print(TAG);
  writer.print(""String_Node_Str"");
  writer.print(mIsVisible ? ""String_Node_Str"" : ""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(lastPersistUptime);
  writer.print(""String_Node_Str"");
  writer.print(lastVisibleTaskActiveUptime);
  writer.print(""String_Node_Str"");
  writer.print(id);
  writer.print(""String_Node_Str"");
  writer.println();
  if (mRecentsView != null) {
    mRecentsView.dump(prefix,writer);
  }
}","@Override public void dump(String prefix,FileDescriptor fd,PrintWriter writer,String[] args){
  super.dump(prefix,fd,writer,args);
  EventBus.getDefault().dump(prefix,writer);
  Recents.getTaskLoader().dump(prefix,writer);
  String id=Integer.toHexString(System.identityHashCode(this));
  long lastStackActiveTime=Prefs.getLong(this,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,-1);
  writer.print(prefix);
  writer.print(TAG);
  writer.print(""String_Node_Str"");
  writer.print(mIsVisible ? ""String_Node_Str"" : ""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(lastStackActiveTime);
  writer.print(""String_Node_Str"");
  writer.print(System.currentTimeMillis());
  writer.print(""String_Node_Str"");
  writer.print(id);
  writer.print(""String_Node_Str"");
  writer.println();
  if (mRecentsView != null) {
    mRecentsView.dump(prefix,writer);
  }
}",0.6817724068479355
191004,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mFinishedOnStartup=false;
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp == null) {
    mFinishedOnStartup=true;
    finish();
    return;
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  mPackageMonitor=new RecentsPackageMonitor();
  mPackageMonitor.register(this);
  setContentView(R.layout.recents);
  takeKeyEvents(true);
  mRecentsView=(RecentsView)findViewById(R.id.recents_view);
  mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mScrimViews=new SystemBarScrimViews(this);
  getWindow().getAttributes().privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY;
  Configuration appConfiguration=Utilities.getAppConfiguration(this);
  mLastDeviceOrientation=appConfiguration.orientation;
  mLastDisplayDensity=appConfiguration.densityDpi;
  mFocusTimerDuration=getResources().getInteger(R.integer.recents_auto_advance_duration);
  mIterateTrigger=new DozeTrigger(mFocusTimerDuration,new Runnable(){
    @Override public void run(){
      dismissRecentsToFocusedTask(MetricsEvent.OVERVIEW_SELECT_TIMEOUT);
    }
  }
);
  getWindow().setBackgroundDrawable(mRecentsView.getBackgroundScrim());
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mSystemBroadcastReceiver,filter);
  getWindow().addPrivateFlags(LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION);
  reloadStackView();
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mFinishedOnStartup=false;
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp == null) {
    mFinishedOnStartup=true;
    finish();
    return;
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  mPackageMonitor=new RecentsPackageMonitor();
  mPackageMonitor.register(this);
  setContentView(R.layout.recents);
  takeKeyEvents(true);
  mRecentsView=(RecentsView)findViewById(R.id.recents_view);
  mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mScrimViews=new SystemBarScrimViews(this);
  getWindow().getAttributes().privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY;
  Configuration appConfiguration=Utilities.getAppConfiguration(this);
  mLastDeviceOrientation=appConfiguration.orientation;
  mLastDisplayDensity=appConfiguration.densityDpi;
  mFocusTimerDuration=getResources().getInteger(R.integer.recents_auto_advance_duration);
  mIterateTrigger=new DozeTrigger(mFocusTimerDuration,new Runnable(){
    @Override public void run(){
      dismissRecentsToFocusedTask(MetricsEvent.OVERVIEW_SELECT_TIMEOUT);
    }
  }
);
  getWindow().setBackgroundDrawable(mRecentsView.getBackgroundScrim());
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_TIME_CHANGED);
  registerReceiver(mSystemBroadcastReceiver,filter);
  getWindow().addPrivateFlags(LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION);
  reloadStackView();
}",0.9872408293460924
191005,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    dismissRecentsToHomeIfVisible(false);
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    dismissRecentsToHomeIfVisible(false);
  }
 else   if (action.equals(Intent.ACTION_TIME_CHANGED)) {
    Prefs.putLong(RecentsActivity.this,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  }
}",0.7219152854511971
191006,"/** 
 * Returns a list of the recents tasks.
 * @param includeFrontMostExcludedTask if set, will ensure that the front most excluded taskwill be visible, otherwise no excluded tasks will be visible.
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean includeFrontMostExcludedTask,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=SystemClock.elapsedRealtime();
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  int flags=ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES;
  if (includeFrontMostExcludedTask) {
    flags|=ActivityManager.RECENT_WITH_EXCLUDED;
  }
  List<ActivityManager.RecentTaskInfo> tasks=null;
  try {
    tasks=mAm.getRecentTasksForUser(numTasksToQuery,flags,userId);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    if (sRecentsBlacklist.contains(t.realActivity.getClassName()) || sRecentsBlacklist.contains(t.realActivity.getPackageName())) {
      iter.remove();
      continue;
    }
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isExcluded && (!isFirstValidTask || !includeFrontMostExcludedTask)) {
      iter.remove();
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}","/** 
 * Returns a list of the recents tasks.
 * @param includeFrontMostExcludedTask if set, will ensure that the front most excluded taskwill be visible, otherwise no excluded tasks will be visible.
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean includeFrontMostExcludedTask,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=i;
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  int flags=ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES;
  if (includeFrontMostExcludedTask) {
    flags|=ActivityManager.RECENT_WITH_EXCLUDED;
  }
  List<ActivityManager.RecentTaskInfo> tasks=null;
  try {
    tasks=mAm.getRecentTasksForUser(numTasksToQuery,flags,userId);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    if (sRecentsBlacklist.contains(t.realActivity.getClassName()) || sRecentsBlacklist.contains(t.realActivity.getPackageName())) {
      iter.remove();
      continue;
    }
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isExcluded && (!isFirstValidTask || !includeFrontMostExcludedTask)) {
      iter.remove();
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}",0.9951519069166128
191007,"/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean includeFrontMostExcludedTask){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(includeFrontMostExcludedTask);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  boolean updatedLastVisibleTaskActiveTime=false;
  long newLastVisibileTaskActiveTime=0;
  long currentTime=mTimeProvider.getTime();
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=mSystemServicesProxy.isFreeformStack(t.stackId);
    boolean isRecentlyUsedTask=t.lastActiveTime >= (currentTime - SESSION_BEGIN_TIME);
    boolean isMoreRecentThanLastVisible=t.lastActiveTime >= mLastVisibileTaskActiveTime;
    boolean isStackTask=isFreeformTask || (isMoreRecentThanLastVisible && (isRecentlyUsedTask || i >= (taskCount - MIN_NUM_TASKS)));
    boolean isLaunchTarget=t.persistentId == runningTaskId;
    if (isStackTask && !updatedLastVisibleTaskActiveTime) {
      newLastVisibileTaskActiveTime=t.lastActiveTime;
      updatedLastVisibleTaskActiveTime=true;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (updatedLastVisibleTaskActiveTime && newLastVisibileTaskActiveTime != mLastVisibileTaskActiveTime) {
    Settings.Secure.putLongForUser(mContext.getContentResolver(),Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,newLastVisibileTaskActiveTime,UserHandle.USER_CURRENT);
    mLastVisibileTaskActiveTime=newLastVisibileTaskActiveTime;
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}","/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean includeFrontMostExcludedTask){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(includeFrontMostExcludedTask);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  long lastStackActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    lastStackActiveTime=0;
  }
  long newLastStackActiveTime=-1;
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=SystemServicesProxy.isFreeformStack(t.stackId);
    boolean isStackTask=isFreeformTask || !isHistoricalTask(t) || (t.lastActiveTime >= lastStackActiveTime && i >= (taskCount - MIN_NUM_TASKS));
    boolean isLaunchTarget=taskKey.id == runningTaskId;
    if (isStackTask && newLastStackActiveTime < 0) {
      newLastStackActiveTime=t.lastActiveTime;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (newLastStackActiveTime != -1) {
    Prefs.putLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,newLastStackActiveTime);
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}",0.3211300086480254
191008,"/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean includeFrontMostExcludedTask){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  mRawTasks=mSystemServicesProxy.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,includeFrontMostExcludedTask,mCurrentQuietProfiles);
  mLastVisibileTaskActiveTime=RecentsDebugFlags.Static.EnableMockTasks ? SystemClock.elapsedRealtime() : Settings.Secure.getLongForUser(mContext.getContentResolver(),Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,0,currentUserId);
  Collections.reverse(mRawTasks);
}","/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean includeFrontMostExcludedTask){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  SystemServicesProxy ssp=Recents.getSystemServices();
  mRawTasks=ssp.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,includeFrontMostExcludedTask,mCurrentQuietProfiles);
  Collections.reverse(mRawTasks);
}",0.7216494845360825
191009,"@VisibleForTesting public RecentsTaskLoadPlan(Context context,SystemServicesProxy ssp){
  mContext=context;
  mSystemServicesProxy=ssp;
}","/** 
 * Package level ctor 
 */
RecentsTaskLoadPlan(Context context){
  mContext=context;
}",0.5701754385964912
191010,"public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(mPackages);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  mPackageDexOptimizer=new PackageDexOptimizer(installer,mInstallLock,context,""String_Node_Str"");
  mMoveCallbacks=new MoveCallbacks(FgThread.get().getLooper());
  mOnPermissionChangeListeners=new OnPermissionChangeListeners(FgThread.get().getLooper());
  getDefaultDisplayMetrics(context,mMetrics);
  SystemConfig systemConfig=SystemConfig.getInstance();
  mGlobalGids=systemConfig.getGlobalGids();
  mSystemPermissions=systemConfig.getSystemPermissions();
  mAvailableFeatures=systemConfig.getAvailableFeatures();
  mProtectedPackages=new ProtectedPackages(mContext);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread=new ServiceThread(TAG,Process.THREAD_PRIORITY_BACKGROUND,true);
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      mProcessLoggingHandler=new ProcessLoggingHandler();
      Watchdog.getInstance().addThread(mHandler,WATCHDOG_TIMEOUT);
      mDefaultPermissionPolicy=new DefaultPermissionGrantPolicy(this);
      File dataDir=Environment.getDataDirectory();
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLib32InstallDir=new File(dataDir,""String_Node_Str"");
      mEphemeralInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mPackages);
      ArrayMap<String,SystemConfig.PermissionEntry> permConfig=systemConfig.getPermissions();
      for (int i=0; i < permConfig.size(); i++) {
        SystemConfig.PermissionEntry perm=permConfig.valueAt(i);
        BasePermission bp=mSettings.mPermissions.get(perm.name);
        if (bp == null) {
          bp=new BasePermission(perm.name,""String_Node_Str"",BasePermission.TYPE_BUILTIN);
          mSettings.mPermissions.put(perm.name,bp);
        }
        if (perm.gids != null) {
          bp.setGids(perm.gids,perm.perUser);
        }
      }
      ArrayMap<String,String> libConfig=systemConfig.getSharedLibraries();
      for (int i=0; i < libConfig.size(); i++) {
        mSharedLibraries.put(libConfig.keyAt(i),new SharedLibraryEntry(libConfig.valueAt(i),null));
      }
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mFirstBoot=!mSettings.readLPw(sUserManager.getUsers(false));
      if (mFirstBoot) {
        requestCopyPreoptedFiles();
      }
      String customResolverActivity=Resources.getSystem().getString(R.string.config_customResolverActivity);
      if (TextUtils.isEmpty(customResolverActivity)) {
        customResolverActivity=null;
      }
 else {
        mCustomResolverComponentName=ComponentName.unflattenFromString(customResolverActivity);
      }
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      final int scanFlags=SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING| SCAN_INITIAL;
      final String bootClassPath=System.getenv(""String_Node_Str"");
      final String systemServerClassPath=System.getenv(""String_Node_Str"");
      if (bootClassPath == null) {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (systemServerClassPath == null) {
        Slog.w(TAG,""String_Node_Str"");
      }
      final List<String> allInstructionSets=InstructionSets.getAllInstructionSets();
      final String[] dexCodeInstructionSets=getDexCodeInstructionSets(allInstructionSets.toArray(new String[allInstructionSets.size()]));
      if (mSharedLibraries.size() > 0) {
        for (        String dexCodeInstructionSet : dexCodeInstructionSets) {
          for (          SharedLibraryEntry libEntry : mSharedLibraries.values()) {
            final String lib=libEntry.path;
            if (lib == null) {
              continue;
            }
            try {
              int dexoptNeeded=DexFile.getDexOptNeeded(lib,dexCodeInstructionSet,getCompilerFilterForReason(REASON_SHARED_APK),false);
              if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                mInstaller.dexopt(lib,Process.SYSTEM_UID,dexCodeInstructionSet,dexoptNeeded,DEXOPT_PUBLIC,getCompilerFilterForReason(REASON_SHARED_APK),StorageManager.UUID_PRIVATE_INTERNAL,SKIP_SHARED_LIBRARY_CHECK);
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException|InstallerException e) {
              Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
            }
          }
        }
      }
      File frameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      final VersionInfo ver=mSettings.getInternalVersion();
      mIsUpgrade=!Build.FINGERPRINT.equals(ver.fingerprint);
      mPromoteSystemApps=mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;
      mIsPreNUpgrade=mIsUpgrade && ver.sdkVersion < Build.VERSION_CODES.N;
      mIsPreNMR1Upgrade=mIsUpgrade && ver.sdkVersion < Build.VERSION_CODES.N_MR1;
      if (mPromoteSystemApps) {
        Iterator<PackageSetting> pkgSettingIter=mSettings.mPackages.values().iterator();
        while (pkgSettingIter.hasNext()) {
          PackageSetting ps=pkgSettingIter.next();
          if (isSystemApp(ps)) {
            mExistingSystemPackages.add(ps.name);
          }
        }
      }
      File vendorOverlayDir=new File(VENDOR_OVERLAY_DIR);
      scanDirTracedLI(vendorOverlayDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR| PackageParser.PARSE_TRUSTED_OVERLAY,scanFlags | SCAN_TRUSTED_OVERLAY,0);
      scanDirTracedLI(frameworkDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR| PackageParser.PARSE_IS_PRIVILEGED,scanFlags | SCAN_NO_DEX,0);
      final File privilegedAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      scanDirTracedLI(privilegedAppDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR| PackageParser.PARSE_IS_PRIVILEGED,scanFlags,0);
      final File systemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      scanDirTracedLI(systemAppDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags,0);
      File vendorAppDir=new File(""String_Node_Str"");
      try {
        vendorAppDir=vendorAppDir.getCanonicalFile();
      }
 catch (      IOException e) {
      }
      scanDirTracedLI(vendorAppDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags,0);
      final File oemAppDir=new File(Environment.getOemDirectory(),""String_Node_Str"");
      scanDirTracedLI(oemAppDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags,0);
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              logCriticalInfo(Log.WARN,""String_Node_Str"" + ps.name + ""String_Node_Str""+ ps.codePathString+ ""String_Node_Str""+ ps.installStatus+ ""String_Node_Str""+ ps.versionCode+ ""String_Node_Str""+ scannedPkg.mVersionCode);
              removePackageLI(scannedPkg,true);
              mExpectingBetter.put(ps.name,ps.codePath);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            logCriticalInfo(Log.WARN,""String_Node_Str"" + ps.name + ""String_Node_Str"");
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        final String packageName=deletePkgsList.get(i).name;
        logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName);
synchronized (mPackages) {
          mSettings.removePackageLPw(packageName);
        }
      }
      deleteTempPackageFiles();
      mSettings.pruneSharedUsersLPw();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        scanDirTracedLI(mAppInstallDir,0,scanFlags | SCAN_REQUIRE_KNOWN,0);
        scanDirTracedLI(mDrmAppPrivateInstallDir,mDefParseFlags | PackageParser.PARSE_FORWARD_LOCK,scanFlags | SCAN_REQUIRE_KNOWN,0);
        scanDirLI(mEphemeralInstallDir,mDefParseFlags | PackageParser.PARSE_IS_EPHEMERAL,scanFlags | SCAN_REQUIRE_KNOWN,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          logCriticalInfo(Log.WARN,msg);
        }
        for (int i=0; i < mExpectingBetter.size(); i++) {
          final String packageName=mExpectingBetter.keyAt(i);
          if (!mPackages.containsKey(packageName)) {
            final File scanFile=mExpectingBetter.valueAt(i);
            logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str"");
            int reparseFlags=mDefParseFlags;
            if (FileUtils.contains(privilegedAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED;
            }
 else             if (FileUtils.contains(systemAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
            }
 else             if (FileUtils.contains(vendorAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
            }
 else             if (FileUtils.contains(oemAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
            }
 else {
              Slog.e(TAG,""String_Node_Str"" + scanFile);
              continue;
            }
            mSettings.enableSystemPackageLPw(packageName);
            try {
              scanPackageTracedLI(scanFile,reparseFlags,scanFlags,0,null);
            }
 catch (            PackageManagerException e) {
              Slog.e(TAG,""String_Node_Str"" + e.getMessage());
            }
          }
        }
      }
      mExpectingBetter.clear();
      mSetupWizardPackage=getSetupWizardPackageName();
      if (mProtectedFilters.size() > 0) {
        if (DEBUG_FILTERS && mSetupWizardPackage == null) {
          Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
        }
        for (        ActivityIntentInfo filter : mProtectedFilters) {
          if (filter.activity.info.packageName.equals(mSetupWizardPackage)) {
            if (DEBUG_FILTERS) {
              Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + filter.getPriority() + ""String_Node_Str""+ ""String_Node_Str""+ filter.activity.info.packageName+ ""String_Node_Str""+ filter.activity.className+ ""String_Node_Str""+ filter.getPriority());
            }
            continue;
          }
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + filter.activity.info.packageName + ""String_Node_Str""+ filter.activity.className+ ""String_Node_Str""+ filter.getPriority());
          filter.setPriority(0);
        }
      }
      mDeferProtectedFilters=false;
      mProtectedFilters.clear();
      updateAllSharedLibrariesLPw();
      for (      SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {
        adjustCpuAbisForSharedUserLPw(setting.packages,null,false);
      }
      mPackageUsage.read(mPackages);
      mCompilerStats.read();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      int updateFlags=UPDATE_PERMISSIONS_ALL;
      if (ver.sdkVersion != mSdkVersion) {
        Slog.i(TAG,""String_Node_Str"" + ver.sdkVersion + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
        updateFlags|=UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;
      }
      updatePermissionsLPw(null,null,StorageManager.UUID_PRIVATE_INTERNAL,updateFlags);
      ver.sdkVersion=mSdkVersion;
      if (!onlyCore && (mPromoteSystemApps || mFirstBoot)) {
        for (        UserInfo user : sUserManager.getUsers(true)) {
          mSettings.applyDefaultPreferredAppsLPw(this,user.id);
          applyFactoryDefaultBrowserLPw(user.id);
          primeDomainVerificationsLPw(user.id);
        }
      }
      final int storageFlags;
      if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        storageFlags=StorageManager.FLAG_STORAGE_DE;
      }
 else {
        storageFlags=StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;
      }
      reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL,UserHandle.USER_SYSTEM,storageFlags);
      if (mIsUpgrade && !onlyCore) {
        Slog.i(TAG,""String_Node_Str"");
        for (int i=0; i < mSettings.mPackages.size(); i++) {
          final PackageSetting ps=mSettings.mPackages.valueAt(i);
          if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,ps.volumeUuid)) {
            clearAppDataLIF(ps.pkg,UserHandle.USER_ALL,StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
          }
        }
        ver.fingerprint=Build.FINGERPRINT;
      }
      checkDefaultBrowser();
      mExistingSystemPackages.clear();
      mPromoteSystemApps=false;
      ver.databaseVersion=Settings.CURRENT_DATABASE_VERSION;
      mSettings.writeLPr();
      if ((isFirstBoot() || isUpgrade() || VMRuntime.didPruneDalvikCache()) && !onlyCore) {
        long start=System.nanoTime();
        List<PackageParser.Package> coreApps=new ArrayList<>();
        for (        PackageParser.Package pkg : mPackages.values()) {
          if (pkg.coreApp) {
            coreApps.add(pkg);
          }
        }
        int[] stats=performDexOptUpgrade(coreApps,false,getCompilerFilterForReason(REASON_CORE_APP));
        final int elapsedTimeSeconds=(int)TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start);
        MetricsLogger.histogram(mContext,""String_Node_Str"",elapsedTimeSeconds);
        if (DEBUG_DEXOPT) {
          Slog.i(TAG,""String_Node_Str"" + elapsedTimeSeconds + ""String_Node_Str""+ stats[0]+ ""String_Node_Str""+ stats[1]+ ""String_Node_Str""+ stats[2]+ ""String_Node_Str"");
        }
      }
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      if (!mOnlyCore) {
        mRequiredVerifierPackage=getRequiredButNotReallyRequiredVerifierLPr();
        mRequiredInstallerPackage=getRequiredInstallerLPr();
        mRequiredUninstallerPackage=getRequiredUninstallerLPr();
        mIntentFilterVerifierComponent=getIntentFilterVerifierComponentNameLPr();
        mIntentFilterVerifier=new IntentVerifierProxy(mContext,mIntentFilterVerifierComponent);
        mServicesSystemSharedLibraryPackageName=getRequiredSharedLibraryLPr(PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES);
        mSharedSystemSharedLibraryPackageName=getRequiredSharedLibraryLPr(PackageManager.SYSTEM_SHARED_LIBRARY_SHARED);
      }
 else {
        mRequiredVerifierPackage=null;
        mRequiredInstallerPackage=null;
        mRequiredUninstallerPackage=null;
        mIntentFilterVerifierComponent=null;
        mIntentFilterVerifier=null;
        mServicesSystemSharedLibraryPackageName=null;
        mSharedSystemSharedLibraryPackageName=null;
      }
      mInstallerService=new PackageInstallerService(context,this);
      final ComponentName ephemeralResolverComponent=getEphemeralResolverLPr();
      final ComponentName ephemeralInstallerComponent=getEphemeralInstallerLPr();
      if (ephemeralInstallerComponent != null && ephemeralResolverComponent != null) {
        if (DEBUG_EPHEMERAL) {
          Slog.i(TAG,""String_Node_Str"" + ephemeralResolverComponent + ""String_Node_Str""+ ephemeralInstallerComponent);
        }
        mEphemeralResolverComponent=ephemeralResolverComponent;
        mEphemeralInstallerComponent=ephemeralInstallerComponent;
        setUpEphemeralInstallerActivityLP(mEphemeralInstallerComponent);
        mEphemeralResolverConnection=new EphemeralResolverConnection(mContext,mEphemeralResolverComponent);
      }
 else {
        if (DEBUG_EPHEMERAL) {
          final String missingComponent=(ephemeralResolverComponent == null) ? (ephemeralInstallerComponent == null) ? ""String_Node_Str"" : ""String_Node_Str"" : ""String_Node_Str"";
          Slog.i(TAG,""String_Node_Str"" + missingComponent);
        }
        mEphemeralResolverComponent=null;
        mEphemeralInstallerComponent=null;
        mEphemeralResolverConnection=null;
      }
      mEphemeralApplicationRegistry=new EphemeralApplicationRegistry(this);
    }
  }
  Runtime.getRuntime().gc();
  mInstaller.setWarnIfHeld(mPackages);
  LocalServices.addService(PackageManagerInternal.class,new PackageManagerInternalImpl());
}","public PackageManagerService(Context context,Installer installer,boolean factoryTest,boolean onlyCore){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(mPackages);
  mSettings.addSharedUserLPw(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",RADIO_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",LOG_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",NFC_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw(""String_Node_Str"",SHELL_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  mPackageDexOptimizer=new PackageDexOptimizer(installer,mInstallLock,context,""String_Node_Str"");
  mMoveCallbacks=new MoveCallbacks(FgThread.get().getLooper());
  mOnPermissionChangeListeners=new OnPermissionChangeListeners(FgThread.get().getLooper());
  getDefaultDisplayMetrics(context,mMetrics);
  SystemConfig systemConfig=SystemConfig.getInstance();
  mGlobalGids=systemConfig.getGlobalGids();
  mSystemPermissions=systemConfig.getSystemPermissions();
  mAvailableFeatures=systemConfig.getAvailableFeatures();
  mProtectedPackages=new ProtectedPackages(mContext);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread=new ServiceThread(TAG,Process.THREAD_PRIORITY_BACKGROUND,true);
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      mProcessLoggingHandler=new ProcessLoggingHandler();
      Watchdog.getInstance().addThread(mHandler,WATCHDOG_TIMEOUT);
      mDefaultPermissionPolicy=new DefaultPermissionGrantPolicy(this);
      File dataDir=Environment.getDataDirectory();
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      mAppLib32InstallDir=new File(dataDir,""String_Node_Str"");
      mEphemeralInstallDir=new File(dataDir,""String_Node_Str"");
      mAsecInternalPath=new File(dataDir,""String_Node_Str"").getPath();
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      sUserManager=new UserManagerService(context,this,mPackages);
      ArrayMap<String,SystemConfig.PermissionEntry> permConfig=systemConfig.getPermissions();
      for (int i=0; i < permConfig.size(); i++) {
        SystemConfig.PermissionEntry perm=permConfig.valueAt(i);
        BasePermission bp=mSettings.mPermissions.get(perm.name);
        if (bp == null) {
          bp=new BasePermission(perm.name,""String_Node_Str"",BasePermission.TYPE_BUILTIN);
          mSettings.mPermissions.put(perm.name,bp);
        }
        if (perm.gids != null) {
          bp.setGids(perm.gids,perm.perUser);
        }
      }
      ArrayMap<String,String> libConfig=systemConfig.getSharedLibraries();
      for (int i=0; i < libConfig.size(); i++) {
        mSharedLibraries.put(libConfig.keyAt(i),new SharedLibraryEntry(libConfig.valueAt(i),null));
      }
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mFirstBoot=!mSettings.readLPw(sUserManager.getUsers(false));
      if (mFirstBoot) {
        requestCopyPreoptedFiles();
      }
      String customResolverActivity=Resources.getSystem().getString(R.string.config_customResolverActivity);
      if (TextUtils.isEmpty(customResolverActivity)) {
        customResolverActivity=null;
      }
 else {
        mCustomResolverComponentName=ComponentName.unflattenFromString(customResolverActivity);
      }
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      final int scanFlags=SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING| SCAN_INITIAL;
      final String bootClassPath=System.getenv(""String_Node_Str"");
      final String systemServerClassPath=System.getenv(""String_Node_Str"");
      if (bootClassPath == null) {
        Slog.w(TAG,""String_Node_Str"");
      }
      if (systemServerClassPath == null) {
        Slog.w(TAG,""String_Node_Str"");
      }
      final List<String> allInstructionSets=InstructionSets.getAllInstructionSets();
      final String[] dexCodeInstructionSets=getDexCodeInstructionSets(allInstructionSets.toArray(new String[allInstructionSets.size()]));
      if (mSharedLibraries.size() > 0) {
        for (        String dexCodeInstructionSet : dexCodeInstructionSets) {
          for (          SharedLibraryEntry libEntry : mSharedLibraries.values()) {
            final String lib=libEntry.path;
            if (lib == null) {
              continue;
            }
            try {
              int dexoptNeeded=DexFile.getDexOptNeeded(lib,dexCodeInstructionSet,getCompilerFilterForReason(REASON_SHARED_APK),false);
              if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                mInstaller.dexopt(lib,Process.SYSTEM_UID,dexCodeInstructionSet,dexoptNeeded,DEXOPT_PUBLIC,getCompilerFilterForReason(REASON_SHARED_APK),StorageManager.UUID_PRIVATE_INTERNAL,SKIP_SHARED_LIBRARY_CHECK);
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException|InstallerException e) {
              Slog.w(TAG,""String_Node_Str"" + lib + ""String_Node_Str""+ e.getMessage());
            }
          }
        }
      }
      File frameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      final VersionInfo ver=mSettings.getInternalVersion();
      mIsUpgrade=!Build.FINGERPRINT.equals(ver.fingerprint);
      mPromoteSystemApps=mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;
      mIsPreNUpgrade=mIsUpgrade && ver.sdkVersion < Build.VERSION_CODES.N;
      mIsPreNMR1Upgrade=mIsUpgrade && ver.sdkVersion < Build.VERSION_CODES.N_MR1;
      if (mPromoteSystemApps) {
        Iterator<PackageSetting> pkgSettingIter=mSettings.mPackages.values().iterator();
        while (pkgSettingIter.hasNext()) {
          PackageSetting ps=pkgSettingIter.next();
          if (isSystemApp(ps)) {
            mExistingSystemPackages.add(ps.name);
          }
        }
      }
      File vendorOverlayDir=new File(VENDOR_OVERLAY_DIR);
      scanDirTracedLI(vendorOverlayDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR| PackageParser.PARSE_TRUSTED_OVERLAY,scanFlags | SCAN_TRUSTED_OVERLAY,0);
      scanDirTracedLI(frameworkDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR| PackageParser.PARSE_IS_PRIVILEGED,scanFlags | SCAN_NO_DEX,0);
      final File privilegedAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      scanDirTracedLI(privilegedAppDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR| PackageParser.PARSE_IS_PRIVILEGED,scanFlags,0);
      final File systemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      scanDirTracedLI(systemAppDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags,0);
      File vendorAppDir=new File(""String_Node_Str"");
      try {
        vendorAppDir=vendorAppDir.getCanonicalFile();
      }
 catch (      IOException e) {
      }
      scanDirTracedLI(vendorAppDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags,0);
      final File oemAppDir=new File(Environment.getOemDirectory(),""String_Node_Str"");
      scanDirTracedLI(oemAppDir,mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags,0);
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              logCriticalInfo(Log.WARN,""String_Node_Str"" + ps.name + ""String_Node_Str""+ ps.codePathString+ ""String_Node_Str""+ ps.installStatus+ ""String_Node_Str""+ ps.versionCode+ ""String_Node_Str""+ scannedPkg.mVersionCode);
              removePackageLI(scannedPkg,true);
              mExpectingBetter.put(ps.name,ps.codePath);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            logCriticalInfo(Log.WARN,""String_Node_Str"" + ps.name + ""String_Node_Str"");
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        final String packageName=deletePkgsList.get(i).name;
        logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName);
synchronized (mPackages) {
          mSettings.removePackageLPw(packageName);
        }
      }
      deleteTempPackageFiles();
      mSettings.pruneSharedUsersLPw();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        scanDirTracedLI(mAppInstallDir,0,scanFlags | SCAN_REQUIRE_KNOWN,0);
        scanDirTracedLI(mDrmAppPrivateInstallDir,mDefParseFlags | PackageParser.PARSE_FORWARD_LOCK,scanFlags | SCAN_REQUIRE_KNOWN,0);
        scanDirLI(mEphemeralInstallDir,mDefParseFlags | PackageParser.PARSE_IS_EPHEMERAL,scanFlags | SCAN_REQUIRE_KNOWN,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str"";
          }
 else {
            msg=""String_Node_Str"" + deletedAppName + ""String_Node_Str""+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          logCriticalInfo(Log.WARN,msg);
        }
        for (int i=0; i < mExpectingBetter.size(); i++) {
          final String packageName=mExpectingBetter.keyAt(i);
          if (!mPackages.containsKey(packageName)) {
            final File scanFile=mExpectingBetter.valueAt(i);
            logCriticalInfo(Log.WARN,""String_Node_Str"" + packageName + ""String_Node_Str"");
            int reparseFlags=mDefParseFlags;
            if (FileUtils.contains(privilegedAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED;
            }
 else             if (FileUtils.contains(systemAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
            }
 else             if (FileUtils.contains(vendorAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
            }
 else             if (FileUtils.contains(oemAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
            }
 else {
              Slog.e(TAG,""String_Node_Str"" + scanFile);
              continue;
            }
            mSettings.enableSystemPackageLPw(packageName);
            try {
              scanPackageTracedLI(scanFile,reparseFlags,scanFlags,0,null);
            }
 catch (            PackageManagerException e) {
              Slog.e(TAG,""String_Node_Str"" + e.getMessage());
            }
          }
        }
      }
      mExpectingBetter.clear();
      mStorageManagerPackage=getStorageManagerPackageName();
      mSetupWizardPackage=getSetupWizardPackageName();
      if (mProtectedFilters.size() > 0) {
        if (DEBUG_FILTERS && mSetupWizardPackage == null) {
          Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
        }
        for (        ActivityIntentInfo filter : mProtectedFilters) {
          if (filter.activity.info.packageName.equals(mSetupWizardPackage)) {
            if (DEBUG_FILTERS) {
              Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + filter.getPriority() + ""String_Node_Str""+ ""String_Node_Str""+ filter.activity.info.packageName+ ""String_Node_Str""+ filter.activity.className+ ""String_Node_Str""+ filter.getPriority());
            }
            continue;
          }
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + filter.activity.info.packageName + ""String_Node_Str""+ filter.activity.className+ ""String_Node_Str""+ filter.getPriority());
          filter.setPriority(0);
        }
      }
      mDeferProtectedFilters=false;
      mProtectedFilters.clear();
      updateAllSharedLibrariesLPw();
      for (      SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {
        adjustCpuAbisForSharedUserLPw(setting.packages,null,false);
      }
      mPackageUsage.read(mPackages);
      mCompilerStats.read();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      int updateFlags=UPDATE_PERMISSIONS_ALL;
      if (ver.sdkVersion != mSdkVersion) {
        Slog.i(TAG,""String_Node_Str"" + ver.sdkVersion + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
        updateFlags|=UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;
      }
      updatePermissionsLPw(null,null,StorageManager.UUID_PRIVATE_INTERNAL,updateFlags);
      ver.sdkVersion=mSdkVersion;
      if (!onlyCore && (mPromoteSystemApps || mFirstBoot)) {
        for (        UserInfo user : sUserManager.getUsers(true)) {
          mSettings.applyDefaultPreferredAppsLPw(this,user.id);
          applyFactoryDefaultBrowserLPw(user.id);
          primeDomainVerificationsLPw(user.id);
        }
      }
      final int storageFlags;
      if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        storageFlags=StorageManager.FLAG_STORAGE_DE;
      }
 else {
        storageFlags=StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;
      }
      reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL,UserHandle.USER_SYSTEM,storageFlags);
      if (mIsUpgrade && !onlyCore) {
        Slog.i(TAG,""String_Node_Str"");
        for (int i=0; i < mSettings.mPackages.size(); i++) {
          final PackageSetting ps=mSettings.mPackages.valueAt(i);
          if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,ps.volumeUuid)) {
            clearAppDataLIF(ps.pkg,UserHandle.USER_ALL,StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
          }
        }
        ver.fingerprint=Build.FINGERPRINT;
      }
      checkDefaultBrowser();
      mExistingSystemPackages.clear();
      mPromoteSystemApps=false;
      ver.databaseVersion=Settings.CURRENT_DATABASE_VERSION;
      mSettings.writeLPr();
      if ((isFirstBoot() || isUpgrade() || VMRuntime.didPruneDalvikCache()) && !onlyCore) {
        long start=System.nanoTime();
        List<PackageParser.Package> coreApps=new ArrayList<>();
        for (        PackageParser.Package pkg : mPackages.values()) {
          if (pkg.coreApp) {
            coreApps.add(pkg);
          }
        }
        int[] stats=performDexOptUpgrade(coreApps,false,getCompilerFilterForReason(REASON_CORE_APP));
        final int elapsedTimeSeconds=(int)TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start);
        MetricsLogger.histogram(mContext,""String_Node_Str"",elapsedTimeSeconds);
        if (DEBUG_DEXOPT) {
          Slog.i(TAG,""String_Node_Str"" + elapsedTimeSeconds + ""String_Node_Str""+ stats[0]+ ""String_Node_Str""+ stats[1]+ ""String_Node_Str""+ stats[2]+ ""String_Node_Str"");
        }
      }
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      if (!mOnlyCore) {
        mRequiredVerifierPackage=getRequiredButNotReallyRequiredVerifierLPr();
        mRequiredInstallerPackage=getRequiredInstallerLPr();
        mRequiredUninstallerPackage=getRequiredUninstallerLPr();
        mIntentFilterVerifierComponent=getIntentFilterVerifierComponentNameLPr();
        mIntentFilterVerifier=new IntentVerifierProxy(mContext,mIntentFilterVerifierComponent);
        mServicesSystemSharedLibraryPackageName=getRequiredSharedLibraryLPr(PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES);
        mSharedSystemSharedLibraryPackageName=getRequiredSharedLibraryLPr(PackageManager.SYSTEM_SHARED_LIBRARY_SHARED);
      }
 else {
        mRequiredVerifierPackage=null;
        mRequiredInstallerPackage=null;
        mRequiredUninstallerPackage=null;
        mIntentFilterVerifierComponent=null;
        mIntentFilterVerifier=null;
        mServicesSystemSharedLibraryPackageName=null;
        mSharedSystemSharedLibraryPackageName=null;
      }
      mInstallerService=new PackageInstallerService(context,this);
      final ComponentName ephemeralResolverComponent=getEphemeralResolverLPr();
      final ComponentName ephemeralInstallerComponent=getEphemeralInstallerLPr();
      if (ephemeralInstallerComponent != null && ephemeralResolverComponent != null) {
        if (DEBUG_EPHEMERAL) {
          Slog.i(TAG,""String_Node_Str"" + ephemeralResolverComponent + ""String_Node_Str""+ ephemeralInstallerComponent);
        }
        mEphemeralResolverComponent=ephemeralResolverComponent;
        mEphemeralInstallerComponent=ephemeralInstallerComponent;
        setUpEphemeralInstallerActivityLP(mEphemeralInstallerComponent);
        mEphemeralResolverConnection=new EphemeralResolverConnection(mContext,mEphemeralResolverComponent);
      }
 else {
        if (DEBUG_EPHEMERAL) {
          final String missingComponent=(ephemeralResolverComponent == null) ? (ephemeralInstallerComponent == null) ? ""String_Node_Str"" : ""String_Node_Str"" : ""String_Node_Str"";
          Slog.i(TAG,""String_Node_Str"" + missingComponent);
        }
        mEphemeralResolverComponent=null;
        mEphemeralInstallerComponent=null;
        mEphemeralResolverConnection=null;
      }
      mEphemeralApplicationRegistry=new EphemeralApplicationRegistry(this);
    }
  }
  Runtime.getRuntime().gc();
  mInstaller.setWarnIfHeld(mPackages);
  LocalServices.addService(PackageManagerInternal.class,new PackageManagerInternalImpl());
}",0.9984594792534788
191011,"private boolean isCallerAllowedToSilentlyUninstall(int callingUid,String pkgName){
  if (callingUid == Process.SHELL_UID || callingUid == Process.ROOT_UID || callingUid == Process.SYSTEM_UID) {
    return true;
  }
  final int callingUserId=UserHandle.getUserId(callingUid);
  if (callingUid == getPackageUid(getInstallerPackageName(pkgName),0,callingUserId)) {
    return true;
  }
  if (mRequiredVerifierPackage != null && callingUid == getPackageUid(mRequiredVerifierPackage,0,callingUserId)) {
    return true;
  }
  if (mRequiredUninstallerPackage != null && callingUid == getPackageUid(mRequiredUninstallerPackage,0,callingUserId)) {
    return true;
  }
  return false;
}","private boolean isCallerAllowedToSilentlyUninstall(int callingUid,String pkgName){
  if (callingUid == Process.SHELL_UID || callingUid == Process.ROOT_UID || callingUid == Process.SYSTEM_UID) {
    return true;
  }
  final int callingUserId=UserHandle.getUserId(callingUid);
  if (callingUid == getPackageUid(getInstallerPackageName(pkgName),0,callingUserId)) {
    return true;
  }
  if (mRequiredVerifierPackage != null && callingUid == getPackageUid(mRequiredVerifierPackage,0,callingUserId)) {
    return true;
  }
  if (mRequiredUninstallerPackage != null && callingUid == getPackageUid(mRequiredUninstallerPackage,0,callingUserId)) {
    return true;
  }
  if (mStorageManagerPackage != null && callingUid == getPackageUid(mStorageManagerPackage,0,callingUserId)) {
    return true;
  }
  return false;
}",0.8978494623655914
191012,"/** 
 * Confirm passkey for   {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.<p>Requires  {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * @return true confirmation has been sent outfalse for error
 */
public boolean setPairingConfirmation(boolean confirm){
  if (sService == null) {
    Log.e(TAG,""String_Node_Str"");
    return false;
  }
  try {
    return sService.setPairingConfirmation(this,confirm);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  return false;
}","/** 
 * Confirm passkey for   {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.<p>Requires  {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}.
 * @return true confirmation has been sent outfalse for error
 */
public boolean setPairingConfirmation(boolean confirm){
  if (sService == null) {
    Log.e(TAG,""String_Node_Str"");
    return false;
  }
  try {
    return sService.setPairingConfirmation(this,confirm);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  return false;
}",0.9873663751214772
191013,"/** 
 * Confirm passkey for   {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.<p>Requires  {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * @return true confirmation has been sent outfalse for error
 */
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN) public boolean setPairingConfirmation(boolean confirm){
  if (sService == null) {
    Log.e(TAG,""String_Node_Str"");
    return false;
  }
  try {
    return sService.setPairingConfirmation(this,confirm);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  return false;
}","/** 
 * Confirm passkey for   {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.<p>Requires  {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}.
 * @return true confirmation has been sent outfalse for error
 */
@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED) public boolean setPairingConfirmation(boolean confirm){
  if (sService == null) {
    Log.e(TAG,""String_Node_Str"");
    return false;
  }
  try {
    return sService.setPairingConfirmation(this,confirm);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  return false;
}",0.9773519163763066
191014,"/** 
 * Confirm passkey for   {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.<p>Requires  {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * @return true confirmation has been sent outfalse for error
 */
public boolean setPairingConfirmation(boolean confirm){
  if (sService == null) {
    Log.e(TAG,""String_Node_Str"");
    return false;
  }
  try {
    return sService.setPairingConfirmation(this,confirm);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  return false;
}","/** 
 * Confirm passkey for   {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.<p>Requires  {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}.
 * @return true confirmation has been sent outfalse for error
 */
public boolean setPairingConfirmation(boolean confirm){
  if (sService == null) {
    Log.e(TAG,""String_Node_Str"");
    return false;
  }
  try {
    return sService.setPairingConfirmation(this,confirm);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  return false;
}",0.9873663751214772
191015,"private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0;
  allowWhenLocked|=win.mAttachedWindow != null && (win.mAttachedWindow.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  allowWhenLocked|=(win.mAttrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mPolicy.canShowDismissingWindowWhileLockedLw();
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  boolean hideDockDivider=win.mAttrs.type == TYPE_DOCK_DIVIDER && win.getDisplayContent().getDockedStackLocked() == null;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY) || hideDockDivider;
}","private boolean shouldForceHide(WindowState win){
  final WindowState imeTarget=mService.mInputMethodTarget;
  final boolean showImeOverKeyguard=imeTarget != null && imeTarget.isVisibleNow() && ((imeTarget.getAttrs().flags & FLAG_SHOW_WHEN_LOCKED) != 0 || !mPolicy.canBeForceHidden(imeTarget,imeTarget.mAttrs));
  final WindowState winShowWhenLocked=getWinShowWhenLockedOrAnimating();
  final AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
  boolean allowWhenLocked=false;
  allowWhenLocked|=(win.mIsImWindow || imeTarget == win) && showImeOverKeyguard;
  allowWhenLocked|=(win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 && win.mTurnOnScreen;
  if (appShowWhenLocked != null) {
    allowWhenLocked|=appShowWhenLocked == win.mAppToken || (win.mAttrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0 || (win.mAttrs.privateFlags & PRIVATE_FLAG_SYSTEM_ERROR) != 0;
  }
  allowWhenLocked|=(win.mAttrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mPolicy.canShowDismissingWindowWhileLockedLw();
  boolean keyguardOn=mPolicy.isKeyguardShowingOrOccluded() && mForceHiding != KEYGUARD_ANIMATING_OUT;
  boolean hideDockDivider=win.mAttrs.type == TYPE_DOCK_DIVIDER && win.getDisplayContent().getDockedStackLocked() == null;
  return keyguardOn && !allowWhenLocked && (win.getDisplayId() == Display.DEFAULT_DISPLAY) || hideDockDivider;
}",0.8854354897000362
191016,"private void updateWindowsLocked(final int displayId){
  ++mAnimTransactionSequence;
  final WindowList windows=mService.getWindowListLocked(displayId);
  final boolean keyguardGoingAwayToShade=(mKeyguardGoingAwayFlags & KEYGUARD_GOING_AWAY_FLAG_TO_SHADE) != 0;
  final boolean keyguardGoingAwayNoAnimation=(mKeyguardGoingAwayFlags & KEYGUARD_GOING_AWAY_FLAG_NO_WINDOW_ANIMATIONS) != 0;
  final boolean keyguardGoingAwayWithWallpaper=(mKeyguardGoingAwayFlags & KEYGUARD_GOING_AWAY_FLAG_WITH_WALLPAPER) != 0;
  if (mKeyguardGoingAway) {
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState win=windows.get(i);
      if (!mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        continue;
      }
      final WindowStateAnimator winAnimator=win.mWinAnimator;
      if ((win.mAttrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        if (!winAnimator.mAnimating) {
          if (DEBUG_KEYGUARD)           Slog.d(TAG,""String_Node_Str"");
          winAnimator.mAnimation=new AlphaAnimation(1.0f,1.0f);
          winAnimator.mAnimation.setDuration(KEYGUARD_ANIM_TIMEOUT_MS);
          winAnimator.mAnimationIsEntrance=false;
          winAnimator.mAnimationStartTime=-1;
          winAnimator.mKeyguardGoingAwayAnimation=true;
          winAnimator.mKeyguardGoingAwayWithWallpaper=keyguardGoingAwayWithWallpaper;
        }
      }
 else {
        if (DEBUG_KEYGUARD)         Slog.d(TAG,""String_Node_Str"");
        mKeyguardGoingAway=false;
        winAnimator.clearAnimation();
      }
      break;
    }
  }
  mForceHiding=KEYGUARD_NOT_SHOWN;
  boolean wallpaperInUnForceHiding=false;
  boolean startingInUnForceHiding=false;
  ArrayList<WindowStateAnimator> unForceHiding=null;
  WindowState wallpaper=null;
  final WallpaperController wallpaperController=mService.mWallpaperControllerLocked;
  for (int i=windows.size() - 1; i >= 0; i--) {
    WindowState win=windows.get(i);
    WindowStateAnimator winAnimator=win.mWinAnimator;
    final int flags=win.mAttrs.flags;
    boolean canBeForceHidden=mPolicy.canBeForceHidden(win,win.mAttrs);
    boolean shouldBeForceHidden=shouldForceHide(win);
    if (winAnimator.hasSurface()) {
      final boolean wasAnimating=winAnimator.mWasAnimating;
      final boolean nowAnimating=winAnimator.stepAnimationLocked(mCurrentTime);
      winAnimator.mWasAnimating=nowAnimating;
      orAnimating(nowAnimating);
      if (DEBUG_WALLPAPER) {
        Slog.v(TAG,win + ""String_Node_Str"" + wasAnimating+ ""String_Node_Str""+ nowAnimating);
      }
      if (wasAnimating && !winAnimator.mAnimating && wallpaperController.isWallpaperTarget(win)) {
        mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
        setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
        if (DEBUG_LAYOUT_REPEATS) {
          mWindowPlacerLocked.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
        }
      }
      if (mPolicy.isForceHiding(win.mAttrs)) {
        if (!wasAnimating && nowAnimating) {
          if (DEBUG_KEYGUARD || DEBUG_ANIM || DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
          mBulkUpdateParams|=SET_FORCE_HIDING_CHANGED;
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (DEBUG_LAYOUT_REPEATS) {
            mWindowPlacerLocked.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
          mService.mFocusMayChange=true;
        }
 else         if (mKeyguardGoingAway && !nowAnimating) {
          Slog.e(TAG,""String_Node_Str"");
          mPolicy.startKeyguardExitAnimation(0,0);
          mKeyguardGoingAway=false;
        }
        if (win.isReadyForDisplay()) {
          if (nowAnimating && win.mWinAnimator.mKeyguardGoingAwayAnimation) {
            mForceHiding=KEYGUARD_ANIMATING_OUT;
          }
 else {
            mForceHiding=win.isDrawnLw() ? KEYGUARD_SHOWN : KEYGUARD_NOT_SHOWN;
          }
        }
        if (DEBUG_KEYGUARD || DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + forceHidingToString() + ""String_Node_Str""+ win.mHasSurface+ ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDestroying+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ win.mViewVisibility+ ""String_Node_Str""+ win.mRootToken.hidden+ ""String_Node_Str""+ win.mWinAnimator.mAnimation);
      }
 else       if (canBeForceHidden) {
        if (shouldBeForceHidden) {
          if (!win.hideLw(false,false)) {
            continue;
          }
          if (DEBUG_KEYGUARD || DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
        }
 else {
          boolean applyExistingExitAnimation=mPostKeyguardExitAnimation != null && !mPostKeyguardExitAnimation.hasEnded() && !winAnimator.mKeyguardGoingAwayAnimation && win.hasDrawnLw() && win.mAttachedWindow == null && !win.mIsImWindow && displayId == Display.DEFAULT_DISPLAY;
          if (!win.showLw(false,false) && !applyExistingExitAnimation) {
            continue;
          }
          final boolean visibleNow=win.isVisibleNow();
          if (!visibleNow) {
            win.hideLw(false,false);
            continue;
          }
          if (DEBUG_KEYGUARD || DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
          if ((mBulkUpdateParams & SET_FORCE_HIDING_CHANGED) != 0 && win.mAttachedWindow == null) {
            if (unForceHiding == null) {
              unForceHiding=new ArrayList<>();
            }
            unForceHiding.add(winAnimator);
            if ((flags & FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperInUnForceHiding=true;
            }
            if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
              startingInUnForceHiding=true;
            }
          }
 else           if (applyExistingExitAnimation) {
            if (DEBUG_KEYGUARD)             Slog.v(TAG,""String_Node_Str"" + win);
            Animation a=mPolicy.createForceHideEnterAnimation(false,keyguardGoingAwayToShade);
            winAnimator.setAnimation(a,mPostKeyguardExitAnimation.getStartTime(),STACK_CLIP_BEFORE_ANIM);
            winAnimator.mKeyguardGoingAwayAnimation=true;
            winAnimator.mKeyguardGoingAwayWithWallpaper=keyguardGoingAwayWithWallpaper;
          }
          final WindowState currentFocus=mService.mCurrentFocus;
          if (currentFocus == null || currentFocus.mLayer < win.mLayer) {
            if (DEBUG_FOCUS_LIGHT)             Slog.v(TAG,""String_Node_Str"");
            mService.mFocusMayChange=true;
          }
        }
        if ((flags & FLAG_SHOW_WALLPAPER) != 0) {
          mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
          setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (DEBUG_LAYOUT_REPEATS) {
            mWindowPlacerLocked.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
          }
        }
      }
    }
 else     if (canBeForceHidden) {
      if (shouldBeForceHidden) {
        win.hideLw(false,false);
      }
 else {
        win.showLw(false,false);
      }
    }
    final AppWindowToken atoken=win.mAppToken;
    if (winAnimator.mDrawState == READY_TO_SHOW) {
      if (atoken == null || atoken.allDrawn) {
        if (winAnimator.performShowLocked()) {
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
          if (DEBUG_LAYOUT_REPEATS) {
            mWindowPlacerLocked.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
        }
      }
    }
    final AppWindowAnimator appAnimator=winAnimator.mAppAnimator;
    if (appAnimator != null && appAnimator.thumbnail != null) {
      if (appAnimator.thumbnailTransactionSeq != mAnimTransactionSequence) {
        appAnimator.thumbnailTransactionSeq=mAnimTransactionSequence;
        appAnimator.thumbnailLayer=0;
      }
      if (appAnimator.thumbnailLayer < winAnimator.mAnimLayer) {
        appAnimator.thumbnailLayer=winAnimator.mAnimLayer;
      }
    }
    if (win.mIsWallpaper) {
      wallpaper=win;
    }
  }
  if (unForceHiding != null) {
    if (!keyguardGoingAwayNoAnimation) {
      boolean first=true;
      for (int i=unForceHiding.size() - 1; i >= 0; i--) {
        final WindowStateAnimator winAnimator=unForceHiding.get(i);
        Animation a=mPolicy.createForceHideEnterAnimation(wallpaperInUnForceHiding && !startingInUnForceHiding,keyguardGoingAwayToShade);
        if (a != null) {
          if (DEBUG_KEYGUARD)           Slog.v(TAG,""String_Node_Str"" + winAnimator.mWin);
          winAnimator.setAnimation(a,STACK_CLIP_BEFORE_ANIM);
          winAnimator.mKeyguardGoingAwayAnimation=true;
          winAnimator.mKeyguardGoingAwayWithWallpaper=keyguardGoingAwayWithWallpaper;
          if (first) {
            mPostKeyguardExitAnimation=a;
            mPostKeyguardExitAnimation.setStartTime(mCurrentTime);
            first=false;
          }
        }
      }
    }
 else     if (mKeyguardGoingAway) {
      mPolicy.startKeyguardExitAnimation(mCurrentTime,0);
      mKeyguardGoingAway=false;
    }
    if (!wallpaperInUnForceHiding && wallpaper != null && !keyguardGoingAwayNoAnimation) {
      if (DEBUG_KEYGUARD)       Slog.d(TAG,""String_Node_Str"");
      Animation a=mPolicy.createForceHideWallpaperExitAnimation(keyguardGoingAwayToShade);
      if (a != null) {
        wallpaper.mWinAnimator.setAnimation(a);
      }
    }
  }
  if (mPostKeyguardExitAnimation != null) {
    if (mKeyguardGoingAway) {
      mPolicy.startKeyguardExitAnimation(mCurrentTime + mPostKeyguardExitAnimation.getStartOffset(),mPostKeyguardExitAnimation.getDuration());
      mKeyguardGoingAway=false;
    }
 else     if (mPostKeyguardExitAnimation.hasEnded() || mCurrentTime - mPostKeyguardExitAnimation.getStartTime() > mPostKeyguardExitAnimation.getDuration()) {
      if (DEBUG_KEYGUARD)       Slog.v(TAG,""String_Node_Str"");
      mPostKeyguardExitAnimation=null;
    }
  }
}","private void updateWindowsLocked(final int displayId){
  ++mAnimTransactionSequence;
  final WindowList windows=mService.getWindowListLocked(displayId);
  final boolean keyguardGoingAwayToShade=(mKeyguardGoingAwayFlags & KEYGUARD_GOING_AWAY_FLAG_TO_SHADE) != 0;
  final boolean keyguardGoingAwayNoAnimation=(mKeyguardGoingAwayFlags & KEYGUARD_GOING_AWAY_FLAG_NO_WINDOW_ANIMATIONS) != 0;
  final boolean keyguardGoingAwayWithWallpaper=(mKeyguardGoingAwayFlags & KEYGUARD_GOING_AWAY_FLAG_WITH_WALLPAPER) != 0;
  if (mKeyguardGoingAway) {
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState win=windows.get(i);
      if (!mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        continue;
      }
      final WindowStateAnimator winAnimator=win.mWinAnimator;
      if ((win.mAttrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        if (!winAnimator.mAnimating) {
          if (DEBUG_KEYGUARD)           Slog.d(TAG,""String_Node_Str"");
          winAnimator.mAnimation=new AlphaAnimation(1.0f,1.0f);
          winAnimator.mAnimation.setDuration(KEYGUARD_ANIM_TIMEOUT_MS);
          winAnimator.mAnimationIsEntrance=false;
          winAnimator.mAnimationStartTime=-1;
          winAnimator.mKeyguardGoingAwayAnimation=true;
          winAnimator.mKeyguardGoingAwayWithWallpaper=keyguardGoingAwayWithWallpaper;
        }
      }
 else {
        if (DEBUG_KEYGUARD)         Slog.d(TAG,""String_Node_Str"");
        mKeyguardGoingAway=false;
        winAnimator.clearAnimation();
      }
      break;
    }
  }
  mForceHiding=KEYGUARD_NOT_SHOWN;
  boolean wallpaperInUnForceHiding=false;
  boolean startingInUnForceHiding=false;
  ArrayList<WindowStateAnimator> unForceHiding=null;
  WindowState wallpaper=null;
  final WallpaperController wallpaperController=mService.mWallpaperControllerLocked;
  for (int i=windows.size() - 1; i >= 0; i--) {
    WindowState win=windows.get(i);
    WindowStateAnimator winAnimator=win.mWinAnimator;
    final int flags=win.mAttrs.flags;
    boolean canBeForceHidden=mPolicy.canBeForceHidden(win,win.mAttrs);
    boolean shouldBeForceHidden=shouldForceHide(win);
    if (winAnimator.hasSurface()) {
      final boolean wasAnimating=winAnimator.mWasAnimating;
      final boolean nowAnimating=winAnimator.stepAnimationLocked(mCurrentTime);
      winAnimator.mWasAnimating=nowAnimating;
      orAnimating(nowAnimating);
      if (DEBUG_WALLPAPER) {
        Slog.v(TAG,win + ""String_Node_Str"" + wasAnimating+ ""String_Node_Str""+ nowAnimating);
      }
      if (wasAnimating && !winAnimator.mAnimating && wallpaperController.isWallpaperTarget(win)) {
        mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
        setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
        if (DEBUG_LAYOUT_REPEATS) {
          mWindowPlacerLocked.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
        }
      }
      if (mPolicy.isForceHiding(win.mAttrs)) {
        if (!wasAnimating && nowAnimating) {
          if (DEBUG_KEYGUARD || DEBUG_ANIM || DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
          mBulkUpdateParams|=SET_FORCE_HIDING_CHANGED;
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (DEBUG_LAYOUT_REPEATS) {
            mWindowPlacerLocked.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
          mService.mFocusMayChange=true;
        }
 else         if (mKeyguardGoingAway && !nowAnimating) {
          Slog.e(TAG,""String_Node_Str"");
          mPolicy.startKeyguardExitAnimation(0,0);
          mKeyguardGoingAway=false;
        }
        if (win.isReadyForDisplay()) {
          if (nowAnimating && win.mWinAnimator.mKeyguardGoingAwayAnimation) {
            mForceHiding=KEYGUARD_ANIMATING_OUT;
          }
 else {
            mForceHiding=win.isDrawnLw() ? KEYGUARD_SHOWN : KEYGUARD_NOT_SHOWN;
          }
        }
        if (DEBUG_KEYGUARD || DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + forceHidingToString() + ""String_Node_Str""+ win.mHasSurface+ ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDestroying+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ win.mViewVisibility+ ""String_Node_Str""+ win.mRootToken.hidden+ ""String_Node_Str""+ win.mWinAnimator.mAnimation);
      }
 else       if (canBeForceHidden) {
        if (shouldBeForceHidden) {
          if (!win.hideLw(false,false)) {
            continue;
          }
          if (DEBUG_KEYGUARD || DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
        }
 else {
          boolean applyExistingExitAnimation=mPostKeyguardExitAnimation != null && !mPostKeyguardExitAnimation.hasEnded() && !winAnimator.mKeyguardGoingAwayAnimation && win.hasDrawnLw() && win.mAttachedWindow == null && !win.mIsImWindow && displayId == Display.DEFAULT_DISPLAY;
          if (!win.showLw(false,false) && !applyExistingExitAnimation) {
            continue;
          }
          final boolean visibleNow=win.isVisibleNow();
          if (!visibleNow) {
            win.hideLw(false,false);
            continue;
          }
          if (DEBUG_KEYGUARD || DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
          if ((mBulkUpdateParams & SET_FORCE_HIDING_CHANGED) != 0 && win.mAttachedWindow == null) {
            if (unForceHiding == null) {
              unForceHiding=new ArrayList<>();
            }
            unForceHiding.add(winAnimator);
            if ((flags & FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperInUnForceHiding=true;
            }
            if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
              startingInUnForceHiding=true;
            }
          }
 else           if (applyExistingExitAnimation) {
            if (DEBUG_KEYGUARD)             Slog.v(TAG,""String_Node_Str"" + win);
            Animation a=mPolicy.createForceHideEnterAnimation(false,keyguardGoingAwayToShade);
            winAnimator.setAnimation(a,mPostKeyguardExitAnimation.getStartTime(),STACK_CLIP_BEFORE_ANIM);
            winAnimator.mKeyguardGoingAwayAnimation=true;
            winAnimator.mKeyguardGoingAwayWithWallpaper=keyguardGoingAwayWithWallpaper;
          }
          final WindowState currentFocus=mService.mCurrentFocus;
          if (currentFocus == null || currentFocus.mLayer < win.mLayer) {
            if (DEBUG_FOCUS_LIGHT)             Slog.v(TAG,""String_Node_Str"");
            mService.mFocusMayChange=true;
          }
        }
        if ((flags & FLAG_SHOW_WALLPAPER) != 0) {
          mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
          setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (DEBUG_LAYOUT_REPEATS) {
            mWindowPlacerLocked.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
          }
        }
      }
    }
 else     if (canBeForceHidden) {
      if (shouldBeForceHidden) {
        win.hideLw(false,false);
      }
 else {
        win.showLw(false,false);
      }
    }
    final AppWindowToken atoken=win.mAppToken;
    if (winAnimator.mDrawState == READY_TO_SHOW) {
      if (atoken == null || atoken.allDrawn) {
        if (winAnimator.performShowLocked()) {
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
          if (DEBUG_LAYOUT_REPEATS) {
            mWindowPlacerLocked.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
        }
      }
    }
    final AppWindowAnimator appAnimator=winAnimator.mAppAnimator;
    if (appAnimator != null && appAnimator.thumbnail != null) {
      if (appAnimator.thumbnailTransactionSeq != mAnimTransactionSequence) {
        appAnimator.thumbnailTransactionSeq=mAnimTransactionSequence;
        appAnimator.thumbnailLayer=0;
      }
      if (appAnimator.thumbnailLayer < winAnimator.mAnimLayer) {
        appAnimator.thumbnailLayer=winAnimator.mAnimLayer;
      }
    }
    if (win.mIsWallpaper) {
      wallpaper=win;
    }
  }
  if (unForceHiding != null) {
    if (!keyguardGoingAwayNoAnimation) {
      boolean first=true;
      for (int i=unForceHiding.size() - 1; i >= 0; i--) {
        final WindowStateAnimator winAnimator=unForceHiding.get(i);
        Animation a=mPolicy.createForceHideEnterAnimation(wallpaperInUnForceHiding && !startingInUnForceHiding,keyguardGoingAwayToShade);
        if (a != null) {
          if (DEBUG_KEYGUARD)           Slog.v(TAG,""String_Node_Str"" + winAnimator.mWin);
          winAnimator.setAnimation(a,STACK_CLIP_BEFORE_ANIM);
          winAnimator.mKeyguardGoingAwayAnimation=true;
          winAnimator.mKeyguardGoingAwayWithWallpaper=keyguardGoingAwayWithWallpaper;
          if (first) {
            mPostKeyguardExitAnimation=a;
            mPostKeyguardExitAnimation.setStartTime(mCurrentTime);
            first=false;
          }
        }
      }
    }
 else     if (mKeyguardGoingAway) {
      mPolicy.startKeyguardExitAnimation(mCurrentTime,0);
      mKeyguardGoingAway=false;
    }
    if (!wallpaperInUnForceHiding && wallpaper != null && !keyguardGoingAwayNoAnimation) {
      if (DEBUG_KEYGUARD)       Slog.d(TAG,""String_Node_Str"");
      Animation a=mPolicy.createForceHideWallpaperExitAnimation(keyguardGoingAwayToShade);
      if (a != null) {
        wallpaper.mWinAnimator.setAnimation(a);
      }
    }
  }
  if (mPostKeyguardExitAnimation != null) {
    if (mKeyguardGoingAway) {
      mPolicy.startKeyguardExitAnimation(mCurrentTime + mPostKeyguardExitAnimation.getStartOffset(),mPostKeyguardExitAnimation.getDuration());
      mKeyguardGoingAway=false;
    }
 else     if (mPostKeyguardExitAnimation.hasEnded() || mCurrentTime - mPostKeyguardExitAnimation.getStartTime() > mPostKeyguardExitAnimation.getDuration()) {
      if (DEBUG_KEYGUARD)       Slog.v(TAG,""String_Node_Str"");
      mPostKeyguardExitAnimation=null;
    }
  }
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  if (winShowWhenLocked != null) {
    mLastShowWinWhenLocked=winShowWhenLocked;
  }
}",0.9915279577394598
191017,"@Override public void start(){
  sDebugFlags=new RecentsDebugFlags(mContext);
  sSystemServicesProxy=SystemServicesProxy.getInstance(mContext);
  sTaskLoader=new RecentsTaskLoader(mContext);
  sConfiguration=new RecentsConfiguration(mContext);
  UiModeManager uiModeManager=(UiModeManager)mContext.getSystemService(Context.UI_MODE_SERVICE);
  if (uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION) {
    mImpl=new RecentsTvImpl(mContext);
  }
 else {
    mImpl=new RecentsImpl(mContext);
  }
  if (""String_Node_Str"".equals(Build.TYPE) || ""String_Node_Str"".equals(Build.TYPE)) {
    String cnStr=SystemProperties.get(RECENTS_OVERRIDE_SYSPROP_KEY);
    if (!cnStr.isEmpty()) {
      mOverrideRecentsPackageName=cnStr;
    }
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sSystemServicesProxy,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sTaskLoader,EVENT_BUS_PRIORITY);
  final int processUser=sSystemServicesProxy.getProcessUser();
  if (sSystemServicesProxy.isSystemUser(processUser)) {
    mSystemToUserCallbacks=new RecentsSystemUser(mContext,mImpl);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    mContext.registerReceiverAsUser(mSystemUserUnlockedReceiver,UserHandle.SYSTEM,filter,null,null);
  }
 else {
    registerWithSystemUser();
  }
  putComponent(Recents.class,this);
}","@Override public void start(){
  sDebugFlags=new RecentsDebugFlags(mContext);
  sSystemServicesProxy=SystemServicesProxy.getInstance(mContext);
  sTaskLoader=new RecentsTaskLoader(mContext);
  sConfiguration=new RecentsConfiguration(mContext);
  UiModeManager uiModeManager=(UiModeManager)mContext.getSystemService(Context.UI_MODE_SERVICE);
  if (uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION) {
    mImpl=new RecentsTvImpl(mContext);
  }
 else {
    mImpl=new RecentsImpl(mContext);
  }
  if (""String_Node_Str"".equals(Build.TYPE) || ""String_Node_Str"".equals(Build.TYPE)) {
    String cnStr=SystemProperties.get(RECENTS_OVERRIDE_SYSPROP_KEY);
    if (!cnStr.isEmpty()) {
      mOverrideRecentsPackageName=cnStr;
    }
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sSystemServicesProxy,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sTaskLoader,EVENT_BUS_PRIORITY);
  final int processUser=sSystemServicesProxy.getProcessUser();
  if (sSystemServicesProxy.isSystemUser(processUser)) {
    mSystemToUserCallbacks=new RecentsSystemUser(mContext,mImpl);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    mContext.registerReceiverAsUser(mSystemUserUnlockedReceiver,UserHandle.SYSTEM,filter,null,null);
  }
 else {
    registerWithSystemUser();
  }
  putComponent(Recents.class,this);
  long lastVisibleTaskActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,-1);
  if (lastVisibleTaskActiveTime != -1) {
    long uptime=SystemClock.elapsedRealtime();
    Settings.Secure.putLongForUser(mContext.getContentResolver(),Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,uptime - Math.max(0,System.currentTimeMillis() - lastVisibleTaskActiveTime),processUser);
    Prefs.remove(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME);
  }
}",0.8532690569448629
191018,"@Override public void dump(String prefix,FileDescriptor fd,PrintWriter writer,String[] args){
  super.dump(prefix,fd,writer,args);
  EventBus.getDefault().dump(prefix,writer);
  Recents.getTaskLoader().dump(prefix,writer);
  String id=Integer.toHexString(System.identityHashCode(this));
  long lastStackActiveTime=Prefs.getLong(this,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,-1);
  writer.print(prefix);
  writer.print(TAG);
  writer.print(""String_Node_Str"");
  writer.print(mIsVisible ? ""String_Node_Str"" : ""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(lastStackActiveTime);
  writer.print(""String_Node_Str"");
  writer.print(System.currentTimeMillis());
  writer.print(""String_Node_Str"");
  writer.print(id);
  writer.print(""String_Node_Str"");
  writer.println();
  if (mRecentsView != null) {
    mRecentsView.dump(prefix,writer);
  }
}","@Override public void dump(String prefix,FileDescriptor fd,PrintWriter writer,String[] args){
  super.dump(prefix,fd,writer,args);
  EventBus.getDefault().dump(prefix,writer);
  Recents.getTaskLoader().dump(prefix,writer);
  ContentResolver cr=getContentResolver();
  long lastPersistUptime=Settings.Secure.getLong(cr,Settings.Secure.TASK_PERSISTER_LAST_WRITE_UPTIME,0);
  long lastVisibleTaskActiveUptime=Settings.Secure.getLongForUser(cr,Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,SystemClock.elapsedRealtime(),Recents.getSystemServices().getCurrentUser());
  String id=Integer.toHexString(System.identityHashCode(this));
  writer.print(prefix);
  writer.print(TAG);
  writer.print(""String_Node_Str"");
  writer.print(mIsVisible ? ""String_Node_Str"" : ""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(lastPersistUptime);
  writer.print(""String_Node_Str"");
  writer.print(lastVisibleTaskActiveUptime);
  writer.print(""String_Node_Str"");
  writer.print(id);
  writer.print(""String_Node_Str"");
  writer.println();
  if (mRecentsView != null) {
    mRecentsView.dump(prefix,writer);
  }
}",0.6817724068479355
191019,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mFinishedOnStartup=false;
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp == null) {
    mFinishedOnStartup=true;
    finish();
    return;
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  mPackageMonitor=new RecentsPackageMonitor();
  mPackageMonitor.register(this);
  setContentView(R.layout.recents);
  takeKeyEvents(true);
  mRecentsView=(RecentsView)findViewById(R.id.recents_view);
  mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mScrimViews=new SystemBarScrimViews(this);
  getWindow().getAttributes().privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY;
  Configuration appConfiguration=Utilities.getAppConfiguration(this);
  mLastDeviceOrientation=appConfiguration.orientation;
  mLastDisplayDensity=appConfiguration.densityDpi;
  mFocusTimerDuration=getResources().getInteger(R.integer.recents_auto_advance_duration);
  mIterateTrigger=new DozeTrigger(mFocusTimerDuration,new Runnable(){
    @Override public void run(){
      dismissRecentsToFocusedTask(MetricsEvent.OVERVIEW_SELECT_TIMEOUT);
    }
  }
);
  getWindow().setBackgroundDrawable(mRecentsView.getBackgroundScrim());
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_TIME_CHANGED);
  registerReceiver(mSystemBroadcastReceiver,filter);
  getWindow().addPrivateFlags(LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION);
  reloadStackView();
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mFinishedOnStartup=false;
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp == null) {
    mFinishedOnStartup=true;
    finish();
    return;
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  mPackageMonitor=new RecentsPackageMonitor();
  mPackageMonitor.register(this);
  setContentView(R.layout.recents);
  takeKeyEvents(true);
  mRecentsView=(RecentsView)findViewById(R.id.recents_view);
  mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mScrimViews=new SystemBarScrimViews(this);
  getWindow().getAttributes().privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY;
  Configuration appConfiguration=Utilities.getAppConfiguration(this);
  mLastDeviceOrientation=appConfiguration.orientation;
  mLastDisplayDensity=appConfiguration.densityDpi;
  mFocusTimerDuration=getResources().getInteger(R.integer.recents_auto_advance_duration);
  mIterateTrigger=new DozeTrigger(mFocusTimerDuration,new Runnable(){
    @Override public void run(){
      dismissRecentsToFocusedTask(MetricsEvent.OVERVIEW_SELECT_TIMEOUT);
    }
  }
);
  getWindow().setBackgroundDrawable(mRecentsView.getBackgroundScrim());
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mSystemBroadcastReceiver,filter);
  getWindow().addPrivateFlags(LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION);
  reloadStackView();
}",0.9872408293460924
191020,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    dismissRecentsToHomeIfVisible(false);
  }
 else   if (action.equals(Intent.ACTION_TIME_CHANGED)) {
    Prefs.putLong(RecentsActivity.this,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    dismissRecentsToHomeIfVisible(false);
  }
}",0.7219152854511971
191021,"/** 
 * Returns a list of the recents tasks.
 * @param includeFrontMostExcludedTask if set, will ensure that the front most excluded taskwill be visible, otherwise no excluded tasks will be visible.
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean includeFrontMostExcludedTask,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=i;
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  int flags=ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES;
  if (includeFrontMostExcludedTask) {
    flags|=ActivityManager.RECENT_WITH_EXCLUDED;
  }
  List<ActivityManager.RecentTaskInfo> tasks=null;
  try {
    tasks=mAm.getRecentTasksForUser(numTasksToQuery,flags,userId);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    if (sRecentsBlacklist.contains(t.realActivity.getClassName()) || sRecentsBlacklist.contains(t.realActivity.getPackageName())) {
      iter.remove();
      continue;
    }
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isExcluded && (!isFirstValidTask || !includeFrontMostExcludedTask)) {
      iter.remove();
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}","/** 
 * Returns a list of the recents tasks.
 * @param includeFrontMostExcludedTask if set, will ensure that the front most excluded taskwill be visible, otherwise no excluded tasks will be visible.
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean includeFrontMostExcludedTask,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=SystemClock.elapsedRealtime();
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  int flags=ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES;
  if (includeFrontMostExcludedTask) {
    flags|=ActivityManager.RECENT_WITH_EXCLUDED;
  }
  List<ActivityManager.RecentTaskInfo> tasks=null;
  try {
    tasks=mAm.getRecentTasksForUser(numTasksToQuery,flags,userId);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    if (sRecentsBlacklist.contains(t.realActivity.getClassName()) || sRecentsBlacklist.contains(t.realActivity.getPackageName())) {
      iter.remove();
      continue;
    }
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isExcluded && (!isFirstValidTask || !includeFrontMostExcludedTask)) {
      iter.remove();
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}",0.9951519069166128
191022,"/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean includeFrontMostExcludedTask){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(includeFrontMostExcludedTask);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  long lastStackActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    lastStackActiveTime=0;
  }
  long newLastStackActiveTime=-1;
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=SystemServicesProxy.isFreeformStack(t.stackId);
    boolean isStackTask=isFreeformTask || !isHistoricalTask(t) || (t.lastActiveTime >= lastStackActiveTime && i >= (taskCount - MIN_NUM_TASKS));
    boolean isLaunchTarget=taskKey.id == runningTaskId;
    if (isStackTask && newLastStackActiveTime < 0) {
      newLastStackActiveTime=t.lastActiveTime;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (newLastStackActiveTime != -1) {
    Prefs.putLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,newLastStackActiveTime);
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}","/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean includeFrontMostExcludedTask){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(includeFrontMostExcludedTask);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  boolean updatedLastVisibleTaskActiveTime=false;
  long newLastVisibileTaskActiveTime=0;
  long currentTime=mTimeProvider.getTime();
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=mSystemServicesProxy.isFreeformStack(t.stackId);
    boolean isRecentlyUsedTask=t.lastActiveTime >= (currentTime - SESSION_BEGIN_TIME);
    boolean isMoreRecentThanLastVisible=t.lastActiveTime >= mLastVisibileTaskActiveTime;
    boolean isStackTask=isFreeformTask || (isMoreRecentThanLastVisible && (isRecentlyUsedTask || i >= (taskCount - MIN_NUM_TASKS)));
    boolean isLaunchTarget=t.persistentId == runningTaskId;
    if (isStackTask && !updatedLastVisibleTaskActiveTime) {
      newLastVisibileTaskActiveTime=t.lastActiveTime;
      updatedLastVisibleTaskActiveTime=true;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (updatedLastVisibleTaskActiveTime && newLastVisibileTaskActiveTime != mLastVisibileTaskActiveTime) {
    Settings.Secure.putLongForUser(mContext.getContentResolver(),Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,newLastVisibileTaskActiveTime,UserHandle.USER_CURRENT);
    mLastVisibileTaskActiveTime=newLastVisibileTaskActiveTime;
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}",0.3081579705967137
191023,"/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean includeFrontMostExcludedTask){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  SystemServicesProxy ssp=Recents.getSystemServices();
  mRawTasks=ssp.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,includeFrontMostExcludedTask,mCurrentQuietProfiles);
  Collections.reverse(mRawTasks);
}","/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean includeFrontMostExcludedTask){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  mRawTasks=mSystemServicesProxy.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,includeFrontMostExcludedTask,mCurrentQuietProfiles);
  mLastVisibileTaskActiveTime=RecentsDebugFlags.Static.EnableMockTasks ? SystemClock.elapsedRealtime() : Settings.Secure.getLongForUser(mContext.getContentResolver(),Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,0,currentUserId);
  Collections.reverse(mRawTasks);
}",0.7216494845360825
191024,"/** 
 * Package level ctor 
 */
RecentsTaskLoadPlan(Context context){
  mContext=context;
}","@VisibleForTesting public RecentsTaskLoadPlan(Context context,SystemServicesProxy ssp){
  mContext=context;
  mSystemServicesProxy=ssp;
}",0.5701754385964912
191025,"private void maybeSwapSearchIcon(@NonNull ComponentName assistComponent,boolean isService){
  replaceDrawable(mView.getOrb().getLogo(),assistComponent,ASSIST_ICON_METADATA_NAME,isService);
}","private void maybeSwapSearchIcon(@NonNull ComponentName assistComponent,boolean isService){
  if (mView == null) {
    onConfigurationChanged();
  }
  replaceDrawable(mView.getOrb().getLogo(),assistComponent,ASSIST_ICON_METADATA_NAME,isService);
}",0.8695652173913043
191026,"@Override public void interfaceStatusChanged(String iface,boolean up){
  if (VDBG)   Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str""+ up);
  boolean found=false;
  boolean usb=false;
  WifiManager mWifiManager=(WifiManager)mContext.getSystemService(Context.WIFI_SERVICE);
synchronized (mPublicSync) {
    if (isWifi(iface)) {
      found=true;
    }
 else     if (isUsb(iface)) {
      found=true;
      usb=true;
    }
 else     if (isBluetooth(iface)) {
      found=true;
    }
    if (found == false)     return;
    TetherInterfaceSM sm=mIfaces.get(iface);
    if (up) {
      if (sm == null) {
        sm=new TetherInterfaceSM(iface,mLooper,usb);
        mIfaces.put(iface,sm);
        sm.start();
      }
    }
 else {
      if (isUsb(iface)) {
        if (VDBG)         Log.d(TAG,""String_Node_Str"" + iface);
      }
 else       if (isWifi(iface) && (mWifiManager != null) && mWifiManager.getWifiStaSapConcurrency()) {
        int wifiApState=0;
        wifiApState=mWifiManager.getWifiApState();
        if ((wifiApState == WifiManager.WIFI_AP_STATE_DISABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_DISABLED)) {
          if (VDBG)           Log.d(TAG,""String_Node_Str"" + iface);
          sm.sendMessage(TetherInterfaceSM.CMD_INTERFACE_DOWN);
          mIfaces.remove(iface);
        }
 else {
          if (VDBG)           Log.d(TAG,""String_Node_Str"" + iface);
        }
      }
 else       if (sm != null) {
        sm.sendMessage(TetherInterfaceSM.CMD_INTERFACE_DOWN);
        mIfaces.remove(iface);
      }
    }
  }
}","@Override public void interfaceStatusChanged(String iface,boolean up){
  if (VDBG)   Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str""+ up);
  boolean found=false;
  boolean usb=false;
  WifiManager mWifiManager=(WifiManager)mContext.getSystemService(Context.WIFI_SERVICE);
synchronized (mPublicSync) {
    if (isWifi(iface)) {
      found=true;
    }
 else     if (isUsb(iface)) {
      found=true;
      usb=true;
    }
 else     if (isBluetooth(iface)) {
      found=true;
    }
    if (found == false)     return;
    TetherInterfaceSM sm=mIfaces.get(iface);
    if (up) {
      if (sm == null) {
        sm=new TetherInterfaceSM(iface,mLooper,usb);
        mIfaces.put(iface,sm);
        sm.start();
      }
    }
 else {
      if (isUsb(iface) || isBluetooth(iface) || isWifi(iface)) {
        if (VDBG)         Log.d(TAG,""String_Node_Str"" + iface);
      }
 else       if (sm != null) {
        sm.sendMessage(TetherInterfaceSM.CMD_INTERFACE_DOWN);
        mIfaces.remove(iface);
      }
    }
  }
}",0.7594837700430191
191027,"protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
    final String pkg=sbn.getPackageName();
    String appname=pkg;
    try {
      final ApplicationInfo info=pmUser.getApplicationInfo(pkg,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      if (info != null) {
        appname=String.valueOf(pmUser.getApplicationLabel(info));
      }
    }
 catch (    NameNotFoundException e) {
    }
    row.setAppName(appname);
  }
  workAroundBadLayerDrawableOpacity(row);
  View vetoButton=bindVetoButtonClickListener(row,sbn);
  vetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}","protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
    final String pkg=sbn.getPackageName();
    String appname=pkg;
    try {
      final ApplicationInfo info=pmUser.getApplicationInfo(pkg,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      if (info != null) {
        appname=String.valueOf(pmUser.getApplicationLabel(info));
      }
    }
 catch (    NameNotFoundException e) {
    }
    row.setAppName(appname);
  }
  workAroundBadLayerDrawableOpacity(row);
  bindDismissListener(row);
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}",0.984725050916497
191028,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
    mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  bindVetoButtonClickListener(entry.row,notification);
  if (!notification.isClearable()) {
    mStackScroller.snapViewIfNeeded(entry.row);
  }
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
    mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  if (!notification.isClearable()) {
    mStackScroller.snapViewIfNeeded(entry.row);
  }
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.989093793376958
191029,"public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  updateClearability();
  if (mIsSummaryWithChildren) {
    mChildrenContainer.recreateNotificationHeader(mExpandClickListener,mEntry.notification);
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  if (mIsSummaryWithChildren) {
    mChildrenContainer.recreateNotificationHeader(mExpandClickListener,mEntry.notification);
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}",0.9835841313269492
191030,"private boolean canViewBeDismissed(){
  return isClearable() && (!mShowingPublic || !mSensitiveHiddenInGeneral);
}","/** 
 * @return Whether this view is allowed to be dismissed. Only valid for visible notifications asotherwise some state might not be updated. To request about the general clearability see  {@link #isClearable()}.
 */
public boolean canViewBeDismissed(){
  return isClearable() && (!mShowingPublic || !mSensitiveHiddenInGeneral);
}",0.484304932735426
191031,"/** 
 * @return Can the underlying notification be cleared?
 */
public boolean isClearable(){
  return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}","/** 
 * @return Can the underlying notification be cleared? This can be different from whether thenotification can be dismissed in case notifications are sensitive on the lockscreen.
 * @see #canViewBeDismissed()
 */
public boolean isClearable(){
  return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}",0.697029702970297
191032,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mPublicLayout=(NotificationContentView)findViewById(R.id.expandedPublic);
  mPublicLayout.setContainingNotification(this);
  mPrivateLayout=(NotificationContentView)findViewById(R.id.expanded);
  mPrivateLayout.setExpandClickListener(mExpandClickListener);
  mPrivateLayout.setContainingNotification(this);
  mPublicLayout.setExpandClickListener(mExpandClickListener);
  mSettingsIconRowStub=(ViewStub)findViewById(R.id.settings_icon_row_stub);
  mSettingsIconRowStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mSettingsIconRow=(NotificationSettingsIconRow)inflated;
      mSettingsIconRow.setNotificationRowParent(ExpandableNotificationRow.this);
      mSettingsIconRow.setAppName(mAppName);
    }
  }
);
  mGutsStub=(ViewStub)findViewById(R.id.notification_guts_stub);
  mGutsStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mGuts=(NotificationGuts)inflated;
      mGuts.setClipTopAmount(getClipTopAmount());
      mGuts.setActualHeight(getActualHeight());
      mGutsStub=null;
    }
  }
);
  mChildrenContainerStub=(ViewStub)findViewById(R.id.child_container_stub);
  mChildrenContainerStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mChildrenContainer=(NotificationChildrenContainer)inflated;
      mChildrenContainer.setNotificationParent(ExpandableNotificationRow.this);
      mChildrenContainer.onNotificationUpdated();
      mTranslateableViews.add(mChildrenContainer);
    }
  }
);
  mVetoButton=findViewById(R.id.veto);
  mTranslateableViews=new ArrayList<View>();
  for (int i=0; i < getChildCount(); i++) {
    mTranslateableViews.add(getChildAt(i));
  }
  mTranslateableViews.remove(mVetoButton);
  mTranslateableViews.remove(mSettingsIconRowStub);
  mTranslateableViews.remove(mChildrenContainerStub);
  mTranslateableViews.remove(mGutsStub);
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mPublicLayout=(NotificationContentView)findViewById(R.id.expandedPublic);
  mPublicLayout.setContainingNotification(this);
  mPrivateLayout=(NotificationContentView)findViewById(R.id.expanded);
  mPrivateLayout.setExpandClickListener(mExpandClickListener);
  mPrivateLayout.setContainingNotification(this);
  mPublicLayout.setExpandClickListener(mExpandClickListener);
  mSettingsIconRowStub=(ViewStub)findViewById(R.id.settings_icon_row_stub);
  mSettingsIconRowStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mSettingsIconRow=(NotificationSettingsIconRow)inflated;
      mSettingsIconRow.setNotificationRowParent(ExpandableNotificationRow.this);
      mSettingsIconRow.setAppName(mAppName);
    }
  }
);
  mGutsStub=(ViewStub)findViewById(R.id.notification_guts_stub);
  mGutsStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mGuts=(NotificationGuts)inflated;
      mGuts.setClipTopAmount(getClipTopAmount());
      mGuts.setActualHeight(getActualHeight());
      mGutsStub=null;
    }
  }
);
  mChildrenContainerStub=(ViewStub)findViewById(R.id.child_container_stub);
  mChildrenContainerStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mChildrenContainer=(NotificationChildrenContainer)inflated;
      mChildrenContainer.setNotificationParent(ExpandableNotificationRow.this);
      mChildrenContainer.onNotificationUpdated();
      mTranslateableViews.add(mChildrenContainer);
    }
  }
);
  mVetoButton=findViewById(R.id.veto);
  mVetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  mVetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  mTranslateableViews=new ArrayList<View>();
  for (int i=0; i < getChildCount(); i++) {
    mTranslateableViews.add(getChildAt(i));
  }
  mTranslateableViews.remove(mVetoButton);
  mTranslateableViews.remove(mSettingsIconRowStub);
  mTranslateableViews.remove(mChildrenContainerStub);
  mTranslateableViews.remove(mGutsStub);
}",0.9585987261146496
191033,"public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    if (mChildrenContainer != null) {
      mChildrenContainer.animate().cancel();
      mChildrenContainer.setAlpha(1f);
    }
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateClearability();
  mShowingPublicInitialized=true;
}","public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    if (mChildrenContainer != null) {
      mChildrenContainer.animate().cancel();
      mChildrenContainer.setAlpha(1f);
    }
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  mShowingPublicInitialized=true;
}",0.9879396984924624
191034,"public static void performDismiss(View v,NotificationGroupManager groupManager,boolean fromAccessibility){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (groupManager.isOnlyChildInGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=groupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary,groupManager,fromAccessibility);
      }
    }
    row.setDismissed(true,fromAccessibility);
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}","public static void performDismiss(View v,NotificationGroupManager groupManager,boolean fromAccessibility){
  if (!(v instanceof ExpandableNotificationRow)) {
    return;
  }
  ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  if (groupManager.isOnlyChildInGroup(row.getStatusBarNotification())) {
    ExpandableNotificationRow groupSummary=groupManager.getLogicalGroupSummary(row.getStatusBarNotification());
    if (groupSummary.isClearable()) {
      performDismiss(groupSummary,groupManager,fromAccessibility);
    }
  }
  row.setDismissed(true,fromAccessibility);
  if (row.isClearable()) {
    row.performDismiss();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}",0.8697450034458993
191035,"public static boolean canChildBeDismissed(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (row.areGutsExposed()) {
      return false;
    }
  }
  final View veto=v.findViewById(R.id.veto);
  return (veto != null && veto.getVisibility() != View.GONE);
}","public static boolean canChildBeDismissed(View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    return false;
  }
  ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  if (row.areGutsExposed()) {
    return false;
  }
  return row.canViewBeDismissed();
}",0.6721581548599671
191036,"/** 
 * Authentication result
 * @param crypto the crypto object
 * @param fingerprint the recognized fingerprint data, if allowed.
 * @hide
 */
public AuthenticationResult(CryptoObject crypto,Fingerprint fingerprint){
  mCryptoObject=crypto;
  mFingerprint=fingerprint;
}","/** 
 * Authentication result
 * @param crypto the crypto object
 * @param fingerprint the recognized fingerprint data, if allowed.
 * @hide
 */
public AuthenticationResult(CryptoObject crypto,Fingerprint fingerprint,int userId){
  mCryptoObject=crypto;
  mFingerprint=fingerprint;
  mUserId=userId;
}",0.949389179755672
191037,"@Override public void onAuthenticationSucceeded(long deviceId,Fingerprint fp){
  mHandler.obtainMessage(MSG_AUTHENTICATION_SUCCEEDED,fp).sendToTarget();
}","@Override public void onAuthenticationSucceeded(long deviceId,Fingerprint fp,int userId){
  mHandler.obtainMessage(MSG_AUTHENTICATION_SUCCEEDED,userId,0,fp).sendToTarget();
}",0.9390243902439024
191038,"@Override public void handleMessage(android.os.Message msg){
switch (msg.what) {
case MSG_ENROLL_RESULT:
    sendEnrollResult((Fingerprint)msg.obj,msg.arg1);
  break;
case MSG_ACQUIRED:
sendAcquiredResult((Long)msg.obj,msg.arg1);
break;
case MSG_AUTHENTICATION_SUCCEEDED:
sendAuthenticatedSucceeded((Fingerprint)msg.obj);
break;
case MSG_AUTHENTICATION_FAILED:
sendAuthenticatedFailed();
break;
case MSG_ERROR:
sendErrorResult((Long)msg.obj,msg.arg1);
break;
case MSG_REMOVED:
sendRemovedResult((Long)msg.obj,msg.arg1,msg.arg2);
}
}","@Override public void handleMessage(android.os.Message msg){
switch (msg.what) {
case MSG_ENROLL_RESULT:
    sendEnrollResult((Fingerprint)msg.obj,msg.arg1);
  break;
case MSG_ACQUIRED:
sendAcquiredResult((Long)msg.obj,msg.arg1);
break;
case MSG_AUTHENTICATION_SUCCEEDED:
sendAuthenticatedSucceeded((Fingerprint)msg.obj,msg.arg1);
break;
case MSG_AUTHENTICATION_FAILED:
sendAuthenticatedFailed();
break;
case MSG_ERROR:
sendErrorResult((Long)msg.obj,msg.arg1);
break;
case MSG_REMOVED:
sendRemovedResult((Long)msg.obj,msg.arg1,msg.arg2);
}
}",0.9916123019571296
191039,"private void sendAuthenticatedSucceeded(Fingerprint fp){
  if (mAuthenticationCallback != null) {
    final AuthenticationResult result=new AuthenticationResult(mCryptoObject,fp);
    mAuthenticationCallback.onAuthenticationSucceeded(result);
  }
}","private void sendAuthenticatedSucceeded(Fingerprint fp,int userId){
  if (mAuthenticationCallback != null) {
    final AuthenticationResult result=new AuthenticationResult(mCryptoObject,fp,userId);
    mAuthenticationCallback.onAuthenticationSucceeded(result);
  }
}",0.9649805447470816
191040,"private void generateHeadsUpAnimationEvents(){
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    int type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_OTHER;
    boolean onBottom=false;
    boolean pinnedAndClosed=row.isPinned() && !mIsExpanded;
    if (!mIsExpanded && !isHeadsUp) {
      type=row.wasJustClicked() ? AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR_CLICK : AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR;
    }
 else {
      StackViewState viewState=mCurrentStackScrollState.getViewStateForView(row);
      if (viewState == null) {
        continue;
      }
      if (isHeadsUp && (mAddedHeadsUpChildren.contains(row) || pinnedAndClosed)) {
        if (pinnedAndClosed || shouldHunAppearFromBottom(viewState)) {
          type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_APPEAR;
        }
 else {
          type=AnimationEvent.ANIMATION_TYPE_ADD;
        }
        onBottom=!pinnedAndClosed;
      }
    }
    AnimationEvent event=new AnimationEvent(row,type);
    event.headsUpFromBottom=onBottom;
    mAnimationEvents.add(event);
  }
  mHeadsUpChangeAnimations.clear();
  mAddedHeadsUpChildren.clear();
}","private void generateHeadsUpAnimationEvents(){
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    int type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_OTHER;
    boolean onBottom=false;
    boolean pinnedAndClosed=row.isPinned() && !mIsExpanded;
    if (!mIsExpanded && !isHeadsUp) {
      type=row.wasJustClicked() ? AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR_CLICK : AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR;
      if (row.isChildInGroup()) {
        row.setHeadsupDisappearRunning(false);
      }
    }
 else {
      StackViewState viewState=mCurrentStackScrollState.getViewStateForView(row);
      if (viewState == null) {
        continue;
      }
      if (isHeadsUp && (mAddedHeadsUpChildren.contains(row) || pinnedAndClosed)) {
        if (pinnedAndClosed || shouldHunAppearFromBottom(viewState)) {
          type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_APPEAR;
        }
 else {
          type=AnimationEvent.ANIMATION_TYPE_ADD;
        }
        onBottom=!pinnedAndClosed;
      }
    }
    AnimationEvent event=new AnimationEvent(row,type);
    event.headsUpFromBottom=onBottom;
    mAnimationEvents.add(event);
  }
  mHeadsUpChangeAnimations.clear();
  mAddedHeadsUpChildren.clear();
}",0.9655972168534984
191041,"/** 
 * Remove a removed child view from the heads up animations if it was just added there
 * @return whether any child was removed from the list to animate
 */
private boolean removeRemovedChildFromHeadsUpChangeAnimations(View child){
  boolean hasAddEvent=false;
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    if (child == row) {
      mTmpList.add(eventPair);
      hasAddEvent|=isHeadsUp;
    }
  }
  if (hasAddEvent) {
    mHeadsUpChangeAnimations.removeAll(mTmpList);
  }
  mTmpList.clear();
  return hasAddEvent;
}","/** 
 * Remove a removed child view from the heads up animations if it was just added there
 * @return whether any child was removed from the list to animate
 */
private boolean removeRemovedChildFromHeadsUpChangeAnimations(View child){
  boolean hasAddEvent=false;
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    if (child == row) {
      mTmpList.add(eventPair);
      hasAddEvent|=isHeadsUp;
    }
  }
  if (hasAddEvent) {
    mHeadsUpChangeAnimations.removeAll(mTmpList);
    ((ExpandableNotificationRow)child).setHeadsupDisappearRunning(false);
  }
  mTmpList.clear();
  return hasAddEvent;
}",0.9468390804597702
191042,"public void onChildAnimationFinished(){
  setAnimationRunning(false);
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
  clearViewOverlays();
}","public void onChildAnimationFinished(){
  setAnimationRunning(false);
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
  clearViewOverlays();
  clearHeadsUpDisappearRunning();
}",0.9017341040462428
191043,"/** 
 * Validate internal set of accounts against installed authenticators for given user. Clear cached authenticators before validating when requested.
 */
private void validateAccountsInternal(UserAccounts accounts,boolean invalidateAuthenticatorCache){
  if (Log.isLoggable(TAG,Log.DEBUG)) {
    Log.d(TAG,""String_Node_Str"" + accounts.userId + ""String_Node_Str""+ accounts.openHelper.isCeDatabaseAttached()+ ""String_Node_Str""+ mLocalUnlockedUsers.get(accounts.userId));
  }
  if (invalidateAuthenticatorCache) {
    mAuthenticatorCache.invalidateCache(accounts.userId);
  }
  final HashMap<String,Integer> knownAuth=getAuthenticatorTypeAndUIDForUser(mAuthenticatorCache,accounts.userId);
  boolean userUnlocked=isLocalUnlockedUser(accounts.userId);
synchronized (accounts.cacheLock) {
    final SQLiteDatabase db=accounts.openHelper.getWritableDatabase();
    boolean accountDeleted=false;
    Cursor metaCursor=db.query(TABLE_META,new String[]{META_KEY,META_VALUE},SELECTION_META_BY_AUTHENTICATOR_TYPE,new String[]{META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + ""String_Node_Str""},null,null,META_KEY);
    HashSet<String> obsoleteAuthType=Sets.newHashSet();
    try {
      SparseBooleanArray knownUids=null;
      while (metaCursor.moveToNext()) {
        String type=TextUtils.split(metaCursor.getString(0),META_KEY_DELIMITER)[1];
        String uid=metaCursor.getString(1);
        if (TextUtils.isEmpty(type) || TextUtils.isEmpty(uid)) {
          Slog.e(TAG,""String_Node_Str"" + TextUtils.isEmpty(type) + ""String_Node_Str""+ TextUtils.isEmpty(uid));
          continue;
        }
        Integer knownUid=knownAuth.get(type);
        if (knownUid != null && uid.equals(knownUid.toString())) {
          knownAuth.remove(type);
        }
 else {
          if (knownUids == null) {
            knownUids=getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);
          }
          if (!knownUids.get(Integer.parseInt(uid))) {
            obsoleteAuthType.add(type);
            db.delete(TABLE_META,META_KEY + ""String_Node_Str"" + META_VALUE+ ""String_Node_Str"",new String[]{META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + type,uid});
          }
        }
      }
    }
  finally {
      metaCursor.close();
    }
    Iterator<Entry<String,Integer>> iterator=knownAuth.entrySet().iterator();
    while (iterator.hasNext()) {
      Entry<String,Integer> entry=iterator.next();
      ContentValues values=new ContentValues();
      values.put(META_KEY,META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + entry.getKey());
      values.put(META_VALUE,entry.getValue());
      db.insertWithOnConflict(TABLE_META,null,values,SQLiteDatabase.CONFLICT_REPLACE);
    }
    Cursor cursor=db.query(TABLE_ACCOUNTS,new String[]{ACCOUNTS_ID,ACCOUNTS_TYPE,ACCOUNTS_NAME},null,null,null,null,ACCOUNTS_ID);
    try {
      accounts.accountCache.clear();
      final HashMap<String,ArrayList<String>> accountNamesByType=new LinkedHashMap<>();
      while (cursor.moveToNext()) {
        final long accountId=cursor.getLong(0);
        final String accountType=cursor.getString(1);
        final String accountName=cursor.getString(2);
        if (obsoleteAuthType.contains(accountType)) {
          Slog.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ accountType+ ""String_Node_Str"");
          db.beginTransaction();
          try {
            db.delete(TABLE_ACCOUNTS,ACCOUNTS_ID + ""String_Node_Str"" + accountId,null);
            if (userUnlocked) {
              db.delete(CE_TABLE_ACCOUNTS,ACCOUNTS_ID + ""String_Node_Str"" + accountId,null);
            }
            db.setTransactionSuccessful();
          }
  finally {
            db.endTransaction();
          }
          accountDeleted=true;
          logRecord(db,DebugDbHelper.ACTION_AUTHENTICATOR_REMOVE,TABLE_ACCOUNTS,accountId,accounts);
          final Account account=new Account(accountName,accountType);
          accounts.userDataCache.remove(account);
          accounts.authTokenCache.remove(account);
          accounts.accountTokenCaches.remove(account);
        }
 else {
          ArrayList<String> accountNames=accountNamesByType.get(accountType);
          if (accountNames == null) {
            accountNames=new ArrayList<String>();
            accountNamesByType.put(accountType,accountNames);
          }
          accountNames.add(accountName);
        }
      }
      for (      Map.Entry<String,ArrayList<String>> cur : accountNamesByType.entrySet()) {
        final String accountType=cur.getKey();
        final ArrayList<String> accountNames=cur.getValue();
        final Account[] accountsForType=new Account[accountNames.size()];
        for (int i=0; i < accountsForType.length; i++) {
          accountsForType[i]=new Account(accountNames.get(i),accountType);
        }
        accounts.accountCache.put(accountType,accountsForType);
      }
    }
  finally {
      cursor.close();
      if (accountDeleted) {
        sendAccountsChangedBroadcast(accounts.userId);
      }
    }
  }
}","/** 
 * Validate internal set of accounts against installed authenticators for given user. Clear cached authenticators before validating when requested.
 */
private void validateAccountsInternal(UserAccounts accounts,boolean invalidateAuthenticatorCache){
  if (Log.isLoggable(TAG,Log.DEBUG)) {
    Log.d(TAG,""String_Node_Str"" + accounts.userId + ""String_Node_Str""+ accounts.openHelper.isCeDatabaseAttached()+ ""String_Node_Str""+ mLocalUnlockedUsers.get(accounts.userId));
  }
  if (SystemProperties.getBoolean(""String_Node_Str"",false)) {
    return;
  }
  if (invalidateAuthenticatorCache) {
    mAuthenticatorCache.invalidateCache(accounts.userId);
  }
  final HashMap<String,Integer> knownAuth=getAuthenticatorTypeAndUIDForUser(mAuthenticatorCache,accounts.userId);
  boolean userUnlocked=isLocalUnlockedUser(accounts.userId);
synchronized (accounts.cacheLock) {
    final SQLiteDatabase db=accounts.openHelper.getWritableDatabase();
    boolean accountDeleted=false;
    Cursor metaCursor=db.query(TABLE_META,new String[]{META_KEY,META_VALUE},SELECTION_META_BY_AUTHENTICATOR_TYPE,new String[]{META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + ""String_Node_Str""},null,null,META_KEY);
    HashSet<String> obsoleteAuthType=Sets.newHashSet();
    try {
      SparseBooleanArray knownUids=null;
      while (metaCursor.moveToNext()) {
        String type=TextUtils.split(metaCursor.getString(0),META_KEY_DELIMITER)[1];
        String uid=metaCursor.getString(1);
        if (TextUtils.isEmpty(type) || TextUtils.isEmpty(uid)) {
          Slog.e(TAG,""String_Node_Str"" + TextUtils.isEmpty(type) + ""String_Node_Str""+ TextUtils.isEmpty(uid));
          continue;
        }
        Integer knownUid=knownAuth.get(type);
        if (knownUid != null && uid.equals(knownUid.toString())) {
          knownAuth.remove(type);
        }
 else {
          if (knownUids == null) {
            knownUids=getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);
          }
          if (!knownUids.get(Integer.parseInt(uid))) {
            obsoleteAuthType.add(type);
            db.delete(TABLE_META,META_KEY + ""String_Node_Str"" + META_VALUE+ ""String_Node_Str"",new String[]{META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + type,uid});
          }
        }
      }
    }
  finally {
      metaCursor.close();
    }
    Iterator<Entry<String,Integer>> iterator=knownAuth.entrySet().iterator();
    while (iterator.hasNext()) {
      Entry<String,Integer> entry=iterator.next();
      ContentValues values=new ContentValues();
      values.put(META_KEY,META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + entry.getKey());
      values.put(META_VALUE,entry.getValue());
      db.insertWithOnConflict(TABLE_META,null,values,SQLiteDatabase.CONFLICT_REPLACE);
    }
    Cursor cursor=db.query(TABLE_ACCOUNTS,new String[]{ACCOUNTS_ID,ACCOUNTS_TYPE,ACCOUNTS_NAME},null,null,null,null,ACCOUNTS_ID);
    try {
      accounts.accountCache.clear();
      final HashMap<String,ArrayList<String>> accountNamesByType=new LinkedHashMap<>();
      while (cursor.moveToNext()) {
        final long accountId=cursor.getLong(0);
        final String accountType=cursor.getString(1);
        final String accountName=cursor.getString(2);
        if (obsoleteAuthType.contains(accountType)) {
          Slog.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ accountType+ ""String_Node_Str"");
          db.beginTransaction();
          try {
            db.delete(TABLE_ACCOUNTS,ACCOUNTS_ID + ""String_Node_Str"" + accountId,null);
            if (userUnlocked) {
              db.delete(CE_TABLE_ACCOUNTS,ACCOUNTS_ID + ""String_Node_Str"" + accountId,null);
            }
            db.setTransactionSuccessful();
          }
  finally {
            db.endTransaction();
          }
          accountDeleted=true;
          logRecord(db,DebugDbHelper.ACTION_AUTHENTICATOR_REMOVE,TABLE_ACCOUNTS,accountId,accounts);
          final Account account=new Account(accountName,accountType);
          accounts.userDataCache.remove(account);
          accounts.authTokenCache.remove(account);
          accounts.accountTokenCaches.remove(account);
        }
 else {
          ArrayList<String> accountNames=accountNamesByType.get(accountType);
          if (accountNames == null) {
            accountNames=new ArrayList<String>();
            accountNamesByType.put(accountType,accountNames);
          }
          accountNames.add(accountName);
        }
      }
      for (      Map.Entry<String,ArrayList<String>> cur : accountNamesByType.entrySet()) {
        final String accountType=cur.getKey();
        final ArrayList<String> accountNames=cur.getValue();
        final Account[] accountsForType=new Account[accountNames.size()];
        for (int i=0; i < accountsForType.length; i++) {
          accountsForType[i]=new Account(accountNames.get(i),accountType);
        }
        accounts.accountCache.put(accountType,accountsForType);
      }
    }
  finally {
      cursor.close();
      if (accountDeleted) {
        sendAccountsChangedBroadcast(accounts.userId);
      }
    }
  }
}",0.9922264301375324
191044,"/** 
 * Called when the set of account has changed, given the new array of active accounts.
 */
public void doDatabaseCleanup(Account[] accounts,int userId){
synchronized (mAuthorities) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Slog.v(TAG,""String_Node_Str"");
    }
    SparseArray<AuthorityInfo> removing=new SparseArray<AuthorityInfo>();
    Iterator<AccountInfo> accIt=mAccounts.values().iterator();
    while (accIt.hasNext()) {
      AccountInfo acc=accIt.next();
      if (!ArrayUtils.contains(accounts,acc.accountAndUser.account) && acc.accountAndUser.userId == userId) {
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          Slog.v(TAG,""String_Node_Str"" + acc.accountAndUser);
        }
        for (        AuthorityInfo auth : acc.authorities.values()) {
          removing.put(auth.ident,auth);
        }
        accIt.remove();
      }
    }
    int i=removing.size();
    if (i > 0) {
      while (i > 0) {
        i--;
        int ident=removing.keyAt(i);
        AuthorityInfo auth=removing.valueAt(i);
        if (mAuthorityRemovedListener != null) {
          mAuthorityRemovedListener.onAuthorityRemoved(auth.target);
        }
        mAuthorities.remove(ident);
        int j=mSyncStatus.size();
        while (j > 0) {
          j--;
          if (mSyncStatus.keyAt(j) == ident) {
            mSyncStatus.remove(mSyncStatus.keyAt(j));
          }
        }
        j=mSyncHistory.size();
        while (j > 0) {
          j--;
          if (mSyncHistory.get(j).authorityId == ident) {
            mSyncHistory.remove(j);
          }
        }
      }
      writeAccountInfoLocked();
      writeStatusLocked();
      writeStatisticsLocked();
    }
  }
}","/** 
 * Called when the set of account has changed, given the new array of active accounts.
 */
public void doDatabaseCleanup(Account[] accounts,int userId){
  if (SystemProperties.getBoolean(""String_Node_Str"",false)) {
    return;
  }
synchronized (mAuthorities) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Slog.v(TAG,""String_Node_Str"");
    }
    SparseArray<AuthorityInfo> removing=new SparseArray<AuthorityInfo>();
    Iterator<AccountInfo> accIt=mAccounts.values().iterator();
    while (accIt.hasNext()) {
      AccountInfo acc=accIt.next();
      if (!ArrayUtils.contains(accounts,acc.accountAndUser.account) && acc.accountAndUser.userId == userId) {
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          Slog.v(TAG,""String_Node_Str"" + acc.accountAndUser);
        }
        for (        AuthorityInfo auth : acc.authorities.values()) {
          removing.put(auth.ident,auth);
        }
        accIt.remove();
      }
    }
    int i=removing.size();
    if (i > 0) {
      while (i > 0) {
        i--;
        int ident=removing.keyAt(i);
        AuthorityInfo auth=removing.valueAt(i);
        if (mAuthorityRemovedListener != null) {
          mAuthorityRemovedListener.onAuthorityRemoved(auth.target);
        }
        mAuthorities.remove(ident);
        int j=mSyncStatus.size();
        while (j > 0) {
          j--;
          if (mSyncStatus.keyAt(j) == ident) {
            mSyncStatus.remove(mSyncStatus.keyAt(j));
          }
        }
        j=mSyncHistory.size();
        while (j > 0) {
          j--;
          if (mSyncHistory.get(j).authorityId == ident) {
            mSyncHistory.remove(j);
          }
        }
      }
      writeAccountInfoLocked();
      writeStatusLocked();
      writeStatisticsLocked();
    }
  }
}",0.9773650609402206
191045,"private void maybeSwapSearchIcon(@NonNull ComponentName assistComponent,boolean isService){
  replaceDrawable(mView.getOrb().getLogo(),assistComponent,ASSIST_ICON_METADATA_NAME,isService);
}","private void maybeSwapSearchIcon(@NonNull ComponentName assistComponent,boolean isService){
  if (mView == null) {
    onConfigurationChanged();
  }
  replaceDrawable(mView.getOrb().getLogo(),assistComponent,ASSIST_ICON_METADATA_NAME,isService);
}",0.8695652173913043
191046,"/** 
 * Returns stack's visibility:   {@link #STACK_INVISIBLE},   {@link #STACK_VISIBLE} or{@link #STACK_VISIBLE_ACTIVITY_BEHIND}.
 * @param starting The currently starting activity or null if there is none.
 */
int getStackVisibilityLocked(ActivityRecord starting){
  if (!isAttached()) {
    return STACK_INVISIBLE;
  }
  if (mStackSupervisor.isFrontStack(this) || mStackSupervisor.isFocusedStack(this)) {
    return STACK_VISIBLE;
  }
  final int stackIndex=mStacks.indexOf(this);
  if (stackIndex == mStacks.size() - 1) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
    return STACK_INVISIBLE;
  }
  final boolean isLockscreenShown=mService.mLockScreenShown == LOCK_SCREEN_SHOWN;
  if (isLockscreenShown && !StackId.isAllowedOverLockscreen(mStackId)) {
    return STACK_INVISIBLE;
  }
  final ActivityStack focusedStack=mStackSupervisor.getFocusedStack();
  final int focusedStackId=focusedStack.mStackId;
  if (mStackId == FULLSCREEN_WORKSPACE_STACK_ID && hasVisibleBehindActivity() && focusedStackId == HOME_STACK_ID && !focusedStack.topActivity().fullscreen) {
    return STACK_VISIBLE_ACTIVITY_BEHIND;
  }
  if (mStackId == DOCKED_STACK_ID) {
    final ActivityRecord r=focusedStack.topRunningActivityLocked();
    final TaskRecord task=r != null ? r.task : null;
    return task == null || task.canGoInDockedStack() || task.isHomeTask() ? STACK_VISIBLE : STACK_INVISIBLE;
  }
  int stackBehindFocusedIndex=mStacks.indexOf(focusedStack) - 1;
  while (stackBehindFocusedIndex >= 0 && mStacks.get(stackBehindFocusedIndex).topRunningActivityLocked() == null) {
    stackBehindFocusedIndex--;
  }
  if ((focusedStackId == DOCKED_STACK_ID || focusedStackId == PINNED_STACK_ID) && stackIndex == stackBehindFocusedIndex) {
    return STACK_VISIBLE;
  }
  final int stackBehindFocusedId=(stackBehindFocusedIndex >= 0) ? mStacks.get(stackBehindFocusedIndex).mStackId : INVALID_STACK_ID;
  if (focusedStackId == FULLSCREEN_WORKSPACE_STACK_ID && focusedStack.isStackTranslucent(starting,stackBehindFocusedId)) {
    if (stackIndex == stackBehindFocusedIndex) {
      return STACK_VISIBLE;
    }
    if (stackBehindFocusedIndex >= 0) {
      if ((stackBehindFocusedId == DOCKED_STACK_ID || stackBehindFocusedId == PINNED_STACK_ID) && stackIndex == (stackBehindFocusedIndex - 1)) {
        return STACK_VISIBLE;
      }
    }
  }
  if (StackId.isStaticStack(mStackId)) {
    return STACK_INVISIBLE;
  }
  for (int i=stackIndex + 1; i < mStacks.size(); i++) {
    final ActivityStack stack=mStacks.get(i);
    if (!stack.mFullscreen && !stack.hasFullscreenTask()) {
      continue;
    }
    if (!StackId.isDynamicStacksVisibleBehindAllowed(stack.mStackId)) {
      return STACK_INVISIBLE;
    }
    if (!stack.isStackTranslucent(starting,INVALID_STACK_ID)) {
      return STACK_INVISIBLE;
    }
  }
  return STACK_VISIBLE;
}","/** 
 * Returns stack's visibility:   {@link #STACK_INVISIBLE},   {@link #STACK_VISIBLE} or{@link #STACK_VISIBLE_ACTIVITY_BEHIND}.
 * @param starting The currently starting activity or null if there is none.
 */
int getStackVisibilityLocked(ActivityRecord starting){
  if (!isAttached()) {
    return STACK_INVISIBLE;
  }
  if (mStackSupervisor.isFrontStack(this) || mStackSupervisor.isFocusedStack(this)) {
    return STACK_VISIBLE;
  }
  final int stackIndex=mStacks.indexOf(this);
  if (stackIndex == mStacks.size() - 1) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
    return STACK_INVISIBLE;
  }
  final ActivityStack focusedStack=mStackSupervisor.getFocusedStack();
  final int focusedStackId=focusedStack.mStackId;
  if (mStackId == FULLSCREEN_WORKSPACE_STACK_ID && hasVisibleBehindActivity() && focusedStackId == HOME_STACK_ID && !focusedStack.topActivity().fullscreen) {
    return STACK_VISIBLE_ACTIVITY_BEHIND;
  }
  if (mStackId == DOCKED_STACK_ID) {
    final ActivityRecord r=focusedStack.topRunningActivityLocked();
    final TaskRecord task=r != null ? r.task : null;
    return task == null || task.canGoInDockedStack() || task.isHomeTask() ? STACK_VISIBLE : STACK_INVISIBLE;
  }
  int stackBehindFocusedIndex=mStacks.indexOf(focusedStack) - 1;
  while (stackBehindFocusedIndex >= 0 && mStacks.get(stackBehindFocusedIndex).topRunningActivityLocked() == null) {
    stackBehindFocusedIndex--;
  }
  if ((focusedStackId == DOCKED_STACK_ID || focusedStackId == PINNED_STACK_ID) && stackIndex == stackBehindFocusedIndex) {
    return STACK_VISIBLE;
  }
  final int stackBehindFocusedId=(stackBehindFocusedIndex >= 0) ? mStacks.get(stackBehindFocusedIndex).mStackId : INVALID_STACK_ID;
  if (focusedStackId == FULLSCREEN_WORKSPACE_STACK_ID && focusedStack.isStackTranslucent(starting,stackBehindFocusedId)) {
    if (stackIndex == stackBehindFocusedIndex) {
      return STACK_VISIBLE;
    }
    if (stackBehindFocusedIndex >= 0) {
      if ((stackBehindFocusedId == DOCKED_STACK_ID || stackBehindFocusedId == PINNED_STACK_ID) && stackIndex == (stackBehindFocusedIndex - 1)) {
        return STACK_VISIBLE;
      }
    }
  }
  if (StackId.isStaticStack(mStackId)) {
    return STACK_INVISIBLE;
  }
  for (int i=stackIndex + 1; i < mStacks.size(); i++) {
    final ActivityStack stack=mStacks.get(i);
    if (!stack.mFullscreen && !stack.hasFullscreenTask()) {
      continue;
    }
    if (!StackId.isDynamicStacksVisibleBehindAllowed(stack.mStackId)) {
      return STACK_INVISIBLE;
    }
    if (!stack.isStackTranslucent(starting,INVALID_STACK_ID)) {
      return STACK_INVISIBLE;
    }
  }
  return STACK_VISIBLE;
}",0.9659442724458204
191047,"void goodToGo(AppWindowAnimator topOpeningAppAnimator,AppWindowAnimator topClosingAppAnimator,ArraySet<AppWindowToken> openingApps,ArraySet<AppWindowToken> closingApps){
  mNextAppTransition=TRANSIT_UNSET;
  mAppTransitionState=APP_STATE_RUNNING;
  notifyAppTransitionStartingLocked(topOpeningAppAnimator != null ? topOpeningAppAnimator.mAppToken.token : null,topClosingAppAnimator != null ? topClosingAppAnimator.mAppToken.token : null,topOpeningAppAnimator != null ? topOpeningAppAnimator.animation : null,topClosingAppAnimator != null ? topClosingAppAnimator.animation : null);
  mService.getDefaultDisplayContentLocked().getDockedDividerController().notifyAppTransitionStarting();
  if (mNextAppTransition == TRANSIT_DOCK_TASK_FROM_RECENTS && !mProlongedAnimationsEnded) {
    for (int i=openingApps.size() - 1; i >= 0; i--) {
      final AppWindowAnimator appAnimator=openingApps.valueAt(i).mAppAnimator;
      appAnimator.startProlongAnimation(PROLONG_ANIMATION_AT_START);
    }
  }
}","void goodToGo(AppWindowAnimator topOpeningAppAnimator,AppWindowAnimator topClosingAppAnimator,ArraySet<AppWindowToken> openingApps,ArraySet<AppWindowToken> closingApps){
  mNextAppTransition=TRANSIT_UNSET;
  mAppTransitionState=APP_STATE_RUNNING;
  notifyAppTransitionStartingLocked(topOpeningAppAnimator != null ? topOpeningAppAnimator.mAppToken.token : null,topClosingAppAnimator != null ? topClosingAppAnimator.mAppToken.token : null,topOpeningAppAnimator != null ? topOpeningAppAnimator.animation : null,topClosingAppAnimator != null ? topClosingAppAnimator.animation : null);
  mService.getDefaultDisplayContentLocked().getDockedDividerController().notifyAppTransitionStarting(openingApps);
  if (mNextAppTransition == TRANSIT_DOCK_TASK_FROM_RECENTS && !mProlongedAnimationsEnded) {
    for (int i=openingApps.size() - 1; i >= 0; i--) {
      final AppWindowAnimator appAnimator=openingApps.valueAt(i).mAppAnimator;
      appAnimator.startProlongAnimation(PROLONG_ANIMATION_AT_START);
    }
  }
}",0.994475138121547
191048,"void notifyAppTransitionStarting(){
  checkMinimizeChanged(true);
}","void notifyAppTransitionStarting(ArraySet<AppWindowToken> openingApps){
  final boolean wasMinimized=mMinimizedDock;
  checkMinimizeChanged(true);
  if (wasMinimized && mMinimizedDock && containsAppInDockedStack(openingApps)) {
    mService.showRecentApps(true);
  }
}",0.4
191049,"@Override public void start(){
  sDebugFlags=new RecentsDebugFlags(mContext);
  sSystemServicesProxy=SystemServicesProxy.getInstance(mContext);
  sTaskLoader=new RecentsTaskLoader(mContext);
  sConfiguration=new RecentsConfiguration(mContext);
  UiModeManager uiModeManager=(UiModeManager)mContext.getSystemService(Context.UI_MODE_SERVICE);
  if (uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION) {
    mImpl=new RecentsTvImpl(mContext);
  }
 else {
    mImpl=new RecentsImpl(mContext);
  }
  if (""String_Node_Str"".equals(Build.TYPE) || ""String_Node_Str"".equals(Build.TYPE)) {
    String cnStr=SystemProperties.get(RECENTS_OVERRIDE_SYSPROP_KEY);
    if (!cnStr.isEmpty()) {
      mOverrideRecentsPackageName=cnStr;
    }
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sSystemServicesProxy,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sTaskLoader,EVENT_BUS_PRIORITY);
  final int processUser=sSystemServicesProxy.getProcessUser();
  if (sSystemServicesProxy.isSystemUser(processUser)) {
    mSystemToUserCallbacks=new RecentsSystemUser(mContext,mImpl);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    mContext.registerReceiverAsUser(mSystemUserUnlockedReceiver,UserHandle.SYSTEM,filter,null,null);
  }
 else {
    registerWithSystemUser();
  }
  putComponent(Recents.class,this);
}","@Override public void start(){
  sDebugFlags=new RecentsDebugFlags(mContext);
  sSystemServicesProxy=SystemServicesProxy.getInstance(mContext);
  sTaskLoader=new RecentsTaskLoader(mContext);
  sConfiguration=new RecentsConfiguration(mContext);
  UiModeManager uiModeManager=(UiModeManager)mContext.getSystemService(Context.UI_MODE_SERVICE);
  if (uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION) {
    mImpl=new RecentsTvImpl(mContext);
  }
 else {
    mImpl=new RecentsImpl(mContext);
  }
  if (""String_Node_Str"".equals(Build.TYPE) || ""String_Node_Str"".equals(Build.TYPE)) {
    String cnStr=SystemProperties.get(RECENTS_OVERRIDE_SYSPROP_KEY);
    if (!cnStr.isEmpty()) {
      mOverrideRecentsPackageName=cnStr;
    }
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sSystemServicesProxy,EVENT_BUS_PRIORITY);
  EventBus.getDefault().register(sTaskLoader,EVENT_BUS_PRIORITY);
  final int processUser=sSystemServicesProxy.getProcessUser();
  if (sSystemServicesProxy.isSystemUser(processUser)) {
    mSystemToUserCallbacks=new RecentsSystemUser(mContext,mImpl);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    mContext.registerReceiverAsUser(mSystemUserUnlockedReceiver,UserHandle.SYSTEM,filter,null,null);
  }
 else {
    registerWithSystemUser();
  }
  putComponent(Recents.class,this);
  long lastVisibleTaskActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,-1);
  if (lastVisibleTaskActiveTime != -1) {
    long uptime=SystemClock.elapsedRealtime();
    Settings.Secure.putLongForUser(mContext.getContentResolver(),Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,uptime - Math.max(0,System.currentTimeMillis() - lastVisibleTaskActiveTime),processUser);
    Prefs.remove(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME);
  }
}",0.8532690569448629
191050,"@Override public void dump(String prefix,FileDescriptor fd,PrintWriter writer,String[] args){
  super.dump(prefix,fd,writer,args);
  EventBus.getDefault().dump(prefix,writer);
  Recents.getTaskLoader().dump(prefix,writer);
  String id=Integer.toHexString(System.identityHashCode(this));
  long lastStackActiveTime=Prefs.getLong(this,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,-1);
  writer.print(prefix);
  writer.print(TAG);
  writer.print(""String_Node_Str"");
  writer.print(mIsVisible ? ""String_Node_Str"" : ""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(lastStackActiveTime);
  writer.print(""String_Node_Str"");
  writer.print(System.currentTimeMillis());
  writer.print(""String_Node_Str"");
  writer.print(id);
  writer.print(""String_Node_Str"");
  writer.println();
  if (mRecentsView != null) {
    mRecentsView.dump(prefix,writer);
  }
}","@Override public void dump(String prefix,FileDescriptor fd,PrintWriter writer,String[] args){
  super.dump(prefix,fd,writer,args);
  EventBus.getDefault().dump(prefix,writer);
  Recents.getTaskLoader().dump(prefix,writer);
  ContentResolver cr=getContentResolver();
  long lastPersistUptime=Settings.Secure.getLong(cr,Settings.Secure.TASK_PERSISTER_LAST_WRITE_UPTIME,0);
  long lastVisibleTaskActiveUptime=Settings.Secure.getLongForUser(cr,Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,SystemClock.elapsedRealtime(),Recents.getSystemServices().getCurrentUser());
  String id=Integer.toHexString(System.identityHashCode(this));
  writer.print(prefix);
  writer.print(TAG);
  writer.print(""String_Node_Str"");
  writer.print(mIsVisible ? ""String_Node_Str"" : ""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(lastPersistUptime);
  writer.print(""String_Node_Str"");
  writer.print(lastVisibleTaskActiveUptime);
  writer.print(""String_Node_Str"");
  writer.print(id);
  writer.print(""String_Node_Str"");
  writer.println();
  if (mRecentsView != null) {
    mRecentsView.dump(prefix,writer);
  }
}",0.6817724068479355
191051,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mFinishedOnStartup=false;
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp == null) {
    mFinishedOnStartup=true;
    finish();
    return;
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  mPackageMonitor=new RecentsPackageMonitor();
  mPackageMonitor.register(this);
  setContentView(R.layout.recents);
  takeKeyEvents(true);
  mRecentsView=(RecentsView)findViewById(R.id.recents_view);
  mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mScrimViews=new SystemBarScrimViews(this);
  getWindow().getAttributes().privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY;
  Configuration appConfiguration=Utilities.getAppConfiguration(this);
  mLastDeviceOrientation=appConfiguration.orientation;
  mLastDisplayDensity=appConfiguration.densityDpi;
  mFocusTimerDuration=getResources().getInteger(R.integer.recents_auto_advance_duration);
  mIterateTrigger=new DozeTrigger(mFocusTimerDuration,new Runnable(){
    @Override public void run(){
      dismissRecentsToFocusedTask(MetricsEvent.OVERVIEW_SELECT_TIMEOUT);
    }
  }
);
  getWindow().setBackgroundDrawable(mRecentsView.getBackgroundScrim());
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_TIME_CHANGED);
  registerReceiver(mSystemBroadcastReceiver,filter);
  getWindow().addPrivateFlags(LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION);
  reloadStackView();
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mFinishedOnStartup=false;
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp == null) {
    mFinishedOnStartup=true;
    finish();
    return;
  }
  EventBus.getDefault().register(this,EVENT_BUS_PRIORITY);
  mPackageMonitor=new RecentsPackageMonitor();
  mPackageMonitor.register(this);
  setContentView(R.layout.recents);
  takeKeyEvents(true);
  mRecentsView=(RecentsView)findViewById(R.id.recents_view);
  mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mScrimViews=new SystemBarScrimViews(this);
  getWindow().getAttributes().privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY;
  Configuration appConfiguration=Utilities.getAppConfiguration(this);
  mLastDeviceOrientation=appConfiguration.orientation;
  mLastDisplayDensity=appConfiguration.densityDpi;
  mFocusTimerDuration=getResources().getInteger(R.integer.recents_auto_advance_duration);
  mIterateTrigger=new DozeTrigger(mFocusTimerDuration,new Runnable(){
    @Override public void run(){
      dismissRecentsToFocusedTask(MetricsEvent.OVERVIEW_SELECT_TIMEOUT);
    }
  }
);
  getWindow().setBackgroundDrawable(mRecentsView.getBackgroundScrim());
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mSystemBroadcastReceiver,filter);
  getWindow().addPrivateFlags(LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION);
  reloadStackView();
}",0.9872408293460924
191052,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    dismissRecentsToHomeIfVisible(false);
  }
 else   if (action.equals(Intent.ACTION_TIME_CHANGED)) {
    Prefs.putLong(RecentsActivity.this,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_SCREEN_OFF)) {
    dismissRecentsToHomeIfVisible(false);
  }
}",0.7219152854511971
191053,"/** 
 * Returns a list of the recents tasks.
 * @param includeFrontMostExcludedTask if set, will ensure that the front most excluded taskwill be visible, otherwise no excluded tasks will be visible.
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean includeFrontMostExcludedTask,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=i;
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  int flags=ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES;
  if (includeFrontMostExcludedTask) {
    flags|=ActivityManager.RECENT_WITH_EXCLUDED;
  }
  List<ActivityManager.RecentTaskInfo> tasks=null;
  try {
    tasks=mAm.getRecentTasksForUser(numTasksToQuery,flags,userId);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    if (sRecentsBlacklist.contains(t.realActivity.getClassName()) || sRecentsBlacklist.contains(t.realActivity.getPackageName())) {
      iter.remove();
      continue;
    }
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isExcluded && (!isFirstValidTask || !includeFrontMostExcludedTask)) {
      iter.remove();
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}","/** 
 * Returns a list of the recents tasks.
 * @param includeFrontMostExcludedTask if set, will ensure that the front most excluded taskwill be visible, otherwise no excluded tasks will be visible.
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean includeFrontMostExcludedTask,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=SystemClock.elapsedRealtime();
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  int flags=ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES;
  if (includeFrontMostExcludedTask) {
    flags|=ActivityManager.RECENT_WITH_EXCLUDED;
  }
  List<ActivityManager.RecentTaskInfo> tasks=null;
  try {
    tasks=mAm.getRecentTasksForUser(numTasksToQuery,flags,userId);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    if (sRecentsBlacklist.contains(t.realActivity.getClassName()) || sRecentsBlacklist.contains(t.realActivity.getPackageName())) {
      iter.remove();
      continue;
    }
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isExcluded && (!isFirstValidTask || !includeFrontMostExcludedTask)) {
      iter.remove();
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}",0.9951519069166128
191054,"/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean includeFrontMostExcludedTask){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(includeFrontMostExcludedTask);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  long lastStackActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    lastStackActiveTime=0;
  }
  long newLastStackActiveTime=-1;
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=SystemServicesProxy.isFreeformStack(t.stackId);
    boolean isStackTask=isFreeformTask || !isHistoricalTask(t) || (t.lastActiveTime >= lastStackActiveTime && i >= (taskCount - MIN_NUM_TASKS));
    boolean isLaunchTarget=taskKey.id == runningTaskId;
    if (isStackTask && newLastStackActiveTime < 0) {
      newLastStackActiveTime=t.lastActiveTime;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (newLastStackActiveTime != -1) {
    Prefs.putLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,newLastStackActiveTime);
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}","/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean includeFrontMostExcludedTask){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(includeFrontMostExcludedTask);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  boolean updatedLastVisibleTaskActiveTime=false;
  long newLastVisibileTaskActiveTime=0;
  long currentTime=mTimeProvider.getTime();
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=mSystemServicesProxy.isFreeformStack(t.stackId);
    boolean isRecentlyUsedTask=t.lastActiveTime >= (currentTime - SESSION_BEGIN_TIME);
    boolean isMoreRecentThanLastVisible=t.lastActiveTime >= mLastVisibileTaskActiveTime;
    boolean isStackTask=isFreeformTask || (isMoreRecentThanLastVisible && (isRecentlyUsedTask || i >= (taskCount - MIN_NUM_TASKS)));
    boolean isLaunchTarget=t.persistentId == runningTaskId;
    if (isStackTask && !updatedLastVisibleTaskActiveTime) {
      newLastVisibileTaskActiveTime=t.lastActiveTime;
      updatedLastVisibleTaskActiveTime=true;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (updatedLastVisibleTaskActiveTime && newLastVisibileTaskActiveTime != mLastVisibileTaskActiveTime) {
    Settings.Secure.putLongForUser(mContext.getContentResolver(),Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,newLastVisibileTaskActiveTime,UserHandle.USER_CURRENT);
    mLastVisibileTaskActiveTime=newLastVisibileTaskActiveTime;
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}",0.3081579705967137
191055,"/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean includeFrontMostExcludedTask){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  SystemServicesProxy ssp=Recents.getSystemServices();
  mRawTasks=ssp.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,includeFrontMostExcludedTask,mCurrentQuietProfiles);
  Collections.reverse(mRawTasks);
}","/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean includeFrontMostExcludedTask){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  mRawTasks=mSystemServicesProxy.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,includeFrontMostExcludedTask,mCurrentQuietProfiles);
  mLastVisibileTaskActiveTime=RecentsDebugFlags.Static.EnableMockTasks ? SystemClock.elapsedRealtime() : Settings.Secure.getLongForUser(mContext.getContentResolver(),Settings.Secure.OVERVIEW_LAST_VISIBLE_TASK_ACTIVE_UPTIME,0,currentUserId);
  Collections.reverse(mRawTasks);
}",0.7216494845360825
191056,"/** 
 * Package level ctor 
 */
RecentsTaskLoadPlan(Context context){
  mContext=context;
}","@VisibleForTesting public RecentsTaskLoadPlan(Context context,SystemServicesProxy ssp){
  mContext=context;
  mSystemServicesProxy=ssp;
}",0.5701754385964912
191057,"/** 
 * Validate internal set of accounts against installed authenticators for given user. Clear cached authenticators before validating when requested.
 */
private void validateAccountsInternal(UserAccounts accounts,boolean invalidateAuthenticatorCache){
  if (Log.isLoggable(TAG,Log.DEBUG)) {
    Log.d(TAG,""String_Node_Str"" + accounts.userId + ""String_Node_Str""+ accounts.openHelper.isCeDatabaseAttached()+ ""String_Node_Str""+ mLocalUnlockedUsers.get(accounts.userId));
  }
  if (invalidateAuthenticatorCache) {
    mAuthenticatorCache.invalidateCache(accounts.userId);
  }
  final HashMap<String,Integer> knownAuth=getAuthenticatorTypeAndUIDForUser(mAuthenticatorCache,accounts.userId);
  boolean userUnlocked=isLocalUnlockedUser(accounts.userId);
synchronized (accounts.cacheLock) {
    final SQLiteDatabase db=accounts.openHelper.getWritableDatabase();
    boolean accountDeleted=false;
    Cursor metaCursor=db.query(TABLE_META,new String[]{META_KEY,META_VALUE},SELECTION_META_BY_AUTHENTICATOR_TYPE,new String[]{META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + ""String_Node_Str""},null,null,META_KEY);
    HashSet<String> obsoleteAuthType=Sets.newHashSet();
    try {
      SparseBooleanArray knownUids=null;
      while (metaCursor.moveToNext()) {
        String type=TextUtils.split(metaCursor.getString(0),META_KEY_DELIMITER)[1];
        String uid=metaCursor.getString(1);
        if (TextUtils.isEmpty(type) || TextUtils.isEmpty(uid)) {
          Slog.e(TAG,""String_Node_Str"" + TextUtils.isEmpty(type) + ""String_Node_Str""+ TextUtils.isEmpty(uid));
          continue;
        }
        Integer knownUid=knownAuth.get(type);
        if (knownUid != null && uid.equals(knownUid.toString())) {
          knownAuth.remove(type);
        }
 else {
          if (knownUids == null) {
            knownUids=getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);
          }
          if (!knownUids.get(Integer.parseInt(uid))) {
            obsoleteAuthType.add(type);
            db.delete(TABLE_META,META_KEY + ""String_Node_Str"" + META_VALUE+ ""String_Node_Str"",new String[]{META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + type,uid});
          }
        }
      }
    }
  finally {
      metaCursor.close();
    }
    Iterator<Entry<String,Integer>> iterator=knownAuth.entrySet().iterator();
    while (iterator.hasNext()) {
      Entry<String,Integer> entry=iterator.next();
      ContentValues values=new ContentValues();
      values.put(META_KEY,META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + entry.getKey());
      values.put(META_VALUE,entry.getValue());
      db.insertWithOnConflict(TABLE_META,null,values,SQLiteDatabase.CONFLICT_REPLACE);
    }
    Cursor cursor=db.query(TABLE_ACCOUNTS,new String[]{ACCOUNTS_ID,ACCOUNTS_TYPE,ACCOUNTS_NAME},null,null,null,null,ACCOUNTS_ID);
    try {
      accounts.accountCache.clear();
      final HashMap<String,ArrayList<String>> accountNamesByType=new LinkedHashMap<>();
      while (cursor.moveToNext()) {
        final long accountId=cursor.getLong(0);
        final String accountType=cursor.getString(1);
        final String accountName=cursor.getString(2);
        if (obsoleteAuthType.contains(accountType)) {
          Slog.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ accountType+ ""String_Node_Str"");
          db.beginTransaction();
          try {
            db.delete(TABLE_ACCOUNTS,ACCOUNTS_ID + ""String_Node_Str"" + accountId,null);
            if (userUnlocked) {
              db.delete(CE_TABLE_ACCOUNTS,ACCOUNTS_ID + ""String_Node_Str"" + accountId,null);
            }
            db.setTransactionSuccessful();
          }
  finally {
            db.endTransaction();
          }
          accountDeleted=true;
          logRecord(db,DebugDbHelper.ACTION_AUTHENTICATOR_REMOVE,TABLE_ACCOUNTS,accountId,accounts);
          final Account account=new Account(accountName,accountType);
          accounts.userDataCache.remove(account);
          accounts.authTokenCache.remove(account);
          accounts.accountTokenCaches.remove(account);
        }
 else {
          ArrayList<String> accountNames=accountNamesByType.get(accountType);
          if (accountNames == null) {
            accountNames=new ArrayList<String>();
            accountNamesByType.put(accountType,accountNames);
          }
          accountNames.add(accountName);
        }
      }
      for (      Map.Entry<String,ArrayList<String>> cur : accountNamesByType.entrySet()) {
        final String accountType=cur.getKey();
        final ArrayList<String> accountNames=cur.getValue();
        final Account[] accountsForType=new Account[accountNames.size()];
        for (int i=0; i < accountsForType.length; i++) {
          accountsForType[i]=new Account(accountNames.get(i),accountType);
        }
        accounts.accountCache.put(accountType,accountsForType);
      }
    }
  finally {
      cursor.close();
      if (accountDeleted) {
        sendAccountsChangedBroadcast(accounts.userId);
      }
    }
  }
}","/** 
 * Validate internal set of accounts against installed authenticators for given user. Clear cached authenticators before validating when requested.
 */
private void validateAccountsInternal(UserAccounts accounts,boolean invalidateAuthenticatorCache){
  if (Log.isLoggable(TAG,Log.DEBUG)) {
    Log.d(TAG,""String_Node_Str"" + accounts.userId + ""String_Node_Str""+ accounts.openHelper.isCeDatabaseAttached()+ ""String_Node_Str""+ mLocalUnlockedUsers.get(accounts.userId));
  }
  if (SystemProperties.getBoolean(""String_Node_Str"",false)) {
    return;
  }
  if (invalidateAuthenticatorCache) {
    mAuthenticatorCache.invalidateCache(accounts.userId);
  }
  final HashMap<String,Integer> knownAuth=getAuthenticatorTypeAndUIDForUser(mAuthenticatorCache,accounts.userId);
  boolean userUnlocked=isLocalUnlockedUser(accounts.userId);
synchronized (accounts.cacheLock) {
    final SQLiteDatabase db=accounts.openHelper.getWritableDatabase();
    boolean accountDeleted=false;
    Cursor metaCursor=db.query(TABLE_META,new String[]{META_KEY,META_VALUE},SELECTION_META_BY_AUTHENTICATOR_TYPE,new String[]{META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + ""String_Node_Str""},null,null,META_KEY);
    HashSet<String> obsoleteAuthType=Sets.newHashSet();
    try {
      SparseBooleanArray knownUids=null;
      while (metaCursor.moveToNext()) {
        String type=TextUtils.split(metaCursor.getString(0),META_KEY_DELIMITER)[1];
        String uid=metaCursor.getString(1);
        if (TextUtils.isEmpty(type) || TextUtils.isEmpty(uid)) {
          Slog.e(TAG,""String_Node_Str"" + TextUtils.isEmpty(type) + ""String_Node_Str""+ TextUtils.isEmpty(uid));
          continue;
        }
        Integer knownUid=knownAuth.get(type);
        if (knownUid != null && uid.equals(knownUid.toString())) {
          knownAuth.remove(type);
        }
 else {
          if (knownUids == null) {
            knownUids=getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);
          }
          if (!knownUids.get(Integer.parseInt(uid))) {
            obsoleteAuthType.add(type);
            db.delete(TABLE_META,META_KEY + ""String_Node_Str"" + META_VALUE+ ""String_Node_Str"",new String[]{META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + type,uid});
          }
        }
      }
    }
  finally {
      metaCursor.close();
    }
    Iterator<Entry<String,Integer>> iterator=knownAuth.entrySet().iterator();
    while (iterator.hasNext()) {
      Entry<String,Integer> entry=iterator.next();
      ContentValues values=new ContentValues();
      values.put(META_KEY,META_KEY_FOR_AUTHENTICATOR_UID_FOR_TYPE_PREFIX + entry.getKey());
      values.put(META_VALUE,entry.getValue());
      db.insertWithOnConflict(TABLE_META,null,values,SQLiteDatabase.CONFLICT_REPLACE);
    }
    Cursor cursor=db.query(TABLE_ACCOUNTS,new String[]{ACCOUNTS_ID,ACCOUNTS_TYPE,ACCOUNTS_NAME},null,null,null,null,ACCOUNTS_ID);
    try {
      accounts.accountCache.clear();
      final HashMap<String,ArrayList<String>> accountNamesByType=new LinkedHashMap<>();
      while (cursor.moveToNext()) {
        final long accountId=cursor.getLong(0);
        final String accountType=cursor.getString(1);
        final String accountName=cursor.getString(2);
        if (obsoleteAuthType.contains(accountType)) {
          Slog.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ accountType+ ""String_Node_Str"");
          db.beginTransaction();
          try {
            db.delete(TABLE_ACCOUNTS,ACCOUNTS_ID + ""String_Node_Str"" + accountId,null);
            if (userUnlocked) {
              db.delete(CE_TABLE_ACCOUNTS,ACCOUNTS_ID + ""String_Node_Str"" + accountId,null);
            }
            db.setTransactionSuccessful();
          }
  finally {
            db.endTransaction();
          }
          accountDeleted=true;
          logRecord(db,DebugDbHelper.ACTION_AUTHENTICATOR_REMOVE,TABLE_ACCOUNTS,accountId,accounts);
          final Account account=new Account(accountName,accountType);
          accounts.userDataCache.remove(account);
          accounts.authTokenCache.remove(account);
          accounts.accountTokenCaches.remove(account);
        }
 else {
          ArrayList<String> accountNames=accountNamesByType.get(accountType);
          if (accountNames == null) {
            accountNames=new ArrayList<String>();
            accountNamesByType.put(accountType,accountNames);
          }
          accountNames.add(accountName);
        }
      }
      for (      Map.Entry<String,ArrayList<String>> cur : accountNamesByType.entrySet()) {
        final String accountType=cur.getKey();
        final ArrayList<String> accountNames=cur.getValue();
        final Account[] accountsForType=new Account[accountNames.size()];
        for (int i=0; i < accountsForType.length; i++) {
          accountsForType[i]=new Account(accountNames.get(i),accountType);
        }
        accounts.accountCache.put(accountType,accountsForType);
      }
    }
  finally {
      cursor.close();
      if (accountDeleted) {
        sendAccountsChangedBroadcast(accounts.userId);
      }
    }
  }
}",0.9922264301375324
191058,"/** 
 * Called when the set of account has changed, given the new array of active accounts.
 */
public void doDatabaseCleanup(Account[] accounts,int userId){
synchronized (mAuthorities) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Slog.v(TAG,""String_Node_Str"");
    }
    SparseArray<AuthorityInfo> removing=new SparseArray<AuthorityInfo>();
    Iterator<AccountInfo> accIt=mAccounts.values().iterator();
    while (accIt.hasNext()) {
      AccountInfo acc=accIt.next();
      if (!ArrayUtils.contains(accounts,acc.accountAndUser.account) && acc.accountAndUser.userId == userId) {
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          Slog.v(TAG,""String_Node_Str"" + acc.accountAndUser);
        }
        for (        AuthorityInfo auth : acc.authorities.values()) {
          removing.put(auth.ident,auth);
        }
        accIt.remove();
      }
    }
    int i=removing.size();
    if (i > 0) {
      while (i > 0) {
        i--;
        int ident=removing.keyAt(i);
        AuthorityInfo auth=removing.valueAt(i);
        if (mAuthorityRemovedListener != null) {
          mAuthorityRemovedListener.onAuthorityRemoved(auth.target);
        }
        mAuthorities.remove(ident);
        int j=mSyncStatus.size();
        while (j > 0) {
          j--;
          if (mSyncStatus.keyAt(j) == ident) {
            mSyncStatus.remove(mSyncStatus.keyAt(j));
          }
        }
        j=mSyncHistory.size();
        while (j > 0) {
          j--;
          if (mSyncHistory.get(j).authorityId == ident) {
            mSyncHistory.remove(j);
          }
        }
      }
      writeAccountInfoLocked();
      writeStatusLocked();
      writeStatisticsLocked();
    }
  }
}","/** 
 * Called when the set of account has changed, given the new array of active accounts.
 */
public void doDatabaseCleanup(Account[] accounts,int userId){
  if (SystemProperties.getBoolean(""String_Node_Str"",false)) {
    return;
  }
synchronized (mAuthorities) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Slog.v(TAG,""String_Node_Str"");
    }
    SparseArray<AuthorityInfo> removing=new SparseArray<AuthorityInfo>();
    Iterator<AccountInfo> accIt=mAccounts.values().iterator();
    while (accIt.hasNext()) {
      AccountInfo acc=accIt.next();
      if (!ArrayUtils.contains(accounts,acc.accountAndUser.account) && acc.accountAndUser.userId == userId) {
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          Slog.v(TAG,""String_Node_Str"" + acc.accountAndUser);
        }
        for (        AuthorityInfo auth : acc.authorities.values()) {
          removing.put(auth.ident,auth);
        }
        accIt.remove();
      }
    }
    int i=removing.size();
    if (i > 0) {
      while (i > 0) {
        i--;
        int ident=removing.keyAt(i);
        AuthorityInfo auth=removing.valueAt(i);
        if (mAuthorityRemovedListener != null) {
          mAuthorityRemovedListener.onAuthorityRemoved(auth.target);
        }
        mAuthorities.remove(ident);
        int j=mSyncStatus.size();
        while (j > 0) {
          j--;
          if (mSyncStatus.keyAt(j) == ident) {
            mSyncStatus.remove(mSyncStatus.keyAt(j));
          }
        }
        j=mSyncHistory.size();
        while (j > 0) {
          j--;
          if (mSyncHistory.get(j).authorityId == ident) {
            mSyncHistory.remove(j);
          }
        }
      }
      writeAccountInfoLocked();
      writeStatusLocked();
      writeStatisticsLocked();
    }
  }
}",0.9773650609402206
191059,"/** 
 * Updates the current state based on mServiceState, mSignalStrength, mDataNetType, mDataState, and mSimState.  It should be called any time one of these is updated. This will call listeners if necessary.
 */
private final void updateTelephony(){
  if (DEBUG) {
    Log.d(mTag,""String_Node_Str"" + hasService() + ""String_Node_Str""+ mSignalStrength);
  }
  mCurrentState.connected=hasService() && mSignalStrength != null;
  if (mCurrentState.connected) {
    if (!mSignalStrength.isGsm() && mConfig.alwaysShowCdmaRssi) {
      mCurrentState.level=mSignalStrength.getCdmaLevel();
    }
 else {
      mCurrentState.level=mSignalStrength.getLevel();
      if (mConfig.showRsrpSignalLevelforLTE) {
        int dataType=mServiceState.getDataNetworkType();
        if (dataType == TelephonyManager.NETWORK_TYPE_LTE || dataType == TelephonyManager.NETWORK_TYPE_LTE_CA) {
          mCurrentState.level=getAlternateLteLevel(mSignalStrength);
        }
      }
    }
  }
  if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
    mCurrentState.iconGroup=mNetworkToIconLookup.get(mDataNetType);
  }
 else {
    mCurrentState.iconGroup=mDefaultIcons;
  }
  mCurrentState.dataConnected=mCurrentState.connected && mDataState == TelephonyManager.DATA_CONNECTED;
  if (isCarrierNetworkChangeActive()) {
    mCurrentState.iconGroup=TelephonyIcons.CARRIER_NETWORK_CHANGE;
  }
 else   if (isRoaming()) {
    mCurrentState.iconGroup=TelephonyIcons.ROAMING;
  }
 else   if (isDataDisabled()) {
    mCurrentState.iconGroup=TelephonyIcons.DATA_DISABLED;
  }
  if (isEmergencyOnly() != mCurrentState.isEmergency) {
    mCurrentState.isEmergency=isEmergencyOnly();
    mNetworkController.recalculateEmergency();
  }
  if (mCurrentState.networkName == mNetworkNameDefault && mServiceState != null && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
    mCurrentState.networkName=mServiceState.getOperatorAlphaShort();
  }
  if (!showLongOperatorName()) {
    mCurrentState.networkNameData=TextUtils.isEmpty(mServiceState.getOperatorAlphaShort()) ? mCurrentState.networkNameData : mServiceState.getOperatorAlphaShort() + ""String_Node_Str"" + getNetworkClassString(mServiceState);
  }
  if (mConfig.readIconsFromXml) {
    mCurrentState.voiceLevel=getVoiceSignalLevel();
  }
  if (mStyle == STATUS_BAR_STYLE_EXTENDED) {
    mCurrentState.imsRadioTechnology=getImsRadioTechnology();
  }
  notifyListenersIfNecessary();
}","/** 
 * Updates the current state based on mServiceState, mSignalStrength, mDataNetType, mDataState, and mSimState.  It should be called any time one of these is updated. This will call listeners if necessary.
 */
private final void updateTelephony(){
  if (DEBUG) {
    Log.d(mTag,""String_Node_Str"" + hasService() + ""String_Node_Str""+ mSignalStrength);
  }
  mCurrentState.connected=hasService() && mSignalStrength != null;
  if (mCurrentState.connected) {
    if (!mSignalStrength.isGsm() && mConfig.alwaysShowCdmaRssi) {
      mCurrentState.level=mSignalStrength.getCdmaLevel();
    }
 else {
      mCurrentState.level=mSignalStrength.getLevel();
      if (mConfig.showRsrpSignalLevelforLTE) {
        int dataType=mServiceState.getDataNetworkType();
        if (dataType == TelephonyManager.NETWORK_TYPE_LTE || dataType == TelephonyManager.NETWORK_TYPE_LTE_CA) {
          mCurrentState.level=getAlternateLteLevel(mSignalStrength);
        }
      }
    }
  }
  if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
    mCurrentState.iconGroup=mNetworkToIconLookup.get(mDataNetType);
  }
 else {
    mCurrentState.iconGroup=mDefaultIcons;
  }
  mCurrentState.dataConnected=mCurrentState.connected && mDataState == TelephonyManager.DATA_CONNECTED;
  if (isCarrierNetworkChangeActive()) {
    mCurrentState.iconGroup=TelephonyIcons.CARRIER_NETWORK_CHANGE;
  }
 else   if (isRoaming()) {
    mCurrentState.iconGroup=TelephonyIcons.ROAMING;
  }
 else   if (isDataDisabled()) {
    mCurrentState.iconGroup=TelephonyIcons.DATA_DISABLED;
  }
  if (isEmergencyOnly() != mCurrentState.isEmergency) {
    mCurrentState.isEmergency=isEmergencyOnly();
    mNetworkController.recalculateEmergency();
  }
  if (mCurrentState.networkName == mNetworkNameDefault && mServiceState != null && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
    mCurrentState.networkName=mServiceState.getOperatorAlphaShort();
  }
  if (!showLongOperatorName() && mServiceState != null && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
    mCurrentState.networkNameData=mServiceState.getOperatorAlphaShort() + ""String_Node_Str"" + getNetworkClassString(mServiceState);
  }
  if (mConfig.readIconsFromXml) {
    mCurrentState.voiceLevel=getVoiceSignalLevel();
  }
  if (mStyle == STATUS_BAR_STYLE_EXTENDED) {
    mCurrentState.imsRadioTechnology=getImsRadioTechnology();
  }
  notifyListenersIfNecessary();
}",0.963239875389408
191060,"/** 
 * Returns stack's visibility:   {@link #STACK_INVISIBLE},   {@link #STACK_VISIBLE} or{@link #STACK_VISIBLE_ACTIVITY_BEHIND}.
 * @param starting The currently starting activity or null if there is none.
 */
int getStackVisibilityLocked(ActivityRecord starting){
  if (!isAttached()) {
    return STACK_INVISIBLE;
  }
  if (mStackSupervisor.isFrontStack(this) || mStackSupervisor.isFocusedStack(this)) {
    return STACK_VISIBLE;
  }
  final int stackIndex=mStacks.indexOf(this);
  if (stackIndex == mStacks.size() - 1) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
    return STACK_INVISIBLE;
  }
  final boolean isLockscreenShown=mService.mLockScreenShown == LOCK_SCREEN_SHOWN;
  if (isLockscreenShown && !StackId.isAllowedOverLockscreen(mStackId)) {
    return STACK_INVISIBLE;
  }
  final ActivityStack focusedStack=mStackSupervisor.getFocusedStack();
  final int focusedStackId=focusedStack.mStackId;
  if (mStackId == FULLSCREEN_WORKSPACE_STACK_ID && hasVisibleBehindActivity() && focusedStackId == HOME_STACK_ID && !focusedStack.topActivity().fullscreen) {
    return STACK_VISIBLE_ACTIVITY_BEHIND;
  }
  if (mStackId == DOCKED_STACK_ID) {
    final ActivityRecord r=focusedStack.topRunningActivityLocked();
    final TaskRecord task=r != null ? r.task : null;
    return task == null || task.canGoInDockedStack() || task.isHomeTask() ? STACK_VISIBLE : STACK_INVISIBLE;
  }
  int stackBehindFocusedIndex=mStacks.indexOf(focusedStack) - 1;
  while (stackBehindFocusedIndex >= 0 && mStacks.get(stackBehindFocusedIndex).topRunningActivityLocked() == null) {
    stackBehindFocusedIndex--;
  }
  if ((focusedStackId == DOCKED_STACK_ID || focusedStackId == PINNED_STACK_ID) && stackIndex == stackBehindFocusedIndex) {
    return STACK_VISIBLE;
  }
  final int stackBehindFocusedId=(stackBehindFocusedIndex >= 0) ? mStacks.get(stackBehindFocusedIndex).mStackId : INVALID_STACK_ID;
  if (focusedStackId == FULLSCREEN_WORKSPACE_STACK_ID && focusedStack.isStackTranslucent(starting,stackBehindFocusedId)) {
    if (stackIndex == stackBehindFocusedIndex) {
      return STACK_VISIBLE;
    }
    if (stackBehindFocusedIndex >= 0) {
      if ((stackBehindFocusedId == DOCKED_STACK_ID || stackBehindFocusedId == PINNED_STACK_ID) && stackIndex == (stackBehindFocusedIndex - 1)) {
        return STACK_VISIBLE;
      }
    }
  }
  if (StackId.isStaticStack(mStackId)) {
    return STACK_INVISIBLE;
  }
  for (int i=stackIndex + 1; i < mStacks.size(); i++) {
    final ActivityStack stack=mStacks.get(i);
    if (!stack.mFullscreen && !stack.hasFullscreenTask()) {
      continue;
    }
    if (!StackId.isDynamicStacksVisibleBehindAllowed(stack.mStackId)) {
      return STACK_INVISIBLE;
    }
    if (!stack.isStackTranslucent(starting,INVALID_STACK_ID)) {
      return STACK_INVISIBLE;
    }
  }
  return STACK_VISIBLE;
}","/** 
 * Returns stack's visibility:   {@link #STACK_INVISIBLE},   {@link #STACK_VISIBLE} or{@link #STACK_VISIBLE_ACTIVITY_BEHIND}.
 * @param starting The currently starting activity or null if there is none.
 */
int getStackVisibilityLocked(ActivityRecord starting){
  if (!isAttached()) {
    return STACK_INVISIBLE;
  }
  if (mStackSupervisor.isFrontStack(this) || mStackSupervisor.isFocusedStack(this)) {
    return STACK_VISIBLE;
  }
  final int stackIndex=mStacks.indexOf(this);
  if (stackIndex == mStacks.size() - 1) {
    Slog.wtf(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
    return STACK_INVISIBLE;
  }
  final ActivityStack focusedStack=mStackSupervisor.getFocusedStack();
  final int focusedStackId=focusedStack.mStackId;
  if (mStackId == FULLSCREEN_WORKSPACE_STACK_ID && hasVisibleBehindActivity() && focusedStackId == HOME_STACK_ID && !focusedStack.topActivity().fullscreen) {
    return STACK_VISIBLE_ACTIVITY_BEHIND;
  }
  if (mStackId == DOCKED_STACK_ID) {
    final ActivityRecord r=focusedStack.topRunningActivityLocked();
    final TaskRecord task=r != null ? r.task : null;
    return task == null || task.canGoInDockedStack() || task.isHomeTask() ? STACK_VISIBLE : STACK_INVISIBLE;
  }
  int stackBehindFocusedIndex=mStacks.indexOf(focusedStack) - 1;
  while (stackBehindFocusedIndex >= 0 && mStacks.get(stackBehindFocusedIndex).topRunningActivityLocked() == null) {
    stackBehindFocusedIndex--;
  }
  if ((focusedStackId == DOCKED_STACK_ID || focusedStackId == PINNED_STACK_ID) && stackIndex == stackBehindFocusedIndex) {
    return STACK_VISIBLE;
  }
  final int stackBehindFocusedId=(stackBehindFocusedIndex >= 0) ? mStacks.get(stackBehindFocusedIndex).mStackId : INVALID_STACK_ID;
  if (focusedStackId == FULLSCREEN_WORKSPACE_STACK_ID && focusedStack.isStackTranslucent(starting,stackBehindFocusedId)) {
    if (stackIndex == stackBehindFocusedIndex) {
      return STACK_VISIBLE;
    }
    if (stackBehindFocusedIndex >= 0) {
      if ((stackBehindFocusedId == DOCKED_STACK_ID || stackBehindFocusedId == PINNED_STACK_ID) && stackIndex == (stackBehindFocusedIndex - 1)) {
        return STACK_VISIBLE;
      }
    }
  }
  if (StackId.isStaticStack(mStackId)) {
    return STACK_INVISIBLE;
  }
  for (int i=stackIndex + 1; i < mStacks.size(); i++) {
    final ActivityStack stack=mStacks.get(i);
    if (!stack.mFullscreen && !stack.hasFullscreenTask()) {
      continue;
    }
    if (!StackId.isDynamicStacksVisibleBehindAllowed(stack.mStackId)) {
      return STACK_INVISIBLE;
    }
    if (!stack.isStackTranslucent(starting,INVALID_STACK_ID)) {
      return STACK_INVISIBLE;
    }
  }
  return STACK_VISIBLE;
}",0.9659442724458204
191061,"void goodToGo(AppWindowAnimator topOpeningAppAnimator,AppWindowAnimator topClosingAppAnimator,ArraySet<AppWindowToken> openingApps,ArraySet<AppWindowToken> closingApps){
  mNextAppTransition=TRANSIT_UNSET;
  mAppTransitionState=APP_STATE_RUNNING;
  notifyAppTransitionStartingLocked(topOpeningAppAnimator != null ? topOpeningAppAnimator.mAppToken.token : null,topClosingAppAnimator != null ? topClosingAppAnimator.mAppToken.token : null,topOpeningAppAnimator != null ? topOpeningAppAnimator.animation : null,topClosingAppAnimator != null ? topClosingAppAnimator.animation : null);
  mService.getDefaultDisplayContentLocked().getDockedDividerController().notifyAppTransitionStarting();
  if (mNextAppTransition == TRANSIT_DOCK_TASK_FROM_RECENTS && !mProlongedAnimationsEnded) {
    for (int i=openingApps.size() - 1; i >= 0; i--) {
      final AppWindowAnimator appAnimator=openingApps.valueAt(i).mAppAnimator;
      appAnimator.startProlongAnimation(PROLONG_ANIMATION_AT_START);
    }
  }
}","void goodToGo(AppWindowAnimator topOpeningAppAnimator,AppWindowAnimator topClosingAppAnimator,ArraySet<AppWindowToken> openingApps,ArraySet<AppWindowToken> closingApps){
  mNextAppTransition=TRANSIT_UNSET;
  mAppTransitionState=APP_STATE_RUNNING;
  notifyAppTransitionStartingLocked(topOpeningAppAnimator != null ? topOpeningAppAnimator.mAppToken.token : null,topClosingAppAnimator != null ? topClosingAppAnimator.mAppToken.token : null,topOpeningAppAnimator != null ? topOpeningAppAnimator.animation : null,topClosingAppAnimator != null ? topClosingAppAnimator.animation : null);
  mService.getDefaultDisplayContentLocked().getDockedDividerController().notifyAppTransitionStarting(openingApps);
  if (mNextAppTransition == TRANSIT_DOCK_TASK_FROM_RECENTS && !mProlongedAnimationsEnded) {
    for (int i=openingApps.size() - 1; i >= 0; i--) {
      final AppWindowAnimator appAnimator=openingApps.valueAt(i).mAppAnimator;
      appAnimator.startProlongAnimation(PROLONG_ANIMATION_AT_START);
    }
  }
}",0.994475138121547
191062,"void notifyAppTransitionStarting(){
  checkMinimizeChanged(true);
}","void notifyAppTransitionStarting(ArraySet<AppWindowToken> openingApps){
  final boolean wasMinimized=mMinimizedDock;
  checkMinimizeChanged(true);
  if (wasMinimized && mMinimizedDock && containsAppInDockedStack(openingApps)) {
    mService.showRecentApps(true);
  }
}",0.4
191063,"/** 
 * Initialize or update the local profile objects. If a UUID was previously present but has been removed, we print a warning but don't remove the profile object as it might be referenced elsewhere, or the UUID might come back and we don't want multiple copies of the profile objects.
 * @param uuids
 */
void updateLocalProfiles(ParcelUuid[] uuids){
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.AudioSource)) {
    if (mA2dpProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mA2dpProfile=new A2dpProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mA2dpProfile,A2dpProfile.NAME,BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mA2dpProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.AudioSink)) {
    if (mA2dpSinkProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mA2dpSinkProfile=new A2dpSinkProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mA2dpSinkProfile,A2dpSinkProfile.NAME,BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mA2dpSinkProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.Handsfree_AG) || BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.HSP_AG)) {
    if (mHeadsetProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mHeadsetProfile=new HeadsetProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mHeadsetProfile,HeadsetProfile.NAME,BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mHeadsetProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.Handsfree)) {
    if (mHfpClientProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mHfpClientProfile=new HfpClientProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mHfpClientProfile,HfpClientProfile.NAME,BluetoothHeadsetClient.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mHfpClientProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.ObexObjectPush)) {
    if (mOppProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mOppProfile=new OppProfile();
      mProfileNameMap.put(OppProfile.NAME,mOppProfile);
    }
  }
 else   if (mOppProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (mUsePbapPce) {
    if (mPbapClientProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mPbapClientProfile=new PbapClientProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mPbapClientProfile,PbapClientProfile.NAME,BluetoothPbapClient.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mPbapClientProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  mEventManager.registerProfileIntentReceiver();
}","/** 
 * Initialize or update the local profile objects. If a UUID was previously present but has been removed, we print a warning but don't remove the profile object as it might be referenced elsewhere, or the UUID might come back and we don't want multiple copies of the profile objects.
 * @param uuids
 */
void updateLocalProfiles(ParcelUuid[] uuids){
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.AudioSource)) {
    if (mA2dpProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mA2dpProfile=new A2dpProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mA2dpProfile,A2dpProfile.NAME,BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mA2dpProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.AudioSink)) {
    if (mA2dpSinkProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mA2dpSinkProfile=new A2dpSinkProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mA2dpSinkProfile,A2dpSinkProfile.NAME,BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mA2dpSinkProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.Handsfree_AG) || BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.HSP_AG)) {
    if (mHeadsetProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mHeadsetProfile=new HeadsetProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mHeadsetProfile,HeadsetProfile.NAME,BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mHeadsetProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.Handsfree)) {
    if (mHfpClientProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mHfpClientProfile=new HfpClientProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mHfpClientProfile,HfpClientProfile.NAME,BluetoothHeadsetClient.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mHfpClientProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  if (BluetoothUuid.isUuidPresent(uuids,BluetoothUuid.ObexObjectPush)) {
    if (mOppProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mOppProfile=new OppProfile();
      mProfileNameMap.put(OppProfile.NAME,mOppProfile);
    }
  }
 else   if (mOppProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  if (mUsePbapPce) {
    if (mPbapClientProfile == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mPbapClientProfile=new PbapClientProfile(mContext,mLocalAdapter,mDeviceManager,this);
      addProfile(mPbapClientProfile,PbapClientProfile.NAME,BluetoothPbapClient.ACTION_CONNECTION_STATE_CHANGED);
    }
  }
 else   if (mPbapClientProfile != null) {
    Log.w(TAG,""String_Node_Str"");
  }
  mEventManager.setDefaultReceiverHandler();
}",0.993975903614458
191064,"/** 
 * Updates the current state based on mServiceState, mSignalStrength, mDataNetType, mDataState, and mSimState.  It should be called any time one of these is updated. This will call listeners if necessary.
 */
private final void updateTelephony(){
  if (DEBUG) {
    Log.d(mTag,""String_Node_Str"" + hasService() + ""String_Node_Str""+ mSignalStrength);
  }
  mCurrentState.connected=hasService() && mSignalStrength != null;
  if (mCurrentState.connected) {
    if (!mSignalStrength.isGsm() && mConfig.alwaysShowCdmaRssi) {
      mCurrentState.level=mSignalStrength.getCdmaLevel();
    }
 else {
      mCurrentState.level=mSignalStrength.getLevel();
      if (mConfig.showRsrpSignalLevelforLTE) {
        int dataType=mServiceState.getDataNetworkType();
        if (dataType == TelephonyManager.NETWORK_TYPE_LTE || dataType == TelephonyManager.NETWORK_TYPE_LTE_CA) {
          mCurrentState.level=getAlternateLteLevel(mSignalStrength);
        }
      }
    }
  }
  if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
    mCurrentState.iconGroup=mNetworkToIconLookup.get(mDataNetType);
  }
 else {
    mCurrentState.iconGroup=mDefaultIcons;
  }
  mCurrentState.dataConnected=mCurrentState.connected && mDataState == TelephonyManager.DATA_CONNECTED;
  if (isCarrierNetworkChangeActive()) {
    mCurrentState.iconGroup=TelephonyIcons.CARRIER_NETWORK_CHANGE;
  }
 else   if (isRoaming()) {
    mCurrentState.iconGroup=TelephonyIcons.ROAMING;
  }
 else   if (isDataDisabled()) {
    mCurrentState.iconGroup=TelephonyIcons.DATA_DISABLED;
  }
  if (isEmergencyOnly() != mCurrentState.isEmergency) {
    mCurrentState.isEmergency=isEmergencyOnly();
    mNetworkController.recalculateEmergency();
  }
  if (mCurrentState.networkName == mNetworkNameDefault && mServiceState != null && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
    mCurrentState.networkName=mServiceState.getOperatorAlphaShort();
  }
  if (!showLongOperatorName()) {
    mCurrentState.networkNameData=TextUtils.isEmpty(mServiceState.getOperatorAlphaShort()) ? mCurrentState.networkNameData : mServiceState.getOperatorAlphaShort() + ""String_Node_Str"" + getNetworkClassString(mServiceState);
  }
  if (mConfig.readIconsFromXml) {
    mCurrentState.voiceLevel=getVoiceSignalLevel();
  }
  if (mStyle == STATUS_BAR_STYLE_EXTENDED) {
    mCurrentState.imsRadioTechnology=getImsRadioTechnology();
  }
  notifyListenersIfNecessary();
}","/** 
 * Updates the current state based on mServiceState, mSignalStrength, mDataNetType, mDataState, and mSimState.  It should be called any time one of these is updated. This will call listeners if necessary.
 */
private final void updateTelephony(){
  if (DEBUG) {
    Log.d(mTag,""String_Node_Str"" + hasService() + ""String_Node_Str""+ mSignalStrength);
  }
  mCurrentState.connected=hasService() && mSignalStrength != null;
  if (mCurrentState.connected) {
    if (!mSignalStrength.isGsm() && mConfig.alwaysShowCdmaRssi) {
      mCurrentState.level=mSignalStrength.getCdmaLevel();
    }
 else {
      mCurrentState.level=mSignalStrength.getLevel();
      if (mConfig.showRsrpSignalLevelforLTE) {
        int dataType=mServiceState.getDataNetworkType();
        if (dataType == TelephonyManager.NETWORK_TYPE_LTE || dataType == TelephonyManager.NETWORK_TYPE_LTE_CA) {
          mCurrentState.level=getAlternateLteLevel(mSignalStrength);
        }
      }
    }
  }
  if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
    mCurrentState.iconGroup=mNetworkToIconLookup.get(mDataNetType);
  }
 else {
    mCurrentState.iconGroup=mDefaultIcons;
  }
  mCurrentState.dataConnected=mCurrentState.connected && mDataState == TelephonyManager.DATA_CONNECTED;
  if (isCarrierNetworkChangeActive()) {
    mCurrentState.iconGroup=TelephonyIcons.CARRIER_NETWORK_CHANGE;
  }
 else   if (isRoaming()) {
    mCurrentState.iconGroup=TelephonyIcons.ROAMING;
  }
 else   if (isDataDisabled()) {
    mCurrentState.iconGroup=TelephonyIcons.DATA_DISABLED;
  }
  if (isEmergencyOnly() != mCurrentState.isEmergency) {
    mCurrentState.isEmergency=isEmergencyOnly();
    mNetworkController.recalculateEmergency();
  }
  if (mCurrentState.networkName == mNetworkNameDefault && mServiceState != null && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
    mCurrentState.networkName=mServiceState.getOperatorAlphaShort();
  }
  if (!showLongOperatorName() && mServiceState != null && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
    mCurrentState.networkNameData=mServiceState.getOperatorAlphaShort() + ""String_Node_Str"" + getNetworkClassString(mServiceState);
  }
  if (mConfig.readIconsFromXml) {
    mCurrentState.voiceLevel=getVoiceSignalLevel();
  }
  if (mStyle == STATUS_BAR_STYLE_EXTENDED) {
    mCurrentState.imsRadioTechnology=getImsRadioTechnology();
  }
  notifyListenersIfNecessary();
}",0.963239875389408
191065,"protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
    final String pkg=sbn.getPackageName();
    String appname=pkg;
    try {
      final ApplicationInfo info=pmUser.getApplicationInfo(pkg,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      if (info != null) {
        appname=String.valueOf(pmUser.getApplicationLabel(info));
      }
    }
 catch (    NameNotFoundException e) {
    }
    row.setAppName(appname);
  }
  workAroundBadLayerDrawableOpacity(row);
  View vetoButton=bindVetoButtonClickListener(row,sbn);
  vetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}","protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
    final String pkg=sbn.getPackageName();
    String appname=pkg;
    try {
      final ApplicationInfo info=pmUser.getApplicationInfo(pkg,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      if (info != null) {
        appname=String.valueOf(pmUser.getApplicationLabel(info));
      }
    }
 catch (    NameNotFoundException e) {
    }
    row.setAppName(appname);
  }
  workAroundBadLayerDrawableOpacity(row);
  bindDismissListener(row);
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}",0.984725050916497
191066,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
    mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  bindVetoButtonClickListener(entry.row,notification);
  if (!notification.isClearable()) {
    mStackScroller.snapViewIfNeeded(entry.row);
  }
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
    mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  if (!notification.isClearable()) {
    mStackScroller.snapViewIfNeeded(entry.row);
  }
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.989093793376958
191067,"public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  updateClearability();
  if (mIsSummaryWithChildren) {
    mChildrenContainer.recreateNotificationHeader(mExpandClickListener,mEntry.notification);
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  if (mIsSummaryWithChildren) {
    mChildrenContainer.recreateNotificationHeader(mExpandClickListener,mEntry.notification);
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}",0.9835841313269492
191068,"private boolean canViewBeDismissed(){
  return isClearable() && (!mShowingPublic || !mSensitiveHiddenInGeneral);
}","/** 
 * @return Whether this view is allowed to be dismissed. Only valid for visible notifications asotherwise some state might not be updated. To request about the general clearability see  {@link #isClearable()}.
 */
public boolean canViewBeDismissed(){
  return isClearable() && (!mShowingPublic || !mSensitiveHiddenInGeneral);
}",0.484304932735426
191069,"/** 
 * @return Can the underlying notification be cleared?
 */
public boolean isClearable(){
  return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}","/** 
 * @return Can the underlying notification be cleared? This can be different from whether thenotification can be dismissed in case notifications are sensitive on the lockscreen.
 * @see #canViewBeDismissed()
 */
public boolean isClearable(){
  return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}",0.697029702970297
191070,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mPublicLayout=(NotificationContentView)findViewById(R.id.expandedPublic);
  mPublicLayout.setContainingNotification(this);
  mPrivateLayout=(NotificationContentView)findViewById(R.id.expanded);
  mPrivateLayout.setExpandClickListener(mExpandClickListener);
  mPrivateLayout.setContainingNotification(this);
  mPublicLayout.setExpandClickListener(mExpandClickListener);
  mSettingsIconRowStub=(ViewStub)findViewById(R.id.settings_icon_row_stub);
  mSettingsIconRowStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mSettingsIconRow=(NotificationSettingsIconRow)inflated;
      mSettingsIconRow.setNotificationRowParent(ExpandableNotificationRow.this);
      mSettingsIconRow.setAppName(mAppName);
    }
  }
);
  mGutsStub=(ViewStub)findViewById(R.id.notification_guts_stub);
  mGutsStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mGuts=(NotificationGuts)inflated;
      mGuts.setClipTopAmount(getClipTopAmount());
      mGuts.setActualHeight(getActualHeight());
      mGutsStub=null;
    }
  }
);
  mChildrenContainerStub=(ViewStub)findViewById(R.id.child_container_stub);
  mChildrenContainerStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mChildrenContainer=(NotificationChildrenContainer)inflated;
      mChildrenContainer.setNotificationParent(ExpandableNotificationRow.this);
      mChildrenContainer.onNotificationUpdated();
      mTranslateableViews.add(mChildrenContainer);
    }
  }
);
  mVetoButton=findViewById(R.id.veto);
  mTranslateableViews=new ArrayList<View>();
  for (int i=0; i < getChildCount(); i++) {
    mTranslateableViews.add(getChildAt(i));
  }
  mTranslateableViews.remove(mVetoButton);
  mTranslateableViews.remove(mSettingsIconRowStub);
  mTranslateableViews.remove(mChildrenContainerStub);
  mTranslateableViews.remove(mGutsStub);
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mPublicLayout=(NotificationContentView)findViewById(R.id.expandedPublic);
  mPublicLayout.setContainingNotification(this);
  mPrivateLayout=(NotificationContentView)findViewById(R.id.expanded);
  mPrivateLayout.setExpandClickListener(mExpandClickListener);
  mPrivateLayout.setContainingNotification(this);
  mPublicLayout.setExpandClickListener(mExpandClickListener);
  mSettingsIconRowStub=(ViewStub)findViewById(R.id.settings_icon_row_stub);
  mSettingsIconRowStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mSettingsIconRow=(NotificationSettingsIconRow)inflated;
      mSettingsIconRow.setNotificationRowParent(ExpandableNotificationRow.this);
      mSettingsIconRow.setAppName(mAppName);
    }
  }
);
  mGutsStub=(ViewStub)findViewById(R.id.notification_guts_stub);
  mGutsStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mGuts=(NotificationGuts)inflated;
      mGuts.setClipTopAmount(getClipTopAmount());
      mGuts.setActualHeight(getActualHeight());
      mGutsStub=null;
    }
  }
);
  mChildrenContainerStub=(ViewStub)findViewById(R.id.child_container_stub);
  mChildrenContainerStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mChildrenContainer=(NotificationChildrenContainer)inflated;
      mChildrenContainer.setNotificationParent(ExpandableNotificationRow.this);
      mChildrenContainer.onNotificationUpdated();
      mTranslateableViews.add(mChildrenContainer);
    }
  }
);
  mVetoButton=findViewById(R.id.veto);
  mVetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  mVetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  mTranslateableViews=new ArrayList<View>();
  for (int i=0; i < getChildCount(); i++) {
    mTranslateableViews.add(getChildAt(i));
  }
  mTranslateableViews.remove(mVetoButton);
  mTranslateableViews.remove(mSettingsIconRowStub);
  mTranslateableViews.remove(mChildrenContainerStub);
  mTranslateableViews.remove(mGutsStub);
}",0.9585987261146496
191071,"public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    if (mChildrenContainer != null) {
      mChildrenContainer.animate().cancel();
      mChildrenContainer.setAlpha(1f);
    }
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateClearability();
  mShowingPublicInitialized=true;
}","public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    if (mChildrenContainer != null) {
      mChildrenContainer.animate().cancel();
      mChildrenContainer.setAlpha(1f);
    }
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  mShowingPublicInitialized=true;
}",0.9879396984924624
191072,"public static void performDismiss(View v,NotificationGroupManager groupManager,boolean fromAccessibility){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (groupManager.isOnlyChildInGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=groupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary,groupManager,fromAccessibility);
      }
    }
    row.setDismissed(true,fromAccessibility);
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}","public static void performDismiss(View v,NotificationGroupManager groupManager,boolean fromAccessibility){
  if (!(v instanceof ExpandableNotificationRow)) {
    return;
  }
  ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  if (groupManager.isOnlyChildInGroup(row.getStatusBarNotification())) {
    ExpandableNotificationRow groupSummary=groupManager.getLogicalGroupSummary(row.getStatusBarNotification());
    if (groupSummary.isClearable()) {
      performDismiss(groupSummary,groupManager,fromAccessibility);
    }
  }
  row.setDismissed(true,fromAccessibility);
  if (row.isClearable()) {
    row.performDismiss();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}",0.8697450034458993
191073,"public static boolean canChildBeDismissed(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (row.areGutsExposed()) {
      return false;
    }
  }
  final View veto=v.findViewById(R.id.veto);
  return (veto != null && veto.getVisibility() != View.GONE);
}","public static boolean canChildBeDismissed(View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    return false;
  }
  ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  if (row.areGutsExposed()) {
    return false;
  }
  return row.canViewBeDismissed();
}",0.6721581548599671
191074,"@Override public void interfaceStatusChanged(String iface,boolean up){
  if (VDBG)   Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str""+ up);
  boolean found=false;
  boolean usb=false;
  WifiManager mWifiManager=(WifiManager)mContext.getSystemService(Context.WIFI_SERVICE);
synchronized (mPublicSync) {
    if (isWifi(iface)) {
      found=true;
    }
 else     if (isUsb(iface)) {
      found=true;
      usb=true;
    }
 else     if (isBluetooth(iface)) {
      found=true;
    }
    if (found == false)     return;
    TetherInterfaceSM sm=mIfaces.get(iface);
    if (up) {
      if (sm == null) {
        sm=new TetherInterfaceSM(iface,mLooper,usb);
        mIfaces.put(iface,sm);
        sm.start();
      }
    }
 else {
      if (isUsb(iface)) {
        if (VDBG)         Log.d(TAG,""String_Node_Str"" + iface);
      }
 else       if (isWifi(iface) && (mWifiManager != null) && mWifiManager.getWifiStaSapConcurrency()) {
        int wifiApState=0;
        wifiApState=mWifiManager.getWifiApState();
        if ((wifiApState == WifiManager.WIFI_AP_STATE_DISABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_DISABLED)) {
          if (VDBG)           Log.d(TAG,""String_Node_Str"" + iface);
          sm.sendMessage(TetherInterfaceSM.CMD_INTERFACE_DOWN);
          mIfaces.remove(iface);
        }
 else {
          if (VDBG)           Log.d(TAG,""String_Node_Str"" + iface);
        }
      }
 else       if (sm != null) {
        sm.sendMessage(TetherInterfaceSM.CMD_INTERFACE_DOWN);
        mIfaces.remove(iface);
      }
    }
  }
}","@Override public void interfaceStatusChanged(String iface,boolean up){
  if (VDBG)   Log.d(TAG,""String_Node_Str"" + iface + ""String_Node_Str""+ up);
  boolean found=false;
  boolean usb=false;
  WifiManager mWifiManager=(WifiManager)mContext.getSystemService(Context.WIFI_SERVICE);
synchronized (mPublicSync) {
    if (isWifi(iface)) {
      found=true;
    }
 else     if (isUsb(iface)) {
      found=true;
      usb=true;
    }
 else     if (isBluetooth(iface)) {
      found=true;
    }
    if (found == false)     return;
    TetherInterfaceSM sm=mIfaces.get(iface);
    if (up) {
      if (sm == null) {
        sm=new TetherInterfaceSM(iface,mLooper,usb);
        mIfaces.put(iface,sm);
        sm.start();
      }
    }
 else {
      if (isUsb(iface) || isBluetooth(iface) || isWifi(iface)) {
        if (VDBG)         Log.d(TAG,""String_Node_Str"" + iface);
      }
 else       if (sm != null) {
        sm.sendMessage(TetherInterfaceSM.CMD_INTERFACE_DOWN);
        mIfaces.remove(iface);
      }
    }
  }
}",0.7594837700430191
191075,"private void generateHeadsUpAnimationEvents(){
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    int type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_OTHER;
    boolean onBottom=false;
    boolean pinnedAndClosed=row.isPinned() && !mIsExpanded;
    if (!mIsExpanded && !isHeadsUp) {
      type=row.wasJustClicked() ? AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR_CLICK : AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR;
    }
 else {
      StackViewState viewState=mCurrentStackScrollState.getViewStateForView(row);
      if (viewState == null) {
        continue;
      }
      if (isHeadsUp && (mAddedHeadsUpChildren.contains(row) || pinnedAndClosed)) {
        if (pinnedAndClosed || shouldHunAppearFromBottom(viewState)) {
          type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_APPEAR;
        }
 else {
          type=AnimationEvent.ANIMATION_TYPE_ADD;
        }
        onBottom=!pinnedAndClosed;
      }
    }
    AnimationEvent event=new AnimationEvent(row,type);
    event.headsUpFromBottom=onBottom;
    mAnimationEvents.add(event);
  }
  mHeadsUpChangeAnimations.clear();
  mAddedHeadsUpChildren.clear();
}","private void generateHeadsUpAnimationEvents(){
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    int type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_OTHER;
    boolean onBottom=false;
    boolean pinnedAndClosed=row.isPinned() && !mIsExpanded;
    if (!mIsExpanded && !isHeadsUp) {
      type=row.wasJustClicked() ? AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR_CLICK : AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR;
      if (row.isChildInGroup()) {
        row.setHeadsupDisappearRunning(false);
      }
    }
 else {
      StackViewState viewState=mCurrentStackScrollState.getViewStateForView(row);
      if (viewState == null) {
        continue;
      }
      if (isHeadsUp && (mAddedHeadsUpChildren.contains(row) || pinnedAndClosed)) {
        if (pinnedAndClosed || shouldHunAppearFromBottom(viewState)) {
          type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_APPEAR;
        }
 else {
          type=AnimationEvent.ANIMATION_TYPE_ADD;
        }
        onBottom=!pinnedAndClosed;
      }
    }
    AnimationEvent event=new AnimationEvent(row,type);
    event.headsUpFromBottom=onBottom;
    mAnimationEvents.add(event);
  }
  mHeadsUpChangeAnimations.clear();
  mAddedHeadsUpChildren.clear();
}",0.9655972168534984
191076,"/** 
 * Remove a removed child view from the heads up animations if it was just added there
 * @return whether any child was removed from the list to animate
 */
private boolean removeRemovedChildFromHeadsUpChangeAnimations(View child){
  boolean hasAddEvent=false;
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    if (child == row) {
      mTmpList.add(eventPair);
      hasAddEvent|=isHeadsUp;
    }
  }
  if (hasAddEvent) {
    mHeadsUpChangeAnimations.removeAll(mTmpList);
  }
  mTmpList.clear();
  return hasAddEvent;
}","/** 
 * Remove a removed child view from the heads up animations if it was just added there
 * @return whether any child was removed from the list to animate
 */
private boolean removeRemovedChildFromHeadsUpChangeAnimations(View child){
  boolean hasAddEvent=false;
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    if (child == row) {
      mTmpList.add(eventPair);
      hasAddEvent|=isHeadsUp;
    }
  }
  if (hasAddEvent) {
    mHeadsUpChangeAnimations.removeAll(mTmpList);
    ((ExpandableNotificationRow)child).setHeadsupDisappearRunning(false);
  }
  mTmpList.clear();
  return hasAddEvent;
}",0.9468390804597702
191077,"public void onChildAnimationFinished(){
  setAnimationRunning(false);
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
  clearViewOverlays();
}","public void onChildAnimationFinished(){
  setAnimationRunning(false);
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
  clearViewOverlays();
  clearHeadsUpDisappearRunning();
}",0.9017341040462428
191078,"protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
    final String pkg=sbn.getPackageName();
    String appname=pkg;
    try {
      final ApplicationInfo info=pmUser.getApplicationInfo(pkg,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      if (info != null) {
        appname=String.valueOf(pmUser.getApplicationLabel(info));
      }
    }
 catch (    NameNotFoundException e) {
    }
    row.setAppName(appname);
  }
  workAroundBadLayerDrawableOpacity(row);
  View vetoButton=bindVetoButtonClickListener(row,sbn);
  vetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}","protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
    final String pkg=sbn.getPackageName();
    String appname=pkg;
    try {
      final ApplicationInfo info=pmUser.getApplicationInfo(pkg,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      if (info != null) {
        appname=String.valueOf(pmUser.getApplicationLabel(info));
      }
    }
 catch (    NameNotFoundException e) {
    }
    row.setAppName(appname);
  }
  workAroundBadLayerDrawableOpacity(row);
  bindDismissListener(row);
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}",0.984725050916497
191079,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
    mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  bindVetoButtonClickListener(entry.row,notification);
  if (!notification.isClearable()) {
    mStackScroller.snapViewIfNeeded(entry.row);
  }
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
    mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  if (!notification.isClearable()) {
    mStackScroller.snapViewIfNeeded(entry.row);
  }
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.989093793376958
191080,"public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  updateClearability();
  if (mIsSummaryWithChildren) {
    mChildrenContainer.recreateNotificationHeader(mExpandClickListener,mEntry.notification);
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  if (mIsSummaryWithChildren) {
    mChildrenContainer.recreateNotificationHeader(mExpandClickListener,mEntry.notification);
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}",0.9835841313269492
191081,"private boolean canViewBeDismissed(){
  return isClearable() && (!mShowingPublic || !mSensitiveHiddenInGeneral);
}","/** 
 * @return Whether this view is allowed to be dismissed. Only valid for visible notifications asotherwise some state might not be updated. To request about the general clearability see  {@link #isClearable()}.
 */
public boolean canViewBeDismissed(){
  return isClearable() && (!mShowingPublic || !mSensitiveHiddenInGeneral);
}",0.484304932735426
191082,"/** 
 * @return Can the underlying notification be cleared?
 */
public boolean isClearable(){
  return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}","/** 
 * @return Can the underlying notification be cleared? This can be different from whether thenotification can be dismissed in case notifications are sensitive on the lockscreen.
 * @see #canViewBeDismissed()
 */
public boolean isClearable(){
  return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}",0.697029702970297
191083,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mPublicLayout=(NotificationContentView)findViewById(R.id.expandedPublic);
  mPublicLayout.setContainingNotification(this);
  mPrivateLayout=(NotificationContentView)findViewById(R.id.expanded);
  mPrivateLayout.setExpandClickListener(mExpandClickListener);
  mPrivateLayout.setContainingNotification(this);
  mPublicLayout.setExpandClickListener(mExpandClickListener);
  mSettingsIconRowStub=(ViewStub)findViewById(R.id.settings_icon_row_stub);
  mSettingsIconRowStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mSettingsIconRow=(NotificationSettingsIconRow)inflated;
      mSettingsIconRow.setNotificationRowParent(ExpandableNotificationRow.this);
      mSettingsIconRow.setAppName(mAppName);
    }
  }
);
  mGutsStub=(ViewStub)findViewById(R.id.notification_guts_stub);
  mGutsStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mGuts=(NotificationGuts)inflated;
      mGuts.setClipTopAmount(getClipTopAmount());
      mGuts.setActualHeight(getActualHeight());
      mGutsStub=null;
    }
  }
);
  mChildrenContainerStub=(ViewStub)findViewById(R.id.child_container_stub);
  mChildrenContainerStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mChildrenContainer=(NotificationChildrenContainer)inflated;
      mChildrenContainer.setNotificationParent(ExpandableNotificationRow.this);
      mChildrenContainer.onNotificationUpdated();
      mTranslateableViews.add(mChildrenContainer);
    }
  }
);
  mVetoButton=findViewById(R.id.veto);
  mTranslateableViews=new ArrayList<View>();
  for (int i=0; i < getChildCount(); i++) {
    mTranslateableViews.add(getChildAt(i));
  }
  mTranslateableViews.remove(mVetoButton);
  mTranslateableViews.remove(mSettingsIconRowStub);
  mTranslateableViews.remove(mChildrenContainerStub);
  mTranslateableViews.remove(mGutsStub);
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mPublicLayout=(NotificationContentView)findViewById(R.id.expandedPublic);
  mPublicLayout.setContainingNotification(this);
  mPrivateLayout=(NotificationContentView)findViewById(R.id.expanded);
  mPrivateLayout.setExpandClickListener(mExpandClickListener);
  mPrivateLayout.setContainingNotification(this);
  mPublicLayout.setExpandClickListener(mExpandClickListener);
  mSettingsIconRowStub=(ViewStub)findViewById(R.id.settings_icon_row_stub);
  mSettingsIconRowStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mSettingsIconRow=(NotificationSettingsIconRow)inflated;
      mSettingsIconRow.setNotificationRowParent(ExpandableNotificationRow.this);
      mSettingsIconRow.setAppName(mAppName);
    }
  }
);
  mGutsStub=(ViewStub)findViewById(R.id.notification_guts_stub);
  mGutsStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mGuts=(NotificationGuts)inflated;
      mGuts.setClipTopAmount(getClipTopAmount());
      mGuts.setActualHeight(getActualHeight());
      mGutsStub=null;
    }
  }
);
  mChildrenContainerStub=(ViewStub)findViewById(R.id.child_container_stub);
  mChildrenContainerStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mChildrenContainer=(NotificationChildrenContainer)inflated;
      mChildrenContainer.setNotificationParent(ExpandableNotificationRow.this);
      mChildrenContainer.onNotificationUpdated();
      mTranslateableViews.add(mChildrenContainer);
    }
  }
);
  mVetoButton=findViewById(R.id.veto);
  mVetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  mVetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  mTranslateableViews=new ArrayList<View>();
  for (int i=0; i < getChildCount(); i++) {
    mTranslateableViews.add(getChildAt(i));
  }
  mTranslateableViews.remove(mVetoButton);
  mTranslateableViews.remove(mSettingsIconRowStub);
  mTranslateableViews.remove(mChildrenContainerStub);
  mTranslateableViews.remove(mGutsStub);
}",0.9585987261146496
191084,"public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    if (mChildrenContainer != null) {
      mChildrenContainer.animate().cancel();
      mChildrenContainer.setAlpha(1f);
    }
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateClearability();
  mShowingPublicInitialized=true;
}","public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    if (mChildrenContainer != null) {
      mChildrenContainer.animate().cancel();
      mChildrenContainer.setAlpha(1f);
    }
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  mShowingPublicInitialized=true;
}",0.9879396984924624
191085,"public static void performDismiss(View v,NotificationGroupManager groupManager,boolean fromAccessibility){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (groupManager.isOnlyChildInGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=groupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary,groupManager,fromAccessibility);
      }
    }
    row.setDismissed(true,fromAccessibility);
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}","public static void performDismiss(View v,NotificationGroupManager groupManager,boolean fromAccessibility){
  if (!(v instanceof ExpandableNotificationRow)) {
    return;
  }
  ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  if (groupManager.isOnlyChildInGroup(row.getStatusBarNotification())) {
    ExpandableNotificationRow groupSummary=groupManager.getLogicalGroupSummary(row.getStatusBarNotification());
    if (groupSummary.isClearable()) {
      performDismiss(groupSummary,groupManager,fromAccessibility);
    }
  }
  row.setDismissed(true,fromAccessibility);
  if (row.isClearable()) {
    row.performDismiss();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}",0.8697450034458993
191086,"public static boolean canChildBeDismissed(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (row.areGutsExposed()) {
      return false;
    }
  }
  final View veto=v.findViewById(R.id.veto);
  return (veto != null && veto.getVisibility() != View.GONE);
}","public static boolean canChildBeDismissed(View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    return false;
  }
  ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  if (row.areGutsExposed()) {
    return false;
  }
  return row.canViewBeDismissed();
}",0.6721581548599671
191087,"@Override public void onHeadsUpPinnedModeChanged(boolean inPinnedMode){
  if (inPinnedMode) {
    mStatusBarWindowManager.setHeadsUpShowing(true);
    mStatusBarWindowManager.setForceStatusBarVisible(true);
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.requestLayout();
      mStatusBarWindowManager.setForceWindowCollapsed(true);
      mNotificationPanel.post(new Runnable(){
        @Override public void run(){
          mStatusBarWindowManager.setForceWindowCollapsed(false);
        }
      }
);
    }
  }
 else {
    if (!mNotificationPanel.isFullyCollapsed() || mNotificationPanel.isTracking()) {
      mStatusBarWindowManager.setHeadsUpShowing(false);
    }
 else {
      mHeadsUpManager.setHeadsUpGoingAway(true);
      mStackScroller.runAfterAnimationFinished(new Runnable(){
        @Override public void run(){
          if (!mHeadsUpManager.hasPinnedHeadsUp()) {
            mStatusBarWindowManager.setHeadsUpShowing(false);
            mHeadsUpManager.setHeadsUpGoingAway(false);
          }
        }
      }
);
    }
  }
}","@Override public void onHeadsUpPinnedModeChanged(boolean inPinnedMode){
  if (inPinnedMode) {
    mStatusBarWindowManager.setHeadsUpShowing(true);
    mStatusBarWindowManager.setForceStatusBarVisible(true);
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.requestLayout();
      mStatusBarWindowManager.setForceWindowCollapsed(true);
      mNotificationPanel.post(new Runnable(){
        @Override public void run(){
          mStatusBarWindowManager.setForceWindowCollapsed(false);
        }
      }
);
    }
  }
 else {
    if (!mNotificationPanel.isFullyCollapsed() || mNotificationPanel.isTracking()) {
      mStatusBarWindowManager.setHeadsUpShowing(false);
    }
 else {
      mHeadsUpManager.setHeadsUpGoingAway(true);
      mStackScroller.runAfterAnimationFinished(new Runnable(){
        @Override public void run(){
          if (!mHeadsUpManager.hasPinnedHeadsUp()) {
            mStatusBarWindowManager.setHeadsUpShowing(false);
            mHeadsUpManager.setHeadsUpGoingAway(false);
          }
          removeRemoteInputEntriesKeptUntilCollapsed();
        }
      }
);
    }
  }
}",0.9744058500914076
191088,"@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  Entry entry=mNotificationData.get(key);
  if (entry != null && mRemoteInputController.isRemoteInputActive(entry)) {
    mLatestRankingMap=ranking;
    mRemoteInputEntriesToRemoveOnCollapse.add(entry);
    return;
  }
  if (entry != null && entry.row != null) {
    entry.row.setRemoved();
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED && !isCollapsing()) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}","@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  Entry entry=mNotificationData.get(key);
  if (entry != null && mRemoteInputController.isRemoteInputActive(entry) && (entry.row != null && !entry.row.isDismissed())) {
    mLatestRankingMap=ranking;
    mRemoteInputEntriesToRemoveOnCollapse.add(entry);
    return;
  }
  if (entry != null && entry.row != null) {
    entry.row.setRemoved();
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED && !isCollapsing()) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}",0.9910132158590308
191089,"public boolean isActive(){
  return mEditText.isFocused();
}","public boolean isActive(){
  return mEditText.isFocused() && mEditText.isEnabled();
}",0.8275862068965517
191090,"@Override public void onHeadsUpPinnedModeChanged(boolean inPinnedMode){
  if (inPinnedMode) {
    mStatusBarWindowManager.setHeadsUpShowing(true);
    mStatusBarWindowManager.setForceStatusBarVisible(true);
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.requestLayout();
      mStatusBarWindowManager.setForceWindowCollapsed(true);
      mNotificationPanel.post(new Runnable(){
        @Override public void run(){
          mStatusBarWindowManager.setForceWindowCollapsed(false);
        }
      }
);
    }
  }
 else {
    if (!mNotificationPanel.isFullyCollapsed() || mNotificationPanel.isTracking()) {
      mStatusBarWindowManager.setHeadsUpShowing(false);
    }
 else {
      mHeadsUpManager.setHeadsUpGoingAway(true);
      mStackScroller.runAfterAnimationFinished(new Runnable(){
        @Override public void run(){
          if (!mHeadsUpManager.hasPinnedHeadsUp()) {
            mStatusBarWindowManager.setHeadsUpShowing(false);
            mHeadsUpManager.setHeadsUpGoingAway(false);
          }
        }
      }
);
    }
  }
}","@Override public void onHeadsUpPinnedModeChanged(boolean inPinnedMode){
  if (inPinnedMode) {
    mStatusBarWindowManager.setHeadsUpShowing(true);
    mStatusBarWindowManager.setForceStatusBarVisible(true);
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.requestLayout();
      mStatusBarWindowManager.setForceWindowCollapsed(true);
      mNotificationPanel.post(new Runnable(){
        @Override public void run(){
          mStatusBarWindowManager.setForceWindowCollapsed(false);
        }
      }
);
    }
  }
 else {
    if (!mNotificationPanel.isFullyCollapsed() || mNotificationPanel.isTracking()) {
      mStatusBarWindowManager.setHeadsUpShowing(false);
    }
 else {
      mHeadsUpManager.setHeadsUpGoingAway(true);
      mStackScroller.runAfterAnimationFinished(new Runnable(){
        @Override public void run(){
          if (!mHeadsUpManager.hasPinnedHeadsUp()) {
            mStatusBarWindowManager.setHeadsUpShowing(false);
            mHeadsUpManager.setHeadsUpGoingAway(false);
          }
          removeRemoteInputEntriesKeptUntilCollapsed();
        }
      }
);
    }
  }
}",0.9744058500914076
191091,"@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  Entry entry=mNotificationData.get(key);
  if (entry != null && mRemoteInputController.isRemoteInputActive(entry)) {
    mLatestRankingMap=ranking;
    mRemoteInputEntriesToRemoveOnCollapse.add(entry);
    return;
  }
  if (entry != null && entry.row != null) {
    entry.row.setRemoved();
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED && !isCollapsing()) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}","@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  Entry entry=mNotificationData.get(key);
  if (entry != null && mRemoteInputController.isRemoteInputActive(entry) && (entry.row != null && !entry.row.isDismissed())) {
    mLatestRankingMap=ranking;
    mRemoteInputEntriesToRemoveOnCollapse.add(entry);
    return;
  }
  if (entry != null && entry.row != null) {
    entry.row.setRemoved();
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED && !isCollapsing()) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}",0.9910132158590308
191092,"public boolean isActive(){
  return mEditText.isFocused();
}","public boolean isActive(){
  return mEditText.isFocused() && mEditText.isEnabled();
}",0.8275862068965517
191093,"@Override public void onHeadsUpPinnedModeChanged(boolean inPinnedMode){
  if (inPinnedMode) {
    mStatusBarWindowManager.setHeadsUpShowing(true);
    mStatusBarWindowManager.setForceStatusBarVisible(true);
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.requestLayout();
      mStatusBarWindowManager.setForceWindowCollapsed(true);
      mNotificationPanel.post(new Runnable(){
        @Override public void run(){
          mStatusBarWindowManager.setForceWindowCollapsed(false);
        }
      }
);
    }
  }
 else {
    if (!mNotificationPanel.isFullyCollapsed() || mNotificationPanel.isTracking()) {
      mStatusBarWindowManager.setHeadsUpShowing(false);
    }
 else {
      mHeadsUpManager.setHeadsUpGoingAway(true);
      mStackScroller.runAfterAnimationFinished(new Runnable(){
        @Override public void run(){
          if (!mHeadsUpManager.hasPinnedHeadsUp()) {
            mStatusBarWindowManager.setHeadsUpShowing(false);
            mHeadsUpManager.setHeadsUpGoingAway(false);
          }
        }
      }
);
    }
  }
}","@Override public void onHeadsUpPinnedModeChanged(boolean inPinnedMode){
  if (inPinnedMode) {
    mStatusBarWindowManager.setHeadsUpShowing(true);
    mStatusBarWindowManager.setForceStatusBarVisible(true);
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.requestLayout();
      mStatusBarWindowManager.setForceWindowCollapsed(true);
      mNotificationPanel.post(new Runnable(){
        @Override public void run(){
          mStatusBarWindowManager.setForceWindowCollapsed(false);
        }
      }
);
    }
  }
 else {
    if (!mNotificationPanel.isFullyCollapsed() || mNotificationPanel.isTracking()) {
      mStatusBarWindowManager.setHeadsUpShowing(false);
    }
 else {
      mHeadsUpManager.setHeadsUpGoingAway(true);
      mStackScroller.runAfterAnimationFinished(new Runnable(){
        @Override public void run(){
          if (!mHeadsUpManager.hasPinnedHeadsUp()) {
            mStatusBarWindowManager.setHeadsUpShowing(false);
            mHeadsUpManager.setHeadsUpGoingAway(false);
          }
          removeRemoteInputEntriesKeptUntilCollapsed();
        }
      }
);
    }
  }
}",0.9744058500914076
191094,"@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  Entry entry=mNotificationData.get(key);
  if (entry != null && mRemoteInputController.isRemoteInputActive(entry)) {
    mLatestRankingMap=ranking;
    mRemoteInputEntriesToRemoveOnCollapse.add(entry);
    return;
  }
  if (entry != null && entry.row != null) {
    entry.row.setRemoved();
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}","@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  Entry entry=mNotificationData.get(key);
  if (entry != null && mRemoteInputController.isRemoteInputActive(entry) && (entry.row != null && !entry.row.isDismissed())) {
    mLatestRankingMap=ranking;
    mRemoteInputEntriesToRemoveOnCollapse.add(entry);
    return;
  }
  if (entry != null && entry.row != null) {
    entry.row.setRemoved();
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}",0.9909526343799894
191095,"public boolean isActive(){
  return mEditText.isFocused();
}","public boolean isActive(){
  return mEditText.isFocused() && mEditText.isEnabled();
}",0.8275862068965517
191096,"@Override public void onHeadsUpPinnedModeChanged(boolean inPinnedMode){
  if (inPinnedMode) {
    mStatusBarWindowManager.setHeadsUpShowing(true);
    mStatusBarWindowManager.setForceStatusBarVisible(true);
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.requestLayout();
      mStatusBarWindowManager.setForceWindowCollapsed(true);
      mNotificationPanel.post(new Runnable(){
        @Override public void run(){
          mStatusBarWindowManager.setForceWindowCollapsed(false);
        }
      }
);
    }
  }
 else {
    if (!mNotificationPanel.isFullyCollapsed() || mNotificationPanel.isTracking()) {
      mStatusBarWindowManager.setHeadsUpShowing(false);
    }
 else {
      mHeadsUpManager.setHeadsUpGoingAway(true);
      mStackScroller.runAfterAnimationFinished(new Runnable(){
        @Override public void run(){
          if (!mHeadsUpManager.hasPinnedHeadsUp()) {
            mStatusBarWindowManager.setHeadsUpShowing(false);
            mHeadsUpManager.setHeadsUpGoingAway(false);
          }
        }
      }
);
    }
  }
}","@Override public void onHeadsUpPinnedModeChanged(boolean inPinnedMode){
  if (inPinnedMode) {
    mStatusBarWindowManager.setHeadsUpShowing(true);
    mStatusBarWindowManager.setForceStatusBarVisible(true);
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.requestLayout();
      mStatusBarWindowManager.setForceWindowCollapsed(true);
      mNotificationPanel.post(new Runnable(){
        @Override public void run(){
          mStatusBarWindowManager.setForceWindowCollapsed(false);
        }
      }
);
    }
  }
 else {
    if (!mNotificationPanel.isFullyCollapsed() || mNotificationPanel.isTracking()) {
      mStatusBarWindowManager.setHeadsUpShowing(false);
    }
 else {
      mHeadsUpManager.setHeadsUpGoingAway(true);
      mStackScroller.runAfterAnimationFinished(new Runnable(){
        @Override public void run(){
          if (!mHeadsUpManager.hasPinnedHeadsUp()) {
            mStatusBarWindowManager.setHeadsUpShowing(false);
            mHeadsUpManager.setHeadsUpGoingAway(false);
          }
          removeRemoteInputEntriesKeptUntilCollapsed();
        }
      }
);
    }
  }
}",0.9744058500914076
191097,"@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  Entry entry=mNotificationData.get(key);
  if (entry != null && mRemoteInputController.isRemoteInputActive(entry)) {
    mLatestRankingMap=ranking;
    mRemoteInputEntriesToRemoveOnCollapse.add(entry);
    return;
  }
  if (entry != null && entry.row != null) {
    entry.row.setRemoved();
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED && !isCollapsing()) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}","@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  Entry entry=mNotificationData.get(key);
  if (entry != null && mRemoteInputController.isRemoteInputActive(entry) && (entry.row != null && !entry.row.isDismissed())) {
    mLatestRankingMap=ranking;
    mRemoteInputEntriesToRemoveOnCollapse.add(entry);
    return;
  }
  if (entry != null && entry.row != null) {
    entry.row.setRemoved();
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED && !isCollapsing()) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}",0.9910132158590308
191098,"public boolean isActive(){
  return mEditText.isFocused();
}","public boolean isActive(){
  return mEditText.isFocused() && mEditText.isEnabled();
}",0.8275862068965517
191099,"public int getSlotIndex(String slot){
  final int N=mSlots.size();
  for (int i=0; i < N; i++) {
    if (slot.equals(mSlots.get(i))) {
      return i;
    }
  }
  mSlots.add(0,slot);
  mIcons.add(0,null);
  return 0;
}","public int getSlotIndex(String slot){
  final int N=mSlots.size();
  for (int i=0; i < N; i++) {
    if (slot.equals(mSlots.get(i))) {
      return i;
    }
  }
  mSlots.add(slot);
  mIcons.add(null);
  return N;
}",0.9120370370370372
191100,"protected List<String> loadTileSpecs(Context context,String tileList){
  final Resources res=context.getResources();
  final String defaultTileList=res.getString(R.string.quick_settings_tiles_default);
  if (tileList == null) {
    tileList=res.getString(R.string.quick_settings_tiles);
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + tileList);
  }
 else {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + tileList);
  }
  final ArrayList<String> tiles=new ArrayList<String>();
  boolean addedDefault=false;
  for (  String tile : tileList.split(""String_Node_Str"")) {
    tile=tile.trim();
    if (tile.isEmpty())     continue;
    if (tile.equals(""String_Node_Str"")) {
      if (!addedDefault) {
        tiles.addAll(Arrays.asList(defaultTileList.split(""String_Node_Str"")));
        addedDefault=true;
      }
    }
 else {
      tiles.add(tile);
    }
  }
  return tiles;
}","protected List<String> loadTileSpecs(Context context,String tileList){
  final Resources res=context.getResources();
  final String defaultTileList=res.getString(R.string.quick_settings_tiles_default);
  if (tileList == null) {
    tileList=res.getString(R.string.quick_settings_tiles);
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + tileList);
  }
 else {
    for (    String tile : res.getString(R.string.quick_settings_tiles).split(""String_Node_Str"")) {
      tile=tile.trim();
      if (tile.isEmpty())       continue;
      if (tile.startsWith(IntentTile.PREFIX)) {
        tileList=tileList.concat(""String_Node_Str"").concat(tile);
      }
    }
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + tileList);
  }
  final ArrayList<String> tiles=new ArrayList<String>();
  boolean addedDefault=false;
  for (  String tile : tileList.split(""String_Node_Str"")) {
    tile=tile.trim();
    if (tile.isEmpty())     continue;
    if (tile.equals(""String_Node_Str"")) {
      if (!addedDefault) {
        tiles.addAll(Arrays.asList(defaultTileList.split(""String_Node_Str"")));
        addedDefault=true;
      }
    }
 else {
      tiles.add(tile);
    }
  }
  return tiles;
}",0.8564453125
191101,"/** 
 * Starts a miscellaneous grab bag of stuff that has yet to be refactored and organized.
 */
private void startOtherServices(){
  final Context context=mSystemContext;
  VibratorService vibrator=null;
  IMountService mountService=null;
  NetworkManagementService networkManagement=null;
  NetworkStatsService networkStats=null;
  NetworkPolicyManagerService networkPolicy=null;
  ConnectivityService connectivity=null;
  NetworkScoreService networkScore=null;
  NsdService serviceDiscovery=null;
  WindowManagerService wm=null;
  SerialService serial=null;
  NetworkTimeUpdateService networkTimeUpdater=null;
  CommonTimeManagementService commonTimeMgmtService=null;
  InputManagerService inputManager=null;
  TelephonyRegistry telephonyRegistry=null;
  ConsumerIrService consumerIr=null;
  MmsServiceBroker mmsService=null;
  HardwarePropertiesManagerService hardwarePropertiesService=null;
  Object wigigP2pService=null;
  Object wigigService=null;
  boolean disableStorage=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableBluetooth=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableLocation=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableSystemUI=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableNonCoreServices=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableNetwork=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableNetworkTime=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableRtt=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableMediaProjection=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableSerial=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableSearchManager=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableTrustManager=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableTextServices=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableSamplingProfiler=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean isEmulator=SystemProperties.get(""String_Node_Str"").equals(""String_Node_Str"");
  boolean enableWigig=SystemProperties.getBoolean(""String_Node_Str"",false);
  try {
    Slog.i(TAG,""String_Node_Str"");
    SystemConfig.getInstance();
    traceBeginAndSlog(""String_Node_Str"");
    ServiceManager.addService(""String_Node_Str"",new SchedulingPolicyService());
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    mSystemServiceManager.startService(TelecomLoaderService.class);
    traceBeginAndSlog(""String_Node_Str"");
    telephonyRegistry=new TelephonyRegistry(context);
    ServiceManager.addService(""String_Node_Str"",telephonyRegistry);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mEntropyMixer=new EntropyMixer(context);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    mContentResolver=context.getContentResolver();
    Slog.i(TAG,""String_Node_Str"");
    mSystemServiceManager.startService(CameraService.class);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mActivityManagerService.installSystemProviders();
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    vibrator=new VibratorService(context);
    ServiceManager.addService(""String_Node_Str"",vibrator);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    consumerIr=new ConsumerIrService(context);
    ServiceManager.addService(Context.CONSUMER_IR_SERVICE,consumerIr);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(AlarmManagerService.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    final Watchdog watchdog=Watchdog.getInstance();
    watchdog.init(context,mActivityManagerService);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    inputManager=new InputManagerService(context);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    wm=WindowManagerService.main(context,inputManager,mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,!mFirstBoot,mOnlyCore);
    ServiceManager.addService(Context.WINDOW_SERVICE,wm);
    ServiceManager.addService(Context.INPUT_SERVICE,inputManager);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(VrManagerService.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    mActivityManagerService.setWindowManager(wm);
    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
    inputManager.start();
    mDisplayManagerService.windowManagerAndInputReady();
    if (isEmulator) {
      Slog.i(TAG,""String_Node_Str"");
    }
 else     if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      Slog.i(TAG,""String_Node_Str"");
    }
 else     if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
      Slog.i(TAG,""String_Node_Str"");
    }
 else     if (disableBluetooth) {
      Slog.i(TAG,""String_Node_Str"");
    }
 else {
      mSystemServiceManager.startService(BluetoothService.class);
    }
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(MetricsLoggerService.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(PinnerService.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  }
 catch (  RuntimeException e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"");
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  StatusBarManagerService statusBar=null;
  INotificationManager notification=null;
  LocationManagerService location=null;
  CountryDetectorService countryDetector=null;
  ILockSettings lockSettings=null;
  AssetAtlasService atlas=null;
  MediaRouterService mediaRouter=null;
  if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
    mSystemServiceManager.startService(InputMethodManagerService.Lifecycle.class);
    traceBeginAndSlog(""String_Node_Str"");
    try {
      ServiceManager.addService(Context.ACCESSIBILITY_SERVICE,new AccessibilityManagerService(context));
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  }
  try {
    wm.displayReady();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
    if (!disableStorage && !""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""))) {
      try {
        mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
        mountService=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
    }
  }
  mSystemServiceManager.startService(UiModeManagerService.class);
  if (!mOnlyCore) {
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
    try {
      mPackageManagerService.updatePackagesIfNeeded();
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  }
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    mPackageManagerService.performFstrimIfNeeded();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  try {
    ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps),false);
  }
 catch (  RemoteException e) {
  }
  if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
    if (!disableNonCoreServices) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        mSystemServiceManager.startService(LOCK_SETTINGS_SERVICE_CLASS);
        lockSettings=ILockSettings.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals(""String_Node_Str"")) {
        mSystemServiceManager.startService(PersistentDataBlockService.class);
      }
      mSystemServiceManager.startService(DeviceIdleController.class);
      mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
    }
    if (!disableSystemUI) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        statusBar=new StatusBarManagerService(context,wm);
        ServiceManager.addService(Context.STATUS_BAR_SERVICE,statusBar);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        ServiceManager.addService(Context.CLIPBOARD_SERVICE,new ClipboardService(context));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNetwork) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkManagement=NetworkManagementService.create(context);
        ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE,networkManagement);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices && !disableTextServices) {
      mSystemServiceManager.startService(TextServicesManagerService.Lifecycle.class);
    }
    if (!disableNetwork) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkScore=new NetworkScoreService(context);
        ServiceManager.addService(Context.NETWORK_SCORE_SERVICE,networkScore);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkStats=NetworkStatsService.create(context,networkManagement);
        ServiceManager.addService(Context.NETWORK_STATS_SERVICE,networkStats);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkPolicy=new NetworkPolicyManagerService(context,mActivityManagerService,(IPowerManager)ServiceManager.getService(Context.POWER_SERVICE),networkStats,networkManagement);
        ServiceManager.addService(Context.NETWORK_POLICY_SERVICE,networkPolicy);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_NAN)) {
        mSystemServiceManager.startService(WIFI_NAN_SERVICE_CLASS);
      }
 else {
        Slog.i(TAG,""String_Node_Str"");
      }
      mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
      mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
      mSystemServiceManager.startService(""String_Node_Str"");
      if (!disableRtt) {
        mSystemServiceManager.startService(""String_Node_Str"");
      }
      if (enableWigig) {
        try {
          Slog.i(TAG,""String_Node_Str"");
          PathClassLoader wigigClassLoader=new PathClassLoader(""String_Node_Str"",""String_Node_Str"",getClass().getClassLoader());
          Class wigigP2pClass=wigigClassLoader.loadClass(""String_Node_Str"");
          Constructor<Class> ctor=wigigP2pClass.getConstructor(Context.class);
          wigigP2pService=ctor.newInstance(context);
          Slog.i(TAG,""String_Node_Str"");
          ServiceManager.addService(""String_Node_Str"",(IBinder)wigigP2pService);
          Class wigigClass=wigigClassLoader.loadClass(""String_Node_Str"");
          ctor=wigigClass.getConstructor(Context.class);
          wigigService=ctor.newInstance(context);
          Slog.i(TAG,""String_Node_Str"");
          ServiceManager.addService(""String_Node_Str"",(IBinder)wigigService);
        }
 catch (        Throwable e) {
          reportWtf(""String_Node_Str"",e);
        }
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
        mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
      }
      traceBeginAndSlog(""String_Node_Str"");
      try {
        connectivity=new ConnectivityService(context,networkManagement,networkStats,networkPolicy);
        ServiceManager.addService(Context.CONNECTIVITY_SERVICE,connectivity);
        networkStats.bindConnectivityManager(connectivity);
        networkPolicy.bindConnectivityManager(connectivity);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      traceBeginAndSlog(""String_Node_Str"");
      try {
        serviceDiscovery=NsdService.create(context);
        ServiceManager.addService(Context.NSD_SERVICE,serviceDiscovery);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        ServiceManager.addService(Context.UPDATE_LOCK_SERVICE,new UpdateLockService(context));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      mSystemServiceManager.startService(RecoverySystemService.class);
    }
    if (mountService != null && !mOnlyCore) {
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        mountService.waitForAsecScan();
      }
 catch (      RemoteException ignored) {
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    mSystemServiceManager.startService(NotificationManagerService.class);
    notification=INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
    networkPolicy.bindNotificationManager(notification);
    mSystemServiceManager.startService(DeviceStorageMonitorService.class);
    if (!disableLocation) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        location=new LocationManagerService(context);
        ServiceManager.addService(Context.LOCATION_SERVICE,location);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      traceBeginAndSlog(""String_Node_Str"");
      try {
        countryDetector=new CountryDetectorService(context);
        ServiceManager.addService(Context.COUNTRY_DETECTOR,countryDetector);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices && !disableSearchManager) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        mSystemServiceManager.startService(SEARCH_MANAGER_SERVICE_CLASS);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    mSystemServiceManager.startService(DropBoxManagerService.class);
    if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
      traceBeginAndSlog(""String_Node_Str"");
      mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS);
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(AudioService.Lifecycle.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (!disableNonCoreServices) {
      mSystemServiceManager.startService(DockObserver.class);
      if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
        mSystemServiceManager.startService(THERMAL_OBSERVER_CLASS);
      }
    }
    traceBeginAndSlog(""String_Node_Str"");
    try {
      inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context,inputManager));
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (!disableNonCoreServices) {
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
        mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
        mSystemServiceManager.startService(USB_SERVICE_CLASS);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      }
      if (!disableSerial) {
        traceBeginAndSlog(""String_Node_Str"");
        try {
          serial=new SerialService(context);
          ServiceManager.addService(Context.SERIAL_SERVICE,serial);
        }
 catch (        Throwable e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      }
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        hardwarePropertiesService=new HardwarePropertiesManagerService(context);
        ServiceManager.addService(Context.HARDWARE_PROPERTIES_SERVICE,hardwarePropertiesService);
      }
 catch (      Throwable e) {
        Slog.e(TAG,""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    mSystemServiceManager.startService(TwilightService.class);
    mSystemServiceManager.startService(JobSchedulerService.class);
    mSystemServiceManager.startService(SoundTriggerService.class);
    if (!disableNonCoreServices) {
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
        mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS) || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) {
        mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
        mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
      }
      if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
        Slog.i(TAG,""String_Node_Str"");
        mSystemServiceManager.startService(GestureLauncherService.class);
      }
      mSystemServiceManager.startService(SensorNotificationService.class);
      mSystemServiceManager.startService(ContextHubSystemService.class);
    }
    traceBeginAndSlog(""String_Node_Str"");
    try {
      ServiceManager.addService(""String_Node_Str"",new DiskStatsService(context));
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (!disableSamplingProfiler) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        ServiceManager.addService(""String_Node_Str"",new SamplingProfilerService(context));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNetwork && !disableNetworkTime) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkTimeUpdater=new NetworkTimeUpdateService(context);
        ServiceManager.addService(""String_Node_Str"",networkTimeUpdater);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    traceBeginAndSlog(""String_Node_Str"");
    try {
      commonTimeMgmtService=new CommonTimeManagementService(context);
      ServiceManager.addService(""String_Node_Str"",commonTimeMgmtService);
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (!disableNetwork) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        CertBlacklister blacklister=new CertBlacklister(context);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      mSystemServiceManager.startService(DreamManagerService.class);
    }
    if (!disableNonCoreServices && ZygoteInit.PRELOAD_RESOURCES) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        atlas=new AssetAtlasService(context);
        ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE,atlas);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE,new GraphicsStatsService(context));
    }
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
      mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
    }
    mSystemServiceManager.startService(RestrictionsManagerService.class);
    mSystemServiceManager.startService(MediaSessionService.class);
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
      mSystemServiceManager.startService(HdmiControlService.class);
    }
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
      mSystemServiceManager.startService(TvInputManagerService.class);
    }
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PICTURE_IN_PICTURE)) {
      mSystemServiceManager.startService(MediaResourceMonitorService.class);
    }
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
      mSystemServiceManager.startService(TvRemoteService.class);
    }
    if (!disableNonCoreServices) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        mediaRouter=new MediaRouterService(context);
        ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE,mediaRouter);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      if (!disableTrustManager) {
        mSystemServiceManager.startService(TrustManagerService.class);
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)) {
        mSystemServiceManager.startService(FingerprintService.class);
      }
      traceBeginAndSlog(""String_Node_Str"");
      try {
        BackgroundDexOptService.schedule(context);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    mSystemServiceManager.startService(ShortcutService.Lifecycle.class);
    mSystemServiceManager.startService(LauncherAppsService.class);
  }
  if (!disableNonCoreServices && !disableMediaProjection) {
    mSystemServiceManager.startService(MediaProjectionManagerService.class);
  }
  if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
    mSystemServiceManager.startService(WEAR_BLUETOOTH_SERVICE_CLASS);
  }
  final boolean safeMode=wm.detectSafeMode();
  if (safeMode) {
    mActivityManagerService.enterSafeMode();
    VMRuntime.getRuntime().disableJitCompilation();
  }
 else {
    VMRuntime.getRuntime().startJitCompilation();
  }
  mmsService=mSystemServiceManager.startService(MmsServiceBroker.class);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    vibrator.systemReady();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  if (lockSettings != null) {
    try {
      lockSettings.systemReady();
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
  mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  if (enableWigig) {
    try {
      Slog.i(TAG,""String_Node_Str"");
      Class wigigP2pClass=wigigP2pService.getClass();
      Method m=wigigP2pClass.getMethod(""String_Node_Str"",int.class);
      m.invoke(wigigP2pService,new Integer(SystemService.PHASE_SYSTEM_SERVICES_READY));
      Class wigigClass=wigigService.getClass();
      m=wigigClass.getMethod(""String_Node_Str"",int.class);
      m.invoke(wigigService,new Integer(SystemService.PHASE_SYSTEM_SERVICES_READY));
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
  }
  try {
    wm.systemReady();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  if (safeMode) {
    mActivityManagerService.showSafeModeOverlay();
  }
  Configuration config=wm.computeNewConfiguration();
  DisplayMetrics metrics=new DisplayMetrics();
  WindowManager w=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  w.getDefaultDisplay().getMetrics(metrics);
  context.getResources().updateConfiguration(config,metrics);
  final Theme systemTheme=context.getTheme();
  if (systemTheme.getChangingConfigurations() != 0) {
    systemTheme.rebase();
  }
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    mPackageManagerService.systemReady();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    mDisplayManagerService.systemReady(safeMode,mOnlyCore);
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  final NetworkManagementService networkManagementF=networkManagement;
  final NetworkStatsService networkStatsF=networkStats;
  final NetworkPolicyManagerService networkPolicyF=networkPolicy;
  final ConnectivityService connectivityF=connectivity;
  final NetworkScoreService networkScoreF=networkScore;
  final LocationManagerService locationF=location;
  final CountryDetectorService countryDetectorF=countryDetector;
  final NetworkTimeUpdateService networkTimeUpdaterF=networkTimeUpdater;
  final CommonTimeManagementService commonTimeMgmtServiceF=commonTimeMgmtService;
  final AssetAtlasService atlasF=atlas;
  final InputManagerService inputManagerF=inputManager;
  final TelephonyRegistry telephonyRegistryF=telephonyRegistry;
  final MediaRouterService mediaRouterF=mediaRouter;
  final MmsServiceBroker mmsServiceF=mmsService;
  mActivityManagerService.systemReady(new Runnable(){
    @Override public void run(){
      Slog.i(TAG,""String_Node_Str"");
      mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        mActivityManagerService.startObservingNativeCrashes();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      if (!mOnlyCore) {
        Slog.i(TAG,""String_Node_Str"");
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
        mWebViewUpdateService.prepareWebViewInSystemServer();
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      }
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        startSystemUi(context);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (networkScoreF != null)         networkScoreF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (networkManagementF != null)         networkManagementF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (networkStatsF != null)         networkStatsF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (networkPolicyF != null)         networkPolicyF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (connectivityF != null)         connectivityF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Watchdog.getInstance().start();
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
      try {
        if (locationF != null)         locationF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (countryDetectorF != null)         countryDetectorF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (networkTimeUpdaterF != null)         networkTimeUpdaterF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (commonTimeMgmtServiceF != null) {
          commonTimeMgmtServiceF.systemRunning();
        }
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (atlasF != null)         atlasF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (inputManagerF != null)         inputManagerF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (telephonyRegistryF != null)         telephonyRegistryF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (mediaRouterF != null)         mediaRouterF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (mmsServiceF != null)         mmsServiceF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (networkScoreF != null)         networkScoreF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
  }
);
}","/** 
 * Starts a miscellaneous grab bag of stuff that has yet to be refactored and organized.
 */
private void startOtherServices(){
  final Context context=mSystemContext;
  VibratorService vibrator=null;
  IMountService mountService=null;
  NetworkManagementService networkManagement=null;
  NetworkStatsService networkStats=null;
  NetworkPolicyManagerService networkPolicy=null;
  ConnectivityService connectivity=null;
  NetworkScoreService networkScore=null;
  NsdService serviceDiscovery=null;
  WindowManagerService wm=null;
  SerialService serial=null;
  NetworkTimeUpdateService networkTimeUpdater=null;
  CommonTimeManagementService commonTimeMgmtService=null;
  InputManagerService inputManager=null;
  TelephonyRegistry telephonyRegistry=null;
  ConsumerIrService consumerIr=null;
  MmsServiceBroker mmsService=null;
  HardwarePropertiesManagerService hardwarePropertiesService=null;
  Object wigigP2pService=null;
  Object wigigService=null;
  boolean disableStorage=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableBluetooth=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableLocation=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableSystemUI=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableNonCoreServices=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableNetwork=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableNetworkTime=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableRtt=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableMediaProjection=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableSerial=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableSearchManager=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableTrustManager=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableTextServices=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean disableSamplingProfiler=SystemProperties.getBoolean(""String_Node_Str"",false);
  boolean isEmulator=SystemProperties.get(""String_Node_Str"").equals(""String_Node_Str"");
  boolean enableWigig=SystemProperties.getBoolean(""String_Node_Str"",false);
  try {
    Slog.i(TAG,""String_Node_Str"");
    SystemConfig.getInstance();
    traceBeginAndSlog(""String_Node_Str"");
    ServiceManager.addService(""String_Node_Str"",new SchedulingPolicyService());
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    mSystemServiceManager.startService(TelecomLoaderService.class);
    traceBeginAndSlog(""String_Node_Str"");
    telephonyRegistry=new TelephonyRegistry(context);
    ServiceManager.addService(""String_Node_Str"",telephonyRegistry);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mEntropyMixer=new EntropyMixer(context);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    mContentResolver=context.getContentResolver();
    Slog.i(TAG,""String_Node_Str"");
    mSystemServiceManager.startService(CameraService.class);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mActivityManagerService.installSystemProviders();
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    vibrator=new VibratorService(context);
    ServiceManager.addService(""String_Node_Str"",vibrator);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    consumerIr=new ConsumerIrService(context);
    ServiceManager.addService(Context.CONSUMER_IR_SERVICE,consumerIr);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(AlarmManagerService.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    final Watchdog watchdog=Watchdog.getInstance();
    watchdog.init(context,mActivityManagerService);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    inputManager=new InputManagerService(context);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    wm=WindowManagerService.main(context,inputManager,mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,!mFirstBoot,mOnlyCore);
    ServiceManager.addService(Context.WINDOW_SERVICE,wm);
    ServiceManager.addService(Context.INPUT_SERVICE,inputManager);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(VrManagerService.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    mActivityManagerService.setWindowManager(wm);
    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
    inputManager.start();
    mDisplayManagerService.windowManagerAndInputReady();
    if (isEmulator) {
      Slog.i(TAG,""String_Node_Str"");
    }
 else     if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      Slog.i(TAG,""String_Node_Str"");
    }
 else     if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
      Slog.i(TAG,""String_Node_Str"");
    }
 else     if (disableBluetooth) {
      Slog.i(TAG,""String_Node_Str"");
    }
 else {
      mSystemServiceManager.startService(BluetoothService.class);
    }
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(MetricsLoggerService.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(PinnerService.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  }
 catch (  RuntimeException e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"");
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  StatusBarManagerService statusBar=null;
  INotificationManager notification=null;
  LocationManagerService location=null;
  CountryDetectorService countryDetector=null;
  ILockSettings lockSettings=null;
  AssetAtlasService atlas=null;
  MediaRouterService mediaRouter=null;
  if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
    mSystemServiceManager.startService(InputMethodManagerService.Lifecycle.class);
    traceBeginAndSlog(""String_Node_Str"");
    try {
      ServiceManager.addService(Context.ACCESSIBILITY_SERVICE,new AccessibilityManagerService(context));
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  }
  try {
    wm.displayReady();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
    if (!disableStorage && !""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""))) {
      try {
        mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
        mountService=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
    }
  }
  mSystemServiceManager.startService(UiModeManagerService.class);
  if (!mOnlyCore) {
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
    try {
      mPackageManagerService.updatePackagesIfNeeded();
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  }
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    mPackageManagerService.performFstrimIfNeeded();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  try {
    ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps),false);
  }
 catch (  RemoteException e) {
  }
  if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
    if (!disableNonCoreServices) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        mSystemServiceManager.startService(LOCK_SETTINGS_SERVICE_CLASS);
        lockSettings=ILockSettings.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals(""String_Node_Str"")) {
        mSystemServiceManager.startService(PersistentDataBlockService.class);
      }
      mSystemServiceManager.startService(DeviceIdleController.class);
      mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
    }
    if (!disableSystemUI) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        statusBar=new StatusBarManagerService(context,wm);
        ServiceManager.addService(Context.STATUS_BAR_SERVICE,statusBar);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        ServiceManager.addService(Context.CLIPBOARD_SERVICE,new ClipboardService(context));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNetwork) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkManagement=NetworkManagementService.create(context);
        ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE,networkManagement);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices && !disableTextServices) {
      mSystemServiceManager.startService(TextServicesManagerService.Lifecycle.class);
    }
    if (!disableNetwork) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkScore=new NetworkScoreService(context);
        ServiceManager.addService(Context.NETWORK_SCORE_SERVICE,networkScore);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkStats=NetworkStatsService.create(context,networkManagement);
        ServiceManager.addService(Context.NETWORK_STATS_SERVICE,networkStats);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkPolicy=new NetworkPolicyManagerService(context,mActivityManagerService,(IPowerManager)ServiceManager.getService(Context.POWER_SERVICE),networkStats,networkManagement);
        ServiceManager.addService(Context.NETWORK_POLICY_SERVICE,networkPolicy);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_NAN)) {
        mSystemServiceManager.startService(WIFI_NAN_SERVICE_CLASS);
      }
 else {
        Slog.i(TAG,""String_Node_Str"");
      }
      mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
      mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
      mSystemServiceManager.startService(""String_Node_Str"");
      if (!disableRtt) {
        mSystemServiceManager.startService(""String_Node_Str"");
      }
      if (enableWigig) {
        try {
          Slog.i(TAG,""String_Node_Str"");
          PathClassLoader wigigClassLoader=new PathClassLoader(""String_Node_Str"",""String_Node_Str"",getClass().getClassLoader());
          Class wigigP2pClass=wigigClassLoader.loadClass(""String_Node_Str"");
          Constructor<Class> ctor=wigigP2pClass.getConstructor(Context.class);
          wigigP2pService=ctor.newInstance(context);
          Slog.i(TAG,""String_Node_Str"");
          ServiceManager.addService(""String_Node_Str"",(IBinder)wigigP2pService);
          Class wigigClass=wigigClassLoader.loadClass(""String_Node_Str"");
          ctor=wigigClass.getConstructor(Context.class);
          wigigService=ctor.newInstance(context);
          Slog.i(TAG,""String_Node_Str"");
          ServiceManager.addService(""String_Node_Str"",(IBinder)wigigService);
        }
 catch (        Throwable e) {
          reportWtf(""String_Node_Str"",e);
        }
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
        mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
      }
      traceBeginAndSlog(""String_Node_Str"");
      try {
        connectivity=new ConnectivityService(context,networkManagement,networkStats,networkPolicy);
        ServiceManager.addService(Context.CONNECTIVITY_SERVICE,connectivity);
        networkStats.bindConnectivityManager(connectivity);
        networkPolicy.bindConnectivityManager(connectivity);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      traceBeginAndSlog(""String_Node_Str"");
      try {
        serviceDiscovery=NsdService.create(context);
        ServiceManager.addService(Context.NSD_SERVICE,serviceDiscovery);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        ServiceManager.addService(Context.UPDATE_LOCK_SERVICE,new UpdateLockService(context));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      mSystemServiceManager.startService(RecoverySystemService.class);
    }
    if (mountService != null && !mOnlyCore) {
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        mountService.waitForAsecScan();
      }
 catch (      RemoteException ignored) {
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    mSystemServiceManager.startService(NotificationManagerService.class);
    notification=INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
    networkPolicy.bindNotificationManager(notification);
    mSystemServiceManager.startService(DeviceStorageMonitorService.class);
    if (!disableLocation) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        location=new LocationManagerService(context);
        ServiceManager.addService(Context.LOCATION_SERVICE,location);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      traceBeginAndSlog(""String_Node_Str"");
      try {
        countryDetector=new CountryDetectorService(context);
        ServiceManager.addService(Context.COUNTRY_DETECTOR,countryDetector);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices && !disableSearchManager) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        mSystemServiceManager.startService(SEARCH_MANAGER_SERVICE_CLASS);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    mSystemServiceManager.startService(DropBoxManagerService.class);
    if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
      traceBeginAndSlog(""String_Node_Str"");
      mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS);
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    traceBeginAndSlog(""String_Node_Str"");
    mSystemServiceManager.startService(AudioService.Lifecycle.class);
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (!disableNonCoreServices) {
      mSystemServiceManager.startService(DockObserver.class);
      if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
      }
    }
    traceBeginAndSlog(""String_Node_Str"");
    try {
      inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context,inputManager));
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (!disableNonCoreServices) {
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
        mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
        mSystemServiceManager.startService(USB_SERVICE_CLASS);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      }
      if (!disableSerial) {
        traceBeginAndSlog(""String_Node_Str"");
        try {
          serial=new SerialService(context);
          ServiceManager.addService(Context.SERIAL_SERVICE,serial);
        }
 catch (        Throwable e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      }
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        hardwarePropertiesService=new HardwarePropertiesManagerService(context);
        ServiceManager.addService(Context.HARDWARE_PROPERTIES_SERVICE,hardwarePropertiesService);
      }
 catch (      Throwable e) {
        Slog.e(TAG,""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    mSystemServiceManager.startService(TwilightService.class);
    mSystemServiceManager.startService(JobSchedulerService.class);
    mSystemServiceManager.startService(SoundTriggerService.class);
    if (!disableNonCoreServices) {
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
        mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS) || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) {
        mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
        mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
      }
      if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
        Slog.i(TAG,""String_Node_Str"");
        mSystemServiceManager.startService(GestureLauncherService.class);
      }
      mSystemServiceManager.startService(SensorNotificationService.class);
      mSystemServiceManager.startService(ContextHubSystemService.class);
    }
    traceBeginAndSlog(""String_Node_Str"");
    try {
      ServiceManager.addService(""String_Node_Str"",new DiskStatsService(context));
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (!disableSamplingProfiler) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        ServiceManager.addService(""String_Node_Str"",new SamplingProfilerService(context));
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNetwork && !disableNetworkTime) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        networkTimeUpdater=new NetworkTimeUpdateService(context);
        ServiceManager.addService(""String_Node_Str"",networkTimeUpdater);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    traceBeginAndSlog(""String_Node_Str"");
    try {
      commonTimeMgmtService=new CommonTimeManagementService(context);
      ServiceManager.addService(""String_Node_Str"",commonTimeMgmtService);
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (!disableNetwork) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        CertBlacklister blacklister=new CertBlacklister(context);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      mSystemServiceManager.startService(DreamManagerService.class);
    }
    if (!disableNonCoreServices && ZygoteInit.PRELOAD_RESOURCES) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        atlas=new AssetAtlasService(context);
        ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE,atlas);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    if (!disableNonCoreServices) {
      ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE,new GraphicsStatsService(context));
    }
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
      mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
    }
    mSystemServiceManager.startService(RestrictionsManagerService.class);
    mSystemServiceManager.startService(MediaSessionService.class);
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
      mSystemServiceManager.startService(HdmiControlService.class);
    }
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
      mSystemServiceManager.startService(TvInputManagerService.class);
    }
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PICTURE_IN_PICTURE)) {
      mSystemServiceManager.startService(MediaResourceMonitorService.class);
    }
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
      mSystemServiceManager.startService(TvRemoteService.class);
    }
    if (!disableNonCoreServices) {
      traceBeginAndSlog(""String_Node_Str"");
      try {
        mediaRouter=new MediaRouterService(context);
        ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE,mediaRouter);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      if (!disableTrustManager) {
        mSystemServiceManager.startService(TrustManagerService.class);
      }
      if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)) {
        mSystemServiceManager.startService(FingerprintService.class);
      }
      traceBeginAndSlog(""String_Node_Str"");
      try {
        BackgroundDexOptService.schedule(context);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    mSystemServiceManager.startService(ShortcutService.Lifecycle.class);
    mSystemServiceManager.startService(LauncherAppsService.class);
  }
  if (!disableNonCoreServices && !disableMediaProjection) {
    mSystemServiceManager.startService(MediaProjectionManagerService.class);
  }
  if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
  }
  final boolean safeMode=wm.detectSafeMode();
  if (safeMode) {
    mActivityManagerService.enterSafeMode();
    VMRuntime.getRuntime().disableJitCompilation();
  }
 else {
    VMRuntime.getRuntime().startJitCompilation();
  }
  mmsService=mSystemServiceManager.startService(MmsServiceBroker.class);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    vibrator.systemReady();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  if (lockSettings != null) {
    try {
      lockSettings.systemReady();
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
  mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  if (enableWigig) {
    try {
      Slog.i(TAG,""String_Node_Str"");
      Class wigigP2pClass=wigigP2pService.getClass();
      Method m=wigigP2pClass.getMethod(""String_Node_Str"",int.class);
      m.invoke(wigigP2pService,new Integer(SystemService.PHASE_SYSTEM_SERVICES_READY));
      Class wigigClass=wigigService.getClass();
      m=wigigClass.getMethod(""String_Node_Str"",int.class);
      m.invoke(wigigService,new Integer(SystemService.PHASE_SYSTEM_SERVICES_READY));
    }
 catch (    Throwable e) {
      reportWtf(""String_Node_Str"",e);
    }
  }
  try {
    wm.systemReady();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  if (safeMode) {
    mActivityManagerService.showSafeModeOverlay();
  }
  Configuration config=wm.computeNewConfiguration();
  DisplayMetrics metrics=new DisplayMetrics();
  WindowManager w=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  w.getDefaultDisplay().getMetrics(metrics);
  context.getResources().updateConfiguration(config,metrics);
  final Theme systemTheme=context.getTheme();
  if (systemTheme.getChangingConfigurations() != 0) {
    systemTheme.rebase();
  }
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    mPackageManagerService.systemReady();
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
  try {
    mDisplayManagerService.systemReady(safeMode,mOnlyCore);
  }
 catch (  Throwable e) {
    reportWtf(""String_Node_Str"",e);
  }
  Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
  final NetworkManagementService networkManagementF=networkManagement;
  final NetworkStatsService networkStatsF=networkStats;
  final NetworkPolicyManagerService networkPolicyF=networkPolicy;
  final ConnectivityService connectivityF=connectivity;
  final NetworkScoreService networkScoreF=networkScore;
  final LocationManagerService locationF=location;
  final CountryDetectorService countryDetectorF=countryDetector;
  final NetworkTimeUpdateService networkTimeUpdaterF=networkTimeUpdater;
  final CommonTimeManagementService commonTimeMgmtServiceF=commonTimeMgmtService;
  final AssetAtlasService atlasF=atlas;
  final InputManagerService inputManagerF=inputManager;
  final TelephonyRegistry telephonyRegistryF=telephonyRegistry;
  final MediaRouterService mediaRouterF=mediaRouter;
  final MmsServiceBroker mmsServiceF=mmsService;
  mActivityManagerService.systemReady(new Runnable(){
    @Override public void run(){
      Slog.i(TAG,""String_Node_Str"");
      mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        mActivityManagerService.startObservingNativeCrashes();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      if (!mOnlyCore) {
        Slog.i(TAG,""String_Node_Str"");
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
        mWebViewUpdateService.prepareWebViewInSystemServer();
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      }
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        startSystemUi(context);
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (networkScoreF != null)         networkScoreF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (networkManagementF != null)         networkManagementF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (networkStatsF != null)         networkStatsF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (networkPolicyF != null)         networkPolicyF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      try {
        if (connectivityF != null)         connectivityF.systemReady();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Watchdog.getInstance().start();
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
      Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER,""String_Node_Str"");
      mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
      try {
        if (locationF != null)         locationF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (countryDetectorF != null)         countryDetectorF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (networkTimeUpdaterF != null)         networkTimeUpdaterF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (commonTimeMgmtServiceF != null) {
          commonTimeMgmtServiceF.systemRunning();
        }
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (atlasF != null)         atlasF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (inputManagerF != null)         inputManagerF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (telephonyRegistryF != null)         telephonyRegistryF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (mediaRouterF != null)         mediaRouterF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (mmsServiceF != null)         mmsServiceF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      try {
        if (networkScoreF != null)         networkScoreF.systemRunning();
      }
 catch (      Throwable e) {
        reportWtf(""String_Node_Str"",e);
      }
      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
  }
);
}",0.9978672766049516
191102,"@Override public void onHotspotChanged(boolean enabled){
  mIconController.setIconVisibility(mSlotHotspot,enabled);
}","@Override public void onHotspotChanged(boolean enabled){
  mIconController.setIcon(mSlotHotspot,R.drawable.stat_sys_hotspot,mContext.getString(R.string.accessibility_status_bar_hotspot));
  mIconController.setIconVisibility(mSlotHotspot,enabled);
}",0.6410958904109589
191103,"private VerifyCredentialResponse doVerifyPattern(String pattern,CredentialHash storedHash,boolean hasChallenge,long challenge,int userId) throws RemoteException {
  boolean shouldReEnrollBaseZero=storedHash != null && storedHash.isBaseZeroPattern;
  String patternToVerify;
  if (shouldReEnrollBaseZero) {
    patternToVerify=LockPatternUtils.patternStringToBaseZero(pattern);
  }
 else {
    patternToVerify=pattern;
  }
  VerifyCredentialResponse response=verifyCredential(userId,storedHash,patternToVerify,hasChallenge,challenge,new CredentialUtil(){
    @Override public void setCredential(    String pattern,    String oldPattern,    int userId) throws RemoteException {
      setLockPatternInternal(pattern,oldPattern,userId);
    }
    @Override public byte[] toHash(    String pattern,    int userId){
      return LockPatternUtils.patternToHash(LockPatternUtils.stringToPattern(pattern));
    }
    @Override public String adjustForKeystore(    String pattern){
      return LockPatternUtils.patternStringToBaseZero(pattern);
    }
  }
);
  if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK && shouldReEnrollBaseZero) {
    setLockPatternInternal(pattern,patternToVerify,userId);
  }
  if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK)   retainPassword(pattern);
  return response;
}","private VerifyCredentialResponse doVerifyPattern(String pattern,CredentialHash storedHash,boolean hasChallenge,long challenge,int userId) throws RemoteException {
  boolean shouldReEnrollBaseZero=storedHash != null && storedHash.isBaseZeroPattern;
  String patternToVerify;
  if (shouldReEnrollBaseZero) {
    patternToVerify=LockPatternUtils.patternStringToBaseZero(pattern);
  }
 else {
    patternToVerify=pattern;
  }
  VerifyCredentialResponse response=verifyCredential(userId,storedHash,patternToVerify,hasChallenge,challenge,new CredentialUtil(){
    @Override public void setCredential(    String pattern,    String oldPattern,    int userId) throws RemoteException {
      setLockPatternInternal(pattern,oldPattern,userId);
    }
    @Override public byte[] toHash(    String pattern,    int userId){
      return LockPatternUtils.patternToHash(LockPatternUtils.stringToPattern(pattern));
    }
    @Override public String adjustForKeystore(    String pattern){
      return LockPatternUtils.patternStringToBaseZero(pattern);
    }
  }
);
  if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK && shouldReEnrollBaseZero) {
    setLockPatternInternal(pattern,patternToVerify,userId);
  }
  return response;
}",0.9490073958738808
191104,"@Override public VerifyCredentialResponse checkPattern(String pattern,int userId) throws RemoteException {
  return doVerifyPattern(pattern,false,0,userId);
}","@Override public VerifyCredentialResponse checkPattern(String pattern,int userId) throws RemoteException {
  VerifyCredentialResponse response=doVerifyPattern(pattern,false,0,userId);
  if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK)   retainPassword(pattern);
  return response;
}",0.652267818574514
191105,"@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerServiceStub.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}","@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerServiceStub.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    ComponentName curAssistant=getCurAssistant(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        resetCurAssistant(userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    if (curAssistant != null) {
      int change=isPackageDisappearing(curAssistant.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        resetCurAssistant(userHandle);
        initForUser(userHandle);
        return;
      }
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}",0.87893864013267
191106,"@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerServiceStub.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}","@Override public void onSomePackagesChanged(){
  int userHandle=getChangingUserId();
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + userHandle);
synchronized (VoiceInteractionManagerServiceStub.this) {
    ComponentName curInteractor=getCurInteractor(userHandle);
    ComponentName curRecognizer=getCurRecognizer(userHandle);
    ComponentName curAssistant=getCurAssistant(userHandle);
    if (curRecognizer == null) {
      if (anyPackagesAppearing()) {
        curRecognizer=findAvailRecognizer(null,userHandle);
        if (curRecognizer != null) {
          setCurRecognizer(curRecognizer,userHandle);
        }
      }
      return;
    }
    if (curInteractor != null) {
      int change=isPackageDisappearing(curInteractor.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        resetCurAssistant(userHandle);
        initForUser(userHandle);
        return;
      }
      change=isPackageAppearing(curInteractor.getPackageName());
      if (change != PACKAGE_UNCHANGED) {
        if (mImpl != null && curInteractor.getPackageName().equals(mImpl.mComponent.getPackageName())) {
          switchImplementationIfNeededLocked(true);
        }
      }
      return;
    }
    if (curAssistant != null) {
      int change=isPackageDisappearing(curAssistant.getPackageName());
      if (change == PACKAGE_PERMANENT_CHANGE) {
        setCurInteractor(null,userHandle);
        setCurRecognizer(null,userHandle);
        resetCurAssistant(userHandle);
        initForUser(userHandle);
        return;
      }
    }
    int change=isPackageDisappearing(curRecognizer.getPackageName());
    if (change == PACKAGE_PERMANENT_CHANGE || change == PACKAGE_TEMPORARY_CHANGE) {
      setCurRecognizer(findAvailRecognizer(null,userHandle),userHandle);
    }
 else     if (isPackageModified(curRecognizer.getPackageName())) {
      setCurRecognizer(findAvailRecognizer(curRecognizer.getPackageName(),userHandle),userHandle);
    }
  }
}",0.87893864013267
191107,"private void updateSuppression(NotificationGroup group){
  if (group == null || mUpdatingSuppressionBlocked) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    mListener.onGroupsChanged();
  }
}","private void updateSuppression(NotificationGroup group){
  if (group == null) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    if (!mIsUpdatingUnchangedGroup) {
      mListener.onGroupsChanged();
    }
  }
}",0.4424934152765584
191108,"public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  String oldKey=oldNotification.getGroupKey();
  String newKey=entry.notification.getGroupKey();
  boolean groupKeysChanged=!oldKey.equals(newKey);
  boolean wasGroupChild=isGroupChild(oldNotification);
  boolean isGroupChild=isGroupChild(entry.notification);
  mUpdatingSuppressionBlocked=!groupKeysChanged && wasGroupChild == isGroupChild;
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  mUpdatingSuppressionBlocked=false;
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    if (groupKeysChanged) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!wasGroupChild && isGroupChild) {
    onEntryBecomingChild(entry);
  }
}","public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  String oldKey=oldNotification.getGroupKey();
  String newKey=entry.notification.getGroupKey();
  boolean groupKeysChanged=!oldKey.equals(newKey);
  boolean wasGroupChild=isGroupChild(oldNotification);
  boolean isGroupChild=isGroupChild(entry.notification);
  mIsUpdatingUnchangedGroup=!groupKeysChanged && wasGroupChild == isGroupChild;
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  mIsUpdatingUnchangedGroup=false;
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    if (groupKeysChanged) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!wasGroupChild && isGroupChild) {
    onEntryBecomingChild(entry);
  }
}",0.9632829373650108
191109,"private void updateSuppression(NotificationGroup group){
  if (group == null || mUpdatingSuppressionBlocked) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    mListener.onGroupsChanged();
  }
}","private void updateSuppression(NotificationGroup group){
  if (group == null) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    if (!mIsUpdatingUnchangedGroup) {
      mListener.onGroupsChanged();
    }
  }
}",0.4424934152765584
191110,"public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  String oldKey=oldNotification.getGroupKey();
  String newKey=entry.notification.getGroupKey();
  boolean groupKeysChanged=!oldKey.equals(newKey);
  boolean wasGroupChild=isGroupChild(oldNotification);
  boolean isGroupChild=isGroupChild(entry.notification);
  mUpdatingSuppressionBlocked=!groupKeysChanged && wasGroupChild == isGroupChild;
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  mUpdatingSuppressionBlocked=false;
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    if (groupKeysChanged) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!wasGroupChild && isGroupChild) {
    onEntryBecomingChild(entry);
  }
}","public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  String oldKey=oldNotification.getGroupKey();
  String newKey=entry.notification.getGroupKey();
  boolean groupKeysChanged=!oldKey.equals(newKey);
  boolean wasGroupChild=isGroupChild(oldNotification);
  boolean isGroupChild=isGroupChild(entry.notification);
  mIsUpdatingUnchangedGroup=!groupKeysChanged && wasGroupChild == isGroupChild;
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  mIsUpdatingUnchangedGroup=false;
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    if (groupKeysChanged) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!wasGroupChild && isGroupChild) {
    onEntryBecomingChild(entry);
  }
}",0.9632829373650108
191111,"private void updateSuppression(NotificationGroup group){
  if (group == null || mUpdatingSuppressionBlocked) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    mListener.onGroupsChanged();
  }
}","private void updateSuppression(NotificationGroup group){
  if (group == null) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    if (!mIsUpdatingUnchangedGroup) {
      mListener.onGroupsChanged();
    }
  }
}",0.4424934152765584
191112,"public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  String oldKey=oldNotification.getGroupKey();
  String newKey=entry.notification.getGroupKey();
  boolean groupKeysChanged=!oldKey.equals(newKey);
  boolean wasGroupChild=isGroupChild(oldNotification);
  boolean isGroupChild=isGroupChild(entry.notification);
  mUpdatingSuppressionBlocked=!groupKeysChanged && wasGroupChild == isGroupChild;
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  mUpdatingSuppressionBlocked=false;
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    if (groupKeysChanged) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!wasGroupChild && isGroupChild) {
    onEntryBecomingChild(entry);
  }
}","public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  String oldKey=oldNotification.getGroupKey();
  String newKey=entry.notification.getGroupKey();
  boolean groupKeysChanged=!oldKey.equals(newKey);
  boolean wasGroupChild=isGroupChild(oldNotification);
  boolean isGroupChild=isGroupChild(entry.notification);
  mIsUpdatingUnchangedGroup=!groupKeysChanged && wasGroupChild == isGroupChild;
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  mIsUpdatingUnchangedGroup=false;
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    if (groupKeysChanged) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!wasGroupChild && isGroupChild) {
    onEntryBecomingChild(entry);
  }
}",0.9632829373650108
191113,"/** 
 * Update the background bounds to the new desired bounds
 */
private void updateBackgroundBounds(){
  mBackgroundBounds.left=(int)getX();
  mBackgroundBounds.right=(int)(getX() + getWidth());
  if (!mIsExpanded) {
    mBackgroundBounds.top=0;
    mBackgroundBounds.bottom=0;
  }
  ActivatableNotificationView firstView=mFirstVisibleBackgroundChild;
  int top=0;
  if (firstView != null) {
    int finalTranslationY=(int)StackStateAnimator.getFinalTranslationY(firstView);
    if (mAnimateNextBackgroundTop || mTopAnimator == null && mCurrentBounds.top == finalTranslationY || mTopAnimator != null && mEndAnimationRect.top == finalTranslationY) {
      top=finalTranslationY;
    }
 else {
      top=(int)firstView.getTranslationY();
    }
  }
  ActivatableNotificationView lastView=mLastVisibleBackgroundChild;
  int bottom=0;
  if (lastView != null) {
    int finalTranslationY=(int)StackStateAnimator.getFinalTranslationY(lastView);
    int finalHeight=StackStateAnimator.getFinalActualHeight(lastView);
    int finalBottom=finalTranslationY + finalHeight;
    finalBottom=Math.min(finalBottom,getHeight());
    if (mAnimateNextBackgroundBottom || mBottomAnimator == null && mCurrentBounds.bottom == finalBottom || mBottomAnimator != null && mEndAnimationRect.bottom == finalBottom) {
      bottom=finalBottom;
    }
 else {
      bottom=(int)(lastView.getTranslationY() + lastView.getActualHeight());
      bottom=Math.min(bottom,getHeight());
    }
  }
 else {
    top=mTopPadding;
    bottom=top;
  }
  if (mPhoneStatusBar.getBarState() != StatusBarState.KEYGUARD) {
    mBackgroundBounds.top=(int)Math.max(mTopPadding + mStackTranslation,top);
  }
 else {
    mBackgroundBounds.top=Math.max(0,top);
  }
  mBackgroundBounds.bottom=Math.min(getHeight(),Math.max(bottom,top));
}","/** 
 * Update the background bounds to the new desired bounds
 */
private void updateBackgroundBounds(){
  mBackgroundBounds.left=(int)getX();
  mBackgroundBounds.right=(int)(getX() + getWidth());
  if (!mIsExpanded) {
    mBackgroundBounds.top=0;
    mBackgroundBounds.bottom=0;
  }
  ActivatableNotificationView firstView=mFirstVisibleBackgroundChild;
  int top=0;
  if (firstView != null) {
    int finalTranslationY=(int)StackStateAnimator.getFinalTranslationY(firstView);
    if (mAnimateNextBackgroundTop || mTopAnimator == null && mCurrentBounds.top == finalTranslationY || mTopAnimator != null && mEndAnimationRect.top == finalTranslationY) {
      top=finalTranslationY;
    }
 else {
      top=(int)firstView.getTranslationY();
    }
  }
  ActivatableNotificationView lastView=mLastVisibleBackgroundChild;
  int bottom=0;
  if (lastView != null) {
    int finalTranslationY=(int)StackStateAnimator.getFinalTranslationY(lastView);
    int finalHeight=StackStateAnimator.getFinalActualHeight(lastView);
    int finalBottom=finalTranslationY + finalHeight;
    finalBottom=Math.min(finalBottom,getHeight());
    if (mAnimateNextBackgroundBottom || mBottomAnimator == null && mCurrentBounds.bottom == finalBottom || mBottomAnimator != null && mEndAnimationRect.bottom == finalBottom) {
      bottom=finalBottom;
    }
 else {
      bottom=(int)(lastView.getTranslationY() + lastView.getActualHeight());
      bottom=Math.min(bottom,getHeight());
    }
  }
 else {
    top=mTopPadding;
    bottom=top;
  }
  if (mPhoneStatusBar.getBarState() != StatusBarState.KEYGUARD) {
    top=(int)Math.max(mTopPadding + mStackTranslation,top);
  }
 else {
    top=Math.max(0,top);
  }
  mBackgroundBounds.top=top;
  mBackgroundBounds.bottom=Math.min(getHeight(),Math.max(bottom,top));
}",0.9817774039809364
191114,"@Override protected void onDraw(Canvas canvas){
  canvas.drawRect(0,mCurrentBounds.top,getWidth(),mCurrentBounds.bottom,mBackgroundPaint);
  if (DEBUG) {
    int y=mTopPadding;
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
    y=(int)(getLayoutHeight() - mBottomStackPeekSize - mBottomStackSlowDownHeight);
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
    y=(int)(getLayoutHeight() - mBottomStackPeekSize);
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
    y=(int)getLayoutHeight();
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
    y=getHeight() - getEmptyBottomMargin();
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
  }
}","@Override protected void onDraw(Canvas canvas){
  if (mCurrentBounds.top < mCurrentBounds.bottom) {
    canvas.drawRect(0,mCurrentBounds.top,getWidth(),mCurrentBounds.bottom,mBackgroundPaint);
  }
  if (DEBUG) {
    int y=mTopPadding;
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
    y=(int)(getLayoutHeight() - mBottomStackPeekSize - mBottomStackSlowDownHeight);
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
    y=(int)(getLayoutHeight() - mBottomStackPeekSize);
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
    y=(int)getLayoutHeight();
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
    y=getHeight() - getEmptyBottomMargin();
    canvas.drawLine(0,y,getWidth(),y,mDebugPaint);
  }
}",0.9572901325478644
191115,"@SmallTest public void testSampleTimerSummaryParceling() throws Exception {
  final MockClocks clocks=new MockClocks();
  clocks.realtime=0;
  clocks.uptime=0;
  final BatteryStatsImpl.TimeBase timeBase=new BatteryStatsImpl.TimeBase();
  timeBase.init(clocks.uptimeMillis(),clocks.elapsedRealtime());
  BatteryStatsImpl.SamplingTimer timer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  timeBase.setRunning(true,clocks.uptimeMillis(),clocks.elapsedRealtime());
  timer.add(10,1);
  timer.add(10,1);
  clocks.realtime=20;
  clocks.uptime=20;
  assertEquals(10,timer.getTotalTimeLocked(clocks.elapsedRealtime(),BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,timer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  final Parcel onBatterySummaryParcel=Parcel.obtain();
  timer.writeSummaryFromParcelLocked(onBatterySummaryParcel,clocks.elapsedRealtime() * 1000);
  onBatterySummaryParcel.setDataPosition(0);
  timeBase.setRunning(false,clocks.uptimeMillis(),clocks.elapsedRealtime());
  assertEquals(10,timer.getTotalTimeLocked(clocks.elapsedRealtime(),BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,timer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  final Parcel offBatterySummaryParcel=Parcel.obtain();
  timer.writeSummaryFromParcelLocked(offBatterySummaryParcel,clocks.elapsedRealtime() * 1000);
  offBatterySummaryParcel.setDataPosition(0);
  BatteryStatsImpl.SamplingTimer unparceledTimer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  unparceledTimer.readSummaryFromParcelLocked(onBatterySummaryParcel);
  assertEquals(10,unparceledTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  unparceledTimer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  unparceledTimer.readSummaryFromParcelLocked(offBatterySummaryParcel);
  assertEquals(10,unparceledTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
}","@SmallTest public void testSampleTimerSummaryParceling() throws Exception {
  final MockClocks clocks=new MockClocks();
  clocks.realtime=0;
  clocks.uptime=0;
  final BatteryStatsImpl.TimeBase timeBase=new BatteryStatsImpl.TimeBase();
  timeBase.init(clocks.uptimeMillis(),clocks.elapsedRealtime());
  BatteryStatsImpl.SamplingTimer timer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  timeBase.setRunning(true,clocks.uptimeMillis(),clocks.elapsedRealtime());
  timer.add(10,1);
  timer.add(10,1);
  clocks.realtime=20;
  clocks.uptime=20;
  assertEquals(10,timer.getTotalTimeLocked(clocks.elapsedRealtime(),BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,timer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  final Parcel onBatterySummaryParcel=Parcel.obtain();
  timer.writeSummaryFromParcelLocked(onBatterySummaryParcel,clocks.elapsedRealtime() * 1000);
  onBatterySummaryParcel.setDataPosition(0);
  timeBase.setRunning(false,clocks.uptimeMillis(),clocks.elapsedRealtime());
  assertEquals(10,timer.getTotalTimeLocked(clocks.elapsedRealtime(),BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,timer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  final Parcel offBatterySummaryParcel=Parcel.obtain();
  timer.writeSummaryFromParcelLocked(offBatterySummaryParcel,clocks.elapsedRealtime() * 1000);
  offBatterySummaryParcel.setDataPosition(0);
  timeBase.setRunning(true,clocks.uptimeMillis(),clocks.elapsedRealtime());
  BatteryStatsImpl.SamplingTimer unparceledOnBatteryTimer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  unparceledOnBatteryTimer.readSummaryFromParcelLocked(onBatterySummaryParcel);
  assertEquals(10,unparceledOnBatteryTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledOnBatteryTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  BatteryStatsImpl.SamplingTimer unparceledOffBatteryTimer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  unparceledOffBatteryTimer.readSummaryFromParcelLocked(offBatterySummaryParcel);
  assertEquals(10,unparceledOffBatteryTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledOffBatteryTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  unparceledOnBatteryTimer.update(10,10);
  assertEquals(10,unparceledOnBatteryTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledOnBatteryTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  unparceledOffBatteryTimer.update(10,10);
  assertEquals(10,unparceledOffBatteryTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledOffBatteryTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
}",0.8222128378378378
191116,"@SmallTest public void testSampleTimerSummaryParceling() throws Exception {
  final MockClocks clocks=new MockClocks();
  clocks.realtime=0;
  clocks.uptime=0;
  final BatteryStatsImpl.TimeBase timeBase=new BatteryStatsImpl.TimeBase();
  timeBase.init(clocks.uptimeMillis(),clocks.elapsedRealtime());
  BatteryStatsImpl.SamplingTimer timer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  timeBase.setRunning(true,clocks.uptimeMillis(),clocks.elapsedRealtime());
  timer.add(10,1);
  timer.add(10,1);
  clocks.realtime=20;
  clocks.uptime=20;
  assertEquals(10,timer.getTotalTimeLocked(clocks.elapsedRealtime(),BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,timer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  final Parcel onBatterySummaryParcel=Parcel.obtain();
  timer.writeSummaryFromParcelLocked(onBatterySummaryParcel,clocks.elapsedRealtime() * 1000);
  onBatterySummaryParcel.setDataPosition(0);
  timeBase.setRunning(false,clocks.uptimeMillis(),clocks.elapsedRealtime());
  assertEquals(10,timer.getTotalTimeLocked(clocks.elapsedRealtime(),BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,timer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  final Parcel offBatterySummaryParcel=Parcel.obtain();
  timer.writeSummaryFromParcelLocked(offBatterySummaryParcel,clocks.elapsedRealtime() * 1000);
  offBatterySummaryParcel.setDataPosition(0);
  BatteryStatsImpl.SamplingTimer unparceledTimer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  unparceledTimer.readSummaryFromParcelLocked(onBatterySummaryParcel);
  assertEquals(10,unparceledTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  unparceledTimer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  unparceledTimer.readSummaryFromParcelLocked(offBatterySummaryParcel);
  assertEquals(10,unparceledTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
}","@SmallTest public void testSampleTimerSummaryParceling() throws Exception {
  final MockClocks clocks=new MockClocks();
  clocks.realtime=0;
  clocks.uptime=0;
  final BatteryStatsImpl.TimeBase timeBase=new BatteryStatsImpl.TimeBase();
  timeBase.init(clocks.uptimeMillis(),clocks.elapsedRealtime());
  BatteryStatsImpl.SamplingTimer timer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  timeBase.setRunning(true,clocks.uptimeMillis(),clocks.elapsedRealtime());
  timer.add(10,1);
  timer.add(10,1);
  clocks.realtime=20;
  clocks.uptime=20;
  assertEquals(10,timer.getTotalTimeLocked(clocks.elapsedRealtime(),BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,timer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  final Parcel onBatterySummaryParcel=Parcel.obtain();
  timer.writeSummaryFromParcelLocked(onBatterySummaryParcel,clocks.elapsedRealtime() * 1000);
  onBatterySummaryParcel.setDataPosition(0);
  timeBase.setRunning(false,clocks.uptimeMillis(),clocks.elapsedRealtime());
  assertEquals(10,timer.getTotalTimeLocked(clocks.elapsedRealtime(),BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,timer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  final Parcel offBatterySummaryParcel=Parcel.obtain();
  timer.writeSummaryFromParcelLocked(offBatterySummaryParcel,clocks.elapsedRealtime() * 1000);
  offBatterySummaryParcel.setDataPosition(0);
  timeBase.setRunning(true,clocks.uptimeMillis(),clocks.elapsedRealtime());
  BatteryStatsImpl.SamplingTimer unparceledOnBatteryTimer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  unparceledOnBatteryTimer.readSummaryFromParcelLocked(onBatterySummaryParcel);
  assertEquals(10,unparceledOnBatteryTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledOnBatteryTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  BatteryStatsImpl.SamplingTimer unparceledOffBatteryTimer=new BatteryStatsImpl.SamplingTimer(clocks,timeBase);
  unparceledOffBatteryTimer.readSummaryFromParcelLocked(offBatterySummaryParcel);
  assertEquals(10,unparceledOffBatteryTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledOffBatteryTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  unparceledOnBatteryTimer.update(10,10);
  assertEquals(10,unparceledOnBatteryTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledOnBatteryTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
  unparceledOffBatteryTimer.update(10,10);
  assertEquals(10,unparceledOffBatteryTimer.getTotalTimeLocked(0,BatteryStats.STATS_SINCE_CHARGED));
  assertEquals(1,unparceledOffBatteryTimer.getCountLocked(BatteryStats.STATS_SINCE_CHARGED));
}",0.8222128378378378
191117,"void removeIcon(@UserIdInt int userId,ShortcutInfo shortcut){
  if (shortcut.getBitmapPath() != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + shortcut.getBitmapPath());
    }
    new File(shortcut.getBitmapPath()).delete();
    shortcut.setBitmapPath(null);
  }
  shortcut.setIconResourceId(0);
  shortcut.setIconResName(null);
  shortcut.clearFlags(ShortcutInfo.FLAG_HAS_ICON_FILE | ShortcutInfo.FLAG_HAS_ICON_RES);
}","void removeIcon(@UserIdInt int userId,ShortcutInfo shortcut){
  shortcut.setIconResourceId(0);
  shortcut.setIconResName(null);
  shortcut.clearFlags(ShortcutInfo.FLAG_HAS_ICON_FILE | ShortcutInfo.FLAG_HAS_ICON_RES);
}",0.6687116564417178
191118,"private void cleanupDanglingBitmapDirectoriesLocked(@UserIdInt int userId,@NonNull ShortcutUser user){
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + userId);
  }
  final long start=injectElapsedRealtime();
  final File bitmapDir=getUserBitmapFilePath(userId);
  final File[] children=bitmapDir.listFiles();
  if (children == null) {
    return;
  }
  for (  File child : children) {
    if (!child.isDirectory()) {
      continue;
    }
    final String packageName=child.getName();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + packageName);
    }
    if (!user.hasPackage(packageName)) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + packageName);
      }
      cleanupBitmapsForPackage(userId,packageName);
    }
 else {
      cleanupDanglingBitmapFilesLocked(userId,user,packageName,child);
    }
  }
  logDurationStat(Stats.CLEANUP_DANGLING_BITMAPS,start);
}","private void cleanupDanglingBitmapDirectoriesLocked(@UserIdInt int userId){
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + userId);
  }
  final long start=injectElapsedRealtime();
  final ShortcutUser user=getUserShortcutsLocked(userId);
  final File bitmapDir=getUserBitmapFilePath(userId);
  final File[] children=bitmapDir.listFiles();
  if (children == null) {
    return;
  }
  for (  File child : children) {
    if (!child.isDirectory()) {
      continue;
    }
    final String packageName=child.getName();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + packageName);
    }
    if (!user.hasPackage(packageName)) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + packageName);
      }
      cleanupBitmapsForPackage(userId,packageName);
    }
 else {
      cleanupDanglingBitmapFilesLocked(userId,user,packageName,child);
    }
  }
  logDurationStat(Stats.CLEANUP_DANGLING_BITMAPS,start);
}",0.9529085872576176
191119,"@Nullable private ShortcutUser loadUserLocked(@UserIdInt int userId){
  final File path=getUserFile(userId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + path);
  }
  final AtomicFile file=new AtomicFile(path);
  final FileInputStream in;
  try {
    in=file.openRead();
  }
 catch (  FileNotFoundException e) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + path);
    }
    return null;
  }
  try {
    final ShortcutUser ret=loadUserInternal(userId,in,false);
    cleanupDanglingBitmapDirectoriesLocked(userId,ret);
    return ret;
  }
 catch (  IOException|XmlPullParserException e) {
    Slog.e(TAG,""String_Node_Str"" + file.getBaseFile(),e);
    return null;
  }
 finally {
    IoUtils.closeQuietly(in);
  }
}","@Nullable private ShortcutUser loadUserLocked(@UserIdInt int userId){
  final File path=getUserFile(userId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + path);
  }
  final AtomicFile file=new AtomicFile(path);
  final FileInputStream in;
  try {
    in=file.openRead();
  }
 catch (  FileNotFoundException e) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + path);
    }
    return null;
  }
  try {
    final ShortcutUser ret=loadUserInternal(userId,in,false);
    return ret;
  }
 catch (  IOException|XmlPullParserException e) {
    Slog.e(TAG,""String_Node_Str"" + file.getBaseFile(),e);
    return null;
  }
 finally {
    IoUtils.closeQuietly(in);
  }
}",0.9598853868194842
191120,"protected boolean isUserUnlockedL(@UserIdInt int userId){
  return mUnlockedUsers.get(userId);
}","protected boolean isUserUnlockedL(@UserIdInt int userId){
  if (mUnlockedUsers.get(userId)) {
    return true;
  }
  final long token=injectClearCallingIdentity();
  try {
    return mUserManager.isUserUnlockingOrUnlocked(userId);
  }
  finally {
    injectRestoreCallingIdentity(token);
  }
}",0.442159383033419
191121,"private void saveUserLocked(@UserIdInt int userId){
  final File path=getUserFile(userId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + path);
  }
  path.getParentFile().mkdirs();
  final AtomicFile file=new AtomicFile(path);
  FileOutputStream os=null;
  try {
    os=file.startWrite();
    saveUserInternalLocked(userId,os,false);
    file.finishWrite(os);
  }
 catch (  XmlPullParserException|IOException e) {
    Slog.e(TAG,""String_Node_Str"" + file.getBaseFile(),e);
    file.failWrite(os);
  }
}","private void saveUserLocked(@UserIdInt int userId){
  final File path=getUserFile(userId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + path);
  }
  path.getParentFile().mkdirs();
  final AtomicFile file=new AtomicFile(path);
  FileOutputStream os=null;
  try {
    os=file.startWrite();
    saveUserInternalLocked(userId,os,false);
    file.finishWrite(os);
    cleanupDanglingBitmapDirectoriesLocked(userId);
  }
 catch (  XmlPullParserException|IOException e) {
    Slog.e(TAG,""String_Node_Str"" + file.getBaseFile(),e);
    file.failWrite(os);
  }
}",0.9510357815442562
191122,"public void testManifestShortcut_publishOnBroadcast(){
  uninstallPackage(USER_0,CALLING_PACKAGE_1);
  uninstallPackage(USER_0,CALLING_PACKAGE_2);
  uninstallPackage(USER_0,CALLING_PACKAGE_3);
  uninstallPackage(USER_0,CALLING_PACKAGE_4);
  uninstallPackage(USER_10,CALLING_PACKAGE_1);
  uninstallPackage(USER_10,CALLING_PACKAGE_2);
  uninstallPackage(USER_10,CALLING_PACKAGE_3);
  uninstallPackage(USER_10,CALLING_PACKAGE_4);
  mService.handleUnlockUser(USER_0);
  mRunningUsers.put(USER_10,true);
  mService.handleUnlockUser(USER_10);
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_1,ShortcutActivity.class.getName()),R.xml.shortcut_1);
  updatePackageVersion(CALLING_PACKAGE_1,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_1,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_5);
  updatePackageVersion(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  dumpsysOnLogcat(""String_Node_Str"");
  runWithCaller(LAUNCHER_1,USER_0,() -> {
    mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),HANDLE_USER_0);
  }
);
  dumpsysOnLogcat(""String_Node_Str"");
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_2);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertShortcutIds(assertAllImmutable(assertAllPinned(mManager.getPinnedShortcuts())),""String_Node_Str"",""String_Node_Str"");
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllDisabled(list(getCallerShortcut(""String_Node_Str"")));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  mRunningUsers.put(USER_10,false);
  mUnlockedUsers.put(USER_10,false);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(getCallerShortcuts());
  }
);
  mRunningUsers.put(USER_10,true);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(getCallerShortcuts());
  }
);
  mUnlockedUsers.put(USER_10,true);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertShortcutIds(assertAllImmutable(assertAllPinned(mManager.getPinnedShortcuts())),""String_Node_Str"",""String_Node_Str"");
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllDisabled(list(getCallerShortcut(""String_Node_Str"")));
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_5_alt);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName()),R.xml.shortcut_5_reverse);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_0);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName()),R.xml.shortcut_0);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllDisabled(mManager.getPinnedShortcuts()))),""String_Node_Str"",""String_Node_Str"");
  }
);
}","public void testManifestShortcut_publishOnBroadcast(){
  uninstallPackage(USER_0,CALLING_PACKAGE_1);
  uninstallPackage(USER_0,CALLING_PACKAGE_2);
  uninstallPackage(USER_0,CALLING_PACKAGE_3);
  uninstallPackage(USER_0,CALLING_PACKAGE_4);
  uninstallPackage(USER_10,CALLING_PACKAGE_1);
  uninstallPackage(USER_10,CALLING_PACKAGE_2);
  uninstallPackage(USER_10,CALLING_PACKAGE_3);
  uninstallPackage(USER_10,CALLING_PACKAGE_4);
  mService.handleUnlockUser(USER_0);
  mRunningUsers.put(USER_10,true);
  mService.handleUnlockUser(USER_10);
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_1,ShortcutActivity.class.getName()),R.xml.shortcut_1);
  updatePackageVersion(CALLING_PACKAGE_1,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_1,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_5);
  updatePackageVersion(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  dumpsysOnLogcat(""String_Node_Str"");
  runWithCaller(LAUNCHER_1,USER_0,() -> {
    mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),HANDLE_USER_0);
  }
);
  dumpsysOnLogcat(""String_Node_Str"");
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_2);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertShortcutIds(assertAllImmutable(assertAllPinned(mManager.getPinnedShortcuts())),""String_Node_Str"",""String_Node_Str"");
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllDisabled(list(getCallerShortcut(""String_Node_Str"")));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  mService.handleCleanupUser(USER_10);
  mRunningUsers.put(USER_10,false);
  mUnlockedUsers.put(USER_10,false);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(getCallerShortcuts());
  }
);
  mRunningUsers.put(USER_10,true);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(getCallerShortcuts());
  }
);
  mUnlockedUsers.put(USER_10,true);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertShortcutIds(assertAllImmutable(assertAllPinned(mManager.getPinnedShortcuts())),""String_Node_Str"",""String_Node_Str"");
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllDisabled(list(getCallerShortcut(""String_Node_Str"")));
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_5_alt);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName()),R.xml.shortcut_5_reverse);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_0);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName()),R.xml.shortcut_0);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllDisabled(mManager.getPinnedShortcuts()))),""String_Node_Str"",""String_Node_Str"");
  }
);
}",0.9805134549953604
191123,"void removeIcon(@UserIdInt int userId,ShortcutInfo shortcut){
  if (shortcut.getBitmapPath() != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + shortcut.getBitmapPath());
    }
    new File(shortcut.getBitmapPath()).delete();
    shortcut.setBitmapPath(null);
  }
  shortcut.setIconResourceId(0);
  shortcut.setIconResName(null);
  shortcut.clearFlags(ShortcutInfo.FLAG_HAS_ICON_FILE | ShortcutInfo.FLAG_HAS_ICON_RES);
}","void removeIcon(@UserIdInt int userId,ShortcutInfo shortcut){
  shortcut.setIconResourceId(0);
  shortcut.setIconResName(null);
  shortcut.clearFlags(ShortcutInfo.FLAG_HAS_ICON_FILE | ShortcutInfo.FLAG_HAS_ICON_RES);
}",0.6687116564417178
191124,"private void cleanupDanglingBitmapDirectoriesLocked(@UserIdInt int userId,@NonNull ShortcutUser user){
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + userId);
  }
  final long start=injectElapsedRealtime();
  final File bitmapDir=getUserBitmapFilePath(userId);
  final File[] children=bitmapDir.listFiles();
  if (children == null) {
    return;
  }
  for (  File child : children) {
    if (!child.isDirectory()) {
      continue;
    }
    final String packageName=child.getName();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + packageName);
    }
    if (!user.hasPackage(packageName)) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + packageName);
      }
      cleanupBitmapsForPackage(userId,packageName);
    }
 else {
      cleanupDanglingBitmapFilesLocked(userId,user,packageName,child);
    }
  }
  logDurationStat(Stats.CLEANUP_DANGLING_BITMAPS,start);
}","private void cleanupDanglingBitmapDirectoriesLocked(@UserIdInt int userId){
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + userId);
  }
  final long start=injectElapsedRealtime();
  final ShortcutUser user=getUserShortcutsLocked(userId);
  final File bitmapDir=getUserBitmapFilePath(userId);
  final File[] children=bitmapDir.listFiles();
  if (children == null) {
    return;
  }
  for (  File child : children) {
    if (!child.isDirectory()) {
      continue;
    }
    final String packageName=child.getName();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + packageName);
    }
    if (!user.hasPackage(packageName)) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + packageName);
      }
      cleanupBitmapsForPackage(userId,packageName);
    }
 else {
      cleanupDanglingBitmapFilesLocked(userId,user,packageName,child);
    }
  }
  logDurationStat(Stats.CLEANUP_DANGLING_BITMAPS,start);
}",0.9529085872576176
191125,"@Nullable private ShortcutUser loadUserLocked(@UserIdInt int userId){
  final File path=getUserFile(userId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + path);
  }
  final AtomicFile file=new AtomicFile(path);
  final FileInputStream in;
  try {
    in=file.openRead();
  }
 catch (  FileNotFoundException e) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + path);
    }
    return null;
  }
  try {
    final ShortcutUser ret=loadUserInternal(userId,in,false);
    cleanupDanglingBitmapDirectoriesLocked(userId,ret);
    return ret;
  }
 catch (  IOException|XmlPullParserException e) {
    Slog.e(TAG,""String_Node_Str"" + file.getBaseFile(),e);
    return null;
  }
 finally {
    IoUtils.closeQuietly(in);
  }
}","@Nullable private ShortcutUser loadUserLocked(@UserIdInt int userId){
  final File path=getUserFile(userId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + path);
  }
  final AtomicFile file=new AtomicFile(path);
  final FileInputStream in;
  try {
    in=file.openRead();
  }
 catch (  FileNotFoundException e) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + path);
    }
    return null;
  }
  try {
    final ShortcutUser ret=loadUserInternal(userId,in,false);
    return ret;
  }
 catch (  IOException|XmlPullParserException e) {
    Slog.e(TAG,""String_Node_Str"" + file.getBaseFile(),e);
    return null;
  }
 finally {
    IoUtils.closeQuietly(in);
  }
}",0.9598853868194842
191126,"protected boolean isUserUnlockedL(@UserIdInt int userId){
  return mUnlockedUsers.get(userId);
}","protected boolean isUserUnlockedL(@UserIdInt int userId){
  if (mUnlockedUsers.get(userId)) {
    return true;
  }
  final long token=injectClearCallingIdentity();
  try {
    return mUserManager.isUserUnlockingOrUnlocked(userId);
  }
  finally {
    injectRestoreCallingIdentity(token);
  }
}",0.442159383033419
191127,"private void saveUserLocked(@UserIdInt int userId){
  final File path=getUserFile(userId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + path);
  }
  path.getParentFile().mkdirs();
  final AtomicFile file=new AtomicFile(path);
  FileOutputStream os=null;
  try {
    os=file.startWrite();
    saveUserInternalLocked(userId,os,false);
    file.finishWrite(os);
  }
 catch (  XmlPullParserException|IOException e) {
    Slog.e(TAG,""String_Node_Str"" + file.getBaseFile(),e);
    file.failWrite(os);
  }
}","private void saveUserLocked(@UserIdInt int userId){
  final File path=getUserFile(userId);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + path);
  }
  path.getParentFile().mkdirs();
  final AtomicFile file=new AtomicFile(path);
  FileOutputStream os=null;
  try {
    os=file.startWrite();
    saveUserInternalLocked(userId,os,false);
    file.finishWrite(os);
    cleanupDanglingBitmapDirectoriesLocked(userId);
  }
 catch (  XmlPullParserException|IOException e) {
    Slog.e(TAG,""String_Node_Str"" + file.getBaseFile(),e);
    file.failWrite(os);
  }
}",0.9510357815442562
191128,"public void testManifestShortcut_publishOnBroadcast(){
  uninstallPackage(USER_0,CALLING_PACKAGE_1);
  uninstallPackage(USER_0,CALLING_PACKAGE_2);
  uninstallPackage(USER_0,CALLING_PACKAGE_3);
  uninstallPackage(USER_0,CALLING_PACKAGE_4);
  uninstallPackage(USER_10,CALLING_PACKAGE_1);
  uninstallPackage(USER_10,CALLING_PACKAGE_2);
  uninstallPackage(USER_10,CALLING_PACKAGE_3);
  uninstallPackage(USER_10,CALLING_PACKAGE_4);
  mService.handleUnlockUser(USER_0);
  mRunningUsers.put(USER_10,true);
  mService.handleUnlockUser(USER_10);
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_1,ShortcutActivity.class.getName()),R.xml.shortcut_1);
  updatePackageVersion(CALLING_PACKAGE_1,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_1,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_5);
  updatePackageVersion(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  dumpsysOnLogcat(""String_Node_Str"");
  runWithCaller(LAUNCHER_1,USER_0,() -> {
    mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),HANDLE_USER_0);
  }
);
  dumpsysOnLogcat(""String_Node_Str"");
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_2);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertShortcutIds(assertAllImmutable(assertAllPinned(mManager.getPinnedShortcuts())),""String_Node_Str"",""String_Node_Str"");
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllDisabled(list(getCallerShortcut(""String_Node_Str"")));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  mRunningUsers.put(USER_10,false);
  mUnlockedUsers.put(USER_10,false);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(getCallerShortcuts());
  }
);
  mRunningUsers.put(USER_10,true);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(getCallerShortcuts());
  }
);
  mUnlockedUsers.put(USER_10,true);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertShortcutIds(assertAllImmutable(assertAllPinned(mManager.getPinnedShortcuts())),""String_Node_Str"",""String_Node_Str"");
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllDisabled(list(getCallerShortcut(""String_Node_Str"")));
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_5_alt);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName()),R.xml.shortcut_5_reverse);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_0);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName()),R.xml.shortcut_0);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllDisabled(mManager.getPinnedShortcuts()))),""String_Node_Str"",""String_Node_Str"");
  }
);
}","public void testManifestShortcut_publishOnBroadcast(){
  uninstallPackage(USER_0,CALLING_PACKAGE_1);
  uninstallPackage(USER_0,CALLING_PACKAGE_2);
  uninstallPackage(USER_0,CALLING_PACKAGE_3);
  uninstallPackage(USER_0,CALLING_PACKAGE_4);
  uninstallPackage(USER_10,CALLING_PACKAGE_1);
  uninstallPackage(USER_10,CALLING_PACKAGE_2);
  uninstallPackage(USER_10,CALLING_PACKAGE_3);
  uninstallPackage(USER_10,CALLING_PACKAGE_4);
  mService.handleUnlockUser(USER_0);
  mRunningUsers.put(USER_10,true);
  mService.handleUnlockUser(USER_10);
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_1,ShortcutActivity.class.getName()),R.xml.shortcut_1);
  updatePackageVersion(CALLING_PACKAGE_1,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_1,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_5);
  updatePackageVersion(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  dumpsysOnLogcat(""String_Node_Str"");
  runWithCaller(LAUNCHER_1,USER_0,() -> {
    mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),HANDLE_USER_0);
  }
);
  dumpsysOnLogcat(""String_Node_Str"");
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_2);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertShortcutIds(assertAllImmutable(assertAllPinned(mManager.getPinnedShortcuts())),""String_Node_Str"",""String_Node_Str"");
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllDisabled(list(getCallerShortcut(""String_Node_Str"")));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  mService.handleCleanupUser(USER_10);
  mRunningUsers.put(USER_10,false);
  mUnlockedUsers.put(USER_10,false);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(getCallerShortcuts());
  }
);
  mRunningUsers.put(USER_10,true);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertEmpty(getCallerShortcuts());
  }
);
  mUnlockedUsers.put(USER_10,true);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_10));
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertEmpty(mManager.getPinnedShortcuts());
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"");
    assertShortcutIds(assertAllImmutable(assertAllPinned(mManager.getPinnedShortcuts())),""String_Node_Str"",""String_Node_Str"");
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllEnabled(list(getCallerShortcut(""String_Node_Str"")));
    assertAllDisabled(list(getCallerShortcut(""String_Node_Str"")));
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_5_alt);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName()),R.xml.shortcut_5_reverse);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertShortcutIds(assertAllManifest(assertAllImmutable(assertAllEnabled(mManager.getManifestShortcuts()))),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertWith(getCallerShortcuts()).selectManifest().selectByActivity(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName())).haveRanksInOrder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),R.xml.shortcut_0);
  addManifestShortcutResource(new ComponentName(CALLING_PACKAGE_2,ShortcutActivity2.class.getName()),R.xml.shortcut_0);
  updatePackageLastUpdateTime(CALLING_PACKAGE_2,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageAddIntent(CALLING_PACKAGE_2,USER_0));
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertEmpty(mManager.getManifestShortcuts());
    assertShortcutIds(assertAllImmutable(assertAllPinned(assertAllDisabled(mManager.getPinnedShortcuts()))),""String_Node_Str"",""String_Node_Str"");
  }
);
}",0.9805134549953604
191129,"/** 
 * Called to do initial creation of a fragment.  This is called after  {@link #onAttach(Activity)} and before{@link #onCreateView(LayoutInflater,ViewGroup,Bundle)}, but is not called if the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}). <p>Note that this can be called while the fragment's activity is still in the process of being created.  As such, you can not rely on things like the activity's content view hierarchy being initialized at this point.  If you want to do work once the activity itself is created, see   {@link #onActivityCreated(Bundle)}. <p>If your app's <code>targetSdkVersion</code> is 23 or lower, child fragments being restored from the savedInstanceState are restored after <code>onCreate</code> returns. When targeting N or above and running on an N or newer platform version they are restored by <code>Fragment.onCreate</code>.</p>
 * @param savedInstanceState If the fragment is being re-created froma previous saved state, this is the state.
 */
@CallSuper public void onCreate(@Nullable Bundle savedInstanceState){
  mCalled=true;
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version >= Build.VERSION_CODES.N) {
    restoreChildFragmentState(savedInstanceState,true);
    if (mChildFragmentManager != null && !mChildFragmentManager.isStateAtLeast(Fragment.CREATED)) {
      mChildFragmentManager.dispatchCreate();
    }
  }
}","/** 
 * Called to do initial creation of a fragment.  This is called after  {@link #onAttach(Activity)} and before{@link #onCreateView(LayoutInflater,ViewGroup,Bundle)}, but is not called if the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}). <p>Note that this can be called while the fragment's activity is still in the process of being created.  As such, you can not rely on things like the activity's content view hierarchy being initialized at this point.  If you want to do work once the activity itself is created, see   {@link #onActivityCreated(Bundle)}. <p>If your app's <code>targetSdkVersion</code> is   {@link android.os.Build.VERSION_CODES#M}or lower, child fragments being restored from the savedInstanceState are restored after <code>onCreate</code> returns. When targeting @link android.os.Build.VERSION_CODES#N} or above and running on an N or newer platform version they are restored by <code>Fragment.onCreate</code>.</p>
 * @param savedInstanceState If the fragment is being re-created froma previous saved state, this is the state.
 */
@CallSuper public void onCreate(@Nullable Bundle savedInstanceState){
  mCalled=true;
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version >= Build.VERSION_CODES.N) {
    restoreChildFragmentState(savedInstanceState,true);
    if (mChildFragmentManager != null && !mChildFragmentManager.isStateAtLeast(Fragment.CREATED)) {
      mChildFragmentManager.dispatchCreate();
    }
  }
}",0.5890366526110931
191130,"/** 
 * In order to avoid breaking old apps, we only throw exception on invalid VectorDrawable animations * for apps targeting N and later. For older apps, we ignore (i.e. quietly skip) these animations.
 * @return whether invalid animations for vector drawable should be ignored.
 */
private static boolean shouldIgnoreInvalidAnimation(){
  Application app=ActivityThread.currentApplication();
  if (app == null || app.getApplicationInfo() == null) {
    return true;
  }
  if (app.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
    return true;
  }
  return false;
}","/** 
 * In order to avoid breaking old apps, we only throw exception on invalid VectorDrawable animations for apps targeting N and later. For older apps, we ignore (i.e. quietly skip) these animations.
 * @return whether invalid animations for vector drawable should be ignored.
 */
private static boolean shouldIgnoreInvalidAnimation(){
  Application app=ActivityThread.currentApplication();
  if (app == null || app.getApplicationInfo() == null) {
    return true;
  }
  if (app.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
    return true;
  }
  return false;
}",0.9982905982905984
191131,"/** 
 * Called to do initial creation of a fragment.  This is called after  {@link #onAttach(Activity)} and before{@link #onCreateView(LayoutInflater,ViewGroup,Bundle)}, but is not called if the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}). <p>Note that this can be called while the fragment's activity is still in the process of being created.  As such, you can not rely on things like the activity's content view hierarchy being initialized at this point.  If you want to do work once the activity itself is created, see   {@link #onActivityCreated(Bundle)}. <p>If your app's <code>targetSdkVersion</code> is 23 or lower, child fragments being restored from the savedInstanceState are restored after <code>onCreate</code> returns. When targeting N or above and running on an N or newer platform version they are restored by <code>Fragment.onCreate</code>.</p>
 * @param savedInstanceState If the fragment is being re-created froma previous saved state, this is the state.
 */
@CallSuper public void onCreate(@Nullable Bundle savedInstanceState){
  mCalled=true;
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version >= Build.VERSION_CODES.N) {
    restoreChildFragmentState(savedInstanceState,true);
    if (mChildFragmentManager != null && !mChildFragmentManager.isStateAtLeast(Fragment.CREATED)) {
      mChildFragmentManager.dispatchCreate();
    }
  }
}","/** 
 * Called to do initial creation of a fragment.  This is called after  {@link #onAttach(Activity)} and before{@link #onCreateView(LayoutInflater,ViewGroup,Bundle)}, but is not called if the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}). <p>Note that this can be called while the fragment's activity is still in the process of being created.  As such, you can not rely on things like the activity's content view hierarchy being initialized at this point.  If you want to do work once the activity itself is created, see   {@link #onActivityCreated(Bundle)}. <p>If your app's <code>targetSdkVersion</code> is   {@link android.os.Build.VERSION_CODES#M}or lower, child fragments being restored from the savedInstanceState are restored after <code>onCreate</code> returns. When targeting @link android.os.Build.VERSION_CODES#N} or above and running on an N or newer platform version they are restored by <code>Fragment.onCreate</code>.</p>
 * @param savedInstanceState If the fragment is being re-created froma previous saved state, this is the state.
 */
@CallSuper public void onCreate(@Nullable Bundle savedInstanceState){
  mCalled=true;
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version >= Build.VERSION_CODES.N) {
    restoreChildFragmentState(savedInstanceState,true);
    if (mChildFragmentManager != null && !mChildFragmentManager.isStateAtLeast(Fragment.CREATED)) {
      mChildFragmentManager.dispatchCreate();
    }
  }
}",0.5890366526110931
191132,"/** 
 * In order to avoid breaking old apps, we only throw exception on invalid VectorDrawable animations * for apps targeting N and later. For older apps, we ignore (i.e. quietly skip) these animations.
 * @return whether invalid animations for vector drawable should be ignored.
 */
private static boolean shouldIgnoreInvalidAnimation(){
  Application app=ActivityThread.currentApplication();
  if (app == null || app.getApplicationInfo() == null) {
    return true;
  }
  if (app.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
    return true;
  }
  return false;
}","/** 
 * In order to avoid breaking old apps, we only throw exception on invalid VectorDrawable animations for apps targeting N and later. For older apps, we ignore (i.e. quietly skip) these animations.
 * @return whether invalid animations for vector drawable should be ignored.
 */
private static boolean shouldIgnoreInvalidAnimation(){
  Application app=ActivityThread.currentApplication();
  if (app == null || app.getApplicationInfo() == null) {
    return true;
  }
  if (app.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
    return true;
  }
  return false;
}",0.9982905982905984
191133,"/** 
 * @param opPackageName name of package for caller
 * @param foregroundOnly only allow this call while app is in the foreground
 * @return true if caller can use fingerprint API
 */
private boolean canUseFingerprint(String opPackageName,boolean foregroundOnly,int uid,int pid){
  checkPermission(USE_FINGERPRINT);
  if (isKeyguard(opPackageName)) {
    return true;
  }
  if (!isCurrentUserOrProfile(UserHandle.getCallingUserId())) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  if (mAppOps.noteOp(AppOpsManager.OP_USE_FINGERPRINT,uid,opPackageName) != AppOpsManager.MODE_ALLOWED) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  if (foregroundOnly && !isForegroundActivity(uid,pid)) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  return true;
}","/** 
 * @param opPackageName name of package for caller
 * @param requireForeground only allow this call while app is in the foreground
 * @return true if caller can use fingerprint API
 */
private boolean canUseFingerprint(String opPackageName,boolean requireForeground,int uid,int pid){
  checkPermission(USE_FINGERPRINT);
  if (isKeyguard(opPackageName)) {
    return true;
  }
  if (!isCurrentUserOrProfile(UserHandle.getCallingUserId())) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  if (mAppOps.noteOp(AppOpsManager.OP_USE_FINGERPRINT,uid,opPackageName) != AppOpsManager.MODE_ALLOWED) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  if (requireForeground && !(isForegroundActivity(uid,pid) || currentClient(opPackageName))) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  return true;
}",0.9309407286568788
191134,"@Override public void onAnimationEnd(Animator animation){
  if (onFinishedRunnable != null) {
    onFinishedRunnable.run();
  }
  if (!mWasCancelled) {
    enableAppearDrawing(false);
  }
}","@Override public void onAnimationEnd(Animator animation){
  if (onFinishedRunnable != null) {
    onFinishedRunnable.run();
  }
  if (!mWasCancelled) {
    enableAppearDrawing(false);
    onAppearAnimationFinished(isAppearing);
  }
}",0.8957345971563981
191135,"private void startAppearAnimation(boolean isAppearing,float translationDirection,long delay,long duration,final Runnable onFinishedRunnable){
  cancelAppearAnimation();
  mAnimationTranslationY=translationDirection * getActualHeight();
  if (mAppearAnimationFraction == -1.0f) {
    if (isAppearing) {
      mAppearAnimationFraction=0.0f;
      mAppearAnimationTranslation=mAnimationTranslationY;
    }
 else {
      mAppearAnimationFraction=1.0f;
      mAppearAnimationTranslation=0;
    }
  }
  float targetValue;
  if (isAppearing) {
    mCurrentAppearInterpolator=mSlowOutFastInInterpolator;
    mCurrentAlphaInterpolator=Interpolators.LINEAR_OUT_SLOW_IN;
    targetValue=1.0f;
  }
 else {
    mCurrentAppearInterpolator=Interpolators.FAST_OUT_SLOW_IN;
    mCurrentAlphaInterpolator=mSlowOutLinearInInterpolator;
    targetValue=0.0f;
  }
  mAppearAnimator=ValueAnimator.ofFloat(mAppearAnimationFraction,targetValue);
  mAppearAnimator.setInterpolator(Interpolators.LINEAR);
  mAppearAnimator.setDuration((long)(duration * Math.abs(mAppearAnimationFraction - targetValue)));
  mAppearAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      mAppearAnimationFraction=(float)animation.getAnimatedValue();
      updateAppearAnimationAlpha();
      updateAppearRect();
      invalidate();
    }
  }
);
  if (delay > 0) {
    updateAppearAnimationAlpha();
    updateAppearRect();
    mAppearAnimator.setStartDelay(delay);
  }
  mAppearAnimator.addListener(new AnimatorListenerAdapter(){
    private boolean mWasCancelled;
    @Override public void onAnimationEnd(    Animator animation){
      if (onFinishedRunnable != null) {
        onFinishedRunnable.run();
      }
      if (!mWasCancelled) {
        enableAppearDrawing(false);
      }
    }
    @Override public void onAnimationStart(    Animator animation){
      mWasCancelled=false;
    }
    @Override public void onAnimationCancel(    Animator animation){
      mWasCancelled=true;
    }
  }
);
  mAppearAnimator.start();
}","private void startAppearAnimation(boolean isAppearing,float translationDirection,long delay,long duration,final Runnable onFinishedRunnable){
  cancelAppearAnimation();
  mAnimationTranslationY=translationDirection * getActualHeight();
  if (mAppearAnimationFraction == -1.0f) {
    if (isAppearing) {
      mAppearAnimationFraction=0.0f;
      mAppearAnimationTranslation=mAnimationTranslationY;
    }
 else {
      mAppearAnimationFraction=1.0f;
      mAppearAnimationTranslation=0;
    }
  }
  float targetValue;
  if (isAppearing) {
    mCurrentAppearInterpolator=mSlowOutFastInInterpolator;
    mCurrentAlphaInterpolator=Interpolators.LINEAR_OUT_SLOW_IN;
    targetValue=1.0f;
  }
 else {
    mCurrentAppearInterpolator=Interpolators.FAST_OUT_SLOW_IN;
    mCurrentAlphaInterpolator=mSlowOutLinearInInterpolator;
    targetValue=0.0f;
  }
  mAppearAnimator=ValueAnimator.ofFloat(mAppearAnimationFraction,targetValue);
  mAppearAnimator.setInterpolator(Interpolators.LINEAR);
  mAppearAnimator.setDuration((long)(duration * Math.abs(mAppearAnimationFraction - targetValue)));
  mAppearAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      mAppearAnimationFraction=(float)animation.getAnimatedValue();
      updateAppearAnimationAlpha();
      updateAppearRect();
      invalidate();
    }
  }
);
  if (delay > 0) {
    updateAppearAnimationAlpha();
    updateAppearRect();
    mAppearAnimator.setStartDelay(delay);
  }
  mAppearAnimator.addListener(new AnimatorListenerAdapter(){
    private boolean mWasCancelled;
    @Override public void onAnimationEnd(    Animator animation){
      if (onFinishedRunnable != null) {
        onFinishedRunnable.run();
      }
      if (!mWasCancelled) {
        enableAppearDrawing(false);
        onAppearAnimationFinished(isAppearing);
      }
    }
    @Override public void onAnimationStart(    Animator animation){
      mWasCancelled=false;
    }
    @Override public void onAnimationCancel(    Animator animation){
      mWasCancelled=true;
    }
  }
);
  mAppearAnimator.start();
}",0.988582302568982
191136,"@Override protected View getContentView(){
  if (mIsSummaryWithChildren) {
    return mChildrenContainer;
  }
  return getShowingLayout();
}","@Override protected View getContentView(){
  if (mIsSummaryWithChildren && !mShowingPublic) {
    return mChildrenContainer;
  }
  return getShowingLayout();
}",0.9364548494983278
191137,"private NotificationHeaderView getVisibleNotificationHeader(){
  if (mIsSummaryWithChildren) {
    return mChildrenContainer.getHeaderView();
  }
  return getShowingLayout().getVisibleNotificationHeader();
}","private NotificationHeaderView getVisibleNotificationHeader(){
  if (mIsSummaryWithChildren && !mShowingPublic) {
    return mChildrenContainer.getHeaderView();
  }
  return getShowingLayout().getVisibleNotificationHeader();
}",0.9561200923787528
191138,"/** 
 * @param opPackageName name of package for caller
 * @param foregroundOnly only allow this call while app is in the foreground
 * @return true if caller can use fingerprint API
 */
private boolean canUseFingerprint(String opPackageName,boolean foregroundOnly,int uid,int pid){
  checkPermission(USE_FINGERPRINT);
  if (isKeyguard(opPackageName)) {
    return true;
  }
  if (!isCurrentUserOrProfile(UserHandle.getCallingUserId())) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  if (mAppOps.noteOp(AppOpsManager.OP_USE_FINGERPRINT,uid,opPackageName) != AppOpsManager.MODE_ALLOWED) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  if (foregroundOnly && !isForegroundActivity(uid,pid)) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  return true;
}","/** 
 * @param opPackageName name of package for caller
 * @param requireForeground only allow this call while app is in the foreground
 * @return true if caller can use fingerprint API
 */
private boolean canUseFingerprint(String opPackageName,boolean requireForeground,int uid,int pid){
  checkPermission(USE_FINGERPRINT);
  if (isKeyguard(opPackageName)) {
    return true;
  }
  if (!isCurrentUserOrProfile(UserHandle.getCallingUserId())) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  if (mAppOps.noteOp(AppOpsManager.OP_USE_FINGERPRINT,uid,opPackageName) != AppOpsManager.MODE_ALLOWED) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  if (requireForeground && !(isForegroundActivity(uid,pid) || currentClient(opPackageName))) {
    Slog.w(TAG,""String_Node_Str"" + opPackageName + ""String_Node_Str"");
    return false;
  }
  return true;
}",0.9309407286568788
191139,"private void cancelForegroudNotificationLocked(ServiceRecord r){
  if (r.foregroundId != 0) {
    ServiceMap sm=getServiceMap(r.userId);
    if (sm != null) {
      for (int i=sm.mServicesByName.size() - 1; i >= 0; i--) {
        ServiceRecord other=sm.mServicesByName.valueAt(i);
        if (other.foregroundId == r.foregroundId && other.packageName.equals(r.packageName)) {
          return;
        }
      }
    }
    r.cancelNotification();
  }
}","private void cancelForegroudNotificationLocked(ServiceRecord r){
  if (r.foregroundId != 0) {
    ServiceMap sm=getServiceMap(r.userId);
    if (sm != null) {
      for (int i=sm.mServicesByName.size() - 1; i >= 0; i--) {
        ServiceRecord other=sm.mServicesByName.valueAt(i);
        if (other != r && other.foregroundId == r.foregroundId && other.packageName.equals(r.packageName)) {
          return;
        }
      }
    }
    r.cancelNotification();
  }
}",0.9170305676855895
191140,"private void handleNotifyScreenTurnedOff(){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mStatusBarKeyguardViewManager.onScreenTurnedOff();
    mWakeAndUnlocking=false;
  }
}","private void handleNotifyScreenTurnedOff(){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mStatusBarKeyguardViewManager.onScreenTurnedOff();
    mDrawnCallback=null;
    mWakeAndUnlocking=false;
  }
}",0.9422632794457276
191141,"private void handleStartKeyguardExitAnimation(long startTime,long fadeoutDuration){
  Trace.beginSection(""String_Node_Str"");
synchronized (KeyguardViewMediator.this) {
    if (!mHiding) {
      return;
    }
    mHiding=false;
    if (mWakeAndUnlocking && mDrawnCallback != null) {
      mStatusBarKeyguardViewManager.getViewRootImpl().setReportNextDraw();
      notifyDrawn(mDrawnCallback);
    }
    if (TelephonyManager.EXTRA_STATE_IDLE.equals(mPhoneState)) {
      playSounds(false);
    }
    setShowingLocked(false);
    mStatusBarKeyguardViewManager.hide(startTime,fadeoutDuration);
    resetKeyguardDonePendingLocked();
    mHideAnimationRun=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
    sendUserPresentBroadcast();
  }
  Trace.endSection();
}","private void handleStartKeyguardExitAnimation(long startTime,long fadeoutDuration){
  Trace.beginSection(""String_Node_Str"");
synchronized (KeyguardViewMediator.this) {
    if (!mHiding) {
      return;
    }
    mHiding=false;
    if (mWakeAndUnlocking && mDrawnCallback != null) {
      mStatusBarKeyguardViewManager.getViewRootImpl().setReportNextDraw();
      notifyDrawn(mDrawnCallback);
      mDrawnCallback=null;
    }
    if (TelephonyManager.EXTRA_STATE_IDLE.equals(mPhoneState)) {
      playSounds(false);
    }
    mWakeAndUnlocking=false;
    setShowingLocked(false);
    mStatusBarKeyguardViewManager.hide(startTime,fadeoutDuration);
    resetKeyguardDonePendingLocked();
    mHideAnimationRun=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
    sendUserPresentBroadcast();
  }
  Trace.endSection();
}",0.965432098765432
191142,"@Override public void waitForAllWindowsDrawn(Runnable callback,long timeout){
  boolean allWindowsDrawn=false;
synchronized (mWindowMap) {
    mWaitingForDrawnCallback=callback;
    final WindowList windows=getDefaultWindowListLocked();
    for (int winNdx=windows.size() - 1; winNdx >= 0; --winNdx) {
      final WindowState win=windows.get(winNdx);
      final boolean isForceHiding=mPolicy.isForceHiding(win.mAttrs);
      if (win.isVisibleLw() && (win.mAppToken != null || isForceHiding)) {
        win.mWinAnimator.mDrawState=DRAW_PENDING;
        win.mLastContentInsets.set(-1,-1,-1,-1);
        mWaitingForDrawn.add(win);
        if (isForceHiding) {
          break;
        }
      }
    }
    mWindowPlacerLocked.requestTraversal();
    mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    if (mWaitingForDrawn.isEmpty()) {
      allWindowsDrawn=true;
    }
 else {
      mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,timeout);
      checkDrawnWindowsLocked();
    }
  }
  if (allWindowsDrawn) {
    callback.run();
  }
}","@Override public void waitForAllWindowsDrawn(Runnable callback,long timeout){
  boolean allWindowsDrawn=false;
synchronized (mWindowMap) {
    mWaitingForDrawnCallback=callback;
    final WindowList windows=getDefaultWindowListLocked();
    for (int winNdx=windows.size() - 1; winNdx >= 0; --winNdx) {
      final WindowState win=windows.get(winNdx);
      final boolean isForceHiding=mPolicy.isForceHiding(win.mAttrs);
      final boolean keyguard=mPolicy.isKeyguardHostWindow(win.mAttrs);
      if (win.isVisibleLw() && (win.mAppToken != null || isForceHiding || keyguard)) {
        win.mWinAnimator.mDrawState=DRAW_PENDING;
        win.mLastContentInsets.set(-1,-1,-1,-1);
        mWaitingForDrawn.add(win);
        if (isForceHiding) {
          break;
        }
      }
    }
    mWindowPlacerLocked.requestTraversal();
    mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    if (mWaitingForDrawn.isEmpty()) {
      allWindowsDrawn=true;
    }
 else {
      mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,timeout);
      checkDrawnWindowsLocked();
    }
  }
  if (allWindowsDrawn) {
    callback.run();
  }
}",0.961591855622397
191143,"private void cancelForegroudNotificationLocked(ServiceRecord r){
  if (r.foregroundId != 0) {
    ServiceMap sm=getServiceMap(r.userId);
    if (sm != null) {
      for (int i=sm.mServicesByName.size() - 1; i >= 0; i--) {
        ServiceRecord other=sm.mServicesByName.valueAt(i);
        if (other.foregroundId == r.foregroundId && other.packageName.equals(r.packageName)) {
          return;
        }
      }
    }
    r.cancelNotification();
  }
}","private void cancelForegroudNotificationLocked(ServiceRecord r){
  if (r.foregroundId != 0) {
    ServiceMap sm=getServiceMap(r.userId);
    if (sm != null) {
      for (int i=sm.mServicesByName.size() - 1; i >= 0; i--) {
        ServiceRecord other=sm.mServicesByName.valueAt(i);
        if (other != r && other.foregroundId == r.foregroundId && other.packageName.equals(r.packageName)) {
          return;
        }
      }
    }
    r.cancelNotification();
  }
}",0.9170305676855895
191144,"private void cancelForegroudNotificationLocked(ServiceRecord r){
  if (r.foregroundId != 0) {
    ServiceMap sm=getServiceMap(r.userId);
    if (sm != null) {
      for (int i=sm.mServicesByName.size() - 1; i >= 0; i--) {
        ServiceRecord other=sm.mServicesByName.valueAt(i);
        if (other.foregroundId == r.foregroundId && other.packageName.equals(r.packageName)) {
          return;
        }
      }
    }
    r.cancelNotification();
  }
}","private void cancelForegroudNotificationLocked(ServiceRecord r){
  if (r.foregroundId != 0) {
    ServiceMap sm=getServiceMap(r.userId);
    if (sm != null) {
      for (int i=sm.mServicesByName.size() - 1; i >= 0; i--) {
        ServiceRecord other=sm.mServicesByName.valueAt(i);
        if (other != r && other.foregroundId == r.foregroundId && other.packageName.equals(r.packageName)) {
          return;
        }
      }
    }
    r.cancelNotification();
  }
}",0.9170305676855895
191145,"private void handleNotifyScreenTurnedOff(){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mStatusBarKeyguardViewManager.onScreenTurnedOff();
    mWakeAndUnlocking=false;
  }
}","private void handleNotifyScreenTurnedOff(){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mStatusBarKeyguardViewManager.onScreenTurnedOff();
    mDrawnCallback=null;
    mWakeAndUnlocking=false;
  }
}",0.9422632794457276
191146,"private void handleStartKeyguardExitAnimation(long startTime,long fadeoutDuration){
  Trace.beginSection(""String_Node_Str"");
synchronized (KeyguardViewMediator.this) {
    if (!mHiding) {
      return;
    }
    mHiding=false;
    if (mWakeAndUnlocking && mDrawnCallback != null) {
      mStatusBarKeyguardViewManager.getViewRootImpl().setReportNextDraw();
      notifyDrawn(mDrawnCallback);
    }
    if (TelephonyManager.EXTRA_STATE_IDLE.equals(mPhoneState)) {
      playSounds(false);
    }
    setShowingLocked(false);
    mStatusBarKeyguardViewManager.hide(startTime,fadeoutDuration);
    resetKeyguardDonePendingLocked();
    mHideAnimationRun=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
    sendUserPresentBroadcast();
  }
  Trace.endSection();
}","private void handleStartKeyguardExitAnimation(long startTime,long fadeoutDuration){
  Trace.beginSection(""String_Node_Str"");
synchronized (KeyguardViewMediator.this) {
    if (!mHiding) {
      return;
    }
    mHiding=false;
    if (mWakeAndUnlocking && mDrawnCallback != null) {
      mStatusBarKeyguardViewManager.getViewRootImpl().setReportNextDraw();
      notifyDrawn(mDrawnCallback);
      mDrawnCallback=null;
    }
    if (TelephonyManager.EXTRA_STATE_IDLE.equals(mPhoneState)) {
      playSounds(false);
    }
    mWakeAndUnlocking=false;
    setShowingLocked(false);
    mStatusBarKeyguardViewManager.hide(startTime,fadeoutDuration);
    resetKeyguardDonePendingLocked();
    mHideAnimationRun=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
    sendUserPresentBroadcast();
  }
  Trace.endSection();
}",0.965432098765432
191147,"@Override public void waitForAllWindowsDrawn(Runnable callback,long timeout){
  boolean allWindowsDrawn=false;
synchronized (mWindowMap) {
    mWaitingForDrawnCallback=callback;
    final WindowList windows=getDefaultWindowListLocked();
    for (int winNdx=windows.size() - 1; winNdx >= 0; --winNdx) {
      final WindowState win=windows.get(winNdx);
      final boolean isForceHiding=mPolicy.isForceHiding(win.mAttrs);
      if (win.isVisibleLw() && (win.mAppToken != null || isForceHiding)) {
        win.mWinAnimator.mDrawState=DRAW_PENDING;
        win.mLastContentInsets.set(-1,-1,-1,-1);
        mWaitingForDrawn.add(win);
        if (isForceHiding) {
          break;
        }
      }
    }
    mWindowPlacerLocked.requestTraversal();
    mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    if (mWaitingForDrawn.isEmpty()) {
      allWindowsDrawn=true;
    }
 else {
      mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,timeout);
      checkDrawnWindowsLocked();
    }
  }
  if (allWindowsDrawn) {
    callback.run();
  }
}","@Override public void waitForAllWindowsDrawn(Runnable callback,long timeout){
  boolean allWindowsDrawn=false;
synchronized (mWindowMap) {
    mWaitingForDrawnCallback=callback;
    final WindowList windows=getDefaultWindowListLocked();
    for (int winNdx=windows.size() - 1; winNdx >= 0; --winNdx) {
      final WindowState win=windows.get(winNdx);
      final boolean isForceHiding=mPolicy.isForceHiding(win.mAttrs);
      final boolean keyguard=mPolicy.isKeyguardHostWindow(win.mAttrs);
      if (win.isVisibleLw() && (win.mAppToken != null || isForceHiding || keyguard)) {
        win.mWinAnimator.mDrawState=DRAW_PENDING;
        win.mLastContentInsets.set(-1,-1,-1,-1);
        mWaitingForDrawn.add(win);
        if (isForceHiding) {
          break;
        }
      }
    }
    mWindowPlacerLocked.requestTraversal();
    mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    if (mWaitingForDrawn.isEmpty()) {
      allWindowsDrawn=true;
    }
 else {
      mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,timeout);
      checkDrawnWindowsLocked();
    }
  }
  if (allWindowsDrawn) {
    callback.run();
  }
}",0.961591855622397
191148,"private void updateSuppression(NotificationGroup group){
  if (group == null) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    mListener.onGroupsChanged();
  }
}","private void updateSuppression(NotificationGroup group){
  if (group == null || mUpdatingSuppressionBlocked) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    mListener.onGroupsChanged();
  }
}",0.97163769441903
191149,"public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    String oldKey=oldNotification.getGroupKey();
    String newKey=entry.notification.getGroupKey();
    if (!oldKey.equals(newKey)) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!isGroupChild(oldNotification) && isGroupChild(entry.notification)) {
    onEntryBecomingChild(entry);
  }
}","public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  String oldKey=oldNotification.getGroupKey();
  String newKey=entry.notification.getGroupKey();
  boolean groupKeysChanged=!oldKey.equals(newKey);
  boolean wasGroupChild=isGroupChild(oldNotification);
  boolean isGroupChild=isGroupChild(entry.notification);
  mUpdatingSuppressionBlocked=!groupKeysChanged && wasGroupChild == isGroupChild;
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  mUpdatingSuppressionBlocked=false;
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    if (groupKeysChanged) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!wasGroupChild && isGroupChild) {
    onEntryBecomingChild(entry);
  }
}",0.5061728395061729
191150,"private void updateSuppression(NotificationGroup group){
  if (group == null) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    mListener.onGroupsChanged();
  }
}","private void updateSuppression(NotificationGroup group){
  if (group == null || mUpdatingSuppressionBlocked) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    mListener.onGroupsChanged();
  }
}",0.97163769441903
191151,"public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    String oldKey=oldNotification.getGroupKey();
    String newKey=entry.notification.getGroupKey();
    if (!oldKey.equals(newKey)) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!isGroupChild(oldNotification) && isGroupChild(entry.notification)) {
    onEntryBecomingChild(entry);
  }
}","public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  String oldKey=oldNotification.getGroupKey();
  String newKey=entry.notification.getGroupKey();
  boolean groupKeysChanged=!oldKey.equals(newKey);
  boolean wasGroupChild=isGroupChild(oldNotification);
  boolean isGroupChild=isGroupChild(entry.notification);
  mUpdatingSuppressionBlocked=!groupKeysChanged && wasGroupChild == isGroupChild;
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  mUpdatingSuppressionBlocked=false;
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    if (groupKeysChanged) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!wasGroupChild && isGroupChild) {
    onEntryBecomingChild(entry);
  }
}",0.5061728395061729
191152,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageUninstalledLocked(ssp);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_PACKAGE_DATA_CLEARED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageDataClearedLocked(ssp);
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
if (resultTo != null) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
try {
queue.performReceiveLocked(callerApp,resultTo,intent,Activity.RESULT_CANCELED,null,null,false,false,userId);
}
 catch (RemoteException e) {
Slog.w(TAG,""String_Node_Str"" + queue.mQueueName + ""String_Node_Str""+ intent,e);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (!isCallerSystem) {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageUninstalledLocked(ssp);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_PACKAGE_DATA_CLEARED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageDataClearedLocked(ssp);
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
if (resultTo != null) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
try {
queue.performReceiveLocked(callerApp,resultTo,intent,Activity.RESULT_CANCELED,null,null,false,false,userId);
}
 catch (RemoteException e) {
Slog.w(TAG,""String_Node_Str"" + queue.mQueueName + ""String_Node_Str""+ intent,e);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
if (isCallerSystem) {
checkBroadcastFromSystem(intent,callerApp,callerPackage,callingUid,isProtectedBroadcast,registeredReceivers);
}
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if (isCallerSystem) {
checkBroadcastFromSystem(intent,callerApp,callerPackage,callingUid,isProtectedBroadcast,receivers);
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.963194465515672
191153,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageUninstalledLocked(ssp);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_PACKAGE_DATA_CLEARED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageDataClearedLocked(ssp);
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
if (resultTo != null) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
try {
queue.performReceiveLocked(callerApp,resultTo,intent,Activity.RESULT_CANCELED,null,null,false,false,userId);
}
 catch (RemoteException e) {
Slog.w(TAG,""String_Node_Str"" + queue.mQueueName + ""String_Node_Str""+ intent,e);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (!isCallerSystem) {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageUninstalledLocked(ssp);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_PACKAGE_DATA_CLEARED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageDataClearedLocked(ssp);
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
if (resultTo != null) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
try {
queue.performReceiveLocked(callerApp,resultTo,intent,Activity.RESULT_CANCELED,null,null,false,false,userId);
}
 catch (RemoteException e) {
Slog.w(TAG,""String_Node_Str"" + queue.mQueueName + ""String_Node_Str""+ intent,e);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
if (isCallerSystem) {
checkBroadcastFromSystem(intent,callerApp,callerPackage,callingUid,isProtectedBroadcast,registeredReceivers);
}
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if (isCallerSystem) {
checkBroadcastFromSystem(intent,callerApp,callerPackage,callingUid,isProtectedBroadcast,receivers);
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.963194465515672
191154,"public void setServiceForegroundLocked(ComponentName className,IBinder token,int id,Notification notification,int flags){
  final int userId=UserHandle.getCallingUserId();
  final long origId=Binder.clearCallingIdentity();
  try {
    ServiceRecord r=findServiceLocked(className,token,userId);
    if (r != null) {
      if (id != 0) {
        if (notification == null) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        if (r.foregroundId != id) {
          r.cancelNotification();
          r.foregroundId=id;
        }
        notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
        r.foregroundNoti=notification;
        r.isForeground=true;
        r.postNotification();
        if (r.app != null) {
          updateServiceForegroundLocked(r.app,true);
        }
        getServiceMap(r.userId).ensureNotStartingBackground(r);
        mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_FOREGROUND_SERVICE);
      }
 else {
        if (r.isForeground) {
          r.isForeground=false;
          if (r.app != null) {
            mAm.updateLruProcessLocked(r.app,false,null);
            updateServiceForegroundLocked(r.app,true);
          }
        }
        if ((flags & Service.STOP_FOREGROUND_REMOVE) != 0) {
          r.cancelNotification();
          r.foregroundId=0;
          r.foregroundNoti=null;
        }
 else         if (r.appInfo.targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
          r.stripForegroundServiceFlagFromNotification();
          if ((flags & Service.STOP_FOREGROUND_DETACH) != 0) {
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForegroundLocked(ComponentName className,IBinder token,int id,Notification notification,int flags){
  final int userId=UserHandle.getCallingUserId();
  final long origId=Binder.clearCallingIdentity();
  try {
    ServiceRecord r=findServiceLocked(className,token,userId);
    if (r != null) {
      if (id != 0) {
        if (notification == null) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        if (r.foregroundId != id) {
          cancelForegroudNotificationLocked(r);
          r.foregroundId=id;
        }
        notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
        r.foregroundNoti=notification;
        r.isForeground=true;
        r.postNotification();
        if (r.app != null) {
          updateServiceForegroundLocked(r.app,true);
        }
        getServiceMap(r.userId).ensureNotStartingBackground(r);
        mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_FOREGROUND_SERVICE);
      }
 else {
        if (r.isForeground) {
          r.isForeground=false;
          if (r.app != null) {
            mAm.updateLruProcessLocked(r.app,false,null);
            updateServiceForegroundLocked(r.app,true);
          }
        }
        if ((flags & Service.STOP_FOREGROUND_REMOVE) != 0) {
          cancelForegroudNotificationLocked(r);
          r.foregroundId=0;
          r.foregroundNoti=null;
        }
 else         if (r.appInfo.targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
          r.stripForegroundServiceFlagFromNotification();
          if ((flags & Service.STOP_FOREGROUND_DETACH) != 0) {
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}",0.9684684684684683
191155,"private final boolean scheduleServiceRestartLocked(ServiceRecord r,boolean allowCancel){
  boolean canceled=false;
  if (mAm.isShuttingDownLocked()) {
    Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str"");
    return false;
  }
  ServiceMap smap=getServiceMap(r.userId);
  if (smap.mServicesByName.get(r.name) != r) {
    ServiceRecord cur=smap.mServicesByName.get(r.name);
    Slog.wtf(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ cur);
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if ((r.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
    long minDuration=SERVICE_RESTART_DURATION;
    long resetTime=SERVICE_RESET_RUN_DURATION;
    final int N=r.deliveredStarts.size();
    if (N > 0) {
      for (int i=N - 1; i >= 0; i--) {
        ServiceRecord.StartItem si=r.deliveredStarts.get(i);
        si.removeUriPermissionsLocked();
        if (si.intent == null) {
        }
 else         if (!allowCancel || (si.deliveryCount < ServiceRecord.MAX_DELIVERY_COUNT && si.doneExecutingCount < ServiceRecord.MAX_DONE_EXECUTING_COUNT)) {
          r.pendingStarts.add(0,si);
          long dur=SystemClock.uptimeMillis() - si.deliveredTime;
          dur*=2;
          if (minDuration < dur)           minDuration=dur;
          if (resetTime < dur)           resetTime=dur;
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + si.intent + ""String_Node_Str""+ r.name);
          canceled=true;
        }
      }
      r.deliveredStarts.clear();
    }
    r.totalRestartCount++;
    if (r.restartDelay == 0) {
      r.restartCount++;
      r.restartDelay=minDuration;
    }
 else {
      if (now > (r.restartTime + resetTime)) {
        r.restartCount=1;
        r.restartDelay=minDuration;
      }
 else {
        r.restartDelay*=SERVICE_RESTART_DURATION_FACTOR;
        if (r.restartDelay < minDuration) {
          r.restartDelay=minDuration;
        }
      }
    }
    r.nextRestartTime=now + r.restartDelay;
    boolean repeat;
    do {
      repeat=false;
      for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
        ServiceRecord r2=mRestartingServices.get(i);
        if (r2 != r && r.nextRestartTime >= (r2.nextRestartTime - SERVICE_MIN_RESTART_TIME_BETWEEN) && r.nextRestartTime < (r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN)) {
          r.nextRestartTime=r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN;
          r.restartDelay=r.nextRestartTime - now;
          repeat=true;
          break;
        }
      }
    }
 while (repeat);
  }
 else {
    r.totalRestartCount++;
    r.restartCount=0;
    r.restartDelay=0;
    r.nextRestartTime=now;
  }
  if (!mRestartingServices.contains(r)) {
    r.createdFromFg=false;
    mRestartingServices.add(r);
    r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(),now);
  }
  r.cancelNotification();
  mAm.mHandler.removeCallbacks(r.restarter);
  mAm.mHandler.postAtTime(r.restarter,r.nextRestartTime);
  r.nextRestartTime=SystemClock.uptimeMillis() + r.restartDelay;
  Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ r.restartDelay+ ""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.AM_SCHEDULE_SERVICE_RESTART,r.userId,r.shortName,r.restartDelay);
  return canceled;
}","private final boolean scheduleServiceRestartLocked(ServiceRecord r,boolean allowCancel){
  boolean canceled=false;
  if (mAm.isShuttingDownLocked()) {
    Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str"");
    return false;
  }
  ServiceMap smap=getServiceMap(r.userId);
  if (smap.mServicesByName.get(r.name) != r) {
    ServiceRecord cur=smap.mServicesByName.get(r.name);
    Slog.wtf(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ cur);
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if ((r.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
    long minDuration=SERVICE_RESTART_DURATION;
    long resetTime=SERVICE_RESET_RUN_DURATION;
    final int N=r.deliveredStarts.size();
    if (N > 0) {
      for (int i=N - 1; i >= 0; i--) {
        ServiceRecord.StartItem si=r.deliveredStarts.get(i);
        si.removeUriPermissionsLocked();
        if (si.intent == null) {
        }
 else         if (!allowCancel || (si.deliveryCount < ServiceRecord.MAX_DELIVERY_COUNT && si.doneExecutingCount < ServiceRecord.MAX_DONE_EXECUTING_COUNT)) {
          r.pendingStarts.add(0,si);
          long dur=SystemClock.uptimeMillis() - si.deliveredTime;
          dur*=2;
          if (minDuration < dur)           minDuration=dur;
          if (resetTime < dur)           resetTime=dur;
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + si.intent + ""String_Node_Str""+ r.name);
          canceled=true;
        }
      }
      r.deliveredStarts.clear();
    }
    r.totalRestartCount++;
    if (r.restartDelay == 0) {
      r.restartCount++;
      r.restartDelay=minDuration;
    }
 else {
      if (now > (r.restartTime + resetTime)) {
        r.restartCount=1;
        r.restartDelay=minDuration;
      }
 else {
        r.restartDelay*=SERVICE_RESTART_DURATION_FACTOR;
        if (r.restartDelay < minDuration) {
          r.restartDelay=minDuration;
        }
      }
    }
    r.nextRestartTime=now + r.restartDelay;
    boolean repeat;
    do {
      repeat=false;
      for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
        ServiceRecord r2=mRestartingServices.get(i);
        if (r2 != r && r.nextRestartTime >= (r2.nextRestartTime - SERVICE_MIN_RESTART_TIME_BETWEEN) && r.nextRestartTime < (r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN)) {
          r.nextRestartTime=r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN;
          r.restartDelay=r.nextRestartTime - now;
          repeat=true;
          break;
        }
      }
    }
 while (repeat);
  }
 else {
    r.totalRestartCount++;
    r.restartCount=0;
    r.restartDelay=0;
    r.nextRestartTime=now;
  }
  if (!mRestartingServices.contains(r)) {
    r.createdFromFg=false;
    mRestartingServices.add(r);
    r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(),now);
  }
  cancelForegroudNotificationLocked(r);
  mAm.mHandler.removeCallbacks(r.restarter);
  mAm.mHandler.postAtTime(r.restarter,r.nextRestartTime);
  r.nextRestartTime=SystemClock.uptimeMillis() + r.restartDelay;
  Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ r.restartDelay+ ""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.AM_SCHEDULE_SERVICE_RESTART,r.userId,r.shortName,r.restartDelay);
  return canceled;
}",0.995079950799508
191156,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.whitelistManager) {
      updateWhitelistManagerLocked(r.app);
    }
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  cancelForegroudNotificationLocked(r);
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.whitelistManager) {
      updateWhitelistManagerLocked(r.app);
    }
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}",0.9953943580886586
191157,"public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotificationWithTag(localPackageName,null,localForegroundId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void cancelNotification(){
  final String localPackageName=packageName;
  final int localForegroundId=foregroundId;
  ams.mHandler.post(new Runnable(){
    public void run(){
      INotificationManager inm=NotificationManager.getService();
      if (inm == null) {
        return;
      }
      try {
        inm.cancelNotificationWithTag(localPackageName,null,localForegroundId,userId);
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
catch (      RemoteException e) {
      }
    }
  }
);
}",0.8865800865800866
191158,"public void setServiceForegroundLocked(ComponentName className,IBinder token,int id,Notification notification,int flags){
  final int userId=UserHandle.getCallingUserId();
  final long origId=Binder.clearCallingIdentity();
  try {
    ServiceRecord r=findServiceLocked(className,token,userId);
    if (r != null) {
      if (id != 0) {
        if (notification == null) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        if (r.foregroundId != id) {
          r.cancelNotification();
          r.foregroundId=id;
        }
        notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
        r.foregroundNoti=notification;
        r.isForeground=true;
        r.postNotification();
        if (r.app != null) {
          updateServiceForegroundLocked(r.app,true);
        }
        getServiceMap(r.userId).ensureNotStartingBackground(r);
        mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_FOREGROUND_SERVICE);
      }
 else {
        if (r.isForeground) {
          r.isForeground=false;
          if (r.app != null) {
            mAm.updateLruProcessLocked(r.app,false,null);
            updateServiceForegroundLocked(r.app,true);
          }
        }
        if ((flags & Service.STOP_FOREGROUND_REMOVE) != 0) {
          r.cancelNotification();
          r.foregroundId=0;
          r.foregroundNoti=null;
        }
 else         if (r.appInfo.targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
          r.stripForegroundServiceFlagFromNotification();
          if ((flags & Service.STOP_FOREGROUND_DETACH) != 0) {
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForegroundLocked(ComponentName className,IBinder token,int id,Notification notification,int flags){
  final int userId=UserHandle.getCallingUserId();
  final long origId=Binder.clearCallingIdentity();
  try {
    ServiceRecord r=findServiceLocked(className,token,userId);
    if (r != null) {
      if (id != 0) {
        if (notification == null) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        if (r.foregroundId != id) {
          cancelForegroudNotificationLocked(r);
          r.foregroundId=id;
        }
        notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
        r.foregroundNoti=notification;
        r.isForeground=true;
        r.postNotification();
        if (r.app != null) {
          updateServiceForegroundLocked(r.app,true);
        }
        getServiceMap(r.userId).ensureNotStartingBackground(r);
        mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_FOREGROUND_SERVICE);
      }
 else {
        if (r.isForeground) {
          r.isForeground=false;
          if (r.app != null) {
            mAm.updateLruProcessLocked(r.app,false,null);
            updateServiceForegroundLocked(r.app,true);
          }
        }
        if ((flags & Service.STOP_FOREGROUND_REMOVE) != 0) {
          cancelForegroudNotificationLocked(r);
          r.foregroundId=0;
          r.foregroundNoti=null;
        }
 else         if (r.appInfo.targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
          r.stripForegroundServiceFlagFromNotification();
          if ((flags & Service.STOP_FOREGROUND_DETACH) != 0) {
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}",0.9684684684684683
191159,"private final boolean scheduleServiceRestartLocked(ServiceRecord r,boolean allowCancel){
  boolean canceled=false;
  if (mAm.isShuttingDownLocked()) {
    Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str"");
    return false;
  }
  ServiceMap smap=getServiceMap(r.userId);
  if (smap.mServicesByName.get(r.name) != r) {
    ServiceRecord cur=smap.mServicesByName.get(r.name);
    Slog.wtf(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ cur);
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if ((r.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
    long minDuration=SERVICE_RESTART_DURATION;
    long resetTime=SERVICE_RESET_RUN_DURATION;
    final int N=r.deliveredStarts.size();
    if (N > 0) {
      for (int i=N - 1; i >= 0; i--) {
        ServiceRecord.StartItem si=r.deliveredStarts.get(i);
        si.removeUriPermissionsLocked();
        if (si.intent == null) {
        }
 else         if (!allowCancel || (si.deliveryCount < ServiceRecord.MAX_DELIVERY_COUNT && si.doneExecutingCount < ServiceRecord.MAX_DONE_EXECUTING_COUNT)) {
          r.pendingStarts.add(0,si);
          long dur=SystemClock.uptimeMillis() - si.deliveredTime;
          dur*=2;
          if (minDuration < dur)           minDuration=dur;
          if (resetTime < dur)           resetTime=dur;
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + si.intent + ""String_Node_Str""+ r.name);
          canceled=true;
        }
      }
      r.deliveredStarts.clear();
    }
    r.totalRestartCount++;
    if (r.restartDelay == 0) {
      r.restartCount++;
      r.restartDelay=minDuration;
    }
 else {
      if (now > (r.restartTime + resetTime)) {
        r.restartCount=1;
        r.restartDelay=minDuration;
      }
 else {
        r.restartDelay*=SERVICE_RESTART_DURATION_FACTOR;
        if (r.restartDelay < minDuration) {
          r.restartDelay=minDuration;
        }
      }
    }
    r.nextRestartTime=now + r.restartDelay;
    boolean repeat;
    do {
      repeat=false;
      for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
        ServiceRecord r2=mRestartingServices.get(i);
        if (r2 != r && r.nextRestartTime >= (r2.nextRestartTime - SERVICE_MIN_RESTART_TIME_BETWEEN) && r.nextRestartTime < (r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN)) {
          r.nextRestartTime=r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN;
          r.restartDelay=r.nextRestartTime - now;
          repeat=true;
          break;
        }
      }
    }
 while (repeat);
  }
 else {
    r.totalRestartCount++;
    r.restartCount=0;
    r.restartDelay=0;
    r.nextRestartTime=now;
  }
  if (!mRestartingServices.contains(r)) {
    r.createdFromFg=false;
    mRestartingServices.add(r);
    r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(),now);
  }
  r.cancelNotification();
  mAm.mHandler.removeCallbacks(r.restarter);
  mAm.mHandler.postAtTime(r.restarter,r.nextRestartTime);
  r.nextRestartTime=SystemClock.uptimeMillis() + r.restartDelay;
  Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ r.restartDelay+ ""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.AM_SCHEDULE_SERVICE_RESTART,r.userId,r.shortName,r.restartDelay);
  return canceled;
}","private final boolean scheduleServiceRestartLocked(ServiceRecord r,boolean allowCancel){
  boolean canceled=false;
  if (mAm.isShuttingDownLocked()) {
    Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str"");
    return false;
  }
  ServiceMap smap=getServiceMap(r.userId);
  if (smap.mServicesByName.get(r.name) != r) {
    ServiceRecord cur=smap.mServicesByName.get(r.name);
    Slog.wtf(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ cur);
    return false;
  }
  final long now=SystemClock.uptimeMillis();
  if ((r.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
    long minDuration=SERVICE_RESTART_DURATION;
    long resetTime=SERVICE_RESET_RUN_DURATION;
    final int N=r.deliveredStarts.size();
    if (N > 0) {
      for (int i=N - 1; i >= 0; i--) {
        ServiceRecord.StartItem si=r.deliveredStarts.get(i);
        si.removeUriPermissionsLocked();
        if (si.intent == null) {
        }
 else         if (!allowCancel || (si.deliveryCount < ServiceRecord.MAX_DELIVERY_COUNT && si.doneExecutingCount < ServiceRecord.MAX_DONE_EXECUTING_COUNT)) {
          r.pendingStarts.add(0,si);
          long dur=SystemClock.uptimeMillis() - si.deliveredTime;
          dur*=2;
          if (minDuration < dur)           minDuration=dur;
          if (resetTime < dur)           resetTime=dur;
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + si.intent + ""String_Node_Str""+ r.name);
          canceled=true;
        }
      }
      r.deliveredStarts.clear();
    }
    r.totalRestartCount++;
    if (r.restartDelay == 0) {
      r.restartCount++;
      r.restartDelay=minDuration;
    }
 else {
      if (now > (r.restartTime + resetTime)) {
        r.restartCount=1;
        r.restartDelay=minDuration;
      }
 else {
        r.restartDelay*=SERVICE_RESTART_DURATION_FACTOR;
        if (r.restartDelay < minDuration) {
          r.restartDelay=minDuration;
        }
      }
    }
    r.nextRestartTime=now + r.restartDelay;
    boolean repeat;
    do {
      repeat=false;
      for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
        ServiceRecord r2=mRestartingServices.get(i);
        if (r2 != r && r.nextRestartTime >= (r2.nextRestartTime - SERVICE_MIN_RESTART_TIME_BETWEEN) && r.nextRestartTime < (r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN)) {
          r.nextRestartTime=r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN;
          r.restartDelay=r.nextRestartTime - now;
          repeat=true;
          break;
        }
      }
    }
 while (repeat);
  }
 else {
    r.totalRestartCount++;
    r.restartCount=0;
    r.restartDelay=0;
    r.nextRestartTime=now;
  }
  if (!mRestartingServices.contains(r)) {
    r.createdFromFg=false;
    mRestartingServices.add(r);
    r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(),now);
  }
  cancelForegroudNotificationLocked(r);
  mAm.mHandler.removeCallbacks(r.restarter);
  mAm.mHandler.postAtTime(r.restarter,r.nextRestartTime);
  r.nextRestartTime=SystemClock.uptimeMillis() + r.restartDelay;
  Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ r.restartDelay+ ""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.AM_SCHEDULE_SERVICE_RESTART,r.userId,r.shortName,r.restartDelay);
  return canceled;
}",0.995079950799508
191160,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.whitelistManager) {
      updateWhitelistManagerLocked(r.app);
    }
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  cancelForegroudNotificationLocked(r);
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.whitelistManager) {
      updateWhitelistManagerLocked(r.app);
    }
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}",0.9953943580886586
191161,"public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotificationWithTag(localPackageName,null,localForegroundId,userId);
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void cancelNotification(){
  final String localPackageName=packageName;
  final int localForegroundId=foregroundId;
  ams.mHandler.post(new Runnable(){
    public void run(){
      INotificationManager inm=NotificationManager.getService();
      if (inm == null) {
        return;
      }
      try {
        inm.cancelNotificationWithTag(localPackageName,null,localForegroundId,userId);
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
catch (      RemoteException e) {
      }
    }
  }
);
}",0.8865800865800866
191162,"public void setTouchDisabled(boolean disabled){
  mTouchDisabled=disabled;
}","public void setTouchDisabled(boolean disabled){
  mTouchDisabled=disabled;
  if (mTouchDisabled && mTracking) {
    onTrackingStopped(true);
  }
}",0.6846846846846847
191163,"protected void updateBackgroundAlpha(float transformationAmount){
  mBgAlpha=isChildInGroup() && mDimmed ? transformationAmount : 1f;
  mBackgroundDimmed.setAlpha(mBgAlpha);
}","protected void updateBackgroundAlpha(float transformationAmount){
  mBgAlpha=isChildInGroup() && mDimmed ? transformationAmount : 1f;
  if (mDimmedBackgroundFadeInAmount != -1) {
    mBgAlpha*=mDimmedBackgroundFadeInAmount;
  }
  mBackgroundDimmed.setAlpha(mBgAlpha);
}",0.7882882882882883
191164,"public void setUserLocked(boolean userLocked){
  mUserLocked=userLocked;
  mPrivateLayout.setUserExpanding(userLocked);
  if (mIsSummaryWithChildren) {
    mChildrenContainer.setUserLocked(userLocked);
    if (userLocked || (!userLocked && !isGroupExpanded())) {
      updateBackgroundForGroupState();
    }
  }
}","public void setUserLocked(boolean userLocked){
  mUserLocked=userLocked;
  mPrivateLayout.setUserExpanding(userLocked);
  if (mIsSummaryWithChildren) {
    mChildrenContainer.setUserLocked(userLocked);
    if (userLocked || !isGroupExpanded()) {
      updateBackgroundForGroupState();
    }
  }
}",0.9720853858784894
191165,"protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
    final String pkg=sbn.getPackageName();
    String appname=pkg;
    try {
      final ApplicationInfo info=pmUser.getApplicationInfo(pkg,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      if (info != null) {
        appname=String.valueOf(pmUser.getApplicationLabel(info));
      }
    }
 catch (    NameNotFoundException e) {
    }
    row.setAppName(appname);
  }
  workAroundBadLayerDrawableOpacity(row);
  View vetoButton=bindVetoButtonClickListener(row,sbn);
  vetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}","protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
    final String pkg=sbn.getPackageName();
    String appname=pkg;
    try {
      final ApplicationInfo info=pmUser.getApplicationInfo(pkg,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      if (info != null) {
        appname=String.valueOf(pmUser.getApplicationLabel(info));
      }
    }
 catch (    NameNotFoundException e) {
    }
    row.setAppName(appname);
  }
  workAroundBadLayerDrawableOpacity(row);
  bindDismissListener(row);
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}",0.984725050916497
191166,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
    mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  bindVetoButtonClickListener(entry.row,notification);
  if (!notification.isClearable()) {
    mStackScroller.snapViewIfNeeded(entry.row);
  }
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
    mRemoteInputEntriesToRemoveOnCollapse.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,StatusBarIconView.contentDescForNotification(mContext,n));
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  if (!notification.isClearable()) {
    mStackScroller.snapViewIfNeeded(entry.row);
  }
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.989093793376958
191167,"public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  updateClearability();
  if (mIsSummaryWithChildren) {
    mChildrenContainer.recreateNotificationHeader(mExpandClickListener,mEntry.notification);
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  if (mIsSummaryWithChildren) {
    mChildrenContainer.recreateNotificationHeader(mExpandClickListener,mEntry.notification);
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}",0.9835841313269492
191168,"private boolean canViewBeDismissed(){
  return isClearable() && (!mShowingPublic || !mSensitiveHiddenInGeneral);
}","/** 
 * @return Whether this view is allowed to be dismissed. Only valid for visible notifications asotherwise some state might not be updated. To request about the general clearability see  {@link #isClearable()}.
 */
public boolean canViewBeDismissed(){
  return isClearable() && (!mShowingPublic || !mSensitiveHiddenInGeneral);
}",0.484304932735426
191169,"/** 
 * @return Can the underlying notification be cleared?
 */
public boolean isClearable(){
  return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}","/** 
 * @return Can the underlying notification be cleared? This can be different from whether thenotification can be dismissed in case notifications are sensitive on the lockscreen.
 * @see #canViewBeDismissed()
 */
public boolean isClearable(){
  return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}",0.697029702970297
191170,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mPublicLayout=(NotificationContentView)findViewById(R.id.expandedPublic);
  mPublicLayout.setContainingNotification(this);
  mPrivateLayout=(NotificationContentView)findViewById(R.id.expanded);
  mPrivateLayout.setExpandClickListener(mExpandClickListener);
  mPrivateLayout.setContainingNotification(this);
  mPublicLayout.setExpandClickListener(mExpandClickListener);
  mSettingsIconRowStub=(ViewStub)findViewById(R.id.settings_icon_row_stub);
  mSettingsIconRowStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mSettingsIconRow=(NotificationSettingsIconRow)inflated;
      mSettingsIconRow.setNotificationRowParent(ExpandableNotificationRow.this);
      mSettingsIconRow.setAppName(mAppName);
    }
  }
);
  mGutsStub=(ViewStub)findViewById(R.id.notification_guts_stub);
  mGutsStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mGuts=(NotificationGuts)inflated;
      mGuts.setClipTopAmount(getClipTopAmount());
      mGuts.setActualHeight(getActualHeight());
      mGutsStub=null;
    }
  }
);
  mChildrenContainerStub=(ViewStub)findViewById(R.id.child_container_stub);
  mChildrenContainerStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mChildrenContainer=(NotificationChildrenContainer)inflated;
      mChildrenContainer.setNotificationParent(ExpandableNotificationRow.this);
      mChildrenContainer.onNotificationUpdated();
      mTranslateableViews.add(mChildrenContainer);
    }
  }
);
  mVetoButton=findViewById(R.id.veto);
  mTranslateableViews=new ArrayList<View>();
  for (int i=0; i < getChildCount(); i++) {
    mTranslateableViews.add(getChildAt(i));
  }
  mTranslateableViews.remove(mVetoButton);
  mTranslateableViews.remove(mSettingsIconRowStub);
  mTranslateableViews.remove(mChildrenContainerStub);
  mTranslateableViews.remove(mGutsStub);
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mPublicLayout=(NotificationContentView)findViewById(R.id.expandedPublic);
  mPublicLayout.setContainingNotification(this);
  mPrivateLayout=(NotificationContentView)findViewById(R.id.expanded);
  mPrivateLayout.setExpandClickListener(mExpandClickListener);
  mPrivateLayout.setContainingNotification(this);
  mPublicLayout.setExpandClickListener(mExpandClickListener);
  mSettingsIconRowStub=(ViewStub)findViewById(R.id.settings_icon_row_stub);
  mSettingsIconRowStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mSettingsIconRow=(NotificationSettingsIconRow)inflated;
      mSettingsIconRow.setNotificationRowParent(ExpandableNotificationRow.this);
      mSettingsIconRow.setAppName(mAppName);
    }
  }
);
  mGutsStub=(ViewStub)findViewById(R.id.notification_guts_stub);
  mGutsStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mGuts=(NotificationGuts)inflated;
      mGuts.setClipTopAmount(getClipTopAmount());
      mGuts.setActualHeight(getActualHeight());
      mGutsStub=null;
    }
  }
);
  mChildrenContainerStub=(ViewStub)findViewById(R.id.child_container_stub);
  mChildrenContainerStub.setOnInflateListener(new ViewStub.OnInflateListener(){
    @Override public void onInflate(    ViewStub stub,    View inflated){
      mChildrenContainer=(NotificationChildrenContainer)inflated;
      mChildrenContainer.setNotificationParent(ExpandableNotificationRow.this);
      mChildrenContainer.onNotificationUpdated();
      mTranslateableViews.add(mChildrenContainer);
    }
  }
);
  mVetoButton=findViewById(R.id.veto);
  mVetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  mVetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  mTranslateableViews=new ArrayList<View>();
  for (int i=0; i < getChildCount(); i++) {
    mTranslateableViews.add(getChildAt(i));
  }
  mTranslateableViews.remove(mVetoButton);
  mTranslateableViews.remove(mSettingsIconRowStub);
  mTranslateableViews.remove(mChildrenContainerStub);
  mTranslateableViews.remove(mGutsStub);
}",0.9585987261146496
191171,"public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    if (mChildrenContainer != null) {
      mChildrenContainer.animate().cancel();
      mChildrenContainer.setAlpha(1f);
    }
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateClearability();
  mShowingPublicInitialized=true;
}","public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    if (mChildrenContainer != null) {
      mChildrenContainer.animate().cancel();
      mChildrenContainer.setAlpha(1f);
    }
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  mShowingPublicInitialized=true;
}",0.9879396984924624
191172,"public static void performDismiss(View v,NotificationGroupManager groupManager,boolean fromAccessibility){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (groupManager.isOnlyChildInGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=groupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary,groupManager,fromAccessibility);
      }
    }
    row.setDismissed(true,fromAccessibility);
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}","public static void performDismiss(View v,NotificationGroupManager groupManager,boolean fromAccessibility){
  if (!(v instanceof ExpandableNotificationRow)) {
    return;
  }
  ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  if (groupManager.isOnlyChildInGroup(row.getStatusBarNotification())) {
    ExpandableNotificationRow groupSummary=groupManager.getLogicalGroupSummary(row.getStatusBarNotification());
    if (groupSummary.isClearable()) {
      performDismiss(groupSummary,groupManager,fromAccessibility);
    }
  }
  row.setDismissed(true,fromAccessibility);
  if (row.isClearable()) {
    row.performDismiss();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}",0.8697450034458993
191173,"public static boolean canChildBeDismissed(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (row.areGutsExposed()) {
      return false;
    }
  }
  final View veto=v.findViewById(R.id.veto);
  return (veto != null && veto.getVisibility() != View.GONE);
}","public static boolean canChildBeDismissed(View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    return false;
  }
  ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  if (row.areGutsExposed()) {
    return false;
  }
  return row.canViewBeDismissed();
}",0.6721581548599671
191174,"/** 
 * @return Can the underlying notification be cleared? This can be different from whether thenotification can be dismissed in case notifications are sensitive on the lockscreen.
 * @see #canViewBeDismissed()
 */
public boolean isClearable(){
  return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}","/** 
 * @return Can the underlying notification be cleared? This can be different from whether thenotification can be dismissed in case notifications are sensitive on the lockscreen.
 * @see #canViewBeDismissed()
 */
public boolean isClearable(){
  if (mStatusBarNotification == null || !mStatusBarNotification.isClearable()) {
    return false;
  }
  if (mIsSummaryWithChildren) {
    List<ExpandableNotificationRow> notificationChildren=mChildrenContainer.getNotificationChildren();
    for (int i=0; i < notificationChildren.size(); i++) {
      ExpandableNotificationRow child=notificationChildren.get(i);
      if (!child.isClearable()) {
        return false;
      }
    }
  }
  return true;
}",0.5675413022351797
191175,"@NonNull public static AndroidKeyStorePublicKey loadAndroidKeyStorePublicKeyFromKeystore(@NonNull KeyStore keyStore,@NonNull String privateKeyAlias,int uid) throws UnrecoverableKeyException {
  KeyCharacteristics keyCharacteristics=new KeyCharacteristics();
  int errorCode=keyStore.getKeyCharacteristics(privateKeyAlias,null,null,uid,keyCharacteristics);
  if (errorCode != KeyStore.NO_ERROR) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(KeyStore.getKeyStoreException(errorCode));
  }
  ExportResult exportResult=keyStore.exportKey(privateKeyAlias,KeymasterDefs.KM_KEY_FORMAT_X509,null,null,uid);
  if (exportResult.resultCode != KeyStore.NO_ERROR) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(KeyStore.getKeyStoreException(errorCode));
  }
  final byte[] x509EncodedPublicKey=exportResult.exportData;
  Integer keymasterAlgorithm=keyCharacteristics.getEnum(KeymasterDefs.KM_TAG_ALGORITHM);
  if (keymasterAlgorithm == null) {
    throw new UnrecoverableKeyException(""String_Node_Str"");
  }
  String jcaKeyAlgorithm;
  try {
    jcaKeyAlgorithm=KeyProperties.KeyAlgorithm.fromKeymasterAsymmetricKeyAlgorithm(keymasterAlgorithm);
  }
 catch (  IllegalArgumentException e) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(e);
  }
  return AndroidKeyStoreProvider.getAndroidKeyStorePublicKey(privateKeyAlias,uid,jcaKeyAlgorithm,x509EncodedPublicKey);
}","@NonNull public static AndroidKeyStorePublicKey loadAndroidKeyStorePublicKeyFromKeystore(@NonNull KeyStore keyStore,@NonNull String privateKeyAlias,int uid) throws UnrecoverableKeyException {
  KeyCharacteristics keyCharacteristics=new KeyCharacteristics();
  int errorCode=keyStore.getKeyCharacteristics(privateKeyAlias,null,null,uid,keyCharacteristics);
  if (errorCode != KeyStore.NO_ERROR) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(KeyStore.getKeyStoreException(errorCode));
  }
  ExportResult exportResult=keyStore.exportKey(privateKeyAlias,KeymasterDefs.KM_KEY_FORMAT_X509,null,null,uid);
  if (exportResult.resultCode != KeyStore.NO_ERROR) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(KeyStore.getKeyStoreException(exportResult.resultCode));
  }
  final byte[] x509EncodedPublicKey=exportResult.exportData;
  Integer keymasterAlgorithm=keyCharacteristics.getEnum(KeymasterDefs.KM_TAG_ALGORITHM);
  if (keymasterAlgorithm == null) {
    throw new UnrecoverableKeyException(""String_Node_Str"");
  }
  String jcaKeyAlgorithm;
  try {
    jcaKeyAlgorithm=KeyProperties.KeyAlgorithm.fromKeymasterAsymmetricKeyAlgorithm(keymasterAlgorithm);
  }
 catch (  IllegalArgumentException e) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(e);
  }
  return AndroidKeyStoreProvider.getAndroidKeyStorePublicKey(privateKeyAlias,uid,jcaKeyAlgorithm,x509EncodedPublicKey);
}",0.9927248677248676
191176,"/** 
 * Utility function for addErrorToDropBox and handleStrictModeViolation's logging to append various headers to the dropbox log text.
 */
private void appendDropBoxProcessHeaders(ProcessRecord process,String processName,StringBuilder sb){
  if (process == null) {
    sb.append(""String_Node_Str"").append(processName).append(""String_Node_Str"");
    return;
  }
synchronized (this) {
    sb.append(""String_Node_Str"").append(processName).append(""String_Node_Str"");
    int flags=process.info.flags;
    IPackageManager pm=AppGlobals.getPackageManager();
    sb.append(""String_Node_Str"").append(Integer.toString(flags,16)).append(""String_Node_Str"");
    for (int ip=0; ip < process.pkgList.size(); ip++) {
      String pkg=process.pkgList.keyAt(ip);
      sb.append(""String_Node_Str"").append(pkg);
      try {
        PackageInfo pi=pm.getPackageInfo(pkg,0,UserHandle.getCallingUserId());
        if (pi != null) {
          sb.append(""String_Node_Str"").append(pi.versionCode);
          if (pi.versionName != null) {
            sb.append(""String_Node_Str"").append(pi.versionName).append(""String_Node_Str"");
          }
        }
      }
 catch (      RemoteException e) {
        Slog.e(TAG,""String_Node_Str"" + pkg,e);
      }
      sb.append(""String_Node_Str"");
    }
  }
}","/** 
 * Utility function for addErrorToDropBox and handleStrictModeViolation's logging to append various headers to the dropbox log text.
 */
private void appendDropBoxProcessHeaders(ProcessRecord process,String processName,StringBuilder sb){
  if (process == null) {
    sb.append(""String_Node_Str"").append(processName).append(""String_Node_Str"");
    return;
  }
synchronized (this) {
    sb.append(""String_Node_Str"").append(processName).append(""String_Node_Str"");
    int flags=process.info.flags;
    IPackageManager pm=AppGlobals.getPackageManager();
    sb.append(""String_Node_Str"").append(Integer.toHexString(flags)).append(""String_Node_Str"");
    for (int ip=0; ip < process.pkgList.size(); ip++) {
      String pkg=process.pkgList.keyAt(ip);
      sb.append(""String_Node_Str"").append(pkg);
      try {
        PackageInfo pi=pm.getPackageInfo(pkg,0,UserHandle.getCallingUserId());
        if (pi != null) {
          sb.append(""String_Node_Str"").append(pi.versionCode);
          if (pi.versionName != null) {
            sb.append(""String_Node_Str"").append(pi.versionName).append(""String_Node_Str"");
          }
        }
      }
 catch (      RemoteException e) {
        Slog.e(TAG,""String_Node_Str"" + pkg,e);
      }
      sb.append(""String_Node_Str"");
    }
  }
}",0.9976489028213166
191177,"/** 
 * Utility function for addErrorToDropBox and handleStrictModeViolation's logging to append various headers to the dropbox log text.
 */
private void appendDropBoxProcessHeaders(ProcessRecord process,String processName,StringBuilder sb){
  if (process == null) {
    sb.append(""String_Node_Str"").append(processName).append(""String_Node_Str"");
    return;
  }
synchronized (this) {
    sb.append(""String_Node_Str"").append(processName).append(""String_Node_Str"");
    int flags=process.info.flags;
    IPackageManager pm=AppGlobals.getPackageManager();
    sb.append(""String_Node_Str"").append(Integer.toString(flags,16)).append(""String_Node_Str"");
    for (int ip=0; ip < process.pkgList.size(); ip++) {
      String pkg=process.pkgList.keyAt(ip);
      sb.append(""String_Node_Str"").append(pkg);
      try {
        PackageInfo pi=pm.getPackageInfo(pkg,0,UserHandle.getCallingUserId());
        if (pi != null) {
          sb.append(""String_Node_Str"").append(pi.versionCode);
          if (pi.versionName != null) {
            sb.append(""String_Node_Str"").append(pi.versionName).append(""String_Node_Str"");
          }
        }
      }
 catch (      RemoteException e) {
        Slog.e(TAG,""String_Node_Str"" + pkg,e);
      }
      sb.append(""String_Node_Str"");
    }
  }
}","/** 
 * Utility function for addErrorToDropBox and handleStrictModeViolation's logging to append various headers to the dropbox log text.
 */
private void appendDropBoxProcessHeaders(ProcessRecord process,String processName,StringBuilder sb){
  if (process == null) {
    sb.append(""String_Node_Str"").append(processName).append(""String_Node_Str"");
    return;
  }
synchronized (this) {
    sb.append(""String_Node_Str"").append(processName).append(""String_Node_Str"");
    int flags=process.info.flags;
    IPackageManager pm=AppGlobals.getPackageManager();
    sb.append(""String_Node_Str"").append(Integer.toHexString(flags)).append(""String_Node_Str"");
    for (int ip=0; ip < process.pkgList.size(); ip++) {
      String pkg=process.pkgList.keyAt(ip);
      sb.append(""String_Node_Str"").append(pkg);
      try {
        PackageInfo pi=pm.getPackageInfo(pkg,0,UserHandle.getCallingUserId());
        if (pi != null) {
          sb.append(""String_Node_Str"").append(pi.versionCode);
          if (pi.versionName != null) {
            sb.append(""String_Node_Str"").append(pi.versionName).append(""String_Node_Str"");
          }
        }
      }
 catch (      RemoteException e) {
        Slog.e(TAG,""String_Node_Str"" + pkg,e);
      }
      sb.append(""String_Node_Str"");
    }
  }
}",0.9976489028213166
191178,"@NonNull public static AndroidKeyStorePublicKey loadAndroidKeyStorePublicKeyFromKeystore(@NonNull KeyStore keyStore,@NonNull String privateKeyAlias,int uid) throws UnrecoverableKeyException {
  KeyCharacteristics keyCharacteristics=new KeyCharacteristics();
  int errorCode=keyStore.getKeyCharacteristics(privateKeyAlias,null,null,uid,keyCharacteristics);
  if (errorCode != KeyStore.NO_ERROR) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(KeyStore.getKeyStoreException(errorCode));
  }
  ExportResult exportResult=keyStore.exportKey(privateKeyAlias,KeymasterDefs.KM_KEY_FORMAT_X509,null,null,uid);
  if (exportResult.resultCode != KeyStore.NO_ERROR) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(KeyStore.getKeyStoreException(errorCode));
  }
  final byte[] x509EncodedPublicKey=exportResult.exportData;
  Integer keymasterAlgorithm=keyCharacteristics.getEnum(KeymasterDefs.KM_TAG_ALGORITHM);
  if (keymasterAlgorithm == null) {
    throw new UnrecoverableKeyException(""String_Node_Str"");
  }
  String jcaKeyAlgorithm;
  try {
    jcaKeyAlgorithm=KeyProperties.KeyAlgorithm.fromKeymasterAsymmetricKeyAlgorithm(keymasterAlgorithm);
  }
 catch (  IllegalArgumentException e) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(e);
  }
  return AndroidKeyStoreProvider.getAndroidKeyStorePublicKey(privateKeyAlias,uid,jcaKeyAlgorithm,x509EncodedPublicKey);
}","@NonNull public static AndroidKeyStorePublicKey loadAndroidKeyStorePublicKeyFromKeystore(@NonNull KeyStore keyStore,@NonNull String privateKeyAlias,int uid) throws UnrecoverableKeyException {
  KeyCharacteristics keyCharacteristics=new KeyCharacteristics();
  int errorCode=keyStore.getKeyCharacteristics(privateKeyAlias,null,null,uid,keyCharacteristics);
  if (errorCode != KeyStore.NO_ERROR) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(KeyStore.getKeyStoreException(errorCode));
  }
  ExportResult exportResult=keyStore.exportKey(privateKeyAlias,KeymasterDefs.KM_KEY_FORMAT_X509,null,null,uid);
  if (exportResult.resultCode != KeyStore.NO_ERROR) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(KeyStore.getKeyStoreException(exportResult.resultCode));
  }
  final byte[] x509EncodedPublicKey=exportResult.exportData;
  Integer keymasterAlgorithm=keyCharacteristics.getEnum(KeymasterDefs.KM_TAG_ALGORITHM);
  if (keymasterAlgorithm == null) {
    throw new UnrecoverableKeyException(""String_Node_Str"");
  }
  String jcaKeyAlgorithm;
  try {
    jcaKeyAlgorithm=KeyProperties.KeyAlgorithm.fromKeymasterAsymmetricKeyAlgorithm(keymasterAlgorithm);
  }
 catch (  IllegalArgumentException e) {
    throw (UnrecoverableKeyException)new UnrecoverableKeyException(""String_Node_Str"").initCause(e);
  }
  return AndroidKeyStoreProvider.getAndroidKeyStorePublicKey(privateKeyAlias,uid,jcaKeyAlgorithm,x509EncodedPublicKey);
}",0.9927248677248676
191179,"/** 
 * Called for system navigation gestures. First action opens the panel, second opens settings. Down action closes the entire panel.
 */
@Override public void handleSystemNavigationKey(int key){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key);
  if (!panelsEnabled()) {
    return;
  }
  if (!mUserSetup)   return;
  if (KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP == key) {
    mNotificationPanel.collapse(false,1.0f);
  }
 else   if (KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN == key) {
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.expand(true);
    }
 else     if (!mNotificationPanel.isInSettings() && !mNotificationPanel.isExpanding()) {
      mNotificationPanel.flingSettings(0,true);
    }
  }
}","/** 
 * Called for system navigation gestures. First action opens the panel, second opens settings. Down action closes the entire panel.
 */
@Override public void handleSystemNavigationKey(int key){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key);
  if (!panelsEnabled() || !mKeyguardMonitor.isDeviceInteractive()) {
    return;
  }
  if (!mUserSetup)   return;
  if (KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP == key) {
    mNotificationPanel.collapse(false,1.0f);
  }
 else   if (KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN == key) {
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.expand(true);
    }
 else     if (!mNotificationPanel.isInSettings() && !mNotificationPanel.isExpanding()) {
      mNotificationPanel.flingSettings(0,true);
    }
  }
}",0.9712758851035403
191180,"private void generateHeadsUpAnimationEvents(){
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    int type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_OTHER;
    boolean onBottom=false;
    boolean pinnedAndClosed=row.isPinned() && !mIsExpanded;
    if (!mIsExpanded && !isHeadsUp) {
      type=row.wasJustClicked() ? AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR_CLICK : AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR;
    }
 else {
      StackViewState viewState=mCurrentStackScrollState.getViewStateForView(row);
      if (viewState == null) {
        continue;
      }
      if (isHeadsUp && (mAddedHeadsUpChildren.contains(row) || pinnedAndClosed)) {
        if (pinnedAndClosed || shouldHunAppearFromBottom(viewState)) {
          type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_APPEAR;
        }
 else {
          type=AnimationEvent.ANIMATION_TYPE_ADD;
        }
        onBottom=!pinnedAndClosed;
      }
    }
    AnimationEvent event=new AnimationEvent(row,type);
    event.headsUpFromBottom=onBottom;
    mAnimationEvents.add(event);
  }
  mHeadsUpChangeAnimations.clear();
  mAddedHeadsUpChildren.clear();
}","private void generateHeadsUpAnimationEvents(){
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    int type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_OTHER;
    boolean onBottom=false;
    boolean pinnedAndClosed=row.isPinned() && !mIsExpanded;
    if (!mIsExpanded && !isHeadsUp) {
      type=row.wasJustClicked() ? AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR_CLICK : AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR;
      if (row.isChildInGroup()) {
        row.setHeadsupDisappearRunning(false);
      }
    }
 else {
      StackViewState viewState=mCurrentStackScrollState.getViewStateForView(row);
      if (viewState == null) {
        continue;
      }
      if (isHeadsUp && (mAddedHeadsUpChildren.contains(row) || pinnedAndClosed)) {
        if (pinnedAndClosed || shouldHunAppearFromBottom(viewState)) {
          type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_APPEAR;
        }
 else {
          type=AnimationEvent.ANIMATION_TYPE_ADD;
        }
        onBottom=!pinnedAndClosed;
      }
    }
    AnimationEvent event=new AnimationEvent(row,type);
    event.headsUpFromBottom=onBottom;
    mAnimationEvents.add(event);
  }
  mHeadsUpChangeAnimations.clear();
  mAddedHeadsUpChildren.clear();
}",0.9655972168534984
191181,"private void clearHeadsUpDisappearRunning(){
  for (int i=0; i < getChildCount(); i++) {
    View view=getChildAt(i);
    if (view instanceof ExpandableNotificationRow) {
      ((ExpandableNotificationRow)view).setHeadsupDisappearRunning(false);
    }
  }
}","private void clearHeadsUpDisappearRunning(){
  for (int i=0; i < getChildCount(); i++) {
    View view=getChildAt(i);
    if (view instanceof ExpandableNotificationRow) {
      ExpandableNotificationRow row=(ExpandableNotificationRow)view;
      row.setHeadsupDisappearRunning(false);
      if (row.isSummaryWithChildren()) {
        for (        ExpandableNotificationRow child : row.getNotificationChildren()) {
          child.setHeadsupDisappearRunning(false);
        }
      }
    }
  }
}",0.6764314247669774
191182,"@Override protected int getMaxPanelHeight(){
  int min=mStatusBarMinHeight;
  if (mStatusBar.getBarState() != StatusBarState.KEYGUARD && mNotificationStackScroller.getNotGoneChildCount() == 0) {
    int minHeight=(int)((mQsMinExpansionHeight + getOverExpansionAmount()) * HEADER_RUBBERBAND_FACTOR);
    min=Math.max(min,minHeight);
  }
  int maxHeight;
  if (mQsExpandImmediate || mQsExpanded || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    maxHeight=calculatePanelHeightQsExpanded();
  }
 else {
    maxHeight=calculatePanelHeightShade();
  }
  maxHeight=Math.max(maxHeight,min);
  return maxHeight;
}","@Override protected int getMaxPanelHeight(){
  int min=mStatusBarMinHeight;
  if (mStatusBar.getBarState() != StatusBarState.KEYGUARD && mNotificationStackScroller.getNotGoneChildCount() == 0) {
    int minHeight=(int)(mQsMinExpansionHeight + getOverExpansionAmount());
    min=Math.max(min,minHeight);
  }
  int maxHeight;
  if (mQsExpandImmediate || mQsExpanded || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    maxHeight=calculatePanelHeightQsExpanded();
  }
 else {
    maxHeight=calculatePanelHeightShade();
  }
  maxHeight=Math.max(maxHeight,min);
  return maxHeight;
}",0.9757322175732216
191183,"protected float getHeaderTranslation(){
  if (mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
    return 0;
  }
  if (mNotificationStackScroller.getNotGoneChildCount() == 0) {
    return Math.min(0,mExpandedHeight / HEADER_RUBBERBAND_FACTOR - mQsMinExpansionHeight);
  }
  float stackTranslation=mNotificationStackScroller.getStackTranslation();
  float translation=stackTranslation / HEADER_RUBBERBAND_FACTOR;
  if (mHeadsUpManager.hasPinnedHeadsUp() || mIsExpansionFromHeadsUp) {
    translation=mNotificationStackScroller.getTopPadding() + stackTranslation - mQsMinExpansionHeight;
  }
  return Math.min(0,translation);
}","protected float getHeaderTranslation(){
  if (mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
    return 0;
  }
  float translation=NotificationUtils.interpolate(-mQsMinExpansionHeight,0,mNotificationStackScroller.getAppearFraction(mExpandedHeight));
  return Math.min(0,translation);
}",0.4090909090909091
191184,"@Override protected float getPeekHeight(){
  if (mNotificationStackScroller.getNotGoneChildCount() > 0) {
    return mNotificationStackScroller.getPeekHeight();
  }
 else {
    return mQsMinExpansionHeight * HEADER_RUBBERBAND_FACTOR;
  }
}","@Override protected float getPeekHeight(){
  if (mNotificationStackScroller.getNotGoneChildCount() > 0) {
    return mNotificationStackScroller.getPeekHeight();
  }
 else {
    return mQsMinExpansionHeight;
  }
}",0.9401330376940134
191185,"public int getLayoutMinHeight(){
  final ExpandableView firstChild=getFirstChildNotGone();
  int firstChildMinHeight=firstChild != null ? firstChild.getIntrinsicHeight() : mEmptyShadeView != null ? mEmptyShadeView.getMinHeight() : mCollapsedSize;
  if (mOwnScrollY > 0) {
    firstChildMinHeight=Math.max(firstChildMinHeight - mOwnScrollY,mCollapsedSize);
  }
  return Math.min(firstChildMinHeight + mBottomStackPeekSize + mBottomStackSlowDownHeight,mMaxLayoutHeight - mTopPadding);
}","public int getLayoutMinHeight(){
  int firstChildMinHeight=getFirstChildMinHeight();
  return Math.min(firstChildMinHeight + mBottomStackPeekSize + mBottomStackSlowDownHeight,mMaxLayoutHeight - mTopPadding);
}",0.5396825396825397
191186,"/** 
 * Update the height of the stack to a new height.
 * @param height the new height of the stack
 */
public void setStackHeight(float height){
  mLastSetStackHeight=height;
  setIsExpanded(height > 0.0f);
  int newStackHeight=(int)height;
  int minStackHeight=getLayoutMinHeight();
  int stackHeight;
  float paddingOffset;
  boolean trackingHeadsUp=mTrackingHeadsUp || mHeadsUpManager.hasPinnedHeadsUp();
  int normalUnfoldPositionStart=trackingHeadsUp ? mHeadsUpManager.getTopHeadsUpPinnedHeight() : minStackHeight;
  if (newStackHeight - mTopPadding - mTopPaddingOverflow >= normalUnfoldPositionStart || getNotGoneChildCount() == 0) {
    paddingOffset=mTopPaddingOverflow;
    stackHeight=newStackHeight;
  }
 else {
    int translationY;
    translationY=newStackHeight - normalUnfoldPositionStart;
    paddingOffset=translationY - mTopPadding;
    stackHeight=(int)(height - (translationY - mTopPadding));
  }
  if (stackHeight != mCurrentStackHeight) {
    mCurrentStackHeight=stackHeight;
    updateAlgorithmHeightAndPadding();
    requestChildrenUpdate();
  }
  setStackTranslation(paddingOffset);
}","/** 
 * Update the height of the stack to a new height.
 * @param height the new height of the stack
 */
public void setStackHeight(float height){
  mLastSetStackHeight=height;
  setIsExpanded(height > 0.0f);
  int stackHeight;
  float translationY;
  float appearEndPosition=getAppearEndPosition();
  float appearStartPosition=getAppearStartPosition();
  if (height >= appearEndPosition) {
    translationY=mTopPaddingOverflow;
    stackHeight=(int)height;
  }
 else {
    float appearFraction=getAppearFraction(height);
    if (appearFraction >= 0) {
      translationY=NotificationUtils.interpolate(getExpandTranslationStart(),0,appearFraction);
    }
 else {
      translationY=height - appearStartPosition + getExpandTranslationStart();
    }
    stackHeight=(int)(height - translationY);
  }
  if (stackHeight != mCurrentStackHeight) {
    mCurrentStackHeight=stackHeight;
    updateAlgorithmHeightAndPadding();
    requestChildrenUpdate();
  }
  setStackTranslation(translationY);
}",0.4521656354117087
191187,"private void generateHeadsUpAnimationEvents(){
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    int type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_OTHER;
    boolean onBottom=false;
    boolean pinnedAndClosed=row.isPinned() && !mIsExpanded;
    if (!mIsExpanded && !isHeadsUp) {
      type=row.wasJustClicked() ? AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR_CLICK : AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR;
    }
 else {
      StackViewState viewState=mCurrentStackScrollState.getViewStateForView(row);
      if (viewState == null) {
        continue;
      }
      if (isHeadsUp && (mAddedHeadsUpChildren.contains(row) || pinnedAndClosed)) {
        if (pinnedAndClosed || shouldHunAppearFromBottom(viewState)) {
          type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_APPEAR;
        }
 else {
          type=AnimationEvent.ANIMATION_TYPE_ADD;
        }
        onBottom=!pinnedAndClosed;
      }
    }
    AnimationEvent event=new AnimationEvent(row,type);
    event.headsUpFromBottom=onBottom;
    mAnimationEvents.add(event);
  }
  mHeadsUpChangeAnimations.clear();
  mAddedHeadsUpChildren.clear();
}","private void generateHeadsUpAnimationEvents(){
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    int type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_OTHER;
    boolean onBottom=false;
    boolean pinnedAndClosed=row.isPinned() && !mIsExpanded;
    if (!mIsExpanded && !isHeadsUp) {
      type=row.wasJustClicked() ? AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR_CLICK : AnimationEvent.ANIMATION_TYPE_HEADS_UP_DISAPPEAR;
      if (row.isChildInGroup()) {
        row.setHeadsupDisappearRunning(false);
      }
    }
 else {
      StackViewState viewState=mCurrentStackScrollState.getViewStateForView(row);
      if (viewState == null) {
        continue;
      }
      if (isHeadsUp && (mAddedHeadsUpChildren.contains(row) || pinnedAndClosed)) {
        if (pinnedAndClosed || shouldHunAppearFromBottom(viewState)) {
          type=AnimationEvent.ANIMATION_TYPE_HEADS_UP_APPEAR;
        }
 else {
          type=AnimationEvent.ANIMATION_TYPE_ADD;
        }
        onBottom=!pinnedAndClosed;
      }
    }
    AnimationEvent event=new AnimationEvent(row,type);
    event.headsUpFromBottom=onBottom;
    mAnimationEvents.add(event);
  }
  mHeadsUpChangeAnimations.clear();
  mAddedHeadsUpChildren.clear();
}",0.9655972168534984
191188,"private void clearHeadsUpDisappearRunning(){
  for (int i=0; i < getChildCount(); i++) {
    View view=getChildAt(i);
    if (view instanceof ExpandableNotificationRow) {
      ((ExpandableNotificationRow)view).setHeadsupDisappearRunning(false);
    }
  }
}","private void clearHeadsUpDisappearRunning(){
  for (int i=0; i < getChildCount(); i++) {
    View view=getChildAt(i);
    if (view instanceof ExpandableNotificationRow) {
      ExpandableNotificationRow row=(ExpandableNotificationRow)view;
      row.setHeadsupDisappearRunning(false);
      if (row.isSummaryWithChildren()) {
        for (        ExpandableNotificationRow child : row.getNotificationChildren()) {
          child.setHeadsupDisappearRunning(false);
        }
      }
    }
  }
}",0.6764314247669774
191189,"@Override protected int getMaxPanelHeight(){
  int min=mStatusBarMinHeight;
  if (mStatusBar.getBarState() != StatusBarState.KEYGUARD && mNotificationStackScroller.getNotGoneChildCount() == 0) {
    int minHeight=(int)((mQsMinExpansionHeight + getOverExpansionAmount()) * HEADER_RUBBERBAND_FACTOR);
    min=Math.max(min,minHeight);
  }
  int maxHeight;
  if (mQsExpandImmediate || mQsExpanded || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    maxHeight=calculatePanelHeightQsExpanded();
  }
 else {
    maxHeight=calculatePanelHeightShade();
  }
  maxHeight=Math.max(maxHeight,min);
  return maxHeight;
}","@Override protected int getMaxPanelHeight(){
  int min=mStatusBarMinHeight;
  if (mStatusBar.getBarState() != StatusBarState.KEYGUARD && mNotificationStackScroller.getNotGoneChildCount() == 0) {
    int minHeight=(int)(mQsMinExpansionHeight + getOverExpansionAmount());
    min=Math.max(min,minHeight);
  }
  int maxHeight;
  if (mQsExpandImmediate || mQsExpanded || mIsExpanding && mQsExpandedWhenExpandingStarted) {
    maxHeight=calculatePanelHeightQsExpanded();
  }
 else {
    maxHeight=calculatePanelHeightShade();
  }
  maxHeight=Math.max(maxHeight,min);
  return maxHeight;
}",0.9757322175732216
191190,"protected float getHeaderTranslation(){
  if (mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
    return 0;
  }
  if (mNotificationStackScroller.getNotGoneChildCount() == 0) {
    return Math.min(0,mExpandedHeight / HEADER_RUBBERBAND_FACTOR - mQsMinExpansionHeight);
  }
  float stackTranslation=mNotificationStackScroller.getStackTranslation();
  float translation=stackTranslation / HEADER_RUBBERBAND_FACTOR;
  if (mHeadsUpManager.hasPinnedHeadsUp() || mIsExpansionFromHeadsUp) {
    translation=mNotificationStackScroller.getTopPadding() + stackTranslation - mQsMinExpansionHeight;
  }
  return Math.min(0,translation);
}","protected float getHeaderTranslation(){
  if (mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
    return 0;
  }
  float translation=NotificationUtils.interpolate(-mQsMinExpansionHeight,0,mNotificationStackScroller.getAppearFraction(mExpandedHeight));
  return Math.min(0,translation);
}",0.4090909090909091
191191,"@Override protected float getPeekHeight(){
  if (mNotificationStackScroller.getNotGoneChildCount() > 0) {
    return mNotificationStackScroller.getPeekHeight();
  }
 else {
    return mQsMinExpansionHeight * HEADER_RUBBERBAND_FACTOR;
  }
}","@Override protected float getPeekHeight(){
  if (mNotificationStackScroller.getNotGoneChildCount() > 0) {
    return mNotificationStackScroller.getPeekHeight();
  }
 else {
    return mQsMinExpansionHeight;
  }
}",0.9401330376940134
191192,"public int getLayoutMinHeight(){
  final ExpandableView firstChild=getFirstChildNotGone();
  int firstChildMinHeight=firstChild != null ? firstChild.getIntrinsicHeight() : mEmptyShadeView != null ? mEmptyShadeView.getMinHeight() : mCollapsedSize;
  if (mOwnScrollY > 0) {
    firstChildMinHeight=Math.max(firstChildMinHeight - mOwnScrollY,mCollapsedSize);
  }
  return Math.min(firstChildMinHeight + mBottomStackPeekSize + mBottomStackSlowDownHeight,mMaxLayoutHeight - mTopPadding);
}","public int getLayoutMinHeight(){
  int firstChildMinHeight=getFirstChildMinHeight();
  return Math.min(firstChildMinHeight + mBottomStackPeekSize + mBottomStackSlowDownHeight,mMaxLayoutHeight - mTopPadding);
}",0.5396825396825397
191193,"/** 
 * Update the height of the stack to a new height.
 * @param height the new height of the stack
 */
public void setStackHeight(float height){
  mLastSetStackHeight=height;
  setIsExpanded(height > 0.0f);
  int newStackHeight=(int)height;
  int minStackHeight=getLayoutMinHeight();
  int stackHeight;
  float paddingOffset;
  boolean trackingHeadsUp=mTrackingHeadsUp || mHeadsUpManager.hasPinnedHeadsUp();
  int normalUnfoldPositionStart=trackingHeadsUp ? mHeadsUpManager.getTopHeadsUpPinnedHeight() : minStackHeight;
  if (newStackHeight - mTopPadding - mTopPaddingOverflow >= normalUnfoldPositionStart || getNotGoneChildCount() == 0) {
    paddingOffset=mTopPaddingOverflow;
    stackHeight=newStackHeight;
  }
 else {
    int translationY;
    translationY=newStackHeight - normalUnfoldPositionStart;
    paddingOffset=translationY - mTopPadding;
    stackHeight=(int)(height - (translationY - mTopPadding));
  }
  if (stackHeight != mCurrentStackHeight) {
    mCurrentStackHeight=stackHeight;
    updateAlgorithmHeightAndPadding();
    requestChildrenUpdate();
  }
  setStackTranslation(paddingOffset);
}","/** 
 * Update the height of the stack to a new height.
 * @param height the new height of the stack
 */
public void setStackHeight(float height){
  mLastSetStackHeight=height;
  setIsExpanded(height > 0.0f);
  int stackHeight;
  float translationY;
  float appearEndPosition=getAppearEndPosition();
  float appearStartPosition=getAppearStartPosition();
  if (height >= appearEndPosition) {
    translationY=mTopPaddingOverflow;
    stackHeight=(int)height;
  }
 else {
    float appearFraction=getAppearFraction(height);
    if (appearFraction >= 0) {
      translationY=NotificationUtils.interpolate(getExpandTranslationStart(),0,appearFraction);
    }
 else {
      translationY=height - appearStartPosition + getExpandTranslationStart();
    }
    stackHeight=(int)(height - translationY);
  }
  if (stackHeight != mCurrentStackHeight) {
    mCurrentStackHeight=stackHeight;
    updateAlgorithmHeightAndPadding();
    requestChildrenUpdate();
  }
  setStackTranslation(translationY);
}",0.4521656354117087
191194,"/** 
 * Called for system navigation gestures. First action opens the panel, second opens settings. Down action closes the entire panel.
 */
@Override public void handleSystemNavigationKey(int key){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key);
  if (!panelsEnabled()) {
    return;
  }
  if (!mUserSetup)   return;
  if (KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP == key) {
    mNotificationPanel.collapse(false,1.0f);
  }
 else   if (KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN == key) {
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.expand(true);
    }
 else     if (!mNotificationPanel.isInSettings() && !mNotificationPanel.isExpanding()) {
      mNotificationPanel.flingSettings(0,true);
    }
  }
}","/** 
 * Called for system navigation gestures. First action opens the panel, second opens settings. Down action closes the entire panel.
 */
@Override public void handleSystemNavigationKey(int key){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key);
  if (!panelsEnabled() || !mKeyguardMonitor.isDeviceInteractive()) {
    return;
  }
  if (!mUserSetup)   return;
  if (KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP == key) {
    mNotificationPanel.collapse(false,1.0f);
  }
 else   if (KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN == key) {
    if (mNotificationPanel.isFullyCollapsed()) {
      mNotificationPanel.expand(true);
    }
 else     if (!mNotificationPanel.isInSettings() && !mNotificationPanel.isExpanding()) {
      mNotificationPanel.flingSettings(0,true);
    }
  }
}",0.9712758851035403
191195,"/** 
 * Remove a removed child view from the heads up animations if it was just added there
 * @return whether any child was removed from the list to animate
 */
private boolean removeRemovedChildFromHeadsUpChangeAnimations(View child){
  boolean hasAddEvent=false;
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    if (child == row) {
      mTmpList.add(eventPair);
      hasAddEvent|=isHeadsUp;
    }
  }
  if (hasAddEvent) {
    mHeadsUpChangeAnimations.removeAll(mTmpList);
  }
  mTmpList.clear();
  return hasAddEvent;
}","/** 
 * Remove a removed child view from the heads up animations if it was just added there
 * @return whether any child was removed from the list to animate
 */
private boolean removeRemovedChildFromHeadsUpChangeAnimations(View child){
  boolean hasAddEvent=false;
  for (  Pair<ExpandableNotificationRow,Boolean> eventPair : mHeadsUpChangeAnimations) {
    ExpandableNotificationRow row=eventPair.first;
    boolean isHeadsUp=eventPair.second;
    if (child == row) {
      mTmpList.add(eventPair);
      hasAddEvent|=isHeadsUp;
    }
  }
  if (hasAddEvent) {
    mHeadsUpChangeAnimations.removeAll(mTmpList);
    ((ExpandableNotificationRow)child).setHeadsupDisappearRunning(false);
  }
  mTmpList.clear();
  return hasAddEvent;
}",0.9468390804597702
191196,"public void onChildAnimationFinished(){
  setAnimationRunning(false);
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
  clearViewOverlays();
}","public void onChildAnimationFinished(){
  setAnimationRunning(false);
  requestChildrenUpdate();
  runAnimationFinishedRunnables();
  clearViewOverlays();
  clearHeadsUpDisappearRunning();
}",0.9017341040462428
191197,"/** 
 * @hide
 */
@TestApi public GnssMeasurementsEvent(GnssClock clock,GnssMeasurement[] measurements){
  if (clock == null) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
  if (measurements == null || measurements.length == 0) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
  mClock=clock;
  Collection<GnssMeasurement> measurementCollection=Arrays.asList(measurements);
  mReadOnlyMeasurements=Collections.unmodifiableCollection(measurementCollection);
}","/** 
 * @hide
 */
@TestApi public GnssMeasurementsEvent(GnssClock clock,GnssMeasurement[] measurements){
  if (clock == null) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
  if (measurements == null || measurements.length == 0) {
    mReadOnlyMeasurements=Collections.emptyList();
  }
 else {
    Collection<GnssMeasurement> measurementCollection=Arrays.asList(measurements);
    mReadOnlyMeasurements=Collections.unmodifiableCollection(measurementCollection);
  }
  mClock=clock;
}",0.5656970912738215
191198,"void crashApplicationInner(ProcessRecord r,ApplicationErrorReport.CrashInfo crashInfo){
  long timeMillis=System.currentTimeMillis();
  String shortMsg=crashInfo.exceptionClassName;
  String longMsg=crashInfo.exceptionMessage;
  String stackTrace=crashInfo.stackTrace;
  if (shortMsg != null && longMsg != null) {
    longMsg=shortMsg + ""String_Node_Str"" + longMsg;
  }
 else   if (shortMsg != null) {
    longMsg=shortMsg;
  }
  AppErrorResult result=new AppErrorResult();
  TaskRecord task;
synchronized (mService) {
    if (handleAppCrashInActivityController(r,crashInfo,shortMsg,longMsg,stackTrace,timeMillis)) {
      return;
    }
    if (r != null && r.instrumentationClass != null) {
      return;
    }
    if (r != null) {
      mService.mBatteryStatsService.noteProcessCrash(r.processName,r.uid);
    }
    AppErrorDialog.Data data=new AppErrorDialog.Data();
    data.result=result;
    data.proc=r;
    if (r == null || !makeAppCrashingLocked(r,shortMsg,longMsg,stackTrace,data)) {
      return;
    }
    Message msg=Message.obtain();
    msg.what=ActivityManagerService.SHOW_ERROR_UI_MSG;
    task=data.task;
    msg.obj=data;
    mService.mUiHandler.sendMessage(msg);
  }
  int res=result.get();
  Intent appErrorIntent=null;
  MetricsLogger.action(mContext,MetricsProto.MetricsEvent.ACTION_APP_CRASH,res);
  if (res == AppErrorDialog.TIMEOUT || res == AppErrorDialog.CANCEL) {
    res=AppErrorDialog.FORCE_QUIT;
  }
synchronized (mService) {
    if (res == AppErrorDialog.MUTE) {
      stopReportingCrashesLocked(r);
    }
    if (res == AppErrorDialog.RESTART) {
      mService.removeProcessLocked(r,false,true,""String_Node_Str"");
      if (task != null) {
        try {
          mService.startActivityFromRecents(task.taskId,ActivityOptions.makeBasic().toBundle());
        }
 catch (        IllegalArgumentException e) {
          if (task.intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
            mService.startActivityInPackage(task.mCallingUid,task.mCallingPackage,task.intent,null,null,null,0,0,ActivityOptions.makeBasic().toBundle(),task.userId,null,null);
          }
        }
      }
    }
    if (res == AppErrorDialog.FORCE_QUIT) {
      long orig=Binder.clearCallingIdentity();
      try {
        mService.mStackSupervisor.handleAppCrashLocked(r);
        if (!r.persistent) {
          mService.removeProcessLocked(r,false,false,""String_Node_Str"");
          mService.mStackSupervisor.resumeFocusedStackTopActivityLocked();
        }
      }
  finally {
        Binder.restoreCallingIdentity(orig);
      }
    }
    if (res == AppErrorDialog.FORCE_QUIT_AND_REPORT) {
      appErrorIntent=createAppErrorIntentLocked(r,timeMillis,crashInfo);
    }
    if (r != null && !r.isolated && res != AppErrorDialog.RESTART) {
      mProcessCrashTimes.put(r.info.processName,r.uid,SystemClock.uptimeMillis());
    }
  }
  if (appErrorIntent != null) {
    try {
      mContext.startActivityAsUser(appErrorIntent,new UserHandle(r.userId));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","void crashApplicationInner(ProcessRecord r,ApplicationErrorReport.CrashInfo crashInfo){
  long timeMillis=System.currentTimeMillis();
  String shortMsg=crashInfo.exceptionClassName;
  String longMsg=crashInfo.exceptionMessage;
  String stackTrace=crashInfo.stackTrace;
  if (shortMsg != null && longMsg != null) {
    longMsg=shortMsg + ""String_Node_Str"" + longMsg;
  }
 else   if (shortMsg != null) {
    longMsg=shortMsg;
  }
  AppErrorResult result=new AppErrorResult();
  TaskRecord task;
synchronized (mService) {
    if (handleAppCrashInActivityController(r,crashInfo,shortMsg,longMsg,stackTrace,timeMillis)) {
      return;
    }
    if (r != null && r.instrumentationClass != null) {
      return;
    }
    if (r != null) {
      mService.mBatteryStatsService.noteProcessCrash(r.processName,r.uid);
    }
    AppErrorDialog.Data data=new AppErrorDialog.Data();
    data.result=result;
    data.proc=r;
    if (r == null || !makeAppCrashingLocked(r,shortMsg,longMsg,stackTrace,data)) {
      return;
    }
    Message msg=Message.obtain();
    msg.what=ActivityManagerService.SHOW_ERROR_UI_MSG;
    task=data.task;
    msg.obj=data;
    mService.mUiHandler.sendMessage(msg);
  }
  int res=result.get();
  Intent appErrorIntent=null;
  MetricsLogger.action(mContext,MetricsProto.MetricsEvent.ACTION_APP_CRASH,res);
  if (res == AppErrorDialog.TIMEOUT || res == AppErrorDialog.CANCEL) {
    res=AppErrorDialog.FORCE_QUIT;
  }
synchronized (mService) {
    if (res == AppErrorDialog.MUTE) {
      stopReportingCrashesLocked(r);
    }
    if (res == AppErrorDialog.RESTART) {
      mService.removeProcessLocked(r,false,true,""String_Node_Str"");
      if (task != null) {
        try {
          mService.startActivityFromRecents(task.taskId,ActivityOptions.makeBasic().toBundle());
        }
 catch (        IllegalArgumentException e) {
          final Set<String> cats=task.intent.getCategories();
          if (cats != null && cats.contains(Intent.CATEGORY_LAUNCHER)) {
            mService.startActivityInPackage(task.mCallingUid,task.mCallingPackage,task.intent,null,null,null,0,0,ActivityOptions.makeBasic().toBundle(),task.userId,null,null);
          }
        }
      }
    }
    if (res == AppErrorDialog.FORCE_QUIT) {
      long orig=Binder.clearCallingIdentity();
      try {
        mService.mStackSupervisor.handleAppCrashLocked(r);
        if (!r.persistent) {
          mService.removeProcessLocked(r,false,false,""String_Node_Str"");
          mService.mStackSupervisor.resumeFocusedStackTopActivityLocked();
        }
      }
  finally {
        Binder.restoreCallingIdentity(orig);
      }
    }
    if (res == AppErrorDialog.FORCE_QUIT_AND_REPORT) {
      appErrorIntent=createAppErrorIntentLocked(r,timeMillis,crashInfo);
    }
    if (r != null && !r.isolated && res != AppErrorDialog.RESTART) {
      mProcessCrashTimes.put(r.info.processName,r.uid,SystemClock.uptimeMillis());
    }
  }
  if (appErrorIntent != null) {
    try {
      mContext.startActivityAsUser(appErrorIntent,new UserHandle(r.userId));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}",0.9901692183722804
191199,"void crashApplicationInner(ProcessRecord r,ApplicationErrorReport.CrashInfo crashInfo){
  long timeMillis=System.currentTimeMillis();
  String shortMsg=crashInfo.exceptionClassName;
  String longMsg=crashInfo.exceptionMessage;
  String stackTrace=crashInfo.stackTrace;
  if (shortMsg != null && longMsg != null) {
    longMsg=shortMsg + ""String_Node_Str"" + longMsg;
  }
 else   if (shortMsg != null) {
    longMsg=shortMsg;
  }
  AppErrorResult result=new AppErrorResult();
  TaskRecord task;
synchronized (mService) {
    if (handleAppCrashInActivityController(r,crashInfo,shortMsg,longMsg,stackTrace,timeMillis)) {
      return;
    }
    if (r != null && r.instrumentationClass != null) {
      return;
    }
    if (r != null) {
      mService.mBatteryStatsService.noteProcessCrash(r.processName,r.uid);
    }
    AppErrorDialog.Data data=new AppErrorDialog.Data();
    data.result=result;
    data.proc=r;
    if (r == null || !makeAppCrashingLocked(r,shortMsg,longMsg,stackTrace,data)) {
      return;
    }
    Message msg=Message.obtain();
    msg.what=ActivityManagerService.SHOW_ERROR_UI_MSG;
    task=data.task;
    msg.obj=data;
    mService.mUiHandler.sendMessage(msg);
  }
  int res=result.get();
  Intent appErrorIntent=null;
  MetricsLogger.action(mContext,MetricsProto.MetricsEvent.ACTION_APP_CRASH,res);
  if (res == AppErrorDialog.TIMEOUT || res == AppErrorDialog.CANCEL) {
    res=AppErrorDialog.FORCE_QUIT;
  }
synchronized (mService) {
    if (res == AppErrorDialog.MUTE) {
      stopReportingCrashesLocked(r);
    }
    if (res == AppErrorDialog.RESTART) {
      mService.removeProcessLocked(r,false,true,""String_Node_Str"");
      if (task != null) {
        try {
          mService.startActivityFromRecents(task.taskId,ActivityOptions.makeBasic().toBundle());
        }
 catch (        IllegalArgumentException e) {
          if (task.intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
            mService.startActivityInPackage(task.mCallingUid,task.mCallingPackage,task.intent,null,null,null,0,0,ActivityOptions.makeBasic().toBundle(),task.userId,null,null);
          }
        }
      }
    }
    if (res == AppErrorDialog.FORCE_QUIT) {
      long orig=Binder.clearCallingIdentity();
      try {
        mService.mStackSupervisor.handleAppCrashLocked(r);
        if (!r.persistent) {
          mService.removeProcessLocked(r,false,false,""String_Node_Str"");
          mService.mStackSupervisor.resumeFocusedStackTopActivityLocked();
        }
      }
  finally {
        Binder.restoreCallingIdentity(orig);
      }
    }
    if (res == AppErrorDialog.FORCE_QUIT_AND_REPORT) {
      appErrorIntent=createAppErrorIntentLocked(r,timeMillis,crashInfo);
    }
    if (r != null && !r.isolated && res != AppErrorDialog.RESTART) {
      mProcessCrashTimes.put(r.info.processName,r.uid,SystemClock.uptimeMillis());
    }
  }
  if (appErrorIntent != null) {
    try {
      mContext.startActivityAsUser(appErrorIntent,new UserHandle(r.userId));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","void crashApplicationInner(ProcessRecord r,ApplicationErrorReport.CrashInfo crashInfo){
  long timeMillis=System.currentTimeMillis();
  String shortMsg=crashInfo.exceptionClassName;
  String longMsg=crashInfo.exceptionMessage;
  String stackTrace=crashInfo.stackTrace;
  if (shortMsg != null && longMsg != null) {
    longMsg=shortMsg + ""String_Node_Str"" + longMsg;
  }
 else   if (shortMsg != null) {
    longMsg=shortMsg;
  }
  AppErrorResult result=new AppErrorResult();
  TaskRecord task;
synchronized (mService) {
    if (handleAppCrashInActivityController(r,crashInfo,shortMsg,longMsg,stackTrace,timeMillis)) {
      return;
    }
    if (r != null && r.instrumentationClass != null) {
      return;
    }
    if (r != null) {
      mService.mBatteryStatsService.noteProcessCrash(r.processName,r.uid);
    }
    AppErrorDialog.Data data=new AppErrorDialog.Data();
    data.result=result;
    data.proc=r;
    if (r == null || !makeAppCrashingLocked(r,shortMsg,longMsg,stackTrace,data)) {
      return;
    }
    Message msg=Message.obtain();
    msg.what=ActivityManagerService.SHOW_ERROR_UI_MSG;
    task=data.task;
    msg.obj=data;
    mService.mUiHandler.sendMessage(msg);
  }
  int res=result.get();
  Intent appErrorIntent=null;
  MetricsLogger.action(mContext,MetricsProto.MetricsEvent.ACTION_APP_CRASH,res);
  if (res == AppErrorDialog.TIMEOUT || res == AppErrorDialog.CANCEL) {
    res=AppErrorDialog.FORCE_QUIT;
  }
synchronized (mService) {
    if (res == AppErrorDialog.MUTE) {
      stopReportingCrashesLocked(r);
    }
    if (res == AppErrorDialog.RESTART) {
      mService.removeProcessLocked(r,false,true,""String_Node_Str"");
      if (task != null) {
        try {
          mService.startActivityFromRecents(task.taskId,ActivityOptions.makeBasic().toBundle());
        }
 catch (        IllegalArgumentException e) {
          final Set<String> cats=task.intent.getCategories();
          if (cats != null && cats.contains(Intent.CATEGORY_LAUNCHER)) {
            mService.startActivityInPackage(task.mCallingUid,task.mCallingPackage,task.intent,null,null,null,0,0,ActivityOptions.makeBasic().toBundle(),task.userId,null,null);
          }
        }
      }
    }
    if (res == AppErrorDialog.FORCE_QUIT) {
      long orig=Binder.clearCallingIdentity();
      try {
        mService.mStackSupervisor.handleAppCrashLocked(r);
        if (!r.persistent) {
          mService.removeProcessLocked(r,false,false,""String_Node_Str"");
          mService.mStackSupervisor.resumeFocusedStackTopActivityLocked();
        }
      }
  finally {
        Binder.restoreCallingIdentity(orig);
      }
    }
    if (res == AppErrorDialog.FORCE_QUIT_AND_REPORT) {
      appErrorIntent=createAppErrorIntentLocked(r,timeMillis,crashInfo);
    }
    if (r != null && !r.isolated && res != AppErrorDialog.RESTART) {
      mProcessCrashTimes.put(r.info.processName,r.uid,SystemClock.uptimeMillis());
    }
  }
  if (appErrorIntent != null) {
    try {
      mContext.startActivityAsUser(appErrorIntent,new UserHandle(r.userId));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}",0.9901692183722804
191200,"/** 
 * @hide
 */
@TestApi public GnssMeasurementsEvent(GnssClock clock,GnssMeasurement[] measurements){
  if (clock == null) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
  if (measurements == null || measurements.length == 0) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
  mClock=clock;
  Collection<GnssMeasurement> measurementCollection=Arrays.asList(measurements);
  mReadOnlyMeasurements=Collections.unmodifiableCollection(measurementCollection);
}","/** 
 * @hide
 */
@TestApi public GnssMeasurementsEvent(GnssClock clock,GnssMeasurement[] measurements){
  if (clock == null) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
  if (measurements == null || measurements.length == 0) {
    mReadOnlyMeasurements=Collections.emptyList();
  }
 else {
    Collection<GnssMeasurement> measurementCollection=Arrays.asList(measurements);
    mReadOnlyMeasurements=Collections.unmodifiableCollection(measurementCollection);
  }
  mClock=clock;
}",0.5656970912738215
191201,"@Override public void handleMessage(Message msg){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG_WM,""String_Node_Str"" + msg.what);
  }
switch (msg.what) {
case REPORT_FOCUS_CHANGE:
{
      WindowState lastFocus;
      WindowState newFocus;
      AccessibilityController accessibilityController=null;
synchronized (mWindowMap) {
        if (mAccessibilityController != null && getDefaultDisplayContentLocked().getDisplayId() == Display.DEFAULT_DISPLAY) {
          accessibilityController=mAccessibilityController;
        }
        lastFocus=mLastFocus;
        newFocus=mCurrentFocus;
        if (lastFocus == newFocus) {
          return;
        }
        mLastFocus=newFocus;
        if (DEBUG_FOCUS_LIGHT)         Slog.i(TAG_WM,""String_Node_Str"" + lastFocus + ""String_Node_Str""+ newFocus);
        if (newFocus != null && lastFocus != null && !newFocus.isDisplayedLw()) {
          mLosingFocus.add(lastFocus);
          lastFocus=null;
        }
      }
      if (accessibilityController != null) {
        accessibilityController.onWindowFocusChangedNotLocked();
      }
      if (newFocus != null) {
        if (DEBUG_FOCUS_LIGHT)         Slog.i(TAG_WM,""String_Node_Str"" + newFocus);
        newFocus.reportFocusChangedSerialized(true,mInTouchMode);
        notifyFocusChanged();
      }
      if (lastFocus != null) {
        if (DEBUG_FOCUS_LIGHT)         Slog.i(TAG_WM,""String_Node_Str"" + lastFocus);
        lastFocus.reportFocusChangedSerialized(false,mInTouchMode);
      }
    }
  break;
case REPORT_LOSING_FOCUS:
{
  ArrayList<WindowState> losers;
synchronized (mWindowMap) {
    losers=mLosingFocus;
    mLosingFocus=new ArrayList<WindowState>();
  }
  final int N=losers.size();
  for (int i=0; i < N; i++) {
    if (DEBUG_FOCUS_LIGHT)     Slog.i(TAG_WM,""String_Node_Str"" + losers.get(i));
    losers.get(i).reportFocusChangedSerialized(false,mInTouchMode);
  }
}
break;
case DO_TRAVERSAL:
{
synchronized (mWindowMap) {
mWindowPlacerLocked.performSurfacePlacement();
}
}
break;
case ADD_STARTING:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
final StartingData sd=wtoken.startingData;
if (sd == null) {
return;
}
if (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ sd.pkg);
View view=null;
try {
final Configuration overrideConfig=wtoken != null && wtoken.mTask != null ? wtoken.mTask.mOverrideConfig : null;
view=mPolicy.addStartingWindow(wtoken.token,sd.pkg,sd.theme,sd.compatInfo,sd.nonLocalizedLabel,sd.labelRes,sd.icon,sd.logo,sd.windowFlags,overrideConfig);
}
 catch (Exception e) {
Slog.w(TAG_WM,""String_Node_Str"",e);
}
if (view != null) {
boolean abort=false;
synchronized (mWindowMap) {
if (wtoken.removed || wtoken.startingData == null) {
if (wtoken.startingWindow != null) {
  if (DEBUG_STARTING_WINDOW)   Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.removed+ ""String_Node_Str""+ wtoken.startingData);
  wtoken.startingWindow=null;
  wtoken.startingData=null;
  abort=true;
}
}
 else {
wtoken.startingView=view;
}
if (DEBUG_STARTING_WINDOW && !abort) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.startingWindow+ ""String_Node_Str""+ wtoken.startingView);
}
if (abort) {
try {
mPolicy.removeStartingWindow(wtoken.token,view);
}
 catch (Exception e) {
Slog.w(TAG_WM,""String_Node_Str"",e);
}
}
}
}
break;
case REMOVE_STARTING:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
IBinder token=null;
View view=null;
synchronized (mWindowMap) {
if (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.startingWindow+ ""String_Node_Str""+ wtoken.startingView);
if (wtoken.startingWindow != null) {
view=wtoken.startingView;
token=wtoken.token;
wtoken.startingData=null;
wtoken.startingView=null;
wtoken.startingWindow=null;
wtoken.startingDisplayed=false;
}
}
if (view != null) {
try {
mPolicy.removeStartingWindow(token,view);
}
 catch (Exception e) {
Slog.w(TAG_WM,""String_Node_Str"",e);
}
}
}
break;
case FINISHED_STARTING:
{
IBinder token=null;
View view=null;
while (true) {
synchronized (mWindowMap) {
final int N=mFinishedStarting.size();
if (N <= 0) {
break;
}
AppWindowToken wtoken=mFinishedStarting.remove(N - 1);
if (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.startingWindow+ ""String_Node_Str""+ wtoken.startingView);
if (wtoken.startingWindow == null) {
continue;
}
view=wtoken.startingView;
token=wtoken.token;
wtoken.startingData=null;
wtoken.startingView=null;
wtoken.startingWindow=null;
wtoken.startingDisplayed=false;
}
try {
mPolicy.removeStartingWindow(token,view);
}
 catch (Exception e) {
Slog.w(TAG_WM,""String_Node_Str"",e);
}
}
}
break;
case REPORT_APPLICATION_TOKEN_DRAWN:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
try {
if (DEBUG_VISIBILITY) Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
wtoken.appToken.windowsDrawn();
}
 catch (RemoteException ex) {
}
}
break;
case REPORT_APPLICATION_TOKEN_WINDOWS:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
boolean nowVisible=msg.arg1 != 0;
boolean nowGone=msg.arg2 != 0;
try {
if (DEBUG_VISIBILITY) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ nowVisible+ ""String_Node_Str""+ nowGone);
if (nowVisible) {
wtoken.appToken.windowsVisible();
}
 else {
wtoken.appToken.windowsGone();
}
}
 catch (RemoteException ex) {
}
}
break;
case WINDOW_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
Slog.w(TAG_WM,""String_Node_Str"");
mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_TIMEOUT;
final WindowList windows=getDefaultWindowListLocked();
int i=windows.size();
while (i > 0) {
i--;
WindowState w=windows.get(i);
if (w.mOrientationChanging) {
w.mOrientationChanging=false;
w.mLastFreezeDuration=(int)(SystemClock.elapsedRealtime() - mDisplayFreezeTime);
Slog.w(TAG_WM,""String_Node_Str"" + w);
}
}
mWindowPlacerLocked.performSurfacePlacement();
}
break;
}
case APP_TRANSITION_TIMEOUT:
{
synchronized (mWindowMap) {
if (mAppTransition.isTransitionSet() || !mOpeningApps.isEmpty() || !mClosingApps.isEmpty()) {
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + mAppTransition.isTransitionSet() + ""String_Node_Str""+ mOpeningApps.size()+ ""String_Node_Str""+ mClosingApps.size());
mAppTransition.setTimeout();
mWindowPlacerLocked.performSurfacePlacement();
}
}
break;
}
case PERSIST_ANIMATION_SCALE:
{
Settings.Global.putFloat(mContext.getContentResolver(),Settings.Global.WINDOW_ANIMATION_SCALE,mWindowAnimationScaleSetting);
Settings.Global.putFloat(mContext.getContentResolver(),Settings.Global.TRANSITION_ANIMATION_SCALE,mTransitionAnimationScaleSetting);
Settings.Global.putFloat(mContext.getContentResolver(),Settings.Global.ANIMATOR_DURATION_SCALE,mAnimatorDurationScaleSetting);
break;
}
case UPDATE_ANIMATION_SCALE:
{
@UpdateAnimationScaleMode final int mode=msg.arg1;
switch (mode) {
case WINDOW_ANIMATION_SCALE:
{
mWindowAnimationScaleSetting=Settings.Global.getFloat(mContext.getContentResolver(),Settings.Global.WINDOW_ANIMATION_SCALE,mWindowAnimationScaleSetting);
break;
}
case TRANSITION_ANIMATION_SCALE:
{
mTransitionAnimationScaleSetting=Settings.Global.getFloat(mContext.getContentResolver(),Settings.Global.TRANSITION_ANIMATION_SCALE,mTransitionAnimationScaleSetting);
break;
}
case ANIMATION_DURATION_SCALE:
{
mAnimatorDurationScaleSetting=Settings.Global.getFloat(mContext.getContentResolver(),Settings.Global.ANIMATOR_DURATION_SCALE,mAnimatorDurationScaleSetting);
dispatchNewAnimatorScaleLocked(null);
break;
}
}
break;
}
case FORCE_GC:
{
synchronized (mWindowMap) {
if (mAnimator.isAnimating() || mAnimationScheduled) {
sendEmptyMessageDelayed(H.FORCE_GC,2000);
return;
}
if (mDisplayFrozen) {
return;
}
}
Runtime.getRuntime().gc();
break;
}
case ENABLE_SCREEN:
{
performEnableScreen();
break;
}
case APP_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
Slog.w(TAG_WM,""String_Node_Str"");
mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_TIMEOUT;
final int numStacks=mStackIdToStack.size();
for (int stackNdx=0; stackNdx < numStacks; ++stackNdx) {
final TaskStack stack=mStackIdToStack.valueAt(stackNdx);
final ArrayList<Task> tasks=stack.getTasks();
for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
AppTokenList tokens=tasks.get(taskNdx).mAppTokens;
for (int tokenNdx=tokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
AppWindowToken tok=tokens.get(tokenNdx);
if (tok.mAppAnimator.freezingScreen) {
Slog.w(TAG_WM,""String_Node_Str"" + tok);
unsetAppFreezingScreenLocked(tok,true,true);
}
}
}
}
}
break;
}
case CLIENT_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
if (mClientFreezingScreen) {
mClientFreezingScreen=false;
mLastFinishedFreezeSource=""String_Node_Str"";
stopFreezingDisplayLocked();
}
}
break;
}
case SEND_NEW_CONFIGURATION:
{
removeMessages(SEND_NEW_CONFIGURATION);
sendNewConfiguration();
break;
}
case REPORT_WINDOWS_CHANGE:
{
if (mWindowsChanged) {
synchronized (mWindowMap) {
mWindowsChanged=false;
}
notifyWindowsChanged();
}
break;
}
case DRAG_START_TIMEOUT:
{
IBinder win=(IBinder)msg.obj;
if (DEBUG_DRAG) {
Slog.w(TAG_WM,""String_Node_Str"" + win);
}
synchronized (mWindowMap) {
if (mDragState != null) {
mDragState.unregister();
mInputMonitor.updateInputWindowsLw(true);
mDragState.reset();
mDragState=null;
}
}
break;
}
case DRAG_END_TIMEOUT:
{
IBinder win=(IBinder)msg.obj;
if (DEBUG_DRAG) {
Slog.w(TAG_WM,""String_Node_Str"" + win);
}
synchronized (mWindowMap) {
if (mDragState != null) {
mDragState.mDragResult=false;
mDragState.endDragLw();
}
}
break;
}
case REPORT_HARD_KEYBOARD_STATUS_CHANGE:
{
notifyHardKeyboardStatusChange();
break;
}
case BOOT_TIMEOUT:
{
performBootTimeout();
break;
}
case WAITING_FOR_DRAWN_TIMEOUT:
{
Runnable callback=null;
synchronized (mWindowMap) {
Slog.w(TAG_WM,""String_Node_Str"" + mWaitingForDrawn);
mWaitingForDrawn.clear();
callback=mWaitingForDrawnCallback;
mWaitingForDrawnCallback=null;
}
if (callback != null) {
callback.run();
}
break;
}
case SHOW_STRICT_MODE_VIOLATION:
{
showStrictModeViolation(msg.arg1,msg.arg2);
break;
}
case SHOW_CIRCULAR_DISPLAY_MASK:
{
showCircularMask(msg.arg1 == 1);
break;
}
case SHOW_EMULATOR_DISPLAY_OVERLAY:
{
showEmulatorDisplayOverlay();
break;
}
case DO_ANIMATION_CALLBACK:
{
try {
((IRemoteCallback)msg.obj).sendResult(null);
}
 catch (RemoteException e) {
}
break;
}
case DO_DISPLAY_ADDED:
handleDisplayAdded(msg.arg1);
break;
case DO_DISPLAY_REMOVED:
synchronized (mWindowMap) {
handleDisplayRemovedLocked(msg.arg1);
}
break;
case DO_DISPLAY_CHANGED:
synchronized (mWindowMap) {
handleDisplayChangedLocked(msg.arg1);
}
break;
case TWO_FINGER_SCROLL_START:
{
startScrollingTask((DisplayContent)msg.obj,msg.arg1,msg.arg2);
}
break;
case TAP_OUTSIDE_TASK:
{
handleTapOutsideTask((DisplayContent)msg.obj,msg.arg1,msg.arg2);
}
break;
case FINISH_TASK_POSITIONING:
{
finishPositioning();
}
break;
case NOTIFY_ACTIVITY_DRAWN:
try {
mActivityManager.notifyActivityDrawn((IBinder)msg.obj);
}
 catch (RemoteException e) {
}
break;
case ALL_WINDOWS_DRAWN:
{
Runnable callback;
synchronized (mWindowMap) {
callback=mWaitingForDrawnCallback;
mWaitingForDrawnCallback=null;
}
if (callback != null) {
callback.run();
}
}
case NEW_ANIMATOR_SCALE:
{
float scale=getCurrentAnimatorScale();
ValueAnimator.setDurationScale(scale);
Session session=(Session)msg.obj;
if (session != null) {
try {
session.mCallback.onAnimatorScaleChanged(scale);
}
 catch (RemoteException e) {
}
}
 else {
ArrayList<IWindowSessionCallback> callbacks=new ArrayList<IWindowSessionCallback>();
synchronized (mWindowMap) {
for (int i=0; i < mSessions.size(); i++) {
callbacks.add(mSessions.valueAt(i).mCallback);
}
}
for (int i=0; i < callbacks.size(); i++) {
try {
callbacks.get(i).onAnimatorScaleChanged(scale);
}
 catch (RemoteException e) {
}
}
}
}
break;
case CHECK_IF_BOOT_ANIMATION_FINISHED:
{
final boolean bootAnimationComplete;
synchronized (mWindowMap) {
if (DEBUG_BOOT) Slog.i(TAG_WM,""String_Node_Str"");
bootAnimationComplete=checkBootAnimationCompleteLocked();
}
if (bootAnimationComplete) {
performEnableScreen();
}
}
break;
case RESET_ANR_MESSAGE:
{
synchronized (mWindowMap) {
mLastANRState=null;
}
}
break;
case WALLPAPER_DRAW_PENDING_TIMEOUT:
{
synchronized (mWindowMap) {
if (mWallpaperControllerLocked.processWallpaperDrawPendingTimeout()) {
mWindowPlacerLocked.performSurfacePlacement();
}
}
}
case UPDATE_DOCKED_STACK_DIVIDER:
{
synchronized (mWindowMap) {
final DisplayContent displayContent=getDefaultDisplayContentLocked();
displayContent.getDockedDividerController().reevaluateVisibility(false);
adjustForImeIfNeeded(displayContent);
}
}
break;
case RESIZE_TASK:
{
try {
mActivityManager.resizeTask(msg.arg1,(Rect)msg.obj,msg.arg2);
}
 catch (RemoteException e) {
}
}
break;
case RESIZE_STACK:
{
try {
mActivityManager.resizeStack(msg.arg1,(Rect)msg.obj,msg.arg2 == 1,false,false,-1);
}
 catch (RemoteException e) {
}
}
break;
case WINDOW_REPLACEMENT_TIMEOUT:
{
synchronized (mWindowMap) {
for (int i=mReplacingWindowTimeouts.size() - 1; i >= 0; i--) {
final AppWindowToken token=mReplacingWindowTimeouts.get(i);
token.clearTimedoutReplacesLocked();
}
mReplacingWindowTimeouts.clear();
}
}
case NOTIFY_APP_TRANSITION_STARTING:
{
mAmInternal.notifyAppTransitionStarting(msg.arg1);
}
break;
case NOTIFY_APP_TRANSITION_CANCELLED:
{
mAmInternal.notifyAppTransitionCancelled();
}
break;
case NOTIFY_APP_TRANSITION_FINISHED:
{
mAmInternal.notifyAppTransitionFinished();
}
break;
case NOTIFY_STARTING_WINDOW_DRAWN:
{
mAmInternal.notifyStartingWindowDrawn();
}
break;
case WINDOW_REMOVE_TIMEOUT:
{
final WindowState window=(WindowState)msg.obj;
synchronized (mWindowMap) {
window.mAttrs.flags&=~FLAG_KEEP_SCREEN_ON;
window.setDisplayLayoutNeeded();
mWindowPlacerLocked.performSurfacePlacement();
}
}
break;
case NOTIFY_DOCKED_STACK_MINIMIZED_CHANGED:
{
mAmInternal.notifyDockedStackMinimizedChanged(msg.arg1 == 1);
}
break;
case SEAMLESS_ROTATION_TIMEOUT:
{
final DisplayContent displayContent=getDefaultDisplayContentLocked();
final WindowList windows=displayContent.getWindowList();
boolean layoutNeeded=false;
for (int i=windows.size() - 1; i >= 0; i--) {
WindowState w=windows.get(i);
if (w.mSeamlesslyRotated) {
layoutNeeded=true;
w.setDisplayLayoutNeeded();
}
w.mSeamlesslyRotated=false;
}
if (layoutNeeded) {
mWindowPlacerLocked.performSurfacePlacement();
}
}
break;
}
if (DEBUG_WINDOW_TRACE) {
Slog.v(TAG_WM,""String_Node_Str"");
}
}","@Override public void handleMessage(Message msg){
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG_WM,""String_Node_Str"" + msg.what);
  }
switch (msg.what) {
case REPORT_FOCUS_CHANGE:
{
      WindowState lastFocus;
      WindowState newFocus;
      AccessibilityController accessibilityController=null;
synchronized (mWindowMap) {
        if (mAccessibilityController != null && getDefaultDisplayContentLocked().getDisplayId() == Display.DEFAULT_DISPLAY) {
          accessibilityController=mAccessibilityController;
        }
        lastFocus=mLastFocus;
        newFocus=mCurrentFocus;
        if (lastFocus == newFocus) {
          return;
        }
        mLastFocus=newFocus;
        if (DEBUG_FOCUS_LIGHT)         Slog.i(TAG_WM,""String_Node_Str"" + lastFocus + ""String_Node_Str""+ newFocus);
        if (newFocus != null && lastFocus != null && !newFocus.isDisplayedLw()) {
          mLosingFocus.add(lastFocus);
          lastFocus=null;
        }
      }
      if (accessibilityController != null) {
        accessibilityController.onWindowFocusChangedNotLocked();
      }
      if (newFocus != null) {
        if (DEBUG_FOCUS_LIGHT)         Slog.i(TAG_WM,""String_Node_Str"" + newFocus);
        newFocus.reportFocusChangedSerialized(true,mInTouchMode);
        notifyFocusChanged();
      }
      if (lastFocus != null) {
        if (DEBUG_FOCUS_LIGHT)         Slog.i(TAG_WM,""String_Node_Str"" + lastFocus);
        lastFocus.reportFocusChangedSerialized(false,mInTouchMode);
      }
    }
  break;
case REPORT_LOSING_FOCUS:
{
  ArrayList<WindowState> losers;
synchronized (mWindowMap) {
    losers=mLosingFocus;
    mLosingFocus=new ArrayList<WindowState>();
  }
  final int N=losers.size();
  for (int i=0; i < N; i++) {
    if (DEBUG_FOCUS_LIGHT)     Slog.i(TAG_WM,""String_Node_Str"" + losers.get(i));
    losers.get(i).reportFocusChangedSerialized(false,mInTouchMode);
  }
}
break;
case DO_TRAVERSAL:
{
synchronized (mWindowMap) {
mWindowPlacerLocked.performSurfacePlacement();
}
}
break;
case ADD_STARTING:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
final StartingData sd=wtoken.startingData;
if (sd == null) {
return;
}
if (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ sd.pkg);
View view=null;
try {
final Configuration overrideConfig=wtoken != null && wtoken.mTask != null ? wtoken.mTask.mOverrideConfig : null;
view=mPolicy.addStartingWindow(wtoken.token,sd.pkg,sd.theme,sd.compatInfo,sd.nonLocalizedLabel,sd.labelRes,sd.icon,sd.logo,sd.windowFlags,overrideConfig);
}
 catch (Exception e) {
Slog.w(TAG_WM,""String_Node_Str"",e);
}
if (view != null) {
boolean abort=false;
synchronized (mWindowMap) {
if (wtoken.removed || wtoken.startingData == null) {
if (wtoken.startingWindow != null) {
  if (DEBUG_STARTING_WINDOW)   Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.removed+ ""String_Node_Str""+ wtoken.startingData);
  wtoken.startingWindow=null;
  wtoken.startingData=null;
  abort=true;
}
}
 else {
wtoken.startingView=view;
}
if (DEBUG_STARTING_WINDOW && !abort) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.startingWindow+ ""String_Node_Str""+ wtoken.startingView);
}
if (abort) {
try {
mPolicy.removeStartingWindow(wtoken.token,view);
}
 catch (Exception e) {
Slog.w(TAG_WM,""String_Node_Str"",e);
}
}
}
}
break;
case REMOVE_STARTING:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
IBinder token=null;
View view=null;
synchronized (mWindowMap) {
if (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.startingWindow+ ""String_Node_Str""+ wtoken.startingView);
if (wtoken.startingWindow != null) {
view=wtoken.startingView;
token=wtoken.token;
wtoken.startingData=null;
wtoken.startingView=null;
wtoken.startingWindow=null;
wtoken.startingDisplayed=false;
}
}
if (view != null) {
try {
mPolicy.removeStartingWindow(token,view);
}
 catch (Exception e) {
Slog.w(TAG_WM,""String_Node_Str"",e);
}
}
}
break;
case FINISHED_STARTING:
{
IBinder token=null;
View view=null;
while (true) {
synchronized (mWindowMap) {
final int N=mFinishedStarting.size();
if (N <= 0) {
break;
}
AppWindowToken wtoken=mFinishedStarting.remove(N - 1);
if (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.startingWindow+ ""String_Node_Str""+ wtoken.startingView);
if (wtoken.startingWindow == null) {
continue;
}
view=wtoken.startingView;
token=wtoken.token;
wtoken.startingData=null;
wtoken.startingView=null;
wtoken.startingWindow=null;
wtoken.startingDisplayed=false;
}
try {
mPolicy.removeStartingWindow(token,view);
}
 catch (Exception e) {
Slog.w(TAG_WM,""String_Node_Str"",e);
}
}
}
break;
case REPORT_APPLICATION_TOKEN_DRAWN:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
try {
if (DEBUG_VISIBILITY) Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
wtoken.appToken.windowsDrawn();
}
 catch (RemoteException ex) {
}
}
break;
case REPORT_APPLICATION_TOKEN_WINDOWS:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
boolean nowVisible=msg.arg1 != 0;
boolean nowGone=msg.arg2 != 0;
try {
if (DEBUG_VISIBILITY) Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ nowVisible+ ""String_Node_Str""+ nowGone);
if (nowVisible) {
wtoken.appToken.windowsVisible();
}
 else {
wtoken.appToken.windowsGone();
}
}
 catch (RemoteException ex) {
}
}
break;
case WINDOW_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
Slog.w(TAG_WM,""String_Node_Str"");
mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_TIMEOUT;
final WindowList windows=getDefaultWindowListLocked();
int i=windows.size();
while (i > 0) {
i--;
WindowState w=windows.get(i);
if (w.mOrientationChanging) {
w.mOrientationChanging=false;
w.mLastFreezeDuration=(int)(SystemClock.elapsedRealtime() - mDisplayFreezeTime);
Slog.w(TAG_WM,""String_Node_Str"" + w);
}
}
mWindowPlacerLocked.performSurfacePlacement();
}
break;
}
case APP_TRANSITION_TIMEOUT:
{
synchronized (mWindowMap) {
if (mAppTransition.isTransitionSet() || !mOpeningApps.isEmpty() || !mClosingApps.isEmpty()) {
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + mAppTransition.isTransitionSet() + ""String_Node_Str""+ mOpeningApps.size()+ ""String_Node_Str""+ mClosingApps.size());
mAppTransition.setTimeout();
mWindowPlacerLocked.performSurfacePlacement();
}
}
break;
}
case PERSIST_ANIMATION_SCALE:
{
Settings.Global.putFloat(mContext.getContentResolver(),Settings.Global.WINDOW_ANIMATION_SCALE,mWindowAnimationScaleSetting);
Settings.Global.putFloat(mContext.getContentResolver(),Settings.Global.TRANSITION_ANIMATION_SCALE,mTransitionAnimationScaleSetting);
Settings.Global.putFloat(mContext.getContentResolver(),Settings.Global.ANIMATOR_DURATION_SCALE,mAnimatorDurationScaleSetting);
break;
}
case UPDATE_ANIMATION_SCALE:
{
@UpdateAnimationScaleMode final int mode=msg.arg1;
switch (mode) {
case WINDOW_ANIMATION_SCALE:
{
mWindowAnimationScaleSetting=Settings.Global.getFloat(mContext.getContentResolver(),Settings.Global.WINDOW_ANIMATION_SCALE,mWindowAnimationScaleSetting);
break;
}
case TRANSITION_ANIMATION_SCALE:
{
mTransitionAnimationScaleSetting=Settings.Global.getFloat(mContext.getContentResolver(),Settings.Global.TRANSITION_ANIMATION_SCALE,mTransitionAnimationScaleSetting);
break;
}
case ANIMATION_DURATION_SCALE:
{
mAnimatorDurationScaleSetting=Settings.Global.getFloat(mContext.getContentResolver(),Settings.Global.ANIMATOR_DURATION_SCALE,mAnimatorDurationScaleSetting);
dispatchNewAnimatorScaleLocked(null);
break;
}
}
break;
}
case FORCE_GC:
{
synchronized (mWindowMap) {
if (mAnimator.isAnimating() || mAnimationScheduled) {
sendEmptyMessageDelayed(H.FORCE_GC,2000);
return;
}
if (mDisplayFrozen) {
return;
}
}
Runtime.getRuntime().gc();
break;
}
case ENABLE_SCREEN:
{
performEnableScreen();
break;
}
case APP_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
Slog.w(TAG_WM,""String_Node_Str"");
mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_TIMEOUT;
final int numStacks=mStackIdToStack.size();
for (int stackNdx=0; stackNdx < numStacks; ++stackNdx) {
final TaskStack stack=mStackIdToStack.valueAt(stackNdx);
final ArrayList<Task> tasks=stack.getTasks();
for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
AppTokenList tokens=tasks.get(taskNdx).mAppTokens;
for (int tokenNdx=tokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
AppWindowToken tok=tokens.get(tokenNdx);
if (tok.mAppAnimator.freezingScreen) {
Slog.w(TAG_WM,""String_Node_Str"" + tok);
unsetAppFreezingScreenLocked(tok,true,true);
}
}
}
}
}
break;
}
case CLIENT_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
if (mClientFreezingScreen) {
mClientFreezingScreen=false;
mLastFinishedFreezeSource=""String_Node_Str"";
stopFreezingDisplayLocked();
}
}
break;
}
case SEND_NEW_CONFIGURATION:
{
removeMessages(SEND_NEW_CONFIGURATION);
sendNewConfiguration();
break;
}
case REPORT_WINDOWS_CHANGE:
{
if (mWindowsChanged) {
synchronized (mWindowMap) {
mWindowsChanged=false;
}
notifyWindowsChanged();
}
break;
}
case DRAG_START_TIMEOUT:
{
IBinder win=(IBinder)msg.obj;
if (DEBUG_DRAG) {
Slog.w(TAG_WM,""String_Node_Str"" + win);
}
synchronized (mWindowMap) {
if (mDragState != null) {
mDragState.unregister();
mInputMonitor.updateInputWindowsLw(true);
mDragState.reset();
mDragState=null;
}
}
break;
}
case DRAG_END_TIMEOUT:
{
IBinder win=(IBinder)msg.obj;
if (DEBUG_DRAG) {
Slog.w(TAG_WM,""String_Node_Str"" + win);
}
synchronized (mWindowMap) {
if (mDragState != null) {
mDragState.mDragResult=false;
mDragState.endDragLw();
}
}
break;
}
case REPORT_HARD_KEYBOARD_STATUS_CHANGE:
{
notifyHardKeyboardStatusChange();
break;
}
case BOOT_TIMEOUT:
{
performBootTimeout();
break;
}
case WAITING_FOR_DRAWN_TIMEOUT:
{
Runnable callback=null;
synchronized (mWindowMap) {
Slog.w(TAG_WM,""String_Node_Str"" + mWaitingForDrawn);
mWaitingForDrawn.clear();
callback=mWaitingForDrawnCallback;
mWaitingForDrawnCallback=null;
}
if (callback != null) {
callback.run();
}
break;
}
case SHOW_STRICT_MODE_VIOLATION:
{
showStrictModeViolation(msg.arg1,msg.arg2);
break;
}
case SHOW_CIRCULAR_DISPLAY_MASK:
{
showCircularMask(msg.arg1 == 1);
break;
}
case SHOW_EMULATOR_DISPLAY_OVERLAY:
{
showEmulatorDisplayOverlay();
break;
}
case DO_ANIMATION_CALLBACK:
{
try {
((IRemoteCallback)msg.obj).sendResult(null);
}
 catch (RemoteException e) {
}
break;
}
case DO_DISPLAY_ADDED:
handleDisplayAdded(msg.arg1);
break;
case DO_DISPLAY_REMOVED:
synchronized (mWindowMap) {
handleDisplayRemovedLocked(msg.arg1);
}
break;
case DO_DISPLAY_CHANGED:
synchronized (mWindowMap) {
handleDisplayChangedLocked(msg.arg1);
}
break;
case TWO_FINGER_SCROLL_START:
{
startScrollingTask((DisplayContent)msg.obj,msg.arg1,msg.arg2);
}
break;
case TAP_OUTSIDE_TASK:
{
handleTapOutsideTask((DisplayContent)msg.obj,msg.arg1,msg.arg2);
}
break;
case FINISH_TASK_POSITIONING:
{
finishPositioning();
}
break;
case NOTIFY_ACTIVITY_DRAWN:
try {
mActivityManager.notifyActivityDrawn((IBinder)msg.obj);
}
 catch (RemoteException e) {
}
break;
case ALL_WINDOWS_DRAWN:
{
Runnable callback;
synchronized (mWindowMap) {
callback=mWaitingForDrawnCallback;
mWaitingForDrawnCallback=null;
}
if (callback != null) {
callback.run();
}
}
case NEW_ANIMATOR_SCALE:
{
float scale=getCurrentAnimatorScale();
ValueAnimator.setDurationScale(scale);
Session session=(Session)msg.obj;
if (session != null) {
try {
session.mCallback.onAnimatorScaleChanged(scale);
}
 catch (RemoteException e) {
}
}
 else {
ArrayList<IWindowSessionCallback> callbacks=new ArrayList<IWindowSessionCallback>();
synchronized (mWindowMap) {
for (int i=0; i < mSessions.size(); i++) {
callbacks.add(mSessions.valueAt(i).mCallback);
}
}
for (int i=0; i < callbacks.size(); i++) {
try {
callbacks.get(i).onAnimatorScaleChanged(scale);
}
 catch (RemoteException e) {
}
}
}
}
break;
case CHECK_IF_BOOT_ANIMATION_FINISHED:
{
final boolean bootAnimationComplete;
synchronized (mWindowMap) {
if (DEBUG_BOOT) Slog.i(TAG_WM,""String_Node_Str"");
bootAnimationComplete=checkBootAnimationCompleteLocked();
}
if (bootAnimationComplete) {
performEnableScreen();
}
}
break;
case RESET_ANR_MESSAGE:
{
synchronized (mWindowMap) {
mLastANRState=null;
}
}
break;
case WALLPAPER_DRAW_PENDING_TIMEOUT:
{
synchronized (mWindowMap) {
if (mWallpaperControllerLocked.processWallpaperDrawPendingTimeout()) {
mWindowPlacerLocked.performSurfacePlacement();
}
}
}
case UPDATE_DOCKED_STACK_DIVIDER:
{
synchronized (mWindowMap) {
final DisplayContent displayContent=getDefaultDisplayContentLocked();
displayContent.getDockedDividerController().reevaluateVisibility(false);
adjustForImeIfNeeded(displayContent);
}
}
break;
case RESIZE_TASK:
{
try {
mActivityManager.resizeTask(msg.arg1,(Rect)msg.obj,msg.arg2);
}
 catch (RemoteException e) {
}
}
break;
case RESIZE_STACK:
{
try {
mActivityManager.resizeStack(msg.arg1,(Rect)msg.obj,msg.arg2 == 1,false,false,-1);
}
 catch (RemoteException e) {
}
}
break;
case WINDOW_REPLACEMENT_TIMEOUT:
{
synchronized (mWindowMap) {
for (int i=mReplacingWindowTimeouts.size() - 1; i >= 0; i--) {
final AppWindowToken token=mReplacingWindowTimeouts.get(i);
token.clearTimedoutReplacesLocked();
}
mReplacingWindowTimeouts.clear();
}
}
case NOTIFY_APP_TRANSITION_STARTING:
{
mAmInternal.notifyAppTransitionStarting(msg.arg1);
}
break;
case NOTIFY_APP_TRANSITION_CANCELLED:
{
mAmInternal.notifyAppTransitionCancelled();
}
break;
case NOTIFY_APP_TRANSITION_FINISHED:
{
mAmInternal.notifyAppTransitionFinished();
}
break;
case NOTIFY_STARTING_WINDOW_DRAWN:
{
mAmInternal.notifyStartingWindowDrawn();
}
break;
case WINDOW_REMOVE_TIMEOUT:
{
final WindowState window=(WindowState)msg.obj;
synchronized (mWindowMap) {
window.mAttrs.flags&=~FLAG_KEEP_SCREEN_ON;
window.setDisplayLayoutNeeded();
mWindowPlacerLocked.performSurfacePlacement();
}
}
break;
case NOTIFY_DOCKED_STACK_MINIMIZED_CHANGED:
{
mAmInternal.notifyDockedStackMinimizedChanged(msg.arg1 == 1);
}
break;
case SEAMLESS_ROTATION_TIMEOUT:
{
synchronized (mWindowMap) {
final DisplayContent displayContent=getDefaultDisplayContentLocked();
final WindowList windows=displayContent.getWindowList();
boolean layoutNeeded=false;
for (int i=windows.size() - 1; i >= 0; i--) {
WindowState w=windows.get(i);
if (w.mSeamlesslyRotated) {
layoutNeeded=true;
w.setDisplayLayoutNeeded();
}
w.mSeamlesslyRotated=false;
}
if (layoutNeeded) {
mWindowPlacerLocked.performSurfacePlacement();
}
}
}
break;
}
if (DEBUG_WINDOW_TRACE) {
Slog.v(TAG_WM,""String_Node_Str"");
}
}",0.9989485489976168
191202,"public int getCode(){
  return mEvent.getCode();
}","public int getCode(){
  return mEvent != null ? mEvent.getCode() : -1;
}",0.819672131147541
191203,"public int getCode(){
  return mEvent.getCode();
}","public int getCode(){
  return mEvent != null ? mEvent.getCode() : -1;
}",0.819672131147541
191204,"private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  final boolean newService=app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    if (LOG_SERVICE_START_STOP) {
      String nameTerm;
      int lastPeriod=r.shortName.lastIndexOf('.');
      nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
      EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
    }
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_SERVICE);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
 catch (  DeadObjectException e) {
    Slog.w(TAG,""String_Node_Str"" + r);
    mAm.appDiedLocked(app);
    throw e;
  }
 finally {
    if (!created) {
      final boolean inDestroying=mDestroyingServices.contains(r);
      serviceDoneExecutingLocked(r,inDestroying,inDestroying);
      if (newService) {
        app.services.remove(r);
        r.app=null;
      }
      if (!inDestroying) {
        scheduleServiceRestartLocked(r,false);
      }
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  updateServiceClientActivitiesLocked(app,null,true);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}","private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  final boolean newService=app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    if (LOG_SERVICE_START_STOP) {
      String nameTerm;
      int lastPeriod=r.shortName.lastIndexOf('.');
      nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
      EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
    }
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_SERVICE);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
 catch (  DeadObjectException e) {
    Slog.w(TAG,""String_Node_Str"" + r);
    mAm.appDiedLocked(app);
    throw e;
  }
 finally {
    if (!created) {
      final boolean inDestroying=mDestroyingServices.contains(r);
      serviceDoneExecutingLocked(r,inDestroying,inDestroying);
      if (newService) {
        app.services.remove(r);
        r.app=null;
      }
      if (!inDestroying) {
        scheduleServiceRestartLocked(r,false);
      }
    }
  }
  if (r.whitelistManager) {
    app.whitelistManager=true;
  }
  requestServiceBindingsLocked(r,execInFg);
  updateServiceClientActivitiesLocked(app,null,true);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}",0.9873009473896392
191205,"private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r,false);
        r.tracker=null;
      }
    }
    if (finishing) {
      if (r.app != null && !r.app.persistent) {
        r.app.services.remove(r);
      }
      r.app=null;
    }
  }
}","private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r,false);
        r.tracker=null;
      }
    }
    if (finishing) {
      if (r.app != null && !r.app.persistent) {
        r.app.services.remove(r);
        if (r.whitelistManager) {
          updateWhitelistManagerLocked(r.app);
        }
      }
      r.app=null;
    }
  }
}",0.974559686888454
191206,"private boolean collectPackageServicesLocked(String packageName,Set<String> filterByClasses,boolean evenPersistent,boolean doit,boolean killProcess,ArrayMap<ComponentName,ServiceRecord> services){
  boolean didSomething=false;
  for (int i=services.size() - 1; i >= 0; i--) {
    ServiceRecord service=services.valueAt(i);
    final boolean sameComponent=packageName == null || (service.packageName.equals(packageName) && (filterByClasses == null || filterByClasses.contains(service.name.getClassName())));
    if (sameComponent && (service.app == null || evenPersistent || !service.app.persistent)) {
      if (!doit) {
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + service);
      if (service.app != null) {
        service.app.removed=killProcess;
        if (!service.app.persistent) {
          service.app.services.remove(service);
        }
      }
      service.app=null;
      service.isolatedProc=null;
      if (mTmpCollectionResults == null) {
        mTmpCollectionResults=new ArrayList<>();
      }
      mTmpCollectionResults.add(service);
    }
  }
  return didSomething;
}","private boolean collectPackageServicesLocked(String packageName,Set<String> filterByClasses,boolean evenPersistent,boolean doit,boolean killProcess,ArrayMap<ComponentName,ServiceRecord> services){
  boolean didSomething=false;
  for (int i=services.size() - 1; i >= 0; i--) {
    ServiceRecord service=services.valueAt(i);
    final boolean sameComponent=packageName == null || (service.packageName.equals(packageName) && (filterByClasses == null || filterByClasses.contains(service.name.getClassName())));
    if (sameComponent && (service.app == null || evenPersistent || !service.app.persistent)) {
      if (!doit) {
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + service);
      if (service.app != null) {
        service.app.removed=killProcess;
        if (!service.app.persistent) {
          service.app.services.remove(service);
          if (service.whitelistManager) {
            updateWhitelistManagerLocked(service.app);
          }
        }
      }
      service.app=null;
      service.isolatedProc=null;
      if (mTmpCollectionResults == null) {
        mTmpCollectionResults=new ArrayList<>();
      }
      mTmpCollectionResults.add(service);
    }
  }
  return didSomething;
}",0.9541438788388724
191207,"int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,final IServiceConnection connection,int flags,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  final boolean isCallerSystem=callerApp.info.uid == Process.SYSTEM_UID;
  if (isCallerSystem) {
    service.setDefusable(true);
    clientIntent=service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
    mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0 && !isCallerSystem) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  final boolean callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  final boolean isBindExternal=(flags & Context.BIND_EXTERNAL_SERVICE) != 0;
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,Binder.getCallingPid(),Binder.getCallingUid(),userId,true,callerFg,isBindExternal);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  boolean permissionsReviewRequired=false;
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(s.packageName,s.userId)) {
      permissionsReviewRequired=true;
      if (!callerFg) {
        Slog.w(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName+ ""String_Node_Str"");
        return 0;
      }
      final ServiceRecord serviceRecord=s;
      final Intent serviceIntent=service;
      RemoteCallback callback=new RemoteCallback(new RemoteCallback.OnResultListener(){
        @Override public void onResult(        Bundle result){
synchronized (mAm) {
            final long identity=Binder.clearCallingIdentity();
            try {
              if (!mPendingServices.contains(serviceRecord)) {
                return;
              }
              if (!mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(serviceRecord.packageName,serviceRecord.userId)) {
                try {
                  bringUpServiceLocked(serviceRecord,serviceIntent.getFlags(),callerFg,false,false);
                }
 catch (                RemoteException e) {
                }
              }
 else {
                unbindServiceLocked(connection);
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
        }
      }
);
      final Intent intent=new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      intent.putExtra(Intent.EXTRA_PACKAGE_NAME,s.packageName);
      intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK,callback);
      if (DEBUG_PERMISSIONS_REVIEW) {
        Slog.i(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName);
      }
      mAm.mHandler.post(new Runnable(){
        @Override public void run(){
          mAm.mContext.startActivityAsUser(intent,new UserHandle(userId));
        }
      }
);
    }
  }
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s,callerApp.info.uid,false)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        ServiceState stracker=s.getTracker();
        if (stracker != null) {
          stracker.setBound(true,mAm.mProcessStats.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    mAm.startAssociationLocked(callerApp.uid,callerApp.processName,callerApp.curProcState,s.appInfo.uid,s.name,s.processName);
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),callerFg,false,permissionsReviewRequired) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
        s.app.treatLikeActivity=true;
      }
      mAm.updateLruProcessLocked(s.app,s.app.hasClientActivities || s.app.treatLikeActivity,b.client);
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,callerFg,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,callerFg,false);
    }
    getServiceMap(s.userId).ensureNotStartingBackground(s);
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}","int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,final IServiceConnection connection,int flags,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  final boolean isCallerSystem=callerApp.info.uid == Process.SYSTEM_UID;
  if (isCallerSystem) {
    service.setDefusable(true);
    clientIntent=service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
    mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0 && !isCallerSystem) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  final boolean callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  final boolean isBindExternal=(flags & Context.BIND_EXTERNAL_SERVICE) != 0;
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,Binder.getCallingPid(),Binder.getCallingUid(),userId,true,callerFg,isBindExternal);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  boolean permissionsReviewRequired=false;
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(s.packageName,s.userId)) {
      permissionsReviewRequired=true;
      if (!callerFg) {
        Slog.w(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName+ ""String_Node_Str"");
        return 0;
      }
      final ServiceRecord serviceRecord=s;
      final Intent serviceIntent=service;
      RemoteCallback callback=new RemoteCallback(new RemoteCallback.OnResultListener(){
        @Override public void onResult(        Bundle result){
synchronized (mAm) {
            final long identity=Binder.clearCallingIdentity();
            try {
              if (!mPendingServices.contains(serviceRecord)) {
                return;
              }
              if (!mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(serviceRecord.packageName,serviceRecord.userId)) {
                try {
                  bringUpServiceLocked(serviceRecord,serviceIntent.getFlags(),callerFg,false,false);
                }
 catch (                RemoteException e) {
                }
              }
 else {
                unbindServiceLocked(connection);
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
        }
      }
);
      final Intent intent=new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      intent.putExtra(Intent.EXTRA_PACKAGE_NAME,s.packageName);
      intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK,callback);
      if (DEBUG_PERMISSIONS_REVIEW) {
        Slog.i(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName);
      }
      mAm.mHandler.post(new Runnable(){
        @Override public void run(){
          mAm.mContext.startActivityAsUser(intent,new UserHandle(userId));
        }
      }
);
    }
  }
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s,callerApp.info.uid,false)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        ServiceState stracker=s.getTracker();
        if (stracker != null) {
          stracker.setBound(true,mAm.mProcessStats.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    mAm.startAssociationLocked(callerApp.uid,callerApp.processName,callerApp.curProcState,s.appInfo.uid,s.name,s.processName);
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    if ((c.flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
      s.whitelistManager=true;
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),callerFg,false,permissionsReviewRequired) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
        s.app.treatLikeActivity=true;
      }
      if (s.whitelistManager) {
        s.app.whitelistManager=true;
      }
      mAm.updateLruProcessLocked(s.app,s.app.hasClientActivities || s.app.treatLikeActivity,b.client);
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,callerFg,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,callerFg,false);
    }
    getServiceMap(s.userId).ensureNotStartingBackground(s);
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}",0.9875564063995624
191208,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  updateServiceConnectionActivitiesLocked(app);
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
      for (int appi=b.apps.size() - 1; appi >= 0; appi--) {
        final ProcessRecord proc=b.apps.keyAt(appi);
        if (proc.killedByAm || proc.thread == null) {
          continue;
        }
        final AppBindRecord abind=b.apps.valueAt(appi);
        boolean hasCreate=false;
        for (int conni=abind.connections.size() - 1; conni >= 0; conni--) {
          ConnectionRecord conn=abind.connections.valueAt(conni);
          if ((conn.flags & (Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_OOM_MANAGEMENT | Context.BIND_WAIVE_PRIORITY)) == Context.BIND_AUTO_CREATE) {
            hasCreate=true;
            break;
          }
        }
        if (!hasCreate) {
          continue;
        }
        if (false && proc != null && !proc.persistent && proc.thread != null && proc.pid != 0 && proc.pid != ActivityManagerService.MY_PID && proc.setProcState >= ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
          proc.kill(""String_Node_Str"" + sr.name.flattenToShortString() + ""String_Node_Str""+ (app != null ? app.processName : ""String_Node_Str""),true);
        }
      }
    }
  }
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    final ServiceRecord curRec=smap.mServicesByName.get(sr.name);
    if (curRec != sr) {
      if (curRec != null) {
        Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ curRec);
      }
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart || !mAm.mUserController.isUserRunningLocked(sr.userId,0)) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  updateServiceConnectionActivitiesLocked(app);
  app.connections.clear();
  app.whitelistManager=false;
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
      for (int appi=b.apps.size() - 1; appi >= 0; appi--) {
        final ProcessRecord proc=b.apps.keyAt(appi);
        if (proc.killedByAm || proc.thread == null) {
          continue;
        }
        final AppBindRecord abind=b.apps.valueAt(appi);
        boolean hasCreate=false;
        for (int conni=abind.connections.size() - 1; conni >= 0; conni--) {
          ConnectionRecord conn=abind.connections.valueAt(conni);
          if ((conn.flags & (Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_OOM_MANAGEMENT | Context.BIND_WAIVE_PRIORITY)) == Context.BIND_AUTO_CREATE) {
            hasCreate=true;
            break;
          }
        }
        if (!hasCreate) {
          continue;
        }
        if (false && proc != null && !proc.persistent && proc.thread != null && proc.pid != 0 && proc.pid != ActivityManagerService.MY_PID && proc.setProcState >= ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
          proc.kill(""String_Node_Str"" + sr.name.flattenToShortString() + ""String_Node_Str""+ (app != null ? app.processName : ""String_Node_Str""),true);
        }
      }
    }
  }
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    final ServiceRecord curRec=smap.mServicesByName.get(sr.name);
    if (curRec != sr) {
      if (curRec != null) {
        Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ curRec);
      }
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart || !mAm.mUserController.isUserRunningLocked(sr.userId,0)) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}",0.997187324207763
191209,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.whitelistManager) {
      updateWhitelistManagerLocked(r.app);
    }
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}",0.9884755652808168
191210,"void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  mAm.stopAssociationLocked(b.client.uid,b.client.processName,s.appInfo.uid,s.name);
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        if (b.client != s.app && (c.flags & Context.BIND_WAIVE_PRIORITY) == 0 && s.app.setProcState <= ActivityManager.PROCESS_STATE_RECEIVER) {
          mAm.updateLruProcessLocked(s.app,false,null);
        }
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceProcessGoneLocked(s);
      }
    }
    mPendingServices.remove(s);
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}","void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
    if ((c.flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
      s.updateWhitelistManager();
      if (!s.whitelistManager && s.app != null) {
        updateWhitelistManagerLocked(s.app);
      }
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  mAm.stopAssociationLocked(b.client.uid,b.client.processName,s.appInfo.uid,s.name);
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        if (b.client != s.app && (c.flags & Context.BIND_WAIVE_PRIORITY) == 0 && s.app.setProcState <= ActivityManager.PROCESS_STATE_RECEIVER) {
          mAm.updateLruProcessLocked(s.app,false,null);
        }
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceProcessGoneLocked(s);
      }
    }
    mPendingServices.remove(s);
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}",0.9574510990118976
191211,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.curSchedGroup=ProcessList.SCHED_GROUP_TOP_APP;
      app.adjType=""String_Node_Str"";
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_CUR_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_CUR_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    int minLayer=ProcessList.VISIBLE_APP_LAYER_MAX;
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Log.e(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.app+ ""String_Node_Str""+ app);
        if (r.app == null || (r.app.uid == app.uid)) {
          r.app=app;
        }
 else {
          continue;
        }
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        if (r.task != null && minLayer > 0) {
          final int layer=r.task.mLayerRank;
          if (layer >= 0 && minLayer > layer) {
            minLayer=layer;
          }
        }
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
    if (adj == ProcessList.VISIBLE_APP_ADJ) {
      adj+=minLayer;
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  app.whitelistManager=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
          app.whitelistManager=true;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=Math.max(clientAdj,ProcessList.VISIBLE_APP_ADJ);
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup > schedGroup) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=client.curSchedGroup;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup > schedGroup) {
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.curSchedGroup=ProcessList.SCHED_GROUP_TOP_APP;
      app.adjType=""String_Node_Str"";
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_CUR_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_CUR_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    int minLayer=ProcessList.VISIBLE_APP_LAYER_MAX;
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Log.e(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.app+ ""String_Node_Str""+ app);
        if (r.app == null || (r.app.uid == app.uid)) {
          r.app=app;
        }
 else {
          continue;
        }
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        if (r.task != null && minLayer > 0) {
          final int layer=r.task.mLayerRank;
          if (layer >= 0 && minLayer > layer) {
            minLayer=layer;
          }
        }
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
    if (adj == ProcessList.VISIBLE_APP_ADJ) {
      adj+=minLayer;
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=Math.max(clientAdj,ProcessList.VISIBLE_APP_ADJ);
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup > schedGroup) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=client.curSchedGroup;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup > schedGroup) {
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9960728872133208
191212,"void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(intent.getIntent().toShortString(false,true,false,true));
  pw.println('}');
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(packageName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  if (permission != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(permission);
  }
  long now=SystemClock.uptimeMillis();
  long nowReal=SystemClock.elapsedRealtime();
  if (appInfo != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.sourceDir);
    if (!Objects.equals(appInfo.sourceDir,appInfo.publicSourceDir)) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(appInfo.publicSourceDir);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.dataDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  if (isolatedProc != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(isolatedProc);
  }
  if (delayed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(delayed);
  }
  if (isForeground || foregroundId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(isForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundId);
    pw.print(""String_Node_Str"");
    pw.println(foregroundNoti);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(createTime,nowReal,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(startingBgTimeout,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivity,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(restartTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(createdFromFg);
  if (startRequested || delayedStop || lastStartId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(startRequested);
    pw.print(""String_Node_Str"");
    pw.print(delayedStop);
    pw.print(""String_Node_Str"");
    pw.print(stopIfKilled);
    pw.print(""String_Node_Str"");
    pw.print(callStart);
    pw.print(""String_Node_Str"");
    pw.println(lastStartId);
  }
  if (executeNesting != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(executeNesting);
    pw.print(""String_Node_Str"");
    pw.print(executeFg);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(executingStart,now,pw);
    pw.println();
  }
  if (destroying || destroyTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(destroying);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(destroyTime,now,pw);
    pw.println();
  }
  if (crashCount != 0 || restartCount != 0 || restartDelay != 0 || nextRestartTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(restartCount);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(restartDelay,now,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(nextRestartTime,now,pw);
    pw.print(""String_Node_Str"");
    pw.println(crashCount);
  }
  if (deliveredStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,deliveredStarts,now);
  }
  if (pendingStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,pendingStarts,0);
  }
  if (bindings.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < bindings.size(); i++) {
      IntentBindRecord b=bindings.valueAt(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(Integer.toHexString(System.identityHashCode(b)));
      if ((b.collectFlags() & Context.BIND_AUTO_CREATE) != 0) {
        pw.append(""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      b.dumpInService(pw,prefix + ""String_Node_Str"");
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int conni=0; conni < connections.size(); conni++) {
      ArrayList<ConnectionRecord> c=connections.valueAt(conni);
      for (int i=0; i < c.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(c.get(i));
      }
    }
  }
}","void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(intent.getIntent().toShortString(false,true,false,true));
  pw.println('}');
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(packageName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  if (permission != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(permission);
  }
  long now=SystemClock.uptimeMillis();
  long nowReal=SystemClock.elapsedRealtime();
  if (appInfo != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.sourceDir);
    if (!Objects.equals(appInfo.sourceDir,appInfo.publicSourceDir)) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(appInfo.publicSourceDir);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.dataDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  if (isolatedProc != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(isolatedProc);
  }
  if (whitelistManager) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(whitelistManager);
  }
  if (delayed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(delayed);
  }
  if (isForeground || foregroundId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(isForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundId);
    pw.print(""String_Node_Str"");
    pw.println(foregroundNoti);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(createTime,nowReal,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(startingBgTimeout,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivity,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(restartTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(createdFromFg);
  if (startRequested || delayedStop || lastStartId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(startRequested);
    pw.print(""String_Node_Str"");
    pw.print(delayedStop);
    pw.print(""String_Node_Str"");
    pw.print(stopIfKilled);
    pw.print(""String_Node_Str"");
    pw.print(callStart);
    pw.print(""String_Node_Str"");
    pw.println(lastStartId);
  }
  if (executeNesting != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(executeNesting);
    pw.print(""String_Node_Str"");
    pw.print(executeFg);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(executingStart,now,pw);
    pw.println();
  }
  if (destroying || destroyTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(destroying);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(destroyTime,now,pw);
    pw.println();
  }
  if (crashCount != 0 || restartCount != 0 || restartDelay != 0 || nextRestartTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(restartCount);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(restartDelay,now,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(nextRestartTime,now,pw);
    pw.print(""String_Node_Str"");
    pw.println(crashCount);
  }
  if (deliveredStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,deliveredStarts,now);
  }
  if (pendingStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,pendingStarts,0);
  }
  if (bindings.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < bindings.size(); i++) {
      IntentBindRecord b=bindings.valueAt(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(Integer.toHexString(System.identityHashCode(b)));
      if ((b.collectFlags() & Context.BIND_AUTO_CREATE) != 0) {
        pw.append(""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      b.dumpInService(pw,prefix + ""String_Node_Str"");
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int conni=0; conni < connections.size(); conni++) {
      ArrayList<ConnectionRecord> c=connections.valueAt(conni);
      for (int i=0; i < c.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(c.get(i));
      }
    }
  }
}",0.9866036249014972
191213,"private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  final boolean newService=app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    if (LOG_SERVICE_START_STOP) {
      String nameTerm;
      int lastPeriod=r.shortName.lastIndexOf('.');
      nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
      EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
    }
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_SERVICE);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
 catch (  DeadObjectException e) {
    Slog.w(TAG,""String_Node_Str"" + r);
    mAm.appDiedLocked(app);
    throw e;
  }
 finally {
    if (!created) {
      final boolean inDestroying=mDestroyingServices.contains(r);
      serviceDoneExecutingLocked(r,inDestroying,inDestroying);
      if (newService) {
        app.services.remove(r);
        r.app=null;
      }
      if (!inDestroying) {
        scheduleServiceRestartLocked(r,false);
      }
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  updateServiceClientActivitiesLocked(app,null,true);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}","private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  final boolean newService=app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    if (LOG_SERVICE_START_STOP) {
      String nameTerm;
      int lastPeriod=r.shortName.lastIndexOf('.');
      nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
      EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
    }
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_SERVICE);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
 catch (  DeadObjectException e) {
    Slog.w(TAG,""String_Node_Str"" + r);
    mAm.appDiedLocked(app);
    throw e;
  }
 finally {
    if (!created) {
      final boolean inDestroying=mDestroyingServices.contains(r);
      serviceDoneExecutingLocked(r,inDestroying,inDestroying);
      if (newService) {
        app.services.remove(r);
        r.app=null;
      }
      if (!inDestroying) {
        scheduleServiceRestartLocked(r,false);
      }
    }
  }
  if (r.whitelistManager) {
    app.whitelistManager=true;
  }
  requestServiceBindingsLocked(r,execInFg);
  updateServiceClientActivitiesLocked(app,null,true);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}",0.9873009473896392
191214,"private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r,false);
        r.tracker=null;
      }
    }
    if (finishing) {
      if (r.app != null && !r.app.persistent) {
        r.app.services.remove(r);
      }
      r.app=null;
    }
  }
}","private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r,false);
        r.tracker=null;
      }
    }
    if (finishing) {
      if (r.app != null && !r.app.persistent) {
        r.app.services.remove(r);
        if (r.whitelistManager) {
          updateWhitelistManagerLocked(r.app);
        }
      }
      r.app=null;
    }
  }
}",0.974559686888454
191215,"private boolean collectPackageServicesLocked(String packageName,Set<String> filterByClasses,boolean evenPersistent,boolean doit,boolean killProcess,ArrayMap<ComponentName,ServiceRecord> services){
  boolean didSomething=false;
  for (int i=services.size() - 1; i >= 0; i--) {
    ServiceRecord service=services.valueAt(i);
    final boolean sameComponent=packageName == null || (service.packageName.equals(packageName) && (filterByClasses == null || filterByClasses.contains(service.name.getClassName())));
    if (sameComponent && (service.app == null || evenPersistent || !service.app.persistent)) {
      if (!doit) {
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + service);
      if (service.app != null) {
        service.app.removed=killProcess;
        if (!service.app.persistent) {
          service.app.services.remove(service);
        }
      }
      service.app=null;
      service.isolatedProc=null;
      if (mTmpCollectionResults == null) {
        mTmpCollectionResults=new ArrayList<>();
      }
      mTmpCollectionResults.add(service);
    }
  }
  return didSomething;
}","private boolean collectPackageServicesLocked(String packageName,Set<String> filterByClasses,boolean evenPersistent,boolean doit,boolean killProcess,ArrayMap<ComponentName,ServiceRecord> services){
  boolean didSomething=false;
  for (int i=services.size() - 1; i >= 0; i--) {
    ServiceRecord service=services.valueAt(i);
    final boolean sameComponent=packageName == null || (service.packageName.equals(packageName) && (filterByClasses == null || filterByClasses.contains(service.name.getClassName())));
    if (sameComponent && (service.app == null || evenPersistent || !service.app.persistent)) {
      if (!doit) {
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + service);
      if (service.app != null) {
        service.app.removed=killProcess;
        if (!service.app.persistent) {
          service.app.services.remove(service);
          if (service.whitelistManager) {
            updateWhitelistManagerLocked(service.app);
          }
        }
      }
      service.app=null;
      service.isolatedProc=null;
      if (mTmpCollectionResults == null) {
        mTmpCollectionResults=new ArrayList<>();
      }
      mTmpCollectionResults.add(service);
    }
  }
  return didSomething;
}",0.9541438788388724
191216,"int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,final IServiceConnection connection,int flags,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  final boolean isCallerSystem=callerApp.info.uid == Process.SYSTEM_UID;
  if (isCallerSystem) {
    service.setDefusable(true);
    clientIntent=service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
    mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0 && !isCallerSystem) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  final boolean callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  final boolean isBindExternal=(flags & Context.BIND_EXTERNAL_SERVICE) != 0;
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,Binder.getCallingPid(),Binder.getCallingUid(),userId,true,callerFg,isBindExternal);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  boolean permissionsReviewRequired=false;
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(s.packageName,s.userId)) {
      permissionsReviewRequired=true;
      if (!callerFg) {
        Slog.w(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName+ ""String_Node_Str"");
        return 0;
      }
      final ServiceRecord serviceRecord=s;
      final Intent serviceIntent=service;
      RemoteCallback callback=new RemoteCallback(new RemoteCallback.OnResultListener(){
        @Override public void onResult(        Bundle result){
synchronized (mAm) {
            final long identity=Binder.clearCallingIdentity();
            try {
              if (!mPendingServices.contains(serviceRecord)) {
                return;
              }
              if (!mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(serviceRecord.packageName,serviceRecord.userId)) {
                try {
                  bringUpServiceLocked(serviceRecord,serviceIntent.getFlags(),callerFg,false,false);
                }
 catch (                RemoteException e) {
                }
              }
 else {
                unbindServiceLocked(connection);
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
        }
      }
);
      final Intent intent=new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      intent.putExtra(Intent.EXTRA_PACKAGE_NAME,s.packageName);
      intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK,callback);
      if (DEBUG_PERMISSIONS_REVIEW) {
        Slog.i(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName);
      }
      mAm.mHandler.post(new Runnable(){
        @Override public void run(){
          mAm.mContext.startActivityAsUser(intent,new UserHandle(userId));
        }
      }
);
    }
  }
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s,callerApp.info.uid,false)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        ServiceState stracker=s.getTracker();
        if (stracker != null) {
          stracker.setBound(true,mAm.mProcessStats.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    mAm.startAssociationLocked(callerApp.uid,callerApp.processName,callerApp.curProcState,s.appInfo.uid,s.name,s.processName);
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),callerFg,false,permissionsReviewRequired) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
        s.app.treatLikeActivity=true;
      }
      mAm.updateLruProcessLocked(s.app,s.app.hasClientActivities || s.app.treatLikeActivity,b.client);
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,callerFg,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,callerFg,false);
    }
    getServiceMap(s.userId).ensureNotStartingBackground(s);
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}","int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,final IServiceConnection connection,int flags,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  final boolean isCallerSystem=callerApp.info.uid == Process.SYSTEM_UID;
  if (isCallerSystem) {
    service.setDefusable(true);
    clientIntent=service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
    mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0 && !isCallerSystem) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  final boolean callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  final boolean isBindExternal=(flags & Context.BIND_EXTERNAL_SERVICE) != 0;
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,Binder.getCallingPid(),Binder.getCallingUid(),userId,true,callerFg,isBindExternal);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  boolean permissionsReviewRequired=false;
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(s.packageName,s.userId)) {
      permissionsReviewRequired=true;
      if (!callerFg) {
        Slog.w(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName+ ""String_Node_Str"");
        return 0;
      }
      final ServiceRecord serviceRecord=s;
      final Intent serviceIntent=service;
      RemoteCallback callback=new RemoteCallback(new RemoteCallback.OnResultListener(){
        @Override public void onResult(        Bundle result){
synchronized (mAm) {
            final long identity=Binder.clearCallingIdentity();
            try {
              if (!mPendingServices.contains(serviceRecord)) {
                return;
              }
              if (!mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(serviceRecord.packageName,serviceRecord.userId)) {
                try {
                  bringUpServiceLocked(serviceRecord,serviceIntent.getFlags(),callerFg,false,false);
                }
 catch (                RemoteException e) {
                }
              }
 else {
                unbindServiceLocked(connection);
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
        }
      }
);
      final Intent intent=new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      intent.putExtra(Intent.EXTRA_PACKAGE_NAME,s.packageName);
      intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK,callback);
      if (DEBUG_PERMISSIONS_REVIEW) {
        Slog.i(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName);
      }
      mAm.mHandler.post(new Runnable(){
        @Override public void run(){
          mAm.mContext.startActivityAsUser(intent,new UserHandle(userId));
        }
      }
);
    }
  }
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s,callerApp.info.uid,false)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        ServiceState stracker=s.getTracker();
        if (stracker != null) {
          stracker.setBound(true,mAm.mProcessStats.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    mAm.startAssociationLocked(callerApp.uid,callerApp.processName,callerApp.curProcState,s.appInfo.uid,s.name,s.processName);
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    if ((c.flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
      s.whitelistManager=true;
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),callerFg,false,permissionsReviewRequired) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
        s.app.treatLikeActivity=true;
      }
      if (s.whitelistManager) {
        s.app.whitelistManager=true;
      }
      mAm.updateLruProcessLocked(s.app,s.app.hasClientActivities || s.app.treatLikeActivity,b.client);
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,callerFg,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,callerFg,false);
    }
    getServiceMap(s.userId).ensureNotStartingBackground(s);
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}",0.9875564063995624
191217,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  updateServiceConnectionActivitiesLocked(app);
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
      for (int appi=b.apps.size() - 1; appi >= 0; appi--) {
        final ProcessRecord proc=b.apps.keyAt(appi);
        if (proc.killedByAm || proc.thread == null) {
          continue;
        }
        final AppBindRecord abind=b.apps.valueAt(appi);
        boolean hasCreate=false;
        for (int conni=abind.connections.size() - 1; conni >= 0; conni--) {
          ConnectionRecord conn=abind.connections.valueAt(conni);
          if ((conn.flags & (Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_OOM_MANAGEMENT | Context.BIND_WAIVE_PRIORITY)) == Context.BIND_AUTO_CREATE) {
            hasCreate=true;
            break;
          }
        }
        if (!hasCreate) {
          continue;
        }
        if (false && proc != null && !proc.persistent && proc.thread != null && proc.pid != 0 && proc.pid != ActivityManagerService.MY_PID && proc.setProcState >= ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
          proc.kill(""String_Node_Str"" + sr.name.flattenToShortString() + ""String_Node_Str""+ (app != null ? app.processName : ""String_Node_Str""),true);
        }
      }
    }
  }
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    final ServiceRecord curRec=smap.mServicesByName.get(sr.name);
    if (curRec != sr) {
      if (curRec != null) {
        Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ curRec);
      }
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart || !mAm.mUserController.isUserRunningLocked(sr.userId,0)) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  updateServiceConnectionActivitiesLocked(app);
  app.connections.clear();
  app.whitelistManager=false;
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
      for (int appi=b.apps.size() - 1; appi >= 0; appi--) {
        final ProcessRecord proc=b.apps.keyAt(appi);
        if (proc.killedByAm || proc.thread == null) {
          continue;
        }
        final AppBindRecord abind=b.apps.valueAt(appi);
        boolean hasCreate=false;
        for (int conni=abind.connections.size() - 1; conni >= 0; conni--) {
          ConnectionRecord conn=abind.connections.valueAt(conni);
          if ((conn.flags & (Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_OOM_MANAGEMENT | Context.BIND_WAIVE_PRIORITY)) == Context.BIND_AUTO_CREATE) {
            hasCreate=true;
            break;
          }
        }
        if (!hasCreate) {
          continue;
        }
        if (false && proc != null && !proc.persistent && proc.thread != null && proc.pid != 0 && proc.pid != ActivityManagerService.MY_PID && proc.setProcState >= ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
          proc.kill(""String_Node_Str"" + sr.name.flattenToShortString() + ""String_Node_Str""+ (app != null ? app.processName : ""String_Node_Str""),true);
        }
      }
    }
  }
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    final ServiceRecord curRec=smap.mServicesByName.get(sr.name);
    if (curRec != sr) {
      if (curRec != null) {
        Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ curRec);
      }
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart || !mAm.mUserController.isUserRunningLocked(sr.userId,0)) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}",0.997187324207763
191218,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.whitelistManager) {
      updateWhitelistManagerLocked(r.app);
    }
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}",0.9884755652808168
191219,"void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  mAm.stopAssociationLocked(b.client.uid,b.client.processName,s.appInfo.uid,s.name);
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        if (b.client != s.app && (c.flags & Context.BIND_WAIVE_PRIORITY) == 0 && s.app.setProcState <= ActivityManager.PROCESS_STATE_RECEIVER) {
          mAm.updateLruProcessLocked(s.app,false,null);
        }
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceProcessGoneLocked(s);
      }
    }
    mPendingServices.remove(s);
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}","void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
    if ((c.flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
      s.updateWhitelistManager();
      if (!s.whitelistManager && s.app != null) {
        updateWhitelistManagerLocked(s.app);
      }
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  mAm.stopAssociationLocked(b.client.uid,b.client.processName,s.appInfo.uid,s.name);
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        if (b.client != s.app && (c.flags & Context.BIND_WAIVE_PRIORITY) == 0 && s.app.setProcState <= ActivityManager.PROCESS_STATE_RECEIVER) {
          mAm.updateLruProcessLocked(s.app,false,null);
        }
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceProcessGoneLocked(s);
      }
    }
    mPendingServices.remove(s);
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}",0.9574510990118976
191220,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.curSchedGroup=ProcessList.SCHED_GROUP_TOP_APP;
      app.adjType=""String_Node_Str"";
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_CUR_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_CUR_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    int minLayer=ProcessList.VISIBLE_APP_LAYER_MAX;
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Log.e(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.app+ ""String_Node_Str""+ app);
        if (r.app == null || (r.app.uid == app.uid)) {
          r.app=app;
        }
 else {
          continue;
        }
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        if (r.task != null && minLayer > 0) {
          final int layer=r.task.mLayerRank;
          if (layer >= 0 && minLayer > layer) {
            minLayer=layer;
          }
        }
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
    if (adj == ProcessList.VISIBLE_APP_ADJ) {
      adj+=minLayer;
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  app.whitelistManager=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
          app.whitelistManager=true;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=Math.max(clientAdj,ProcessList.VISIBLE_APP_ADJ);
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup > schedGroup) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=client.curSchedGroup;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup > schedGroup) {
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.curSchedGroup=ProcessList.SCHED_GROUP_TOP_APP;
      app.adjType=""String_Node_Str"";
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_CUR_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_CUR_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    int minLayer=ProcessList.VISIBLE_APP_LAYER_MAX;
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Log.e(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.app+ ""String_Node_Str""+ app);
        if (r.app == null || (r.app.uid == app.uid)) {
          r.app=app;
        }
 else {
          continue;
        }
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        if (r.task != null && minLayer > 0) {
          final int layer=r.task.mLayerRank;
          if (layer >= 0 && minLayer > layer) {
            minLayer=layer;
          }
        }
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
    if (adj == ProcessList.VISIBLE_APP_ADJ) {
      adj+=minLayer;
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=Math.max(clientAdj,ProcessList.VISIBLE_APP_ADJ);
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup > schedGroup) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=client.curSchedGroup;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup > schedGroup) {
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9960728872133208
191221,"void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(intent.getIntent().toShortString(false,true,false,true));
  pw.println('}');
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(packageName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  if (permission != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(permission);
  }
  long now=SystemClock.uptimeMillis();
  long nowReal=SystemClock.elapsedRealtime();
  if (appInfo != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.sourceDir);
    if (!Objects.equals(appInfo.sourceDir,appInfo.publicSourceDir)) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(appInfo.publicSourceDir);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.dataDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  if (isolatedProc != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(isolatedProc);
  }
  if (delayed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(delayed);
  }
  if (isForeground || foregroundId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(isForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundId);
    pw.print(""String_Node_Str"");
    pw.println(foregroundNoti);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(createTime,nowReal,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(startingBgTimeout,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivity,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(restartTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(createdFromFg);
  if (startRequested || delayedStop || lastStartId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(startRequested);
    pw.print(""String_Node_Str"");
    pw.print(delayedStop);
    pw.print(""String_Node_Str"");
    pw.print(stopIfKilled);
    pw.print(""String_Node_Str"");
    pw.print(callStart);
    pw.print(""String_Node_Str"");
    pw.println(lastStartId);
  }
  if (executeNesting != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(executeNesting);
    pw.print(""String_Node_Str"");
    pw.print(executeFg);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(executingStart,now,pw);
    pw.println();
  }
  if (destroying || destroyTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(destroying);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(destroyTime,now,pw);
    pw.println();
  }
  if (crashCount != 0 || restartCount != 0 || restartDelay != 0 || nextRestartTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(restartCount);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(restartDelay,now,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(nextRestartTime,now,pw);
    pw.print(""String_Node_Str"");
    pw.println(crashCount);
  }
  if (deliveredStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,deliveredStarts,now);
  }
  if (pendingStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,pendingStarts,0);
  }
  if (bindings.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < bindings.size(); i++) {
      IntentBindRecord b=bindings.valueAt(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(Integer.toHexString(System.identityHashCode(b)));
      if ((b.collectFlags() & Context.BIND_AUTO_CREATE) != 0) {
        pw.append(""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      b.dumpInService(pw,prefix + ""String_Node_Str"");
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int conni=0; conni < connections.size(); conni++) {
      ArrayList<ConnectionRecord> c=connections.valueAt(conni);
      for (int i=0; i < c.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(c.get(i));
      }
    }
  }
}","void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(intent.getIntent().toShortString(false,true,false,true));
  pw.println('}');
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(packageName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  if (permission != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(permission);
  }
  long now=SystemClock.uptimeMillis();
  long nowReal=SystemClock.elapsedRealtime();
  if (appInfo != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.sourceDir);
    if (!Objects.equals(appInfo.sourceDir,appInfo.publicSourceDir)) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(appInfo.publicSourceDir);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.dataDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  if (isolatedProc != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(isolatedProc);
  }
  if (whitelistManager) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(whitelistManager);
  }
  if (delayed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(delayed);
  }
  if (isForeground || foregroundId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(isForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundId);
    pw.print(""String_Node_Str"");
    pw.println(foregroundNoti);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(createTime,nowReal,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(startingBgTimeout,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivity,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(restartTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(createdFromFg);
  if (startRequested || delayedStop || lastStartId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(startRequested);
    pw.print(""String_Node_Str"");
    pw.print(delayedStop);
    pw.print(""String_Node_Str"");
    pw.print(stopIfKilled);
    pw.print(""String_Node_Str"");
    pw.print(callStart);
    pw.print(""String_Node_Str"");
    pw.println(lastStartId);
  }
  if (executeNesting != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(executeNesting);
    pw.print(""String_Node_Str"");
    pw.print(executeFg);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(executingStart,now,pw);
    pw.println();
  }
  if (destroying || destroyTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(destroying);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(destroyTime,now,pw);
    pw.println();
  }
  if (crashCount != 0 || restartCount != 0 || restartDelay != 0 || nextRestartTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(restartCount);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(restartDelay,now,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(nextRestartTime,now,pw);
    pw.print(""String_Node_Str"");
    pw.println(crashCount);
  }
  if (deliveredStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,deliveredStarts,now);
  }
  if (pendingStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,pendingStarts,0);
  }
  if (bindings.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < bindings.size(); i++) {
      IntentBindRecord b=bindings.valueAt(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(Integer.toHexString(System.identityHashCode(b)));
      if ((b.collectFlags() & Context.BIND_AUTO_CREATE) != 0) {
        pw.append(""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      b.dumpInService(pw,prefix + ""String_Node_Str"");
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int conni=0; conni < connections.size(); conni++) {
      ArrayList<ConnectionRecord> c=connections.valueAt(conni);
      for (int i=0; i < c.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(c.get(i));
      }
    }
  }
}",0.9866036249014972
191222,"private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  final boolean newService=app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    if (LOG_SERVICE_START_STOP) {
      String nameTerm;
      int lastPeriod=r.shortName.lastIndexOf('.');
      nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
      EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
    }
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_SERVICE);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
 catch (  DeadObjectException e) {
    Slog.w(TAG,""String_Node_Str"" + r);
    mAm.appDiedLocked(app);
    throw e;
  }
 finally {
    if (!created) {
      final boolean inDestroying=mDestroyingServices.contains(r);
      serviceDoneExecutingLocked(r,inDestroying,inDestroying);
      if (newService) {
        app.services.remove(r);
        r.app=null;
      }
      if (!inDestroying) {
        scheduleServiceRestartLocked(r,false);
      }
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  updateServiceClientActivitiesLocked(app,null,true);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}","private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  final boolean newService=app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    if (LOG_SERVICE_START_STOP) {
      String nameTerm;
      int lastPeriod=r.shortName.lastIndexOf('.');
      nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
      EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
    }
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.notifyPackageUse(r.serviceInfo.packageName,PackageManager.NOTIFY_PACKAGE_USE_SERVICE);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
 catch (  DeadObjectException e) {
    Slog.w(TAG,""String_Node_Str"" + r);
    mAm.appDiedLocked(app);
    throw e;
  }
 finally {
    if (!created) {
      final boolean inDestroying=mDestroyingServices.contains(r);
      serviceDoneExecutingLocked(r,inDestroying,inDestroying);
      if (newService) {
        app.services.remove(r);
        r.app=null;
      }
      if (!inDestroying) {
        scheduleServiceRestartLocked(r,false);
      }
    }
  }
  if (r.whitelistManager) {
    app.whitelistManager=true;
  }
  requestServiceBindingsLocked(r,execInFg);
  updateServiceClientActivitiesLocked(app,null,true);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}",0.9873009473896392
191223,"private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r,false);
        r.tracker=null;
      }
    }
    if (finishing) {
      if (r.app != null && !r.app.persistent) {
        r.app.services.remove(r);
      }
      r.app=null;
    }
  }
}","private void serviceDoneExecutingLocked(ServiceRecord r,boolean inDestroying,boolean finishing){
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.executeNesting+ ""String_Node_Str""+ inDestroying+ ""String_Node_Str""+ r.app);
 else   if (DEBUG_SERVICE_EXECUTING)   Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
  r.executeNesting--;
  if (r.executeNesting <= 0) {
    if (r.app != null) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r.shortName);
      r.app.execServicesFg=false;
      r.app.executingServices.remove(r);
      if (r.app.executingServices.size() == 0) {
        if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING)         Slog.v(TAG_SERVICE_EXECUTING,""String_Node_Str"" + r.shortName);
        mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG,r.app);
      }
 else       if (r.executeFg) {
        for (int i=r.app.executingServices.size() - 1; i >= 0; i--) {
          if (r.app.executingServices.valueAt(i).executeFg) {
            r.app.execServicesFg=true;
            break;
          }
        }
      }
      if (inDestroying) {
        if (DEBUG_SERVICE)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        mDestroyingServices.remove(r);
        r.bindings.clear();
      }
      mAm.updateOomAdjLocked(r.app);
    }
    r.executeFg=false;
    if (r.tracker != null) {
      r.tracker.setExecuting(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
      if (finishing) {
        r.tracker.clearCurrentOwner(r,false);
        r.tracker=null;
      }
    }
    if (finishing) {
      if (r.app != null && !r.app.persistent) {
        r.app.services.remove(r);
        if (r.whitelistManager) {
          updateWhitelistManagerLocked(r.app);
        }
      }
      r.app=null;
    }
  }
}",0.974559686888454
191224,"private boolean collectPackageServicesLocked(String packageName,Set<String> filterByClasses,boolean evenPersistent,boolean doit,boolean killProcess,ArrayMap<ComponentName,ServiceRecord> services){
  boolean didSomething=false;
  for (int i=services.size() - 1; i >= 0; i--) {
    ServiceRecord service=services.valueAt(i);
    final boolean sameComponent=packageName == null || (service.packageName.equals(packageName) && (filterByClasses == null || filterByClasses.contains(service.name.getClassName())));
    if (sameComponent && (service.app == null || evenPersistent || !service.app.persistent)) {
      if (!doit) {
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + service);
      if (service.app != null) {
        service.app.removed=killProcess;
        if (!service.app.persistent) {
          service.app.services.remove(service);
        }
      }
      service.app=null;
      service.isolatedProc=null;
      if (mTmpCollectionResults == null) {
        mTmpCollectionResults=new ArrayList<>();
      }
      mTmpCollectionResults.add(service);
    }
  }
  return didSomething;
}","private boolean collectPackageServicesLocked(String packageName,Set<String> filterByClasses,boolean evenPersistent,boolean doit,boolean killProcess,ArrayMap<ComponentName,ServiceRecord> services){
  boolean didSomething=false;
  for (int i=services.size() - 1; i >= 0; i--) {
    ServiceRecord service=services.valueAt(i);
    final boolean sameComponent=packageName == null || (service.packageName.equals(packageName) && (filterByClasses == null || filterByClasses.contains(service.name.getClassName())));
    if (sameComponent && (service.app == null || evenPersistent || !service.app.persistent)) {
      if (!doit) {
        return true;
      }
      didSomething=true;
      Slog.i(TAG,""String_Node_Str"" + service);
      if (service.app != null) {
        service.app.removed=killProcess;
        if (!service.app.persistent) {
          service.app.services.remove(service);
          if (service.whitelistManager) {
            updateWhitelistManagerLocked(service.app);
          }
        }
      }
      service.app=null;
      service.isolatedProc=null;
      if (mTmpCollectionResults == null) {
        mTmpCollectionResults=new ArrayList<>();
      }
      mTmpCollectionResults.add(service);
    }
  }
  return didSomething;
}",0.9541438788388724
191225,"int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,final IServiceConnection connection,int flags,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  final boolean isCallerSystem=callerApp.info.uid == Process.SYSTEM_UID;
  if (isCallerSystem) {
    service.setDefusable(true);
    clientIntent=service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
    mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0 && !isCallerSystem) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  final boolean callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  final boolean isBindExternal=(flags & Context.BIND_EXTERNAL_SERVICE) != 0;
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,Binder.getCallingPid(),Binder.getCallingUid(),userId,true,callerFg,isBindExternal);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  boolean permissionsReviewRequired=false;
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(s.packageName,s.userId)) {
      permissionsReviewRequired=true;
      if (!callerFg) {
        Slog.w(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName+ ""String_Node_Str"");
        return 0;
      }
      final ServiceRecord serviceRecord=s;
      final Intent serviceIntent=service;
      RemoteCallback callback=new RemoteCallback(new RemoteCallback.OnResultListener(){
        @Override public void onResult(        Bundle result){
synchronized (mAm) {
            final long identity=Binder.clearCallingIdentity();
            try {
              if (!mPendingServices.contains(serviceRecord)) {
                return;
              }
              if (!mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(serviceRecord.packageName,serviceRecord.userId)) {
                try {
                  bringUpServiceLocked(serviceRecord,serviceIntent.getFlags(),callerFg,false,false);
                }
 catch (                RemoteException e) {
                }
              }
 else {
                unbindServiceLocked(connection);
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
        }
      }
);
      final Intent intent=new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      intent.putExtra(Intent.EXTRA_PACKAGE_NAME,s.packageName);
      intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK,callback);
      if (DEBUG_PERMISSIONS_REVIEW) {
        Slog.i(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName);
      }
      mAm.mHandler.post(new Runnable(){
        @Override public void run(){
          mAm.mContext.startActivityAsUser(intent,new UserHandle(userId));
        }
      }
);
    }
  }
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s,callerApp.info.uid,false)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        ServiceState stracker=s.getTracker();
        if (stracker != null) {
          stracker.setBound(true,mAm.mProcessStats.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    mAm.startAssociationLocked(callerApp.uid,callerApp.processName,callerApp.curProcState,s.appInfo.uid,s.name,s.processName);
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),callerFg,false,permissionsReviewRequired) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
        s.app.treatLikeActivity=true;
      }
      mAm.updateLruProcessLocked(s.app,s.app.hasClientActivities || s.app.treatLikeActivity,b.client);
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,callerFg,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,callerFg,false);
    }
    getServiceMap(s.userId).ensureNotStartingBackground(s);
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}","int bindServiceLocked(IApplicationThread caller,IBinder token,Intent service,String resolvedType,final IServiceConnection connection,int flags,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
  final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
  if (callerApp == null) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  ActivityRecord activity=null;
  if (token != null) {
    activity=ActivityRecord.isInStackLocked(token);
    if (activity == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return 0;
    }
  }
  int clientLabel=0;
  PendingIntent clientIntent=null;
  final boolean isCallerSystem=callerApp.info.uid == Process.SYSTEM_UID;
  if (isCallerSystem) {
    service.setDefusable(true);
    clientIntent=service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
    if (clientIntent != null) {
      clientLabel=service.getIntExtra(Intent.EXTRA_CLIENT_LABEL,0);
      if (clientLabel != 0) {
        service=service.cloneFilter();
      }
    }
  }
  if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
    mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  }
  if ((flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0 && !isCallerSystem) {
    throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
  }
  final boolean callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  final boolean isBindExternal=(flags & Context.BIND_EXTERNAL_SERVICE) != 0;
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,Binder.getCallingPid(),Binder.getCallingUid(),userId,true,callerFg,isBindExternal);
  if (res == null) {
    return 0;
  }
  if (res.record == null) {
    return -1;
  }
  ServiceRecord s=res.record;
  boolean permissionsReviewRequired=false;
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(s.packageName,s.userId)) {
      permissionsReviewRequired=true;
      if (!callerFg) {
        Slog.w(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName+ ""String_Node_Str"");
        return 0;
      }
      final ServiceRecord serviceRecord=s;
      final Intent serviceIntent=service;
      RemoteCallback callback=new RemoteCallback(new RemoteCallback.OnResultListener(){
        @Override public void onResult(        Bundle result){
synchronized (mAm) {
            final long identity=Binder.clearCallingIdentity();
            try {
              if (!mPendingServices.contains(serviceRecord)) {
                return;
              }
              if (!mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(serviceRecord.packageName,serviceRecord.userId)) {
                try {
                  bringUpServiceLocked(serviceRecord,serviceIntent.getFlags(),callerFg,false,false);
                }
 catch (                RemoteException e) {
                }
              }
 else {
                unbindServiceLocked(connection);
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
        }
      }
);
      final Intent intent=new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      intent.putExtra(Intent.EXTRA_PACKAGE_NAME,s.packageName);
      intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK,callback);
      if (DEBUG_PERMISSIONS_REVIEW) {
        Slog.i(TAG,""String_Node_Str"" + s.userId + ""String_Node_Str""+ s.packageName);
      }
      mAm.mHandler.post(new Runnable(){
        @Override public void run(){
          mAm.mContext.startActivityAsUser(intent,new UserHandle(userId));
        }
      }
);
    }
  }
  final long origId=Binder.clearCallingIdentity();
  try {
    if (unscheduleServiceRestartLocked(s,callerApp.info.uid,false)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + s);
    }
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!s.hasAutoCreateConnections()) {
        ServiceState stracker=s.getTracker();
        if (stracker != null) {
          stracker.setBound(true,mAm.mProcessStats.getMemFactorLocked(),s.lastActivity);
        }
      }
    }
    mAm.startAssociationLocked(callerApp.uid,callerApp.processName,callerApp.curProcState,s.appInfo.uid,s.name,s.processName);
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags,clientLabel,clientIntent);
    IBinder binder=connection.asBinder();
    ArrayList<ConnectionRecord> clist=s.connections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      s.connections.put(binder,clist);
    }
    clist.add(c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.hasAboveClient=true;
    }
    if ((c.flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
      s.whitelistManager=true;
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
    clist=mServiceConnections.get(binder);
    if (clist == null) {
      clist=new ArrayList<ConnectionRecord>();
      mServiceConnections.put(binder,clist);
    }
    clist.add(c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (bringUpServiceLocked(s,service.getFlags(),callerFg,false,permissionsReviewRequired) != null) {
        return 0;
      }
    }
    if (s.app != null) {
      if ((flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
        s.app.treatLikeActivity=true;
      }
      if (s.whitelistManager) {
        s.app.whitelistManager=true;
      }
      mAm.updateLruProcessLocked(s.app,s.app.hasClientActivities || s.app.treatLikeActivity,b.client);
      mAm.updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,callerFg,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,callerFg,false);
    }
    getServiceMap(s.userId).ensureNotStartingBackground(s);
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}",0.9875564063995624
191226,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  updateServiceConnectionActivitiesLocked(app);
  app.connections.clear();
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
      for (int appi=b.apps.size() - 1; appi >= 0; appi--) {
        final ProcessRecord proc=b.apps.keyAt(appi);
        if (proc.killedByAm || proc.thread == null) {
          continue;
        }
        final AppBindRecord abind=b.apps.valueAt(appi);
        boolean hasCreate=false;
        for (int conni=abind.connections.size() - 1; conni >= 0; conni--) {
          ConnectionRecord conn=abind.connections.valueAt(conni);
          if ((conn.flags & (Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_OOM_MANAGEMENT | Context.BIND_WAIVE_PRIORITY)) == Context.BIND_AUTO_CREATE) {
            hasCreate=true;
            break;
          }
        }
        if (!hasCreate) {
          continue;
        }
        if (false && proc != null && !proc.persistent && proc.thread != null && proc.pid != 0 && proc.pid != ActivityManagerService.MY_PID && proc.setProcState >= ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
          proc.kill(""String_Node_Str"" + sr.name.flattenToShortString() + ""String_Node_Str""+ (app != null ? app.processName : ""String_Node_Str""),true);
        }
      }
    }
  }
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    final ServiceRecord curRec=smap.mServicesByName.get(sr.name);
    if (curRec != sr) {
      if (curRec != null) {
        Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ curRec);
      }
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart || !mAm.mUserController.isUserRunningLocked(sr.userId,0)) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  updateServiceConnectionActivitiesLocked(app);
  app.connections.clear();
  app.whitelistManager=false;
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
      for (int appi=b.apps.size() - 1; appi >= 0; appi--) {
        final ProcessRecord proc=b.apps.keyAt(appi);
        if (proc.killedByAm || proc.thread == null) {
          continue;
        }
        final AppBindRecord abind=b.apps.valueAt(appi);
        boolean hasCreate=false;
        for (int conni=abind.connections.size() - 1; conni >= 0; conni--) {
          ConnectionRecord conn=abind.connections.valueAt(conni);
          if ((conn.flags & (Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_OOM_MANAGEMENT | Context.BIND_WAIVE_PRIORITY)) == Context.BIND_AUTO_CREATE) {
            hasCreate=true;
            break;
          }
        }
        if (!hasCreate) {
          continue;
        }
        if (false && proc != null && !proc.persistent && proc.thread != null && proc.pid != 0 && proc.pid != ActivityManagerService.MY_PID && proc.setProcState >= ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
          proc.kill(""String_Node_Str"" + sr.name.flattenToShortString() + ""String_Node_Str""+ (app != null ? app.processName : ""String_Node_Str""),true);
        }
      }
    }
  }
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    final ServiceRecord curRec=smap.mServicesByName.get(sr.name);
    if (curRec != sr) {
      if (curRec != null) {
        Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ curRec);
      }
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart || !mAm.mUserController.isUserRunningLocked(sr.userId,0)) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}",0.997187324207763
191227,"private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}","private final void bringDownServiceLocked(ServiceRecord r){
  for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
    ArrayList<ConnectionRecord> c=r.connections.valueAt(conni);
    for (int i=0; i < c.size(); i++) {
      ConnectionRecord cr=c.get(i);
      cr.serviceDead=true;
      try {
        cr.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.get(i).conn.asBinder()+ ""String_Node_Str""+ c.get(i).binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    for (int i=r.bindings.size() - 1; i >= 0; i--) {
      IntentBindRecord ibr=r.bindings.valueAt(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r,false,""String_Node_Str"");
          mAm.updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceProcessGoneLocked(r);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  r.destroyTime=SystemClock.uptimeMillis();
  if (LOG_SERVICE_START_STOP) {
    EventLogTags.writeAmDestroyService(r.userId,System.identityHashCode(r),(r.app != null) ? r.app.pid : -1);
  }
  final ServiceMap smap=getServiceMap(r.userId);
  smap.mServicesByName.remove(r.name);
  smap.mServicesByIntent.remove(r.intent);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r,0,true);
  for (int i=mPendingServices.size() - 1; i >= 0; i--) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.whitelistManager) {
      updateWhitelistManagerLocked(r.app);
    }
    if (r.app.thread != null) {
      updateServiceForegroundLocked(r.app,false);
      try {
        bumpServiceExecutingLocked(r,false,""String_Node_Str"");
        mDestroyingServices.add(r);
        r.destroying=true;
        mAm.updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceProcessGoneLocked(r);
      }
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  if (r.bindings.size() > 0) {
    r.bindings.clear();
  }
  if (r.restarter instanceof ServiceRestarter) {
    ((ServiceRestarter)r.restarter).setService(null);
  }
  int memFactor=mAm.mProcessStats.getMemFactorLocked();
  long now=SystemClock.uptimeMillis();
  if (r.tracker != null) {
    r.tracker.setStarted(false,memFactor,now);
    r.tracker.setBound(false,memFactor,now);
    if (r.executeNesting == 0) {
      r.tracker.clearCurrentOwner(r,false);
      r.tracker=null;
    }
  }
  smap.ensureNotStartingBackground(r);
}",0.9884755652808168
191228,"void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  mAm.stopAssociationLocked(b.client.uid,b.client.processName,s.appInfo.uid,s.name);
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        if (b.client != s.app && (c.flags & Context.BIND_WAIVE_PRIORITY) == 0 && s.app.setProcState <= ActivityManager.PROCESS_STATE_RECEIVER) {
          mAm.updateLruProcessLocked(s.app,false,null);
        }
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceProcessGoneLocked(s);
      }
    }
    mPendingServices.remove(s);
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}","void removeConnectionLocked(ConnectionRecord c,ProcessRecord skipApp,ActivityRecord skipAct){
  IBinder binder=c.conn.asBinder();
  AppBindRecord b=c.binding;
  ServiceRecord s=b.service;
  ArrayList<ConnectionRecord> clist=s.connections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      s.connections.remove(binder);
    }
  }
  b.connections.remove(c);
  if (c.activity != null && c.activity != skipAct) {
    if (c.activity.connections != null) {
      c.activity.connections.remove(c);
    }
  }
  if (b.client != skipApp) {
    b.client.connections.remove(c);
    if ((c.flags & Context.BIND_ABOVE_CLIENT) != 0) {
      b.client.updateHasAboveClientLocked();
    }
    if ((c.flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
      s.updateWhitelistManager();
      if (!s.whitelistManager && s.app != null) {
        updateWhitelistManagerLocked(s.app);
      }
    }
    if (s.app != null) {
      updateServiceClientActivitiesLocked(s.app,c,true);
    }
  }
  clist=mServiceConnections.get(binder);
  if (clist != null) {
    clist.remove(c);
    if (clist.size() == 0) {
      mServiceConnections.remove(binder);
    }
  }
  mAm.stopAssociationLocked(b.client.uid,b.client.processName,s.appInfo.uid,s.name);
  if (b.connections.size() == 0) {
    b.intent.apps.remove(b.client);
  }
  if (!c.serviceDead) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + b.intent + ""String_Node_Str""+ b.intent.hasBound);
    if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0 && b.intent.hasBound) {
      try {
        bumpServiceExecutingLocked(s,false,""String_Node_Str"");
        if (b.client != s.app && (c.flags & Context.BIND_WAIVE_PRIORITY) == 0 && s.app.setProcState <= ActivityManager.PROCESS_STATE_RECEIVER) {
          mAm.updateLruProcessLocked(s.app,false,null);
        }
        mAm.updateOomAdjLocked(s.app);
        b.intent.hasBound=false;
        b.intent.doRebind=false;
        s.app.thread.scheduleUnbindService(s,b.intent.intent.getIntent());
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + s.shortName,e);
        serviceProcessGoneLocked(s);
      }
    }
    mPendingServices.remove(s);
    if ((c.flags & Context.BIND_AUTO_CREATE) != 0) {
      boolean hasAutoCreate=s.hasAutoCreateConnections();
      if (!hasAutoCreate) {
        if (s.tracker != null) {
          s.tracker.setBound(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
        }
      }
      bringDownServiceIfNeededLocked(s,true,hasAutoCreate);
    }
  }
}",0.9574510990118976
191229,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.curSchedGroup=ProcessList.SCHED_GROUP_TOP_APP;
      app.adjType=""String_Node_Str"";
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_CUR_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_CUR_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    int minLayer=ProcessList.VISIBLE_APP_LAYER_MAX;
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Log.e(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.app+ ""String_Node_Str""+ app);
        if (r.app == null || (r.app.uid == app.uid)) {
          r.app=app;
        }
 else {
          continue;
        }
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        if (r.task != null && minLayer > 0) {
          final int layer=r.task.mLayerRank;
          if (layer >= 0 && minLayer > layer) {
            minLayer=layer;
          }
        }
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
    if (adj == ProcessList.VISIBLE_APP_ADJ) {
      adj+=minLayer;
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  app.whitelistManager=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) {
          app.whitelistManager=true;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=Math.max(clientAdj,ProcessList.VISIBLE_APP_ADJ);
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup > schedGroup) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=client.curSchedGroup;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup > schedGroup) {
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.curSchedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
      app.curSchedGroup=ProcessList.SCHED_GROUP_TOP_APP;
      app.adjType=""String_Node_Str"";
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.systemNoUi=false;
  final int PROCESS_STATE_CUR_TOP=mTopProcessState;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    procState=PROCESS_STATE_CUR_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    int minLayer=ProcessList.VISIBLE_APP_LAYER_MAX;
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Log.e(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.app+ ""String_Node_Str""+ app);
        if (r.app == null || (r.app.uid == app.uid)) {
          r.app=app;
        }
 else {
          continue;
        }
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        if (r.task != null && minLayer > 0) {
          final int layer=r.task.mLayerRank;
          if (layer >= 0 && minLayer > layer) {
            minLayer=layer;
          }
        }
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > PROCESS_STATE_CUR_TOP) {
          procState=PROCESS_STATE_CUR_TOP;
        }
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
    if (adj == ProcessList.VISIBLE_APP_ADJ) {
      adj+=minLayer;
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
    }
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG_BACKUP,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=Math.max(clientAdj,ProcessList.VISIBLE_APP_ADJ);
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup > schedGroup) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=client.curSchedGroup;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else                 if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                  clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
 else {
                  clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                }
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceProcState=clientProcState;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                schedGroup=ProcessList.SCHED_GROUP_TOP_APP;
              }
 else {
                schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
              }
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceProcState=procState;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceProcState=clientProcState;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup > schedGroup) {
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
        app.cached=false;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=ProcessList.SCHED_GROUP_BACKGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=ProcessList.SCHED_GROUP_DEFAULT;
}
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9960728872133208
191230,"void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(intent.getIntent().toShortString(false,true,false,true));
  pw.println('}');
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(packageName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  if (permission != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(permission);
  }
  long now=SystemClock.uptimeMillis();
  long nowReal=SystemClock.elapsedRealtime();
  if (appInfo != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.sourceDir);
    if (!Objects.equals(appInfo.sourceDir,appInfo.publicSourceDir)) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(appInfo.publicSourceDir);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.dataDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  if (isolatedProc != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(isolatedProc);
  }
  if (delayed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(delayed);
  }
  if (isForeground || foregroundId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(isForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundId);
    pw.print(""String_Node_Str"");
    pw.println(foregroundNoti);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(createTime,nowReal,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(startingBgTimeout,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivity,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(restartTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(createdFromFg);
  if (startRequested || delayedStop || lastStartId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(startRequested);
    pw.print(""String_Node_Str"");
    pw.print(delayedStop);
    pw.print(""String_Node_Str"");
    pw.print(stopIfKilled);
    pw.print(""String_Node_Str"");
    pw.print(callStart);
    pw.print(""String_Node_Str"");
    pw.println(lastStartId);
  }
  if (executeNesting != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(executeNesting);
    pw.print(""String_Node_Str"");
    pw.print(executeFg);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(executingStart,now,pw);
    pw.println();
  }
  if (destroying || destroyTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(destroying);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(destroyTime,now,pw);
    pw.println();
  }
  if (crashCount != 0 || restartCount != 0 || restartDelay != 0 || nextRestartTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(restartCount);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(restartDelay,now,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(nextRestartTime,now,pw);
    pw.print(""String_Node_Str"");
    pw.println(crashCount);
  }
  if (deliveredStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,deliveredStarts,now);
  }
  if (pendingStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,pendingStarts,0);
  }
  if (bindings.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < bindings.size(); i++) {
      IntentBindRecord b=bindings.valueAt(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(Integer.toHexString(System.identityHashCode(b)));
      if ((b.collectFlags() & Context.BIND_AUTO_CREATE) != 0) {
        pw.append(""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      b.dumpInService(pw,prefix + ""String_Node_Str"");
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int conni=0; conni < connections.size(); conni++) {
      ArrayList<ConnectionRecord> c=connections.valueAt(conni);
      for (int i=0; i < c.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(c.get(i));
      }
    }
  }
}","void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(intent.getIntent().toShortString(false,true,false,true));
  pw.println('}');
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(packageName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  if (permission != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(permission);
  }
  long now=SystemClock.uptimeMillis();
  long nowReal=SystemClock.elapsedRealtime();
  if (appInfo != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.sourceDir);
    if (!Objects.equals(appInfo.sourceDir,appInfo.publicSourceDir)) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(appInfo.publicSourceDir);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.dataDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  if (isolatedProc != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(isolatedProc);
  }
  if (whitelistManager) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(whitelistManager);
  }
  if (delayed) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(delayed);
  }
  if (isForeground || foregroundId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(isForeground);
    pw.print(""String_Node_Str"");
    pw.print(foregroundId);
    pw.print(""String_Node_Str"");
    pw.println(foregroundNoti);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(createTime,nowReal,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(startingBgTimeout,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivity,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(restartTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(createdFromFg);
  if (startRequested || delayedStop || lastStartId != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(startRequested);
    pw.print(""String_Node_Str"");
    pw.print(delayedStop);
    pw.print(""String_Node_Str"");
    pw.print(stopIfKilled);
    pw.print(""String_Node_Str"");
    pw.print(callStart);
    pw.print(""String_Node_Str"");
    pw.println(lastStartId);
  }
  if (executeNesting != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(executeNesting);
    pw.print(""String_Node_Str"");
    pw.print(executeFg);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(executingStart,now,pw);
    pw.println();
  }
  if (destroying || destroyTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(destroying);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(destroyTime,now,pw);
    pw.println();
  }
  if (crashCount != 0 || restartCount != 0 || restartDelay != 0 || nextRestartTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(restartCount);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(restartDelay,now,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(nextRestartTime,now,pw);
    pw.print(""String_Node_Str"");
    pw.println(crashCount);
  }
  if (deliveredStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,deliveredStarts,now);
  }
  if (pendingStarts.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    dumpStartList(pw,prefix,pendingStarts,0);
  }
  if (bindings.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < bindings.size(); i++) {
      IntentBindRecord b=bindings.valueAt(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(Integer.toHexString(System.identityHashCode(b)));
      if ((b.collectFlags() & Context.BIND_AUTO_CREATE) != 0) {
        pw.append(""String_Node_Str"");
      }
      pw.println(""String_Node_Str"");
      b.dumpInService(pw,prefix + ""String_Node_Str"");
    }
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int conni=0; conni < connections.size(); conni++) {
      ArrayList<ConnectionRecord> c=connections.valueAt(conni);
      for (int i=0; i < c.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(c.get(i));
      }
    }
  }
}",0.9866036249014972
191231,"public int getOrientationLocked(){
  if (mDisplayFrozen) {
    if (mLastWindowForcedOrientation != SCREEN_ORIENTATION_UNSPECIFIED) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"" + mLastWindowForcedOrientation);
      return mLastWindowForcedOrientation;
    }
  }
 else {
    final WindowList windows=getDefaultWindowListLocked();
    for (int pos=windows.size() - 1; pos >= 0; --pos) {
      WindowState win=windows.get(pos);
      if (win.mAppToken != null) {
        break;
      }
      if (!win.isVisibleLw() || !win.mPolicyVisibilityAfterAnim) {
        continue;
      }
      int req=win.mAttrs.screenOrientation;
      if (req == SCREEN_ORIENTATION_UNSPECIFIED || req == SCREEN_ORIENTATION_BEHIND) {
        continue;
      }
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,win + ""String_Node_Str"" + req);
      if (mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        mLastKeyguardForcedOrientation=req;
      }
      return (mLastWindowForcedOrientation=req);
    }
    mLastWindowForcedOrientation=SCREEN_ORIENTATION_UNSPECIFIED;
    if (mPolicy.isKeyguardLocked()) {
      WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
      AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
      if (appShowWhenLocked != null) {
        int req=appShowWhenLocked.requestedOrientation;
        if (req == SCREEN_ORIENTATION_BEHIND) {
          req=mLastKeyguardForcedOrientation;
        }
        if (DEBUG_ORIENTATION)         Slog.v(TAG_WM,""String_Node_Str"" + appShowWhenLocked + ""String_Node_Str""+ req);
        return req;
      }
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"");
      return mLastKeyguardForcedOrientation;
    }
  }
  return getAppSpecifiedOrientation();
}","public int getOrientationLocked(){
  if (mDisplayFrozen) {
    if (mLastWindowForcedOrientation != SCREEN_ORIENTATION_UNSPECIFIED) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"" + mLastWindowForcedOrientation);
      return mLastWindowForcedOrientation;
    }
 else     if (mPolicy.isKeyguardLocked() && mLastKeyguardForcedOrientation != SCREEN_ORIENTATION_UNSPECIFIED) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + mLastKeyguardForcedOrientation);
      return mLastKeyguardForcedOrientation;
    }
  }
 else {
    final WindowList windows=getDefaultWindowListLocked();
    for (int pos=windows.size() - 1; pos >= 0; --pos) {
      WindowState win=windows.get(pos);
      if (win.mAppToken != null) {
        break;
      }
      if (!win.isVisibleLw() || !win.mPolicyVisibilityAfterAnim) {
        continue;
      }
      int req=win.mAttrs.screenOrientation;
      if (req == SCREEN_ORIENTATION_UNSPECIFIED || req == SCREEN_ORIENTATION_BEHIND) {
        continue;
      }
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,win + ""String_Node_Str"" + req);
      if (mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        mLastKeyguardForcedOrientation=req;
      }
      return (mLastWindowForcedOrientation=req);
    }
    mLastWindowForcedOrientation=SCREEN_ORIENTATION_UNSPECIFIED;
    if (mPolicy.isKeyguardLocked()) {
      WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
      AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
      if (appShowWhenLocked != null) {
        int req=appShowWhenLocked.requestedOrientation;
        if (req == SCREEN_ORIENTATION_BEHIND) {
          req=mLastKeyguardForcedOrientation;
        }
        if (DEBUG_ORIENTATION)         Slog.v(TAG_WM,""String_Node_Str"" + appShowWhenLocked + ""String_Node_Str""+ req);
        return req;
      }
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"");
      return mLastKeyguardForcedOrientation;
    }
  }
  return getAppSpecifiedOrientation();
}",0.4181490074761536
191232,"public int getOrientationLocked(){
  if (mDisplayFrozen) {
    if (mLastWindowForcedOrientation != SCREEN_ORIENTATION_UNSPECIFIED) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"" + mLastWindowForcedOrientation);
      return mLastWindowForcedOrientation;
    }
  }
 else {
    final WindowList windows=getDefaultWindowListLocked();
    for (int pos=windows.size() - 1; pos >= 0; --pos) {
      WindowState win=windows.get(pos);
      if (win.mAppToken != null) {
        break;
      }
      if (!win.isVisibleLw() || !win.mPolicyVisibilityAfterAnim) {
        continue;
      }
      int req=win.mAttrs.screenOrientation;
      if (req == SCREEN_ORIENTATION_UNSPECIFIED || req == SCREEN_ORIENTATION_BEHIND) {
        continue;
      }
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,win + ""String_Node_Str"" + req);
      if (mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        mLastKeyguardForcedOrientation=req;
      }
      return (mLastWindowForcedOrientation=req);
    }
    mLastWindowForcedOrientation=SCREEN_ORIENTATION_UNSPECIFIED;
    if (mPolicy.isKeyguardLocked()) {
      WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
      AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
      if (appShowWhenLocked != null) {
        int req=appShowWhenLocked.requestedOrientation;
        if (req == SCREEN_ORIENTATION_BEHIND) {
          req=mLastKeyguardForcedOrientation;
        }
        if (DEBUG_ORIENTATION)         Slog.v(TAG_WM,""String_Node_Str"" + appShowWhenLocked + ""String_Node_Str""+ req);
        return req;
      }
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"");
      return mLastKeyguardForcedOrientation;
    }
  }
  return getAppSpecifiedOrientation();
}","public int getOrientationLocked(){
  if (mDisplayFrozen) {
    if (mLastWindowForcedOrientation != SCREEN_ORIENTATION_UNSPECIFIED) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"" + mLastWindowForcedOrientation);
      return mLastWindowForcedOrientation;
    }
 else     if (mPolicy.isKeyguardLocked() && mLastKeyguardForcedOrientation != SCREEN_ORIENTATION_UNSPECIFIED) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + mLastKeyguardForcedOrientation);
      return mLastKeyguardForcedOrientation;
    }
  }
 else {
    final WindowList windows=getDefaultWindowListLocked();
    for (int pos=windows.size() - 1; pos >= 0; --pos) {
      WindowState win=windows.get(pos);
      if (win.mAppToken != null) {
        break;
      }
      if (!win.isVisibleLw() || !win.mPolicyVisibilityAfterAnim) {
        continue;
      }
      int req=win.mAttrs.screenOrientation;
      if (req == SCREEN_ORIENTATION_UNSPECIFIED || req == SCREEN_ORIENTATION_BEHIND) {
        continue;
      }
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,win + ""String_Node_Str"" + req);
      if (mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        mLastKeyguardForcedOrientation=req;
      }
      return (mLastWindowForcedOrientation=req);
    }
    mLastWindowForcedOrientation=SCREEN_ORIENTATION_UNSPECIFIED;
    if (mPolicy.isKeyguardLocked()) {
      WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
      AppWindowToken appShowWhenLocked=winShowWhenLocked == null ? null : winShowWhenLocked.mAppToken;
      if (appShowWhenLocked != null) {
        int req=appShowWhenLocked.requestedOrientation;
        if (req == SCREEN_ORIENTATION_BEHIND) {
          req=mLastKeyguardForcedOrientation;
        }
        if (DEBUG_ORIENTATION)         Slog.v(TAG_WM,""String_Node_Str"" + appShowWhenLocked + ""String_Node_Str""+ req);
        return req;
      }
      if (DEBUG_ORIENTATION)       Slog.v(TAG_WM,""String_Node_Str"");
      return mLastKeyguardForcedOrientation;
    }
  }
  return getAppSpecifiedOrientation();
}",0.4181490074761536
191233,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplay.getDisplayAdjustments().getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  boolean updatedConfiguration=false;
  final int surfaceGenerationId=mSurface.getGenerationId();
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
        updatedConfiguration=true;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      final boolean framesChanged=overscanInsetsChanged || contentInsetsChanged || stableInsetsChanged|| visibleInsetsChanged|| outsetsChanged;
      if (mAdded && mView != null && framesChanged) {
        forceLayout(mView);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight() || mNeedsHwRendererSetup) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
        mNeedsHwRendererSetup=false;
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplay.getDisplayAdjustments().getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  boolean updatedConfiguration=false;
  final int surfaceGenerationId=mSurface.getGenerationId();
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean framesChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
        updatedConfiguration=true;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      boolean contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      framesChanged=overscanInsetsChanged || contentInsetsChanged || stableInsetsChanged|| visibleInsetsChanged|| outsetsChanged;
      if (mAdded && mView != null && framesChanged) {
        forceLayout(mView);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight() || mNeedsHwRendererSetup) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
        mNeedsHwRendererSetup=false;
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || framesChanged || updatedConfiguration) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ framesChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}",0.9984380014978068
191234,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplay.getDisplayAdjustments().getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  boolean updatedConfiguration=false;
  final int surfaceGenerationId=mSurface.getGenerationId();
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
        updatedConfiguration=true;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      final boolean framesChanged=overscanInsetsChanged || contentInsetsChanged || stableInsetsChanged|| visibleInsetsChanged|| outsetsChanged;
      if (mAdded && mView != null && framesChanged) {
        forceLayout(mView);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight() || mNeedsHwRendererSetup) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
        mNeedsHwRendererSetup=false;
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplay.getDisplayAdjustments().getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  boolean updatedConfiguration=false;
  final int surfaceGenerationId=mSurface.getGenerationId();
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean framesChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
        updatedConfiguration=true;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      boolean contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      framesChanged=overscanInsetsChanged || contentInsetsChanged || stableInsetsChanged|| visibleInsetsChanged|| outsetsChanged;
      if (mAdded && mView != null && framesChanged) {
        forceLayout(mView);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight() || mNeedsHwRendererSetup) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
        mNeedsHwRendererSetup=false;
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || framesChanged || updatedConfiguration) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ framesChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}",0.9984380014978068
191235,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplay.getDisplayAdjustments().getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  boolean updatedConfiguration=false;
  final int surfaceGenerationId=mSurface.getGenerationId();
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
        updatedConfiguration=true;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      final boolean framesChanged=overscanInsetsChanged || contentInsetsChanged || stableInsetsChanged|| visibleInsetsChanged|| outsetsChanged;
      if (mAdded && mView != null && framesChanged) {
        forceLayout(mView);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight() || mNeedsHwRendererSetup) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
        mNeedsHwRendererSetup=false;
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplay.getDisplayAdjustments().getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  boolean updatedConfiguration=false;
  final int surfaceGenerationId=mSurface.getGenerationId();
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean framesChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
        updatedConfiguration=true;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      boolean contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      framesChanged=overscanInsetsChanged || contentInsetsChanged || stableInsetsChanged|| visibleInsetsChanged|| outsetsChanged;
      if (mAdded && mView != null && framesChanged) {
        forceLayout(mView);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight() || mNeedsHwRendererSetup) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
        mNeedsHwRendererSetup=false;
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || framesChanged || updatedConfiguration) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ framesChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}",0.9984380014978068
191236,"@Override public IBinder onBind(Intent intent){
  mService=IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
  try {
    mTile=mService.getTile(new ComponentName(getPackageName(),getClass().getName()));
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (mTile != null) {
    mTile.setService(mService);
    mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
  }
  return new IQSTileService.Stub(){
    @Override public void onTileRemoved() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
    }
    @Override public void onTileAdded() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
    }
    @Override public void onStopListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
    }
    @Override public void onStartListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
    }
    @Override public void onClick(    IBinder wtoken) throws RemoteException {
      mHandler.obtainMessage(H.MSG_TILE_CLICKED,wtoken).sendToTarget();
    }
    @Override public void onUnlockComplete() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
    }
  }
;
}","@Override public IBinder onBind(Intent intent){
  mService=IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
  try {
    ComponentName component=intent.getParcelableExtra(EXTRA_COMPONENT);
    mTile=mService.getTile(component);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (mTile != null) {
    mTile.setService(mService);
    mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
  }
  return new IQSTileService.Stub(){
    @Override public void onTileRemoved() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
    }
    @Override public void onTileAdded() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
    }
    @Override public void onStopListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
    }
    @Override public void onStartListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
    }
    @Override public void onClick(    IBinder wtoken) throws RemoteException {
      mHandler.obtainMessage(H.MSG_TILE_CLICKED,wtoken).sendToTarget();
    }
    @Override public void onUnlockComplete() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
    }
  }
;
}",0.9315604223699648
191237,"public TileLifecycleManager(Handler handler,Context context,IQSService service,Tile tile,Intent intent,UserHandle user){
  mContext=context;
  mHandler=handler;
  mIntent=intent;
  mIntent.putExtra(TileService.EXTRA_SERVICE,service.asBinder());
  mUser=user;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mIntent + ""String_Node_Str""+ mUser);
}","public TileLifecycleManager(Handler handler,Context context,IQSService service,Tile tile,Intent intent,UserHandle user){
  mContext=context;
  mHandler=handler;
  mIntent=intent;
  mIntent.putExtra(TileService.EXTRA_SERVICE,service.asBinder());
  mIntent.putExtra(TileService.EXTRA_COMPONENT,intent.getComponent());
  mUser=user;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mIntent + ""String_Node_Str""+ mUser);
}",0.9059602649006624
191238,"@Override public IBinder onBind(Intent intent){
  mService=IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
  try {
    mTile=mService.getTile(new ComponentName(getPackageName(),getClass().getName()));
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (mTile != null) {
    mTile.setService(mService);
    mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
  }
  return new IQSTileService.Stub(){
    @Override public void onTileRemoved() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
    }
    @Override public void onTileAdded() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
    }
    @Override public void onStopListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
    }
    @Override public void onStartListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
    }
    @Override public void onClick(    IBinder wtoken) throws RemoteException {
      mHandler.obtainMessage(H.MSG_TILE_CLICKED,wtoken).sendToTarget();
    }
    @Override public void onUnlockComplete() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
    }
  }
;
}","@Override public IBinder onBind(Intent intent){
  mService=IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
  try {
    ComponentName component=intent.getParcelableExtra(EXTRA_COMPONENT);
    mTile=mService.getTile(component);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (mTile != null) {
    mTile.setService(mService);
    mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
  }
  return new IQSTileService.Stub(){
    @Override public void onTileRemoved() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
    }
    @Override public void onTileAdded() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
    }
    @Override public void onStopListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
    }
    @Override public void onStartListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
    }
    @Override public void onClick(    IBinder wtoken) throws RemoteException {
      mHandler.obtainMessage(H.MSG_TILE_CLICKED,wtoken).sendToTarget();
    }
    @Override public void onUnlockComplete() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
    }
  }
;
}",0.9315604223699648
191239,"public TileLifecycleManager(Handler handler,Context context,IQSService service,Tile tile,Intent intent,UserHandle user){
  mContext=context;
  mHandler=handler;
  mIntent=intent;
  mIntent.putExtra(TileService.EXTRA_SERVICE,service.asBinder());
  mUser=user;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mIntent + ""String_Node_Str""+ mUser);
}","public TileLifecycleManager(Handler handler,Context context,IQSService service,Tile tile,Intent intent,UserHandle user){
  mContext=context;
  mHandler=handler;
  mIntent=intent;
  mIntent.putExtra(TileService.EXTRA_SERVICE,service.asBinder());
  mIntent.putExtra(TileService.EXTRA_COMPONENT,intent.getComponent());
  mUser=user;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mIntent + ""String_Node_Str""+ mUser);
}",0.9059602649006624
191240,"@Override public IBinder onBind(Intent intent){
  mService=IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
  try {
    mTile=mService.getTile(new ComponentName(getPackageName(),getClass().getName()));
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (mTile != null) {
    mTile.setService(mService);
    mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
  }
  return new IQSTileService.Stub(){
    @Override public void onTileRemoved() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
    }
    @Override public void onTileAdded() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
    }
    @Override public void onStopListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
    }
    @Override public void onStartListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
    }
    @Override public void onClick(    IBinder wtoken) throws RemoteException {
      mHandler.obtainMessage(H.MSG_TILE_CLICKED,wtoken).sendToTarget();
    }
    @Override public void onUnlockComplete() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
    }
  }
;
}","@Override public IBinder onBind(Intent intent){
  mService=IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
  try {
    ComponentName component=intent.getParcelableExtra(EXTRA_COMPONENT);
    mTile=mService.getTile(component);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (mTile != null) {
    mTile.setService(mService);
    mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
  }
  return new IQSTileService.Stub(){
    @Override public void onTileRemoved() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
    }
    @Override public void onTileAdded() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
    }
    @Override public void onStopListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
    }
    @Override public void onStartListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
    }
    @Override public void onClick(    IBinder wtoken) throws RemoteException {
      mHandler.obtainMessage(H.MSG_TILE_CLICKED,wtoken).sendToTarget();
    }
    @Override public void onUnlockComplete() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
    }
  }
;
}",0.9315604223699648
191241,"public TileLifecycleManager(Handler handler,Context context,IQSService service,Tile tile,Intent intent,UserHandle user){
  mContext=context;
  mHandler=handler;
  mIntent=intent;
  mIntent.putExtra(TileService.EXTRA_SERVICE,service.asBinder());
  mUser=user;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mIntent + ""String_Node_Str""+ mUser);
}","public TileLifecycleManager(Handler handler,Context context,IQSService service,Tile tile,Intent intent,UserHandle user){
  mContext=context;
  mHandler=handler;
  mIntent=intent;
  mIntent.putExtra(TileService.EXTRA_SERVICE,service.asBinder());
  mIntent.putExtra(TileService.EXTRA_COMPONENT,intent.getComponent());
  mUser=user;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mIntent + ""String_Node_Str""+ mUser);
}",0.9059602649006624
191242,"@Override public IBinder onBind(Intent intent){
  mService=IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
  try {
    mTile=mService.getTile(new ComponentName(getPackageName(),getClass().getName()));
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (mTile != null) {
    mTile.setService(mService);
    mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
  }
  return new IQSTileService.Stub(){
    @Override public void onTileRemoved() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
    }
    @Override public void onTileAdded() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
    }
    @Override public void onStopListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
    }
    @Override public void onStartListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
    }
    @Override public void onClick(    IBinder wtoken) throws RemoteException {
      mHandler.obtainMessage(H.MSG_TILE_CLICKED,wtoken).sendToTarget();
    }
    @Override public void onUnlockComplete() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
    }
  }
;
}","@Override public IBinder onBind(Intent intent){
  mService=IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
  try {
    ComponentName component=intent.getParcelableExtra(EXTRA_COMPONENT);
    mTile=mService.getTile(component);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (mTile != null) {
    mTile.setService(mService);
    mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
  }
  return new IQSTileService.Stub(){
    @Override public void onTileRemoved() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
    }
    @Override public void onTileAdded() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
    }
    @Override public void onStopListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
    }
    @Override public void onStartListening() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
    }
    @Override public void onClick(    IBinder wtoken) throws RemoteException {
      mHandler.obtainMessage(H.MSG_TILE_CLICKED,wtoken).sendToTarget();
    }
    @Override public void onUnlockComplete() throws RemoteException {
      mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
    }
  }
;
}",0.9315604223699648
191243,"public TileLifecycleManager(Handler handler,Context context,IQSService service,Tile tile,Intent intent,UserHandle user){
  mContext=context;
  mHandler=handler;
  mIntent=intent;
  mIntent.putExtra(TileService.EXTRA_SERVICE,service.asBinder());
  mUser=user;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mIntent + ""String_Node_Str""+ mUser);
}","public TileLifecycleManager(Handler handler,Context context,IQSService service,Tile tile,Intent intent,UserHandle user){
  mContext=context;
  mHandler=handler;
  mIntent=intent;
  mIntent.putExtra(TileService.EXTRA_SERVICE,service.asBinder());
  mIntent.putExtra(TileService.EXTRA_COMPONENT,intent.getComponent());
  mUser=user;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mIntent + ""String_Node_Str""+ mUser);
}",0.9059602649006624
191244,"JobInstance(JobStatus jobStatus){
  mJobStatus=jobStatus;
  mExecuteRunner=new TriggerRunnable(this);
  mTimeoutRunner=new TriggerRunnable(this);
  final JobInfo.TriggerContentUri[] uris=jobStatus.getJob().getTriggerContentUris();
  if (uris != null) {
    for (    JobInfo.TriggerContentUri uri : uris) {
      ObserverInstance obs=mObservers.get(uri.getUri());
      if (obs == null) {
        obs=new ObserverInstance(mHandler,uri.getUri());
        mObservers.put(uri.getUri(),obs);
        mContext.getContentResolver().registerContentObserver(uri.getUri(),(uri.getFlags() & JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS) != 0,obs);
      }
      obs.mJobs.add(this);
      mMyObservers.add(obs);
    }
  }
}","JobInstance(JobStatus jobStatus){
  mJobStatus=jobStatus;
  mExecuteRunner=new TriggerRunnable(this);
  mTimeoutRunner=new TriggerRunnable(this);
  final JobInfo.TriggerContentUri[] uris=jobStatus.getJob().getTriggerContentUris();
  if (uris != null) {
    for (    JobInfo.TriggerContentUri uri : uris) {
      ObserverInstance obs=mObservers.get(uri);
      if (obs == null) {
        obs=new ObserverInstance(mHandler,uri.getUri());
        mObservers.put(uri,obs);
        mContext.getContentResolver().registerContentObserver(uri.getUri(),(uri.getFlags() & JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS) != 0,obs);
      }
      obs.mJobs.add(this);
      mMyObservers.add(obs);
    }
  }
}",0.8806179775280899
191245,"@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    JobStatus js=it.next();
    if (!js.shouldDump(filterUid)) {
      continue;
    }
    pw.print(""String_Node_Str"");
    js.printUniqueId(pw);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,js.getSourceUid());
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      int M=obs.mJobs.size();
      boolean shouldDump=false;
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        if (inst.mJobStatus.shouldDump(filterUid)) {
          shouldDump=true;
          break;
        }
      }
      if (!shouldDump) {
        continue;
      }
      pw.print(""String_Node_Str"");
      pw.print(mObservers.keyAt(i));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        inst.mJobStatus.printUniqueId(pw);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,inst.mJobStatus.getSourceUid());
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    JobStatus js=it.next();
    if (!js.shouldDump(filterUid)) {
      continue;
    }
    pw.print(""String_Node_Str"");
    js.printUniqueId(pw);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,js.getSourceUid());
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      int M=obs.mJobs.size();
      boolean shouldDump=false;
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        if (inst.mJobStatus.shouldDump(filterUid)) {
          shouldDump=true;
          break;
        }
      }
      if (!shouldDump) {
        continue;
      }
      pw.print(""String_Node_Str"");
      JobInfo.TriggerContentUri trigger=mObservers.keyAt(i);
      pw.print(trigger.getUri());
      pw.print(""String_Node_Str"");
      pw.print(Integer.toHexString(trigger.getFlags()));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        inst.mJobStatus.printUniqueId(pw);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,inst.mJobStatus.getSourceUid());
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}",0.9658536585365852
191246,"void detachLocked(){
  final int N=mMyObservers.size();
  for (int i=0; i < N; i++) {
    final ObserverInstance obs=mMyObservers.get(i);
    obs.mJobs.remove(this);
    if (obs.mJobs.size() == 0) {
      mContext.getContentResolver().unregisterContentObserver(obs);
      mObservers.remove(obs.mUri);
    }
  }
}","void detachLocked(){
  final int N=mMyObservers.size();
  for (int i=0; i < N; i++) {
    final ObserverInstance obs=mMyObservers.get(i);
    obs.mJobs.remove(this);
    if (obs.mJobs.size() == 0) {
      mContext.getContentResolver().unregisterContentObserver(obs);
      mObservers.remove(obs);
    }
  }
}",0.9919484702093396
191247,"JobInstance(JobStatus jobStatus){
  mJobStatus=jobStatus;
  mExecuteRunner=new TriggerRunnable(this);
  mTimeoutRunner=new TriggerRunnable(this);
  final JobInfo.TriggerContentUri[] uris=jobStatus.getJob().getTriggerContentUris();
  if (uris != null) {
    for (    JobInfo.TriggerContentUri uri : uris) {
      ObserverInstance obs=mObservers.get(uri.getUri());
      if (obs == null) {
        obs=new ObserverInstance(mHandler,uri.getUri());
        mObservers.put(uri.getUri(),obs);
        mContext.getContentResolver().registerContentObserver(uri.getUri(),(uri.getFlags() & JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS) != 0,obs);
      }
      obs.mJobs.add(this);
      mMyObservers.add(obs);
    }
  }
}","JobInstance(JobStatus jobStatus){
  mJobStatus=jobStatus;
  mExecuteRunner=new TriggerRunnable(this);
  mTimeoutRunner=new TriggerRunnable(this);
  final JobInfo.TriggerContentUri[] uris=jobStatus.getJob().getTriggerContentUris();
  if (uris != null) {
    for (    JobInfo.TriggerContentUri uri : uris) {
      ObserverInstance obs=mObservers.get(uri);
      if (obs == null) {
        obs=new ObserverInstance(mHandler,uri.getUri());
        mObservers.put(uri,obs);
        mContext.getContentResolver().registerContentObserver(uri.getUri(),(uri.getFlags() & JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS) != 0,obs);
      }
      obs.mJobs.add(this);
      mMyObservers.add(obs);
    }
  }
}",0.8806179775280899
191248,"@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    JobStatus js=it.next();
    if (!js.shouldDump(filterUid)) {
      continue;
    }
    pw.print(""String_Node_Str"");
    js.printUniqueId(pw);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,js.getSourceUid());
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      int M=obs.mJobs.size();
      boolean shouldDump=false;
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        if (inst.mJobStatus.shouldDump(filterUid)) {
          shouldDump=true;
          break;
        }
      }
      if (!shouldDump) {
        continue;
      }
      pw.print(""String_Node_Str"");
      pw.print(mObservers.keyAt(i));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        inst.mJobStatus.printUniqueId(pw);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,inst.mJobStatus.getSourceUid());
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    JobStatus js=it.next();
    if (!js.shouldDump(filterUid)) {
      continue;
    }
    pw.print(""String_Node_Str"");
    js.printUniqueId(pw);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,js.getSourceUid());
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      int M=obs.mJobs.size();
      boolean shouldDump=false;
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        if (inst.mJobStatus.shouldDump(filterUid)) {
          shouldDump=true;
          break;
        }
      }
      if (!shouldDump) {
        continue;
      }
      pw.print(""String_Node_Str"");
      JobInfo.TriggerContentUri trigger=mObservers.keyAt(i);
      pw.print(trigger.getUri());
      pw.print(""String_Node_Str"");
      pw.print(Integer.toHexString(trigger.getFlags()));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        inst.mJobStatus.printUniqueId(pw);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,inst.mJobStatus.getSourceUid());
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}",0.9658536585365852
191249,"void detachLocked(){
  final int N=mMyObservers.size();
  for (int i=0; i < N; i++) {
    final ObserverInstance obs=mMyObservers.get(i);
    obs.mJobs.remove(this);
    if (obs.mJobs.size() == 0) {
      mContext.getContentResolver().unregisterContentObserver(obs);
      mObservers.remove(obs.mUri);
    }
  }
}","void detachLocked(){
  final int N=mMyObservers.size();
  for (int i=0; i < N; i++) {
    final ObserverInstance obs=mMyObservers.get(i);
    obs.mJobs.remove(this);
    if (obs.mJobs.size() == 0) {
      mContext.getContentResolver().unregisterContentObserver(obs);
      mObservers.remove(obs);
    }
  }
}",0.9919484702093396
191250,"JobInstance(JobStatus jobStatus){
  mJobStatus=jobStatus;
  mExecuteRunner=new TriggerRunnable(this);
  mTimeoutRunner=new TriggerRunnable(this);
  final JobInfo.TriggerContentUri[] uris=jobStatus.getJob().getTriggerContentUris();
  if (uris != null) {
    for (    JobInfo.TriggerContentUri uri : uris) {
      ObserverInstance obs=mObservers.get(uri.getUri());
      if (obs == null) {
        obs=new ObserverInstance(mHandler,uri.getUri());
        mObservers.put(uri.getUri(),obs);
        mContext.getContentResolver().registerContentObserver(uri.getUri(),(uri.getFlags() & JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS) != 0,obs);
      }
      obs.mJobs.add(this);
      mMyObservers.add(obs);
    }
  }
}","JobInstance(JobStatus jobStatus){
  mJobStatus=jobStatus;
  mExecuteRunner=new TriggerRunnable(this);
  mTimeoutRunner=new TriggerRunnable(this);
  final JobInfo.TriggerContentUri[] uris=jobStatus.getJob().getTriggerContentUris();
  if (uris != null) {
    for (    JobInfo.TriggerContentUri uri : uris) {
      ObserverInstance obs=mObservers.get(uri);
      if (obs == null) {
        obs=new ObserverInstance(mHandler,uri.getUri());
        mObservers.put(uri,obs);
        mContext.getContentResolver().registerContentObserver(uri.getUri(),(uri.getFlags() & JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS) != 0,obs);
      }
      obs.mJobs.add(this);
      mMyObservers.add(obs);
    }
  }
}",0.8806179775280899
191251,"@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    JobStatus js=it.next();
    if (!js.shouldDump(filterUid)) {
      continue;
    }
    pw.print(""String_Node_Str"");
    js.printUniqueId(pw);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,js.getSourceUid());
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      int M=obs.mJobs.size();
      boolean shouldDump=false;
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        if (inst.mJobStatus.shouldDump(filterUid)) {
          shouldDump=true;
          break;
        }
      }
      if (!shouldDump) {
        continue;
      }
      pw.print(""String_Node_Str"");
      pw.print(mObservers.keyAt(i));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        inst.mJobStatus.printUniqueId(pw);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,inst.mJobStatus.getSourceUid());
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    JobStatus js=it.next();
    if (!js.shouldDump(filterUid)) {
      continue;
    }
    pw.print(""String_Node_Str"");
    js.printUniqueId(pw);
    pw.print(""String_Node_Str"");
    UserHandle.formatUid(pw,js.getSourceUid());
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      int M=obs.mJobs.size();
      boolean shouldDump=false;
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        if (inst.mJobStatus.shouldDump(filterUid)) {
          shouldDump=true;
          break;
        }
      }
      if (!shouldDump) {
        continue;
      }
      pw.print(""String_Node_Str"");
      JobInfo.TriggerContentUri trigger=mObservers.keyAt(i);
      pw.print(trigger.getUri());
      pw.print(""String_Node_Str"");
      pw.print(Integer.toHexString(trigger.getFlags()));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        inst.mJobStatus.printUniqueId(pw);
        pw.print(""String_Node_Str"");
        UserHandle.formatUid(pw,inst.mJobStatus.getSourceUid());
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}",0.9658536585365852
191252,"void detachLocked(){
  final int N=mMyObservers.size();
  for (int i=0; i < N; i++) {
    final ObserverInstance obs=mMyObservers.get(i);
    obs.mJobs.remove(this);
    if (obs.mJobs.size() == 0) {
      mContext.getContentResolver().unregisterContentObserver(obs);
      mObservers.remove(obs.mUri);
    }
  }
}","void detachLocked(){
  final int N=mMyObservers.size();
  for (int i=0; i < N; i++) {
    final ObserverInstance obs=mMyObservers.get(i);
    obs.mJobs.remove(this);
    if (obs.mJobs.size() == 0) {
      mContext.getContentResolver().unregisterContentObserver(obs);
      mObservers.remove(obs);
    }
  }
}",0.9919484702093396
191253,"/** 
 * Cancels all notifications from a given package that have all of the  {@code mustHaveFlags}.
 */
boolean cancelAllNotificationsInt(int callingUid,int callingPid,String pkg,int mustHaveFlags,int mustNotHaveFlags,boolean doit,int userId,int reason,ManagedServiceInfo listener){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,pkg,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
    final int N=mNotificationList.size();
    ArrayList<NotificationRecord> canceledNotifications=null;
    for (int i=N - 1; i >= 0; --i) {
      NotificationRecord r=mNotificationList.get(i);
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
      if (r.getUserId() == UserHandle.USER_ALL && pkg == null) {
        continue;
      }
      if ((r.getFlags() & mustHaveFlags) != mustHaveFlags) {
        continue;
      }
      if ((r.getFlags() & mustNotHaveFlags) != 0) {
        continue;
      }
      if (pkg != null && !r.sbn.getPackageName().equals(pkg)) {
        continue;
      }
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
      if (!doit) {
        return true;
      }
      mNotificationList.remove(i);
      cancelNotificationLocked(r,false,reason);
    }
    if (doit && canceledNotifications != null) {
      final int M=canceledNotifications.size();
      for (int i=0; i < M; i++) {
        cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
      }
    }
    if (canceledNotifications != null) {
      updateLightsLocked();
    }
    return canceledNotifications != null;
  }
}","/** 
 * Cancels all notifications from a given package that have all of the  {@code mustHaveFlags}.
 */
boolean cancelAllNotificationsInt(int callingUid,int callingPid,String pkg,int mustHaveFlags,int mustNotHaveFlags,boolean doit,int userId,int reason,ManagedServiceInfo listener){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,pkg,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
    final int N=mNotificationList.size();
    ArrayList<NotificationRecord> canceledNotifications=null;
    for (int i=N - 1; i >= 0; --i) {
      NotificationRecord r=mNotificationList.get(i);
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
      if (r.getUserId() == UserHandle.USER_ALL && pkg == null) {
        continue;
      }
      if ((r.getFlags() & mustHaveFlags) != mustHaveFlags) {
        continue;
      }
      if ((r.getFlags() & mustNotHaveFlags) != 0) {
        continue;
      }
      if (pkg != null && !r.sbn.getPackageName().equals(pkg)) {
        continue;
      }
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
      if (!doit) {
        return true;
      }
      mNotificationList.remove(i);
      cancelNotificationLocked(r,false,reason);
    }
    if (doit && canceledNotifications != null) {
      final int M=canceledNotifications.size();
      for (int i=0; i < M; i++) {
        cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED,false);
      }
    }
    if (canceledNotifications != null) {
      updateLightsLocked();
    }
    return canceledNotifications != null;
  }
}",0.9983507421660252
191254,"private void cancelGroupChildrenLocked(NotificationRecord r,int callingUid,int callingPid,String listenerName,int reason){
  Notification n=r.getNotification();
  if (!n.isGroupSummary()) {
    return;
  }
  String pkg=r.sbn.getPackageName();
  int userId=r.getUserId();
  if (pkg == null) {
    if (DBG)     Log.e(TAG,""String_Node_Str"" + r.getKey());
    return;
  }
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord childR=mNotificationList.get(i);
    StatusBarNotification childSbn=childR.sbn;
    if ((childSbn.isGroup() && !childSbn.getNotification().isGroupSummary()) && childR.getGroupKey().equals(r.getGroupKey())) {
      EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,childSbn.getId(),childSbn.getTag(),userId,0,0,reason,listenerName);
      mNotificationList.remove(i);
      cancelNotificationLocked(childR,false,reason);
    }
  }
}","private void cancelGroupChildrenLocked(NotificationRecord r,int callingUid,int callingPid,String listenerName,int reason,boolean sendDelete){
  Notification n=r.getNotification();
  if (!n.isGroupSummary()) {
    return;
  }
  String pkg=r.sbn.getPackageName();
  int userId=r.getUserId();
  if (pkg == null) {
    if (DBG)     Log.e(TAG,""String_Node_Str"" + r.getKey());
    return;
  }
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord childR=mNotificationList.get(i);
    StatusBarNotification childSbn=childR.sbn;
    if ((childSbn.isGroup() && !childSbn.getNotification().isGroupSummary()) && childR.getGroupKey().equals(r.getGroupKey())) {
      EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,childSbn.getId(),childSbn.getTag(),userId,0,0,reason,listenerName);
      mNotificationList.remove(i);
      cancelNotificationLocked(childR,sendDelete,reason);
    }
  }
}",0.982646420824295
191255,"/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelNotificationLocked(r,sendDelete,reason);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
          updateLightsLocked();
        }
      }
    }
  }
);
}","/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelNotificationLocked(r,sendDelete,reason);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED,sendDelete);
          updateLightsLocked();
        }
      }
    }
  }
);
}",0.996267390566678
191256,"/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  if (n.isGroupSummary() && !sbn.isAppGroup()) {
    n.flags&=~Notification.FLAG_GROUP_SUMMARY;
  }
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED);
  }
}","/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  if (n.isGroupSummary() && !sbn.isAppGroup()) {
    n.flags&=~Notification.FLAG_GROUP_SUMMARY;
  }
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED,false);
  }
}",0.9977081741787625
191257,"void cancelAllLocked(int callingUid,int callingPid,int userId,int reason,ManagedServiceInfo listener,boolean includeCurrentProfiles){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,null,userId,0,0,reason,listenerName);
  ArrayList<NotificationRecord> canceledNotifications=null;
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord r=mNotificationList.get(i);
    if (includeCurrentProfiles) {
      if (!notificationMatchesCurrentProfiles(r,userId)) {
        continue;
      }
    }
 else {
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
    }
    if ((r.getFlags() & (Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR)) == 0) {
      mNotificationList.remove(i);
      cancelNotificationLocked(r,true,reason);
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
    }
  }
  int M=canceledNotifications != null ? canceledNotifications.size() : 0;
  for (int i=0; i < M; i++) {
    cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
  }
  updateLightsLocked();
}","void cancelAllLocked(int callingUid,int callingPid,int userId,int reason,ManagedServiceInfo listener,boolean includeCurrentProfiles){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,null,userId,0,0,reason,listenerName);
  ArrayList<NotificationRecord> canceledNotifications=null;
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord r=mNotificationList.get(i);
    if (includeCurrentProfiles) {
      if (!notificationMatchesCurrentProfiles(r,userId)) {
        continue;
      }
    }
 else {
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
    }
    if ((r.getFlags() & (Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR)) == 0) {
      mNotificationList.remove(i);
      cancelNotificationLocked(r,true,reason);
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
    }
  }
  int M=canceledNotifications != null ? canceledNotifications.size() : 0;
  for (int i=0; i < M; i++) {
    cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED,false);
  }
  updateLightsLocked();
}",0.9977046671767408
191258,"/** 
 * Cancels all notifications from a given package that have all of the  {@code mustHaveFlags}.
 */
boolean cancelAllNotificationsInt(int callingUid,int callingPid,String pkg,int mustHaveFlags,int mustNotHaveFlags,boolean doit,int userId,int reason,ManagedServiceInfo listener){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,pkg,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
    final int N=mNotificationList.size();
    ArrayList<NotificationRecord> canceledNotifications=null;
    for (int i=N - 1; i >= 0; --i) {
      NotificationRecord r=mNotificationList.get(i);
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
      if (r.getUserId() == UserHandle.USER_ALL && pkg == null) {
        continue;
      }
      if ((r.getFlags() & mustHaveFlags) != mustHaveFlags) {
        continue;
      }
      if ((r.getFlags() & mustNotHaveFlags) != 0) {
        continue;
      }
      if (pkg != null && !r.sbn.getPackageName().equals(pkg)) {
        continue;
      }
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
      if (!doit) {
        return true;
      }
      mNotificationList.remove(i);
      cancelNotificationLocked(r,false,reason);
    }
    if (doit && canceledNotifications != null) {
      final int M=canceledNotifications.size();
      for (int i=0; i < M; i++) {
        cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
      }
    }
    if (canceledNotifications != null) {
      updateLightsLocked();
    }
    return canceledNotifications != null;
  }
}","/** 
 * Cancels all notifications from a given package that have all of the  {@code mustHaveFlags}.
 */
boolean cancelAllNotificationsInt(int callingUid,int callingPid,String pkg,int mustHaveFlags,int mustNotHaveFlags,boolean doit,int userId,int reason,ManagedServiceInfo listener){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,pkg,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
    final int N=mNotificationList.size();
    ArrayList<NotificationRecord> canceledNotifications=null;
    for (int i=N - 1; i >= 0; --i) {
      NotificationRecord r=mNotificationList.get(i);
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
      if (r.getUserId() == UserHandle.USER_ALL && pkg == null) {
        continue;
      }
      if ((r.getFlags() & mustHaveFlags) != mustHaveFlags) {
        continue;
      }
      if ((r.getFlags() & mustNotHaveFlags) != 0) {
        continue;
      }
      if (pkg != null && !r.sbn.getPackageName().equals(pkg)) {
        continue;
      }
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
      if (!doit) {
        return true;
      }
      mNotificationList.remove(i);
      cancelNotificationLocked(r,false,reason);
    }
    if (doit && canceledNotifications != null) {
      final int M=canceledNotifications.size();
      for (int i=0; i < M; i++) {
        cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED,false);
      }
    }
    if (canceledNotifications != null) {
      updateLightsLocked();
    }
    return canceledNotifications != null;
  }
}",0.9983507421660252
191259,"private void cancelGroupChildrenLocked(NotificationRecord r,int callingUid,int callingPid,String listenerName,int reason){
  Notification n=r.getNotification();
  if (!n.isGroupSummary()) {
    return;
  }
  String pkg=r.sbn.getPackageName();
  int userId=r.getUserId();
  if (pkg == null) {
    if (DBG)     Log.e(TAG,""String_Node_Str"" + r.getKey());
    return;
  }
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord childR=mNotificationList.get(i);
    StatusBarNotification childSbn=childR.sbn;
    if ((childSbn.isGroup() && !childSbn.getNotification().isGroupSummary()) && childR.getGroupKey().equals(r.getGroupKey())) {
      EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,childSbn.getId(),childSbn.getTag(),userId,0,0,reason,listenerName);
      mNotificationList.remove(i);
      cancelNotificationLocked(childR,false,reason);
    }
  }
}","private void cancelGroupChildrenLocked(NotificationRecord r,int callingUid,int callingPid,String listenerName,int reason,boolean sendDelete){
  Notification n=r.getNotification();
  if (!n.isGroupSummary()) {
    return;
  }
  String pkg=r.sbn.getPackageName();
  int userId=r.getUserId();
  if (pkg == null) {
    if (DBG)     Log.e(TAG,""String_Node_Str"" + r.getKey());
    return;
  }
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord childR=mNotificationList.get(i);
    StatusBarNotification childSbn=childR.sbn;
    if ((childSbn.isGroup() && !childSbn.getNotification().isGroupSummary()) && childR.getGroupKey().equals(r.getGroupKey())) {
      EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,childSbn.getId(),childSbn.getTag(),userId,0,0,reason,listenerName);
      mNotificationList.remove(i);
      cancelNotificationLocked(childR,sendDelete,reason);
    }
  }
}",0.982646420824295
191260,"/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelNotificationLocked(r,sendDelete,reason);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
          updateLightsLocked();
        }
      }
    }
  }
);
}","/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelNotificationLocked(r,sendDelete,reason);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED,sendDelete);
          updateLightsLocked();
        }
      }
    }
  }
);
}",0.996267390566678
191261,"/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  if (n.isGroupSummary() && !sbn.isAppGroup()) {
    n.flags&=~Notification.FLAG_GROUP_SUMMARY;
  }
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED);
  }
}","/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  if (n.isGroupSummary() && !sbn.isAppGroup()) {
    n.flags&=~Notification.FLAG_GROUP_SUMMARY;
  }
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED,false);
  }
}",0.9977081741787625
191262,"void cancelAllLocked(int callingUid,int callingPid,int userId,int reason,ManagedServiceInfo listener,boolean includeCurrentProfiles){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,null,userId,0,0,reason,listenerName);
  ArrayList<NotificationRecord> canceledNotifications=null;
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord r=mNotificationList.get(i);
    if (includeCurrentProfiles) {
      if (!notificationMatchesCurrentProfiles(r,userId)) {
        continue;
      }
    }
 else {
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
    }
    if ((r.getFlags() & (Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR)) == 0) {
      mNotificationList.remove(i);
      cancelNotificationLocked(r,true,reason);
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
    }
  }
  int M=canceledNotifications != null ? canceledNotifications.size() : 0;
  for (int i=0; i < M; i++) {
    cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
  }
  updateLightsLocked();
}","void cancelAllLocked(int callingUid,int callingPid,int userId,int reason,ManagedServiceInfo listener,boolean includeCurrentProfiles){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,null,userId,0,0,reason,listenerName);
  ArrayList<NotificationRecord> canceledNotifications=null;
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord r=mNotificationList.get(i);
    if (includeCurrentProfiles) {
      if (!notificationMatchesCurrentProfiles(r,userId)) {
        continue;
      }
    }
 else {
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
    }
    if ((r.getFlags() & (Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR)) == 0) {
      mNotificationList.remove(i);
      cancelNotificationLocked(r,true,reason);
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
    }
  }
  int M=canceledNotifications != null ? canceledNotifications.size() : 0;
  for (int i=0; i < M; i++) {
    cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED,false);
  }
  updateLightsLocked();
}",0.9977046671767408
191263,"/** 
 * Cancels all notifications from a given package that have all of the  {@code mustHaveFlags}.
 */
boolean cancelAllNotificationsInt(int callingUid,int callingPid,String pkg,int mustHaveFlags,int mustNotHaveFlags,boolean doit,int userId,int reason,ManagedServiceInfo listener){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,pkg,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
    final int N=mNotificationList.size();
    ArrayList<NotificationRecord> canceledNotifications=null;
    for (int i=N - 1; i >= 0; --i) {
      NotificationRecord r=mNotificationList.get(i);
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
      if (r.getUserId() == UserHandle.USER_ALL && pkg == null) {
        continue;
      }
      if ((r.getFlags() & mustHaveFlags) != mustHaveFlags) {
        continue;
      }
      if ((r.getFlags() & mustNotHaveFlags) != 0) {
        continue;
      }
      if (pkg != null && !r.sbn.getPackageName().equals(pkg)) {
        continue;
      }
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
      if (!doit) {
        return true;
      }
      mNotificationList.remove(i);
      cancelNotificationLocked(r,false,reason);
    }
    if (doit && canceledNotifications != null) {
      final int M=canceledNotifications.size();
      for (int i=0; i < M; i++) {
        cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
      }
    }
    if (canceledNotifications != null) {
      updateLightsLocked();
    }
    return canceledNotifications != null;
  }
}","/** 
 * Cancels all notifications from a given package that have all of the  {@code mustHaveFlags}.
 */
boolean cancelAllNotificationsInt(int callingUid,int callingPid,String pkg,int mustHaveFlags,int mustNotHaveFlags,boolean doit,int userId,int reason,ManagedServiceInfo listener){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,pkg,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
    final int N=mNotificationList.size();
    ArrayList<NotificationRecord> canceledNotifications=null;
    for (int i=N - 1; i >= 0; --i) {
      NotificationRecord r=mNotificationList.get(i);
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
      if (r.getUserId() == UserHandle.USER_ALL && pkg == null) {
        continue;
      }
      if ((r.getFlags() & mustHaveFlags) != mustHaveFlags) {
        continue;
      }
      if ((r.getFlags() & mustNotHaveFlags) != 0) {
        continue;
      }
      if (pkg != null && !r.sbn.getPackageName().equals(pkg)) {
        continue;
      }
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
      if (!doit) {
        return true;
      }
      mNotificationList.remove(i);
      cancelNotificationLocked(r,false,reason);
    }
    if (doit && canceledNotifications != null) {
      final int M=canceledNotifications.size();
      for (int i=0; i < M; i++) {
        cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED,false);
      }
    }
    if (canceledNotifications != null) {
      updateLightsLocked();
    }
    return canceledNotifications != null;
  }
}",0.9983507421660252
191264,"private void cancelGroupChildrenLocked(NotificationRecord r,int callingUid,int callingPid,String listenerName,int reason){
  Notification n=r.getNotification();
  if (!n.isGroupSummary()) {
    return;
  }
  String pkg=r.sbn.getPackageName();
  int userId=r.getUserId();
  if (pkg == null) {
    if (DBG)     Log.e(TAG,""String_Node_Str"" + r.getKey());
    return;
  }
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord childR=mNotificationList.get(i);
    StatusBarNotification childSbn=childR.sbn;
    if ((childSbn.isGroup() && !childSbn.getNotification().isGroupSummary()) && childR.getGroupKey().equals(r.getGroupKey())) {
      EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,childSbn.getId(),childSbn.getTag(),userId,0,0,reason,listenerName);
      mNotificationList.remove(i);
      cancelNotificationLocked(childR,false,reason);
    }
  }
}","private void cancelGroupChildrenLocked(NotificationRecord r,int callingUid,int callingPid,String listenerName,int reason,boolean sendDelete){
  Notification n=r.getNotification();
  if (!n.isGroupSummary()) {
    return;
  }
  String pkg=r.sbn.getPackageName();
  int userId=r.getUserId();
  if (pkg == null) {
    if (DBG)     Log.e(TAG,""String_Node_Str"" + r.getKey());
    return;
  }
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord childR=mNotificationList.get(i);
    StatusBarNotification childSbn=childR.sbn;
    if ((childSbn.isGroup() && !childSbn.getNotification().isGroupSummary()) && childR.getGroupKey().equals(r.getGroupKey())) {
      EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,childSbn.getId(),childSbn.getTag(),userId,0,0,reason,listenerName);
      mNotificationList.remove(i);
      cancelNotificationLocked(childR,sendDelete,reason);
    }
  }
}",0.982646420824295
191265,"/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelNotificationLocked(r,sendDelete,reason);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
          updateLightsLocked();
        }
      }
    }
  }
);
}","/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelNotificationLocked(r,sendDelete,reason);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED,sendDelete);
          updateLightsLocked();
        }
      }
    }
  }
);
}",0.996267390566678
191266,"/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  if (n.isGroupSummary() && !sbn.isAppGroup()) {
    n.flags&=~Notification.FLAG_GROUP_SUMMARY;
  }
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED);
  }
}","/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  if (n.isGroupSummary() && !sbn.isAppGroup()) {
    n.flags&=~Notification.FLAG_GROUP_SUMMARY;
  }
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED,false);
  }
}",0.9977081741787625
191267,"void cancelAllLocked(int callingUid,int callingPid,int userId,int reason,ManagedServiceInfo listener,boolean includeCurrentProfiles){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,null,userId,0,0,reason,listenerName);
  ArrayList<NotificationRecord> canceledNotifications=null;
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord r=mNotificationList.get(i);
    if (includeCurrentProfiles) {
      if (!notificationMatchesCurrentProfiles(r,userId)) {
        continue;
      }
    }
 else {
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
    }
    if ((r.getFlags() & (Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR)) == 0) {
      mNotificationList.remove(i);
      cancelNotificationLocked(r,true,reason);
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
    }
  }
  int M=canceledNotifications != null ? canceledNotifications.size() : 0;
  for (int i=0; i < M; i++) {
    cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
  }
  updateLightsLocked();
}","void cancelAllLocked(int callingUid,int callingPid,int userId,int reason,ManagedServiceInfo listener,boolean includeCurrentProfiles){
  String listenerName=listener == null ? null : listener.component.toShortString();
  EventLogTags.writeNotificationCancelAll(callingUid,callingPid,null,userId,0,0,reason,listenerName);
  ArrayList<NotificationRecord> canceledNotifications=null;
  final int N=mNotificationList.size();
  for (int i=N - 1; i >= 0; i--) {
    NotificationRecord r=mNotificationList.get(i);
    if (includeCurrentProfiles) {
      if (!notificationMatchesCurrentProfiles(r,userId)) {
        continue;
      }
    }
 else {
      if (!notificationMatchesUserId(r,userId)) {
        continue;
      }
    }
    if ((r.getFlags() & (Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR)) == 0) {
      mNotificationList.remove(i);
      cancelNotificationLocked(r,true,reason);
      if (canceledNotifications == null) {
        canceledNotifications=new ArrayList<>();
      }
      canceledNotifications.add(r);
    }
  }
  int M=canceledNotifications != null ? canceledNotifications.size() : 0;
  for (int i=0; i < M; i++) {
    cancelGroupChildrenLocked(canceledNotifications.get(i),callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED,false);
  }
  updateLightsLocked();
}",0.9977046671767408
191268,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageUninstalledLocked(ssp);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_PACKAGE_DATA_CLEARED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageDataClearedLocked(ssp);
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageUninstalledLocked(ssp);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_PACKAGE_DATA_CLEARED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageDataClearedLocked(ssp);
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
if (resultTo != null) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
try {
queue.performReceiveLocked(callerApp,resultTo,intent,Activity.RESULT_CANCELED,null,null,false,false,userId);
}
 catch (RemoteException e) {
Slog.w(TAG,""String_Node_Str"" + queue.mQueueName + ""String_Node_Str""+ intent,e);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.990581318615394
191269,"private void performReceiveLocked(ProcessRecord app,IIntentReceiver receiver,Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser) throws RemoteException {
  if (app != null) {
    if (app.thread != null) {
      try {
        app.thread.scheduleRegisteredReceiver(receiver,intent,resultCode,data,extras,ordered,sticky,sendingUser,app.repProcState);
      }
 catch (      RemoteException ex) {
synchronized (mService) {
          Slog.w(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
          app.scheduleCrash(""String_Node_Str"");
        }
        throw ex;
      }
    }
 else {
      throw new RemoteException(""String_Node_Str"");
    }
  }
 else {
    receiver.performReceive(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  }
}","void performReceiveLocked(ProcessRecord app,IIntentReceiver receiver,Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser) throws RemoteException {
  if (app != null) {
    if (app.thread != null) {
      try {
        app.thread.scheduleRegisteredReceiver(receiver,intent,resultCode,data,extras,ordered,sticky,sendingUser,app.repProcState);
      }
 catch (      RemoteException ex) {
synchronized (mService) {
          Slog.w(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
          app.scheduleCrash(""String_Node_Str"");
        }
        throw ex;
      }
    }
 else {
      throw new RemoteException(""String_Node_Str"");
    }
  }
 else {
    receiver.performReceive(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  }
}",0.9951923076923076
191270,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
if (resultTo != null) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
try {
queue.performReceiveLocked(callerApp,resultTo,intent,Activity.RESULT_CANCELED,null,null,false,false,userId);
}
 catch (RemoteException e) {
Slog.w(TAG,""String_Node_Str"" + queue.mQueueName + ""String_Node_Str""+ intent,e);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.9902021967049426
191271,"private void performReceiveLocked(ProcessRecord app,IIntentReceiver receiver,Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser) throws RemoteException {
  if (app != null) {
    if (app.thread != null) {
      try {
        app.thread.scheduleRegisteredReceiver(receiver,intent,resultCode,data,extras,ordered,sticky,sendingUser,app.repProcState);
      }
 catch (      RemoteException ex) {
synchronized (mService) {
          Slog.w(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
          app.scheduleCrash(""String_Node_Str"");
        }
        throw ex;
      }
    }
 else {
      throw new RemoteException(""String_Node_Str"");
    }
  }
 else {
    receiver.performReceive(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  }
}","void performReceiveLocked(ProcessRecord app,IIntentReceiver receiver,Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser) throws RemoteException {
  if (app != null) {
    if (app.thread != null) {
      try {
        app.thread.scheduleRegisteredReceiver(receiver,intent,resultCode,data,extras,ordered,sticky,sendingUser,app.repProcState);
      }
 catch (      RemoteException ex) {
synchronized (mService) {
          Slog.w(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
          app.scheduleCrash(""String_Node_Str"");
        }
        throw ex;
      }
    }
 else {
      throw new RemoteException(""String_Node_Str"");
    }
  }
 else {
    receiver.performReceive(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  }
}",0.9951923076923076
191272,"/** 
 * Defer the specified SyncOperation by rescheduling it on the JobScheduler with some delay. This is equivalent to a failure. If this is a periodic sync, a delayed one-off sync will be scheduled.
 */
private void deferSyncH(SyncOperation op,long delay){
  mSyncJobService.callJobFinished(op.jobId,false);
  if (op.isPeriodic) {
    scheduleSyncOperationH(op.createOneTimeSyncOperation(),delay);
  }
 else {
    scheduleSyncOperationH(op,delay);
  }
}","/** 
 * Defer the specified SyncOperation by rescheduling it on the JobScheduler with some delay. This is equivalent to a failure. If this is a periodic sync, a delayed one-off sync will be scheduled.
 */
private void deferSyncH(SyncOperation op,long delay){
  mSyncJobService.callJobFinished(op.jobId,false);
  if (op.isPeriodic) {
    scheduleSyncOperationH(op.createOneTimeSyncOperation(),delay);
  }
 else {
    getJobScheduler().cancel(op.jobId);
    scheduleSyncOperationH(op,delay);
  }
}",0.9578947368421052
191273,"private void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  final boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false) && !syncResult.syncAlreadyInProgress) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.tooManyRetries) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000);
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}","private void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  final boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false) && !syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false) && !syncResult.syncAlreadyInProgress) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.tooManyRetries) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000);
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}",0.9888587774766636
191274,"private void runSyncFinishedOrCanceledH(SyncResult syncResult,ActiveSyncContext activeSyncContext){
  final boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
  final SyncOperation syncOperation=activeSyncContext.mSyncOperation;
  final SyncStorageEngine.EndPoint info=syncOperation.target;
  if (activeSyncContext.mIsLinkedToDeath) {
    activeSyncContext.mSyncAdapter.asBinder().unlinkToDeath(activeSyncContext,0);
    activeSyncContext.mIsLinkedToDeath=false;
  }
  closeActiveSyncContext(activeSyncContext);
  final long elapsedTime=SystemClock.elapsedRealtime() - activeSyncContext.mStartTime;
  String historyMessage;
  int downstreamActivity;
  int upstreamActivity;
  if (syncResult != null) {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
    }
    if (!syncResult.hasError()) {
      historyMessage=SyncStorageEngine.MESG_SUCCESS;
      downstreamActivity=0;
      upstreamActivity=0;
      clearBackoffSetting(syncOperation.target);
      if (syncOperation.isDerivedFromFailedPeriodicSync()) {
        reschedulePeriodicSyncH(syncOperation);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
      increaseBackoffSetting(syncOperation.target);
      if (!syncOperation.isPeriodic) {
        maybeRescheduleSync(syncResult,syncOperation);
      }
 else {
        postScheduleSyncMessage(syncOperation.createOneTimeSyncOperation());
      }
      historyMessage=ContentResolver.syncErrorToString(syncResultToErrorNumber(syncResult));
      downstreamActivity=0;
      upstreamActivity=0;
    }
    setDelayUntilTime(syncOperation.target,syncResult.delayUntil);
  }
 else {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation);
    }
    if (activeSyncContext.mSyncAdapter != null) {
      try {
        activeSyncContext.mSyncAdapter.cancelSync(activeSyncContext);
      }
 catch (      RemoteException e) {
      }
    }
    historyMessage=SyncStorageEngine.MESG_CANCELED;
    downstreamActivity=0;
    upstreamActivity=0;
  }
  stopSyncEvent(activeSyncContext.mHistoryRowId,syncOperation,historyMessage,upstreamActivity,downstreamActivity,elapsedTime);
  if (syncResult != null && syncResult.tooManyDeletions) {
    installHandleTooManyDeletesNotification(info.account,info.provider,syncResult.stats.numDeletes,info.userId);
  }
 else {
    mNotificationMgr.cancelAsUser(null,info.account.hashCode() ^ info.provider.hashCode(),new UserHandle(info.userId));
  }
  if (syncResult != null && syncResult.fullSyncRequested) {
    scheduleSyncOperationH(new SyncOperation(info.account,info.userId,syncOperation.owningUid,syncOperation.owningPackage,syncOperation.reason,syncOperation.syncSource,info.provider,new Bundle(),syncOperation.allowParallelSyncs));
  }
}","private void runSyncFinishedOrCanceledH(SyncResult syncResult,ActiveSyncContext activeSyncContext){
  final boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
  final SyncOperation syncOperation=activeSyncContext.mSyncOperation;
  final SyncStorageEngine.EndPoint info=syncOperation.target;
  if (activeSyncContext.mIsLinkedToDeath) {
    activeSyncContext.mSyncAdapter.asBinder().unlinkToDeath(activeSyncContext,0);
    activeSyncContext.mIsLinkedToDeath=false;
  }
  closeActiveSyncContext(activeSyncContext);
  final long elapsedTime=SystemClock.elapsedRealtime() - activeSyncContext.mStartTime;
  String historyMessage;
  int downstreamActivity;
  int upstreamActivity;
  if (!syncOperation.isPeriodic) {
    getJobScheduler().cancel(syncOperation.jobId);
  }
  if (syncResult != null) {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
    }
    if (!syncResult.hasError()) {
      historyMessage=SyncStorageEngine.MESG_SUCCESS;
      downstreamActivity=0;
      upstreamActivity=0;
      clearBackoffSetting(syncOperation.target);
      if (syncOperation.isDerivedFromFailedPeriodicSync()) {
        reschedulePeriodicSyncH(syncOperation);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
      increaseBackoffSetting(syncOperation.target);
      if (!syncOperation.isPeriodic) {
        maybeRescheduleSync(syncResult,syncOperation);
      }
 else {
        postScheduleSyncMessage(syncOperation.createOneTimeSyncOperation());
      }
      historyMessage=ContentResolver.syncErrorToString(syncResultToErrorNumber(syncResult));
      downstreamActivity=0;
      upstreamActivity=0;
    }
    setDelayUntilTime(syncOperation.target,syncResult.delayUntil);
  }
 else {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation);
    }
    if (activeSyncContext.mSyncAdapter != null) {
      try {
        activeSyncContext.mSyncAdapter.cancelSync(activeSyncContext);
      }
 catch (      RemoteException e) {
      }
    }
    historyMessage=SyncStorageEngine.MESG_CANCELED;
    downstreamActivity=0;
    upstreamActivity=0;
  }
  stopSyncEvent(activeSyncContext.mHistoryRowId,syncOperation,historyMessage,upstreamActivity,downstreamActivity,elapsedTime);
  if (syncResult != null && syncResult.tooManyDeletions) {
    installHandleTooManyDeletesNotification(info.account,info.provider,syncResult.stats.numDeletes,info.userId);
  }
 else {
    mNotificationMgr.cancelAsUser(null,info.account.hashCode() ^ info.provider.hashCode(),new UserHandle(info.userId));
  }
  if (syncResult != null && syncResult.fullSyncRequested) {
    scheduleSyncOperationH(new SyncOperation(info.account,info.userId,syncOperation.owningUid,syncOperation.owningPackage,syncOperation.reason,syncOperation.syncSource,info.provider,new Bundle(),syncOperation.allowParallelSyncs));
  }
}",0.9842215988779804
191275,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageUninstalledLocked(ssp);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_PACKAGE_DATA_CLEARED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageDataClearedLocked(ssp);
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageUninstalledLocked(ssp);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
if (aInfo == null) {
Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ssp + ""String_Node_Str""+ data);
return ActivityManager.BROADCAST_SUCCESS;
}
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_PACKAGE_DATA_CLEARED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
mUnsupportedDisplaySizeDialog.dismiss();
mUnsupportedDisplaySizeDialog=null;
}
mCompatModePackages.handlePackageDataClearedLocked(ssp);
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
if (resultTo != null) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
try {
queue.performReceiveLocked(callerApp,resultTo,intent,Activity.RESULT_CANCELED,null,null,false,false,userId);
}
 catch (RemoteException e) {
Slog.w(TAG,""String_Node_Str"" + queue.mQueueName + ""String_Node_Str""+ intent,e);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.990581318615394
191276,"private void performReceiveLocked(ProcessRecord app,IIntentReceiver receiver,Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser) throws RemoteException {
  if (app != null) {
    if (app.thread != null) {
      try {
        app.thread.scheduleRegisteredReceiver(receiver,intent,resultCode,data,extras,ordered,sticky,sendingUser,app.repProcState);
      }
 catch (      RemoteException ex) {
synchronized (mService) {
          Slog.w(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
          app.scheduleCrash(""String_Node_Str"");
        }
        throw ex;
      }
    }
 else {
      throw new RemoteException(""String_Node_Str"");
    }
  }
 else {
    receiver.performReceive(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  }
}","void performReceiveLocked(ProcessRecord app,IIntentReceiver receiver,Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser) throws RemoteException {
  if (app != null) {
    if (app.thread != null) {
      try {
        app.thread.scheduleRegisteredReceiver(receiver,intent,resultCode,data,extras,ordered,sticky,sendingUser,app.repProcState);
      }
 catch (      RemoteException ex) {
synchronized (mService) {
          Slog.w(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
          app.scheduleCrash(""String_Node_Str"");
        }
        throw ex;
      }
    }
 else {
      throw new RemoteException(""String_Node_Str"");
    }
  }
 else {
    receiver.performReceive(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  }
}",0.9951923076923076
191277,"public void setRemoved(){
  mRemoved=true;
  mPrivateLayout.setRemoved();
  if (mChildrenContainer != null) {
    mChildrenContainer.setRemoved();
  }
}","public void setRemoved(){
  mRemoved=true;
  mPrivateLayout.setRemoved();
}",0.6607929515418502
191278,"/** 
 * Defer the specified SyncOperation by rescheduling it on the JobScheduler with some delay. This is equivalent to a failure. If this is a periodic sync, a delayed one-off sync will be scheduled.
 */
private void deferSyncH(SyncOperation op,long delay){
  mSyncJobService.callJobFinished(op.jobId,false);
  if (op.isPeriodic) {
    scheduleSyncOperationH(op.createOneTimeSyncOperation(),delay);
  }
 else {
    scheduleSyncOperationH(op,delay);
  }
}","/** 
 * Defer the specified SyncOperation by rescheduling it on the JobScheduler with some delay. This is equivalent to a failure. If this is a periodic sync, a delayed one-off sync will be scheduled.
 */
private void deferSyncH(SyncOperation op,long delay){
  mSyncJobService.callJobFinished(op.jobId,false);
  if (op.isPeriodic) {
    scheduleSyncOperationH(op.createOneTimeSyncOperation(),delay);
  }
 else {
    getJobScheduler().cancel(op.jobId);
    scheduleSyncOperationH(op,delay);
  }
}",0.9578947368421052
191279,"private void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  final boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false) && !syncResult.syncAlreadyInProgress) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.tooManyRetries) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000);
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}","private void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  final boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false) && !syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false) && !syncResult.syncAlreadyInProgress) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.tooManyRetries) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000);
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}",0.9888587774766636
191280,"private void runSyncFinishedOrCanceledH(SyncResult syncResult,ActiveSyncContext activeSyncContext){
  final boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
  final SyncOperation syncOperation=activeSyncContext.mSyncOperation;
  final SyncStorageEngine.EndPoint info=syncOperation.target;
  if (activeSyncContext.mIsLinkedToDeath) {
    activeSyncContext.mSyncAdapter.asBinder().unlinkToDeath(activeSyncContext,0);
    activeSyncContext.mIsLinkedToDeath=false;
  }
  closeActiveSyncContext(activeSyncContext);
  final long elapsedTime=SystemClock.elapsedRealtime() - activeSyncContext.mStartTime;
  String historyMessage;
  int downstreamActivity;
  int upstreamActivity;
  if (syncResult != null) {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
    }
    if (!syncResult.hasError()) {
      historyMessage=SyncStorageEngine.MESG_SUCCESS;
      downstreamActivity=0;
      upstreamActivity=0;
      clearBackoffSetting(syncOperation.target);
      if (syncOperation.isDerivedFromFailedPeriodicSync()) {
        reschedulePeriodicSyncH(syncOperation);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
      increaseBackoffSetting(syncOperation.target);
      if (!syncOperation.isPeriodic) {
        maybeRescheduleSync(syncResult,syncOperation);
      }
 else {
        postScheduleSyncMessage(syncOperation.createOneTimeSyncOperation());
      }
      historyMessage=ContentResolver.syncErrorToString(syncResultToErrorNumber(syncResult));
      downstreamActivity=0;
      upstreamActivity=0;
    }
    setDelayUntilTime(syncOperation.target,syncResult.delayUntil);
  }
 else {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation);
    }
    if (activeSyncContext.mSyncAdapter != null) {
      try {
        activeSyncContext.mSyncAdapter.cancelSync(activeSyncContext);
      }
 catch (      RemoteException e) {
      }
    }
    historyMessage=SyncStorageEngine.MESG_CANCELED;
    downstreamActivity=0;
    upstreamActivity=0;
  }
  stopSyncEvent(activeSyncContext.mHistoryRowId,syncOperation,historyMessage,upstreamActivity,downstreamActivity,elapsedTime);
  if (syncResult != null && syncResult.tooManyDeletions) {
    installHandleTooManyDeletesNotification(info.account,info.provider,syncResult.stats.numDeletes,info.userId);
  }
 else {
    mNotificationMgr.cancelAsUser(null,info.account.hashCode() ^ info.provider.hashCode(),new UserHandle(info.userId));
  }
  if (syncResult != null && syncResult.fullSyncRequested) {
    scheduleSyncOperationH(new SyncOperation(info.account,info.userId,syncOperation.owningUid,syncOperation.owningPackage,syncOperation.reason,syncOperation.syncSource,info.provider,new Bundle(),syncOperation.allowParallelSyncs));
  }
}","private void runSyncFinishedOrCanceledH(SyncResult syncResult,ActiveSyncContext activeSyncContext){
  final boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
  final SyncOperation syncOperation=activeSyncContext.mSyncOperation;
  final SyncStorageEngine.EndPoint info=syncOperation.target;
  if (activeSyncContext.mIsLinkedToDeath) {
    activeSyncContext.mSyncAdapter.asBinder().unlinkToDeath(activeSyncContext,0);
    activeSyncContext.mIsLinkedToDeath=false;
  }
  closeActiveSyncContext(activeSyncContext);
  final long elapsedTime=SystemClock.elapsedRealtime() - activeSyncContext.mStartTime;
  String historyMessage;
  int downstreamActivity;
  int upstreamActivity;
  if (!syncOperation.isPeriodic) {
    getJobScheduler().cancel(syncOperation.jobId);
  }
  if (syncResult != null) {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
    }
    if (!syncResult.hasError()) {
      historyMessage=SyncStorageEngine.MESG_SUCCESS;
      downstreamActivity=0;
      upstreamActivity=0;
      clearBackoffSetting(syncOperation.target);
      if (syncOperation.isDerivedFromFailedPeriodicSync()) {
        reschedulePeriodicSyncH(syncOperation);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
      increaseBackoffSetting(syncOperation.target);
      if (!syncOperation.isPeriodic) {
        maybeRescheduleSync(syncResult,syncOperation);
      }
 else {
        postScheduleSyncMessage(syncOperation.createOneTimeSyncOperation());
      }
      historyMessage=ContentResolver.syncErrorToString(syncResultToErrorNumber(syncResult));
      downstreamActivity=0;
      upstreamActivity=0;
    }
    setDelayUntilTime(syncOperation.target,syncResult.delayUntil);
  }
 else {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation);
    }
    if (activeSyncContext.mSyncAdapter != null) {
      try {
        activeSyncContext.mSyncAdapter.cancelSync(activeSyncContext);
      }
 catch (      RemoteException e) {
      }
    }
    historyMessage=SyncStorageEngine.MESG_CANCELED;
    downstreamActivity=0;
    upstreamActivity=0;
  }
  stopSyncEvent(activeSyncContext.mHistoryRowId,syncOperation,historyMessage,upstreamActivity,downstreamActivity,elapsedTime);
  if (syncResult != null && syncResult.tooManyDeletions) {
    installHandleTooManyDeletesNotification(info.account,info.provider,syncResult.stats.numDeletes,info.userId);
  }
 else {
    mNotificationMgr.cancelAsUser(null,info.account.hashCode() ^ info.provider.hashCode(),new UserHandle(info.userId));
  }
  if (syncResult != null && syncResult.fullSyncRequested) {
    scheduleSyncOperationH(new SyncOperation(info.account,info.userId,syncOperation.owningUid,syncOperation.owningPackage,syncOperation.reason,syncOperation.syncSource,info.provider,new Bundle(),syncOperation.allowParallelSyncs));
  }
}",0.9842215988779804
191281,"public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateClearability();
  mShowingPublicInitialized=true;
}","public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    if (mChildrenContainer != null) {
      mChildrenContainer.animate().cancel();
      mChildrenContainer.setAlpha(1f);
    }
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  NotificationContentView showingLayout=getShowingLayout();
  showingLayout.updateBackgroundColor(animated);
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateClearability();
  mShowingPublicInitialized=true;
}",0.9321314952279958
191282,"@Override public int getIntrinsicHeight(){
  if (isUserLocked()) {
    return getActualHeight();
  }
  if (mGuts != null && mGuts.areGutsExposed()) {
    return mGuts.getHeight();
  }
 else   if ((isChildInGroup() && !isGroupExpanded())) {
    return mPrivateLayout.getMinHeight();
  }
 else   if (mSensitive && mHideSensitiveForIntrinsicHeight) {
    return getMinHeight();
  }
 else   if (mIsSummaryWithChildren && !mOnKeyguard) {
    return mChildrenContainer.getIntrinsicHeight();
  }
 else   if (mIsHeadsUp) {
    if (isPinned()) {
      return getPinnedHeadsUpHeight(true);
    }
 else     if (isExpanded()) {
      return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
    }
 else {
      return Math.max(getCollapsedHeight(),mHeadsUpHeight);
    }
  }
 else   if (isExpanded()) {
    return getMaxExpandHeight();
  }
 else {
    return getCollapsedHeight();
  }
}","@Override public int getIntrinsicHeight(){
  if (isUserLocked()) {
    return getActualHeight();
  }
  if (mGuts != null && mGuts.areGutsExposed()) {
    return mGuts.getHeight();
  }
 else   if ((isChildInGroup() && !isGroupExpanded())) {
    return mPrivateLayout.getMinHeight();
  }
 else   if (mSensitive && mHideSensitiveForIntrinsicHeight) {
    return getMinHeight();
  }
 else   if (mIsSummaryWithChildren && !mOnKeyguard) {
    return mChildrenContainer.getIntrinsicHeight();
  }
 else   if (mIsHeadsUp || mHeadsupDisappearRunning) {
    if (isPinned() || mHeadsupDisappearRunning) {
      return getPinnedHeadsUpHeight(true);
    }
 else     if (isExpanded()) {
      return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
    }
 else {
      return Math.max(getCollapsedHeight(),mHeadsUpHeight);
    }
  }
 else   if (isExpanded()) {
    return getMaxExpandHeight();
  }
 else {
    return getCollapsedHeight();
  }
}",0.9688542825361512
191283,"private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if (mIsHeadsUp && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || isGroupExpanded() || !mContainingNotification.isExpanded(true)))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}","private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if ((mIsHeadsUp || mHeadsupDisappearRunning) && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || isGroupExpanded() || !mContainingNotification.isExpanded(true)))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}",0.981549815498155
191284,"/** 
 * @return the minimum apparent height that the wrapper should allow for the purposeof aligning elements at the bottom edge. If this is larger than the content height, the notification is clipped instead of being further shrunk.
 */
private int getMinContentHeightHint(){
  if (mIsChildInGroup && isVisibleOrTransitioning(VISIBLE_TYPE_SINGLELINE)) {
    return mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mHeadsUpChild != null && mExpandedChild != null) {
    boolean transitioningBetweenHunAndExpanded=isTransitioningFromTo(VISIBLE_TYPE_HEADSUP,VISIBLE_TYPE_EXPANDED) || isTransitioningFromTo(VISIBLE_TYPE_EXPANDED,VISIBLE_TYPE_HEADSUP);
    boolean pinned=!isVisibleOrTransitioning(VISIBLE_TYPE_CONTRACTED) && mIsHeadsUp;
    if (transitioningBetweenHunAndExpanded || pinned) {
      return Math.min(mHeadsUpChild.getHeight(),mExpandedChild.getHeight());
    }
  }
  if ((mVisibleType == VISIBLE_TYPE_EXPANDED) && mContentHeightAtAnimationStart >= 0 && mExpandedChild != null) {
    return Math.min(mContentHeightAtAnimationStart,mExpandedChild.getHeight());
  }
  int hint;
  if (mHeadsUpChild != null && isVisibleOrTransitioning(VISIBLE_TYPE_HEADSUP)) {
    hint=mHeadsUpChild.getHeight();
  }
 else   if (mExpandedChild != null) {
    hint=mExpandedChild.getHeight();
  }
 else {
    hint=mContractedChild.getHeight() + mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mExpandedChild != null && isVisibleOrTransitioning(VISIBLE_TYPE_EXPANDED)) {
    hint=Math.min(hint,mExpandedChild.getHeight());
  }
  return hint;
}","/** 
 * @return the minimum apparent height that the wrapper should allow for the purposeof aligning elements at the bottom edge. If this is larger than the content height, the notification is clipped instead of being further shrunk.
 */
private int getMinContentHeightHint(){
  if (mIsChildInGroup && isVisibleOrTransitioning(VISIBLE_TYPE_SINGLELINE)) {
    return mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mHeadsUpChild != null && mExpandedChild != null) {
    boolean transitioningBetweenHunAndExpanded=isTransitioningFromTo(VISIBLE_TYPE_HEADSUP,VISIBLE_TYPE_EXPANDED) || isTransitioningFromTo(VISIBLE_TYPE_EXPANDED,VISIBLE_TYPE_HEADSUP);
    boolean pinned=!isVisibleOrTransitioning(VISIBLE_TYPE_CONTRACTED) && (mIsHeadsUp || mHeadsupDisappearRunning);
    if (transitioningBetweenHunAndExpanded || pinned) {
      return Math.min(mHeadsUpChild.getHeight(),mExpandedChild.getHeight());
    }
  }
  if ((mVisibleType == VISIBLE_TYPE_EXPANDED) && mContentHeightAtAnimationStart >= 0 && mExpandedChild != null) {
    return Math.min(mContentHeightAtAnimationStart,mExpandedChild.getHeight());
  }
  int hint;
  if (mHeadsUpChild != null && isVisibleOrTransitioning(VISIBLE_TYPE_HEADSUP)) {
    hint=mHeadsUpChild.getHeight();
  }
 else   if (mExpandedChild != null) {
    hint=mExpandedChild.getHeight();
  }
 else {
    hint=mContractedChild.getHeight() + mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mExpandedChild != null && isVisibleOrTransitioning(VISIBLE_TYPE_EXPANDED)) {
    hint=Math.min(hint,mExpandedChild.getHeight());
  }
  return hint;
}",0.9911137440758294
191285,"public void generateHeadsUpAnimation(ExpandableNotificationRow row,boolean isHeadsUp){
  if (mAnimationsEnabled) {
    mHeadsUpChangeAnimations.add(new Pair<>(row,isHeadsUp));
    mNeedsAnimation=true;
    requestChildrenUpdate();
  }
}","public void generateHeadsUpAnimation(ExpandableNotificationRow row,boolean isHeadsUp){
  if (mAnimationsEnabled) {
    mHeadsUpChangeAnimations.add(new Pair<>(row,isHeadsUp));
    mNeedsAnimation=true;
    if (!mIsExpanded && !isHeadsUp) {
      row.setHeadsupDisappearRunning(true);
    }
    requestChildrenUpdate();
  }
}",0.8428571428571429
191286,"private void startYTranslationAnimation(final View child,ViewState viewState,long duration,long delay){
  Float previousStartValue=getChildTag(child,TAG_START_TRANSLATION_Y);
  Float previousEndValue=getChildTag(child,TAG_END_TRANSLATION_Y);
  float newEndValue=viewState.yTranslation;
  if (previousEndValue != null && previousEndValue == newEndValue) {
    return;
  }
  ObjectAnimator previousAnimator=getChildTag(child,TAG_ANIMATOR_TRANSLATION_Y);
  if (!mAnimationFilter.animateY) {
    if (previousAnimator != null) {
      PropertyValuesHolder[] values=previousAnimator.getValues();
      float relativeDiff=newEndValue - previousEndValue;
      float newStartValue=previousStartValue + relativeDiff;
      values[0].setFloatValues(newStartValue,newEndValue);
      child.setTag(TAG_START_TRANSLATION_Y,newStartValue);
      child.setTag(TAG_END_TRANSLATION_Y,newEndValue);
      previousAnimator.setCurrentPlayTime(previousAnimator.getCurrentPlayTime());
      return;
    }
 else {
      child.setTranslationY(newEndValue);
      return;
    }
  }
  ObjectAnimator animator=ObjectAnimator.ofFloat(child,View.TRANSLATION_Y,child.getTranslationY(),newEndValue);
  Interpolator interpolator=mHeadsUpAppearChildren.contains(child) ? mHeadsUpAppearInterpolator : Interpolators.FAST_OUT_SLOW_IN;
  animator.setInterpolator(interpolator);
  long newDuration=cancelAnimatorAndGetNewDuration(duration,previousAnimator);
  animator.setDuration(newDuration);
  if (delay > 0 && (previousAnimator == null || !previousAnimator.isRunning())) {
    animator.setStartDelay(delay);
  }
  animator.addListener(getGlobalAnimationFinishedListener());
  animator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      HeadsUpManager.setIsClickedNotification(child,false);
      child.setTag(TAG_ANIMATOR_TRANSLATION_Y,null);
      child.setTag(TAG_START_TRANSLATION_Y,null);
      child.setTag(TAG_END_TRANSLATION_Y,null);
    }
  }
);
  startAnimator(animator);
  child.setTag(TAG_ANIMATOR_TRANSLATION_Y,animator);
  child.setTag(TAG_START_TRANSLATION_Y,child.getTranslationY());
  child.setTag(TAG_END_TRANSLATION_Y,newEndValue);
}","private void startYTranslationAnimation(final View child,ViewState viewState,long duration,long delay){
  Float previousStartValue=getChildTag(child,TAG_START_TRANSLATION_Y);
  Float previousEndValue=getChildTag(child,TAG_END_TRANSLATION_Y);
  float newEndValue=viewState.yTranslation;
  if (previousEndValue != null && previousEndValue == newEndValue) {
    return;
  }
  ObjectAnimator previousAnimator=getChildTag(child,TAG_ANIMATOR_TRANSLATION_Y);
  if (!mAnimationFilter.animateY) {
    if (previousAnimator != null) {
      PropertyValuesHolder[] values=previousAnimator.getValues();
      float relativeDiff=newEndValue - previousEndValue;
      float newStartValue=previousStartValue + relativeDiff;
      values[0].setFloatValues(newStartValue,newEndValue);
      child.setTag(TAG_START_TRANSLATION_Y,newStartValue);
      child.setTag(TAG_END_TRANSLATION_Y,newEndValue);
      previousAnimator.setCurrentPlayTime(previousAnimator.getCurrentPlayTime());
      return;
    }
 else {
      child.setTranslationY(newEndValue);
      return;
    }
  }
  ObjectAnimator animator=ObjectAnimator.ofFloat(child,View.TRANSLATION_Y,child.getTranslationY(),newEndValue);
  Interpolator interpolator=mHeadsUpAppearChildren.contains(child) ? mHeadsUpAppearInterpolator : Interpolators.FAST_OUT_SLOW_IN;
  animator.setInterpolator(interpolator);
  long newDuration=cancelAnimatorAndGetNewDuration(duration,previousAnimator);
  animator.setDuration(newDuration);
  if (delay > 0 && (previousAnimator == null || !previousAnimator.isRunning())) {
    animator.setStartDelay(delay);
  }
  animator.addListener(getGlobalAnimationFinishedListener());
  final boolean isHeadsUpDisappear=mHeadsUpDisappearChildren.contains(child);
  animator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      HeadsUpManager.setIsClickedNotification(child,false);
      child.setTag(TAG_ANIMATOR_TRANSLATION_Y,null);
      child.setTag(TAG_START_TRANSLATION_Y,null);
      child.setTag(TAG_END_TRANSLATION_Y,null);
      if (isHeadsUpDisappear) {
        ((ExpandableNotificationRow)child).setHeadsupDisappearRunning(false);
      }
    }
  }
);
  startAnimator(animator);
  child.setTag(TAG_ANIMATOR_TRANSLATION_Y,animator);
  child.setTag(TAG_START_TRANSLATION_Y,child.getTranslationY());
  child.setTag(TAG_END_TRANSLATION_Y,newEndValue);
}",0.9569986836331724
191287,"/** 
 * Defer the specified SyncOperation by rescheduling it on the JobScheduler with some delay. This is equivalent to a failure. If this is a periodic sync, a delayed one-off sync will be scheduled.
 */
private void deferSyncH(SyncOperation op,long delay){
  mSyncJobService.callJobFinished(op.jobId,false);
  if (op.isPeriodic) {
    scheduleSyncOperationH(op.createOneTimeSyncOperation(),delay);
  }
 else {
    scheduleSyncOperationH(op,delay);
  }
}","/** 
 * Defer the specified SyncOperation by rescheduling it on the JobScheduler with some delay. This is equivalent to a failure. If this is a periodic sync, a delayed one-off sync will be scheduled.
 */
private void deferSyncH(SyncOperation op,long delay){
  mSyncJobService.callJobFinished(op.jobId,false);
  if (op.isPeriodic) {
    scheduleSyncOperationH(op.createOneTimeSyncOperation(),delay);
  }
 else {
    getJobScheduler().cancel(op.jobId);
    scheduleSyncOperationH(op,delay);
  }
}",0.9578947368421052
191288,"private void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  final boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false) && !syncResult.syncAlreadyInProgress) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.tooManyRetries) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000);
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}","private void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  final boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false) && !syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false) && !syncResult.syncAlreadyInProgress) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.tooManyRetries) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperationH(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000);
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperationH(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}",0.9888587774766636
191289,"private void runSyncFinishedOrCanceledH(SyncResult syncResult,ActiveSyncContext activeSyncContext){
  final boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
  final SyncOperation syncOperation=activeSyncContext.mSyncOperation;
  final SyncStorageEngine.EndPoint info=syncOperation.target;
  if (activeSyncContext.mIsLinkedToDeath) {
    activeSyncContext.mSyncAdapter.asBinder().unlinkToDeath(activeSyncContext,0);
    activeSyncContext.mIsLinkedToDeath=false;
  }
  closeActiveSyncContext(activeSyncContext);
  final long elapsedTime=SystemClock.elapsedRealtime() - activeSyncContext.mStartTime;
  String historyMessage;
  int downstreamActivity;
  int upstreamActivity;
  if (syncResult != null) {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
    }
    if (!syncResult.hasError()) {
      historyMessage=SyncStorageEngine.MESG_SUCCESS;
      downstreamActivity=0;
      upstreamActivity=0;
      clearBackoffSetting(syncOperation.target);
      if (syncOperation.isDerivedFromFailedPeriodicSync()) {
        reschedulePeriodicSyncH(syncOperation);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
      increaseBackoffSetting(syncOperation.target);
      if (!syncOperation.isPeriodic) {
        maybeRescheduleSync(syncResult,syncOperation);
      }
 else {
        postScheduleSyncMessage(syncOperation.createOneTimeSyncOperation());
      }
      historyMessage=ContentResolver.syncErrorToString(syncResultToErrorNumber(syncResult));
      downstreamActivity=0;
      upstreamActivity=0;
    }
    setDelayUntilTime(syncOperation.target,syncResult.delayUntil);
  }
 else {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation);
    }
    if (activeSyncContext.mSyncAdapter != null) {
      try {
        activeSyncContext.mSyncAdapter.cancelSync(activeSyncContext);
      }
 catch (      RemoteException e) {
      }
    }
    historyMessage=SyncStorageEngine.MESG_CANCELED;
    downstreamActivity=0;
    upstreamActivity=0;
  }
  stopSyncEvent(activeSyncContext.mHistoryRowId,syncOperation,historyMessage,upstreamActivity,downstreamActivity,elapsedTime);
  if (syncResult != null && syncResult.tooManyDeletions) {
    installHandleTooManyDeletesNotification(info.account,info.provider,syncResult.stats.numDeletes,info.userId);
  }
 else {
    mNotificationMgr.cancelAsUser(null,info.account.hashCode() ^ info.provider.hashCode(),new UserHandle(info.userId));
  }
  if (syncResult != null && syncResult.fullSyncRequested) {
    scheduleSyncOperationH(new SyncOperation(info.account,info.userId,syncOperation.owningUid,syncOperation.owningPackage,syncOperation.reason,syncOperation.syncSource,info.provider,new Bundle(),syncOperation.allowParallelSyncs));
  }
}","private void runSyncFinishedOrCanceledH(SyncResult syncResult,ActiveSyncContext activeSyncContext){
  final boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
  final SyncOperation syncOperation=activeSyncContext.mSyncOperation;
  final SyncStorageEngine.EndPoint info=syncOperation.target;
  if (activeSyncContext.mIsLinkedToDeath) {
    activeSyncContext.mSyncAdapter.asBinder().unlinkToDeath(activeSyncContext,0);
    activeSyncContext.mIsLinkedToDeath=false;
  }
  closeActiveSyncContext(activeSyncContext);
  final long elapsedTime=SystemClock.elapsedRealtime() - activeSyncContext.mStartTime;
  String historyMessage;
  int downstreamActivity;
  int upstreamActivity;
  if (!syncOperation.isPeriodic) {
    getJobScheduler().cancel(syncOperation.jobId);
  }
  if (syncResult != null) {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
    }
    if (!syncResult.hasError()) {
      historyMessage=SyncStorageEngine.MESG_SUCCESS;
      downstreamActivity=0;
      upstreamActivity=0;
      clearBackoffSetting(syncOperation.target);
      if (syncOperation.isDerivedFromFailedPeriodicSync()) {
        reschedulePeriodicSyncH(syncOperation);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"" + syncOperation + ""String_Node_Str""+ syncResult);
      increaseBackoffSetting(syncOperation.target);
      if (!syncOperation.isPeriodic) {
        maybeRescheduleSync(syncResult,syncOperation);
      }
 else {
        postScheduleSyncMessage(syncOperation.createOneTimeSyncOperation());
      }
      historyMessage=ContentResolver.syncErrorToString(syncResultToErrorNumber(syncResult));
      downstreamActivity=0;
      upstreamActivity=0;
    }
    setDelayUntilTime(syncOperation.target,syncResult.delayUntil);
  }
 else {
    if (isLoggable) {
      Slog.v(TAG,""String_Node_Str"" + syncOperation);
    }
    if (activeSyncContext.mSyncAdapter != null) {
      try {
        activeSyncContext.mSyncAdapter.cancelSync(activeSyncContext);
      }
 catch (      RemoteException e) {
      }
    }
    historyMessage=SyncStorageEngine.MESG_CANCELED;
    downstreamActivity=0;
    upstreamActivity=0;
  }
  stopSyncEvent(activeSyncContext.mHistoryRowId,syncOperation,historyMessage,upstreamActivity,downstreamActivity,elapsedTime);
  if (syncResult != null && syncResult.tooManyDeletions) {
    installHandleTooManyDeletesNotification(info.account,info.provider,syncResult.stats.numDeletes,info.userId);
  }
 else {
    mNotificationMgr.cancelAsUser(null,info.account.hashCode() ^ info.provider.hashCode(),new UserHandle(info.userId));
  }
  if (syncResult != null && syncResult.fullSyncRequested) {
    scheduleSyncOperationH(new SyncOperation(info.account,info.userId,syncOperation.owningUid,syncOperation.owningPackage,syncOperation.reason,syncOperation.syncSource,info.provider,new Bundle(),syncOperation.allowParallelSyncs));
  }
}",0.9842215988779804
191290,"@Override public void onClick(View v){
  if (!mShowingPublic && mGroupManager.isSummaryOfGroup(mStatusBarNotification)) {
    final boolean wasExpanded=mGroupManager.isGroupExpanded(mStatusBarNotification);
    boolean nowExpanded=mGroupManager.toggleGroupExpansion(mStatusBarNotification);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    mGroupExpansionChanging=true;
    updateBackgroundForGroupState();
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_GROUP_EXPANDER,nowExpanded);
    logExpansionEvent(true,wasExpanded);
  }
 else {
    boolean nowExpanded;
    if (isPinned()) {
      nowExpanded=!mExpandedWhenPinned;
      mExpandedWhenPinned=nowExpanded;
    }
 else {
      nowExpanded=!isExpanded();
      setUserExpanded(nowExpanded);
    }
    notifyHeightChanged(true);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_EXPANDER,nowExpanded);
  }
}","@Override public void onClick(View v){
  if (!mShowingPublic && mGroupManager.isSummaryOfGroup(mStatusBarNotification)) {
    mGroupExpansionChanging=true;
    final boolean wasExpanded=mGroupManager.isGroupExpanded(mStatusBarNotification);
    boolean nowExpanded=mGroupManager.toggleGroupExpansion(mStatusBarNotification);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_GROUP_EXPANDER,nowExpanded);
    logExpansionEvent(true,wasExpanded);
  }
 else {
    boolean nowExpanded;
    if (isPinned()) {
      nowExpanded=!mExpandedWhenPinned;
      mExpandedWhenPinned=nowExpanded;
    }
 else {
      nowExpanded=!isExpanded();
      setUserExpanded(nowExpanded);
    }
    notifyHeightChanged(true);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_EXPANDER,nowExpanded);
  }
}",0.9453978159126364
191291,"public void setChildrenExpanded(boolean expanded,boolean animate){
  mChildrenExpanded=expanded;
  if (mChildrenContainer != null) {
    mChildrenContainer.setChildrenExpanded(expanded);
  }
  updateClickAndFocus();
}","public void setChildrenExpanded(boolean expanded,boolean animate){
  mChildrenExpanded=expanded;
  if (mChildrenContainer != null) {
    mChildrenContainer.setChildrenExpanded(expanded);
  }
  updateBackgroundForGroupState();
  updateClickAndFocus();
}",0.9253731343283582
191292,"@Override public void onClick(View v){
  if (!mShowingPublic && mGroupManager.isSummaryOfGroup(mStatusBarNotification)) {
    final boolean wasExpanded=mGroupManager.isGroupExpanded(mStatusBarNotification);
    boolean nowExpanded=mGroupManager.toggleGroupExpansion(mStatusBarNotification);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    mGroupExpansionChanging=true;
    updateBackgroundForGroupState();
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_GROUP_EXPANDER,nowExpanded);
    logExpansionEvent(true,wasExpanded);
  }
 else {
    boolean nowExpanded;
    if (isPinned()) {
      nowExpanded=!mExpandedWhenPinned;
      mExpandedWhenPinned=nowExpanded;
    }
 else {
      nowExpanded=!isExpanded();
      setUserExpanded(nowExpanded);
    }
    notifyHeightChanged(true);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_EXPANDER,nowExpanded);
  }
}","@Override public void onClick(View v){
  if (!mShowingPublic && mGroupManager.isSummaryOfGroup(mStatusBarNotification)) {
    mGroupExpansionChanging=true;
    final boolean wasExpanded=mGroupManager.isGroupExpanded(mStatusBarNotification);
    boolean nowExpanded=mGroupManager.toggleGroupExpansion(mStatusBarNotification);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_GROUP_EXPANDER,nowExpanded);
    logExpansionEvent(true,wasExpanded);
  }
 else {
    boolean nowExpanded;
    if (isPinned()) {
      nowExpanded=!mExpandedWhenPinned;
      mExpandedWhenPinned=nowExpanded;
    }
 else {
      nowExpanded=!isExpanded();
      setUserExpanded(nowExpanded);
    }
    notifyHeightChanged(true);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_EXPANDER,nowExpanded);
  }
}",0.9453978159126364
191293,"public void setChildrenExpanded(boolean expanded,boolean animate){
  mChildrenExpanded=expanded;
  if (mChildrenContainer != null) {
    mChildrenContainer.setChildrenExpanded(expanded);
  }
  updateClickAndFocus();
}","public void setChildrenExpanded(boolean expanded,boolean animate){
  mChildrenExpanded=expanded;
  if (mChildrenContainer != null) {
    mChildrenContainer.setChildrenExpanded(expanded);
  }
  updateBackgroundForGroupState();
  updateClickAndFocus();
}",0.9253731343283582
191294,"@Override public void updateRecentsVisibility(boolean visible){
  mImpl.onVisibilityChanged(mContext,visible);
}","@Override public void updateRecentsVisibility(boolean visible){
  ForegroundThread.getHandler().post(() -> {
    mImpl.onVisibilityChanged(mContext,visible);
  }
);
}",0.8057553956834532
191295,"@Override public void startScreenPinning(int taskId){
  mImpl.onStartScreenPinning(mContext,taskId);
}","@Override public void startScreenPinning(int taskId){
  ForegroundThread.getHandler().post(() -> {
    mImpl.onStartScreenPinning(mContext,taskId);
  }
);
}",0.7906976744186046
191296,"public void showPrompt(int taskId,boolean allowCancel){
  clearPrompt();
  this.taskId=taskId;
  mRequestWindow=new RequestWindowView(mContext,allowCancel);
  mRequestWindow.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
  WindowManager.LayoutParams lp=getWindowLayoutParams();
  mWindowManager.addView(mRequestWindow,lp);
}","public void showPrompt(int taskId,boolean allowCancel){
  try {
    clearPrompt();
  }
 catch (  IllegalArgumentException e) {
  }
  this.taskId=taskId;
  mRequestWindow=new RequestWindowView(mContext,allowCancel);
  mRequestWindow.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
  WindowManager.LayoutParams lp=getWindowLayoutParams();
  mWindowManager.addView(mRequestWindow,lp);
}",0.9203296703296704
191297,"@Override public void onClick(View v){
  if (!mShowingPublic && mGroupManager.isSummaryOfGroup(mStatusBarNotification)) {
    final boolean wasExpanded=mGroupManager.isGroupExpanded(mStatusBarNotification);
    boolean nowExpanded=mGroupManager.toggleGroupExpansion(mStatusBarNotification);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    mGroupExpansionChanging=true;
    updateBackgroundForGroupState();
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_GROUP_EXPANDER,nowExpanded);
    logExpansionEvent(true,wasExpanded);
  }
 else {
    boolean nowExpanded;
    if (isPinned()) {
      nowExpanded=!mExpandedWhenPinned;
      mExpandedWhenPinned=nowExpanded;
    }
 else {
      nowExpanded=!isExpanded();
      setUserExpanded(nowExpanded);
    }
    notifyHeightChanged(true);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_EXPANDER,nowExpanded);
  }
}","@Override public void onClick(View v){
  if (!mShowingPublic && mGroupManager.isSummaryOfGroup(mStatusBarNotification)) {
    mGroupExpansionChanging=true;
    final boolean wasExpanded=mGroupManager.isGroupExpanded(mStatusBarNotification);
    boolean nowExpanded=mGroupManager.toggleGroupExpansion(mStatusBarNotification);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_GROUP_EXPANDER,nowExpanded);
    logExpansionEvent(true,wasExpanded);
  }
 else {
    boolean nowExpanded;
    if (isPinned()) {
      nowExpanded=!mExpandedWhenPinned;
      mExpandedWhenPinned=nowExpanded;
    }
 else {
      nowExpanded=!isExpanded();
      setUserExpanded(nowExpanded);
    }
    notifyHeightChanged(true);
    mOnExpandClickListener.onExpandClicked(mEntry,nowExpanded);
    MetricsLogger.action(mContext,MetricsEvent.ACTION_NOTIFICATION_EXPANDER,nowExpanded);
  }
}",0.9453978159126364
191298,"public void setChildrenExpanded(boolean expanded,boolean animate){
  mChildrenExpanded=expanded;
  if (mChildrenContainer != null) {
    mChildrenContainer.setChildrenExpanded(expanded);
  }
  updateClickAndFocus();
}","public void setChildrenExpanded(boolean expanded,boolean animate){
  mChildrenExpanded=expanded;
  if (mChildrenContainer != null) {
    mChildrenContainer.setChildrenExpanded(expanded);
  }
  updateBackgroundForGroupState();
  updateClickAndFocus();
}",0.9253731343283582
191299,"@Override public void updateRecentsVisibility(boolean visible){
  mImpl.onVisibilityChanged(mContext,visible);
}","@Override public void updateRecentsVisibility(boolean visible){
  ForegroundThread.getHandler().post(() -> {
    mImpl.onVisibilityChanged(mContext,visible);
  }
);
}",0.8057553956834532
191300,"@Override public void startScreenPinning(int taskId){
  mImpl.onStartScreenPinning(mContext,taskId);
}","@Override public void startScreenPinning(int taskId){
  ForegroundThread.getHandler().post(() -> {
    mImpl.onStartScreenPinning(mContext,taskId);
  }
);
}",0.7906976744186046
191301,"public void showPrompt(int taskId,boolean allowCancel){
  clearPrompt();
  this.taskId=taskId;
  mRequestWindow=new RequestWindowView(mContext,allowCancel);
  mRequestWindow.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
  WindowManager.LayoutParams lp=getWindowLayoutParams();
  mWindowManager.addView(mRequestWindow,lp);
}","public void showPrompt(int taskId,boolean allowCancel){
  try {
    clearPrompt();
  }
 catch (  IllegalArgumentException e) {
  }
  this.taskId=taskId;
  mRequestWindow=new RequestWindowView(mContext,allowCancel);
  mRequestWindow.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
  WindowManager.LayoutParams lp=getWindowLayoutParams();
  mWindowManager.addView(mRequestWindow,lp);
}",0.9203296703296704
191302,"@Override public void updateRecentsVisibility(boolean visible){
  mImpl.onVisibilityChanged(mContext,visible);
}","@Override public void updateRecentsVisibility(boolean visible){
  ForegroundThread.getHandler().post(() -> {
    mImpl.onVisibilityChanged(mContext,visible);
  }
);
}",0.8057553956834532
191303,"@Override public void startScreenPinning(int taskId){
  mImpl.onStartScreenPinning(mContext,taskId);
}","@Override public void startScreenPinning(int taskId){
  ForegroundThread.getHandler().post(() -> {
    mImpl.onStartScreenPinning(mContext,taskId);
  }
);
}",0.7906976744186046
191304,"public void showPrompt(int taskId,boolean allowCancel){
  clearPrompt();
  this.taskId=taskId;
  mRequestWindow=new RequestWindowView(mContext,allowCancel);
  mRequestWindow.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
  WindowManager.LayoutParams lp=getWindowLayoutParams();
  mWindowManager.addView(mRequestWindow,lp);
}","public void showPrompt(int taskId,boolean allowCancel){
  try {
    clearPrompt();
  }
 catch (  IllegalArgumentException e) {
  }
  this.taskId=taskId;
  mRequestWindow=new RequestWindowView(mContext,allowCancel);
  mRequestWindow.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
  WindowManager.LayoutParams lp=getWindowLayoutParams();
  mWindowManager.addView(mRequestWindow,lp);
}",0.9203296703296704
191305,"@Override public CharSequence getAccessibilityClassName(){
  return TaskStackView.class.getName();
}","@Override public CharSequence getAccessibilityClassName(){
  return ScrollView.class.getName();
}",0.9441624365482234
191306,"/** 
 * Sets the focused task relative to the currently focused task.
 * @param forward whether to go to the next task in the stack (along the curve) or the previous
 * @param stackTasksOnly if set, will ensure that the traversal only goes along stack tasks, andif the currently focused task is not a stack task, will set the focus to the first visible stack task
 * @param animated determines whether to actually draw the highlight along with the change infocus.
 * @param cancelWindowAnimations if set, will attempt to cancel window animations if a scrollhappens.
 * @param timerIndicatorDuration the duration to initialize the auto-advance timer indicator
 */
public void setRelativeFocusedTask(boolean forward,boolean stackTasksOnly,boolean animated,boolean cancelWindowAnimations,int timerIndicatorDuration){
  int newIndex=mStack.indexOfStackTask(mFocusedTask);
  if (mFocusedTask != null) {
    if (stackTasksOnly) {
      List<Task> tasks=mStack.getStackTasks();
      if (mFocusedTask.isFreeformTask()) {
        TaskView tv=getFrontMostTaskView(stackTasksOnly);
        if (tv != null) {
          newIndex=mStack.indexOfStackTask(tv.getTask());
        }
      }
 else {
        int tmpNewIndex=newIndex + (forward ? -1 : 1);
        if (0 <= tmpNewIndex && tmpNewIndex < tasks.size()) {
          Task t=tasks.get(tmpNewIndex);
          if (!t.isFreeformTask()) {
            newIndex=tmpNewIndex;
          }
        }
      }
    }
 else {
      int taskCount=mStack.getTaskCount();
      newIndex=(newIndex + (forward ? -1 : 1) + taskCount) % taskCount;
    }
  }
 else {
    float stackScroll=mStackScroller.getStackScroll();
    ArrayList<Task> tasks=mStack.getStackTasks();
    int taskCount=tasks.size();
    if (forward) {
      for (newIndex=taskCount - 1; newIndex >= 0; newIndex--) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) <= 0) {
          break;
        }
      }
    }
 else {
      for (newIndex=0; newIndex < taskCount; newIndex++) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) >= 0) {
          break;
        }
      }
    }
  }
  if (newIndex != -1) {
    boolean willScroll=setFocusedTask(newIndex,true,true,timerIndicatorDuration);
    if (willScroll && cancelWindowAnimations) {
      EventBus.getDefault().send(new CancelEnterRecentsWindowAnimationEvent(null));
    }
  }
}","/** 
 * Sets the focused task relative to the currently focused task.
 * @param forward whether to go to the next task in the stack (along the curve) or the previous
 * @param stackTasksOnly if set, will ensure that the traversal only goes along stack tasks, andif the currently focused task is not a stack task, will set the focus to the first visible stack task
 * @param animated determines whether to actually draw the highlight along with the change infocus.
 * @param cancelWindowAnimations if set, will attempt to cancel window animations if a scrollhappens.
 * @param timerIndicatorDuration the duration to initialize the auto-advance timer indicator
 */
public void setRelativeFocusedTask(boolean forward,boolean stackTasksOnly,boolean animated,boolean cancelWindowAnimations,int timerIndicatorDuration){
  Task focusedTask=getFocusedTask();
  int newIndex=mStack.indexOfStackTask(focusedTask);
  if (focusedTask != null) {
    if (stackTasksOnly) {
      List<Task> tasks=mStack.getStackTasks();
      if (focusedTask.isFreeformTask()) {
        TaskView tv=getFrontMostTaskView(stackTasksOnly);
        if (tv != null) {
          newIndex=mStack.indexOfStackTask(tv.getTask());
        }
      }
 else {
        int tmpNewIndex=newIndex + (forward ? -1 : 1);
        if (0 <= tmpNewIndex && tmpNewIndex < tasks.size()) {
          Task t=tasks.get(tmpNewIndex);
          if (!t.isFreeformTask()) {
            newIndex=tmpNewIndex;
          }
        }
      }
    }
 else {
      int taskCount=mStack.getTaskCount();
      newIndex=(newIndex + (forward ? -1 : 1) + taskCount) % taskCount;
    }
  }
 else {
    float stackScroll=mStackScroller.getStackScroll();
    ArrayList<Task> tasks=mStack.getStackTasks();
    int taskCount=tasks.size();
    if (forward) {
      for (newIndex=taskCount - 1; newIndex >= 0; newIndex--) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) <= 0) {
          break;
        }
      }
    }
 else {
      for (newIndex=0; newIndex < taskCount; newIndex++) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) >= 0) {
          break;
        }
      }
    }
  }
  if (newIndex != -1) {
    boolean willScroll=setFocusedTask(newIndex,true,true,timerIndicatorDuration);
    if (willScroll && cancelWindowAnimations) {
      EventBus.getDefault().send(new CancelEnterRecentsWindowAnimationEvent(null));
    }
  }
}",0.9907815631262524
191307,"/** 
 * Synchronizes the set of children   {@link TaskView}s to match the visible set of tasks in the current   {@link TaskStack}. This call does not continue on to update their position to the computed   {@link TaskViewTransform}s of the visible range, but only ensures that they will be added/removed from the view hierarchy and placed in the correct Z order and initial position (if not currently on screen).
 * @param targetStackScroll If provided, will ensure that the set of visible {@link TaskView}s includes those visible at the current stack scroll, and all at the target stack scroll.
 * @param ignoreTaskOverrides If set, the visible task computation will get the transforms fortasks at their non-overridden task progress
 */
void bindVisibleTaskViews(float targetStackScroll,boolean ignoreTaskOverrides){
  ArrayList<Task> tasks=mStack.getStackTasks();
  int[] visibleTaskRange=computeVisibleTaskTransforms(mCurrentTaskTransforms,tasks,mStackScroller.getStackScroll(),targetStackScroll,mIgnoreTasks,ignoreTaskOverrides);
  mTmpTaskViewMap.clear();
  List<TaskView> taskViews=getTaskViews();
  int lastFocusedTaskIndex=-1;
  int taskViewCount=taskViews.size();
  for (int i=taskViewCount - 1; i >= 0; i--) {
    TaskView tv=taskViews.get(i);
    Task task=tv.getTask();
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    int taskIndex=mStack.indexOfStackTask(task);
    TaskViewTransform transform=null;
    if (taskIndex != -1) {
      transform=mCurrentTaskTransforms.get(taskIndex);
    }
    if (task.isFreeformTask() || (transform != null && transform.visible)) {
      mTmpTaskViewMap.put(task.key,tv);
    }
 else {
      if (mTouchExplorationEnabled) {
        lastFocusedTaskIndex=taskIndex;
        resetFocusedTask(task);
      }
      mViewPool.returnViewToPool(tv);
    }
  }
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    TaskViewTransform transform=mCurrentTaskTransforms.get(i);
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    if (!task.isFreeformTask() && !transform.visible) {
      continue;
    }
    TaskView tv=mTmpTaskViewMap.get(task.key);
    if (tv == null) {
      tv=mViewPool.pickUpViewFromPool(task,task);
      if (task.isFreeformTask()) {
        updateTaskViewToTransform(tv,transform,AnimationProps.IMMEDIATE);
      }
 else {
        if (transform.rect.top <= mLayoutAlgorithm.mStackRect.top) {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getBackOfStackTransform(),AnimationProps.IMMEDIATE);
        }
 else {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getFrontOfStackTransform(),AnimationProps.IMMEDIATE);
        }
      }
    }
 else {
      final int taskIndex=mStack.indexOfStackTask(task);
      final int insertIndex=findTaskViewInsertIndex(task,taskIndex);
      if (insertIndex != getTaskViews().indexOf(tv)) {
        detachViewFromParent(tv);
        attachViewToParent(tv,insertIndex,tv.getLayoutParams());
        updateTaskViewsList();
      }
    }
  }
  if (lastFocusedTaskIndex != -1) {
    if (lastFocusedTaskIndex < visibleTaskRange[1]) {
      setFocusedTask(visibleTaskRange[1],false,true);
    }
 else {
      setFocusedTask(visibleTaskRange[0],false,true);
    }
  }
}","/** 
 * Synchronizes the set of children   {@link TaskView}s to match the visible set of tasks in the current   {@link TaskStack}. This call does not continue on to update their position to the computed   {@link TaskViewTransform}s of the visible range, but only ensures that they will be added/removed from the view hierarchy and placed in the correct Z order and initial position (if not currently on screen).
 * @param targetStackScroll If provided, will ensure that the set of visible {@link TaskView}s includes those visible at the current stack scroll, and all at the target stack scroll.
 * @param ignoreTaskOverrides If set, the visible task computation will get the transforms fortasks at their non-overridden task progress
 */
void bindVisibleTaskViews(float targetStackScroll,boolean ignoreTaskOverrides){
  ArrayList<Task> tasks=mStack.getStackTasks();
  int[] visibleTaskRange=computeVisibleTaskTransforms(mCurrentTaskTransforms,tasks,mStackScroller.getStackScroll(),targetStackScroll,mIgnoreTasks,ignoreTaskOverrides);
  mTmpTaskViewMap.clear();
  List<TaskView> taskViews=getTaskViews();
  int lastFocusedTaskIndex=-1;
  int taskViewCount=taskViews.size();
  for (int i=taskViewCount - 1; i >= 0; i--) {
    TaskView tv=taskViews.get(i);
    Task task=tv.getTask();
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    int taskIndex=mStack.indexOfStackTask(task);
    TaskViewTransform transform=null;
    if (taskIndex != -1) {
      transform=mCurrentTaskTransforms.get(taskIndex);
    }
    if (task.isFreeformTask() || (transform != null && transform.visible)) {
      mTmpTaskViewMap.put(task.key,tv);
    }
 else {
      if (mTouchExplorationEnabled && Utilities.isDescendentAccessibilityFocused(tv)) {
        lastFocusedTaskIndex=taskIndex;
        resetFocusedTask(task);
      }
      mViewPool.returnViewToPool(tv);
    }
  }
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    TaskViewTransform transform=mCurrentTaskTransforms.get(i);
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    if (!task.isFreeformTask() && !transform.visible) {
      continue;
    }
    TaskView tv=mTmpTaskViewMap.get(task.key);
    if (tv == null) {
      tv=mViewPool.pickUpViewFromPool(task,task);
      if (task.isFreeformTask()) {
        updateTaskViewToTransform(tv,transform,AnimationProps.IMMEDIATE);
      }
 else {
        if (transform.rect.top <= mLayoutAlgorithm.mStackRect.top) {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getBackOfStackTransform(),AnimationProps.IMMEDIATE);
        }
 else {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getFrontOfStackTransform(),AnimationProps.IMMEDIATE);
        }
      }
    }
 else {
      final int taskIndex=mStack.indexOfStackTask(task);
      final int insertIndex=findTaskViewInsertIndex(task,taskIndex);
      if (insertIndex != getTaskViews().indexOf(tv)) {
        detachViewFromParent(tv);
        attachViewToParent(tv,insertIndex,tv.getLayoutParams());
        updateTaskViewsList();
      }
    }
  }
  if (lastFocusedTaskIndex != -1) {
    int newFocusedTaskIndex=(lastFocusedTaskIndex < visibleTaskRange[1]) ? visibleTaskRange[1] : visibleTaskRange[0];
    setFocusedTask(newFocusedTaskIndex,false,true);
    TaskView focusedTaskView=getChildViewForTask(mFocusedTask);
    if (focusedTaskView != null) {
      focusedTaskView.requestAccessibilityFocus();
    }
  }
}",0.9486332231901472
191308,"@Override public boolean performAccessibilityAction(int action,Bundle arguments){
  if (super.performAccessibilityAction(action,arguments)) {
    return true;
  }
switch (action) {
case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
{
      setRelativeFocusedTask(true,false,false);
      return true;
    }
case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
{
    setRelativeFocusedTask(false,false,false);
    return true;
  }
}
return false;
}","@Override public boolean performAccessibilityAction(int action,Bundle arguments){
  if (super.performAccessibilityAction(action,arguments)) {
    return true;
  }
  Task focusedTask=getAccessibilityFocusedTask();
  int taskIndex=mStack.indexOfStackTask(focusedTask);
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
switch (action) {
case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
{
        setFocusedTask(taskIndex + 1,true,true,0);
        return true;
      }
case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
{
      setFocusedTask(taskIndex - 1,true,true,0);
      return true;
    }
}
}
return false;
}",0.6254681647940075
191309,"@Override public void onReturnViewToPool(TaskView tv){
  final Task task=tv.getTask();
  unbindTaskView(tv,task);
  tv.resetViewProperties();
  tv.setFocusedState(false,false);
  tv.setClipViewInStack(false);
  if (mScreenPinningEnabled) {
    tv.hideActionButton(false,0,false,null);
  }
  detachViewFromParent(tv);
  updateTaskViewsList();
}","@Override public void onReturnViewToPool(TaskView tv){
  final Task task=tv.getTask();
  unbindTaskView(tv,task);
  tv.clearAccessibilityFocus();
  tv.resetViewProperties();
  tv.setFocusedState(false,false);
  tv.setClipViewInStack(false);
  if (mScreenPinningEnabled) {
    tv.hideActionButton(false,0,false,null);
  }
  detachViewFromParent(tv);
  updateTaskViewsList();
}",0.9554317548746518
191310,"@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  if (taskViewCount > 1 && mFocusedTask != null) {
    info.setScrollable(true);
    int focusedTaskIndex=mStack.indexOfStackTask(mFocusedTask);
    if (focusedTaskIndex > 0) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    }
    if (focusedTaskIndex < mStack.getTaskCount() - 1) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  if (taskViewCount > 1) {
    Task focusedTask=getAccessibilityFocusedTask();
    info.setScrollable(true);
    int focusedTaskIndex=mStack.indexOfStackTask(focusedTask);
    if (focusedTaskIndex > 0) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
    }
    if (0 <= focusedTaskIndex && focusedTaskIndex < mStack.getTaskCount() - 1) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    }
  }
}",0.65814696485623
191311,"private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      cancelNonDismissTaskAnimations();
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}","private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      cancelNonDismissTaskAnimations();
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
if (!mSv.mTouchExplorationEnabled) {
  mSv.resetFocusedTask(mSv.getFocusedTask());
}
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}",0.9955303608416004
191312,"/** 
 * Explicitly sets the focused state of this task.
 */
public void setFocusedState(boolean isFocused,boolean requestViewFocus){
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (isFocused) {
    if (requestViewFocus && !isFocused()) {
      requestFocus();
    }
    if (requestViewFocus && !isAccessibilityFocused() && ssp.isTouchExplorationEnabled()) {
      requestAccessibilityFocus();
    }
  }
 else {
    if (isAccessibilityFocused() && ssp.isTouchExplorationEnabled()) {
      clearAccessibilityFocus();
    }
  }
}","/** 
 * Explicitly sets the focused state of this task.
 */
public void setFocusedState(boolean isFocused,boolean requestViewFocus){
  if (isFocused) {
    if (requestViewFocus && !isFocused()) {
      requestFocus();
    }
  }
 else {
    if (isAccessibilityFocused() && mTouchExplorationEnabled) {
      clearAccessibilityFocus();
    }
  }
}",0.6455266138165345
191313,"@Override public void onTaskDataLoaded(Task task,ActivityManager.TaskThumbnailInfo thumbnailInfo){
  mThumbnailView.onTaskDataLoaded(thumbnailInfo);
  mHeaderView.onTaskDataLoaded();
  mTaskDataLoaded=true;
}","@Override public void onTaskDataLoaded(Task task,ActivityManager.TaskThumbnailInfo thumbnailInfo){
  mThumbnailView.onTaskDataLoaded(thumbnailInfo);
  mHeaderView.onTaskDataLoaded();
}",0.9387755102040816
191314,"@Override public void onTaskDataUnloaded(){
  mTask.removeCallback(this);
  mThumbnailView.unbindFromTask();
  mHeaderView.unbindFromTask(mTouchExplorationEnabled);
  mTaskDataLoaded=false;
}","@Override public void onTaskDataUnloaded(){
  mTask.removeCallback(this);
  mThumbnailView.unbindFromTask();
  mHeaderView.unbindFromTask(mTouchExplorationEnabled);
}",0.9299719887955182
191315,"@Override public CharSequence getAccessibilityClassName(){
  return TaskStackView.class.getName();
}","@Override public CharSequence getAccessibilityClassName(){
  return ScrollView.class.getName();
}",0.9441624365482234
191316,"/** 
 * Sets the focused task relative to the currently focused task.
 * @param forward whether to go to the next task in the stack (along the curve) or the previous
 * @param stackTasksOnly if set, will ensure that the traversal only goes along stack tasks, andif the currently focused task is not a stack task, will set the focus to the first visible stack task
 * @param animated determines whether to actually draw the highlight along with the change infocus.
 * @param cancelWindowAnimations if set, will attempt to cancel window animations if a scrollhappens.
 * @param timerIndicatorDuration the duration to initialize the auto-advance timer indicator
 */
public void setRelativeFocusedTask(boolean forward,boolean stackTasksOnly,boolean animated,boolean cancelWindowAnimations,int timerIndicatorDuration){
  int newIndex=mStack.indexOfStackTask(mFocusedTask);
  if (mFocusedTask != null) {
    if (stackTasksOnly) {
      List<Task> tasks=mStack.getStackTasks();
      if (mFocusedTask.isFreeformTask()) {
        TaskView tv=getFrontMostTaskView(stackTasksOnly);
        if (tv != null) {
          newIndex=mStack.indexOfStackTask(tv.getTask());
        }
      }
 else {
        int tmpNewIndex=newIndex + (forward ? -1 : 1);
        if (0 <= tmpNewIndex && tmpNewIndex < tasks.size()) {
          Task t=tasks.get(tmpNewIndex);
          if (!t.isFreeformTask()) {
            newIndex=tmpNewIndex;
          }
        }
      }
    }
 else {
      int taskCount=mStack.getTaskCount();
      newIndex=(newIndex + (forward ? -1 : 1) + taskCount) % taskCount;
    }
  }
 else {
    float stackScroll=mStackScroller.getStackScroll();
    ArrayList<Task> tasks=mStack.getStackTasks();
    int taskCount=tasks.size();
    if (forward) {
      for (newIndex=taskCount - 1; newIndex >= 0; newIndex--) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) <= 0) {
          break;
        }
      }
    }
 else {
      for (newIndex=0; newIndex < taskCount; newIndex++) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) >= 0) {
          break;
        }
      }
    }
  }
  if (newIndex != -1) {
    boolean willScroll=setFocusedTask(newIndex,true,true,timerIndicatorDuration);
    if (willScroll && cancelWindowAnimations) {
      EventBus.getDefault().send(new CancelEnterRecentsWindowAnimationEvent(null));
    }
  }
}","/** 
 * Sets the focused task relative to the currently focused task.
 * @param forward whether to go to the next task in the stack (along the curve) or the previous
 * @param stackTasksOnly if set, will ensure that the traversal only goes along stack tasks, andif the currently focused task is not a stack task, will set the focus to the first visible stack task
 * @param animated determines whether to actually draw the highlight along with the change infocus.
 * @param cancelWindowAnimations if set, will attempt to cancel window animations if a scrollhappens.
 * @param timerIndicatorDuration the duration to initialize the auto-advance timer indicator
 */
public void setRelativeFocusedTask(boolean forward,boolean stackTasksOnly,boolean animated,boolean cancelWindowAnimations,int timerIndicatorDuration){
  Task focusedTask=getFocusedTask();
  int newIndex=mStack.indexOfStackTask(focusedTask);
  if (focusedTask != null) {
    if (stackTasksOnly) {
      List<Task> tasks=mStack.getStackTasks();
      if (focusedTask.isFreeformTask()) {
        TaskView tv=getFrontMostTaskView(stackTasksOnly);
        if (tv != null) {
          newIndex=mStack.indexOfStackTask(tv.getTask());
        }
      }
 else {
        int tmpNewIndex=newIndex + (forward ? -1 : 1);
        if (0 <= tmpNewIndex && tmpNewIndex < tasks.size()) {
          Task t=tasks.get(tmpNewIndex);
          if (!t.isFreeformTask()) {
            newIndex=tmpNewIndex;
          }
        }
      }
    }
 else {
      int taskCount=mStack.getTaskCount();
      newIndex=(newIndex + (forward ? -1 : 1) + taskCount) % taskCount;
    }
  }
 else {
    float stackScroll=mStackScroller.getStackScroll();
    ArrayList<Task> tasks=mStack.getStackTasks();
    int taskCount=tasks.size();
    if (forward) {
      for (newIndex=taskCount - 1; newIndex >= 0; newIndex--) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) <= 0) {
          break;
        }
      }
    }
 else {
      for (newIndex=0; newIndex < taskCount; newIndex++) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) >= 0) {
          break;
        }
      }
    }
  }
  if (newIndex != -1) {
    boolean willScroll=setFocusedTask(newIndex,true,true,timerIndicatorDuration);
    if (willScroll && cancelWindowAnimations) {
      EventBus.getDefault().send(new CancelEnterRecentsWindowAnimationEvent(null));
    }
  }
}",0.9907815631262524
191317,"/** 
 * Synchronizes the set of children   {@link TaskView}s to match the visible set of tasks in the current   {@link TaskStack}. This call does not continue on to update their position to the computed   {@link TaskViewTransform}s of the visible range, but only ensures that they will be added/removed from the view hierarchy and placed in the correct Z order and initial position (if not currently on screen).
 * @param targetStackScroll If provided, will ensure that the set of visible {@link TaskView}s includes those visible at the current stack scroll, and all at the target stack scroll.
 * @param ignoreTaskOverrides If set, the visible task computation will get the transforms fortasks at their non-overridden task progress
 */
void bindVisibleTaskViews(float targetStackScroll,boolean ignoreTaskOverrides){
  ArrayList<Task> tasks=mStack.getStackTasks();
  int[] visibleTaskRange=computeVisibleTaskTransforms(mCurrentTaskTransforms,tasks,mStackScroller.getStackScroll(),targetStackScroll,mIgnoreTasks,ignoreTaskOverrides);
  mTmpTaskViewMap.clear();
  List<TaskView> taskViews=getTaskViews();
  int lastFocusedTaskIndex=-1;
  int taskViewCount=taskViews.size();
  for (int i=taskViewCount - 1; i >= 0; i--) {
    TaskView tv=taskViews.get(i);
    Task task=tv.getTask();
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    int taskIndex=mStack.indexOfStackTask(task);
    TaskViewTransform transform=null;
    if (taskIndex != -1) {
      transform=mCurrentTaskTransforms.get(taskIndex);
    }
    if (task.isFreeformTask() || (transform != null && transform.visible)) {
      mTmpTaskViewMap.put(task.key,tv);
    }
 else {
      if (mTouchExplorationEnabled) {
        lastFocusedTaskIndex=taskIndex;
        resetFocusedTask(task);
      }
      mViewPool.returnViewToPool(tv);
    }
  }
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    TaskViewTransform transform=mCurrentTaskTransforms.get(i);
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    if (!task.isFreeformTask() && !transform.visible) {
      continue;
    }
    TaskView tv=mTmpTaskViewMap.get(task.key);
    if (tv == null) {
      tv=mViewPool.pickUpViewFromPool(task,task);
      if (task.isFreeformTask()) {
        updateTaskViewToTransform(tv,transform,AnimationProps.IMMEDIATE);
      }
 else {
        if (transform.rect.top <= mLayoutAlgorithm.mStackRect.top) {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getBackOfStackTransform(),AnimationProps.IMMEDIATE);
        }
 else {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getFrontOfStackTransform(),AnimationProps.IMMEDIATE);
        }
      }
    }
 else {
      final int taskIndex=mStack.indexOfStackTask(task);
      final int insertIndex=findTaskViewInsertIndex(task,taskIndex);
      if (insertIndex != getTaskViews().indexOf(tv)) {
        detachViewFromParent(tv);
        attachViewToParent(tv,insertIndex,tv.getLayoutParams());
        updateTaskViewsList();
      }
    }
  }
  if (lastFocusedTaskIndex != -1) {
    if (lastFocusedTaskIndex < visibleTaskRange[1]) {
      setFocusedTask(visibleTaskRange[1],false,true);
    }
 else {
      setFocusedTask(visibleTaskRange[0],false,true);
    }
  }
}","/** 
 * Synchronizes the set of children   {@link TaskView}s to match the visible set of tasks in the current   {@link TaskStack}. This call does not continue on to update their position to the computed   {@link TaskViewTransform}s of the visible range, but only ensures that they will be added/removed from the view hierarchy and placed in the correct Z order and initial position (if not currently on screen).
 * @param targetStackScroll If provided, will ensure that the set of visible {@link TaskView}s includes those visible at the current stack scroll, and all at the target stack scroll.
 * @param ignoreTaskOverrides If set, the visible task computation will get the transforms fortasks at their non-overridden task progress
 */
void bindVisibleTaskViews(float targetStackScroll,boolean ignoreTaskOverrides){
  ArrayList<Task> tasks=mStack.getStackTasks();
  int[] visibleTaskRange=computeVisibleTaskTransforms(mCurrentTaskTransforms,tasks,mStackScroller.getStackScroll(),targetStackScroll,mIgnoreTasks,ignoreTaskOverrides);
  mTmpTaskViewMap.clear();
  List<TaskView> taskViews=getTaskViews();
  int lastFocusedTaskIndex=-1;
  int taskViewCount=taskViews.size();
  for (int i=taskViewCount - 1; i >= 0; i--) {
    TaskView tv=taskViews.get(i);
    Task task=tv.getTask();
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    int taskIndex=mStack.indexOfStackTask(task);
    TaskViewTransform transform=null;
    if (taskIndex != -1) {
      transform=mCurrentTaskTransforms.get(taskIndex);
    }
    if (task.isFreeformTask() || (transform != null && transform.visible)) {
      mTmpTaskViewMap.put(task.key,tv);
    }
 else {
      if (mTouchExplorationEnabled && Utilities.isDescendentAccessibilityFocused(tv)) {
        lastFocusedTaskIndex=taskIndex;
        resetFocusedTask(task);
      }
      mViewPool.returnViewToPool(tv);
    }
  }
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    TaskViewTransform transform=mCurrentTaskTransforms.get(i);
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    if (!task.isFreeformTask() && !transform.visible) {
      continue;
    }
    TaskView tv=mTmpTaskViewMap.get(task.key);
    if (tv == null) {
      tv=mViewPool.pickUpViewFromPool(task,task);
      if (task.isFreeformTask()) {
        updateTaskViewToTransform(tv,transform,AnimationProps.IMMEDIATE);
      }
 else {
        if (transform.rect.top <= mLayoutAlgorithm.mStackRect.top) {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getBackOfStackTransform(),AnimationProps.IMMEDIATE);
        }
 else {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getFrontOfStackTransform(),AnimationProps.IMMEDIATE);
        }
      }
    }
 else {
      final int taskIndex=mStack.indexOfStackTask(task);
      final int insertIndex=findTaskViewInsertIndex(task,taskIndex);
      if (insertIndex != getTaskViews().indexOf(tv)) {
        detachViewFromParent(tv);
        attachViewToParent(tv,insertIndex,tv.getLayoutParams());
        updateTaskViewsList();
      }
    }
  }
  if (lastFocusedTaskIndex != -1) {
    int newFocusedTaskIndex=(lastFocusedTaskIndex < visibleTaskRange[1]) ? visibleTaskRange[1] : visibleTaskRange[0];
    setFocusedTask(newFocusedTaskIndex,false,true);
    TaskView focusedTaskView=getChildViewForTask(mFocusedTask);
    if (focusedTaskView != null) {
      focusedTaskView.requestAccessibilityFocus();
    }
  }
}",0.9486332231901472
191318,"@Override public boolean performAccessibilityAction(int action,Bundle arguments){
  if (super.performAccessibilityAction(action,arguments)) {
    return true;
  }
switch (action) {
case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
{
      setRelativeFocusedTask(true,false,false);
      return true;
    }
case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
{
    setRelativeFocusedTask(false,false,false);
    return true;
  }
}
return false;
}","@Override public boolean performAccessibilityAction(int action,Bundle arguments){
  if (super.performAccessibilityAction(action,arguments)) {
    return true;
  }
  Task focusedTask=getAccessibilityFocusedTask();
  int taskIndex=mStack.indexOfStackTask(focusedTask);
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
switch (action) {
case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
{
        setFocusedTask(taskIndex + 1,true,true,0);
        return true;
      }
case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
{
      setFocusedTask(taskIndex - 1,true,true,0);
      return true;
    }
}
}
return false;
}",0.6254681647940075
191319,"@Override public void onReturnViewToPool(TaskView tv){
  final Task task=tv.getTask();
  unbindTaskView(tv,task);
  tv.resetViewProperties();
  tv.setFocusedState(false,false);
  tv.setClipViewInStack(false);
  if (mScreenPinningEnabled) {
    tv.hideActionButton(false,0,false,null);
  }
  detachViewFromParent(tv);
  updateTaskViewsList();
}","@Override public void onReturnViewToPool(TaskView tv){
  final Task task=tv.getTask();
  unbindTaskView(tv,task);
  tv.clearAccessibilityFocus();
  tv.resetViewProperties();
  tv.setFocusedState(false,false);
  tv.setClipViewInStack(false);
  if (mScreenPinningEnabled) {
    tv.hideActionButton(false,0,false,null);
  }
  detachViewFromParent(tv);
  updateTaskViewsList();
}",0.9554317548746518
191320,"@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  if (taskViewCount > 1 && mFocusedTask != null) {
    info.setScrollable(true);
    int focusedTaskIndex=mStack.indexOfStackTask(mFocusedTask);
    if (focusedTaskIndex > 0) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    }
    if (focusedTaskIndex < mStack.getTaskCount() - 1) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  if (taskViewCount > 1) {
    Task focusedTask=getAccessibilityFocusedTask();
    info.setScrollable(true);
    int focusedTaskIndex=mStack.indexOfStackTask(focusedTask);
    if (focusedTaskIndex > 0) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
    }
    if (0 <= focusedTaskIndex && focusedTaskIndex < mStack.getTaskCount() - 1) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    }
  }
}",0.65814696485623
191321,"private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      cancelNonDismissTaskAnimations();
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}","private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      cancelNonDismissTaskAnimations();
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
if (!mSv.mTouchExplorationEnabled) {
  mSv.resetFocusedTask(mSv.getFocusedTask());
}
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}",0.9955303608416004
191322,"/** 
 * Explicitly sets the focused state of this task.
 */
public void setFocusedState(boolean isFocused,boolean requestViewFocus){
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (isFocused) {
    if (requestViewFocus && !isFocused()) {
      requestFocus();
    }
    if (requestViewFocus && !isAccessibilityFocused() && ssp.isTouchExplorationEnabled()) {
      requestAccessibilityFocus();
    }
  }
 else {
    if (isAccessibilityFocused() && ssp.isTouchExplorationEnabled()) {
      clearAccessibilityFocus();
    }
  }
}","/** 
 * Explicitly sets the focused state of this task.
 */
public void setFocusedState(boolean isFocused,boolean requestViewFocus){
  if (isFocused) {
    if (requestViewFocus && !isFocused()) {
      requestFocus();
    }
  }
 else {
    if (isAccessibilityFocused() && mTouchExplorationEnabled) {
      clearAccessibilityFocus();
    }
  }
}",0.6455266138165345
191323,"@Override public void onTaskDataLoaded(Task task,ActivityManager.TaskThumbnailInfo thumbnailInfo){
  mThumbnailView.onTaskDataLoaded(thumbnailInfo);
  mHeaderView.onTaskDataLoaded();
  mTaskDataLoaded=true;
}","@Override public void onTaskDataLoaded(Task task,ActivityManager.TaskThumbnailInfo thumbnailInfo){
  mThumbnailView.onTaskDataLoaded(thumbnailInfo);
  mHeaderView.onTaskDataLoaded();
}",0.9387755102040816
191324,"@Override public void onTaskDataUnloaded(){
  mTask.removeCallback(this);
  mThumbnailView.unbindFromTask();
  mHeaderView.unbindFromTask(mTouchExplorationEnabled);
  mTaskDataLoaded=false;
}","@Override public void onTaskDataUnloaded(){
  mTask.removeCallback(this);
  mThumbnailView.unbindFromTask();
  mHeaderView.unbindFromTask(mTouchExplorationEnabled);
}",0.9299719887955182
191325,"/** 
 * Sets the   {@link #contentView} field to be a view with the standard ""Latest Event""layout. <p>Uses the  {@link #icon} and {@link #when} fields to set the icon and time fieldsin the view.</p>
 * @param context       The context for your application / activity.
 * @param contentTitle The title that goes in the expanded entry.
 * @param contentText  The text that goes in the expanded entry.
 * @param contentIntent The intent to launch when the user clicks the expanded notification.If this is an activity, it must include the {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag, which requiresthat you take care of task management as described in the <a href="" {@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html"">Tasks and Back Stack</a> document.
 * @deprecated Use {@link Builder} instead.
 * @removed
 */
@Deprecated public void setLatestEventInfo(Context context,CharSequence contentTitle,CharSequence contentText,PendingIntent contentIntent){
  if (context.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
    Log.e(TAG,""String_Node_Str"",new Throwable());
  }
  final Notification.Builder builder=new Notification.Builder(context,this);
  if (contentTitle != null) {
    builder.setContentTitle(contentTitle);
  }
  if (contentText != null) {
    builder.setContentText(contentText);
  }
  builder.setContentIntent(contentIntent);
  builder.build();
}","/** 
 * Sets the   {@link #contentView} field to be a view with the standard ""Latest Event""layout. <p>Uses the  {@link #icon} and {@link #when} fields to set the icon and time fieldsin the view.</p>
 * @param context       The context for your application / activity.
 * @param contentTitle The title that goes in the expanded entry.
 * @param contentText  The text that goes in the expanded entry.
 * @param contentIntent The intent to launch when the user clicks the expanded notification.If this is an activity, it must include the {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag, which requiresthat you take care of task management as described in the <a href="" {@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html"">Tasks and Back Stack</a> document.
 * @deprecated Use {@link Builder} instead.
 * @removed
 */
@Deprecated public void setLatestEventInfo(Context context,CharSequence contentTitle,CharSequence contentText,PendingIntent contentIntent){
  if (context.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
    Log.e(TAG,""String_Node_Str"",new Throwable());
  }
  if (context.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
    extras.putBoolean(EXTRA_SHOW_WHEN,true);
  }
  final Notification.Builder builder=new Notification.Builder(context,this);
  if (contentTitle != null) {
    builder.setContentTitle(contentTitle);
  }
  if (contentText != null) {
    builder.setContentText(contentText);
  }
  builder.setContentIntent(contentIntent);
  builder.build();
}",0.9565807327001355
191326,"/** 
 * Sets the   {@link #contentView} field to be a view with the standard ""Latest Event""layout. <p>Uses the  {@link #icon} and {@link #when} fields to set the icon and time fieldsin the view.</p>
 * @param context       The context for your application / activity.
 * @param contentTitle The title that goes in the expanded entry.
 * @param contentText  The text that goes in the expanded entry.
 * @param contentIntent The intent to launch when the user clicks the expanded notification.If this is an activity, it must include the {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag, which requiresthat you take care of task management as described in the <a href="" {@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html"">Tasks and Back Stack</a> document.
 * @deprecated Use {@link Builder} instead.
 * @removed
 */
@Deprecated public void setLatestEventInfo(Context context,CharSequence contentTitle,CharSequence contentText,PendingIntent contentIntent){
  if (context.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
    Log.e(TAG,""String_Node_Str"",new Throwable());
  }
  final Notification.Builder builder=new Notification.Builder(context,this);
  if (contentTitle != null) {
    builder.setContentTitle(contentTitle);
  }
  if (contentText != null) {
    builder.setContentText(contentText);
  }
  builder.setContentIntent(contentIntent);
  builder.build();
}","/** 
 * Sets the   {@link #contentView} field to be a view with the standard ""Latest Event""layout. <p>Uses the  {@link #icon} and {@link #when} fields to set the icon and time fieldsin the view.</p>
 * @param context       The context for your application / activity.
 * @param contentTitle The title that goes in the expanded entry.
 * @param contentText  The text that goes in the expanded entry.
 * @param contentIntent The intent to launch when the user clicks the expanded notification.If this is an activity, it must include the {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag, which requiresthat you take care of task management as described in the <a href="" {@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html"">Tasks and Back Stack</a> document.
 * @deprecated Use {@link Builder} instead.
 * @removed
 */
@Deprecated public void setLatestEventInfo(Context context,CharSequence contentTitle,CharSequence contentText,PendingIntent contentIntent){
  if (context.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
    Log.e(TAG,""String_Node_Str"",new Throwable());
  }
  if (context.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
    extras.putBoolean(EXTRA_SHOW_WHEN,true);
  }
  final Notification.Builder builder=new Notification.Builder(context,this);
  if (contentTitle != null) {
    builder.setContentTitle(contentTitle);
  }
  if (contentText != null) {
    builder.setContentText(contentText);
  }
  builder.setContentIntent(contentIntent);
  builder.build();
}",0.9565807327001355
191327,"/** 
 * Sets the   {@link #contentView} field to be a view with the standard ""Latest Event""layout. <p>Uses the  {@link #icon} and {@link #when} fields to set the icon and time fieldsin the view.</p>
 * @param context       The context for your application / activity.
 * @param contentTitle The title that goes in the expanded entry.
 * @param contentText  The text that goes in the expanded entry.
 * @param contentIntent The intent to launch when the user clicks the expanded notification.If this is an activity, it must include the {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag, which requiresthat you take care of task management as described in the <a href="" {@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html"">Tasks and Back Stack</a> document.
 * @deprecated Use {@link Builder} instead.
 * @removed
 */
@Deprecated public void setLatestEventInfo(Context context,CharSequence contentTitle,CharSequence contentText,PendingIntent contentIntent){
  if (context.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
    Log.e(TAG,""String_Node_Str"",new Throwable());
  }
  final Notification.Builder builder=new Notification.Builder(context,this);
  if (contentTitle != null) {
    builder.setContentTitle(contentTitle);
  }
  if (contentText != null) {
    builder.setContentText(contentText);
  }
  builder.setContentIntent(contentIntent);
  builder.build();
}","/** 
 * Sets the   {@link #contentView} field to be a view with the standard ""Latest Event""layout. <p>Uses the  {@link #icon} and {@link #when} fields to set the icon and time fieldsin the view.</p>
 * @param context       The context for your application / activity.
 * @param contentTitle The title that goes in the expanded entry.
 * @param contentText  The text that goes in the expanded entry.
 * @param contentIntent The intent to launch when the user clicks the expanded notification.If this is an activity, it must include the {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag, which requiresthat you take care of task management as described in the <a href="" {@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html"">Tasks and Back Stack</a> document.
 * @deprecated Use {@link Builder} instead.
 * @removed
 */
@Deprecated public void setLatestEventInfo(Context context,CharSequence contentTitle,CharSequence contentText,PendingIntent contentIntent){
  if (context.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
    Log.e(TAG,""String_Node_Str"",new Throwable());
  }
  if (context.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
    extras.putBoolean(EXTRA_SHOW_WHEN,true);
  }
  final Notification.Builder builder=new Notification.Builder(context,this);
  if (contentTitle != null) {
    builder.setContentTitle(contentTitle);
  }
  if (contentText != null) {
    builder.setContentText(contentText);
  }
  builder.setContentIntent(contentIntent);
  builder.build();
}",0.9565807327001355
191328,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  boolean dumpCheckin=false;
  boolean dumpCheckinFormat=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckin=dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpCheckinFormat) {
    dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
  }
 else   if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  boolean dumpCheckin=false;
  boolean dumpCheckinFormat=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckin=dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        if (dumpCheckinFormat) {
          dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
        }
 else {
          dumpBroadcastStatsLocked(fd,pw,args,opti,true,dumpPackage);
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpCheckinFormat) {
    dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
  }
 else   if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}",0.992878474615208
191329,"@Override public void run(){
  if (!isClosed()) {
    mDeviceCallback.onError(CameraDeviceImpl.this,CameraDeviceCallbacks.ERROR_CAMERA_SERVICE);
  }
}","@Override public void run(){
  if (!isClosed()) {
    mDeviceCallback.onError(CameraDeviceImpl.this,StateCallback.ERROR_CAMERA_SERVICE);
  }
}",0.952054794520548
191330,"/** 
 * Listener for binder death. <p> Handle binder death for ICameraDeviceUser. Trigger onError.</p>
 */
public void binderDied(){
  Log.w(TAG,""String_Node_Str"" + mCameraId + ""String_Node_Str"");
  if (mRemoteDevice == null) {
    return;
  }
  mInError=true;
  Runnable r=new Runnable(){
    @Override public void run(){
      if (!isClosed()) {
        mDeviceCallback.onError(CameraDeviceImpl.this,CameraDeviceCallbacks.ERROR_CAMERA_SERVICE);
      }
    }
  }
;
  CameraDeviceImpl.this.mDeviceHandler.post(r);
}","/** 
 * Listener for binder death. <p> Handle binder death for ICameraDeviceUser. Trigger onError.</p>
 */
public void binderDied(){
  Log.w(TAG,""String_Node_Str"" + mCameraId + ""String_Node_Str"");
  if (mRemoteDevice == null) {
    return;
  }
  mInError=true;
  Runnable r=new Runnable(){
    @Override public void run(){
      if (!isClosed()) {
        mDeviceCallback.onError(CameraDeviceImpl.this,StateCallback.ERROR_CAMERA_SERVICE);
      }
    }
  }
;
  CameraDeviceImpl.this.mDeviceHandler.post(r);
}",0.984375
191331,"@Override public void onDeviceError(final int errorCode,CaptureResultExtras resultExtras){
  if (DEBUG) {
    Log.d(TAG,String.format(""String_Node_Str"",errorCode,resultExtras.getFrameNumber(),resultExtras.getRequestId(),resultExtras.getSubsequenceId()));
  }
synchronized (mInterfaceLock) {
    if (mRemoteDevice == null) {
      return;
    }
switch (errorCode) {
case ERROR_CAMERA_DISCONNECTED:
      CameraDeviceImpl.this.mDeviceHandler.post(mCallOnDisconnected);
    break;
default :
  Log.e(TAG,""String_Node_Str"" + errorCode);
case ERROR_CAMERA_DEVICE:
case ERROR_CAMERA_SERVICE:
mInError=true;
Runnable r=new Runnable(){
@Override public void run(){
  if (!CameraDeviceImpl.this.isClosed()) {
    mDeviceCallback.onError(CameraDeviceImpl.this,errorCode);
  }
}
}
;
CameraDeviceImpl.this.mDeviceHandler.post(r);
break;
case ERROR_CAMERA_REQUEST:
case ERROR_CAMERA_RESULT:
case ERROR_CAMERA_BUFFER:
onCaptureErrorLocked(errorCode,resultExtras);
break;
}
}
}","@Override public void onDeviceError(final int errorCode,CaptureResultExtras resultExtras){
  if (DEBUG) {
    Log.d(TAG,String.format(""String_Node_Str"",errorCode,resultExtras.getFrameNumber(),resultExtras.getRequestId(),resultExtras.getSubsequenceId()));
  }
synchronized (mInterfaceLock) {
    if (mRemoteDevice == null) {
      return;
    }
switch (errorCode) {
case ERROR_CAMERA_DISCONNECTED:
      CameraDeviceImpl.this.mDeviceHandler.post(mCallOnDisconnected);
    break;
default :
  Log.e(TAG,""String_Node_Str"" + errorCode);
case ERROR_CAMERA_DEVICE:
case ERROR_CAMERA_SERVICE:
mInError=true;
final int publicErrorCode=(errorCode == ERROR_CAMERA_DEVICE) ? StateCallback.ERROR_CAMERA_DEVICE : StateCallback.ERROR_CAMERA_SERVICE;
Runnable r=new Runnable(){
@Override public void run(){
if (!CameraDeviceImpl.this.isClosed()) {
  mDeviceCallback.onError(CameraDeviceImpl.this,publicErrorCode);
}
}
}
;
CameraDeviceImpl.this.mDeviceHandler.post(r);
break;
case ERROR_CAMERA_REQUEST:
case ERROR_CAMERA_RESULT:
case ERROR_CAMERA_BUFFER:
onCaptureErrorLocked(errorCode,resultExtras);
break;
}
}
}",0.9071463296062228
191332,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  boolean dumpCheckin=false;
  boolean dumpCheckinFormat=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckin=dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpCheckinFormat) {
    dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
  }
 else   if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  boolean dumpCheckin=false;
  boolean dumpCheckinFormat=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckin=dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        if (dumpCheckinFormat) {
          dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
        }
 else {
          dumpBroadcastStatsLocked(fd,pw,args,opti,true,dumpPackage);
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpCheckinFormat) {
    dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
  }
 else   if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}",0.992878474615208
191333,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  boolean dumpCheckin=false;
  boolean dumpCheckinFormat=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckin=dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpCheckinFormat) {
    dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
  }
 else   if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  boolean dumpCheckin=false;
  boolean dumpCheckinFormat=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckin=dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        if (dumpCheckinFormat) {
          dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
        }
 else {
          dumpBroadcastStatsLocked(fd,pw,args,opti,true,dumpPackage);
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpCheckinFormat) {
    dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
  }
 else   if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}",0.992878474615208
191334,"public void performReceive(Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser){
  if (ActivityThread.DEBUG_BROADCAST) {
    int seq=intent.getIntExtra(""String_Node_Str"",-1);
    Slog.i(ActivityThread.TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ seq+ ""String_Node_Str""+ mReceiver);
  }
  Args args=new Args(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  if (!mActivityThread.post(args)) {
    if (mRegistered && ordered) {
      IActivityManager mgr=ActivityManagerNative.getDefault();
      if (ActivityThread.DEBUG_BROADCAST)       Slog.i(ActivityThread.TAG,""String_Node_Str"" + mReceiver);
      args.sendFinished(mgr);
    }
  }
}","public void performReceive(Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser){
  final Args args=new Args(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  if (intent == null) {
    Log.wtf(TAG,""String_Node_Str"");
  }
 else {
    if (ActivityThread.DEBUG_BROADCAST) {
      int seq=intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(ActivityThread.TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ seq+ ""String_Node_Str""+ mReceiver);
    }
  }
  if (intent == null || !mActivityThread.post(args)) {
    if (mRegistered && ordered) {
      IActivityManager mgr=ActivityManagerNative.getDefault();
      if (ActivityThread.DEBUG_BROADCAST)       Slog.i(ActivityThread.TAG,""String_Node_Str"" + mReceiver);
      args.sendFinished(mgr);
    }
  }
}",0.8246753246753247
191335,"public void performReceive(Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser){
  if (ActivityThread.DEBUG_BROADCAST) {
    int seq=intent.getIntExtra(""String_Node_Str"",-1);
    Slog.i(ActivityThread.TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ seq+ ""String_Node_Str""+ mReceiver);
  }
  Args args=new Args(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  if (!mActivityThread.post(args)) {
    if (mRegistered && ordered) {
      IActivityManager mgr=ActivityManagerNative.getDefault();
      if (ActivityThread.DEBUG_BROADCAST)       Slog.i(ActivityThread.TAG,""String_Node_Str"" + mReceiver);
      args.sendFinished(mgr);
    }
  }
}","public void performReceive(Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser){
  final Args args=new Args(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  if (intent == null) {
    Log.wtf(TAG,""String_Node_Str"");
  }
 else {
    if (ActivityThread.DEBUG_BROADCAST) {
      int seq=intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(ActivityThread.TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ seq+ ""String_Node_Str""+ mReceiver);
    }
  }
  if (intent == null || !mActivityThread.post(args)) {
    if (mRegistered && ordered) {
      IActivityManager mgr=ActivityManagerNative.getDefault();
      if (ActivityThread.DEBUG_BROADCAST)       Slog.i(ActivityThread.TAG,""String_Node_Str"" + mReceiver);
      args.sendFinished(mgr);
    }
  }
}",0.8246753246753247
191336,"public void performReceive(Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser){
  if (ActivityThread.DEBUG_BROADCAST) {
    int seq=intent.getIntExtra(""String_Node_Str"",-1);
    Slog.i(ActivityThread.TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ seq+ ""String_Node_Str""+ mReceiver);
  }
  Args args=new Args(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  if (!mActivityThread.post(args)) {
    if (mRegistered && ordered) {
      IActivityManager mgr=ActivityManagerNative.getDefault();
      if (ActivityThread.DEBUG_BROADCAST)       Slog.i(ActivityThread.TAG,""String_Node_Str"" + mReceiver);
      args.sendFinished(mgr);
    }
  }
}","public void performReceive(Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky,int sendingUser){
  final Args args=new Args(intent,resultCode,data,extras,ordered,sticky,sendingUser);
  if (intent == null) {
    Log.wtf(TAG,""String_Node_Str"");
  }
 else {
    if (ActivityThread.DEBUG_BROADCAST) {
      int seq=intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(ActivityThread.TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ seq+ ""String_Node_Str""+ mReceiver);
    }
  }
  if (intent == null || !mActivityThread.post(args)) {
    if (mRegistered && ordered) {
      IActivityManager mgr=ActivityManagerNative.getDefault();
      if (ActivityThread.DEBUG_BROADCAST)       Slog.i(ActivityThread.TAG,""String_Node_Str"" + mReceiver);
      args.sendFinished(mgr);
    }
  }
}",0.8246753246753247
191337,"@Override public CharSequence getAccessibilityClassName(){
  return TaskStackView.class.getName();
}","@Override public CharSequence getAccessibilityClassName(){
  return ScrollView.class.getName();
}",0.9441624365482234
191338,"/** 
 * Sets the focused task relative to the currently focused task.
 * @param forward whether to go to the next task in the stack (along the curve) or the previous
 * @param stackTasksOnly if set, will ensure that the traversal only goes along stack tasks, andif the currently focused task is not a stack task, will set the focus to the first visible stack task
 * @param animated determines whether to actually draw the highlight along with the change infocus.
 * @param cancelWindowAnimations if set, will attempt to cancel window animations if a scrollhappens.
 * @param timerIndicatorDuration the duration to initialize the auto-advance timer indicator
 */
public void setRelativeFocusedTask(boolean forward,boolean stackTasksOnly,boolean animated,boolean cancelWindowAnimations,int timerIndicatorDuration){
  int newIndex=mStack.indexOfStackTask(mFocusedTask);
  if (mFocusedTask != null) {
    if (stackTasksOnly) {
      List<Task> tasks=mStack.getStackTasks();
      if (mFocusedTask.isFreeformTask()) {
        TaskView tv=getFrontMostTaskView(stackTasksOnly);
        if (tv != null) {
          newIndex=mStack.indexOfStackTask(tv.getTask());
        }
      }
 else {
        int tmpNewIndex=newIndex + (forward ? -1 : 1);
        if (0 <= tmpNewIndex && tmpNewIndex < tasks.size()) {
          Task t=tasks.get(tmpNewIndex);
          if (!t.isFreeformTask()) {
            newIndex=tmpNewIndex;
          }
        }
      }
    }
 else {
      int taskCount=mStack.getTaskCount();
      newIndex=(newIndex + (forward ? -1 : 1) + taskCount) % taskCount;
    }
  }
 else {
    float stackScroll=mStackScroller.getStackScroll();
    ArrayList<Task> tasks=mStack.getStackTasks();
    int taskCount=tasks.size();
    if (forward) {
      for (newIndex=taskCount - 1; newIndex >= 0; newIndex--) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) <= 0) {
          break;
        }
      }
    }
 else {
      for (newIndex=0; newIndex < taskCount; newIndex++) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) >= 0) {
          break;
        }
      }
    }
  }
  if (newIndex != -1) {
    boolean willScroll=setFocusedTask(newIndex,true,true,timerIndicatorDuration);
    if (willScroll && cancelWindowAnimations) {
      EventBus.getDefault().send(new CancelEnterRecentsWindowAnimationEvent(null));
    }
  }
}","/** 
 * Sets the focused task relative to the currently focused task.
 * @param forward whether to go to the next task in the stack (along the curve) or the previous
 * @param stackTasksOnly if set, will ensure that the traversal only goes along stack tasks, andif the currently focused task is not a stack task, will set the focus to the first visible stack task
 * @param animated determines whether to actually draw the highlight along with the change infocus.
 * @param cancelWindowAnimations if set, will attempt to cancel window animations if a scrollhappens.
 * @param timerIndicatorDuration the duration to initialize the auto-advance timer indicator
 */
public void setRelativeFocusedTask(boolean forward,boolean stackTasksOnly,boolean animated,boolean cancelWindowAnimations,int timerIndicatorDuration){
  Task focusedTask=getFocusedTask();
  int newIndex=mStack.indexOfStackTask(focusedTask);
  if (focusedTask != null) {
    if (stackTasksOnly) {
      List<Task> tasks=mStack.getStackTasks();
      if (focusedTask.isFreeformTask()) {
        TaskView tv=getFrontMostTaskView(stackTasksOnly);
        if (tv != null) {
          newIndex=mStack.indexOfStackTask(tv.getTask());
        }
      }
 else {
        int tmpNewIndex=newIndex + (forward ? -1 : 1);
        if (0 <= tmpNewIndex && tmpNewIndex < tasks.size()) {
          Task t=tasks.get(tmpNewIndex);
          if (!t.isFreeformTask()) {
            newIndex=tmpNewIndex;
          }
        }
      }
    }
 else {
      int taskCount=mStack.getTaskCount();
      newIndex=(newIndex + (forward ? -1 : 1) + taskCount) % taskCount;
    }
  }
 else {
    float stackScroll=mStackScroller.getStackScroll();
    ArrayList<Task> tasks=mStack.getStackTasks();
    int taskCount=tasks.size();
    if (forward) {
      for (newIndex=taskCount - 1; newIndex >= 0; newIndex--) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) <= 0) {
          break;
        }
      }
    }
 else {
      for (newIndex=0; newIndex < taskCount; newIndex++) {
        float taskP=mLayoutAlgorithm.getStackScrollForTask(tasks.get(newIndex));
        if (Float.compare(taskP,stackScroll) >= 0) {
          break;
        }
      }
    }
  }
  if (newIndex != -1) {
    boolean willScroll=setFocusedTask(newIndex,true,true,timerIndicatorDuration);
    if (willScroll && cancelWindowAnimations) {
      EventBus.getDefault().send(new CancelEnterRecentsWindowAnimationEvent(null));
    }
  }
}",0.9907815631262524
191339,"/** 
 * Synchronizes the set of children   {@link TaskView}s to match the visible set of tasks in the current   {@link TaskStack}. This call does not continue on to update their position to the computed   {@link TaskViewTransform}s of the visible range, but only ensures that they will be added/removed from the view hierarchy and placed in the correct Z order and initial position (if not currently on screen).
 * @param targetStackScroll If provided, will ensure that the set of visible {@link TaskView}s includes those visible at the current stack scroll, and all at the target stack scroll.
 * @param ignoreTaskOverrides If set, the visible task computation will get the transforms fortasks at their non-overridden task progress
 */
void bindVisibleTaskViews(float targetStackScroll,boolean ignoreTaskOverrides){
  ArrayList<Task> tasks=mStack.getStackTasks();
  int[] visibleTaskRange=computeVisibleTaskTransforms(mCurrentTaskTransforms,tasks,mStackScroller.getStackScroll(),targetStackScroll,mIgnoreTasks,ignoreTaskOverrides);
  mTmpTaskViewMap.clear();
  List<TaskView> taskViews=getTaskViews();
  int lastFocusedTaskIndex=-1;
  int taskViewCount=taskViews.size();
  for (int i=taskViewCount - 1; i >= 0; i--) {
    TaskView tv=taskViews.get(i);
    Task task=tv.getTask();
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    int taskIndex=mStack.indexOfStackTask(task);
    TaskViewTransform transform=null;
    if (taskIndex != -1) {
      transform=mCurrentTaskTransforms.get(taskIndex);
    }
    if (task.isFreeformTask() || (transform != null && transform.visible)) {
      mTmpTaskViewMap.put(task.key,tv);
    }
 else {
      if (mTouchExplorationEnabled) {
        lastFocusedTaskIndex=taskIndex;
        resetFocusedTask(task);
      }
      mViewPool.returnViewToPool(tv);
    }
  }
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    TaskViewTransform transform=mCurrentTaskTransforms.get(i);
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    if (!task.isFreeformTask() && !transform.visible) {
      continue;
    }
    TaskView tv=mTmpTaskViewMap.get(task.key);
    if (tv == null) {
      tv=mViewPool.pickUpViewFromPool(task,task);
      if (task.isFreeformTask()) {
        updateTaskViewToTransform(tv,transform,AnimationProps.IMMEDIATE);
      }
 else {
        if (transform.rect.top <= mLayoutAlgorithm.mStackRect.top) {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getBackOfStackTransform(),AnimationProps.IMMEDIATE);
        }
 else {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getFrontOfStackTransform(),AnimationProps.IMMEDIATE);
        }
      }
    }
 else {
      final int taskIndex=mStack.indexOfStackTask(task);
      final int insertIndex=findTaskViewInsertIndex(task,taskIndex);
      if (insertIndex != getTaskViews().indexOf(tv)) {
        detachViewFromParent(tv);
        attachViewToParent(tv,insertIndex,tv.getLayoutParams());
        updateTaskViewsList();
      }
    }
  }
  if (lastFocusedTaskIndex != -1) {
    if (lastFocusedTaskIndex < visibleTaskRange[1]) {
      setFocusedTask(visibleTaskRange[1],false,true);
    }
 else {
      setFocusedTask(visibleTaskRange[0],false,true);
    }
  }
}","/** 
 * Synchronizes the set of children   {@link TaskView}s to match the visible set of tasks in the current   {@link TaskStack}. This call does not continue on to update their position to the computed   {@link TaskViewTransform}s of the visible range, but only ensures that they will be added/removed from the view hierarchy and placed in the correct Z order and initial position (if not currently on screen).
 * @param targetStackScroll If provided, will ensure that the set of visible {@link TaskView}s includes those visible at the current stack scroll, and all at the target stack scroll.
 * @param ignoreTaskOverrides If set, the visible task computation will get the transforms fortasks at their non-overridden task progress
 */
void bindVisibleTaskViews(float targetStackScroll,boolean ignoreTaskOverrides){
  ArrayList<Task> tasks=mStack.getStackTasks();
  int[] visibleTaskRange=computeVisibleTaskTransforms(mCurrentTaskTransforms,tasks,mStackScroller.getStackScroll(),targetStackScroll,mIgnoreTasks,ignoreTaskOverrides);
  mTmpTaskViewMap.clear();
  List<TaskView> taskViews=getTaskViews();
  int lastFocusedTaskIndex=-1;
  int taskViewCount=taskViews.size();
  for (int i=taskViewCount - 1; i >= 0; i--) {
    TaskView tv=taskViews.get(i);
    Task task=tv.getTask();
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    int taskIndex=mStack.indexOfStackTask(task);
    TaskViewTransform transform=null;
    if (taskIndex != -1) {
      transform=mCurrentTaskTransforms.get(taskIndex);
    }
    if (task.isFreeformTask() || (transform != null && transform.visible)) {
      mTmpTaskViewMap.put(task.key,tv);
    }
 else {
      if (mTouchExplorationEnabled && Utilities.isDescendentAccessibilityFocused(tv)) {
        lastFocusedTaskIndex=taskIndex;
        resetFocusedTask(task);
      }
      mViewPool.returnViewToPool(tv);
    }
  }
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    TaskViewTransform transform=mCurrentTaskTransforms.get(i);
    if (mIgnoreTasks.contains(task.key)) {
      continue;
    }
    if (!task.isFreeformTask() && !transform.visible) {
      continue;
    }
    TaskView tv=mTmpTaskViewMap.get(task.key);
    if (tv == null) {
      tv=mViewPool.pickUpViewFromPool(task,task);
      if (task.isFreeformTask()) {
        updateTaskViewToTransform(tv,transform,AnimationProps.IMMEDIATE);
      }
 else {
        if (transform.rect.top <= mLayoutAlgorithm.mStackRect.top) {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getBackOfStackTransform(),AnimationProps.IMMEDIATE);
        }
 else {
          updateTaskViewToTransform(tv,mLayoutAlgorithm.getFrontOfStackTransform(),AnimationProps.IMMEDIATE);
        }
      }
    }
 else {
      final int taskIndex=mStack.indexOfStackTask(task);
      final int insertIndex=findTaskViewInsertIndex(task,taskIndex);
      if (insertIndex != getTaskViews().indexOf(tv)) {
        detachViewFromParent(tv);
        attachViewToParent(tv,insertIndex,tv.getLayoutParams());
        updateTaskViewsList();
      }
    }
  }
  if (lastFocusedTaskIndex != -1) {
    int newFocusedTaskIndex=(lastFocusedTaskIndex < visibleTaskRange[1]) ? visibleTaskRange[1] : visibleTaskRange[0];
    setFocusedTask(newFocusedTaskIndex,false,true);
    TaskView focusedTaskView=getChildViewForTask(mFocusedTask);
    if (focusedTaskView != null) {
      focusedTaskView.requestAccessibilityFocus();
    }
  }
}",0.9486332231901472
191340,"@Override public boolean performAccessibilityAction(int action,Bundle arguments){
  if (super.performAccessibilityAction(action,arguments)) {
    return true;
  }
switch (action) {
case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
{
      setRelativeFocusedTask(true,false,false);
      return true;
    }
case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
{
    setRelativeFocusedTask(false,false,false);
    return true;
  }
}
return false;
}","@Override public boolean performAccessibilityAction(int action,Bundle arguments){
  if (super.performAccessibilityAction(action,arguments)) {
    return true;
  }
  Task focusedTask=getAccessibilityFocusedTask();
  int taskIndex=mStack.indexOfStackTask(focusedTask);
  if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
switch (action) {
case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
{
        setFocusedTask(taskIndex + 1,true,true,0);
        return true;
      }
case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
{
      setFocusedTask(taskIndex - 1,true,true,0);
      return true;
    }
}
}
return false;
}",0.6254681647940075
191341,"@Override public void onReturnViewToPool(TaskView tv){
  final Task task=tv.getTask();
  unbindTaskView(tv,task);
  tv.resetViewProperties();
  tv.setFocusedState(false,false);
  tv.setClipViewInStack(false);
  if (mScreenPinningEnabled) {
    tv.hideActionButton(false,0,false,null);
  }
  detachViewFromParent(tv);
  updateTaskViewsList();
}","@Override public void onReturnViewToPool(TaskView tv){
  final Task task=tv.getTask();
  unbindTaskView(tv,task);
  tv.clearAccessibilityFocus();
  tv.resetViewProperties();
  tv.setFocusedState(false,false);
  tv.setClipViewInStack(false);
  if (mScreenPinningEnabled) {
    tv.hideActionButton(false,0,false,null);
  }
  detachViewFromParent(tv);
  updateTaskViewsList();
}",0.9554317548746518
191342,"@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  if (taskViewCount > 1 && mFocusedTask != null) {
    info.setScrollable(true);
    int focusedTaskIndex=mStack.indexOfStackTask(mFocusedTask);
    if (focusedTaskIndex > 0) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    }
    if (focusedTaskIndex < mStack.getTaskCount() - 1) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  if (taskViewCount > 1) {
    Task focusedTask=getAccessibilityFocusedTask();
    info.setScrollable(true);
    int focusedTaskIndex=mStack.indexOfStackTask(focusedTask);
    if (focusedTaskIndex > 0) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
    }
    if (0 <= focusedTaskIndex && focusedTaskIndex < mStack.getTaskCount() - 1) {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    }
  }
}",0.65814696485623
191343,"private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      cancelNonDismissTaskAnimations();
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}","private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      cancelNonDismissTaskAnimations();
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
if (!mSv.mTouchExplorationEnabled) {
  mSv.resetFocusedTask(mSv.getFocusedTask());
}
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}",0.9955303608416004
191344,"/** 
 * Explicitly sets the focused state of this task.
 */
public void setFocusedState(boolean isFocused,boolean requestViewFocus){
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (isFocused) {
    if (requestViewFocus && !isFocused()) {
      requestFocus();
    }
    if (requestViewFocus && !isAccessibilityFocused() && ssp.isTouchExplorationEnabled()) {
      requestAccessibilityFocus();
    }
  }
 else {
    if (isAccessibilityFocused() && ssp.isTouchExplorationEnabled()) {
      clearAccessibilityFocus();
    }
  }
}","/** 
 * Explicitly sets the focused state of this task.
 */
public void setFocusedState(boolean isFocused,boolean requestViewFocus){
  if (isFocused) {
    if (requestViewFocus && !isFocused()) {
      requestFocus();
    }
  }
 else {
    if (isAccessibilityFocused() && mTouchExplorationEnabled) {
      clearAccessibilityFocus();
    }
  }
}",0.6455266138165345
191345,"@Override public void onTaskDataLoaded(Task task,ActivityManager.TaskThumbnailInfo thumbnailInfo){
  mThumbnailView.onTaskDataLoaded(thumbnailInfo);
  mHeaderView.onTaskDataLoaded();
  mTaskDataLoaded=true;
}","@Override public void onTaskDataLoaded(Task task,ActivityManager.TaskThumbnailInfo thumbnailInfo){
  mThumbnailView.onTaskDataLoaded(thumbnailInfo);
  mHeaderView.onTaskDataLoaded();
}",0.9387755102040816
191346,"@Override public void onTaskDataUnloaded(){
  mTask.removeCallback(this);
  mThumbnailView.unbindFromTask();
  mHeaderView.unbindFromTask(mTouchExplorationEnabled);
  mTaskDataLoaded=false;
}","@Override public void onTaskDataUnloaded(){
  mTask.removeCallback(this);
  mThumbnailView.unbindFromTask();
  mHeaderView.unbindFromTask(mTouchExplorationEnabled);
}",0.9299719887955182
191347,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(category);
  out.writeInt(id);
  out.writeInt(minTimeMs);
  out.writeInt(maxTimeMs);
  out.writeInt(averageTimeMs);
  out.writeLong(sampleCount);
  if (initialTimings == null) {
    out.writeInt(ABSENT);
  }
 else {
    out.writeInt(PRESENT);
    out.writeIntArray(initialTimings);
  }
  out.writeInt(bucketCount);
  out.writeIntArray(bucketEndPoints);
  out.writeIntArray(bucketCounters);
}","public void writeToParcel(Parcel out,int flags){
  out.writeInt(category);
  out.writeInt(id);
  out.writeInt(minTimeMs);
  out.writeInt(maxTimeMs);
  out.writeInt(averageTimeMs);
  out.writeInt(sampleCount);
  if (initialTimings == null) {
    out.writeInt(ABSENT);
  }
 else {
    out.writeInt(PRESENT);
    out.writeIntArray(initialTimings);
  }
  out.writeInt(bucketCount);
  out.writeIntArray(bucketEndPoints);
  out.writeIntArray(bucketCounters);
}",0.9922992299229924
191348,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(category);
  out.writeInt(id);
  out.writeInt(minTimeMs);
  out.writeInt(maxTimeMs);
  out.writeInt(averageTimeMs);
  out.writeLong(sampleCount);
  if (initialTimings == null) {
    out.writeInt(ABSENT);
  }
 else {
    out.writeInt(PRESENT);
    out.writeIntArray(initialTimings);
  }
  out.writeInt(bucketCount);
  out.writeIntArray(bucketEndPoints);
  out.writeIntArray(bucketCounters);
}","public void writeToParcel(Parcel out,int flags){
  out.writeInt(category);
  out.writeInt(id);
  out.writeInt(minTimeMs);
  out.writeInt(maxTimeMs);
  out.writeInt(averageTimeMs);
  out.writeInt(sampleCount);
  if (initialTimings == null) {
    out.writeInt(ABSENT);
  }
 else {
    out.writeInt(PRESENT);
    out.writeIntArray(initialTimings);
  }
  out.writeInt(bucketCount);
  out.writeIntArray(bucketEndPoints);
  out.writeIntArray(bucketCounters);
}",0.9922992299229924
191349,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(category);
  out.writeInt(id);
  out.writeInt(minTimeMs);
  out.writeInt(maxTimeMs);
  out.writeInt(averageTimeMs);
  out.writeLong(sampleCount);
  if (initialTimings == null) {
    out.writeInt(ABSENT);
  }
 else {
    out.writeInt(PRESENT);
    out.writeIntArray(initialTimings);
  }
  out.writeInt(bucketCount);
  out.writeIntArray(bucketEndPoints);
  out.writeIntArray(bucketCounters);
}","public void writeToParcel(Parcel out,int flags){
  out.writeInt(category);
  out.writeInt(id);
  out.writeInt(minTimeMs);
  out.writeInt(maxTimeMs);
  out.writeInt(averageTimeMs);
  out.writeInt(sampleCount);
  if (initialTimings == null) {
    out.writeInt(ABSENT);
  }
 else {
    out.writeInt(PRESENT);
    out.writeIntArray(initialTimings);
  }
  out.writeInt(bucketCount);
  out.writeIntArray(bucketEndPoints);
  out.writeIntArray(bucketCounters);
}",0.9922992299229924
191350,"@Override public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfoInternal(info);
  final int scrollRange=getScrollRange();
  if (scrollRange > 0) {
    info.setScrollable(true);
    if (mScrollY > 0) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_UP);
    }
    if (mScrollY < scrollRange) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_DOWN);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfoInternal(info);
  final int scrollRange=getScrollRange();
  if (scrollRange > 0) {
    info.setScrollable(true);
    if (mScrollY > 0) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_UP);
    }
    if (mScrollY < scrollRange) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_DOWN);
    }
  }
  info.setClassName(ScrollView.class.getName());
}",0.9643636363636364
191351,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  boolean dumpCheckin=false;
  boolean dumpCheckinFormat=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckin=dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpCheckinFormat) {
    dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
  }
 else   if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}",0.8665748302666535
191352,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.9932430268677748
191353,"static void dumpHelp(PrintWriter pw,boolean dumping){
  if (dumping) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
  }
}","static void dumpHelp(PrintWriter pw,boolean dumping){
  if (dumping) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
  }
}",0.9700085689802912
191354,"final void processNextBroadcast(boolean fromMsg){
synchronized (mService) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mParallelBroadcasts.size()+ ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    mService.updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      r.dispatchClockTime=System.currentTimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ target+ ""String_Node_Str""+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false,i);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp);
      boolean isDead;
synchronized (mService.mPidsSelfLocked) {
        ProcessRecord proc=mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);
        isDead=proc == null || proc.crashing;
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp+ ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        mService.scheduleAppGcsLocked();
        if (looped) {
          mService.updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mService.mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ ""String_Node_Str""+ now+ ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.state+ ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST)             Slog.i(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent.getAction()+ ""String_Node_Str""+ r.callerApp);
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false,r.userId);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            r.resultTo=null;
            Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      r.dispatchClockTime=System.currentTimeMillis();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + mTimeoutPeriod;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    final BroadcastOptions brOptions=r.options;
    final Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ filter+ ""String_Node_Str""+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered,recIdx);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.ordered+ ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
 else {
        if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
          scheduleTempWhitelistLocked(filter.owningUid,brOptions.getTemporaryAppWhitelistDuration(),r);
        }
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    ComponentName component=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    boolean skip=false;
    if (brOptions != null && (info.activityInfo.applicationInfo.targetSdkVersion < brOptions.getMinManifestReceiverApiLevel() || info.activityInfo.applicationInfo.targetSdkVersion > brOptions.getMaxManifestReceiverApiLevel())) {
      skip=true;
    }
    int perm=mService.checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (!skip && perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ component.flattenToShortString());
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ component.flattenToShortString());
      }
      skip=true;
    }
 else     if (!skip && info.activityInfo.permission != null) {
      final int opCode=AppOpsManager.permissionToOpCode(info.activityInfo.permission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(info.activityInfo.permission)+ ""String_Node_Str""+ component.flattenToShortString());
        skip=true;
      }
    }
    if (!skip && info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
      for (int i=0; i < r.requiredPermissions.length; i++) {
        String requiredPermission=r.requiredPermissions[i];
        try {
          perm=AppGlobals.getPackageManager().checkPermission(requiredPermission,info.activityInfo.applicationInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
        }
 catch (        RemoteException e) {
          perm=PackageManager.PERMISSION_DENIED;
        }
        if (perm != PackageManager.PERMISSION_GRANTED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
        int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
        if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
      }
    }
    if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      skip=!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,info.activityInfo.applicationInfo.uid);
    }
    boolean isSingleton=false;
    try {
      isSingleton=mService.isSingleton(info.activityInfo.processName,info.activityInfo.applicationInfo,info.activityInfo.name,info.activityInfo.flags);
    }
 catch (    SecurityException e) {
      Slog.w(TAG,e.getMessage());
      skip=true;
    }
    if ((info.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
      if (ActivityManager.checkUidPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + component.flattenToShortString() + ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS);
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      boolean isAvailable=false;
      try {
        isAvailable=AppGlobals.getPackageManager().isPackageAvailable(info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + info.activityInfo.packageName,e);
      }
      if (!isAvailable) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + info.activityInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (Build.PERMISSIONS_REVIEW_REQUIRED && !skip) {
      if (!requestStartTargetPermissionsReviewIfNeededLocked(r,info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid))) {
        skip=true;
      }
    }
    final int receiverUid=info.activityInfo.applicationInfo.uid;
    if (r.callingUid != Process.SYSTEM_UID && isSingleton && mService.isValidSingletonCall(r.callingUid,receiverUid)) {
      info.activityInfo=mService.getActivityInfoForUser(info.activityInfo,0);
    }
    String targetProcess=info.activityInfo.processName;
    ProcessRecord app=mService.getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid,false);
    if (!skip) {
      final int allowed=mService.checkAllowBackgroundLocked(info.activityInfo.applicationInfo.uid,info.activityInfo.packageName,-1,false);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
 else         if (((r.intent.getFlags() & Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null && r.intent.getPackage() == null && ((r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
      }
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str"");
      r.delivery[recIdx]=BroadcastRecord.DELIVERY_SKIPPED;
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.delivery[recIdx]=BroadcastRecord.DELIVERY_DELIVERED;
    r.state=BroadcastRecord.APP_RECEIVE;
    r.curComponent=component;
    r.curReceiver=info.activityInfo;
    if (DEBUG_MU && r.callingUid > UserHandle.PER_USER_RANGE) {
      Slog.v(TAG_MU,""String_Node_Str"" + info.activityInfo + ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid);
    }
    if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
      scheduleTempWhitelistLocked(receiverUid,brOptions.getTemporaryAppWhitelistDuration(),r);
    }
    try {
      AppGlobals.getPackageManager().setPackageStoppedState(r.curComponent.getPackageName(),false,UserHandle.getUserId(r.callingUid));
    }
 catch (    RemoteException e) {
    }
catch (    IllegalArgumentException e) {
      Slog.w(TAG,""String_Node_Str"" + r.curComponent.getPackageName() + ""String_Node_Str""+ e);
    }
    if (app != null && app.thread != null) {
      try {
        app.addPackage(info.activityInfo.packageName,info.activityInfo.applicationInfo.versionCode,mService.mProcessStats);
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
catch (      RuntimeException e) {
        Slog.wtf(TAG,""String_Node_Str"" + r.curComponent + ""String_Node_Str""+ r.intent,e);
        logBroadcastReceiverDiscardLocked(r);
        finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
        scheduleBroadcastsLocked();
        r.state=BroadcastRecord.IDLE;
        return;
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ targetProcess+ ""String_Node_Str""+ r);
    if ((r.curApp=mService.startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0,false,false)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}","final void processNextBroadcast(boolean fromMsg){
synchronized (mService) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mParallelBroadcasts.size()+ ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    mService.updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      r.dispatchClockTime=System.currentTimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ target+ ""String_Node_Str""+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false,i);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp);
      boolean isDead;
synchronized (mService.mPidsSelfLocked) {
        ProcessRecord proc=mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);
        isDead=proc == null || proc.crashing;
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp+ ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        mService.scheduleAppGcsLocked();
        if (looped) {
          mService.updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mService.mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ ""String_Node_Str""+ now+ ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.state+ ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST)             Slog.i(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent.getAction()+ ""String_Node_Str""+ r.callerApp);
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false,r.userId);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            r.resultTo=null;
            Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        if (r.intent.getComponent() == null && r.intent.getPackage() == null && (r.intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
          mService.addBroadcastStatLocked(r.intent.getAction(),r.callerPackage,r.manifestCount,r.manifestSkipCount,r.finishTime - r.dispatchTime);
        }
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      r.dispatchClockTime=System.currentTimeMillis();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + mTimeoutPeriod;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    final BroadcastOptions brOptions=r.options;
    final Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ filter+ ""String_Node_Str""+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered,recIdx);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.ordered+ ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
 else {
        if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
          scheduleTempWhitelistLocked(filter.owningUid,brOptions.getTemporaryAppWhitelistDuration(),r);
        }
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    ComponentName component=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    boolean skip=false;
    if (brOptions != null && (info.activityInfo.applicationInfo.targetSdkVersion < brOptions.getMinManifestReceiverApiLevel() || info.activityInfo.applicationInfo.targetSdkVersion > brOptions.getMaxManifestReceiverApiLevel())) {
      skip=true;
    }
    int perm=mService.checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (!skip && perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ component.flattenToShortString());
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ component.flattenToShortString());
      }
      skip=true;
    }
 else     if (!skip && info.activityInfo.permission != null) {
      final int opCode=AppOpsManager.permissionToOpCode(info.activityInfo.permission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(info.activityInfo.permission)+ ""String_Node_Str""+ component.flattenToShortString());
        skip=true;
      }
    }
    if (!skip && info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
      for (int i=0; i < r.requiredPermissions.length; i++) {
        String requiredPermission=r.requiredPermissions[i];
        try {
          perm=AppGlobals.getPackageManager().checkPermission(requiredPermission,info.activityInfo.applicationInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
        }
 catch (        RemoteException e) {
          perm=PackageManager.PERMISSION_DENIED;
        }
        if (perm != PackageManager.PERMISSION_GRANTED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
        int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
        if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
      }
    }
    if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      skip=!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,info.activityInfo.applicationInfo.uid);
    }
    boolean isSingleton=false;
    try {
      isSingleton=mService.isSingleton(info.activityInfo.processName,info.activityInfo.applicationInfo,info.activityInfo.name,info.activityInfo.flags);
    }
 catch (    SecurityException e) {
      Slog.w(TAG,e.getMessage());
      skip=true;
    }
    if ((info.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
      if (ActivityManager.checkUidPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + component.flattenToShortString() + ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS);
        skip=true;
      }
    }
    if (!skip) {
      r.manifestCount++;
    }
 else {
      r.manifestSkipCount++;
    }
    if (r.curApp != null && r.curApp.crashing) {
      Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      boolean isAvailable=false;
      try {
        isAvailable=AppGlobals.getPackageManager().isPackageAvailable(info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + info.activityInfo.packageName,e);
      }
      if (!isAvailable) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + info.activityInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (Build.PERMISSIONS_REVIEW_REQUIRED && !skip) {
      if (!requestStartTargetPermissionsReviewIfNeededLocked(r,info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid))) {
        skip=true;
      }
    }
    final int receiverUid=info.activityInfo.applicationInfo.uid;
    if (r.callingUid != Process.SYSTEM_UID && isSingleton && mService.isValidSingletonCall(r.callingUid,receiverUid)) {
      info.activityInfo=mService.getActivityInfoForUser(info.activityInfo,0);
    }
    String targetProcess=info.activityInfo.processName;
    ProcessRecord app=mService.getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid,false);
    if (!skip) {
      final int allowed=mService.checkAllowBackgroundLocked(info.activityInfo.applicationInfo.uid,info.activityInfo.packageName,-1,false);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
 else         if (((r.intent.getFlags() & Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null && r.intent.getPackage() == null && ((r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
      }
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str"");
      r.delivery[recIdx]=BroadcastRecord.DELIVERY_SKIPPED;
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.delivery[recIdx]=BroadcastRecord.DELIVERY_DELIVERED;
    r.state=BroadcastRecord.APP_RECEIVE;
    r.curComponent=component;
    r.curReceiver=info.activityInfo;
    if (DEBUG_MU && r.callingUid > UserHandle.PER_USER_RANGE) {
      Slog.v(TAG_MU,""String_Node_Str"" + info.activityInfo + ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid);
    }
    if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
      scheduleTempWhitelistLocked(receiverUid,brOptions.getTemporaryAppWhitelistDuration(),r);
    }
    try {
      AppGlobals.getPackageManager().setPackageStoppedState(r.curComponent.getPackageName(),false,UserHandle.getUserId(r.callingUid));
    }
 catch (    RemoteException e) {
    }
catch (    IllegalArgumentException e) {
      Slog.w(TAG,""String_Node_Str"" + r.curComponent.getPackageName() + ""String_Node_Str""+ e);
    }
    if (app != null && app.thread != null) {
      try {
        app.addPackage(info.activityInfo.packageName,info.activityInfo.applicationInfo.versionCode,mService.mProcessStats);
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
catch (      RuntimeException e) {
        Slog.wtf(TAG,""String_Node_Str"" + r.curComponent + ""String_Node_Str""+ r.intent,e);
        logBroadcastReceiverDiscardLocked(r);
        finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
        scheduleBroadcastsLocked();
        r.state=BroadcastRecord.IDLE;
        return;
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ targetProcess+ ""String_Node_Str""+ r);
    if ((r.curApp=mService.startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0,false,false)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}",0.987507473488782
191355,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  boolean dumpAll=false;
  boolean dumpClient=false;
  boolean dumpCheckin=false;
  boolean dumpCheckinFormat=false;
  String dumpPackage=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
      dumpAll=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      if (opti < args.length) {
        dumpPackage=args[opti];
        opti++;
      }
 else {
        pw.println(""String_Node_Str"");
        return;
      }
      dumpClient=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckin=dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      dumpCheckinFormat=true;
    }
 else     if (""String_Node_Str"".equals(opt)) {
      ActivityManagerShellCommand.dumpHelp(pw,true);
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  long origId=Binder.clearCallingIdentity();
  boolean more=false;
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpActivitiesLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpRecentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpPendingIntentsLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
synchronized (this) {
        dumpProcessesLocked(fd,pw,args,opti,true,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpOomLocked(fd,pw,args,opti,true);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpPermissionsLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!dumpProvider(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpProvidersLocked(fd,pw,args,opti,true,null);
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      String name;
      if (opti >= args.length) {
        name=null;
        newArgs=EMPTY_STRING_ARRAY;
      }
 else {
        name=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
      }
      if (!mServices.dumpService(fd,pw,name,newArgs,0,dumpAll)) {
        pw.println(""String_Node_Str"" + name);
        pw.println(""String_Node_Str"");
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      String[] newArgs;
      if (opti >= args.length) {
        pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
      }
 else {
        dumpPackage=args[opti];
        opti++;
        newArgs=new String[args.length - opti];
        if (args.length > 2)         System.arraycopy(args,opti,newArgs,0,args.length - opti);
        args=newArgs;
        opti=0;
        more=true;
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
synchronized (this) {
        dumpAssociationsLocked(fd,pw,args,opti,true,dumpClient,dumpPackage);
      }
    }
 else     if (""String_Node_Str"".equals(cmd) || ""String_Node_Str"".equals(cmd)) {
      if (dumpClient) {
        ActiveServices.ServiceDumper dumper;
synchronized (this) {
          dumper=mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage);
        }
        dumper.dumpWithClient();
      }
 else {
synchronized (this) {
          mServices.newServiceDumperLocked(fd,pw,args,opti,true,dumpPackage).dumpLocked();
        }
      }
    }
 else     if (""String_Node_Str"".equals(cmd)) {
      LockGuard.dump(fd,pw,args);
    }
 else {
      if (!dumpActivity(fd,pw,cmd,args,opti,dumpAll)) {
        ActivityManagerShellCommand shell=new ActivityManagerShellCommand(this,true);
        int res=shell.exec(this,null,fd,null,args,new ResultReceiver(null));
        if (res < 0) {
          pw.println(""String_Node_Str"" + cmd);
          pw.println(""String_Node_Str"");
        }
      }
    }
    if (!more) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
  }
  if (dumpCheckinFormat) {
    dumpBroadcastStatsCheckinLocked(fd,pw,args,opti,dumpCheckin,dumpPackage);
  }
 else   if (dumpClient) {
    ActiveServices.ServiceDumper sdumper;
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      sdumper=mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
    sdumper.dumpWithClient();
    pw.println();
synchronized (this) {
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
 else {
synchronized (this) {
      dumpPendingIntentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpBroadcastsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      if (dumpAll || dumpPackage != null) {
        dumpBroadcastStatsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
      }
      dumpProvidersLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpPermissionsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      mServices.newServiceDumperLocked(fd,pw,args,opti,dumpAll,dumpPackage).dumpLocked();
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpRecentsLocked(fd,pw,args,opti,dumpAll,dumpPackage);
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpActivitiesLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      if (mAssociations.size() > 0) {
        pw.println();
        if (dumpAll) {
          pw.println(""String_Node_Str"");
        }
        dumpAssociationsLocked(fd,pw,args,opti,dumpAll,dumpClient,dumpPackage);
      }
      pw.println();
      if (dumpAll) {
        pw.println(""String_Node_Str"");
      }
      dumpProcessesLocked(fd,pw,args,opti,dumpAll,dumpPackage);
    }
  }
  Binder.restoreCallingIdentity(origId);
}",0.8665748302666535
191356,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
 else {
if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
addBroadcastStatLocked(intent.getAction(),callerPackage,0,0,0);
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.9932430268677748
191357,"static void dumpHelp(PrintWriter pw,boolean dumping){
  if (dumping) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
  }
}","static void dumpHelp(PrintWriter pw,boolean dumping){
  if (dumping) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
  }
}",0.9700085689802912
191358,"final void processNextBroadcast(boolean fromMsg){
synchronized (mService) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mParallelBroadcasts.size()+ ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    mService.updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      r.dispatchClockTime=System.currentTimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ target+ ""String_Node_Str""+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false,i);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp);
      boolean isDead;
synchronized (mService.mPidsSelfLocked) {
        ProcessRecord proc=mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);
        isDead=proc == null || proc.crashing;
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp+ ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        mService.scheduleAppGcsLocked();
        if (looped) {
          mService.updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mService.mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ ""String_Node_Str""+ now+ ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.state+ ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST)             Slog.i(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent.getAction()+ ""String_Node_Str""+ r.callerApp);
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false,r.userId);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            r.resultTo=null;
            Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      r.dispatchClockTime=System.currentTimeMillis();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + mTimeoutPeriod;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    final BroadcastOptions brOptions=r.options;
    final Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ filter+ ""String_Node_Str""+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered,recIdx);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.ordered+ ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
 else {
        if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
          scheduleTempWhitelistLocked(filter.owningUid,brOptions.getTemporaryAppWhitelistDuration(),r);
        }
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    ComponentName component=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    boolean skip=false;
    if (brOptions != null && (info.activityInfo.applicationInfo.targetSdkVersion < brOptions.getMinManifestReceiverApiLevel() || info.activityInfo.applicationInfo.targetSdkVersion > brOptions.getMaxManifestReceiverApiLevel())) {
      skip=true;
    }
    int perm=mService.checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (!skip && perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ component.flattenToShortString());
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ component.flattenToShortString());
      }
      skip=true;
    }
 else     if (!skip && info.activityInfo.permission != null) {
      final int opCode=AppOpsManager.permissionToOpCode(info.activityInfo.permission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(info.activityInfo.permission)+ ""String_Node_Str""+ component.flattenToShortString());
        skip=true;
      }
    }
    if (!skip && info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
      for (int i=0; i < r.requiredPermissions.length; i++) {
        String requiredPermission=r.requiredPermissions[i];
        try {
          perm=AppGlobals.getPackageManager().checkPermission(requiredPermission,info.activityInfo.applicationInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
        }
 catch (        RemoteException e) {
          perm=PackageManager.PERMISSION_DENIED;
        }
        if (perm != PackageManager.PERMISSION_GRANTED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
        int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
        if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
      }
    }
    if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      skip=!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,info.activityInfo.applicationInfo.uid);
    }
    boolean isSingleton=false;
    try {
      isSingleton=mService.isSingleton(info.activityInfo.processName,info.activityInfo.applicationInfo,info.activityInfo.name,info.activityInfo.flags);
    }
 catch (    SecurityException e) {
      Slog.w(TAG,e.getMessage());
      skip=true;
    }
    if ((info.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
      if (ActivityManager.checkUidPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + component.flattenToShortString() + ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS);
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      boolean isAvailable=false;
      try {
        isAvailable=AppGlobals.getPackageManager().isPackageAvailable(info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + info.activityInfo.packageName,e);
      }
      if (!isAvailable) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + info.activityInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (Build.PERMISSIONS_REVIEW_REQUIRED && !skip) {
      if (!requestStartTargetPermissionsReviewIfNeededLocked(r,info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid))) {
        skip=true;
      }
    }
    final int receiverUid=info.activityInfo.applicationInfo.uid;
    if (r.callingUid != Process.SYSTEM_UID && isSingleton && mService.isValidSingletonCall(r.callingUid,receiverUid)) {
      info.activityInfo=mService.getActivityInfoForUser(info.activityInfo,0);
    }
    String targetProcess=info.activityInfo.processName;
    ProcessRecord app=mService.getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid,false);
    if (!skip) {
      final int allowed=mService.checkAllowBackgroundLocked(info.activityInfo.applicationInfo.uid,info.activityInfo.packageName,-1,false);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
 else         if (((r.intent.getFlags() & Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null && r.intent.getPackage() == null && ((r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
      }
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str"");
      r.delivery[recIdx]=BroadcastRecord.DELIVERY_SKIPPED;
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.delivery[recIdx]=BroadcastRecord.DELIVERY_DELIVERED;
    r.state=BroadcastRecord.APP_RECEIVE;
    r.curComponent=component;
    r.curReceiver=info.activityInfo;
    if (DEBUG_MU && r.callingUid > UserHandle.PER_USER_RANGE) {
      Slog.v(TAG_MU,""String_Node_Str"" + info.activityInfo + ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid);
    }
    if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
      scheduleTempWhitelistLocked(receiverUid,brOptions.getTemporaryAppWhitelistDuration(),r);
    }
    try {
      AppGlobals.getPackageManager().setPackageStoppedState(r.curComponent.getPackageName(),false,UserHandle.getUserId(r.callingUid));
    }
 catch (    RemoteException e) {
    }
catch (    IllegalArgumentException e) {
      Slog.w(TAG,""String_Node_Str"" + r.curComponent.getPackageName() + ""String_Node_Str""+ e);
    }
    if (app != null && app.thread != null) {
      try {
        app.addPackage(info.activityInfo.packageName,info.activityInfo.applicationInfo.versionCode,mService.mProcessStats);
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
catch (      RuntimeException e) {
        Slog.wtf(TAG,""String_Node_Str"" + r.curComponent + ""String_Node_Str""+ r.intent,e);
        logBroadcastReceiverDiscardLocked(r);
        finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
        scheduleBroadcastsLocked();
        r.state=BroadcastRecord.IDLE;
        return;
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ targetProcess+ ""String_Node_Str""+ r);
    if ((r.curApp=mService.startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0,false,false)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}","final void processNextBroadcast(boolean fromMsg){
synchronized (mService) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mParallelBroadcasts.size()+ ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    mService.updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      r.dispatchClockTime=System.currentTimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ target+ ""String_Node_Str""+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false,i);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp);
      boolean isDead;
synchronized (mService.mPidsSelfLocked) {
        ProcessRecord proc=mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);
        isDead=proc == null || proc.crashing;
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp+ ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        mService.scheduleAppGcsLocked();
        if (looped) {
          mService.updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mService.mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ ""String_Node_Str""+ now+ ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.state+ ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST)             Slog.i(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent.getAction()+ ""String_Node_Str""+ r.callerApp);
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false,r.userId);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            r.resultTo=null;
            Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        if (r.intent.getComponent() == null && r.intent.getPackage() == null && (r.intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
          mService.addBroadcastStatLocked(r.intent.getAction(),r.callerPackage,r.manifestCount,r.manifestSkipCount,r.finishTime - r.dispatchTime);
        }
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      r.dispatchClockTime=System.currentTimeMillis();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + mTimeoutPeriod;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    final BroadcastOptions brOptions=r.options;
    final Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ filter+ ""String_Node_Str""+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered,recIdx);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.ordered+ ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
 else {
        if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
          scheduleTempWhitelistLocked(filter.owningUid,brOptions.getTemporaryAppWhitelistDuration(),r);
        }
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    ComponentName component=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    boolean skip=false;
    if (brOptions != null && (info.activityInfo.applicationInfo.targetSdkVersion < brOptions.getMinManifestReceiverApiLevel() || info.activityInfo.applicationInfo.targetSdkVersion > brOptions.getMaxManifestReceiverApiLevel())) {
      skip=true;
    }
    int perm=mService.checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (!skip && perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ component.flattenToShortString());
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ component.flattenToShortString());
      }
      skip=true;
    }
 else     if (!skip && info.activityInfo.permission != null) {
      final int opCode=AppOpsManager.permissionToOpCode(info.activityInfo.permission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(info.activityInfo.permission)+ ""String_Node_Str""+ component.flattenToShortString());
        skip=true;
      }
    }
    if (!skip && info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
      for (int i=0; i < r.requiredPermissions.length; i++) {
        String requiredPermission=r.requiredPermissions[i];
        try {
          perm=AppGlobals.getPackageManager().checkPermission(requiredPermission,info.activityInfo.applicationInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
        }
 catch (        RemoteException e) {
          perm=PackageManager.PERMISSION_DENIED;
        }
        if (perm != PackageManager.PERMISSION_GRANTED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
        int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
        if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
      }
    }
    if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      skip=!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,info.activityInfo.applicationInfo.uid);
    }
    boolean isSingleton=false;
    try {
      isSingleton=mService.isSingleton(info.activityInfo.processName,info.activityInfo.applicationInfo,info.activityInfo.name,info.activityInfo.flags);
    }
 catch (    SecurityException e) {
      Slog.w(TAG,e.getMessage());
      skip=true;
    }
    if ((info.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
      if (ActivityManager.checkUidPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + component.flattenToShortString() + ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS);
        skip=true;
      }
    }
    if (!skip) {
      r.manifestCount++;
    }
 else {
      r.manifestSkipCount++;
    }
    if (r.curApp != null && r.curApp.crashing) {
      Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      boolean isAvailable=false;
      try {
        isAvailable=AppGlobals.getPackageManager().isPackageAvailable(info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + info.activityInfo.packageName,e);
      }
      if (!isAvailable) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + info.activityInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (Build.PERMISSIONS_REVIEW_REQUIRED && !skip) {
      if (!requestStartTargetPermissionsReviewIfNeededLocked(r,info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid))) {
        skip=true;
      }
    }
    final int receiverUid=info.activityInfo.applicationInfo.uid;
    if (r.callingUid != Process.SYSTEM_UID && isSingleton && mService.isValidSingletonCall(r.callingUid,receiverUid)) {
      info.activityInfo=mService.getActivityInfoForUser(info.activityInfo,0);
    }
    String targetProcess=info.activityInfo.processName;
    ProcessRecord app=mService.getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid,false);
    if (!skip) {
      final int allowed=mService.checkAllowBackgroundLocked(info.activityInfo.applicationInfo.uid,info.activityInfo.packageName,-1,false);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
 else         if (((r.intent.getFlags() & Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null && r.intent.getPackage() == null && ((r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
      }
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str"");
      r.delivery[recIdx]=BroadcastRecord.DELIVERY_SKIPPED;
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.delivery[recIdx]=BroadcastRecord.DELIVERY_DELIVERED;
    r.state=BroadcastRecord.APP_RECEIVE;
    r.curComponent=component;
    r.curReceiver=info.activityInfo;
    if (DEBUG_MU && r.callingUid > UserHandle.PER_USER_RANGE) {
      Slog.v(TAG_MU,""String_Node_Str"" + info.activityInfo + ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid);
    }
    if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
      scheduleTempWhitelistLocked(receiverUid,brOptions.getTemporaryAppWhitelistDuration(),r);
    }
    try {
      AppGlobals.getPackageManager().setPackageStoppedState(r.curComponent.getPackageName(),false,UserHandle.getUserId(r.callingUid));
    }
 catch (    RemoteException e) {
    }
catch (    IllegalArgumentException e) {
      Slog.w(TAG,""String_Node_Str"" + r.curComponent.getPackageName() + ""String_Node_Str""+ e);
    }
    if (app != null && app.thread != null) {
      try {
        app.addPackage(info.activityInfo.packageName,info.activityInfo.applicationInfo.versionCode,mService.mProcessStats);
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
catch (      RuntimeException e) {
        Slog.wtf(TAG,""String_Node_Str"" + r.curComponent + ""String_Node_Str""+ r.intent,e);
        logBroadcastReceiverDiscardLocked(r);
        finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
        scheduleBroadcastsLocked();
        r.state=BroadcastRecord.IDLE;
        return;
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ targetProcess+ ""String_Node_Str""+ r);
    if ((r.curApp=mService.startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0,false,false)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}",0.987507473488782
191359,"@Override public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfoInternal(info);
  final int scrollRange=getScrollRange();
  if (scrollRange > 0) {
    info.setScrollable(true);
    if (mScrollY > 0) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_UP);
    }
    if (mScrollY < scrollRange) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_DOWN);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfoInternal(info);
  final int scrollRange=getScrollRange();
  if (scrollRange > 0) {
    info.setScrollable(true);
    if (mScrollY > 0) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_UP);
    }
    if (mScrollY < scrollRange) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_DOWN);
    }
  }
  info.setClassName(ScrollView.class.getName());
}",0.9643636363636364
191360,"@Override public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfoInternal(info);
  final int scrollRange=getScrollRange();
  if (scrollRange > 0) {
    info.setScrollable(true);
    if (mScrollY > 0) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_UP);
    }
    if (mScrollY < scrollRange) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_DOWN);
    }
  }
}","@Override public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfoInternal(info);
  final int scrollRange=getScrollRange();
  if (scrollRange > 0) {
    info.setScrollable(true);
    if (mScrollY > 0) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_UP);
    }
    if (mScrollY < scrollRange) {
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_DOWN);
    }
  }
  info.setClassName(ScrollView.class.getName());
}",0.9643636363636364
191361,"private void applyMacroBlockLimits(int maxHorizontalBlocks,int maxVerticalBlocks,int maxBlocks,long maxBlocksPerSecond,int blockWidth,int blockHeight,int widthAlignment,int heightAlignment){
  applyAlignment(widthAlignment,heightAlignment);
  applyBlockLimits(blockWidth,blockHeight,Range.create(1,maxBlocks),Range.create(1L,maxBlocksPerSecond),Range.create(new Rational(1,maxVerticalBlocks),new Rational(maxHorizontalBlocks,1)));
  mHorizontalBlockRange=mHorizontalBlockRange.intersect(1,maxHorizontalBlocks / (mBlockWidth / blockWidth));
  mVerticalBlockRange=mVerticalBlockRange.intersect(1,maxVerticalBlocks / (mBlockHeight / blockHeight));
}","private void applyMacroBlockLimits(int minHorizontalBlocks,int minVerticalBlocks,int maxHorizontalBlocks,int maxVerticalBlocks,int maxBlocks,long maxBlocksPerSecond,int blockWidth,int blockHeight,int widthAlignment,int heightAlignment){
  applyAlignment(widthAlignment,heightAlignment);
  applyBlockLimits(blockWidth,blockHeight,Range.create(1,maxBlocks),Range.create(1L,maxBlocksPerSecond),Range.create(new Rational(1,maxVerticalBlocks),new Rational(maxHorizontalBlocks,1)));
  mHorizontalBlockRange=mHorizontalBlockRange.intersect(Utils.divUp(minHorizontalBlocks,(mBlockWidth / blockWidth)),maxHorizontalBlocks / (mBlockWidth / blockWidth));
  mVerticalBlockRange=mVerticalBlockRange.intersect(Utils.divUp(minVerticalBlocks,(mBlockHeight / blockHeight)),maxVerticalBlocks / (mBlockHeight / blockHeight));
}",0.8858321870701513
191362,"private boolean supportsProfileLevel(int profile,Integer level){
  for (  CodecProfileLevel pl : profileLevels) {
    if (pl.profile != profile) {
      continue;
    }
    if (level == null || mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_AAC)) {
      return true;
    }
    if (mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_H263)) {
      if (pl.level != level && pl.level == CodecProfileLevel.H263Level45 && level > CodecProfileLevel.H263Level10) {
        continue;
      }
    }
    if (pl.level >= level) {
      if (createFromProfileLevel(mMime,profile,pl.level) != null) {
        return createFromProfileLevel(mMime,profile,level) != null;
      }
      return true;
    }
  }
  return false;
}","private boolean supportsProfileLevel(int profile,Integer level){
  for (  CodecProfileLevel pl : profileLevels) {
    if (pl.profile != profile) {
      continue;
    }
    if (level == null || mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_AAC)) {
      return true;
    }
    if (mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_H263)) {
      if (pl.level != level && pl.level == CodecProfileLevel.H263Level45 && level > CodecProfileLevel.H263Level10) {
        continue;
      }
    }
    if (mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_MPEG4)) {
      if (pl.level != level && pl.level == CodecProfileLevel.MPEG4Level1 && level > CodecProfileLevel.MPEG4Level0) {
        continue;
      }
    }
    if (mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_HEVC)) {
      boolean supportsHighTier=(pl.level & CodecProfileLevel.HEVCHighTierLevels) != 0;
      boolean checkingHighTier=(level & CodecProfileLevel.HEVCHighTierLevels) != 0;
      if (checkingHighTier && !supportsHighTier) {
        continue;
      }
    }
    if (pl.level >= level) {
      if (createFromProfileLevel(mMime,profile,pl.level) != null) {
        return createFromProfileLevel(mMime,profile,level) != null;
      }
      return true;
    }
  }
  return false;
}",0.7054026503567788
191363,"private void applyMacroBlockLimits(int maxHorizontalBlocks,int maxVerticalBlocks,int maxBlocks,long maxBlocksPerSecond,int blockWidth,int blockHeight,int widthAlignment,int heightAlignment){
  applyAlignment(widthAlignment,heightAlignment);
  applyBlockLimits(blockWidth,blockHeight,Range.create(1,maxBlocks),Range.create(1L,maxBlocksPerSecond),Range.create(new Rational(1,maxVerticalBlocks),new Rational(maxHorizontalBlocks,1)));
  mHorizontalBlockRange=mHorizontalBlockRange.intersect(1,maxHorizontalBlocks / (mBlockWidth / blockWidth));
  mVerticalBlockRange=mVerticalBlockRange.intersect(1,maxVerticalBlocks / (mBlockHeight / blockHeight));
}","private void applyMacroBlockLimits(int minHorizontalBlocks,int minVerticalBlocks,int maxHorizontalBlocks,int maxVerticalBlocks,int maxBlocks,long maxBlocksPerSecond,int blockWidth,int blockHeight,int widthAlignment,int heightAlignment){
  applyAlignment(widthAlignment,heightAlignment);
  applyBlockLimits(blockWidth,blockHeight,Range.create(1,maxBlocks),Range.create(1L,maxBlocksPerSecond),Range.create(new Rational(1,maxVerticalBlocks),new Rational(maxHorizontalBlocks,1)));
  mHorizontalBlockRange=mHorizontalBlockRange.intersect(Utils.divUp(minHorizontalBlocks,(mBlockWidth / blockWidth)),maxHorizontalBlocks / (mBlockWidth / blockWidth));
  mVerticalBlockRange=mVerticalBlockRange.intersect(Utils.divUp(minVerticalBlocks,(mBlockHeight / blockHeight)),maxVerticalBlocks / (mBlockHeight / blockHeight));
}",0.8858321870701513
191364,"private boolean supportsProfileLevel(int profile,Integer level){
  for (  CodecProfileLevel pl : profileLevels) {
    if (pl.profile != profile) {
      continue;
    }
    if (level == null || mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_AAC)) {
      return true;
    }
    if (mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_H263)) {
      if (pl.level != level && pl.level == CodecProfileLevel.H263Level45 && level > CodecProfileLevel.H263Level10) {
        continue;
      }
    }
    if (pl.level >= level) {
      if (createFromProfileLevel(mMime,profile,pl.level) != null) {
        return createFromProfileLevel(mMime,profile,level) != null;
      }
      return true;
    }
  }
  return false;
}","private boolean supportsProfileLevel(int profile,Integer level){
  for (  CodecProfileLevel pl : profileLevels) {
    if (pl.profile != profile) {
      continue;
    }
    if (level == null || mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_AUDIO_AAC)) {
      return true;
    }
    if (mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_H263)) {
      if (pl.level != level && pl.level == CodecProfileLevel.H263Level45 && level > CodecProfileLevel.H263Level10) {
        continue;
      }
    }
    if (mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_MPEG4)) {
      if (pl.level != level && pl.level == CodecProfileLevel.MPEG4Level1 && level > CodecProfileLevel.MPEG4Level0) {
        continue;
      }
    }
    if (mMime.equalsIgnoreCase(MediaFormat.MIMETYPE_VIDEO_HEVC)) {
      boolean supportsHighTier=(pl.level & CodecProfileLevel.HEVCHighTierLevels) != 0;
      boolean checkingHighTier=(level & CodecProfileLevel.HEVCHighTierLevels) != 0;
      if (checkingHighTier && !supportsHighTier) {
        continue;
      }
    }
    if (pl.level >= level) {
      if (createFromProfileLevel(mMime,profile,pl.level) != null) {
        return createFromProfileLevel(mMime,profile,level) != null;
      }
      return true;
    }
  }
  return false;
}",0.7054026503567788
191365,"void calculateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect){
  final WindowState w=mWin;
  final DisplayContent displayContent=w.getDisplayContent();
  if (displayContent == null) {
    clipRect.setEmpty();
    finalClipRect.setEmpty();
    return;
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mLastClipRect);
  if (!w.isDefaultDisplay()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
    mSystemDecorRect.intersect(-w.mCompatFrame.left,-w.mCompatFrame.top,displayInfo.logicalWidth - w.mCompatFrame.left,displayInfo.logicalHeight - w.mCompatFrame.top);
  }
 else   if (w.mLayer >= mService.mSystemDecorLayer) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mDecorFrame.isEmpty()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mAttrs.type == LayoutParams.TYPE_WALLPAPER && mAnimator.isAnimating()) {
    mTmpClipRect.set(mSystemDecorRect);
    calculateSystemDecorRect();
    mSystemDecorRect.union(mTmpClipRect);
  }
 else {
    calculateSystemDecorRect();
    if (DEBUG_WINDOW_CROP)     Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mDecorFrame+ ""String_Node_Str""+ mSystemDecorRect);
  }
  final boolean fullscreen=w.isFrameFullscreen(displayInfo);
  final boolean isFreeformResizing=w.isDragResizing() && w.getResizeMode() == DRAG_RESIZE_MODE_FREEFORM;
  clipRect.set((mHasClipRect && !fullscreen) ? mClipRect : mSystemDecorRect);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect+ ""String_Node_Str""+ mHasClipRect+ ""String_Node_Str""+ fullscreen);
  if (isFreeformResizing && !w.isChildWindow()) {
    clipRect.offset(w.mShownPosition.x,w.mShownPosition.y);
  }
  final WindowManager.LayoutParams attrs=w.mAttrs;
  clipRect.left-=attrs.surfaceInsets.left;
  clipRect.top-=attrs.surfaceInsets.top;
  clipRect.right+=attrs.surfaceInsets.right;
  clipRect.bottom+=attrs.surfaceInsets.bottom;
  if (mHasClipRect && fullscreen) {
    clipRect.intersect(mClipRect);
  }
  clipRect.offset(attrs.surfaceInsets.left,attrs.surfaceInsets.top);
  finalClipRect.setEmpty();
  adjustCropToStackBounds(w,clipRect,finalClipRect,isFreeformResizing);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect);
  w.transformFromScreenToSurfaceSpace(clipRect);
  if (w.hasJustMovedInStack() && mLastClipRect.isEmpty() && !clipRect.isEmpty()) {
    clipRect.setEmpty();
  }
}","void calculateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect){
  final WindowState w=mWin;
  final DisplayContent displayContent=w.getDisplayContent();
  if (displayContent == null) {
    clipRect.setEmpty();
    finalClipRect.setEmpty();
    return;
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mLastClipRect);
  if (!w.isDefaultDisplay()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
    mSystemDecorRect.intersect(-w.mCompatFrame.left,-w.mCompatFrame.top,displayInfo.logicalWidth - w.mCompatFrame.left,displayInfo.logicalHeight - w.mCompatFrame.top);
  }
 else   if (w.mLayer >= mService.mSystemDecorLayer) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mDecorFrame.isEmpty()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mAttrs.type == LayoutParams.TYPE_WALLPAPER && mAnimator.isAnimating()) {
    mTmpClipRect.set(mSystemDecorRect);
    calculateSystemDecorRect();
    mSystemDecorRect.union(mTmpClipRect);
  }
 else {
    calculateSystemDecorRect();
    if (DEBUG_WINDOW_CROP)     Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mDecorFrame+ ""String_Node_Str""+ mSystemDecorRect);
  }
  final boolean fullscreen=w.isFrameFullscreen(displayInfo);
  final boolean isFreeformResizing=w.isDragResizing() && w.getResizeMode() == DRAG_RESIZE_MODE_FREEFORM;
  clipRect.set((mHasClipRect && !fullscreen) ? mClipRect : mSystemDecorRect);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect+ ""String_Node_Str""+ mHasClipRect+ ""String_Node_Str""+ fullscreen);
  if (isFreeformResizing && !w.isChildWindow()) {
    clipRect.offset(w.mShownPosition.x,w.mShownPosition.y);
  }
  final WindowManager.LayoutParams attrs=w.mAttrs;
  clipRect.left-=attrs.surfaceInsets.left;
  clipRect.top-=attrs.surfaceInsets.top;
  clipRect.right+=attrs.surfaceInsets.right;
  clipRect.bottom+=attrs.surfaceInsets.bottom;
  if (mHasClipRect && fullscreen) {
    clipRect.intersect(mClipRect);
  }
  clipRect.offset(attrs.surfaceInsets.left,attrs.surfaceInsets.top);
  finalClipRect.setEmpty();
  adjustCropToStackBounds(w,clipRect,finalClipRect,isFreeformResizing);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect);
  w.transformClipRectFromScreenToSurfaceSpace(clipRect);
  if (w.hasJustMovedInStack() && mLastClipRect.isEmpty() && !clipRect.isEmpty()) {
    clipRect.setEmpty();
  }
}",0.9984550019312476
191366,"private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdate();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}","private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdateOrReset();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}",0.9981157469717362
191367,"public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput != null ? mExpandedRemoteInput.getPendingIntent() : null;
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput != null ? mHeadsUpRemoteInput.getPendingIntent() : null;
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}","public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=null;
  if (mExpandedRemoteInput != null) {
    mExpandedRemoteInput.onNotificationUpdateOrReset();
    if (mExpandedRemoteInput.isActive()) {
      mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput.getPendingIntent();
    }
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=null;
  if (mHeadsUpRemoteInput != null) {
    mHeadsUpRemoteInput.onNotificationUpdateOrReset();
    if (mHeadsUpRemoteInput.isActive()) {
      mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput.getPendingIntent();
    }
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}",0.357931435212086
191368,"void calculateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect){
  final WindowState w=mWin;
  final DisplayContent displayContent=w.getDisplayContent();
  if (displayContent == null) {
    clipRect.setEmpty();
    finalClipRect.setEmpty();
    return;
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mLastClipRect);
  if (!w.isDefaultDisplay()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
    mSystemDecorRect.intersect(-w.mCompatFrame.left,-w.mCompatFrame.top,displayInfo.logicalWidth - w.mCompatFrame.left,displayInfo.logicalHeight - w.mCompatFrame.top);
  }
 else   if (w.mLayer >= mService.mSystemDecorLayer) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mDecorFrame.isEmpty()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mAttrs.type == LayoutParams.TYPE_WALLPAPER && mAnimator.isAnimating()) {
    mTmpClipRect.set(mSystemDecorRect);
    calculateSystemDecorRect();
    mSystemDecorRect.union(mTmpClipRect);
  }
 else {
    calculateSystemDecorRect();
    if (DEBUG_WINDOW_CROP)     Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mDecorFrame+ ""String_Node_Str""+ mSystemDecorRect);
  }
  final boolean fullscreen=w.isFrameFullscreen(displayInfo);
  final boolean isFreeformResizing=w.isDragResizing() && w.getResizeMode() == DRAG_RESIZE_MODE_FREEFORM;
  clipRect.set((mHasClipRect && !fullscreen) ? mClipRect : mSystemDecorRect);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect+ ""String_Node_Str""+ mHasClipRect+ ""String_Node_Str""+ fullscreen);
  if (isFreeformResizing && !w.isChildWindow()) {
    clipRect.offset(w.mShownPosition.x,w.mShownPosition.y);
  }
  final WindowManager.LayoutParams attrs=w.mAttrs;
  clipRect.left-=attrs.surfaceInsets.left;
  clipRect.top-=attrs.surfaceInsets.top;
  clipRect.right+=attrs.surfaceInsets.right;
  clipRect.bottom+=attrs.surfaceInsets.bottom;
  if (mHasClipRect && fullscreen) {
    clipRect.intersect(mClipRect);
  }
  clipRect.offset(attrs.surfaceInsets.left,attrs.surfaceInsets.top);
  finalClipRect.setEmpty();
  adjustCropToStackBounds(w,clipRect,finalClipRect,isFreeformResizing);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect);
  w.transformFromScreenToSurfaceSpace(clipRect);
  if (w.hasJustMovedInStack() && mLastClipRect.isEmpty() && !clipRect.isEmpty()) {
    clipRect.setEmpty();
  }
}","void calculateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect){
  final WindowState w=mWin;
  final DisplayContent displayContent=w.getDisplayContent();
  if (displayContent == null) {
    clipRect.setEmpty();
    finalClipRect.setEmpty();
    return;
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mLastClipRect);
  if (!w.isDefaultDisplay()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
    mSystemDecorRect.intersect(-w.mCompatFrame.left,-w.mCompatFrame.top,displayInfo.logicalWidth - w.mCompatFrame.left,displayInfo.logicalHeight - w.mCompatFrame.top);
  }
 else   if (w.mLayer >= mService.mSystemDecorLayer) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mDecorFrame.isEmpty()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mAttrs.type == LayoutParams.TYPE_WALLPAPER && mAnimator.isAnimating()) {
    mTmpClipRect.set(mSystemDecorRect);
    calculateSystemDecorRect();
    mSystemDecorRect.union(mTmpClipRect);
  }
 else {
    calculateSystemDecorRect();
    if (DEBUG_WINDOW_CROP)     Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mDecorFrame+ ""String_Node_Str""+ mSystemDecorRect);
  }
  final boolean fullscreen=w.isFrameFullscreen(displayInfo);
  final boolean isFreeformResizing=w.isDragResizing() && w.getResizeMode() == DRAG_RESIZE_MODE_FREEFORM;
  clipRect.set((mHasClipRect && !fullscreen) ? mClipRect : mSystemDecorRect);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect+ ""String_Node_Str""+ mHasClipRect+ ""String_Node_Str""+ fullscreen);
  if (isFreeformResizing && !w.isChildWindow()) {
    clipRect.offset(w.mShownPosition.x,w.mShownPosition.y);
  }
  final WindowManager.LayoutParams attrs=w.mAttrs;
  clipRect.left-=attrs.surfaceInsets.left;
  clipRect.top-=attrs.surfaceInsets.top;
  clipRect.right+=attrs.surfaceInsets.right;
  clipRect.bottom+=attrs.surfaceInsets.bottom;
  if (mHasClipRect && fullscreen) {
    clipRect.intersect(mClipRect);
  }
  clipRect.offset(attrs.surfaceInsets.left,attrs.surfaceInsets.top);
  finalClipRect.setEmpty();
  adjustCropToStackBounds(w,clipRect,finalClipRect,isFreeformResizing);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect);
  w.transformClipRectFromScreenToSurfaceSpace(clipRect);
  if (w.hasJustMovedInStack() && mLastClipRect.isEmpty() && !clipRect.isEmpty()) {
    clipRect.setEmpty();
  }
}",0.9984550019312476
191369,"private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdate();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}","private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdateOrReset();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}",0.9981157469717362
191370,"public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput != null ? mExpandedRemoteInput.getPendingIntent() : null;
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput != null ? mHeadsUpRemoteInput.getPendingIntent() : null;
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}","public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=null;
  if (mExpandedRemoteInput != null) {
    mExpandedRemoteInput.onNotificationUpdateOrReset();
    if (mExpandedRemoteInput.isActive()) {
      mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput.getPendingIntent();
    }
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=null;
  if (mHeadsUpRemoteInput != null) {
    mHeadsUpRemoteInput.onNotificationUpdateOrReset();
    if (mHeadsUpRemoteInput.isActive()) {
      mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput.getPendingIntent();
    }
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}",0.357931435212086
191371,"private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdate();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}","private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdateOrReset();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}",0.9981157469717362
191372,"public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput != null ? mExpandedRemoteInput.getPendingIntent() : null;
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput != null ? mHeadsUpRemoteInput.getPendingIntent() : null;
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}","public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=null;
  if (mExpandedRemoteInput != null) {
    mExpandedRemoteInput.onNotificationUpdateOrReset();
    if (mExpandedRemoteInput.isActive()) {
      mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput.getPendingIntent();
    }
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=null;
  if (mHeadsUpRemoteInput != null) {
    mHeadsUpRemoteInput.onNotificationUpdateOrReset();
    if (mHeadsUpRemoteInput.isActive()) {
      mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput.getPendingIntent();
    }
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}",0.357931435212086
191373,"/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p> <p>Because because setting this property is not compatible with periodic or persisted jobs, doing so will throw an   {@link java.lang.IllegalArgumentException} when{@link android.app.job.JobInfo.Builder#build()} is called.</p>
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}","/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p> <p>Because because setting this property is not compatible with periodic or persisted jobs, doing so will throw an   {@link java.lang.IllegalArgumentException} when{@link android.app.job.JobInfo.Builder#build()} is called.</p><p>The following example shows how this feature can be used to monitor for changes in the photos on a device.</p> {@sample development/samples/ApiDemos/src/com/example/android/apis/content/PhotosContentJob.javajob}
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}",0.9098567818028644
191374,"/** 
 * Initializes the system service. <p> Subclasses must define a single argument constructor that accepts the context and passes it to super. </p>
 * @param context The system server context.
 */
public JobSchedulerService(Context context){
  super(context);
  mControllers=new ArrayList<StateController>();
  mControllers.add(ConnectivityController.get(this));
  mControllers.add(TimeController.get(this));
  mControllers.add(IdleController.get(this));
  mControllers.add(BatteryController.get(this));
  mControllers.add(AppIdleController.get(this));
  mControllers.add(ContentObserverController.get(this));
  mControllers.add(DeviceIdleJobsController.get(this));
  mHandler=new JobHandler(context.getMainLooper());
  mConstants=new Constants(mHandler);
  mJobSchedulerStub=new JobSchedulerStub();
  mJobs=JobStore.initAndGet(this);
}","/** 
 * Initializes the system service. <p> Subclasses must define a single argument constructor that accepts the context and passes it to super. </p>
 * @param context The system server context.
 */
public JobSchedulerService(Context context){
  super(context);
  mHandler=new JobHandler(context.getMainLooper());
  mConstants=new Constants(mHandler);
  mJobSchedulerStub=new JobSchedulerStub();
  mJobs=JobStore.initAndGet(this);
  mControllers=new ArrayList<StateController>();
  mControllers.add(ConnectivityController.get(this));
  mControllers.add(TimeController.get(this));
  mControllers.add(IdleController.get(this));
  mControllers.add(BatteryController.get(this));
  mControllers.add(AppIdleController.get(this));
  mControllers.add(ContentObserverController.get(this));
  mControllers.add(DeviceIdleJobsController.get(this));
}",0.798569725864124
191375,"/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p> <p>Because because setting this property is not compatible with periodic or persisted jobs, doing so will throw an   {@link java.lang.IllegalArgumentException} when{@link android.app.job.JobInfo.Builder#build()} is called.</p>
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}","/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p> <p>Because because setting this property is not compatible with periodic or persisted jobs, doing so will throw an   {@link java.lang.IllegalArgumentException} when{@link android.app.job.JobInfo.Builder#build()} is called.</p><p>The following example shows how this feature can be used to monitor for changes in the photos on a device.</p> {@sample development/samples/ApiDemos/src/com/example/android/apis/content/PhotosContentJob.javajob}
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}",0.9098567818028644
191376,"/** 
 * Initializes the system service. <p> Subclasses must define a single argument constructor that accepts the context and passes it to super. </p>
 * @param context The system server context.
 */
public JobSchedulerService(Context context){
  super(context);
  mControllers=new ArrayList<StateController>();
  mControllers.add(ConnectivityController.get(this));
  mControllers.add(TimeController.get(this));
  mControllers.add(IdleController.get(this));
  mControllers.add(BatteryController.get(this));
  mControllers.add(AppIdleController.get(this));
  mControllers.add(ContentObserverController.get(this));
  mControllers.add(DeviceIdleJobsController.get(this));
  mHandler=new JobHandler(context.getMainLooper());
  mConstants=new Constants(mHandler);
  mJobSchedulerStub=new JobSchedulerStub();
  mJobs=JobStore.initAndGet(this);
}","/** 
 * Initializes the system service. <p> Subclasses must define a single argument constructor that accepts the context and passes it to super. </p>
 * @param context The system server context.
 */
public JobSchedulerService(Context context){
  super(context);
  mHandler=new JobHandler(context.getMainLooper());
  mConstants=new Constants(mHandler);
  mJobSchedulerStub=new JobSchedulerStub();
  mJobs=JobStore.initAndGet(this);
  mControllers=new ArrayList<StateController>();
  mControllers.add(ConnectivityController.get(this));
  mControllers.add(TimeController.get(this));
  mControllers.add(IdleController.get(this));
  mControllers.add(BatteryController.get(this));
  mControllers.add(AppIdleController.get(this));
  mControllers.add(ContentObserverController.get(this));
  mControllers.add(DeviceIdleJobsController.get(this));
}",0.798569725864124
191377,"private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdate();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}","private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdateOrReset();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}",0.9981157469717362
191378,"public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput != null ? mExpandedRemoteInput.getPendingIntent() : null;
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput != null ? mHeadsUpRemoteInput.getPendingIntent() : null;
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}","public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=null;
  if (mExpandedRemoteInput != null) {
    mExpandedRemoteInput.onNotificationUpdateOrReset();
    if (mExpandedRemoteInput.isActive()) {
      mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput.getPendingIntent();
    }
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=null;
  if (mHeadsUpRemoteInput != null) {
    mHeadsUpRemoteInput.onNotificationUpdateOrReset();
    if (mHeadsUpRemoteInput.isActive()) {
      mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput.getPendingIntent();
    }
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}",0.357931435212086
191379,"private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdate();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}","private RemoteInputView applyRemoteInput(View view,NotificationData.Entry entry,boolean hasRemoteInput,PendingIntent existingPendingIntent){
  View actionContainerCandidate=view.findViewById(com.android.internal.R.id.actions_container);
  if (actionContainerCandidate instanceof FrameLayout) {
    RemoteInputView existing=(RemoteInputView)view.findViewWithTag(RemoteInputView.VIEW_TAG);
    if (existing != null) {
      existing.onNotificationUpdateOrReset();
    }
    if (existing == null && hasRemoteInput) {
      ViewGroup actionContainer=(FrameLayout)actionContainerCandidate;
      RemoteInputView riv=RemoteInputView.inflate(mContext,actionContainer,entry,mRemoteInputController);
      riv.setVisibility(View.INVISIBLE);
      actionContainer.addView(riv,new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
      existing=riv;
    }
    if (hasRemoteInput) {
      int color=entry.notification.getNotification().color;
      if (color == Notification.COLOR_DEFAULT) {
        color=mContext.getColor(R.color.default_remote_input_background);
      }
      existing.setBackgroundColor(NotificationColorUtil.ensureTextBackgroundColor(color,mContext.getColor(R.color.remote_input_text_enabled),mContext.getColor(R.color.remote_input_hint)));
      if (existingPendingIntent != null || existing.isActive()) {
        Notification.Action[] actions=entry.notification.getNotification().actions;
        if (existingPendingIntent != null) {
          existing.setPendingIntent(existingPendingIntent);
        }
        if (existing.updatePendingIntentFromActions(actions)) {
          if (!existing.isActive()) {
            existing.focus();
          }
        }
 else {
          if (existing.isActive()) {
            existing.close();
          }
        }
      }
    }
    return existing;
  }
  return null;
}",0.9981157469717362
191380,"public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput != null ? mExpandedRemoteInput.getPendingIntent() : null;
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput != null ? mHeadsUpRemoteInput.getPendingIntent() : null;
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}","public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  mPreviousExpandedRemoteInputIntent=null;
  if (mExpandedRemoteInput != null) {
    mExpandedRemoteInput.onNotificationUpdateOrReset();
    if (mExpandedRemoteInput.isActive()) {
      mPreviousExpandedRemoteInputIntent=mExpandedRemoteInput.getPendingIntent();
    }
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
    mExpandedRemoteInput=null;
  }
  mPreviousHeadsUpRemoteInputIntent=null;
  if (mHeadsUpRemoteInput != null) {
    mHeadsUpRemoteInput.onNotificationUpdateOrReset();
    if (mHeadsUpRemoteInput.isActive()) {
      mPreviousHeadsUpRemoteInputIntent=mHeadsUpRemoteInput.getPendingIntent();
    }
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
    mHeadsUpRemoteInput=null;
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}",0.357931435212086
191381,"/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p> <p>Because because setting this property is not compatible with periodic or persisted jobs, doing so will throw an   {@link java.lang.IllegalArgumentException} when{@link android.app.job.JobInfo.Builder#build()} is called.</p>
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}","/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p> <p>Because because setting this property is not compatible with periodic or persisted jobs, doing so will throw an   {@link java.lang.IllegalArgumentException} when{@link android.app.job.JobInfo.Builder#build()} is called.</p><p>The following example shows how this feature can be used to monitor for changes in the photos on a device.</p> {@sample development/samples/ApiDemos/src/com/example/android/apis/content/PhotosContentJob.javajob}
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}",0.9098567818028644
191382,"/** 
 * Initializes the system service. <p> Subclasses must define a single argument constructor that accepts the context and passes it to super. </p>
 * @param context The system server context.
 */
public JobSchedulerService(Context context){
  super(context);
  mControllers=new ArrayList<StateController>();
  mControllers.add(ConnectivityController.get(this));
  mControllers.add(TimeController.get(this));
  mControllers.add(IdleController.get(this));
  mControllers.add(BatteryController.get(this));
  mControllers.add(AppIdleController.get(this));
  mControllers.add(ContentObserverController.get(this));
  mControllers.add(DeviceIdleJobsController.get(this));
  mHandler=new JobHandler(context.getMainLooper());
  mConstants=new Constants(mHandler);
  mJobSchedulerStub=new JobSchedulerStub();
  mJobs=JobStore.initAndGet(this);
}","/** 
 * Initializes the system service. <p> Subclasses must define a single argument constructor that accepts the context and passes it to super. </p>
 * @param context The system server context.
 */
public JobSchedulerService(Context context){
  super(context);
  mHandler=new JobHandler(context.getMainLooper());
  mConstants=new Constants(mHandler);
  mJobSchedulerStub=new JobSchedulerStub();
  mJobs=JobStore.initAndGet(this);
  mControllers=new ArrayList<StateController>();
  mControllers.add(ConnectivityController.get(this));
  mControllers.add(TimeController.get(this));
  mControllers.add(IdleController.get(this));
  mControllers.add(BatteryController.get(this));
  mControllers.add(AppIdleController.get(this));
  mControllers.add(ContentObserverController.get(this));
  mControllers.add(DeviceIdleJobsController.get(this));
}",0.798569725864124
191383,"@Override public void setOnClickListener(@Nullable OnClickListener l){
  mExpandClickListener=l;
  setOnTouchListener(mExpandClickListener != null ? mTouchListener : null);
  updateTouchListener();
}","@Override public void setOnClickListener(@Nullable OnClickListener l){
  mExpandClickListener=l;
  setOnTouchListener(mExpandClickListener != null ? mTouchListener : null);
  setFocusable(l != null);
  updateTouchListener();
}",0.9364705882352942
191384,"@Override public void setOnClickListener(@Nullable OnClickListener l){
  mExpandClickListener=l;
  setOnTouchListener(mExpandClickListener != null ? mTouchListener : null);
  updateTouchListener();
}","@Override public void setOnClickListener(@Nullable OnClickListener l){
  mExpandClickListener=l;
  setOnTouchListener(mExpandClickListener != null ? mTouchListener : null);
  setFocusable(l != null);
  updateTouchListener();
}",0.9364705882352942
191385,"void disconnect(Context context){
  try {
    if (mBound) {
      mBound=false;
      context.unbindService(this);
    }
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","void disconnect(Context context){
  try {
    if (mBound) {
      mBound=false;
      context.unbindService(this);
      if (DBG)       Log.d(TAG,""String_Node_Str"");
    }
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.6711409395973155
191386,"@Override public void onServiceDisconnected(ComponentName name){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + name.flattenToString());
}","@Override public void onServiceDisconnected(ComponentName name){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + name.flattenToString());
  }
  mConnected=false;
}",0.9054054054054054
191387,"@Override public void onServiceConnected(ComponentName name,IBinder service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + name.flattenToString());
}","@Override public void onServiceConnected(ComponentName name,IBinder service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + name.flattenToString());
  mConnected=true;
}",0.939297124600639
191388,"/** 
 * Called when the system is ready to run third-party code but before it actually does so. 
 */
void systemReady(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  ContentResolver cr=mContext.getContentResolver();
  if (Settings.Global.getInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,0) == 0) {
    String defaultPackage=mContext.getResources().getString(R.string.config_defaultNetworkScorerPackageName);
    if (!TextUtils.isEmpty(defaultPackage)) {
      NetworkScorerAppManager.setActiveScorer(mContext,defaultPackage);
    }
    Settings.Global.putInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,1);
  }
  registerPackageReceiverIfNeeded();
}","/** 
 * Called when the system is ready to run third-party code but before it actually does so. 
 */
void systemReady(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  ContentResolver cr=mContext.getContentResolver();
  if (Settings.Global.getInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,0) == 0) {
    String defaultPackage=mContext.getResources().getString(R.string.config_defaultNetworkScorerPackageName);
    if (!TextUtils.isEmpty(defaultPackage)) {
      NetworkScorerAppManager.setActiveScorer(mContext,defaultPackage);
    }
    Settings.Global.putInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,1);
  }
  registerPackageMonitorIfNeeded();
}",0.99009900990099
191389,"/** 
 * Set the active scorer. Callers are responsible for checking permissions as appropriate. 
 */
private boolean setScorerInternal(String packageName){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
  long token=Binder.clearCallingIdentity();
  try {
    unbindFromScoringServiceIfNeeded();
    clearInternal();
    NetworkScorerAppData prevScorer=NetworkScorerAppManager.getActiveScorer(mContext);
    boolean result=NetworkScorerAppManager.setActiveScorer(mContext,packageName);
    bindToScoringServiceIfNeeded();
    if (result) {
      registerPackageReceiverIfNeeded();
      Intent intent=new Intent(NetworkScoreManager.ACTION_SCORER_CHANGED);
      if (prevScorer != null) {
        intent.setPackage(prevScorer.mPackageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
      if (packageName != null) {
        intent.putExtra(NetworkScoreManager.EXTRA_NEW_SCORER,packageName);
        intent.setPackage(packageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
    }
    return result;
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}","/** 
 * Set the active scorer. Callers are responsible for checking permissions as appropriate. 
 */
private boolean setScorerInternal(String packageName){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
  long token=Binder.clearCallingIdentity();
  try {
    unbindFromScoringServiceIfNeeded();
    clearInternal();
    NetworkScorerAppData prevScorer=NetworkScorerAppManager.getActiveScorer(mContext);
    boolean result=NetworkScorerAppManager.setActiveScorer(mContext,packageName);
    bindToScoringServiceIfNeeded();
    if (result) {
      registerPackageMonitorIfNeeded();
      Intent intent=new Intent(NetworkScoreManager.ACTION_SCORER_CHANGED);
      if (prevScorer != null) {
        intent.setPackage(prevScorer.mPackageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
      if (packageName != null) {
        intent.putExtra(NetworkScoreManager.EXTRA_NEW_SCORER,packageName);
        intent.setPackage(packageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
    }
    return result;
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}",0.9943404440574662
191390,"public void dump(FileDescriptor fd,PrintWriter writer,String[] args){
  writer.println(""String_Node_Str"" + mComponentName + ""String_Node_Str""+ mBound);
}","public void dump(FileDescriptor fd,PrintWriter writer,String[] args){
  writer.println(""String_Node_Str"" + mComponentName + ""String_Node_Str""+ mBound+ ""String_Node_Str""+ mConnected);
}",0.9080118694362018
191391,"void connect(Context context){
  disconnect(context);
  Intent service=new Intent();
  service.setComponent(mComponentName);
  mBound=context.bindServiceAsUser(service,this,Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE,UserHandle.SYSTEM);
  if (!mBound) {
    Log.w(TAG,""String_Node_Str"" + service);
  }
}","void connect(Context context){
  if (!mBound) {
    Intent service=new Intent();
    service.setComponent(mComponentName);
    mBound=context.bindServiceAsUser(service,this,Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE,UserHandle.SYSTEM);
    if (!mBound) {
      Log.w(TAG,""String_Node_Str"" + service);
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
    }
  }
}",0.8354430379746836
191392,"@Override public void setOnClickListener(@Nullable OnClickListener l){
  mExpandClickListener=l;
  setOnTouchListener(mExpandClickListener != null ? mTouchListener : null);
  updateTouchListener();
}","@Override public void setOnClickListener(@Nullable OnClickListener l){
  mExpandClickListener=l;
  setOnTouchListener(mExpandClickListener != null ? mTouchListener : null);
  setFocusable(l != null);
  updateTouchListener();
}",0.9364705882352942
191393,"void disconnect(Context context){
  try {
    if (mBound) {
      mBound=false;
      context.unbindService(this);
    }
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","void disconnect(Context context){
  try {
    if (mBound) {
      mBound=false;
      context.unbindService(this);
      if (DBG)       Log.d(TAG,""String_Node_Str"");
    }
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.6711409395973155
191394,"@Override public void onServiceDisconnected(ComponentName name){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + name.flattenToString());
}","@Override public void onServiceDisconnected(ComponentName name){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + name.flattenToString());
  }
  mConnected=false;
}",0.9054054054054054
191395,"@Override public void onServiceConnected(ComponentName name,IBinder service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + name.flattenToString());
}","@Override public void onServiceConnected(ComponentName name,IBinder service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + name.flattenToString());
  mConnected=true;
}",0.939297124600639
191396,"/** 
 * Called when the system is ready to run third-party code but before it actually does so. 
 */
void systemReady(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  ContentResolver cr=mContext.getContentResolver();
  if (Settings.Global.getInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,0) == 0) {
    String defaultPackage=mContext.getResources().getString(R.string.config_defaultNetworkScorerPackageName);
    if (!TextUtils.isEmpty(defaultPackage)) {
      NetworkScorerAppManager.setActiveScorer(mContext,defaultPackage);
    }
    Settings.Global.putInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,1);
  }
  registerPackageReceiverIfNeeded();
}","/** 
 * Called when the system is ready to run third-party code but before it actually does so. 
 */
void systemReady(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  ContentResolver cr=mContext.getContentResolver();
  if (Settings.Global.getInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,0) == 0) {
    String defaultPackage=mContext.getResources().getString(R.string.config_defaultNetworkScorerPackageName);
    if (!TextUtils.isEmpty(defaultPackage)) {
      NetworkScorerAppManager.setActiveScorer(mContext,defaultPackage);
    }
    Settings.Global.putInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,1);
  }
  registerPackageMonitorIfNeeded();
}",0.99009900990099
191397,"/** 
 * Set the active scorer. Callers are responsible for checking permissions as appropriate. 
 */
private boolean setScorerInternal(String packageName){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
  long token=Binder.clearCallingIdentity();
  try {
    unbindFromScoringServiceIfNeeded();
    clearInternal();
    NetworkScorerAppData prevScorer=NetworkScorerAppManager.getActiveScorer(mContext);
    boolean result=NetworkScorerAppManager.setActiveScorer(mContext,packageName);
    bindToScoringServiceIfNeeded();
    if (result) {
      registerPackageReceiverIfNeeded();
      Intent intent=new Intent(NetworkScoreManager.ACTION_SCORER_CHANGED);
      if (prevScorer != null) {
        intent.setPackage(prevScorer.mPackageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
      if (packageName != null) {
        intent.putExtra(NetworkScoreManager.EXTRA_NEW_SCORER,packageName);
        intent.setPackage(packageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
    }
    return result;
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}","/** 
 * Set the active scorer. Callers are responsible for checking permissions as appropriate. 
 */
private boolean setScorerInternal(String packageName){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
  long token=Binder.clearCallingIdentity();
  try {
    unbindFromScoringServiceIfNeeded();
    clearInternal();
    NetworkScorerAppData prevScorer=NetworkScorerAppManager.getActiveScorer(mContext);
    boolean result=NetworkScorerAppManager.setActiveScorer(mContext,packageName);
    bindToScoringServiceIfNeeded();
    if (result) {
      registerPackageMonitorIfNeeded();
      Intent intent=new Intent(NetworkScoreManager.ACTION_SCORER_CHANGED);
      if (prevScorer != null) {
        intent.setPackage(prevScorer.mPackageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
      if (packageName != null) {
        intent.putExtra(NetworkScoreManager.EXTRA_NEW_SCORER,packageName);
        intent.setPackage(packageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
    }
    return result;
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}",0.9943404440574662
191398,"public void dump(FileDescriptor fd,PrintWriter writer,String[] args){
  writer.println(""String_Node_Str"" + mComponentName + ""String_Node_Str""+ mBound);
}","public void dump(FileDescriptor fd,PrintWriter writer,String[] args){
  writer.println(""String_Node_Str"" + mComponentName + ""String_Node_Str""+ mBound+ ""String_Node_Str""+ mConnected);
}",0.9080118694362018
191399,"void connect(Context context){
  disconnect(context);
  Intent service=new Intent();
  service.setComponent(mComponentName);
  mBound=context.bindServiceAsUser(service,this,Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE,UserHandle.SYSTEM);
  if (!mBound) {
    Log.w(TAG,""String_Node_Str"" + service);
  }
}","void connect(Context context){
  if (!mBound) {
    Intent service=new Intent();
    service.setComponent(mComponentName);
    mBound=context.bindServiceAsUser(service,this,Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE,UserHandle.SYSTEM);
    if (!mBound) {
      Log.w(TAG,""String_Node_Str"" + service);
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
    }
  }
}",0.8354430379746836
191400,"/** 
 * @return the minimum apparent height that the wrapper should allow for the purposeof aligning elements at the bottom edge. If this is larger than the content height, the notification is clipped instead of being further shrunk.
 */
private int getMinContentHeightHint(){
  if (mIsChildInGroup && (mVisibleType == VISIBLE_TYPE_SINGLELINE || mTransformationStartVisibleType == VISIBLE_TYPE_SINGLELINE)) {
    return mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mHeadsUpChild != null) {
    return mHeadsUpChild.getHeight();
  }
 else {
    return mContractedChild.getHeight() + mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
}","/** 
 * @return the minimum apparent height that the wrapper should allow for the purposeof aligning elements at the bottom edge. If this is larger than the content height, the notification is clipped instead of being further shrunk.
 */
private int getMinContentHeightHint(){
  if (mIsChildInGroup && (mVisibleType == VISIBLE_TYPE_SINGLELINE || mTransformationStartVisibleType == VISIBLE_TYPE_SINGLELINE)) {
    return mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  int hint;
  if (mHeadsUpChild != null) {
    hint=mHeadsUpChild.getHeight();
  }
 else {
    hint=mContractedChild.getHeight() + mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mExpandedChild != null) {
    hint=Math.min(hint,mExpandedChild.getHeight());
  }
  return hint;
}",0.9158086008479708
191401,"/** 
 * @return the minimum apparent height that the wrapper should allow for the purposeof aligning elements at the bottom edge. If this is larger than the content height, the notification is clipped instead of being further shrunk.
 */
private int getMinContentHeightHint(){
  if (mIsChildInGroup && (mVisibleType == VISIBLE_TYPE_SINGLELINE || mTransformationStartVisibleType == VISIBLE_TYPE_SINGLELINE)) {
    return mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mHeadsUpChild != null) {
    return mHeadsUpChild.getHeight();
  }
 else {
    return mContractedChild.getHeight() + mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
}","/** 
 * @return the minimum apparent height that the wrapper should allow for the purposeof aligning elements at the bottom edge. If this is larger than the content height, the notification is clipped instead of being further shrunk.
 */
private int getMinContentHeightHint(){
  if (mIsChildInGroup && (mVisibleType == VISIBLE_TYPE_SINGLELINE || mTransformationStartVisibleType == VISIBLE_TYPE_SINGLELINE)) {
    return mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  int hint;
  if (mHeadsUpChild != null) {
    hint=mHeadsUpChild.getHeight();
  }
 else {
    hint=mContractedChild.getHeight() + mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mExpandedChild != null) {
    hint=Math.min(hint,mExpandedChild.getHeight());
  }
  return hint;
}",0.9158086008479708
191402,"public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        HeadsUpManager.setIsClickedNotification(row,true);
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      StatusBarNotification parentToCancel=null;
      if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
        StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
        if (shouldAutoCancel(summarySbn)) {
          parentToCancel=summarySbn;
        }
      }
      final StatusBarNotification parentToCancelFinal=parentToCancel;
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
          if (parentToCancelFinal != null) {
            mHandler.post(new Runnable(){
              @Override public void run(){
                Runnable removeRunnable=new Runnable(){
                  @Override public void run(){
                    performRemoveNotification(parentToCancelFinal,true);
                  }
                }
;
                if (isCollapsing()) {
                  addPostCollapseAction(removeRunnable);
                }
 else {
                  removeRunnable.run();
                }
              }
            }
);
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}","public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        if (isPanelFullyCollapsed()) {
          HeadsUpManager.setIsClickedNotification(row,true);
        }
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      StatusBarNotification parentToCancel=null;
      if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
        StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
        if (shouldAutoCancel(summarySbn)) {
          parentToCancel=summarySbn;
        }
      }
      final StatusBarNotification parentToCancelFinal=parentToCancel;
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
          if (parentToCancelFinal != null) {
            mHandler.post(new Runnable(){
              @Override public void run(){
                Runnable removeRunnable=new Runnable(){
                  @Override public void run(){
                    performRemoveNotification(parentToCancelFinal,true);
                  }
                }
;
                if (isCollapsing()) {
                  addPostCollapseAction(removeRunnable);
                }
 else {
                  removeRunnable.run();
                }
              }
            }
);
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}",0.9935172238464473
191403,"public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    HeadsUpManager.setIsClickedNotification(row,true);
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  StatusBarNotification parentToCancel=null;
  if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
    StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
    if (shouldAutoCancel(summarySbn)) {
      parentToCancel=summarySbn;
    }
  }
  final StatusBarNotification parentToCancelFinal=parentToCancel;
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
      if (parentToCancelFinal != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            Runnable removeRunnable=new Runnable(){
              @Override public void run(){
                performRemoveNotification(parentToCancelFinal,true);
              }
            }
;
            if (isCollapsing()) {
              addPostCollapseAction(removeRunnable);
            }
 else {
              removeRunnable.run();
            }
          }
        }
);
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}","public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    if (isPanelFullyCollapsed()) {
      HeadsUpManager.setIsClickedNotification(row,true);
    }
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  StatusBarNotification parentToCancel=null;
  if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
    StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
    if (shouldAutoCancel(summarySbn)) {
      parentToCancel=summarySbn;
    }
  }
  final StatusBarNotification parentToCancelFinal=parentToCancel;
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
      if (parentToCancelFinal != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            Runnable removeRunnable=new Runnable(){
              @Override public void run(){
                performRemoveNotification(parentToCancelFinal,true);
              }
            }
;
            if (isCollapsing()) {
              addPostCollapseAction(removeRunnable);
            }
 else {
              removeRunnable.run();
            }
          }
        }
);
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}",0.9913982796559312
191404,"public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        HeadsUpManager.setIsClickedNotification(row,true);
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      StatusBarNotification parentToCancel=null;
      if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
        StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
        if (shouldAutoCancel(summarySbn)) {
          parentToCancel=summarySbn;
        }
      }
      final StatusBarNotification parentToCancelFinal=parentToCancel;
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
          if (parentToCancelFinal != null) {
            mHandler.post(new Runnable(){
              @Override public void run(){
                Runnable removeRunnable=new Runnable(){
                  @Override public void run(){
                    performRemoveNotification(parentToCancelFinal,true);
                  }
                }
;
                if (isCollapsing()) {
                  addPostCollapseAction(removeRunnable);
                }
 else {
                  removeRunnable.run();
                }
              }
            }
);
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}","public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        if (isPanelFullyCollapsed()) {
          HeadsUpManager.setIsClickedNotification(row,true);
        }
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      StatusBarNotification parentToCancel=null;
      if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
        StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
        if (shouldAutoCancel(summarySbn)) {
          parentToCancel=summarySbn;
        }
      }
      final StatusBarNotification parentToCancelFinal=parentToCancel;
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
          if (parentToCancelFinal != null) {
            mHandler.post(new Runnable(){
              @Override public void run(){
                Runnable removeRunnable=new Runnable(){
                  @Override public void run(){
                    performRemoveNotification(parentToCancelFinal,true);
                  }
                }
;
                if (isCollapsing()) {
                  addPostCollapseAction(removeRunnable);
                }
 else {
                  removeRunnable.run();
                }
              }
            }
);
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}",0.9935172238464473
191405,"public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    HeadsUpManager.setIsClickedNotification(row,true);
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  StatusBarNotification parentToCancel=null;
  if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
    StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
    if (shouldAutoCancel(summarySbn)) {
      parentToCancel=summarySbn;
    }
  }
  final StatusBarNotification parentToCancelFinal=parentToCancel;
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
      if (parentToCancelFinal != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            Runnable removeRunnable=new Runnable(){
              @Override public void run(){
                performRemoveNotification(parentToCancelFinal,true);
              }
            }
;
            if (isCollapsing()) {
              addPostCollapseAction(removeRunnable);
            }
 else {
              removeRunnable.run();
            }
          }
        }
);
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}","public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    if (isPanelFullyCollapsed()) {
      HeadsUpManager.setIsClickedNotification(row,true);
    }
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  StatusBarNotification parentToCancel=null;
  if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
    StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
    if (shouldAutoCancel(summarySbn)) {
      parentToCancel=summarySbn;
    }
  }
  final StatusBarNotification parentToCancelFinal=parentToCancel;
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
      if (parentToCancelFinal != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            Runnable removeRunnable=new Runnable(){
              @Override public void run(){
                performRemoveNotification(parentToCancelFinal,true);
              }
            }
;
            if (isCollapsing()) {
              addPostCollapseAction(removeRunnable);
            }
 else {
              removeRunnable.run();
            }
          }
        }
);
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}",0.9913982796559312
191406,"void disconnect(Context context){
  try {
    if (mBound) {
      mBound=false;
      context.unbindService(this);
    }
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","void disconnect(Context context){
  try {
    if (mBound) {
      mBound=false;
      context.unbindService(this);
      if (DBG)       Log.d(TAG,""String_Node_Str"");
    }
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.6711409395973155
191407,"@Override public void onServiceDisconnected(ComponentName name){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + name.flattenToString());
}","@Override public void onServiceDisconnected(ComponentName name){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + name.flattenToString());
  }
  mConnected=false;
}",0.9054054054054054
191408,"@Override public void onServiceConnected(ComponentName name,IBinder service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + name.flattenToString());
}","@Override public void onServiceConnected(ComponentName name,IBinder service){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + name.flattenToString());
  mConnected=true;
}",0.939297124600639
191409,"/** 
 * Called when the system is ready to run third-party code but before it actually does so. 
 */
void systemReady(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  ContentResolver cr=mContext.getContentResolver();
  if (Settings.Global.getInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,0) == 0) {
    String defaultPackage=mContext.getResources().getString(R.string.config_defaultNetworkScorerPackageName);
    if (!TextUtils.isEmpty(defaultPackage)) {
      NetworkScorerAppManager.setActiveScorer(mContext,defaultPackage);
    }
    Settings.Global.putInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,1);
  }
  registerPackageReceiverIfNeeded();
}","/** 
 * Called when the system is ready to run third-party code but before it actually does so. 
 */
void systemReady(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  ContentResolver cr=mContext.getContentResolver();
  if (Settings.Global.getInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,0) == 0) {
    String defaultPackage=mContext.getResources().getString(R.string.config_defaultNetworkScorerPackageName);
    if (!TextUtils.isEmpty(defaultPackage)) {
      NetworkScorerAppManager.setActiveScorer(mContext,defaultPackage);
    }
    Settings.Global.putInt(cr,Settings.Global.NETWORK_SCORING_PROVISIONED,1);
  }
  registerPackageMonitorIfNeeded();
}",0.99009900990099
191410,"/** 
 * Set the active scorer. Callers are responsible for checking permissions as appropriate. 
 */
private boolean setScorerInternal(String packageName){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
  long token=Binder.clearCallingIdentity();
  try {
    unbindFromScoringServiceIfNeeded();
    clearInternal();
    NetworkScorerAppData prevScorer=NetworkScorerAppManager.getActiveScorer(mContext);
    boolean result=NetworkScorerAppManager.setActiveScorer(mContext,packageName);
    bindToScoringServiceIfNeeded();
    if (result) {
      registerPackageReceiverIfNeeded();
      Intent intent=new Intent(NetworkScoreManager.ACTION_SCORER_CHANGED);
      if (prevScorer != null) {
        intent.setPackage(prevScorer.mPackageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
      if (packageName != null) {
        intent.putExtra(NetworkScoreManager.EXTRA_NEW_SCORER,packageName);
        intent.setPackage(packageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
    }
    return result;
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}","/** 
 * Set the active scorer. Callers are responsible for checking permissions as appropriate. 
 */
private boolean setScorerInternal(String packageName){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
  long token=Binder.clearCallingIdentity();
  try {
    unbindFromScoringServiceIfNeeded();
    clearInternal();
    NetworkScorerAppData prevScorer=NetworkScorerAppManager.getActiveScorer(mContext);
    boolean result=NetworkScorerAppManager.setActiveScorer(mContext,packageName);
    bindToScoringServiceIfNeeded();
    if (result) {
      registerPackageMonitorIfNeeded();
      Intent intent=new Intent(NetworkScoreManager.ACTION_SCORER_CHANGED);
      if (prevScorer != null) {
        intent.setPackage(prevScorer.mPackageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
      if (packageName != null) {
        intent.putExtra(NetworkScoreManager.EXTRA_NEW_SCORER,packageName);
        intent.setPackage(packageName);
        mContext.sendBroadcastAsUser(intent,UserHandle.SYSTEM);
      }
    }
    return result;
  }
  finally {
    Binder.restoreCallingIdentity(token);
  }
}",0.9943404440574662
191411,"public void dump(FileDescriptor fd,PrintWriter writer,String[] args){
  writer.println(""String_Node_Str"" + mComponentName + ""String_Node_Str""+ mBound);
}","public void dump(FileDescriptor fd,PrintWriter writer,String[] args){
  writer.println(""String_Node_Str"" + mComponentName + ""String_Node_Str""+ mBound+ ""String_Node_Str""+ mConnected);
}",0.9080118694362018
191412,"void connect(Context context){
  disconnect(context);
  Intent service=new Intent();
  service.setComponent(mComponentName);
  mBound=context.bindServiceAsUser(service,this,Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE,UserHandle.SYSTEM);
  if (!mBound) {
    Log.w(TAG,""String_Node_Str"" + service);
  }
}","void connect(Context context){
  if (!mBound) {
    Intent service=new Intent();
    service.setComponent(mComponentName);
    mBound=context.bindServiceAsUser(service,this,Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE,UserHandle.SYSTEM);
    if (!mBound) {
      Log.w(TAG,""String_Node_Str"" + service);
    }
 else {
      if (DBG)       Log.d(TAG,""String_Node_Str"");
    }
  }
}",0.8354430379746836
191413,"public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        HeadsUpManager.setIsClickedNotification(row,true);
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      StatusBarNotification parentToCancel=null;
      if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
        StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
        if (shouldAutoCancel(summarySbn)) {
          parentToCancel=summarySbn;
        }
      }
      final StatusBarNotification parentToCancelFinal=parentToCancel;
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
          if (parentToCancelFinal != null) {
            mHandler.post(new Runnable(){
              @Override public void run(){
                Runnable removeRunnable=new Runnable(){
                  @Override public void run(){
                    performRemoveNotification(parentToCancelFinal,true);
                  }
                }
;
                if (isCollapsing()) {
                  addPostCollapseAction(removeRunnable);
                }
 else {
                  removeRunnable.run();
                }
              }
            }
);
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}","public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        if (isPanelFullyCollapsed()) {
          HeadsUpManager.setIsClickedNotification(row,true);
        }
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      StatusBarNotification parentToCancel=null;
      if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
        StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
        if (shouldAutoCancel(summarySbn)) {
          parentToCancel=summarySbn;
        }
      }
      final StatusBarNotification parentToCancelFinal=parentToCancel;
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
          if (parentToCancelFinal != null) {
            mHandler.post(new Runnable(){
              @Override public void run(){
                Runnable removeRunnable=new Runnable(){
                  @Override public void run(){
                    performRemoveNotification(parentToCancelFinal,true);
                  }
                }
;
                if (isCollapsing()) {
                  addPostCollapseAction(removeRunnable);
                }
 else {
                  removeRunnable.run();
                }
              }
            }
);
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}",0.9935172238464473
191414,"public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    HeadsUpManager.setIsClickedNotification(row,true);
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  StatusBarNotification parentToCancel=null;
  if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
    StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
    if (shouldAutoCancel(summarySbn)) {
      parentToCancel=summarySbn;
    }
  }
  final StatusBarNotification parentToCancelFinal=parentToCancel;
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
      if (parentToCancelFinal != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            Runnable removeRunnable=new Runnable(){
              @Override public void run(){
                performRemoveNotification(parentToCancelFinal,true);
              }
            }
;
            if (isCollapsing()) {
              addPostCollapseAction(removeRunnable);
            }
 else {
              removeRunnable.run();
            }
          }
        }
);
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}","public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    if (isPanelFullyCollapsed()) {
      HeadsUpManager.setIsClickedNotification(row,true);
    }
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  StatusBarNotification parentToCancel=null;
  if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
    StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
    if (shouldAutoCancel(summarySbn)) {
      parentToCancel=summarySbn;
    }
  }
  final StatusBarNotification parentToCancelFinal=parentToCancel;
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
      if (parentToCancelFinal != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            Runnable removeRunnable=new Runnable(){
              @Override public void run(){
                performRemoveNotification(parentToCancelFinal,true);
              }
            }
;
            if (isCollapsing()) {
              addPostCollapseAction(removeRunnable);
            }
 else {
              removeRunnable.run();
            }
          }
        }
);
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}",0.9913982796559312
191415,"private void resetAllStatsLocked(){
  mStartCount=0;
  initTimes(mClocks.uptimeMillis() * 1000,mClocks.elapsedRealtime() * 1000);
  mScreenOnTimer.reset(false);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].reset(false);
  }
  mInteractiveTimer.reset(false);
  mPowerSaveModeEnabledTimer.reset(false);
  mLongestLightIdleTime=0;
  mLongestFullIdleTime=0;
  mDeviceIdleModeLightTimer.reset(false);
  mDeviceIdleModeFullTimer.reset(false);
  mDeviceLightIdlingTimer.reset(false);
  mDeviceIdlingTimer.reset(false);
  mPhoneOnTimer.reset(false);
  mAudioOnTimer.reset(false);
  mVideoOnTimer.reset(false);
  mFlashlightOnTimer.reset(false);
  mCameraOnTimer.reset(false);
  mBluetoothScanTimer.reset(false);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].reset(false);
  }
  mPhoneSignalScanningTimer.reset(false);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].reset(false);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].reset(false);
    mNetworkPacketActivityCounters[i].reset(false);
  }
  mMobileRadioActiveTimer.reset(false);
  mMobileRadioActivePerAppTimer.reset(false);
  mMobileRadioActiveAdjustedTime.reset(false);
  mMobileRadioActiveUnknownTime.reset(false);
  mMobileRadioActiveUnknownCount.reset(false);
  mWifiOnTimer.reset(false);
  mGlobalWifiRunningTimer.reset(false);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SUPPL_STATES; i++) {
    mWifiSupplStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SIGNAL_STRENGTH_BINS; i++) {
    mWifiSignalStrengthsTimer[i].reset(false);
  }
  mWifiActivity.reset(false);
  mBluetoothActivity.reset(false);
  mModemActivity.reset(false);
  mNumConnectivityChange=mLoadedNumConnectivityChange=mUnpluggedNumConnectivityChange=0;
  for (int i=0; i < mUidStats.size(); i++) {
    if (mUidStats.valueAt(i).reset()) {
      mUidStats.remove(mUidStats.keyAt(i));
      i--;
    }
  }
  if (mKernelWakelockStats.size() > 0) {
    for (    SamplingTimer timer : mKernelWakelockStats.values()) {
      mOnBatteryScreenOffTimeBase.remove(timer);
    }
    mKernelWakelockStats.clear();
  }
  if (mWakeupReasonStats.size() > 0) {
    for (    SamplingTimer timer : mWakeupReasonStats.values()) {
      mOnBatteryTimeBase.remove(timer);
    }
    mWakeupReasonStats.clear();
  }
  mLastHistoryStepDetails=null;
  mLastStepCpuUserTime=mLastStepCpuSystemTime=0;
  mCurStepCpuUserTime=mCurStepCpuSystemTime=0;
  mLastStepCpuUserTime=mCurStepCpuUserTime=0;
  mLastStepCpuSystemTime=mCurStepCpuSystemTime=0;
  mLastStepStatUserTime=mCurStepStatUserTime=0;
  mLastStepStatSystemTime=mCurStepStatSystemTime=0;
  mLastStepStatIOWaitTime=mCurStepStatIOWaitTime=0;
  mLastStepStatIrqTime=mCurStepStatIrqTime=0;
  mLastStepStatSoftIrqTime=mCurStepStatSoftIrqTime=0;
  mLastStepStatIdleTime=mCurStepStatIdleTime=0;
  initDischarge();
  clearHistoryLocked();
}","private void resetAllStatsLocked(){
  final long uptimeMillis=mClocks.uptimeMillis();
  final long elapsedRealtimeMillis=mClocks.elapsedRealtime();
  mStartCount=0;
  initTimes(uptimeMillis * 1000,elapsedRealtimeMillis * 1000);
  mScreenOnTimer.reset(false);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].reset(false);
  }
  mInteractiveTimer.reset(false);
  mPowerSaveModeEnabledTimer.reset(false);
  mLastIdleTimeStart=elapsedRealtimeMillis;
  mLongestLightIdleTime=0;
  mLongestFullIdleTime=0;
  mDeviceIdleModeLightTimer.reset(false);
  mDeviceIdleModeFullTimer.reset(false);
  mDeviceLightIdlingTimer.reset(false);
  mDeviceIdlingTimer.reset(false);
  mPhoneOnTimer.reset(false);
  mAudioOnTimer.reset(false);
  mVideoOnTimer.reset(false);
  mFlashlightOnTimer.reset(false);
  mCameraOnTimer.reset(false);
  mBluetoothScanTimer.reset(false);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].reset(false);
  }
  mPhoneSignalScanningTimer.reset(false);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].reset(false);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].reset(false);
    mNetworkPacketActivityCounters[i].reset(false);
  }
  mMobileRadioActiveTimer.reset(false);
  mMobileRadioActivePerAppTimer.reset(false);
  mMobileRadioActiveAdjustedTime.reset(false);
  mMobileRadioActiveUnknownTime.reset(false);
  mMobileRadioActiveUnknownCount.reset(false);
  mWifiOnTimer.reset(false);
  mGlobalWifiRunningTimer.reset(false);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SUPPL_STATES; i++) {
    mWifiSupplStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SIGNAL_STRENGTH_BINS; i++) {
    mWifiSignalStrengthsTimer[i].reset(false);
  }
  mWifiActivity.reset(false);
  mBluetoothActivity.reset(false);
  mModemActivity.reset(false);
  mNumConnectivityChange=mLoadedNumConnectivityChange=mUnpluggedNumConnectivityChange=0;
  for (int i=0; i < mUidStats.size(); i++) {
    if (mUidStats.valueAt(i).reset()) {
      mUidStats.remove(mUidStats.keyAt(i));
      i--;
    }
  }
  if (mKernelWakelockStats.size() > 0) {
    for (    SamplingTimer timer : mKernelWakelockStats.values()) {
      mOnBatteryScreenOffTimeBase.remove(timer);
    }
    mKernelWakelockStats.clear();
  }
  if (mWakeupReasonStats.size() > 0) {
    for (    SamplingTimer timer : mWakeupReasonStats.values()) {
      mOnBatteryTimeBase.remove(timer);
    }
    mWakeupReasonStats.clear();
  }
  mLastHistoryStepDetails=null;
  mLastStepCpuUserTime=mLastStepCpuSystemTime=0;
  mCurStepCpuUserTime=mCurStepCpuSystemTime=0;
  mLastStepCpuUserTime=mCurStepCpuUserTime=0;
  mLastStepCpuSystemTime=mCurStepCpuSystemTime=0;
  mLastStepStatUserTime=mCurStepStatUserTime=0;
  mLastStepStatSystemTime=mCurStepStatSystemTime=0;
  mLastStepStatIOWaitTime=mCurStepStatIOWaitTime=0;
  mLastStepStatIrqTime=mCurStepStatIrqTime=0;
  mLastStepStatSoftIrqTime=mCurStepStatSoftIrqTime=0;
  mLastStepStatIdleTime=mCurStepStatIdleTime=0;
  initDischarge();
  clearHistoryLocked();
}",0.9708426786286448
191416,"void calculateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect){
  final WindowState w=mWin;
  final DisplayContent displayContent=w.getDisplayContent();
  if (displayContent == null) {
    clipRect.setEmpty();
    finalClipRect.setEmpty();
    return;
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mLastClipRect);
  if (!w.isDefaultDisplay()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
    mSystemDecorRect.intersect(-w.mCompatFrame.left,-w.mCompatFrame.top,displayInfo.logicalWidth - w.mCompatFrame.left,displayInfo.logicalHeight - w.mCompatFrame.top);
  }
 else   if (w.mLayer >= mService.mSystemDecorLayer) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mDecorFrame.isEmpty()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mAttrs.type == LayoutParams.TYPE_WALLPAPER && mAnimator.isAnimating()) {
    mTmpClipRect.set(mSystemDecorRect);
    calculateSystemDecorRect();
    mSystemDecorRect.union(mTmpClipRect);
  }
 else {
    calculateSystemDecorRect();
    if (DEBUG_WINDOW_CROP)     Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mDecorFrame+ ""String_Node_Str""+ mSystemDecorRect);
  }
  final boolean fullscreen=w.isFrameFullscreen(displayInfo);
  final boolean isFreeformResizing=w.isDragResizing() && w.getResizeMode() == DRAG_RESIZE_MODE_FREEFORM;
  clipRect.set((mHasClipRect && !fullscreen) ? mClipRect : mSystemDecorRect);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect+ ""String_Node_Str""+ mHasClipRect+ ""String_Node_Str""+ fullscreen);
  if (isFreeformResizing && !w.isChildWindow()) {
    clipRect.offset(w.mShownPosition.x,w.mShownPosition.y);
  }
  final WindowManager.LayoutParams attrs=w.mAttrs;
  clipRect.left-=attrs.surfaceInsets.left;
  clipRect.top-=attrs.surfaceInsets.top;
  clipRect.right+=attrs.surfaceInsets.right;
  clipRect.bottom+=attrs.surfaceInsets.bottom;
  if (mHasClipRect && fullscreen) {
    clipRect.intersect(mClipRect);
  }
  clipRect.offset(attrs.surfaceInsets.left,attrs.surfaceInsets.top);
  finalClipRect.setEmpty();
  adjustCropToStackBounds(w,clipRect,finalClipRect,isFreeformResizing);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect);
  w.transformFromScreenToSurfaceSpace(clipRect);
  if (w.hasJustMovedInStack() && mLastClipRect.isEmpty() && !clipRect.isEmpty()) {
    clipRect.setEmpty();
  }
}","void calculateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect){
  final WindowState w=mWin;
  final DisplayContent displayContent=w.getDisplayContent();
  if (displayContent == null) {
    clipRect.setEmpty();
    finalClipRect.setEmpty();
    return;
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mLastClipRect);
  if (!w.isDefaultDisplay()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
    mSystemDecorRect.intersect(-w.mCompatFrame.left,-w.mCompatFrame.top,displayInfo.logicalWidth - w.mCompatFrame.left,displayInfo.logicalHeight - w.mCompatFrame.top);
  }
 else   if (w.mLayer >= mService.mSystemDecorLayer) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mDecorFrame.isEmpty()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mAttrs.type == LayoutParams.TYPE_WALLPAPER && mAnimator.isAnimating()) {
    mTmpClipRect.set(mSystemDecorRect);
    calculateSystemDecorRect();
    mSystemDecorRect.union(mTmpClipRect);
  }
 else {
    calculateSystemDecorRect();
    if (DEBUG_WINDOW_CROP)     Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mDecorFrame+ ""String_Node_Str""+ mSystemDecorRect);
  }
  final boolean fullscreen=w.isFrameFullscreen(displayInfo);
  final boolean isFreeformResizing=w.isDragResizing() && w.getResizeMode() == DRAG_RESIZE_MODE_FREEFORM;
  clipRect.set((mHasClipRect && !fullscreen) ? mClipRect : mSystemDecorRect);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect+ ""String_Node_Str""+ mHasClipRect+ ""String_Node_Str""+ fullscreen);
  if (isFreeformResizing && !w.isChildWindow()) {
    clipRect.offset(w.mShownPosition.x,w.mShownPosition.y);
  }
  final WindowManager.LayoutParams attrs=w.mAttrs;
  clipRect.left-=attrs.surfaceInsets.left;
  clipRect.top-=attrs.surfaceInsets.top;
  clipRect.right+=attrs.surfaceInsets.right;
  clipRect.bottom+=attrs.surfaceInsets.bottom;
  if (mHasClipRect && fullscreen) {
    clipRect.intersect(mClipRect);
  }
  clipRect.offset(attrs.surfaceInsets.left,attrs.surfaceInsets.top);
  finalClipRect.setEmpty();
  adjustCropToStackBounds(w,clipRect,finalClipRect,isFreeformResizing);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect);
  w.transformClipRectFromScreenToSurfaceSpace(clipRect);
  if (w.hasJustMovedInStack() && mLastClipRect.isEmpty() && !clipRect.isEmpty()) {
    clipRect.setEmpty();
  }
}",0.9984550019312476
191417,"private void resetAllStatsLocked(){
  mStartCount=0;
  initTimes(mClocks.uptimeMillis() * 1000,mClocks.elapsedRealtime() * 1000);
  mScreenOnTimer.reset(false);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].reset(false);
  }
  mInteractiveTimer.reset(false);
  mPowerSaveModeEnabledTimer.reset(false);
  mLongestLightIdleTime=0;
  mLongestFullIdleTime=0;
  mDeviceIdleModeLightTimer.reset(false);
  mDeviceIdleModeFullTimer.reset(false);
  mDeviceLightIdlingTimer.reset(false);
  mDeviceIdlingTimer.reset(false);
  mPhoneOnTimer.reset(false);
  mAudioOnTimer.reset(false);
  mVideoOnTimer.reset(false);
  mFlashlightOnTimer.reset(false);
  mCameraOnTimer.reset(false);
  mBluetoothScanTimer.reset(false);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].reset(false);
  }
  mPhoneSignalScanningTimer.reset(false);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].reset(false);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].reset(false);
    mNetworkPacketActivityCounters[i].reset(false);
  }
  mMobileRadioActiveTimer.reset(false);
  mMobileRadioActivePerAppTimer.reset(false);
  mMobileRadioActiveAdjustedTime.reset(false);
  mMobileRadioActiveUnknownTime.reset(false);
  mMobileRadioActiveUnknownCount.reset(false);
  mWifiOnTimer.reset(false);
  mGlobalWifiRunningTimer.reset(false);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SUPPL_STATES; i++) {
    mWifiSupplStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SIGNAL_STRENGTH_BINS; i++) {
    mWifiSignalStrengthsTimer[i].reset(false);
  }
  mWifiActivity.reset(false);
  mBluetoothActivity.reset(false);
  mModemActivity.reset(false);
  mNumConnectivityChange=mLoadedNumConnectivityChange=mUnpluggedNumConnectivityChange=0;
  for (int i=0; i < mUidStats.size(); i++) {
    if (mUidStats.valueAt(i).reset()) {
      mUidStats.remove(mUidStats.keyAt(i));
      i--;
    }
  }
  if (mKernelWakelockStats.size() > 0) {
    for (    SamplingTimer timer : mKernelWakelockStats.values()) {
      mOnBatteryScreenOffTimeBase.remove(timer);
    }
    mKernelWakelockStats.clear();
  }
  if (mWakeupReasonStats.size() > 0) {
    for (    SamplingTimer timer : mWakeupReasonStats.values()) {
      mOnBatteryTimeBase.remove(timer);
    }
    mWakeupReasonStats.clear();
  }
  mLastHistoryStepDetails=null;
  mLastStepCpuUserTime=mLastStepCpuSystemTime=0;
  mCurStepCpuUserTime=mCurStepCpuSystemTime=0;
  mLastStepCpuUserTime=mCurStepCpuUserTime=0;
  mLastStepCpuSystemTime=mCurStepCpuSystemTime=0;
  mLastStepStatUserTime=mCurStepStatUserTime=0;
  mLastStepStatSystemTime=mCurStepStatSystemTime=0;
  mLastStepStatIOWaitTime=mCurStepStatIOWaitTime=0;
  mLastStepStatIrqTime=mCurStepStatIrqTime=0;
  mLastStepStatSoftIrqTime=mCurStepStatSoftIrqTime=0;
  mLastStepStatIdleTime=mCurStepStatIdleTime=0;
  initDischarge();
  clearHistoryLocked();
}","private void resetAllStatsLocked(){
  final long uptimeMillis=mClocks.uptimeMillis();
  final long elapsedRealtimeMillis=mClocks.elapsedRealtime();
  mStartCount=0;
  initTimes(uptimeMillis * 1000,elapsedRealtimeMillis * 1000);
  mScreenOnTimer.reset(false);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].reset(false);
  }
  mInteractiveTimer.reset(false);
  mPowerSaveModeEnabledTimer.reset(false);
  mLastIdleTimeStart=elapsedRealtimeMillis;
  mLongestLightIdleTime=0;
  mLongestFullIdleTime=0;
  mDeviceIdleModeLightTimer.reset(false);
  mDeviceIdleModeFullTimer.reset(false);
  mDeviceLightIdlingTimer.reset(false);
  mDeviceIdlingTimer.reset(false);
  mPhoneOnTimer.reset(false);
  mAudioOnTimer.reset(false);
  mVideoOnTimer.reset(false);
  mFlashlightOnTimer.reset(false);
  mCameraOnTimer.reset(false);
  mBluetoothScanTimer.reset(false);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].reset(false);
  }
  mPhoneSignalScanningTimer.reset(false);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].reset(false);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].reset(false);
    mNetworkPacketActivityCounters[i].reset(false);
  }
  mMobileRadioActiveTimer.reset(false);
  mMobileRadioActivePerAppTimer.reset(false);
  mMobileRadioActiveAdjustedTime.reset(false);
  mMobileRadioActiveUnknownTime.reset(false);
  mMobileRadioActiveUnknownCount.reset(false);
  mWifiOnTimer.reset(false);
  mGlobalWifiRunningTimer.reset(false);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SUPPL_STATES; i++) {
    mWifiSupplStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SIGNAL_STRENGTH_BINS; i++) {
    mWifiSignalStrengthsTimer[i].reset(false);
  }
  mWifiActivity.reset(false);
  mBluetoothActivity.reset(false);
  mModemActivity.reset(false);
  mNumConnectivityChange=mLoadedNumConnectivityChange=mUnpluggedNumConnectivityChange=0;
  for (int i=0; i < mUidStats.size(); i++) {
    if (mUidStats.valueAt(i).reset()) {
      mUidStats.remove(mUidStats.keyAt(i));
      i--;
    }
  }
  if (mKernelWakelockStats.size() > 0) {
    for (    SamplingTimer timer : mKernelWakelockStats.values()) {
      mOnBatteryScreenOffTimeBase.remove(timer);
    }
    mKernelWakelockStats.clear();
  }
  if (mWakeupReasonStats.size() > 0) {
    for (    SamplingTimer timer : mWakeupReasonStats.values()) {
      mOnBatteryTimeBase.remove(timer);
    }
    mWakeupReasonStats.clear();
  }
  mLastHistoryStepDetails=null;
  mLastStepCpuUserTime=mLastStepCpuSystemTime=0;
  mCurStepCpuUserTime=mCurStepCpuSystemTime=0;
  mLastStepCpuUserTime=mCurStepCpuUserTime=0;
  mLastStepCpuSystemTime=mCurStepCpuSystemTime=0;
  mLastStepStatUserTime=mCurStepStatUserTime=0;
  mLastStepStatSystemTime=mCurStepStatSystemTime=0;
  mLastStepStatIOWaitTime=mCurStepStatIOWaitTime=0;
  mLastStepStatIrqTime=mCurStepStatIrqTime=0;
  mLastStepStatSoftIrqTime=mCurStepStatSoftIrqTime=0;
  mLastStepStatIdleTime=mCurStepStatIdleTime=0;
  initDischarge();
  clearHistoryLocked();
}",0.9708426786286448
191418,"private void resetAllStatsLocked(){
  mStartCount=0;
  initTimes(mClocks.uptimeMillis() * 1000,mClocks.elapsedRealtime() * 1000);
  mScreenOnTimer.reset(false);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].reset(false);
  }
  mInteractiveTimer.reset(false);
  mPowerSaveModeEnabledTimer.reset(false);
  mLongestLightIdleTime=0;
  mLongestFullIdleTime=0;
  mDeviceIdleModeLightTimer.reset(false);
  mDeviceIdleModeFullTimer.reset(false);
  mDeviceLightIdlingTimer.reset(false);
  mDeviceIdlingTimer.reset(false);
  mPhoneOnTimer.reset(false);
  mAudioOnTimer.reset(false);
  mVideoOnTimer.reset(false);
  mFlashlightOnTimer.reset(false);
  mCameraOnTimer.reset(false);
  mBluetoothScanTimer.reset(false);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].reset(false);
  }
  mPhoneSignalScanningTimer.reset(false);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].reset(false);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].reset(false);
    mNetworkPacketActivityCounters[i].reset(false);
  }
  mMobileRadioActiveTimer.reset(false);
  mMobileRadioActivePerAppTimer.reset(false);
  mMobileRadioActiveAdjustedTime.reset(false);
  mMobileRadioActiveUnknownTime.reset(false);
  mMobileRadioActiveUnknownCount.reset(false);
  mWifiOnTimer.reset(false);
  mGlobalWifiRunningTimer.reset(false);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SUPPL_STATES; i++) {
    mWifiSupplStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SIGNAL_STRENGTH_BINS; i++) {
    mWifiSignalStrengthsTimer[i].reset(false);
  }
  mWifiActivity.reset(false);
  mBluetoothActivity.reset(false);
  mModemActivity.reset(false);
  mNumConnectivityChange=mLoadedNumConnectivityChange=mUnpluggedNumConnectivityChange=0;
  for (int i=0; i < mUidStats.size(); i++) {
    if (mUidStats.valueAt(i).reset()) {
      mUidStats.remove(mUidStats.keyAt(i));
      i--;
    }
  }
  if (mKernelWakelockStats.size() > 0) {
    for (    SamplingTimer timer : mKernelWakelockStats.values()) {
      mOnBatteryScreenOffTimeBase.remove(timer);
    }
    mKernelWakelockStats.clear();
  }
  if (mWakeupReasonStats.size() > 0) {
    for (    SamplingTimer timer : mWakeupReasonStats.values()) {
      mOnBatteryTimeBase.remove(timer);
    }
    mWakeupReasonStats.clear();
  }
  mLastHistoryStepDetails=null;
  mLastStepCpuUserTime=mLastStepCpuSystemTime=0;
  mCurStepCpuUserTime=mCurStepCpuSystemTime=0;
  mLastStepCpuUserTime=mCurStepCpuUserTime=0;
  mLastStepCpuSystemTime=mCurStepCpuSystemTime=0;
  mLastStepStatUserTime=mCurStepStatUserTime=0;
  mLastStepStatSystemTime=mCurStepStatSystemTime=0;
  mLastStepStatIOWaitTime=mCurStepStatIOWaitTime=0;
  mLastStepStatIrqTime=mCurStepStatIrqTime=0;
  mLastStepStatSoftIrqTime=mCurStepStatSoftIrqTime=0;
  mLastStepStatIdleTime=mCurStepStatIdleTime=0;
  initDischarge();
  clearHistoryLocked();
}","private void resetAllStatsLocked(){
  final long uptimeMillis=mClocks.uptimeMillis();
  final long elapsedRealtimeMillis=mClocks.elapsedRealtime();
  mStartCount=0;
  initTimes(uptimeMillis * 1000,elapsedRealtimeMillis * 1000);
  mScreenOnTimer.reset(false);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].reset(false);
  }
  mInteractiveTimer.reset(false);
  mPowerSaveModeEnabledTimer.reset(false);
  mLastIdleTimeStart=elapsedRealtimeMillis;
  mLongestLightIdleTime=0;
  mLongestFullIdleTime=0;
  mDeviceIdleModeLightTimer.reset(false);
  mDeviceIdleModeFullTimer.reset(false);
  mDeviceLightIdlingTimer.reset(false);
  mDeviceIdlingTimer.reset(false);
  mPhoneOnTimer.reset(false);
  mAudioOnTimer.reset(false);
  mVideoOnTimer.reset(false);
  mFlashlightOnTimer.reset(false);
  mCameraOnTimer.reset(false);
  mBluetoothScanTimer.reset(false);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].reset(false);
  }
  mPhoneSignalScanningTimer.reset(false);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].reset(false);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].reset(false);
    mNetworkPacketActivityCounters[i].reset(false);
  }
  mMobileRadioActiveTimer.reset(false);
  mMobileRadioActivePerAppTimer.reset(false);
  mMobileRadioActiveAdjustedTime.reset(false);
  mMobileRadioActiveUnknownTime.reset(false);
  mMobileRadioActiveUnknownCount.reset(false);
  mWifiOnTimer.reset(false);
  mGlobalWifiRunningTimer.reset(false);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SUPPL_STATES; i++) {
    mWifiSupplStateTimer[i].reset(false);
  }
  for (int i=0; i < NUM_WIFI_SIGNAL_STRENGTH_BINS; i++) {
    mWifiSignalStrengthsTimer[i].reset(false);
  }
  mWifiActivity.reset(false);
  mBluetoothActivity.reset(false);
  mModemActivity.reset(false);
  mNumConnectivityChange=mLoadedNumConnectivityChange=mUnpluggedNumConnectivityChange=0;
  for (int i=0; i < mUidStats.size(); i++) {
    if (mUidStats.valueAt(i).reset()) {
      mUidStats.remove(mUidStats.keyAt(i));
      i--;
    }
  }
  if (mKernelWakelockStats.size() > 0) {
    for (    SamplingTimer timer : mKernelWakelockStats.values()) {
      mOnBatteryScreenOffTimeBase.remove(timer);
    }
    mKernelWakelockStats.clear();
  }
  if (mWakeupReasonStats.size() > 0) {
    for (    SamplingTimer timer : mWakeupReasonStats.values()) {
      mOnBatteryTimeBase.remove(timer);
    }
    mWakeupReasonStats.clear();
  }
  mLastHistoryStepDetails=null;
  mLastStepCpuUserTime=mLastStepCpuSystemTime=0;
  mCurStepCpuUserTime=mCurStepCpuSystemTime=0;
  mLastStepCpuUserTime=mCurStepCpuUserTime=0;
  mLastStepCpuSystemTime=mCurStepCpuSystemTime=0;
  mLastStepStatUserTime=mCurStepStatUserTime=0;
  mLastStepStatSystemTime=mCurStepStatSystemTime=0;
  mLastStepStatIOWaitTime=mCurStepStatIOWaitTime=0;
  mLastStepStatIrqTime=mCurStepStatIrqTime=0;
  mLastStepStatSoftIrqTime=mCurStepStatSoftIrqTime=0;
  mLastStepStatIdleTime=mCurStepStatIdleTime=0;
  initDischarge();
  clearHistoryLocked();
}",0.9708426786286448
191419,"/** 
 * @return the minimum apparent height that the wrapper should allow for the purposeof aligning elements at the bottom edge. If this is larger than the content height, the notification is clipped instead of being further shrunk.
 */
private int getMinContentHeightHint(){
  if (mIsChildInGroup && (mVisibleType == VISIBLE_TYPE_SINGLELINE || mTransformationStartVisibleType == VISIBLE_TYPE_SINGLELINE)) {
    return mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mHeadsUpChild != null) {
    return mHeadsUpChild.getHeight();
  }
 else {
    return mContractedChild.getHeight() + mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
}","/** 
 * @return the minimum apparent height that the wrapper should allow for the purposeof aligning elements at the bottom edge. If this is larger than the content height, the notification is clipped instead of being further shrunk.
 */
private int getMinContentHeightHint(){
  if (mIsChildInGroup && (mVisibleType == VISIBLE_TYPE_SINGLELINE || mTransformationStartVisibleType == VISIBLE_TYPE_SINGLELINE)) {
    return mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  int hint;
  if (mHeadsUpChild != null) {
    hint=mHeadsUpChild.getHeight();
  }
 else {
    hint=mContractedChild.getHeight() + mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_action_list_height);
  }
  if (mExpandedChild != null) {
    hint=Math.min(hint,mExpandedChild.getHeight());
  }
  return hint;
}",0.9158086008479708
191420,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
if (removed) {
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.9927978198806126
191421,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
if (removed) {
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.9927978198806126
191422,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
if (removed) {
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ callerApp.toShortString()+ ""String_Node_Str""+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str""+ UserHandle.formatUid(callingUid)+ ""String_Node_Str""+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,""String_Node_Str"" + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.9927978198806126
191423,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateClipping();
  invalidateOutline();
  selectLayout(false,mForceSelectNextLayout);
  mForceSelectNextLayout=false;
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateClipping();
  invalidateOutline();
  selectLayout(false,mForceSelectNextLayout);
  mForceSelectNextLayout=false;
  updateExpandButtons(mExpandable);
}",0.935483870967742
191424,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateClipping();
  invalidateOutline();
  selectLayout(false,mForceSelectNextLayout);
  mForceSelectNextLayout=false;
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateClipping();
  invalidateOutline();
  selectLayout(false,mForceSelectNextLayout);
  mForceSelectNextLayout=false;
  updateExpandButtons(mExpandable);
}",0.935483870967742
191425,"private void startAnimationToState(){
  if (mNeedsAnimation) {
    generateChildHierarchyEvents();
    mNeedsAnimation=false;
  }
  if (!mAnimationEvents.isEmpty() || isCurrentlyAnimating()) {
    mStateAnimator.startAnimationForEvents(mAnimationEvents,mCurrentStackScrollState,mGoToFullShadeDelay);
    setAnimationRunning(true);
    mAnimationEvents.clear();
    updateBackground();
    updateViewShadows();
  }
 else {
    applyCurrentState();
  }
  mGoToFullShadeDelay=0;
}","private void startAnimationToState(){
  if (mNeedsAnimation) {
    generateChildHierarchyEvents();
    mNeedsAnimation=false;
  }
  if (!mAnimationEvents.isEmpty() || isCurrentlyAnimating()) {
    setAnimationRunning(true);
    mStateAnimator.startAnimationForEvents(mAnimationEvents,mCurrentStackScrollState,mGoToFullShadeDelay);
    mAnimationEvents.clear();
    updateBackground();
    updateViewShadows();
  }
 else {
    applyCurrentState();
  }
  mGoToFullShadeDelay=0;
}",0.9350104821802936
191426,"private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
  updateBackground();
  updateViewShadows();
}","private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
  setAnimationRunning(false);
  updateBackground();
  updateViewShadows();
}",0.9380165289256198
191427,"private void startBackgroundFadeIn(){
  ObjectAnimator fadeAnimator=ObjectAnimator.ofFloat(this,BACKGROUND_FADE,0f,1f);
  int maxLength;
  if (mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_ABOVE || mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_BELOW) {
    maxLength=getNotGoneChildCount() - 1;
  }
 else {
    maxLength=Math.max(mDarkAnimationOriginIndex,getNotGoneChildCount() - mDarkAnimationOriginIndex - 1);
  }
  long delay=maxLength * StackStateAnimator.ANIMATION_DELAY_PER_ELEMENT_DARK;
  fadeAnimator.setStartDelay(delay);
  fadeAnimator.setDuration(StackStateAnimator.ANIMATION_DURATION_STANDARD);
  fadeAnimator.setInterpolator(Interpolators.ALPHA_IN);
  fadeAnimator.start();
}","private void startBackgroundFadeIn(){
  ObjectAnimator fadeAnimator=ObjectAnimator.ofFloat(this,BACKGROUND_FADE,0f,1f);
  int maxLength;
  if (mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_ABOVE || mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_BELOW) {
    maxLength=getNotGoneChildCount() - 1;
  }
 else {
    maxLength=Math.max(mDarkAnimationOriginIndex,getNotGoneChildCount() - mDarkAnimationOriginIndex - 1);
  }
  maxLength=Math.max(0,maxLength);
  long delay=maxLength * StackStateAnimator.ANIMATION_DELAY_PER_ELEMENT_DARK;
  fadeAnimator.setStartDelay(delay);
  fadeAnimator.setDuration(StackStateAnimator.ANIMATION_DURATION_STANDARD);
  fadeAnimator.setInterpolator(Interpolators.ALPHA_IN);
  fadeAnimator.start();
}",0.976928147659855
191428,"/** 
 * Notifies the screenshot service to show an error.
 */
private void notifyScreenshotError(){
  final ComponentName errorComponent=new ComponentName(SYSUI_PACKAGE,SYSUI_SCREENSHOT_ERROR_RECEIVER);
  Intent errorIntent=new Intent();
  errorIntent.setComponent(errorComponent);
  errorIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_FOREGROUND);
  mContext.sendBroadcastAsUser(errorIntent,UserHandle.CURRENT);
}","/** 
 * Notifies the screenshot service to show an error.
 */
private void notifyScreenshotError(){
  final ComponentName errorComponent=new ComponentName(SYSUI_PACKAGE,SYSUI_SCREENSHOT_ERROR_RECEIVER);
  Intent errorIntent=new Intent(Intent.ACTION_USER_PRESENT);
  errorIntent.setComponent(errorComponent);
  errorIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_FOREGROUND);
  mContext.sendBroadcastAsUser(errorIntent,UserHandle.CURRENT);
}",0.9722222222222222
191429,"private void startAnimationToState(){
  if (mNeedsAnimation) {
    generateChildHierarchyEvents();
    mNeedsAnimation=false;
  }
  if (!mAnimationEvents.isEmpty() || isCurrentlyAnimating()) {
    mStateAnimator.startAnimationForEvents(mAnimationEvents,mCurrentStackScrollState,mGoToFullShadeDelay);
    setAnimationRunning(true);
    mAnimationEvents.clear();
    updateBackground();
    updateViewShadows();
  }
 else {
    applyCurrentState();
  }
  mGoToFullShadeDelay=0;
}","private void startAnimationToState(){
  if (mNeedsAnimation) {
    generateChildHierarchyEvents();
    mNeedsAnimation=false;
  }
  if (!mAnimationEvents.isEmpty() || isCurrentlyAnimating()) {
    setAnimationRunning(true);
    mStateAnimator.startAnimationForEvents(mAnimationEvents,mCurrentStackScrollState,mGoToFullShadeDelay);
    mAnimationEvents.clear();
    updateBackground();
    updateViewShadows();
  }
 else {
    applyCurrentState();
  }
  mGoToFullShadeDelay=0;
}",0.9350104821802936
191430,"private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
  updateBackground();
  updateViewShadows();
}","private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
  setAnimationRunning(false);
  updateBackground();
  updateViewShadows();
}",0.9380165289256198
191431,"private void startBackgroundFadeIn(){
  ObjectAnimator fadeAnimator=ObjectAnimator.ofFloat(this,BACKGROUND_FADE,0f,1f);
  int maxLength;
  if (mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_ABOVE || mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_BELOW) {
    maxLength=getNotGoneChildCount() - 1;
  }
 else {
    maxLength=Math.max(mDarkAnimationOriginIndex,getNotGoneChildCount() - mDarkAnimationOriginIndex - 1);
  }
  long delay=maxLength * StackStateAnimator.ANIMATION_DELAY_PER_ELEMENT_DARK;
  fadeAnimator.setStartDelay(delay);
  fadeAnimator.setDuration(StackStateAnimator.ANIMATION_DURATION_STANDARD);
  fadeAnimator.setInterpolator(Interpolators.ALPHA_IN);
  fadeAnimator.start();
}","private void startBackgroundFadeIn(){
  ObjectAnimator fadeAnimator=ObjectAnimator.ofFloat(this,BACKGROUND_FADE,0f,1f);
  int maxLength;
  if (mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_ABOVE || mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_BELOW) {
    maxLength=getNotGoneChildCount() - 1;
  }
 else {
    maxLength=Math.max(mDarkAnimationOriginIndex,getNotGoneChildCount() - mDarkAnimationOriginIndex - 1);
  }
  maxLength=Math.max(0,maxLength);
  long delay=maxLength * StackStateAnimator.ANIMATION_DELAY_PER_ELEMENT_DARK;
  fadeAnimator.setStartDelay(delay);
  fadeAnimator.setDuration(StackStateAnimator.ANIMATION_DURATION_STANDARD);
  fadeAnimator.setInterpolator(Interpolators.ALPHA_IN);
  fadeAnimator.start();
}",0.976928147659855
191432,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateClipping();
  invalidateOutline();
  selectLayout(false,mForceSelectNextLayout);
  mForceSelectNextLayout=false;
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateClipping();
  invalidateOutline();
  selectLayout(false,mForceSelectNextLayout);
  mForceSelectNextLayout=false;
  updateExpandButtons(mExpandable);
}",0.935483870967742
191433,"/** 
 * Notifies the screenshot service to show an error.
 */
private void notifyScreenshotError(){
  final ComponentName errorComponent=new ComponentName(SYSUI_PACKAGE,SYSUI_SCREENSHOT_ERROR_RECEIVER);
  Intent errorIntent=new Intent();
  errorIntent.setComponent(errorComponent);
  errorIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_FOREGROUND);
  mContext.sendBroadcastAsUser(errorIntent,UserHandle.CURRENT);
}","/** 
 * Notifies the screenshot service to show an error.
 */
private void notifyScreenshotError(){
  final ComponentName errorComponent=new ComponentName(SYSUI_PACKAGE,SYSUI_SCREENSHOT_ERROR_RECEIVER);
  Intent errorIntent=new Intent(Intent.ACTION_USER_PRESENT);
  errorIntent.setComponent(errorComponent);
  errorIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_FOREGROUND);
  mContext.sendBroadcastAsUser(errorIntent,UserHandle.CURRENT);
}",0.9722222222222222
191434,"@Override public void bindView(View view,Context context,Cursor cursor){
  CheckedTextView text=(CheckedTextView)view.findViewById(R.id.text1);
  text.setText(cursor.getString(mLabelIndex));
  listView.setItemChecked(cursor.getPosition(),cursor.getInt(mIsCheckedIndex) == 1);
}","@Override public void bindView(View view,Context context,Cursor cursor){
  CheckedTextView text=(CheckedTextView)view.findViewById(R.id.text1);
  text.setText(cursor.getString(mLabelIndex));
  listView.setItemChecked(cursor.getPosition() + listView.getHeaderViewsCount(),cursor.getInt(mIsCheckedIndex) == 1);
}",0.9437819420783644
191435,"private void createListView(final AlertController dialog){
  final RecycleListView listView=(RecycleListView)mInflater.inflate(dialog.mListLayout,null);
  final ListAdapter adapter;
  if (mIsMultiChoice) {
    if (mCursor == null) {
      adapter=new ArrayAdapter<CharSequence>(mContext,dialog.mMultiChoiceItemLayout,R.id.text1,mItems){
        @Override public View getView(        int position,        View convertView,        ViewGroup parent){
          View view=super.getView(position,convertView,parent);
          if (mCheckedItems != null) {
            boolean isItemChecked=mCheckedItems[position];
            if (isItemChecked) {
              listView.setItemChecked(position,true);
            }
          }
          return view;
        }
      }
;
    }
 else {
      adapter=new CursorAdapter(mContext,mCursor,false){
        private final int mLabelIndex;
        private final int mIsCheckedIndex;
{
          final Cursor cursor=getCursor();
          mLabelIndex=cursor.getColumnIndexOrThrow(mLabelColumn);
          mIsCheckedIndex=cursor.getColumnIndexOrThrow(mIsCheckedColumn);
        }
        @Override public void bindView(        View view,        Context context,        Cursor cursor){
          CheckedTextView text=(CheckedTextView)view.findViewById(R.id.text1);
          text.setText(cursor.getString(mLabelIndex));
          listView.setItemChecked(cursor.getPosition(),cursor.getInt(mIsCheckedIndex) == 1);
        }
        @Override public View newView(        Context context,        Cursor cursor,        ViewGroup parent){
          return mInflater.inflate(dialog.mMultiChoiceItemLayout,parent,false);
        }
      }
;
    }
  }
 else {
    final int layout;
    if (mIsSingleChoice) {
      layout=dialog.mSingleChoiceItemLayout;
    }
 else {
      layout=dialog.mListItemLayout;
    }
    if (mCursor != null) {
      adapter=new SimpleCursorAdapter(mContext,layout,mCursor,new String[]{mLabelColumn},new int[]{R.id.text1});
    }
 else     if (mAdapter != null) {
      adapter=mAdapter;
    }
 else {
      adapter=new CheckedItemAdapter(mContext,layout,R.id.text1,mItems);
    }
  }
  if (mOnPrepareListViewListener != null) {
    mOnPrepareListViewListener.onPrepareListView(listView);
  }
  dialog.mAdapter=adapter;
  dialog.mCheckedItem=mCheckedItem;
  if (mOnClickListener != null) {
    listView.setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View v,      int position,      long id){
        position-=listView.getHeaderViewsCount();
        mOnClickListener.onClick(dialog.mDialogInterface,position);
        if (!mIsSingleChoice) {
          dialog.mDialogInterface.dismiss();
        }
      }
    }
);
  }
 else   if (mOnCheckboxClickListener != null) {
    listView.setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View v,      int position,      long id){
        position-=listView.getHeaderViewsCount();
        if (mCheckedItems != null) {
          mCheckedItems[position]=listView.isItemChecked(position);
        }
        mOnCheckboxClickListener.onClick(dialog.mDialogInterface,position,listView.isItemChecked(position));
      }
    }
);
  }
  if (mOnItemSelectedListener != null) {
    listView.setOnItemSelectedListener(mOnItemSelectedListener);
  }
  if (mIsSingleChoice) {
    listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  }
 else   if (mIsMultiChoice) {
    listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
  }
  listView.mRecycleOnMeasure=mRecycleOnMeasure;
  dialog.mListView=listView;
}","private void createListView(final AlertController dialog){
  final RecycleListView listView=(RecycleListView)mInflater.inflate(dialog.mListLayout,null);
  final ListAdapter adapter;
  if (mIsMultiChoice) {
    if (mCursor == null) {
      adapter=new ArrayAdapter<CharSequence>(mContext,dialog.mMultiChoiceItemLayout,R.id.text1,mItems){
        @Override public View getView(        int position,        View convertView,        ViewGroup parent){
          View view=super.getView(position,convertView,parent);
          if (mCheckedItems != null) {
            boolean isItemChecked=mCheckedItems[position];
            if (isItemChecked) {
              listView.setItemChecked(position + listView.getHeaderViewsCount(),true);
            }
          }
          return view;
        }
      }
;
    }
 else {
      adapter=new CursorAdapter(mContext,mCursor,false){
        private final int mLabelIndex;
        private final int mIsCheckedIndex;
{
          final Cursor cursor=getCursor();
          mLabelIndex=cursor.getColumnIndexOrThrow(mLabelColumn);
          mIsCheckedIndex=cursor.getColumnIndexOrThrow(mIsCheckedColumn);
        }
        @Override public void bindView(        View view,        Context context,        Cursor cursor){
          CheckedTextView text=(CheckedTextView)view.findViewById(R.id.text1);
          text.setText(cursor.getString(mLabelIndex));
          listView.setItemChecked(cursor.getPosition() + listView.getHeaderViewsCount(),cursor.getInt(mIsCheckedIndex) == 1);
        }
        @Override public View newView(        Context context,        Cursor cursor,        ViewGroup parent){
          return mInflater.inflate(dialog.mMultiChoiceItemLayout,parent,false);
        }
      }
;
    }
  }
 else {
    final int layout;
    if (mIsSingleChoice) {
      layout=dialog.mSingleChoiceItemLayout;
    }
 else {
      layout=dialog.mListItemLayout;
    }
    if (mCursor != null) {
      adapter=new SimpleCursorAdapter(mContext,layout,mCursor,new String[]{mLabelColumn},new int[]{R.id.text1});
    }
 else     if (mAdapter != null) {
      adapter=mAdapter;
    }
 else {
      adapter=new CheckedItemAdapter(mContext,layout,R.id.text1,mItems);
    }
  }
  if (mOnPrepareListViewListener != null) {
    mOnPrepareListViewListener.onPrepareListView(listView);
  }
  dialog.mAdapter=adapter;
  dialog.mCheckedItem=mCheckedItem;
  if (mOnClickListener != null) {
    listView.setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View v,      int position,      long id){
        position-=listView.getHeaderViewsCount();
        mOnClickListener.onClick(dialog.mDialogInterface,position);
        if (!mIsSingleChoice) {
          dialog.mDialogInterface.dismiss();
        }
      }
    }
);
  }
 else   if (mOnCheckboxClickListener != null) {
    listView.setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View v,      int position,      long id){
        position-=listView.getHeaderViewsCount();
        if (mCheckedItems != null) {
          mCheckedItems[position]=listView.isItemChecked(position);
        }
        mOnCheckboxClickListener.onClick(dialog.mDialogInterface,position,listView.isItemChecked(position));
      }
    }
);
  }
  if (mOnItemSelectedListener != null) {
    listView.setOnItemSelectedListener(mOnItemSelectedListener);
  }
  if (mIsSingleChoice) {
    listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  }
 else   if (mIsMultiChoice) {
    listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
  }
  listView.mRecycleOnMeasure=mRecycleOnMeasure;
  dialog.mListView=listView;
}",0.9910057236304172
191436,"private void setBackground(TypedArray a,View topPanel,View contentPanel,View customPanel,View buttonPanel,boolean hasTitle,boolean hasCustomView,boolean hasButtons){
  int fullDark=0;
  int topDark=0;
  int centerDark=0;
  int bottomDark=0;
  int fullBright=0;
  int topBright=0;
  int centerBright=0;
  int bottomBright=0;
  int bottomMedium=0;
  final boolean needsDefaultBackgrounds=a.getBoolean(R.styleable.AlertDialog_needsDefaultBackgrounds,true);
  if (needsDefaultBackgrounds) {
    fullDark=R.drawable.popup_full_dark;
    topDark=R.drawable.popup_top_dark;
    centerDark=R.drawable.popup_center_dark;
    bottomDark=R.drawable.popup_bottom_dark;
    fullBright=R.drawable.popup_full_bright;
    topBright=R.drawable.popup_top_bright;
    centerBright=R.drawable.popup_center_bright;
    bottomBright=R.drawable.popup_bottom_bright;
    bottomMedium=R.drawable.popup_bottom_medium;
  }
  topBright=a.getResourceId(R.styleable.AlertDialog_topBright,topBright);
  topDark=a.getResourceId(R.styleable.AlertDialog_topDark,topDark);
  centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,centerBright);
  centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,centerDark);
  final View[] views=new View[4];
  final boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=contentPanel.getVisibility() == View.GONE ? null : contentPanel;
  light[pos]=mListView != null;
  pos++;
  if (hasCustomView) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    final View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,bottomBright);
      bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,bottomMedium);
      bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,bottomDark);
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,fullBright);
      fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,fullDark);
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  final ListView listView=mListView;
  if (listView != null && mAdapter != null) {
    listView.setAdapter(mAdapter);
    final int checkedItem=mCheckedItem;
    if (checkedItem > -1) {
      listView.setItemChecked(checkedItem,true);
      listView.setSelection(checkedItem);
    }
  }
}","private void setBackground(TypedArray a,View topPanel,View contentPanel,View customPanel,View buttonPanel,boolean hasTitle,boolean hasCustomView,boolean hasButtons){
  int fullDark=0;
  int topDark=0;
  int centerDark=0;
  int bottomDark=0;
  int fullBright=0;
  int topBright=0;
  int centerBright=0;
  int bottomBright=0;
  int bottomMedium=0;
  final boolean needsDefaultBackgrounds=a.getBoolean(R.styleable.AlertDialog_needsDefaultBackgrounds,true);
  if (needsDefaultBackgrounds) {
    fullDark=R.drawable.popup_full_dark;
    topDark=R.drawable.popup_top_dark;
    centerDark=R.drawable.popup_center_dark;
    bottomDark=R.drawable.popup_bottom_dark;
    fullBright=R.drawable.popup_full_bright;
    topBright=R.drawable.popup_top_bright;
    centerBright=R.drawable.popup_center_bright;
    bottomBright=R.drawable.popup_bottom_bright;
    bottomMedium=R.drawable.popup_bottom_medium;
  }
  topBright=a.getResourceId(R.styleable.AlertDialog_topBright,topBright);
  topDark=a.getResourceId(R.styleable.AlertDialog_topDark,topDark);
  centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,centerBright);
  centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,centerDark);
  final View[] views=new View[4];
  final boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=contentPanel.getVisibility() == View.GONE ? null : contentPanel;
  light[pos]=mListView != null;
  pos++;
  if (hasCustomView) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    final View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,bottomBright);
      bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,bottomMedium);
      bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,bottomDark);
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,fullBright);
      fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,fullDark);
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  final ListView listView=mListView;
  if (listView != null && mAdapter != null) {
    listView.setAdapter(mAdapter);
    final int checkedItem=mCheckedItem;
    if (checkedItem > -1) {
      listView.setItemChecked(checkedItem + listView.getHeaderViewsCount(),true);
      listView.setSelection(checkedItem + listView.getHeaderViewsCount());
    }
  }
}",0.9894602363462152
191437,"@Override public View getView(int position,View convertView,ViewGroup parent){
  View view=super.getView(position,convertView,parent);
  if (mCheckedItems != null) {
    boolean isItemChecked=mCheckedItems[position];
    if (isItemChecked) {
      listView.setItemChecked(position,true);
    }
  }
  return view;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  View view=super.getView(position,convertView,parent);
  if (mCheckedItems != null) {
    boolean isItemChecked=mCheckedItems[position];
    if (isItemChecked) {
      listView.setItemChecked(position + listView.getHeaderViewsCount(),true);
    }
  }
  return view;
}",0.9500756429652042
191438,"/** 
 * Notifies the screenshot service to show an error.
 */
private void notifyScreenshotError(){
  final ComponentName errorComponent=new ComponentName(SYSUI_PACKAGE,SYSUI_SCREENSHOT_ERROR_RECEIVER);
  Intent errorIntent=new Intent();
  errorIntent.setComponent(errorComponent);
  errorIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_FOREGROUND);
  mContext.sendBroadcastAsUser(errorIntent,UserHandle.CURRENT);
}","/** 
 * Notifies the screenshot service to show an error.
 */
private void notifyScreenshotError(){
  final ComponentName errorComponent=new ComponentName(SYSUI_PACKAGE,SYSUI_SCREENSHOT_ERROR_RECEIVER);
  Intent errorIntent=new Intent(Intent.ACTION_USER_PRESENT);
  errorIntent.setComponent(errorComponent);
  errorIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_FOREGROUND);
  mContext.sendBroadcastAsUser(errorIntent,UserHandle.CURRENT);
}",0.9722222222222222
191439,"private void startAnimationToState(){
  if (mNeedsAnimation) {
    generateChildHierarchyEvents();
    mNeedsAnimation=false;
  }
  if (!mAnimationEvents.isEmpty() || isCurrentlyAnimating()) {
    mStateAnimator.startAnimationForEvents(mAnimationEvents,mCurrentStackScrollState,mGoToFullShadeDelay);
    setAnimationRunning(true);
    mAnimationEvents.clear();
    updateBackground();
    updateViewShadows();
  }
 else {
    applyCurrentState();
  }
  mGoToFullShadeDelay=0;
}","private void startAnimationToState(){
  if (mNeedsAnimation) {
    generateChildHierarchyEvents();
    mNeedsAnimation=false;
  }
  if (!mAnimationEvents.isEmpty() || isCurrentlyAnimating()) {
    setAnimationRunning(true);
    mStateAnimator.startAnimationForEvents(mAnimationEvents,mCurrentStackScrollState,mGoToFullShadeDelay);
    mAnimationEvents.clear();
    updateBackground();
    updateViewShadows();
  }
 else {
    applyCurrentState();
  }
  mGoToFullShadeDelay=0;
}",0.9350104821802936
191440,"private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
  updateBackground();
  updateViewShadows();
}","private void applyCurrentState(){
  mCurrentStackScrollState.apply();
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
  runAnimationFinishedRunnables();
  setAnimationRunning(false);
  updateBackground();
  updateViewShadows();
}",0.9380165289256198
191441,"private void startBackgroundFadeIn(){
  ObjectAnimator fadeAnimator=ObjectAnimator.ofFloat(this,BACKGROUND_FADE,0f,1f);
  int maxLength;
  if (mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_ABOVE || mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_BELOW) {
    maxLength=getNotGoneChildCount() - 1;
  }
 else {
    maxLength=Math.max(mDarkAnimationOriginIndex,getNotGoneChildCount() - mDarkAnimationOriginIndex - 1);
  }
  long delay=maxLength * StackStateAnimator.ANIMATION_DELAY_PER_ELEMENT_DARK;
  fadeAnimator.setStartDelay(delay);
  fadeAnimator.setDuration(StackStateAnimator.ANIMATION_DURATION_STANDARD);
  fadeAnimator.setInterpolator(Interpolators.ALPHA_IN);
  fadeAnimator.start();
}","private void startBackgroundFadeIn(){
  ObjectAnimator fadeAnimator=ObjectAnimator.ofFloat(this,BACKGROUND_FADE,0f,1f);
  int maxLength;
  if (mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_ABOVE || mDarkAnimationOriginIndex == AnimationEvent.DARK_ANIMATION_ORIGIN_INDEX_BELOW) {
    maxLength=getNotGoneChildCount() - 1;
  }
 else {
    maxLength=Math.max(mDarkAnimationOriginIndex,getNotGoneChildCount() - mDarkAnimationOriginIndex - 1);
  }
  maxLength=Math.max(0,maxLength);
  long delay=maxLength * StackStateAnimator.ANIMATION_DELAY_PER_ELEMENT_DARK;
  fadeAnimator.setStartDelay(delay);
  fadeAnimator.setDuration(StackStateAnimator.ANIMATION_DURATION_STANDARD);
  fadeAnimator.setInterpolator(Interpolators.ALPHA_IN);
  fadeAnimator.start();
}",0.976928147659855
191442,"@Override public void bindView(View view,Context context,Cursor cursor){
  CheckedTextView text=(CheckedTextView)view.findViewById(R.id.text1);
  text.setText(cursor.getString(mLabelIndex));
  listView.setItemChecked(cursor.getPosition(),cursor.getInt(mIsCheckedIndex) == 1);
}","@Override public void bindView(View view,Context context,Cursor cursor){
  CheckedTextView text=(CheckedTextView)view.findViewById(R.id.text1);
  text.setText(cursor.getString(mLabelIndex));
  listView.setItemChecked(cursor.getPosition() + listView.getHeaderViewsCount(),cursor.getInt(mIsCheckedIndex) == 1);
}",0.9437819420783644
191443,"private void createListView(final AlertController dialog){
  final RecycleListView listView=(RecycleListView)mInflater.inflate(dialog.mListLayout,null);
  final ListAdapter adapter;
  if (mIsMultiChoice) {
    if (mCursor == null) {
      adapter=new ArrayAdapter<CharSequence>(mContext,dialog.mMultiChoiceItemLayout,R.id.text1,mItems){
        @Override public View getView(        int position,        View convertView,        ViewGroup parent){
          View view=super.getView(position,convertView,parent);
          if (mCheckedItems != null) {
            boolean isItemChecked=mCheckedItems[position];
            if (isItemChecked) {
              listView.setItemChecked(position,true);
            }
          }
          return view;
        }
      }
;
    }
 else {
      adapter=new CursorAdapter(mContext,mCursor,false){
        private final int mLabelIndex;
        private final int mIsCheckedIndex;
{
          final Cursor cursor=getCursor();
          mLabelIndex=cursor.getColumnIndexOrThrow(mLabelColumn);
          mIsCheckedIndex=cursor.getColumnIndexOrThrow(mIsCheckedColumn);
        }
        @Override public void bindView(        View view,        Context context,        Cursor cursor){
          CheckedTextView text=(CheckedTextView)view.findViewById(R.id.text1);
          text.setText(cursor.getString(mLabelIndex));
          listView.setItemChecked(cursor.getPosition(),cursor.getInt(mIsCheckedIndex) == 1);
        }
        @Override public View newView(        Context context,        Cursor cursor,        ViewGroup parent){
          return mInflater.inflate(dialog.mMultiChoiceItemLayout,parent,false);
        }
      }
;
    }
  }
 else {
    final int layout;
    if (mIsSingleChoice) {
      layout=dialog.mSingleChoiceItemLayout;
    }
 else {
      layout=dialog.mListItemLayout;
    }
    if (mCursor != null) {
      adapter=new SimpleCursorAdapter(mContext,layout,mCursor,new String[]{mLabelColumn},new int[]{R.id.text1});
    }
 else     if (mAdapter != null) {
      adapter=mAdapter;
    }
 else {
      adapter=new CheckedItemAdapter(mContext,layout,R.id.text1,mItems);
    }
  }
  if (mOnPrepareListViewListener != null) {
    mOnPrepareListViewListener.onPrepareListView(listView);
  }
  dialog.mAdapter=adapter;
  dialog.mCheckedItem=mCheckedItem;
  if (mOnClickListener != null) {
    listView.setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View v,      int position,      long id){
        position-=listView.getHeaderViewsCount();
        mOnClickListener.onClick(dialog.mDialogInterface,position);
        if (!mIsSingleChoice) {
          dialog.mDialogInterface.dismiss();
        }
      }
    }
);
  }
 else   if (mOnCheckboxClickListener != null) {
    listView.setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View v,      int position,      long id){
        position-=listView.getHeaderViewsCount();
        if (mCheckedItems != null) {
          mCheckedItems[position]=listView.isItemChecked(position);
        }
        mOnCheckboxClickListener.onClick(dialog.mDialogInterface,position,listView.isItemChecked(position));
      }
    }
);
  }
  if (mOnItemSelectedListener != null) {
    listView.setOnItemSelectedListener(mOnItemSelectedListener);
  }
  if (mIsSingleChoice) {
    listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  }
 else   if (mIsMultiChoice) {
    listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
  }
  listView.mRecycleOnMeasure=mRecycleOnMeasure;
  dialog.mListView=listView;
}","private void createListView(final AlertController dialog){
  final RecycleListView listView=(RecycleListView)mInflater.inflate(dialog.mListLayout,null);
  final ListAdapter adapter;
  if (mIsMultiChoice) {
    if (mCursor == null) {
      adapter=new ArrayAdapter<CharSequence>(mContext,dialog.mMultiChoiceItemLayout,R.id.text1,mItems){
        @Override public View getView(        int position,        View convertView,        ViewGroup parent){
          View view=super.getView(position,convertView,parent);
          if (mCheckedItems != null) {
            boolean isItemChecked=mCheckedItems[position];
            if (isItemChecked) {
              listView.setItemChecked(position + listView.getHeaderViewsCount(),true);
            }
          }
          return view;
        }
      }
;
    }
 else {
      adapter=new CursorAdapter(mContext,mCursor,false){
        private final int mLabelIndex;
        private final int mIsCheckedIndex;
{
          final Cursor cursor=getCursor();
          mLabelIndex=cursor.getColumnIndexOrThrow(mLabelColumn);
          mIsCheckedIndex=cursor.getColumnIndexOrThrow(mIsCheckedColumn);
        }
        @Override public void bindView(        View view,        Context context,        Cursor cursor){
          CheckedTextView text=(CheckedTextView)view.findViewById(R.id.text1);
          text.setText(cursor.getString(mLabelIndex));
          listView.setItemChecked(cursor.getPosition() + listView.getHeaderViewsCount(),cursor.getInt(mIsCheckedIndex) == 1);
        }
        @Override public View newView(        Context context,        Cursor cursor,        ViewGroup parent){
          return mInflater.inflate(dialog.mMultiChoiceItemLayout,parent,false);
        }
      }
;
    }
  }
 else {
    final int layout;
    if (mIsSingleChoice) {
      layout=dialog.mSingleChoiceItemLayout;
    }
 else {
      layout=dialog.mListItemLayout;
    }
    if (mCursor != null) {
      adapter=new SimpleCursorAdapter(mContext,layout,mCursor,new String[]{mLabelColumn},new int[]{R.id.text1});
    }
 else     if (mAdapter != null) {
      adapter=mAdapter;
    }
 else {
      adapter=new CheckedItemAdapter(mContext,layout,R.id.text1,mItems);
    }
  }
  if (mOnPrepareListViewListener != null) {
    mOnPrepareListViewListener.onPrepareListView(listView);
  }
  dialog.mAdapter=adapter;
  dialog.mCheckedItem=mCheckedItem;
  if (mOnClickListener != null) {
    listView.setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View v,      int position,      long id){
        position-=listView.getHeaderViewsCount();
        mOnClickListener.onClick(dialog.mDialogInterface,position);
        if (!mIsSingleChoice) {
          dialog.mDialogInterface.dismiss();
        }
      }
    }
);
  }
 else   if (mOnCheckboxClickListener != null) {
    listView.setOnItemClickListener(new OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View v,      int position,      long id){
        position-=listView.getHeaderViewsCount();
        if (mCheckedItems != null) {
          mCheckedItems[position]=listView.isItemChecked(position);
        }
        mOnCheckboxClickListener.onClick(dialog.mDialogInterface,position,listView.isItemChecked(position));
      }
    }
);
  }
  if (mOnItemSelectedListener != null) {
    listView.setOnItemSelectedListener(mOnItemSelectedListener);
  }
  if (mIsSingleChoice) {
    listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  }
 else   if (mIsMultiChoice) {
    listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
  }
  listView.mRecycleOnMeasure=mRecycleOnMeasure;
  dialog.mListView=listView;
}",0.9910057236304172
191444,"private void setBackground(TypedArray a,View topPanel,View contentPanel,View customPanel,View buttonPanel,boolean hasTitle,boolean hasCustomView,boolean hasButtons){
  int fullDark=0;
  int topDark=0;
  int centerDark=0;
  int bottomDark=0;
  int fullBright=0;
  int topBright=0;
  int centerBright=0;
  int bottomBright=0;
  int bottomMedium=0;
  final boolean needsDefaultBackgrounds=a.getBoolean(R.styleable.AlertDialog_needsDefaultBackgrounds,true);
  if (needsDefaultBackgrounds) {
    fullDark=R.drawable.popup_full_dark;
    topDark=R.drawable.popup_top_dark;
    centerDark=R.drawable.popup_center_dark;
    bottomDark=R.drawable.popup_bottom_dark;
    fullBright=R.drawable.popup_full_bright;
    topBright=R.drawable.popup_top_bright;
    centerBright=R.drawable.popup_center_bright;
    bottomBright=R.drawable.popup_bottom_bright;
    bottomMedium=R.drawable.popup_bottom_medium;
  }
  topBright=a.getResourceId(R.styleable.AlertDialog_topBright,topBright);
  topDark=a.getResourceId(R.styleable.AlertDialog_topDark,topDark);
  centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,centerBright);
  centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,centerDark);
  final View[] views=new View[4];
  final boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=contentPanel.getVisibility() == View.GONE ? null : contentPanel;
  light[pos]=mListView != null;
  pos++;
  if (hasCustomView) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    final View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,bottomBright);
      bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,bottomMedium);
      bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,bottomDark);
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,fullBright);
      fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,fullDark);
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  final ListView listView=mListView;
  if (listView != null && mAdapter != null) {
    listView.setAdapter(mAdapter);
    final int checkedItem=mCheckedItem;
    if (checkedItem > -1) {
      listView.setItemChecked(checkedItem,true);
      listView.setSelection(checkedItem);
    }
  }
}","private void setBackground(TypedArray a,View topPanel,View contentPanel,View customPanel,View buttonPanel,boolean hasTitle,boolean hasCustomView,boolean hasButtons){
  int fullDark=0;
  int topDark=0;
  int centerDark=0;
  int bottomDark=0;
  int fullBright=0;
  int topBright=0;
  int centerBright=0;
  int bottomBright=0;
  int bottomMedium=0;
  final boolean needsDefaultBackgrounds=a.getBoolean(R.styleable.AlertDialog_needsDefaultBackgrounds,true);
  if (needsDefaultBackgrounds) {
    fullDark=R.drawable.popup_full_dark;
    topDark=R.drawable.popup_top_dark;
    centerDark=R.drawable.popup_center_dark;
    bottomDark=R.drawable.popup_bottom_dark;
    fullBright=R.drawable.popup_full_bright;
    topBright=R.drawable.popup_top_bright;
    centerBright=R.drawable.popup_center_bright;
    bottomBright=R.drawable.popup_bottom_bright;
    bottomMedium=R.drawable.popup_bottom_medium;
  }
  topBright=a.getResourceId(R.styleable.AlertDialog_topBright,topBright);
  topDark=a.getResourceId(R.styleable.AlertDialog_topDark,topDark);
  centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,centerBright);
  centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,centerDark);
  final View[] views=new View[4];
  final boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=contentPanel.getVisibility() == View.GONE ? null : contentPanel;
  light[pos]=mListView != null;
  pos++;
  if (hasCustomView) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    final View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,bottomBright);
      bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,bottomMedium);
      bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,bottomDark);
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,fullBright);
      fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,fullDark);
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  final ListView listView=mListView;
  if (listView != null && mAdapter != null) {
    listView.setAdapter(mAdapter);
    final int checkedItem=mCheckedItem;
    if (checkedItem > -1) {
      listView.setItemChecked(checkedItem + listView.getHeaderViewsCount(),true);
      listView.setSelection(checkedItem + listView.getHeaderViewsCount());
    }
  }
}",0.9894602363462152
191445,"@Override public View getView(int position,View convertView,ViewGroup parent){
  View view=super.getView(position,convertView,parent);
  if (mCheckedItems != null) {
    boolean isItemChecked=mCheckedItems[position];
    if (isItemChecked) {
      listView.setItemChecked(position,true);
    }
  }
  return view;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  View view=super.getView(position,convertView,parent);
  if (mCheckedItems != null) {
    boolean isItemChecked=mCheckedItems[position];
    if (isItemChecked) {
      listView.setItemChecked(position + listView.getHeaderViewsCount(),true);
    }
  }
  return view;
}",0.9500756429652042
191446,"public int sendIntentSender(IIntentSender target,int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(target.asBinder());
  data.writeInt(code);
  if ((intent != null)) {
    data.writeInt(1);
    intent.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  data.writeString(resolvedType);
  data.writeStrongBinder((((finishedReceiver != null)) ? (finishedReceiver.asBinder()) : (null)));
  data.writeString(requiredPermission);
  if ((options != null)) {
    data.writeInt(1);
    options.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(SEND_INTENT_SENDER_TRANSACTION,data,reply,0);
  final int res=reply.readInt();
  data.recycle();
  reply.recycle();
  return res;
}","public int sendIntentSender(IIntentSender target,int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(target.asBinder());
  data.writeInt(code);
  if ((intent != null)) {
    data.writeInt(1);
    intent.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  data.writeString(resolvedType);
  data.writeStrongBinder((((finishedReceiver != null)) ? (finishedReceiver.asBinder()) : (null)));
  data.writeString(requiredPermission);
  if ((options != null)) {
    data.writeInt(1);
    options.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(SEND_INTENT_SENDER_TRANSACTION,data,reply,0);
  reply.readException();
  final int res=reply.readInt();
  data.recycle();
  reply.recycle();
  return res;
}",0.9869451697127938
191447,"/** 
 * @param hasProgress whether the progress bar should be shown and set
 */
private RemoteViews applyStandardTemplate(int resId,boolean hasProgress,CharSequence title,CharSequence text){
  RemoteViews contentView=new BuilderRemoteViews(mContext.getApplicationInfo(),resId);
  resetStandardTemplate(contentView);
  final Bundle ex=mN.extras;
  bindNotificationHeader(contentView);
  bindLargeIcon(contentView);
  if (title != null) {
    contentView.setViewVisibility(R.id.title,View.VISIBLE);
    contentView.setTextViewText(R.id.title,title);
  }
  boolean showProgress=handleProgressBar(hasProgress,contentView,ex);
  if (text != null) {
    int textId=showProgress ? com.android.internal.R.id.text_line_1 : com.android.internal.R.id.text;
    contentView.setTextViewText(textId,text);
    contentView.setViewVisibility(textId,View.VISIBLE);
  }
  setContentMinHeight(contentView,showProgress || mN.mLargeIcon != null);
  return contentView;
}","/** 
 * @param hasProgress whether the progress bar should be shown and set
 */
private RemoteViews applyStandardTemplate(int resId,boolean hasProgress,CharSequence title,CharSequence text){
  RemoteViews contentView=new BuilderRemoteViews(mContext.getApplicationInfo(),resId);
  resetStandardTemplate(contentView);
  final Bundle ex=mN.extras;
  bindNotificationHeader(contentView);
  bindLargeIcon(contentView);
  boolean showProgress=handleProgressBar(hasProgress,contentView,ex);
  if (title != null) {
    contentView.setViewVisibility(R.id.title,View.VISIBLE);
    contentView.setTextViewText(R.id.title,title);
    contentView.setViewLayoutWidth(R.id.title,showProgress ? ViewGroup.LayoutParams.WRAP_CONTENT : ViewGroup.LayoutParams.MATCH_PARENT);
  }
  if (text != null) {
    int textId=showProgress ? com.android.internal.R.id.text_line_1 : com.android.internal.R.id.text;
    contentView.setTextViewText(textId,text);
    contentView.setViewVisibility(textId,View.VISIBLE);
  }
  setContentMinHeight(contentView,showProgress || mN.mLargeIcon != null);
  return contentView;
}",0.8638820638820639
191448,"public int sendIntentSender(IIntentSender target,int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(target.asBinder());
  data.writeInt(code);
  if ((intent != null)) {
    data.writeInt(1);
    intent.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  data.writeString(resolvedType);
  data.writeStrongBinder((((finishedReceiver != null)) ? (finishedReceiver.asBinder()) : (null)));
  data.writeString(requiredPermission);
  if ((options != null)) {
    data.writeInt(1);
    options.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(SEND_INTENT_SENDER_TRANSACTION,data,reply,0);
  final int res=reply.readInt();
  data.recycle();
  reply.recycle();
  return res;
}","public int sendIntentSender(IIntentSender target,int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(target.asBinder());
  data.writeInt(code);
  if ((intent != null)) {
    data.writeInt(1);
    intent.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  data.writeString(resolvedType);
  data.writeStrongBinder((((finishedReceiver != null)) ? (finishedReceiver.asBinder()) : (null)));
  data.writeString(requiredPermission);
  if ((options != null)) {
    data.writeInt(1);
    options.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(SEND_INTENT_SENDER_TRANSACTION,data,reply,0);
  reply.readException();
  final int res=reply.readInt();
  data.recycle();
  reply.recycle();
  return res;
}",0.9869451697127938
191449,"public int sendIntentSender(IIntentSender target,int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(target.asBinder());
  data.writeInt(code);
  if ((intent != null)) {
    data.writeInt(1);
    intent.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  data.writeString(resolvedType);
  data.writeStrongBinder((((finishedReceiver != null)) ? (finishedReceiver.asBinder()) : (null)));
  data.writeString(requiredPermission);
  if ((options != null)) {
    data.writeInt(1);
    options.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(SEND_INTENT_SENDER_TRANSACTION,data,reply,0);
  final int res=reply.readInt();
  data.recycle();
  reply.recycle();
  return res;
}","public int sendIntentSender(IIntentSender target,int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(target.asBinder());
  data.writeInt(code);
  if ((intent != null)) {
    data.writeInt(1);
    intent.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  data.writeString(resolvedType);
  data.writeStrongBinder((((finishedReceiver != null)) ? (finishedReceiver.asBinder()) : (null)));
  data.writeString(requiredPermission);
  if ((options != null)) {
    data.writeInt(1);
    options.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(SEND_INTENT_SENDER_TRANSACTION,data,reply,0);
  reply.readException();
  final int res=reply.readInt();
  data.recycle();
  reply.recycle();
  return res;
}",0.9869451697127938
191450,"private void updateScrim(boolean animate,View scrim,float alpha,float currentAlpha){
  if (mKeyguardFadingOutInProgress) {
    return;
  }
  ValueAnimator previousAnimator=StackStateAnimator.getChildTag(scrim,TAG_KEY_ANIM);
  float animEndValue=-1;
  if (previousAnimator != null) {
    if (animate || alpha == currentAlpha) {
      previousAnimator.cancel();
    }
 else {
      animEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
    }
  }
  if (alpha != currentAlpha && alpha != animEndValue) {
    if (animate) {
      startScrimAnimation(scrim,alpha);
      scrim.setTag(TAG_START_ALPHA,currentAlpha);
      scrim.setTag(TAG_END_ALPHA,alpha);
    }
 else {
      if (previousAnimator != null) {
        float previousStartValue=StackStateAnimator.getChildTag(scrim,TAG_START_ALPHA);
        float previousEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
        PropertyValuesHolder[] values=previousAnimator.getValues();
        float relativeDiff=alpha - previousEndValue;
        float newStartValue=previousStartValue + relativeDiff;
        values[0].setFloatValues(newStartValue,alpha);
        scrim.setTag(TAG_START_ALPHA,newStartValue);
        scrim.setTag(TAG_END_ALPHA,alpha);
        previousAnimator.setCurrentPlayTime(previousAnimator.getCurrentPlayTime());
      }
 else {
        setCurrentScrimAlpha(scrim,alpha);
        updateScrimColor(scrim);
      }
    }
  }
}","private void updateScrim(boolean animate,View scrim,float alpha,float currentAlpha){
  if (mKeyguardFadingOutInProgress) {
    return;
  }
  ValueAnimator previousAnimator=StackStateAnimator.getChildTag(scrim,TAG_KEY_ANIM);
  float animEndValue=-1;
  if (previousAnimator != null) {
    if (animate || alpha == currentAlpha) {
      previousAnimator.cancel();
    }
 else {
      animEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
    }
  }
  if (alpha != currentAlpha && alpha != animEndValue) {
    if (animate) {
      startScrimAnimation(scrim,alpha);
      scrim.setTag(TAG_START_ALPHA,currentAlpha);
      scrim.setTag(TAG_END_ALPHA,alpha);
    }
 else {
      if (previousAnimator != null) {
        float previousStartValue=StackStateAnimator.getChildTag(scrim,TAG_START_ALPHA);
        float previousEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
        PropertyValuesHolder[] values=previousAnimator.getValues();
        float relativeDiff=alpha - previousEndValue;
        float newStartValue=previousStartValue + relativeDiff;
        newStartValue=Math.max(0,Math.min(1.0f,newStartValue));
        values[0].setFloatValues(newStartValue,alpha);
        scrim.setTag(TAG_START_ALPHA,newStartValue);
        scrim.setTag(TAG_END_ALPHA,alpha);
        previousAnimator.setCurrentPlayTime(previousAnimator.getCurrentPlayTime());
      }
 else {
        setCurrentScrimAlpha(scrim,alpha);
        updateScrimColor(scrim);
      }
    }
  }
}",0.9779005524861878
191451,"private void updateScrimColor(View scrim){
  float alpha1=getCurrentScrimAlpha(scrim);
  if (scrim instanceof ScrimView) {
    float alpha2=getDozeAlpha(scrim);
    float alpha=1 - (1 - alpha1) * (1 - alpha2);
    ((ScrimView)scrim).setScrimColor(Color.argb((int)(alpha * 255),0,0,0));
  }
 else {
    scrim.setAlpha(alpha1);
  }
}","private void updateScrimColor(View scrim){
  float alpha1=getCurrentScrimAlpha(scrim);
  if (scrim instanceof ScrimView) {
    float alpha2=getDozeAlpha(scrim);
    float alpha=1 - (1 - alpha1) * (1 - alpha2);
    alpha=Math.max(0,Math.min(1.0f,alpha));
    ((ScrimView)scrim).setScrimColor(Color.argb((int)(alpha * 255),0,0,0));
  }
 else {
    scrim.setAlpha(alpha1);
  }
}",0.9376770538243626
191452,"private void updateScrim(boolean animate,View scrim,float alpha,float currentAlpha){
  if (mKeyguardFadingOutInProgress) {
    return;
  }
  ValueAnimator previousAnimator=StackStateAnimator.getChildTag(scrim,TAG_KEY_ANIM);
  float animEndValue=-1;
  if (previousAnimator != null) {
    if (animate || alpha == currentAlpha) {
      previousAnimator.cancel();
    }
 else {
      animEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
    }
  }
  if (alpha != currentAlpha && alpha != animEndValue) {
    if (animate) {
      startScrimAnimation(scrim,alpha);
      scrim.setTag(TAG_START_ALPHA,currentAlpha);
      scrim.setTag(TAG_END_ALPHA,alpha);
    }
 else {
      if (previousAnimator != null) {
        float previousStartValue=StackStateAnimator.getChildTag(scrim,TAG_START_ALPHA);
        float previousEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
        PropertyValuesHolder[] values=previousAnimator.getValues();
        float relativeDiff=alpha - previousEndValue;
        float newStartValue=previousStartValue + relativeDiff;
        values[0].setFloatValues(newStartValue,alpha);
        scrim.setTag(TAG_START_ALPHA,newStartValue);
        scrim.setTag(TAG_END_ALPHA,alpha);
        previousAnimator.setCurrentPlayTime(previousAnimator.getCurrentPlayTime());
      }
 else {
        setCurrentScrimAlpha(scrim,alpha);
        updateScrimColor(scrim);
      }
    }
  }
}","private void updateScrim(boolean animate,View scrim,float alpha,float currentAlpha){
  if (mKeyguardFadingOutInProgress) {
    return;
  }
  ValueAnimator previousAnimator=StackStateAnimator.getChildTag(scrim,TAG_KEY_ANIM);
  float animEndValue=-1;
  if (previousAnimator != null) {
    if (animate || alpha == currentAlpha) {
      previousAnimator.cancel();
    }
 else {
      animEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
    }
  }
  if (alpha != currentAlpha && alpha != animEndValue) {
    if (animate) {
      startScrimAnimation(scrim,alpha);
      scrim.setTag(TAG_START_ALPHA,currentAlpha);
      scrim.setTag(TAG_END_ALPHA,alpha);
    }
 else {
      if (previousAnimator != null) {
        float previousStartValue=StackStateAnimator.getChildTag(scrim,TAG_START_ALPHA);
        float previousEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
        PropertyValuesHolder[] values=previousAnimator.getValues();
        float relativeDiff=alpha - previousEndValue;
        float newStartValue=previousStartValue + relativeDiff;
        newStartValue=Math.max(0,Math.min(1.0f,newStartValue));
        values[0].setFloatValues(newStartValue,alpha);
        scrim.setTag(TAG_START_ALPHA,newStartValue);
        scrim.setTag(TAG_END_ALPHA,alpha);
        previousAnimator.setCurrentPlayTime(previousAnimator.getCurrentPlayTime());
      }
 else {
        setCurrentScrimAlpha(scrim,alpha);
        updateScrimColor(scrim);
      }
    }
  }
}",0.9779005524861878
191453,"private void updateScrimColor(View scrim){
  float alpha1=getCurrentScrimAlpha(scrim);
  if (scrim instanceof ScrimView) {
    float alpha2=getDozeAlpha(scrim);
    float alpha=1 - (1 - alpha1) * (1 - alpha2);
    ((ScrimView)scrim).setScrimColor(Color.argb((int)(alpha * 255),0,0,0));
  }
 else {
    scrim.setAlpha(alpha1);
  }
}","private void updateScrimColor(View scrim){
  float alpha1=getCurrentScrimAlpha(scrim);
  if (scrim instanceof ScrimView) {
    float alpha2=getDozeAlpha(scrim);
    float alpha=1 - (1 - alpha1) * (1 - alpha2);
    alpha=Math.max(0,Math.min(1.0f,alpha));
    ((ScrimView)scrim).setScrimColor(Color.argb((int)(alpha * 255),0,0,0));
  }
 else {
    scrim.setAlpha(alpha1);
  }
}",0.9376770538243626
191454,"/** 
 * Set this view to count down to the base instead of counting up from it.
 * @param countDown whether this view should count down
 * @see #setBase(long)
 */
@android.view.RemotableViewMethod public void setCountDown(boolean countDown){
  mCountDown=countDown;
}","/** 
 * Set this view to count down to the base instead of counting up from it.
 * @param countDown whether this view should count down
 * @see #setBase(long)
 */
@android.view.RemotableViewMethod public void setCountDown(boolean countDown){
  mCountDown=countDown;
  updateText(SystemClock.elapsedRealtime());
}",0.922279792746114
191455,"private void updateScrim(boolean animate,View scrim,float alpha,float currentAlpha){
  if (mKeyguardFadingOutInProgress) {
    return;
  }
  ValueAnimator previousAnimator=StackStateAnimator.getChildTag(scrim,TAG_KEY_ANIM);
  float animEndValue=-1;
  if (previousAnimator != null) {
    if (animate || alpha == currentAlpha) {
      previousAnimator.cancel();
    }
 else {
      animEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
    }
  }
  if (alpha != currentAlpha && alpha != animEndValue) {
    if (animate) {
      startScrimAnimation(scrim,alpha);
      scrim.setTag(TAG_START_ALPHA,currentAlpha);
      scrim.setTag(TAG_END_ALPHA,alpha);
    }
 else {
      if (previousAnimator != null) {
        float previousStartValue=StackStateAnimator.getChildTag(scrim,TAG_START_ALPHA);
        float previousEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
        PropertyValuesHolder[] values=previousAnimator.getValues();
        float relativeDiff=alpha - previousEndValue;
        float newStartValue=previousStartValue + relativeDiff;
        values[0].setFloatValues(newStartValue,alpha);
        scrim.setTag(TAG_START_ALPHA,newStartValue);
        scrim.setTag(TAG_END_ALPHA,alpha);
        previousAnimator.setCurrentPlayTime(previousAnimator.getCurrentPlayTime());
      }
 else {
        setCurrentScrimAlpha(scrim,alpha);
        updateScrimColor(scrim);
      }
    }
  }
}","private void updateScrim(boolean animate,View scrim,float alpha,float currentAlpha){
  if (mKeyguardFadingOutInProgress) {
    return;
  }
  ValueAnimator previousAnimator=StackStateAnimator.getChildTag(scrim,TAG_KEY_ANIM);
  float animEndValue=-1;
  if (previousAnimator != null) {
    if (animate || alpha == currentAlpha) {
      previousAnimator.cancel();
    }
 else {
      animEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
    }
  }
  if (alpha != currentAlpha && alpha != animEndValue) {
    if (animate) {
      startScrimAnimation(scrim,alpha);
      scrim.setTag(TAG_START_ALPHA,currentAlpha);
      scrim.setTag(TAG_END_ALPHA,alpha);
    }
 else {
      if (previousAnimator != null) {
        float previousStartValue=StackStateAnimator.getChildTag(scrim,TAG_START_ALPHA);
        float previousEndValue=StackStateAnimator.getChildTag(scrim,TAG_END_ALPHA);
        PropertyValuesHolder[] values=previousAnimator.getValues();
        float relativeDiff=alpha - previousEndValue;
        float newStartValue=previousStartValue + relativeDiff;
        newStartValue=Math.max(0,Math.min(1.0f,newStartValue));
        values[0].setFloatValues(newStartValue,alpha);
        scrim.setTag(TAG_START_ALPHA,newStartValue);
        scrim.setTag(TAG_END_ALPHA,alpha);
        previousAnimator.setCurrentPlayTime(previousAnimator.getCurrentPlayTime());
      }
 else {
        setCurrentScrimAlpha(scrim,alpha);
        updateScrimColor(scrim);
      }
    }
  }
}",0.9779005524861878
191456,"private void updateScrimColor(View scrim){
  float alpha1=getCurrentScrimAlpha(scrim);
  if (scrim instanceof ScrimView) {
    float alpha2=getDozeAlpha(scrim);
    float alpha=1 - (1 - alpha1) * (1 - alpha2);
    ((ScrimView)scrim).setScrimColor(Color.argb((int)(alpha * 255),0,0,0));
  }
 else {
    scrim.setAlpha(alpha1);
  }
}","private void updateScrimColor(View scrim){
  float alpha1=getCurrentScrimAlpha(scrim);
  if (scrim instanceof ScrimView) {
    float alpha2=getDozeAlpha(scrim);
    float alpha=1 - (1 - alpha1) * (1 - alpha2);
    alpha=Math.max(0,Math.min(1.0f,alpha));
    ((ScrimView)scrim).setScrimColor(Color.argb((int)(alpha * 255),0,0,0));
  }
 else {
    scrim.setAlpha(alpha1);
  }
}",0.9376770538243626
191457,"/** 
 * @return true if the notification will show the time or the chronometer; falseotherwise
 * @hide
 */
public boolean showsTimeOrChronometer(){
  return when != 0 && extras.getBoolean(EXTRA_SHOW_WHEN);
}","/** 
 * @return true if the built notification will show the time or the chronometer; falseotherwise
 */
private boolean showsTimeOrChronometer(){
  return mN.showsTime() || mN.showsChronometer();
}",0.7684729064039408
191458,"private void sanitizeHeader(NotificationHeaderView rowHeader){
  if (rowHeader == null) {
    return;
  }
  final int childCount=rowHeader.getChildCount();
  View time=rowHeader.findViewById(com.android.internal.R.id.time);
  boolean hasVisibleText=false;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (child instanceof TextView && child.getVisibility() != View.GONE && !mDividers.contains(Integer.valueOf(child.getId())) && child != time) {
      hasVisibleText=true;
      break;
    }
  }
  int timeVisibility=!hasVisibleText || mRow.getStatusBarNotification().getNotification().showsTimeOrChronometer() ? View.VISIBLE : View.GONE;
  time.setVisibility(timeVisibility);
  View left=null;
  View right;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (mDividers.contains(Integer.valueOf(child.getId()))) {
      boolean visible=false;
      for (i++; i < childCount - 1; i++) {
        right=rowHeader.getChildAt(i);
        if (mDividers.contains(Integer.valueOf(right.getId()))) {
          i--;
          break;
        }
 else         if (right.getVisibility() != View.GONE && right instanceof TextView) {
          visible=left != null;
          left=right;
          break;
        }
      }
      child.setVisibility(visible ? View.VISIBLE : View.GONE);
    }
 else     if (child.getVisibility() != View.GONE && child instanceof TextView) {
      left=child;
    }
  }
}","private void sanitizeHeader(NotificationHeaderView rowHeader){
  if (rowHeader == null) {
    return;
  }
  final int childCount=rowHeader.getChildCount();
  View time=rowHeader.findViewById(com.android.internal.R.id.time);
  boolean hasVisibleText=false;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (child instanceof TextView && child.getVisibility() != View.GONE && !mDividers.contains(Integer.valueOf(child.getId())) && child != time) {
      hasVisibleText=true;
      break;
    }
  }
  int timeVisibility=!hasVisibleText || mRow.getStatusBarNotification().getNotification().showsTime() ? View.VISIBLE : View.GONE;
  time.setVisibility(timeVisibility);
  View left=null;
  View right;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (mDividers.contains(Integer.valueOf(child.getId()))) {
      boolean visible=false;
      for (i++; i < childCount - 1; i++) {
        right=rowHeader.getChildAt(i);
        if (mDividers.contains(Integer.valueOf(right.getId()))) {
          i--;
          break;
        }
 else         if (right.getVisibility() != View.GONE && right instanceof TextView) {
          visible=left != null;
          left=right;
          break;
        }
      }
      child.setVisibility(visible ? View.VISIBLE : View.GONE);
    }
 else     if (child.getVisibility() != View.GONE && child instanceof TextView) {
      left=child;
    }
  }
}",0.9955464200068516
191459,"private String generateDeleteMessage(final List<DocumentInfo> docs){
  String message;
  int dirsCount=0;
  for (  DocumentInfo doc : docs) {
    if (doc.isDirectory()) {
      ++dirsCount;
    }
  }
  if (docs.size() == 1) {
    message=dirsCount == 0 ? getActivity().getString(R.string.delete_filename_confirmation_message,docs.get(0).displayName) : getActivity().getString(R.string.delete_foldername_confirmation_message,docs.get(0).displayName);
  }
 else   if (dirsCount == 0) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_files_confirmation_message,docs.size());
  }
 else   if (dirsCount == docs.size()) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_folders_confirmation_message,docs.size());
  }
 else {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_items_confirmation_message,docs.size());
  }
  return message;
}","private String generateDeleteMessage(final List<DocumentInfo> docs){
  String message;
  int dirsCount=0;
  for (  DocumentInfo doc : docs) {
    if (doc.isDirectory()) {
      ++dirsCount;
    }
  }
  if (docs.size() == 1) {
    String displayName=BidiFormatter.getInstance().unicodeWrap(docs.get(0).displayName);
    message=dirsCount == 0 ? getActivity().getString(R.string.delete_filename_confirmation_message,displayName) : getActivity().getString(R.string.delete_foldername_confirmation_message,displayName);
  }
 else   if (dirsCount == 0) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_files_confirmation_message,docs.size());
  }
 else   if (dirsCount == docs.size()) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_folders_confirmation_message,docs.size());
  }
 else {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_items_confirmation_message,docs.size());
  }
  return message;
}",0.9388858842617632
191460,"/** 
 * @return true if the notification will show the time or the chronometer; falseotherwise
 * @hide
 */
public boolean showsTimeOrChronometer(){
  return when != 0 && extras.getBoolean(EXTRA_SHOW_WHEN);
}","/** 
 * @return true if the built notification will show the time or the chronometer; falseotherwise
 */
private boolean showsTimeOrChronometer(){
  return mN.showsTime() || mN.showsChronometer();
}",0.7684729064039408
191461,"private void sanitizeHeader(NotificationHeaderView rowHeader){
  if (rowHeader == null) {
    return;
  }
  final int childCount=rowHeader.getChildCount();
  View time=rowHeader.findViewById(com.android.internal.R.id.time);
  boolean hasVisibleText=false;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (child instanceof TextView && child.getVisibility() != View.GONE && !mDividers.contains(Integer.valueOf(child.getId())) && child != time) {
      hasVisibleText=true;
      break;
    }
  }
  int timeVisibility=!hasVisibleText || mRow.getStatusBarNotification().getNotification().showsTimeOrChronometer() ? View.VISIBLE : View.GONE;
  time.setVisibility(timeVisibility);
  View left=null;
  View right;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (mDividers.contains(Integer.valueOf(child.getId()))) {
      boolean visible=false;
      for (i++; i < childCount - 1; i++) {
        right=rowHeader.getChildAt(i);
        if (mDividers.contains(Integer.valueOf(right.getId()))) {
          i--;
          break;
        }
 else         if (right.getVisibility() != View.GONE && right instanceof TextView) {
          visible=left != null;
          left=right;
          break;
        }
      }
      child.setVisibility(visible ? View.VISIBLE : View.GONE);
    }
 else     if (child.getVisibility() != View.GONE && child instanceof TextView) {
      left=child;
    }
  }
}","private void sanitizeHeader(NotificationHeaderView rowHeader){
  if (rowHeader == null) {
    return;
  }
  final int childCount=rowHeader.getChildCount();
  View time=rowHeader.findViewById(com.android.internal.R.id.time);
  boolean hasVisibleText=false;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (child instanceof TextView && child.getVisibility() != View.GONE && !mDividers.contains(Integer.valueOf(child.getId())) && child != time) {
      hasVisibleText=true;
      break;
    }
  }
  int timeVisibility=!hasVisibleText || mRow.getStatusBarNotification().getNotification().showsTime() ? View.VISIBLE : View.GONE;
  time.setVisibility(timeVisibility);
  View left=null;
  View right;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (mDividers.contains(Integer.valueOf(child.getId()))) {
      boolean visible=false;
      for (i++; i < childCount - 1; i++) {
        right=rowHeader.getChildAt(i);
        if (mDividers.contains(Integer.valueOf(right.getId()))) {
          i--;
          break;
        }
 else         if (right.getVisibility() != View.GONE && right instanceof TextView) {
          visible=left != null;
          left=right;
          break;
        }
      }
      child.setVisibility(visible ? View.VISIBLE : View.GONE);
    }
 else     if (child.getVisibility() != View.GONE && child instanceof TextView) {
      left=child;
    }
  }
}",0.9955464200068516
191462,"/** 
 * Set this view to count down to the base instead of counting up from it.
 * @param countDown whether this view should count down
 * @see #setBase(long)
 */
@android.view.RemotableViewMethod public void setCountDown(boolean countDown){
  mCountDown=countDown;
}","/** 
 * Set this view to count down to the base instead of counting up from it.
 * @param countDown whether this view should count down
 * @see #setBase(long)
 */
@android.view.RemotableViewMethod public void setCountDown(boolean countDown){
  mCountDown=countDown;
  updateText(SystemClock.elapsedRealtime());
}",0.922279792746114
191463,"private String generateDeleteMessage(final List<DocumentInfo> docs){
  String message;
  int dirsCount=0;
  for (  DocumentInfo doc : docs) {
    if (doc.isDirectory()) {
      ++dirsCount;
    }
  }
  if (docs.size() == 1) {
    message=dirsCount == 0 ? getActivity().getString(R.string.delete_filename_confirmation_message,docs.get(0).displayName) : getActivity().getString(R.string.delete_foldername_confirmation_message,docs.get(0).displayName);
  }
 else   if (dirsCount == 0) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_files_confirmation_message,docs.size());
  }
 else   if (dirsCount == docs.size()) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_folders_confirmation_message,docs.size());
  }
 else {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_items_confirmation_message,docs.size());
  }
  return message;
}","private String generateDeleteMessage(final List<DocumentInfo> docs){
  String message;
  int dirsCount=0;
  for (  DocumentInfo doc : docs) {
    if (doc.isDirectory()) {
      ++dirsCount;
    }
  }
  if (docs.size() == 1) {
    String displayName=BidiFormatter.getInstance().unicodeWrap(docs.get(0).displayName);
    message=dirsCount == 0 ? getActivity().getString(R.string.delete_filename_confirmation_message,displayName) : getActivity().getString(R.string.delete_foldername_confirmation_message,displayName);
  }
 else   if (dirsCount == 0) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_files_confirmation_message,docs.size());
  }
 else   if (dirsCount == docs.size()) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_folders_confirmation_message,docs.size());
  }
 else {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_items_confirmation_message,docs.size());
  }
  return message;
}",0.9388858842617632
191464,"private String generateDeleteMessage(final List<DocumentInfo> docs){
  String message;
  int dirsCount=0;
  for (  DocumentInfo doc : docs) {
    if (doc.isDirectory()) {
      ++dirsCount;
    }
  }
  if (docs.size() == 1) {
    message=dirsCount == 0 ? getActivity().getString(R.string.delete_filename_confirmation_message,docs.get(0).displayName) : getActivity().getString(R.string.delete_foldername_confirmation_message,docs.get(0).displayName);
  }
 else   if (dirsCount == 0) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_files_confirmation_message,docs.size());
  }
 else   if (dirsCount == docs.size()) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_folders_confirmation_message,docs.size());
  }
 else {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_items_confirmation_message,docs.size());
  }
  return message;
}","private String generateDeleteMessage(final List<DocumentInfo> docs){
  String message;
  int dirsCount=0;
  for (  DocumentInfo doc : docs) {
    if (doc.isDirectory()) {
      ++dirsCount;
    }
  }
  if (docs.size() == 1) {
    String displayName=BidiFormatter.getInstance().unicodeWrap(docs.get(0).displayName);
    message=dirsCount == 0 ? getActivity().getString(R.string.delete_filename_confirmation_message,displayName) : getActivity().getString(R.string.delete_foldername_confirmation_message,displayName);
  }
 else   if (dirsCount == 0) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_files_confirmation_message,docs.size());
  }
 else   if (dirsCount == docs.size()) {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_folders_confirmation_message,docs.size());
  }
 else {
    message=Shared.getQuantityString(getActivity(),R.plurals.delete_items_confirmation_message,docs.size());
  }
  return message;
}",0.9388858842617632
191465,"/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED);
  }
}","/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  if (n.isGroupSummary() && !sbn.isAppGroup()) {
    n.flags&=~Notification.FLAG_GROUP_SUMMARY;
  }
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED);
  }
}",0.9601910828025476
191466,"private void maybeAddAutobundleSummary(Adjustment adjustment){
  if (adjustment.getSignals() != null) {
    Bundle.setDefusable(adjustment.getSignals(),true);
    if (adjustment.getSignals().getBoolean(Adjustment.NEEDS_AUTOGROUPING_KEY,false)) {
      final String newAutoBundleKey=adjustment.getSignals().getString(Adjustment.GROUP_KEY_OVERRIDE_KEY,null);
      int userId=-1;
      NotificationRecord summaryRecord=null;
synchronized (mNotificationList) {
        final StatusBarNotification adjustedSbn=mNotificationsByKey.get(adjustment.getKey()).sbn;
        userId=adjustedSbn.getUser().getIdentifier();
        ArrayMap<String,String> summaries=mAutobundledSummaries.get(userId);
        if (summaries == null) {
          summaries=new ArrayMap<>();
        }
        mAutobundledSummaries.put(userId,summaries);
        if (!summaries.containsKey(adjustment.getPackage()) && newAutoBundleKey != null) {
          final ApplicationInfo appInfo=adjustedSbn.getNotification().extras.getParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO);
          final Bundle extras=new Bundle();
          extras.putParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO,appInfo);
          final Notification summaryNotification=new Notification.Builder(getContext()).setSmallIcon(adjustedSbn.getNotification().getSmallIcon()).setGroupSummary(true).setGroup(newAutoBundleKey).setFlag(Notification.FLAG_AUTOGROUP_SUMMARY,true).setFlag(Notification.FLAG_GROUP_SUMMARY,true).build();
          summaryNotification.extras.putAll(extras);
          Intent appIntent=getContext().getPackageManager().getLaunchIntentForPackage(adjustment.getPackage());
          if (appIntent != null) {
            summaryNotification.contentIntent=PendingIntent.getActivityAsUser(getContext(),0,appIntent,0,null,UserHandle.of(userId));
          }
          final StatusBarNotification summarySbn=new StatusBarNotification(adjustedSbn.getPackageName(),adjustedSbn.getOpPkg(),Integer.MAX_VALUE,Adjustment.GROUP_KEY_OVERRIDE_KEY,adjustedSbn.getUid(),adjustedSbn.getInitialPid(),summaryNotification,adjustedSbn.getUser(),newAutoBundleKey,System.currentTimeMillis());
          summaryRecord=new NotificationRecord(getContext(),summarySbn);
          summaries.put(adjustment.getPackage(),summarySbn.getKey());
        }
      }
      if (summaryRecord != null) {
        mHandler.post(new EnqueueNotificationRunnable(userId,summaryRecord));
      }
    }
  }
}","private void maybeAddAutobundleSummary(Adjustment adjustment){
  if (adjustment.getSignals() != null) {
    Bundle.setDefusable(adjustment.getSignals(),true);
    if (adjustment.getSignals().getBoolean(Adjustment.NEEDS_AUTOGROUPING_KEY,false)) {
      final String newAutoBundleKey=adjustment.getSignals().getString(Adjustment.GROUP_KEY_OVERRIDE_KEY,null);
      int userId=-1;
      NotificationRecord summaryRecord=null;
synchronized (mNotificationList) {
        NotificationRecord notificationRecord=mNotificationsByKey.get(adjustment.getKey());
        if (notificationRecord == null) {
          return;
        }
        final StatusBarNotification adjustedSbn=notificationRecord.sbn;
        userId=adjustedSbn.getUser().getIdentifier();
        ArrayMap<String,String> summaries=mAutobundledSummaries.get(userId);
        if (summaries == null) {
          summaries=new ArrayMap<>();
        }
        mAutobundledSummaries.put(userId,summaries);
        if (!summaries.containsKey(adjustment.getPackage()) && newAutoBundleKey != null) {
          final ApplicationInfo appInfo=adjustedSbn.getNotification().extras.getParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO);
          final Bundle extras=new Bundle();
          extras.putParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO,appInfo);
          final Notification summaryNotification=new Notification.Builder(getContext()).setSmallIcon(adjustedSbn.getNotification().getSmallIcon()).setGroupSummary(true).setGroup(newAutoBundleKey).setFlag(Notification.FLAG_AUTOGROUP_SUMMARY,true).setFlag(Notification.FLAG_GROUP_SUMMARY,true).build();
          summaryNotification.extras.putAll(extras);
          Intent appIntent=getContext().getPackageManager().getLaunchIntentForPackage(adjustment.getPackage());
          if (appIntent != null) {
            summaryNotification.contentIntent=PendingIntent.getActivityAsUser(getContext(),0,appIntent,0,null,UserHandle.of(userId));
          }
          final StatusBarNotification summarySbn=new StatusBarNotification(adjustedSbn.getPackageName(),adjustedSbn.getOpPkg(),Integer.MAX_VALUE,Adjustment.GROUP_KEY_OVERRIDE_KEY,adjustedSbn.getUid(),adjustedSbn.getInitialPid(),summaryNotification,adjustedSbn.getUser(),newAutoBundleKey,System.currentTimeMillis());
          summaryRecord=new NotificationRecord(getContext(),summarySbn);
          summaries.put(adjustment.getPackage(),summarySbn.getKey());
        }
      }
      if (summaryRecord != null) {
        mHandler.post(new EnqueueNotificationRunnable(userId,summaryRecord));
      }
    }
  }
}",0.9448441247002398
191467,"public void copyRankingInformation(NotificationRecord previous){
  mContactAffinity=previous.mContactAffinity;
  mRecentlyIntrusive=previous.mRecentlyIntrusive;
  mPackagePriority=previous.mPackagePriority;
  mPackageVisibility=previous.mPackageVisibility;
  mIntercept=previous.mIntercept;
  mRankingTimeMs=calculateRankingTimeMs(previous.getRankingTimeMs());
  mCreationTimeMs=previous.mCreationTimeMs;
  mVisibleSinceMs=previous.mVisibleSinceMs;
  if (previous.sbn.getOverrideGroupKey() != null) {
    sbn.setOverrideGroupKey(previous.sbn.getOverrideGroupKey());
  }
}","public void copyRankingInformation(NotificationRecord previous){
  mContactAffinity=previous.mContactAffinity;
  mRecentlyIntrusive=previous.mRecentlyIntrusive;
  mPackagePriority=previous.mPackagePriority;
  mPackageVisibility=previous.mPackageVisibility;
  mIntercept=previous.mIntercept;
  mRankingTimeMs=calculateRankingTimeMs(previous.getRankingTimeMs());
  mCreationTimeMs=previous.mCreationTimeMs;
  mVisibleSinceMs=previous.mVisibleSinceMs;
  if (previous.sbn.getOverrideGroupKey() != null && !sbn.isAppGroup()) {
    sbn.setOverrideGroupKey(previous.sbn.getOverrideGroupKey());
  }
}",0.9819432502149612
191468,"/** 
 * @return true if the notification will show the time or the chronometer; falseotherwise
 * @hide
 */
public boolean showsTimeOrChronometer(){
  return when != 0 && extras.getBoolean(EXTRA_SHOW_WHEN);
}","/** 
 * @return true if the built notification will show the time or the chronometer; falseotherwise
 */
private boolean showsTimeOrChronometer(){
  return mN.showsTime() || mN.showsChronometer();
}",0.7684729064039408
191469,"private void sanitizeHeader(NotificationHeaderView rowHeader){
  if (rowHeader == null) {
    return;
  }
  final int childCount=rowHeader.getChildCount();
  View time=rowHeader.findViewById(com.android.internal.R.id.time);
  boolean hasVisibleText=false;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (child instanceof TextView && child.getVisibility() != View.GONE && !mDividers.contains(Integer.valueOf(child.getId())) && child != time) {
      hasVisibleText=true;
      break;
    }
  }
  int timeVisibility=!hasVisibleText || mRow.getStatusBarNotification().getNotification().showsTimeOrChronometer() ? View.VISIBLE : View.GONE;
  time.setVisibility(timeVisibility);
  View left=null;
  View right;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (mDividers.contains(Integer.valueOf(child.getId()))) {
      boolean visible=false;
      for (i++; i < childCount - 1; i++) {
        right=rowHeader.getChildAt(i);
        if (mDividers.contains(Integer.valueOf(right.getId()))) {
          i--;
          break;
        }
 else         if (right.getVisibility() != View.GONE && right instanceof TextView) {
          visible=left != null;
          left=right;
          break;
        }
      }
      child.setVisibility(visible ? View.VISIBLE : View.GONE);
    }
 else     if (child.getVisibility() != View.GONE && child instanceof TextView) {
      left=child;
    }
  }
}","private void sanitizeHeader(NotificationHeaderView rowHeader){
  if (rowHeader == null) {
    return;
  }
  final int childCount=rowHeader.getChildCount();
  View time=rowHeader.findViewById(com.android.internal.R.id.time);
  boolean hasVisibleText=false;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (child instanceof TextView && child.getVisibility() != View.GONE && !mDividers.contains(Integer.valueOf(child.getId())) && child != time) {
      hasVisibleText=true;
      break;
    }
  }
  int timeVisibility=!hasVisibleText || mRow.getStatusBarNotification().getNotification().showsTime() ? View.VISIBLE : View.GONE;
  time.setVisibility(timeVisibility);
  View left=null;
  View right;
  for (int i=1; i < childCount - 1; i++) {
    View child=rowHeader.getChildAt(i);
    if (mDividers.contains(Integer.valueOf(child.getId()))) {
      boolean visible=false;
      for (i++; i < childCount - 1; i++) {
        right=rowHeader.getChildAt(i);
        if (mDividers.contains(Integer.valueOf(right.getId()))) {
          i--;
          break;
        }
 else         if (right.getVisibility() != View.GONE && right instanceof TextView) {
          visible=left != null;
          left=right;
          break;
        }
      }
      child.setVisibility(visible ? View.VISIBLE : View.GONE);
    }
 else     if (child.getVisibility() != View.GONE && child instanceof TextView) {
      left=child;
    }
  }
}",0.9955464200068516
191470,"/** 
 * Set this view to count down to the base instead of counting up from it.
 * @param countDown whether this view should count down
 * @see #setBase(long)
 */
@android.view.RemotableViewMethod public void setCountDown(boolean countDown){
  mCountDown=countDown;
}","/** 
 * Set this view to count down to the base instead of counting up from it.
 * @param countDown whether this view should count down
 * @see #setBase(long)
 */
@android.view.RemotableViewMethod public void setCountDown(boolean countDown){
  mCountDown=countDown;
  updateText(SystemClock.elapsedRealtime());
}",0.922279792746114
191471,"/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED);
  }
}","/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  if (n.isGroupSummary() && !sbn.isAppGroup()) {
    n.flags&=~Notification.FLAG_GROUP_SUMMARY;
  }
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED);
  }
}",0.9601910828025476
191472,"private void maybeAddAutobundleSummary(Adjustment adjustment){
  if (adjustment.getSignals() != null) {
    Bundle.setDefusable(adjustment.getSignals(),true);
    if (adjustment.getSignals().getBoolean(Adjustment.NEEDS_AUTOGROUPING_KEY,false)) {
      final String newAutoBundleKey=adjustment.getSignals().getString(Adjustment.GROUP_KEY_OVERRIDE_KEY,null);
      int userId=-1;
      NotificationRecord summaryRecord=null;
synchronized (mNotificationList) {
        final StatusBarNotification adjustedSbn=mNotificationsByKey.get(adjustment.getKey()).sbn;
        userId=adjustedSbn.getUser().getIdentifier();
        ArrayMap<String,String> summaries=mAutobundledSummaries.get(userId);
        if (summaries == null) {
          summaries=new ArrayMap<>();
        }
        mAutobundledSummaries.put(userId,summaries);
        if (!summaries.containsKey(adjustment.getPackage()) && newAutoBundleKey != null) {
          final ApplicationInfo appInfo=adjustedSbn.getNotification().extras.getParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO);
          final Bundle extras=new Bundle();
          extras.putParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO,appInfo);
          final Notification summaryNotification=new Notification.Builder(getContext()).setSmallIcon(adjustedSbn.getNotification().getSmallIcon()).setGroupSummary(true).setGroup(newAutoBundleKey).setFlag(Notification.FLAG_AUTOGROUP_SUMMARY,true).setFlag(Notification.FLAG_GROUP_SUMMARY,true).build();
          summaryNotification.extras.putAll(extras);
          Intent appIntent=getContext().getPackageManager().getLaunchIntentForPackage(adjustment.getPackage());
          if (appIntent != null) {
            summaryNotification.contentIntent=PendingIntent.getActivityAsUser(getContext(),0,appIntent,0,null,UserHandle.of(userId));
          }
          final StatusBarNotification summarySbn=new StatusBarNotification(adjustedSbn.getPackageName(),adjustedSbn.getOpPkg(),Integer.MAX_VALUE,Adjustment.GROUP_KEY_OVERRIDE_KEY,adjustedSbn.getUid(),adjustedSbn.getInitialPid(),summaryNotification,adjustedSbn.getUser(),newAutoBundleKey,System.currentTimeMillis());
          summaryRecord=new NotificationRecord(getContext(),summarySbn);
          summaries.put(adjustment.getPackage(),summarySbn.getKey());
        }
      }
      if (summaryRecord != null) {
        mHandler.post(new EnqueueNotificationRunnable(userId,summaryRecord));
      }
    }
  }
}","private void maybeAddAutobundleSummary(Adjustment adjustment){
  if (adjustment.getSignals() != null) {
    Bundle.setDefusable(adjustment.getSignals(),true);
    if (adjustment.getSignals().getBoolean(Adjustment.NEEDS_AUTOGROUPING_KEY,false)) {
      final String newAutoBundleKey=adjustment.getSignals().getString(Adjustment.GROUP_KEY_OVERRIDE_KEY,null);
      int userId=-1;
      NotificationRecord summaryRecord=null;
synchronized (mNotificationList) {
        NotificationRecord notificationRecord=mNotificationsByKey.get(adjustment.getKey());
        if (notificationRecord == null) {
          return;
        }
        final StatusBarNotification adjustedSbn=notificationRecord.sbn;
        userId=adjustedSbn.getUser().getIdentifier();
        ArrayMap<String,String> summaries=mAutobundledSummaries.get(userId);
        if (summaries == null) {
          summaries=new ArrayMap<>();
        }
        mAutobundledSummaries.put(userId,summaries);
        if (!summaries.containsKey(adjustment.getPackage()) && newAutoBundleKey != null) {
          final ApplicationInfo appInfo=adjustedSbn.getNotification().extras.getParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO);
          final Bundle extras=new Bundle();
          extras.putParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO,appInfo);
          final Notification summaryNotification=new Notification.Builder(getContext()).setSmallIcon(adjustedSbn.getNotification().getSmallIcon()).setGroupSummary(true).setGroup(newAutoBundleKey).setFlag(Notification.FLAG_AUTOGROUP_SUMMARY,true).setFlag(Notification.FLAG_GROUP_SUMMARY,true).build();
          summaryNotification.extras.putAll(extras);
          Intent appIntent=getContext().getPackageManager().getLaunchIntentForPackage(adjustment.getPackage());
          if (appIntent != null) {
            summaryNotification.contentIntent=PendingIntent.getActivityAsUser(getContext(),0,appIntent,0,null,UserHandle.of(userId));
          }
          final StatusBarNotification summarySbn=new StatusBarNotification(adjustedSbn.getPackageName(),adjustedSbn.getOpPkg(),Integer.MAX_VALUE,Adjustment.GROUP_KEY_OVERRIDE_KEY,adjustedSbn.getUid(),adjustedSbn.getInitialPid(),summaryNotification,adjustedSbn.getUser(),newAutoBundleKey,System.currentTimeMillis());
          summaryRecord=new NotificationRecord(getContext(),summarySbn);
          summaries.put(adjustment.getPackage(),summarySbn.getKey());
        }
      }
      if (summaryRecord != null) {
        mHandler.post(new EnqueueNotificationRunnable(userId,summaryRecord));
      }
    }
  }
}",0.9448441247002398
191473,"public void copyRankingInformation(NotificationRecord previous){
  mContactAffinity=previous.mContactAffinity;
  mRecentlyIntrusive=previous.mRecentlyIntrusive;
  mPackagePriority=previous.mPackagePriority;
  mPackageVisibility=previous.mPackageVisibility;
  mIntercept=previous.mIntercept;
  mRankingTimeMs=calculateRankingTimeMs(previous.getRankingTimeMs());
  mCreationTimeMs=previous.mCreationTimeMs;
  mVisibleSinceMs=previous.mVisibleSinceMs;
  if (previous.sbn.getOverrideGroupKey() != null) {
    sbn.setOverrideGroupKey(previous.sbn.getOverrideGroupKey());
  }
}","public void copyRankingInformation(NotificationRecord previous){
  mContactAffinity=previous.mContactAffinity;
  mRecentlyIntrusive=previous.mRecentlyIntrusive;
  mPackagePriority=previous.mPackagePriority;
  mPackageVisibility=previous.mPackageVisibility;
  mIntercept=previous.mIntercept;
  mRankingTimeMs=calculateRankingTimeMs(previous.getRankingTimeMs());
  mCreationTimeMs=previous.mCreationTimeMs;
  mVisibleSinceMs=previous.mVisibleSinceMs;
  if (previous.sbn.getOverrideGroupKey() != null && !sbn.isAppGroup()) {
    sbn.setOverrideGroupKey(previous.sbn.getOverrideGroupKey());
  }
}",0.9819432502149612
191474,"/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED);
  }
}","/** 
 * Ensures that grouped notification receive their special treatment. <p>Cancels group children if the new notification causes a group to lose its summary.</p> <p>Updates mSummaryByGroupKey.</p>
 */
private void handleGroupedNotificationLocked(NotificationRecord r,NotificationRecord old,int callingUid,int callingPid){
  StatusBarNotification sbn=r.sbn;
  Notification n=sbn.getNotification();
  if (n.isGroupSummary() && !sbn.isAppGroup()) {
    n.flags&=~Notification.FLAG_GROUP_SUMMARY;
  }
  String group=sbn.getGroupKey();
  boolean isSummary=n.isGroupSummary();
  Notification oldN=old != null ? old.sbn.getNotification() : null;
  String oldGroup=old != null ? old.sbn.getGroupKey() : null;
  boolean oldIsSummary=old != null && oldN.isGroupSummary();
  if (oldIsSummary) {
    NotificationRecord removedSummary=mSummaryByGroupKey.remove(oldGroup);
    if (removedSummary != old) {
      String removedKey=removedSummary != null ? removedSummary.getKey() : ""String_Node_Str"";
      Slog.w(TAG,""String_Node_Str"" + old.getKey() + ""String_Node_Str""+ removedKey);
    }
  }
  if (isSummary) {
    mSummaryByGroupKey.put(group,r);
  }
  if (oldIsSummary && (!isSummary || !oldGroup.equals(group))) {
    cancelGroupChildrenLocked(old,callingUid,callingPid,null,REASON_GROUP_SUMMARY_CANCELED);
  }
}",0.9601910828025476
191475,"private void maybeAddAutobundleSummary(Adjustment adjustment){
  if (adjustment.getSignals() != null) {
    Bundle.setDefusable(adjustment.getSignals(),true);
    if (adjustment.getSignals().getBoolean(Adjustment.NEEDS_AUTOGROUPING_KEY,false)) {
      final String newAutoBundleKey=adjustment.getSignals().getString(Adjustment.GROUP_KEY_OVERRIDE_KEY,null);
      int userId=-1;
      NotificationRecord summaryRecord=null;
synchronized (mNotificationList) {
        final StatusBarNotification adjustedSbn=mNotificationsByKey.get(adjustment.getKey()).sbn;
        userId=adjustedSbn.getUser().getIdentifier();
        ArrayMap<String,String> summaries=mAutobundledSummaries.get(userId);
        if (summaries == null) {
          summaries=new ArrayMap<>();
        }
        mAutobundledSummaries.put(userId,summaries);
        if (!summaries.containsKey(adjustment.getPackage()) && newAutoBundleKey != null) {
          final ApplicationInfo appInfo=adjustedSbn.getNotification().extras.getParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO);
          final Bundle extras=new Bundle();
          extras.putParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO,appInfo);
          final Notification summaryNotification=new Notification.Builder(getContext()).setSmallIcon(adjustedSbn.getNotification().getSmallIcon()).setGroupSummary(true).setGroup(newAutoBundleKey).setFlag(Notification.FLAG_AUTOGROUP_SUMMARY,true).setFlag(Notification.FLAG_GROUP_SUMMARY,true).build();
          summaryNotification.extras.putAll(extras);
          Intent appIntent=getContext().getPackageManager().getLaunchIntentForPackage(adjustment.getPackage());
          if (appIntent != null) {
            summaryNotification.contentIntent=PendingIntent.getActivityAsUser(getContext(),0,appIntent,0,null,UserHandle.of(userId));
          }
          final StatusBarNotification summarySbn=new StatusBarNotification(adjustedSbn.getPackageName(),adjustedSbn.getOpPkg(),Integer.MAX_VALUE,Adjustment.GROUP_KEY_OVERRIDE_KEY,adjustedSbn.getUid(),adjustedSbn.getInitialPid(),summaryNotification,adjustedSbn.getUser(),newAutoBundleKey,System.currentTimeMillis());
          summaryRecord=new NotificationRecord(getContext(),summarySbn);
          summaries.put(adjustment.getPackage(),summarySbn.getKey());
        }
      }
      if (summaryRecord != null) {
        mHandler.post(new EnqueueNotificationRunnable(userId,summaryRecord));
      }
    }
  }
}","private void maybeAddAutobundleSummary(Adjustment adjustment){
  if (adjustment.getSignals() != null) {
    Bundle.setDefusable(adjustment.getSignals(),true);
    if (adjustment.getSignals().getBoolean(Adjustment.NEEDS_AUTOGROUPING_KEY,false)) {
      final String newAutoBundleKey=adjustment.getSignals().getString(Adjustment.GROUP_KEY_OVERRIDE_KEY,null);
      int userId=-1;
      NotificationRecord summaryRecord=null;
synchronized (mNotificationList) {
        NotificationRecord notificationRecord=mNotificationsByKey.get(adjustment.getKey());
        if (notificationRecord == null) {
          return;
        }
        final StatusBarNotification adjustedSbn=notificationRecord.sbn;
        userId=adjustedSbn.getUser().getIdentifier();
        ArrayMap<String,String> summaries=mAutobundledSummaries.get(userId);
        if (summaries == null) {
          summaries=new ArrayMap<>();
        }
        mAutobundledSummaries.put(userId,summaries);
        if (!summaries.containsKey(adjustment.getPackage()) && newAutoBundleKey != null) {
          final ApplicationInfo appInfo=adjustedSbn.getNotification().extras.getParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO);
          final Bundle extras=new Bundle();
          extras.putParcelable(Notification.EXTRA_BUILDER_APPLICATION_INFO,appInfo);
          final Notification summaryNotification=new Notification.Builder(getContext()).setSmallIcon(adjustedSbn.getNotification().getSmallIcon()).setGroupSummary(true).setGroup(newAutoBundleKey).setFlag(Notification.FLAG_AUTOGROUP_SUMMARY,true).setFlag(Notification.FLAG_GROUP_SUMMARY,true).build();
          summaryNotification.extras.putAll(extras);
          Intent appIntent=getContext().getPackageManager().getLaunchIntentForPackage(adjustment.getPackage());
          if (appIntent != null) {
            summaryNotification.contentIntent=PendingIntent.getActivityAsUser(getContext(),0,appIntent,0,null,UserHandle.of(userId));
          }
          final StatusBarNotification summarySbn=new StatusBarNotification(adjustedSbn.getPackageName(),adjustedSbn.getOpPkg(),Integer.MAX_VALUE,Adjustment.GROUP_KEY_OVERRIDE_KEY,adjustedSbn.getUid(),adjustedSbn.getInitialPid(),summaryNotification,adjustedSbn.getUser(),newAutoBundleKey,System.currentTimeMillis());
          summaryRecord=new NotificationRecord(getContext(),summarySbn);
          summaries.put(adjustment.getPackage(),summarySbn.getKey());
        }
      }
      if (summaryRecord != null) {
        mHandler.post(new EnqueueNotificationRunnable(userId,summaryRecord));
      }
    }
  }
}",0.9448441247002398
191476,"public void copyRankingInformation(NotificationRecord previous){
  mContactAffinity=previous.mContactAffinity;
  mRecentlyIntrusive=previous.mRecentlyIntrusive;
  mPackagePriority=previous.mPackagePriority;
  mPackageVisibility=previous.mPackageVisibility;
  mIntercept=previous.mIntercept;
  mRankingTimeMs=calculateRankingTimeMs(previous.getRankingTimeMs());
  mCreationTimeMs=previous.mCreationTimeMs;
  mVisibleSinceMs=previous.mVisibleSinceMs;
  if (previous.sbn.getOverrideGroupKey() != null) {
    sbn.setOverrideGroupKey(previous.sbn.getOverrideGroupKey());
  }
}","public void copyRankingInformation(NotificationRecord previous){
  mContactAffinity=previous.mContactAffinity;
  mRecentlyIntrusive=previous.mRecentlyIntrusive;
  mPackagePriority=previous.mPackagePriority;
  mPackageVisibility=previous.mPackageVisibility;
  mIntercept=previous.mIntercept;
  mRankingTimeMs=calculateRankingTimeMs(previous.getRankingTimeMs());
  mCreationTimeMs=previous.mCreationTimeMs;
  mVisibleSinceMs=previous.mVisibleSinceMs;
  if (previous.sbn.getOverrideGroupKey() != null && !sbn.isAppGroup()) {
    sbn.setOverrideGroupKey(previous.sbn.getOverrideGroupKey());
  }
}",0.9819432502149612
191477,"@Override public void onAdjustedForImeChanged(boolean adjustedForIme,long animDuration) throws RemoteException {
  mView.post(() -> {
    if (mAdjustedForIme != adjustedForIme) {
      mAdjustedForIme=adjustedForIme;
      updateTouchable();
      if (animDuration > 0) {
        mView.setAdjustedForIme(adjustedForIme,animDuration);
      }
 else {
        mView.setAdjustedForIme(adjustedForIme);
      }
    }
  }
);
}","@Override public void onAdjustedForImeChanged(boolean adjustedForIme,long animDuration) throws RemoteException {
  mView.post(() -> {
    if (mAdjustedForIme != adjustedForIme) {
      mAdjustedForIme=adjustedForIme;
      updateTouchable();
      if (!mMinimized) {
        if (animDuration > 0) {
          mView.setAdjustedForIme(adjustedForIme,animDuration);
        }
 else {
          mView.setAdjustedForIme(adjustedForIme);
        }
      }
    }
  }
);
}",0.9514124293785312
191478,"void setAdjustedForIme(boolean adjustedForIme,boolean adjustedForDivider,boolean animate,WindowState imeWin,int imeHeight){
  if (mAdjustedForIme != adjustedForIme || (adjustedForIme && mImeHeight != imeHeight) || mAdjustedForDivider != adjustedForDivider) {
    if (animate) {
      startImeAdjustAnimation(adjustedForIme,adjustedForDivider,imeWin);
    }
 else {
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,0);
    }
    mAdjustedForIme=adjustedForIme;
    mImeHeight=imeHeight;
    mAdjustedForDivider=adjustedForDivider;
  }
}","void setAdjustedForIme(boolean adjustedForIme,boolean adjustedForDivider,boolean animate,WindowState imeWin,int imeHeight){
  if (mAdjustedForIme != adjustedForIme || (adjustedForIme && mImeHeight != imeHeight) || mAdjustedForDivider != adjustedForDivider) {
    if (animate && !mAnimatingForMinimizedDockedStack) {
      startImeAdjustAnimation(adjustedForIme,adjustedForDivider,imeWin);
    }
 else {
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,0);
    }
    mAdjustedForIme=adjustedForIme;
    mImeHeight=imeHeight;
    mAdjustedForDivider=adjustedForDivider;
  }
}",0.9670138888888888
191479,"private void startImeAdjustAnimation(boolean adjustedForIme,boolean adjustedForDivider,WindowState imeWin){
  mAnimatingForIme=true;
  mAnimationStarted=false;
  if (!mAnimatingForIme) {
    mAnimationStart=mAdjustedForIme ? 1 : 0;
    mDividerAnimationStart=mAdjustedForDivider ? 1 : 0;
    mLastAnimationProgress=mAnimationStart;
    mLastDividerProgress=mDividerAnimationStart;
  }
 else {
    mAnimationStart=mLastAnimationProgress;
    mDividerAnimationStart=mLastDividerProgress;
  }
  mAnimationTarget=adjustedForIme ? 1 : 0;
  mDividerAnimationTarget=adjustedForDivider ? 1 : 0;
  final ArrayList<TaskStack> stacks=mDisplayContent.getStacks();
  for (int i=stacks.size() - 1; i >= 0; --i) {
    final TaskStack stack=stacks.get(i);
    if (stack.isVisibleLocked() && stack.isAdjustedForIme()) {
      stack.beginImeAdjustAnimation();
    }
  }
  if (!mService.mWaitingForDrawn.isEmpty()) {
    mService.mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    mService.mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,IME_ADJUST_DRAWN_TIMEOUT);
    mAnimationStartDelayed=true;
    if (imeWin != null) {
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      mDelayedImeWin=imeWin;
      imeWin.mWinAnimator.startDelayingAnimationStart();
    }
    mService.mWaitingForDrawnCallback=() -> {
      mAnimationStartDelayed=false;
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
    }
;
  }
 else {
    notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
  }
}","private void startImeAdjustAnimation(boolean adjustedForIme,boolean adjustedForDivider,WindowState imeWin){
  if (!mAnimatingForIme) {
    mAnimationStart=mAdjustedForIme ? 1 : 0;
    mDividerAnimationStart=mAdjustedForDivider ? 1 : 0;
    mLastAnimationProgress=mAnimationStart;
    mLastDividerProgress=mDividerAnimationStart;
  }
 else {
    mAnimationStart=mLastAnimationProgress;
    mDividerAnimationStart=mLastDividerProgress;
  }
  mAnimatingForIme=true;
  mAnimationStarted=false;
  mAnimationTarget=adjustedForIme ? 1 : 0;
  mDividerAnimationTarget=adjustedForDivider ? 1 : 0;
  final ArrayList<TaskStack> stacks=mDisplayContent.getStacks();
  for (int i=stacks.size() - 1; i >= 0; --i) {
    final TaskStack stack=stacks.get(i);
    if (stack.isVisibleLocked() && stack.isAdjustedForIme()) {
      stack.beginImeAdjustAnimation();
    }
  }
  if (!mService.mWaitingForDrawn.isEmpty()) {
    mService.mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    mService.mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,IME_ADJUST_DRAWN_TIMEOUT);
    mAnimationStartDelayed=true;
    if (imeWin != null) {
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      mDelayedImeWin=imeWin;
      imeWin.mWinAnimator.startDelayingAnimationStart();
    }
    mService.mWaitingForDrawnCallback=() -> {
      mAnimationStartDelayed=false;
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
    }
;
  }
 else {
    notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
  }
}",0.781322505800464
191480,"@Override public void onAdjustedForImeChanged(boolean adjustedForIme,long animDuration) throws RemoteException {
  mView.post(() -> {
    if (mAdjustedForIme != adjustedForIme) {
      mAdjustedForIme=adjustedForIme;
      updateTouchable();
      if (animDuration > 0) {
        mView.setAdjustedForIme(adjustedForIme,animDuration);
      }
 else {
        mView.setAdjustedForIme(adjustedForIme);
      }
    }
  }
);
}","@Override public void onAdjustedForImeChanged(boolean adjustedForIme,long animDuration) throws RemoteException {
  mView.post(() -> {
    if (mAdjustedForIme != adjustedForIme) {
      mAdjustedForIme=adjustedForIme;
      updateTouchable();
      if (!mMinimized) {
        if (animDuration > 0) {
          mView.setAdjustedForIme(adjustedForIme,animDuration);
        }
 else {
          mView.setAdjustedForIme(adjustedForIme);
        }
      }
    }
  }
);
}",0.9514124293785312
191481,"void setAdjustedForIme(boolean adjustedForIme,boolean adjustedForDivider,boolean animate,WindowState imeWin,int imeHeight){
  if (mAdjustedForIme != adjustedForIme || (adjustedForIme && mImeHeight != imeHeight) || mAdjustedForDivider != adjustedForDivider) {
    if (animate) {
      startImeAdjustAnimation(adjustedForIme,adjustedForDivider,imeWin);
    }
 else {
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,0);
    }
    mAdjustedForIme=adjustedForIme;
    mImeHeight=imeHeight;
    mAdjustedForDivider=adjustedForDivider;
  }
}","void setAdjustedForIme(boolean adjustedForIme,boolean adjustedForDivider,boolean animate,WindowState imeWin,int imeHeight){
  if (mAdjustedForIme != adjustedForIme || (adjustedForIme && mImeHeight != imeHeight) || mAdjustedForDivider != adjustedForDivider) {
    if (animate && !mAnimatingForMinimizedDockedStack) {
      startImeAdjustAnimation(adjustedForIme,adjustedForDivider,imeWin);
    }
 else {
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,0);
    }
    mAdjustedForIme=adjustedForIme;
    mImeHeight=imeHeight;
    mAdjustedForDivider=adjustedForDivider;
  }
}",0.9670138888888888
191482,"private void startImeAdjustAnimation(boolean adjustedForIme,boolean adjustedForDivider,WindowState imeWin){
  mAnimatingForIme=true;
  mAnimationStarted=false;
  if (!mAnimatingForIme) {
    mAnimationStart=mAdjustedForIme ? 1 : 0;
    mDividerAnimationStart=mAdjustedForDivider ? 1 : 0;
    mLastAnimationProgress=mAnimationStart;
    mLastDividerProgress=mDividerAnimationStart;
  }
 else {
    mAnimationStart=mLastAnimationProgress;
    mDividerAnimationStart=mLastDividerProgress;
  }
  mAnimationTarget=adjustedForIme ? 1 : 0;
  mDividerAnimationTarget=adjustedForDivider ? 1 : 0;
  final ArrayList<TaskStack> stacks=mDisplayContent.getStacks();
  for (int i=stacks.size() - 1; i >= 0; --i) {
    final TaskStack stack=stacks.get(i);
    if (stack.isVisibleLocked() && stack.isAdjustedForIme()) {
      stack.beginImeAdjustAnimation();
    }
  }
  if (!mService.mWaitingForDrawn.isEmpty()) {
    mService.mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    mService.mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,IME_ADJUST_DRAWN_TIMEOUT);
    mAnimationStartDelayed=true;
    if (imeWin != null) {
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      mDelayedImeWin=imeWin;
      imeWin.mWinAnimator.startDelayingAnimationStart();
    }
    mService.mWaitingForDrawnCallback=() -> {
      mAnimationStartDelayed=false;
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
    }
;
  }
 else {
    notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
  }
}","private void startImeAdjustAnimation(boolean adjustedForIme,boolean adjustedForDivider,WindowState imeWin){
  if (!mAnimatingForIme) {
    mAnimationStart=mAdjustedForIme ? 1 : 0;
    mDividerAnimationStart=mAdjustedForDivider ? 1 : 0;
    mLastAnimationProgress=mAnimationStart;
    mLastDividerProgress=mDividerAnimationStart;
  }
 else {
    mAnimationStart=mLastAnimationProgress;
    mDividerAnimationStart=mLastDividerProgress;
  }
  mAnimatingForIme=true;
  mAnimationStarted=false;
  mAnimationTarget=adjustedForIme ? 1 : 0;
  mDividerAnimationTarget=adjustedForDivider ? 1 : 0;
  final ArrayList<TaskStack> stacks=mDisplayContent.getStacks();
  for (int i=stacks.size() - 1; i >= 0; --i) {
    final TaskStack stack=stacks.get(i);
    if (stack.isVisibleLocked() && stack.isAdjustedForIme()) {
      stack.beginImeAdjustAnimation();
    }
  }
  if (!mService.mWaitingForDrawn.isEmpty()) {
    mService.mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    mService.mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,IME_ADJUST_DRAWN_TIMEOUT);
    mAnimationStartDelayed=true;
    if (imeWin != null) {
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      mDelayedImeWin=imeWin;
      imeWin.mWinAnimator.startDelayingAnimationStart();
    }
    mService.mWaitingForDrawnCallback=() -> {
      mAnimationStartDelayed=false;
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
    }
;
  }
 else {
    notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
  }
}",0.781322505800464
191483,"@Override public void onAdjustedForImeChanged(boolean adjustedForIme,long animDuration) throws RemoteException {
  mView.post(() -> {
    if (mAdjustedForIme != adjustedForIme) {
      mAdjustedForIme=adjustedForIme;
      updateTouchable();
      if (animDuration > 0) {
        mView.setAdjustedForIme(adjustedForIme,animDuration);
      }
 else {
        mView.setAdjustedForIme(adjustedForIme);
      }
    }
  }
);
}","@Override public void onAdjustedForImeChanged(boolean adjustedForIme,long animDuration) throws RemoteException {
  mView.post(() -> {
    if (mAdjustedForIme != adjustedForIme) {
      mAdjustedForIme=adjustedForIme;
      updateTouchable();
      if (!mMinimized) {
        if (animDuration > 0) {
          mView.setAdjustedForIme(adjustedForIme,animDuration);
        }
 else {
          mView.setAdjustedForIme(adjustedForIme);
        }
      }
    }
  }
);
}",0.9514124293785312
191484,"void setAdjustedForIme(boolean adjustedForIme,boolean adjustedForDivider,boolean animate,WindowState imeWin,int imeHeight){
  if (mAdjustedForIme != adjustedForIme || (adjustedForIme && mImeHeight != imeHeight) || mAdjustedForDivider != adjustedForDivider) {
    if (animate) {
      startImeAdjustAnimation(adjustedForIme,adjustedForDivider,imeWin);
    }
 else {
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,0);
    }
    mAdjustedForIme=adjustedForIme;
    mImeHeight=imeHeight;
    mAdjustedForDivider=adjustedForDivider;
  }
}","void setAdjustedForIme(boolean adjustedForIme,boolean adjustedForDivider,boolean animate,WindowState imeWin,int imeHeight){
  if (mAdjustedForIme != adjustedForIme || (adjustedForIme && mImeHeight != imeHeight) || mAdjustedForDivider != adjustedForDivider) {
    if (animate && !mAnimatingForMinimizedDockedStack) {
      startImeAdjustAnimation(adjustedForIme,adjustedForDivider,imeWin);
    }
 else {
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,0);
    }
    mAdjustedForIme=adjustedForIme;
    mImeHeight=imeHeight;
    mAdjustedForDivider=adjustedForDivider;
  }
}",0.9670138888888888
191485,"private void startImeAdjustAnimation(boolean adjustedForIme,boolean adjustedForDivider,WindowState imeWin){
  mAnimatingForIme=true;
  mAnimationStarted=false;
  if (!mAnimatingForIme) {
    mAnimationStart=mAdjustedForIme ? 1 : 0;
    mDividerAnimationStart=mAdjustedForDivider ? 1 : 0;
    mLastAnimationProgress=mAnimationStart;
    mLastDividerProgress=mDividerAnimationStart;
  }
 else {
    mAnimationStart=mLastAnimationProgress;
    mDividerAnimationStart=mLastDividerProgress;
  }
  mAnimationTarget=adjustedForIme ? 1 : 0;
  mDividerAnimationTarget=adjustedForDivider ? 1 : 0;
  final ArrayList<TaskStack> stacks=mDisplayContent.getStacks();
  for (int i=stacks.size() - 1; i >= 0; --i) {
    final TaskStack stack=stacks.get(i);
    if (stack.isVisibleLocked() && stack.isAdjustedForIme()) {
      stack.beginImeAdjustAnimation();
    }
  }
  if (!mService.mWaitingForDrawn.isEmpty()) {
    mService.mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    mService.mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,IME_ADJUST_DRAWN_TIMEOUT);
    mAnimationStartDelayed=true;
    if (imeWin != null) {
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      mDelayedImeWin=imeWin;
      imeWin.mWinAnimator.startDelayingAnimationStart();
    }
    mService.mWaitingForDrawnCallback=() -> {
      mAnimationStartDelayed=false;
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
    }
;
  }
 else {
    notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
  }
}","private void startImeAdjustAnimation(boolean adjustedForIme,boolean adjustedForDivider,WindowState imeWin){
  if (!mAnimatingForIme) {
    mAnimationStart=mAdjustedForIme ? 1 : 0;
    mDividerAnimationStart=mAdjustedForDivider ? 1 : 0;
    mLastAnimationProgress=mAnimationStart;
    mLastDividerProgress=mDividerAnimationStart;
  }
 else {
    mAnimationStart=mLastAnimationProgress;
    mDividerAnimationStart=mLastDividerProgress;
  }
  mAnimatingForIme=true;
  mAnimationStarted=false;
  mAnimationTarget=adjustedForIme ? 1 : 0;
  mDividerAnimationTarget=adjustedForDivider ? 1 : 0;
  final ArrayList<TaskStack> stacks=mDisplayContent.getStacks();
  for (int i=stacks.size() - 1; i >= 0; --i) {
    final TaskStack stack=stacks.get(i);
    if (stack.isVisibleLocked() && stack.isAdjustedForIme()) {
      stack.beginImeAdjustAnimation();
    }
  }
  if (!mService.mWaitingForDrawn.isEmpty()) {
    mService.mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);
    mService.mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT,IME_ADJUST_DRAWN_TIMEOUT);
    mAnimationStartDelayed=true;
    if (imeWin != null) {
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      mDelayedImeWin=imeWin;
      imeWin.mWinAnimator.startDelayingAnimationStart();
    }
    mService.mWaitingForDrawnCallback=() -> {
      mAnimationStartDelayed=false;
      if (mDelayedImeWin != null) {
        mDelayedImeWin.mWinAnimator.endDelayingAnimationStart();
      }
      notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
    }
;
  }
 else {
    notifyAdjustedForImeChanged(adjustedForIme || adjustedForDivider,IME_ADJUST_ANIM_DURATION);
  }
}",0.781322505800464
191486,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mConnectivityService=(ConnectivityService)ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateConnectivityStateLocked(null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mConnectivityService=(ConnectivityService)ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
    updateConnectivityState(null);
  }
}",0.98787023977433
191487,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mConnectivityService=(ConnectivityService)ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateConnectivityStateLocked(null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mConnectivityService=(ConnectivityService)ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
    updateConnectivityState(null);
  }
}",0.98787023977433
191488,"void onResourcesLoaded(DecorView decorView,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawableDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor,int navigationBarColor){
  mDecorView=decorView;
  mResizingBackgroundDrawable=resizingBackgroundDrawable;
  mCaptionBackgroundDrawable=captionBackgroundDrawableDrawable;
  mUserCaptionBackgroundDrawable=userCaptionBackgroundDrawable;
  if (mCaptionBackgroundDrawable == null) {
    mCaptionBackgroundDrawable=mResizingBackgroundDrawable;
  }
  if (statusBarColor != 0) {
    mStatusBarColor=new ColorDrawable(statusBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mStatusBarColor=null;
  }
  if (navigationBarColor != 0) {
    mNavigationBarColor=new ColorDrawable(navigationBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mNavigationBarColor=null;
  }
}","void onResourcesLoaded(DecorView decorView,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawableDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor,int navigationBarColor){
  mDecorView=decorView;
  mResizingBackgroundDrawable=resizingBackgroundDrawable != null ? resizingBackgroundDrawable.getConstantState().newDrawable() : null;
  mCaptionBackgroundDrawable=captionBackgroundDrawableDrawable != null ? captionBackgroundDrawableDrawable.getConstantState().newDrawable() : null;
  mUserCaptionBackgroundDrawable=userCaptionBackgroundDrawable != null ? userCaptionBackgroundDrawable.getConstantState().newDrawable() : null;
  if (mCaptionBackgroundDrawable == null) {
    mCaptionBackgroundDrawable=mResizingBackgroundDrawable;
  }
  if (statusBarColor != 0) {
    mStatusBarColor=new ColorDrawable(statusBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mStatusBarColor=null;
  }
  if (navigationBarColor != 0) {
    mNavigationBarColor=new ColorDrawable(navigationBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mNavigationBarColor=null;
  }
}",0.8766001024065541
191489,"void onResourcesLoaded(DecorView decorView,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawableDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor,int navigationBarColor){
  mDecorView=decorView;
  mResizingBackgroundDrawable=resizingBackgroundDrawable;
  mCaptionBackgroundDrawable=captionBackgroundDrawableDrawable;
  mUserCaptionBackgroundDrawable=userCaptionBackgroundDrawable;
  if (mCaptionBackgroundDrawable == null) {
    mCaptionBackgroundDrawable=mResizingBackgroundDrawable;
  }
  if (statusBarColor != 0) {
    mStatusBarColor=new ColorDrawable(statusBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mStatusBarColor=null;
  }
  if (navigationBarColor != 0) {
    mNavigationBarColor=new ColorDrawable(navigationBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mNavigationBarColor=null;
  }
}","void onResourcesLoaded(DecorView decorView,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawableDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor,int navigationBarColor){
  mDecorView=decorView;
  mResizingBackgroundDrawable=resizingBackgroundDrawable != null ? resizingBackgroundDrawable.getConstantState().newDrawable() : null;
  mCaptionBackgroundDrawable=captionBackgroundDrawableDrawable != null ? captionBackgroundDrawableDrawable.getConstantState().newDrawable() : null;
  mUserCaptionBackgroundDrawable=userCaptionBackgroundDrawable != null ? userCaptionBackgroundDrawable.getConstantState().newDrawable() : null;
  if (mCaptionBackgroundDrawable == null) {
    mCaptionBackgroundDrawable=mResizingBackgroundDrawable;
  }
  if (statusBarColor != 0) {
    mStatusBarColor=new ColorDrawable(statusBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mStatusBarColor=null;
  }
  if (navigationBarColor != 0) {
    mNavigationBarColor=new ColorDrawable(navigationBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mNavigationBarColor=null;
  }
}",0.8766001024065541
191490,"void onResourcesLoaded(DecorView decorView,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawableDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor,int navigationBarColor){
  mDecorView=decorView;
  mResizingBackgroundDrawable=resizingBackgroundDrawable;
  mCaptionBackgroundDrawable=captionBackgroundDrawableDrawable;
  mUserCaptionBackgroundDrawable=userCaptionBackgroundDrawable;
  if (mCaptionBackgroundDrawable == null) {
    mCaptionBackgroundDrawable=mResizingBackgroundDrawable;
  }
  if (statusBarColor != 0) {
    mStatusBarColor=new ColorDrawable(statusBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mStatusBarColor=null;
  }
  if (navigationBarColor != 0) {
    mNavigationBarColor=new ColorDrawable(navigationBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mNavigationBarColor=null;
  }
}","void onResourcesLoaded(DecorView decorView,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawableDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor,int navigationBarColor){
  mDecorView=decorView;
  mResizingBackgroundDrawable=resizingBackgroundDrawable != null ? resizingBackgroundDrawable.getConstantState().newDrawable() : null;
  mCaptionBackgroundDrawable=captionBackgroundDrawableDrawable != null ? captionBackgroundDrawableDrawable.getConstantState().newDrawable() : null;
  mUserCaptionBackgroundDrawable=userCaptionBackgroundDrawable != null ? userCaptionBackgroundDrawable.getConstantState().newDrawable() : null;
  if (mCaptionBackgroundDrawable == null) {
    mCaptionBackgroundDrawable=mResizingBackgroundDrawable;
  }
  if (statusBarColor != 0) {
    mStatusBarColor=new ColorDrawable(statusBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mStatusBarColor=null;
  }
  if (navigationBarColor != 0) {
    mNavigationBarColor=new ColorDrawable(navigationBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mNavigationBarColor=null;
  }
}",0.8766001024065541
191491,"protected View bindVetoButtonClickListener(View row,final StatusBarNotification n){
  View vetoButton=row.findViewById(R.id.veto);
  final String _pkg=n.getPackageName();
  final String _tag=n.getTag();
  final int _id=n.getId();
  final int _userId=n.getUserId();
  vetoButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      v.announceForAccessibility(mContext.getString(R.string.accessibility_notification_dismissed));
      try {
        mBarService.onNotificationClear(_pkg,_tag,_id,_userId);
        if (FORCE_REMOTE_INPUT_HISTORY && mKeysKeptForRemoteInput.contains(n.getKey())) {
          removeNotification(n.getKey(),null);
          mKeysKeptForRemoteInput.remove(n.getKey());
        }
      }
 catch (      RemoteException ex) {
      }
    }
  }
);
  vetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  return vetoButton;
}","protected View bindVetoButtonClickListener(View row,final StatusBarNotification n){
  View vetoButton=row.findViewById(R.id.veto);
  vetoButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      v.announceForAccessibility(mContext.getString(R.string.accessibility_notification_dismissed));
      performRemoveNotification(n,false);
    }
  }
);
  vetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  return vetoButton;
}",0.6676238334529792
191492,"public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        HeadsUpManager.setIsClickedNotification(row,true);
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}","public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        HeadsUpManager.setIsClickedNotification(row,true);
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      StatusBarNotification parentToCancel=null;
      if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
        StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
        if (shouldAutoCancel(summarySbn)) {
          parentToCancel=summarySbn;
        }
      }
      final StatusBarNotification parentToCancelFinal=parentToCancel;
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
          if (parentToCancelFinal != null) {
            mHandler.post(new Runnable(){
              @Override public void run(){
                Runnable removeRunnable=new Runnable(){
                  @Override public void run(){
                    performRemoveNotification(parentToCancelFinal,true);
                  }
                }
;
                if (isCollapsing()) {
                  addPostCollapseAction(removeRunnable);
                }
 else {
                  removeRunnable.run();
                }
              }
            }
);
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}",0.8574769770501389
191493,"@Override public void run(){
  try {
    if (keyguardShowing && !afterKeyguardGone) {
      ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
    }
    ActivityManagerNative.getDefault().resumeAppSwitches();
  }
 catch (  RemoteException e) {
  }
  if (intent != null) {
    if (intent.isActivity()) {
      final int userId=intent.getCreatorUserHandle().getIdentifier();
      if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
        if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
          return;
        }
      }
    }
    try {
      intent.send(null,0,null,null,null,null,getActivityOptions());
    }
 catch (    PendingIntent.CanceledException e) {
      Log.w(TAG,""String_Node_Str"" + e);
    }
    if (intent.isActivity()) {
      mAssistManager.hideAssist();
      overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
    }
  }
  try {
    mBarService.onNotificationClick(notificationKey);
  }
 catch (  RemoteException ex) {
  }
}","@Override public void run(){
  performRemoveNotification(parentToCancelFinal,true);
}",0.1111111111111111
191494,"public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    HeadsUpManager.setIsClickedNotification(row,true);
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}","public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    HeadsUpManager.setIsClickedNotification(row,true);
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  StatusBarNotification parentToCancel=null;
  if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
    StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
    if (shouldAutoCancel(summarySbn)) {
      parentToCancel=summarySbn;
    }
  }
  final StatusBarNotification parentToCancelFinal=parentToCancel;
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
      if (parentToCancelFinal != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            Runnable removeRunnable=new Runnable(){
              @Override public void run(){
                performRemoveNotification(parentToCancelFinal,true);
              }
            }
;
            if (isCollapsing()) {
              addPostCollapseAction(removeRunnable);
            }
 else {
              removeRunnable.run();
            }
          }
        }
);
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}",0.7844002943340692
191495,"public boolean isOnlyChildInSuppressedGroup(StatusBarNotification sbn){
  return isGroupSuppressed(sbn.getGroupKey()) && !sbn.getNotification().isGroupSummary() && getTotalNumberOfChildren(sbn) == 1;
}","public boolean isOnlyChildInSuppressedGroup(StatusBarNotification sbn){
  return isGroupSuppressed(sbn.getGroupKey()) && isOnlyChildInGroup(sbn);
}",0.7816091954022989
191496,"public void addPostCollapseAction(Runnable r){
  mPostCollapseRunnables.add(r);
}","@Override public void addPostCollapseAction(Runnable r){
  mPostCollapseRunnables.add(r);
}",0.9418604651162792
191497,"public boolean isCollapsing(){
  return mNotificationPanel.isCollapsing();
}","@Override public boolean isCollapsing(){
  return mNotificationPanel.isCollapsing();
}",0.9382716049382716
191498,"protected View bindVetoButtonClickListener(View row,final StatusBarNotification n){
  View vetoButton=row.findViewById(R.id.veto);
  final String _pkg=n.getPackageName();
  final String _tag=n.getTag();
  final int _id=n.getId();
  final int _userId=n.getUserId();
  vetoButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      v.announceForAccessibility(mContext.getString(R.string.accessibility_notification_dismissed));
      try {
        mBarService.onNotificationClear(_pkg,_tag,_id,_userId);
        if (FORCE_REMOTE_INPUT_HISTORY && mKeysKeptForRemoteInput.contains(n.getKey())) {
          removeNotification(n.getKey(),null);
          mKeysKeptForRemoteInput.remove(n.getKey());
        }
      }
 catch (      RemoteException ex) {
      }
    }
  }
);
  vetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  return vetoButton;
}","protected View bindVetoButtonClickListener(View row,final StatusBarNotification n){
  View vetoButton=row.findViewById(R.id.veto);
  vetoButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      v.announceForAccessibility(mContext.getString(R.string.accessibility_notification_dismissed));
      performRemoveNotification(n,false);
    }
  }
);
  vetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  return vetoButton;
}",0.6676238334529792
191499,"public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        HeadsUpManager.setIsClickedNotification(row,true);
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}","public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        HeadsUpManager.setIsClickedNotification(row,true);
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      StatusBarNotification parentToCancel=null;
      if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
        StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
        if (shouldAutoCancel(summarySbn)) {
          parentToCancel=summarySbn;
        }
      }
      final StatusBarNotification parentToCancelFinal=parentToCancel;
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
          if (parentToCancelFinal != null) {
            mHandler.post(new Runnable(){
              @Override public void run(){
                Runnable removeRunnable=new Runnable(){
                  @Override public void run(){
                    performRemoveNotification(parentToCancelFinal,true);
                  }
                }
;
                if (isCollapsing()) {
                  addPostCollapseAction(removeRunnable);
                }
 else {
                  removeRunnable.run();
                }
              }
            }
);
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}",0.8574769770501389
191500,"@Override public void run(){
  try {
    if (keyguardShowing && !afterKeyguardGone) {
      ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
    }
    ActivityManagerNative.getDefault().resumeAppSwitches();
  }
 catch (  RemoteException e) {
  }
  if (intent != null) {
    if (intent.isActivity()) {
      final int userId=intent.getCreatorUserHandle().getIdentifier();
      if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
        if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
          return;
        }
      }
    }
    try {
      intent.send(null,0,null,null,null,null,getActivityOptions());
    }
 catch (    PendingIntent.CanceledException e) {
      Log.w(TAG,""String_Node_Str"" + e);
    }
    if (intent.isActivity()) {
      mAssistManager.hideAssist();
      overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
    }
  }
  try {
    mBarService.onNotificationClick(notificationKey);
  }
 catch (  RemoteException ex) {
  }
}","@Override public void run(){
  performRemoveNotification(parentToCancelFinal,true);
}",0.1111111111111111
191501,"public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    HeadsUpManager.setIsClickedNotification(row,true);
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}","public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    HeadsUpManager.setIsClickedNotification(row,true);
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  StatusBarNotification parentToCancel=null;
  if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
    StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
    if (shouldAutoCancel(summarySbn)) {
      parentToCancel=summarySbn;
    }
  }
  final StatusBarNotification parentToCancelFinal=parentToCancel;
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
      if (parentToCancelFinal != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            Runnable removeRunnable=new Runnable(){
              @Override public void run(){
                performRemoveNotification(parentToCancelFinal,true);
              }
            }
;
            if (isCollapsing()) {
              addPostCollapseAction(removeRunnable);
            }
 else {
              removeRunnable.run();
            }
          }
        }
);
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}",0.7844002943340692
191502,"public boolean isOnlyChildInSuppressedGroup(StatusBarNotification sbn){
  return isGroupSuppressed(sbn.getGroupKey()) && !sbn.getNotification().isGroupSummary() && getTotalNumberOfChildren(sbn) == 1;
}","public boolean isOnlyChildInSuppressedGroup(StatusBarNotification sbn){
  return isGroupSuppressed(sbn.getGroupKey()) && isOnlyChildInGroup(sbn);
}",0.7816091954022989
191503,"public void addPostCollapseAction(Runnable r){
  mPostCollapseRunnables.add(r);
}","@Override public void addPostCollapseAction(Runnable r){
  mPostCollapseRunnables.add(r);
}",0.9418604651162792
191504,"public boolean isCollapsing(){
  return mNotificationPanel.isCollapsing();
}","@Override public boolean isCollapsing(){
  return mNotificationPanel.isCollapsing();
}",0.9382716049382716
191505,"@Override public int send(int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options){
  try {
    mResult.offer(intent,5,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return 0;
}","@Override public void send(int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options){
  try {
    mResult.offer(intent,5,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}",0.9667250437828372
191506,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean moveHomeStackFront=data.readInt() != 0;
final boolean res=moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds,moveHomeStackFront);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
final int animationDuration=data.readInt();
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate,animationDuration);
reply.writeNoException();
return true;
}
case RESIZE_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempPinnedTaskBounds=data.readInt() != 0;
Rect tempPinnedTaskBounds=null;
if (hasTempPinnedTaskBounds) {
tempPinnedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
resizePinnedStack(bounds,tempPinnedTaskBounds);
return true;
}
case SWAP_DOCKED_AND_FULLSCREEN_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
swapDockedAndFullscreenStack();
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
int sflags=data.readInt();
setServiceForeground(className,token,id,notification,sflags);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean showing=data.readInt() != 0;
final boolean occluded=data.readInt() != 0;
setLockScreenShown(showing,occluded);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
boolean imAMonkey=data.readInt() != 0;
setActivityController(watcher,imAMonkey);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
IProgressListener listener=IProgressListener.Stub.asInterface(data.readStrongBinder());
boolean result=unlockUser(userId,token,secret,listener);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt());
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
Bundle receiverExtras=data.readBundle();
IBinder activityToken=data.readStrongBinder();
boolean focused=data.readInt() == 1;
boolean newSessionId=data.readInt() == 1;
boolean res=requestAssistContextExtras(requestType,receiver,receiverExtras,activityToken,focused,newSessionId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
startSystemLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopSystemLockTaskMode();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=isInMultiWindowMode(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=isInPictureInPictureMode(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPictureMode(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
int res=setVrMode(token,enable,packageName);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IS_VR_PACKAGE_ENABLED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
boolean res=isVrModePackageEnabled(packageName);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
case NOTIFY_LOCKED_PROFILE:
{
data.enforceInterface(IActivityManager.descriptor);
final int userId=data.readInt();
notifyLockedProfile(userId);
reply.writeNoException();
return true;
}
case START_CONFIRM_DEVICE_CREDENTIAL_INTENT:
{
data.enforceInterface(IActivityManager.descriptor);
final Intent intent=Intent.CREATOR.createFromParcel(data);
startConfirmDeviceCredentialIntent(intent);
reply.writeNoException();
return true;
}
case SEND_IDLE_JOB_TRIGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
sendIdleJobTrigger();
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean moveHomeStackFront=data.readInt() != 0;
final boolean res=moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds,moveHomeStackFront);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
final int animationDuration=data.readInt();
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate,animationDuration);
reply.writeNoException();
return true;
}
case RESIZE_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempPinnedTaskBounds=data.readInt() != 0;
Rect tempPinnedTaskBounds=null;
if (hasTempPinnedTaskBounds) {
tempPinnedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
resizePinnedStack(bounds,tempPinnedTaskBounds);
return true;
}
case SWAP_DOCKED_AND_FULLSCREEN_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
swapDockedAndFullscreenStack();
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
int sflags=data.readInt();
setServiceForeground(className,token,id,notification,sflags);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean showing=data.readInt() != 0;
final boolean occluded=data.readInt() != 0;
setLockScreenShown(showing,occluded);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
boolean imAMonkey=data.readInt() != 0;
setActivityController(watcher,imAMonkey);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
IProgressListener listener=IProgressListener.Stub.asInterface(data.readStrongBinder());
boolean result=unlockUser(userId,token,secret,listener);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt());
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
Bundle receiverExtras=data.readBundle();
IBinder activityToken=data.readStrongBinder();
boolean focused=data.readInt() == 1;
boolean newSessionId=data.readInt() == 1;
boolean res=requestAssistContextExtras(requestType,receiver,receiverExtras,activityToken,focused,newSessionId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
startSystemLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopSystemLockTaskMode();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=isInMultiWindowMode(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=isInPictureInPictureMode(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPictureMode(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
int res=setVrMode(token,enable,packageName);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IS_VR_PACKAGE_ENABLED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
boolean res=isVrModePackageEnabled(packageName);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
case NOTIFY_LOCKED_PROFILE:
{
data.enforceInterface(IActivityManager.descriptor);
final int userId=data.readInt();
notifyLockedProfile(userId);
reply.writeNoException();
return true;
}
case START_CONFIRM_DEVICE_CREDENTIAL_INTENT:
{
data.enforceInterface(IActivityManager.descriptor);
final Intent intent=Intent.CREATOR.createFromParcel(data);
startConfirmDeviceCredentialIntent(intent);
reply.writeNoException();
return true;
}
case SEND_IDLE_JOB_TRIGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
sendIdleJobTrigger();
reply.writeNoException();
return true;
}
case SEND_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender sender=IIntentSender.Stub.asInterface(data.readStrongBinder());
int scode=data.readInt();
Intent intent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String resolvedType=data.readString();
IIntentReceiver finishedReceiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
String requiredPermission=data.readString();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=sendIntentSender(sender,scode,intent,resolvedType,finishedReceiver,requiredPermission,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9957213304970024
191507,"/** 
 * Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed. <p>For the intent parameter, a PendingIntent often has restrictions on which fields can be supplied here, based on how the PendingIntent was retrieved in   {@link #getActivity},  {@link #getBroadcast}, or   {@link #getService}.
 * @param context The Context of the caller.  This may be null if<var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn Intent.fillIn()} for information on how this is applied to theoriginal Intent.  Use null to not modify the original Intent. If flag  {@link #FLAG_IMMUTABLE} was set when this pending intent wascreated, this argument will be ignored.
 * @param onFinished The object to call back on when the send hascompleted, or null for no callback.
 * @param handler Handler identifying the thread on which the callbackshould happen.  If null, the callback will happen from the thread pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntentis required to hold.  This is only valid for broadcast intents, and corresponds to the permission argument in {@link Context#sendBroadcast(Intent,String) Context.sendOrderedBroadcast(Intent, String)}. If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sendingbehavior.  May be built from an  {@link ActivityOptions} to apply to an activity start.
 * @see #send()
 * @see #send(int)
 * @see #send(Context,int,Intent)
 * @see #send(int,android.app.PendingIntent.OnFinished,Handler)
 * @see #send(Context,int,Intent,OnFinished,Handler)
 * @throws CanceledException Throws CanceledException if the PendingIntentis no longer allowing more intents to be sent through it.
 */
public void send(Context context,int code,@Nullable Intent intent,@Nullable OnFinished onFinished,@Nullable Handler handler,@Nullable String requiredPermission,@Nullable Bundle options) throws CanceledException {
  try {
    String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    int res=mTarget.send(code,intent,resolvedType,onFinished != null ? new FinishedDispatcher(this,onFinished,handler) : null,requiredPermission,options);
    if (res < 0) {
      throw new CanceledException();
    }
  }
 catch (  RemoteException e) {
    throw new CanceledException(e);
  }
}","/** 
 * Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed. <p>For the intent parameter, a PendingIntent often has restrictions on which fields can be supplied here, based on how the PendingIntent was retrieved in   {@link #getActivity},  {@link #getBroadcast}, or   {@link #getService}.
 * @param context The Context of the caller.  This may be null if<var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn Intent.fillIn()} for information on how this is applied to theoriginal Intent.  Use null to not modify the original Intent. If flag  {@link #FLAG_IMMUTABLE} was set when this pending intent wascreated, this argument will be ignored.
 * @param onFinished The object to call back on when the send hascompleted, or null for no callback.
 * @param handler Handler identifying the thread on which the callbackshould happen.  If null, the callback will happen from the thread pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntentis required to hold.  This is only valid for broadcast intents, and corresponds to the permission argument in {@link Context#sendBroadcast(Intent,String) Context.sendOrderedBroadcast(Intent, String)}. If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sendingbehavior.  May be built from an  {@link ActivityOptions} to apply to an activity start.
 * @see #send()
 * @see #send(int)
 * @see #send(Context,int,Intent)
 * @see #send(int,android.app.PendingIntent.OnFinished,Handler)
 * @see #send(Context,int,Intent,OnFinished,Handler)
 * @throws CanceledException Throws CanceledException if the PendingIntentis no longer allowing more intents to be sent through it.
 */
public void send(Context context,int code,@Nullable Intent intent,@Nullable OnFinished onFinished,@Nullable Handler handler,@Nullable String requiredPermission,@Nullable Bundle options) throws CanceledException {
  try {
    String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    int res=ActivityManagerNative.getDefault().sendIntentSender(mTarget,code,intent,resolvedType,onFinished != null ? new FinishedDispatcher(this,onFinished,handler) : null,requiredPermission,options);
    if (res < 0) {
      throw new CanceledException();
    }
  }
 catch (  RemoteException e) {
    throw new CanceledException(e);
  }
}",0.9886560276869832
191508,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mConnectivityService=(ConnectivityService)ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateConnectivityStateLocked(null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mConnectivityService=(ConnectivityService)ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
    updateConnectivityState(null);
  }
}",0.98787023977433
191509,"@Override public int send(int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options){
  try {
    mResult.offer(intent,5,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return 0;
}","@Override public void send(int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options){
  try {
    mResult.offer(intent,5,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}",0.9667250437828372
191510,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean moveHomeStackFront=data.readInt() != 0;
final boolean res=moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds,moveHomeStackFront);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
final int animationDuration=data.readInt();
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate,animationDuration);
reply.writeNoException();
return true;
}
case RESIZE_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempPinnedTaskBounds=data.readInt() != 0;
Rect tempPinnedTaskBounds=null;
if (hasTempPinnedTaskBounds) {
tempPinnedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
resizePinnedStack(bounds,tempPinnedTaskBounds);
return true;
}
case SWAP_DOCKED_AND_FULLSCREEN_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
swapDockedAndFullscreenStack();
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
int sflags=data.readInt();
setServiceForeground(className,token,id,notification,sflags);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean showing=data.readInt() != 0;
final boolean occluded=data.readInt() != 0;
setLockScreenShown(showing,occluded);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
boolean imAMonkey=data.readInt() != 0;
setActivityController(watcher,imAMonkey);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
IProgressListener listener=IProgressListener.Stub.asInterface(data.readStrongBinder());
boolean result=unlockUser(userId,token,secret,listener);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt());
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
Bundle receiverExtras=data.readBundle();
IBinder activityToken=data.readStrongBinder();
boolean focused=data.readInt() == 1;
boolean newSessionId=data.readInt() == 1;
boolean res=requestAssistContextExtras(requestType,receiver,receiverExtras,activityToken,focused,newSessionId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
startSystemLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopSystemLockTaskMode();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=isInMultiWindowMode(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=isInPictureInPictureMode(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPictureMode(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
int res=setVrMode(token,enable,packageName);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IS_VR_PACKAGE_ENABLED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
boolean res=isVrModePackageEnabled(packageName);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
case NOTIFY_LOCKED_PROFILE:
{
data.enforceInterface(IActivityManager.descriptor);
final int userId=data.readInt();
notifyLockedProfile(userId);
reply.writeNoException();
return true;
}
case START_CONFIRM_DEVICE_CREDENTIAL_INTENT:
{
data.enforceInterface(IActivityManager.descriptor);
final Intent intent=Intent.CREATOR.createFromParcel(data);
startConfirmDeviceCredentialIntent(intent);
reply.writeNoException();
return true;
}
case SEND_IDLE_JOB_TRIGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
sendIdleJobTrigger();
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean moveHomeStackFront=data.readInt() != 0;
final boolean res=moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds,moveHomeStackFront);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
final int animationDuration=data.readInt();
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate,animationDuration);
reply.writeNoException();
return true;
}
case RESIZE_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempPinnedTaskBounds=data.readInt() != 0;
Rect tempPinnedTaskBounds=null;
if (hasTempPinnedTaskBounds) {
tempPinnedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
resizePinnedStack(bounds,tempPinnedTaskBounds);
return true;
}
case SWAP_DOCKED_AND_FULLSCREEN_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
swapDockedAndFullscreenStack();
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
int sflags=data.readInt();
setServiceForeground(className,token,id,notification,sflags);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean showing=data.readInt() != 0;
final boolean occluded=data.readInt() != 0;
setLockScreenShown(showing,occluded);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
boolean imAMonkey=data.readInt() != 0;
setActivityController(watcher,imAMonkey);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
IProgressListener listener=IProgressListener.Stub.asInterface(data.readStrongBinder());
boolean result=unlockUser(userId,token,secret,listener);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt());
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
Bundle receiverExtras=data.readBundle();
IBinder activityToken=data.readStrongBinder();
boolean focused=data.readInt() == 1;
boolean newSessionId=data.readInt() == 1;
boolean res=requestAssistContextExtras(requestType,receiver,receiverExtras,activityToken,focused,newSessionId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
startSystemLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopSystemLockTaskMode();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=isInMultiWindowMode(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=isInPictureInPictureMode(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPictureMode(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
int res=setVrMode(token,enable,packageName);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IS_VR_PACKAGE_ENABLED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
boolean res=isVrModePackageEnabled(packageName);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
case NOTIFY_LOCKED_PROFILE:
{
data.enforceInterface(IActivityManager.descriptor);
final int userId=data.readInt();
notifyLockedProfile(userId);
reply.writeNoException();
return true;
}
case START_CONFIRM_DEVICE_CREDENTIAL_INTENT:
{
data.enforceInterface(IActivityManager.descriptor);
final Intent intent=Intent.CREATOR.createFromParcel(data);
startConfirmDeviceCredentialIntent(intent);
reply.writeNoException();
return true;
}
case SEND_IDLE_JOB_TRIGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
sendIdleJobTrigger();
reply.writeNoException();
return true;
}
case SEND_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender sender=IIntentSender.Stub.asInterface(data.readStrongBinder());
int scode=data.readInt();
Intent intent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String resolvedType=data.readString();
IIntentReceiver finishedReceiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
String requiredPermission=data.readString();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=sendIntentSender(sender,scode,intent,resolvedType,finishedReceiver,requiredPermission,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9957213304970024
191511,"/** 
 * Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed. <p>For the intent parameter, a PendingIntent often has restrictions on which fields can be supplied here, based on how the PendingIntent was retrieved in   {@link #getActivity},  {@link #getBroadcast}, or   {@link #getService}.
 * @param context The Context of the caller.  This may be null if<var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn Intent.fillIn()} for information on how this is applied to theoriginal Intent.  Use null to not modify the original Intent. If flag  {@link #FLAG_IMMUTABLE} was set when this pending intent wascreated, this argument will be ignored.
 * @param onFinished The object to call back on when the send hascompleted, or null for no callback.
 * @param handler Handler identifying the thread on which the callbackshould happen.  If null, the callback will happen from the thread pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntentis required to hold.  This is only valid for broadcast intents, and corresponds to the permission argument in {@link Context#sendBroadcast(Intent,String) Context.sendOrderedBroadcast(Intent, String)}. If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sendingbehavior.  May be built from an  {@link ActivityOptions} to apply to an activity start.
 * @see #send()
 * @see #send(int)
 * @see #send(Context,int,Intent)
 * @see #send(int,android.app.PendingIntent.OnFinished,Handler)
 * @see #send(Context,int,Intent,OnFinished,Handler)
 * @throws CanceledException Throws CanceledException if the PendingIntentis no longer allowing more intents to be sent through it.
 */
public void send(Context context,int code,@Nullable Intent intent,@Nullable OnFinished onFinished,@Nullable Handler handler,@Nullable String requiredPermission,@Nullable Bundle options) throws CanceledException {
  try {
    String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    int res=mTarget.send(code,intent,resolvedType,onFinished != null ? new FinishedDispatcher(this,onFinished,handler) : null,requiredPermission,options);
    if (res < 0) {
      throw new CanceledException();
    }
  }
 catch (  RemoteException e) {
    throw new CanceledException(e);
  }
}","/** 
 * Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed. <p>For the intent parameter, a PendingIntent often has restrictions on which fields can be supplied here, based on how the PendingIntent was retrieved in   {@link #getActivity},  {@link #getBroadcast}, or   {@link #getService}.
 * @param context The Context of the caller.  This may be null if<var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn Intent.fillIn()} for information on how this is applied to theoriginal Intent.  Use null to not modify the original Intent. If flag  {@link #FLAG_IMMUTABLE} was set when this pending intent wascreated, this argument will be ignored.
 * @param onFinished The object to call back on when the send hascompleted, or null for no callback.
 * @param handler Handler identifying the thread on which the callbackshould happen.  If null, the callback will happen from the thread pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntentis required to hold.  This is only valid for broadcast intents, and corresponds to the permission argument in {@link Context#sendBroadcast(Intent,String) Context.sendOrderedBroadcast(Intent, String)}. If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sendingbehavior.  May be built from an  {@link ActivityOptions} to apply to an activity start.
 * @see #send()
 * @see #send(int)
 * @see #send(Context,int,Intent)
 * @see #send(int,android.app.PendingIntent.OnFinished,Handler)
 * @see #send(Context,int,Intent,OnFinished,Handler)
 * @throws CanceledException Throws CanceledException if the PendingIntentis no longer allowing more intents to be sent through it.
 */
public void send(Context context,int code,@Nullable Intent intent,@Nullable OnFinished onFinished,@Nullable Handler handler,@Nullable String requiredPermission,@Nullable Bundle options) throws CanceledException {
  try {
    String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    int res=ActivityManagerNative.getDefault().sendIntentSender(mTarget,code,intent,resolvedType,onFinished != null ? new FinishedDispatcher(this,onFinished,handler) : null,requiredPermission,options);
    if (res < 0) {
      throw new CanceledException();
    }
  }
 catch (  RemoteException e) {
    throw new CanceledException(e);
  }
}",0.9886560276869832
191512,"/** 
 * @hide 
 */
public ActivityOptions(Bundle opts){
  opts.setDefusable(true);
  mPackageName=opts.getString(KEY_PACKAGE_NAME);
  try {
    mUsageTimeReport=opts.getParcelable(KEY_USAGE_TIME_REPORT);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,e);
  }
  mLaunchBounds=opts.getParcelable(KEY_LAUNCH_BOUNDS);
  mAnimationType=opts.getInt(KEY_ANIM_TYPE);
switch (mAnimationType) {
case ANIM_CUSTOM:
    mCustomEnterResId=opts.getInt(KEY_ANIM_ENTER_RES_ID,0);
  mCustomExitResId=opts.getInt(KEY_ANIM_EXIT_RES_ID,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_CUSTOM_IN_PLACE:
mCustomInPlaceResId=opts.getInt(KEY_ANIM_IN_PLACE_RES_ID,0);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
mThumbnail=(Bitmap)opts.getParcelable(KEY_ANIM_THUMBNAIL);
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_SCENE_TRANSITION:
mTransitionReceiver=opts.getParcelable(KEY_TRANSITION_COMPLETE_LISTENER);
mIsReturning=opts.getBoolean(KEY_TRANSITION_IS_RETURNING,false);
mSharedElementNames=opts.getStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS);
mResultData=opts.getParcelable(KEY_RESULT_DATA);
mResultCode=opts.getInt(KEY_RESULT_CODE);
mExitCoordinatorIndex=opts.getInt(KEY_EXIT_COORDINATOR_INDEX);
break;
}
mLaunchStackId=opts.getInt(KEY_LAUNCH_STACK_ID,INVALID_STACK_ID);
mLaunchTaskId=opts.getInt(KEY_LAUNCH_TASK_ID,-1);
mAvoidMoveToFront=opts.getBoolean(KEY_DONT_MOVE_TO_FRONT,false);
mDockCreateMode=opts.getInt(KEY_DOCK_CREATE_MODE,DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT);
if (opts.containsKey(KEY_ANIM_SPECS)) {
Parcelable[] specs=opts.getParcelableArray(KEY_ANIM_SPECS);
mAnimSpecs=new AppTransitionAnimationSpec[specs.length];
for (int i=specs.length - 1; i >= 0; i--) {
mAnimSpecs[i]=(AppTransitionAnimationSpec)specs[i];
}
}
if (opts.containsKey(KEY_ANIMATION_FINISHED_LISTENER)) {
mAnimationFinishedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIMATION_FINISHED_LISTENER));
}
}","/** 
 * @hide 
 */
public ActivityOptions(Bundle opts){
  opts.setDefusable(true);
  mPackageName=opts.getString(KEY_PACKAGE_NAME);
  try {
    mUsageTimeReport=opts.getParcelable(KEY_USAGE_TIME_REPORT);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,e);
  }
  mLaunchBounds=opts.getParcelable(KEY_LAUNCH_BOUNDS);
  mAnimationType=opts.getInt(KEY_ANIM_TYPE);
switch (mAnimationType) {
case ANIM_CUSTOM:
    mCustomEnterResId=opts.getInt(KEY_ANIM_ENTER_RES_ID,0);
  mCustomExitResId=opts.getInt(KEY_ANIM_EXIT_RES_ID,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_CUSTOM_IN_PLACE:
mCustomInPlaceResId=opts.getInt(KEY_ANIM_IN_PLACE_RES_ID,0);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
mThumbnail=(Bitmap)opts.getParcelable(KEY_ANIM_THUMBNAIL);
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_SCENE_TRANSITION:
mTransitionReceiver=opts.getParcelable(KEY_TRANSITION_COMPLETE_LISTENER);
mIsReturning=opts.getBoolean(KEY_TRANSITION_IS_RETURNING,false);
mSharedElementNames=opts.getStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS);
mResultData=opts.getParcelable(KEY_RESULT_DATA);
mResultCode=opts.getInt(KEY_RESULT_CODE);
mExitCoordinatorIndex=opts.getInt(KEY_EXIT_COORDINATOR_INDEX);
break;
}
mLaunchStackId=opts.getInt(KEY_LAUNCH_STACK_ID,INVALID_STACK_ID);
mLaunchTaskId=opts.getInt(KEY_LAUNCH_TASK_ID,-1);
mTaskOverlay=opts.getBoolean(KEY_TASK_OVERLAY,false);
mDockCreateMode=opts.getInt(KEY_DOCK_CREATE_MODE,DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT);
if (opts.containsKey(KEY_ANIM_SPECS)) {
Parcelable[] specs=opts.getParcelableArray(KEY_ANIM_SPECS);
mAnimSpecs=new AppTransitionAnimationSpec[specs.length];
for (int i=specs.length - 1; i >= 0; i--) {
mAnimSpecs[i]=(AppTransitionAnimationSpec)specs[i];
}
}
if (opts.containsKey(KEY_ANIMATION_FINISHED_LISTENER)) {
mAnimationFinishedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIMATION_FINISHED_LISTENER));
}
}",0.990194116469882
191513,"/** 
 * Returns the created options as a Bundle, which can be passed to  {@link android.content.Context#startActivity(android.content.Intent,android.os.Bundle) Context.startActivity(Intent, Bundle)} and related methods.Note that the returned Bundle is still owned by the ActivityOptions object; you must not modify it, but can supply it to the startActivity methods that take an options Bundle.
 */
public Bundle toBundle(){
  if (mAnimationType == ANIM_DEFAULT) {
    return null;
  }
  Bundle b=new Bundle();
  if (mPackageName != null) {
    b.putString(KEY_PACKAGE_NAME,mPackageName);
  }
  if (mLaunchBounds != null) {
    b.putParcelable(KEY_LAUNCH_BOUNDS,mLaunchBounds);
  }
  b.putInt(KEY_ANIM_TYPE,mAnimationType);
  if (mUsageTimeReport != null) {
    b.putParcelable(KEY_USAGE_TIME_REPORT,mUsageTimeReport);
  }
switch (mAnimationType) {
case ANIM_CUSTOM:
    b.putInt(KEY_ANIM_ENTER_RES_ID,mCustomEnterResId);
  b.putInt(KEY_ANIM_EXIT_RES_ID,mCustomExitResId);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_CUSTOM_IN_PLACE:
b.putInt(KEY_ANIM_IN_PLACE_RES_ID,mCustomInPlaceResId);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
b.putParcelable(KEY_ANIM_THUMBNAIL,mThumbnail);
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_SCENE_TRANSITION:
if (mTransitionReceiver != null) {
b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER,mTransitionReceiver);
}
b.putBoolean(KEY_TRANSITION_IS_RETURNING,mIsReturning);
b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS,mSharedElementNames);
b.putParcelable(KEY_RESULT_DATA,mResultData);
b.putInt(KEY_RESULT_CODE,mResultCode);
b.putInt(KEY_EXIT_COORDINATOR_INDEX,mExitCoordinatorIndex);
break;
}
b.putInt(KEY_LAUNCH_STACK_ID,mLaunchStackId);
b.putInt(KEY_LAUNCH_TASK_ID,mLaunchTaskId);
b.putBoolean(KEY_DONT_MOVE_TO_FRONT,mAvoidMoveToFront);
b.putInt(KEY_DOCK_CREATE_MODE,mDockCreateMode);
if (mAnimSpecs != null) {
b.putParcelableArray(KEY_ANIM_SPECS,mAnimSpecs);
}
if (mAnimationFinishedListener != null) {
b.putBinder(KEY_ANIMATION_FINISHED_LISTENER,mAnimationFinishedListener.asBinder());
}
return b;
}","/** 
 * Returns the created options as a Bundle, which can be passed to  {@link android.content.Context#startActivity(android.content.Intent,android.os.Bundle) Context.startActivity(Intent, Bundle)} and related methods.Note that the returned Bundle is still owned by the ActivityOptions object; you must not modify it, but can supply it to the startActivity methods that take an options Bundle.
 */
public Bundle toBundle(){
  if (mAnimationType == ANIM_DEFAULT) {
    return null;
  }
  Bundle b=new Bundle();
  if (mPackageName != null) {
    b.putString(KEY_PACKAGE_NAME,mPackageName);
  }
  if (mLaunchBounds != null) {
    b.putParcelable(KEY_LAUNCH_BOUNDS,mLaunchBounds);
  }
  b.putInt(KEY_ANIM_TYPE,mAnimationType);
  if (mUsageTimeReport != null) {
    b.putParcelable(KEY_USAGE_TIME_REPORT,mUsageTimeReport);
  }
switch (mAnimationType) {
case ANIM_CUSTOM:
    b.putInt(KEY_ANIM_ENTER_RES_ID,mCustomEnterResId);
  b.putInt(KEY_ANIM_EXIT_RES_ID,mCustomExitResId);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_CUSTOM_IN_PLACE:
b.putInt(KEY_ANIM_IN_PLACE_RES_ID,mCustomInPlaceResId);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
b.putParcelable(KEY_ANIM_THUMBNAIL,mThumbnail);
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_SCENE_TRANSITION:
if (mTransitionReceiver != null) {
b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER,mTransitionReceiver);
}
b.putBoolean(KEY_TRANSITION_IS_RETURNING,mIsReturning);
b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS,mSharedElementNames);
b.putParcelable(KEY_RESULT_DATA,mResultData);
b.putInt(KEY_RESULT_CODE,mResultCode);
b.putInt(KEY_EXIT_COORDINATOR_INDEX,mExitCoordinatorIndex);
break;
}
b.putInt(KEY_LAUNCH_STACK_ID,mLaunchStackId);
b.putInt(KEY_LAUNCH_TASK_ID,mLaunchTaskId);
b.putBoolean(KEY_TASK_OVERLAY,mTaskOverlay);
b.putInt(KEY_DOCK_CREATE_MODE,mDockCreateMode);
if (mAnimSpecs != null) {
b.putParcelableArray(KEY_ANIM_SPECS,mAnimSpecs);
}
if (mAnimationFinishedListener != null) {
b.putBinder(KEY_ANIMATION_FINISHED_LISTENER,mAnimationFinishedListener.asBinder());
}
return b;
}",0.9824759751271904
191514,"protected View bindVetoButtonClickListener(View row,final StatusBarNotification n){
  View vetoButton=row.findViewById(R.id.veto);
  final String _pkg=n.getPackageName();
  final String _tag=n.getTag();
  final int _id=n.getId();
  final int _userId=n.getUserId();
  vetoButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      v.announceForAccessibility(mContext.getString(R.string.accessibility_notification_dismissed));
      try {
        mBarService.onNotificationClear(_pkg,_tag,_id,_userId);
        if (FORCE_REMOTE_INPUT_HISTORY && mKeysKeptForRemoteInput.contains(n.getKey())) {
          removeNotification(n.getKey(),null);
          mKeysKeptForRemoteInput.remove(n.getKey());
        }
      }
 catch (      RemoteException ex) {
      }
    }
  }
);
  vetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  return vetoButton;
}","protected View bindVetoButtonClickListener(View row,final StatusBarNotification n){
  View vetoButton=row.findViewById(R.id.veto);
  vetoButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      v.announceForAccessibility(mContext.getString(R.string.accessibility_notification_dismissed));
      performRemoveNotification(n,false);
    }
  }
);
  vetoButton.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);
  return vetoButton;
}",0.6676238334529792
191515,"public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        HeadsUpManager.setIsClickedNotification(row,true);
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}","public void onClick(final View v){
  if (!(v instanceof ExpandableNotificationRow)) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  final ExpandableNotificationRow row=(ExpandableNotificationRow)v;
  final StatusBarNotification sbn=row.getStatusBarNotification();
  if (sbn == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  if (row.getSettingsRow() != null && row.getSettingsRow().isVisible()) {
    row.animateTranslateNotification(0);
    return;
  }
  Notification notification=sbn.getNotification();
  final PendingIntent intent=notification.contentIntent != null ? notification.contentIntent : notification.fullScreenIntent;
  final String notificationKey=sbn.getKey();
  row.setJustClicked(true);
  DejankUtils.postAfterTraversal(new Runnable(){
    @Override public void run(){
      row.setJustClicked(false);
    }
  }
);
  final boolean keyguardShowing=mStatusBarKeyguardViewManager.isShowing();
  final boolean afterKeyguardGone=intent.isActivity() && PreviewInflater.wouldLaunchResolverActivity(mContext,intent.getIntent(),mCurrentUserId);
  dismissKeyguardThenExecute(new OnDismissAction(){
    public boolean onDismiss(){
      if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
        HeadsUpManager.setIsClickedNotification(row,true);
        mHeadsUpManager.releaseImmediately(notificationKey);
      }
      StatusBarNotification parentToCancel=null;
      if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
        StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
        if (shouldAutoCancel(summarySbn)) {
          parentToCancel=summarySbn;
        }
      }
      final StatusBarNotification parentToCancelFinal=parentToCancel;
      new Thread(){
        @Override public void run(){
          try {
            if (keyguardShowing && !afterKeyguardGone) {
              ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
            }
            ActivityManagerNative.getDefault().resumeAppSwitches();
          }
 catch (          RemoteException e) {
          }
          if (intent != null) {
            if (intent.isActivity()) {
              final int userId=intent.getCreatorUserHandle().getIdentifier();
              if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
                if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
                  return;
                }
              }
            }
            try {
              intent.send(null,0,null,null,null,null,getActivityOptions());
            }
 catch (            PendingIntent.CanceledException e) {
              Log.w(TAG,""String_Node_Str"" + e);
            }
            if (intent.isActivity()) {
              mAssistManager.hideAssist();
              overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
            }
          }
          try {
            mBarService.onNotificationClick(notificationKey);
          }
 catch (          RemoteException ex) {
          }
          if (parentToCancelFinal != null) {
            mHandler.post(new Runnable(){
              @Override public void run(){
                Runnable removeRunnable=new Runnable(){
                  @Override public void run(){
                    performRemoveNotification(parentToCancelFinal,true);
                  }
                }
;
                if (isCollapsing()) {
                  addPostCollapseAction(removeRunnable);
                }
 else {
                  removeRunnable.run();
                }
              }
            }
);
          }
        }
      }
.start();
      animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
      visibilityChanged(false);
      return true;
    }
  }
,afterKeyguardGone);
}",0.8574769770501389
191516,"@Override public void run(){
  try {
    if (keyguardShowing && !afterKeyguardGone) {
      ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
    }
    ActivityManagerNative.getDefault().resumeAppSwitches();
  }
 catch (  RemoteException e) {
  }
  if (intent != null) {
    if (intent.isActivity()) {
      final int userId=intent.getCreatorUserHandle().getIdentifier();
      if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
        if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
          return;
        }
      }
    }
    try {
      intent.send(null,0,null,null,null,null,getActivityOptions());
    }
 catch (    PendingIntent.CanceledException e) {
      Log.w(TAG,""String_Node_Str"" + e);
    }
    if (intent.isActivity()) {
      mAssistManager.hideAssist();
      overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
    }
  }
  try {
    mBarService.onNotificationClick(notificationKey);
  }
 catch (  RemoteException ex) {
  }
}","@Override public void run(){
  performRemoveNotification(parentToCancelFinal,true);
}",0.1111111111111111
191517,"public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    HeadsUpManager.setIsClickedNotification(row,true);
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}","public boolean onDismiss(){
  if (mHeadsUpManager != null && mHeadsUpManager.isHeadsUp(notificationKey)) {
    HeadsUpManager.setIsClickedNotification(row,true);
    mHeadsUpManager.releaseImmediately(notificationKey);
  }
  StatusBarNotification parentToCancel=null;
  if (shouldAutoCancel(sbn) && mGroupManager.isOnlyChildInGroup(sbn)) {
    StatusBarNotification summarySbn=mGroupManager.getLogicalGroupSummary(sbn).getStatusBarNotification();
    if (shouldAutoCancel(summarySbn)) {
      parentToCancel=summarySbn;
    }
  }
  final StatusBarNotification parentToCancelFinal=parentToCancel;
  new Thread(){
    @Override public void run(){
      try {
        if (keyguardShowing && !afterKeyguardGone) {
          ActivityManagerNative.getDefault().keyguardWaitingForActivityDrawn();
        }
        ActivityManagerNative.getDefault().resumeAppSwitches();
      }
 catch (      RemoteException e) {
      }
      if (intent != null) {
        if (intent.isActivity()) {
          final int userId=intent.getCreatorUserHandle().getIdentifier();
          if (mLockPatternUtils.isSeparateProfileChallengeEnabled(userId) && mKeyguardManager.isDeviceLocked(userId)) {
            if (startWorkChallengeIfNecessary(userId,intent.getIntentSender(),notificationKey)) {
              return;
            }
          }
        }
        try {
          intent.send(null,0,null,null,null,null,getActivityOptions());
        }
 catch (        PendingIntent.CanceledException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        if (intent.isActivity()) {
          mAssistManager.hideAssist();
          overrideActivityPendingAppTransition(keyguardShowing && !afterKeyguardGone);
        }
      }
      try {
        mBarService.onNotificationClick(notificationKey);
      }
 catch (      RemoteException ex) {
      }
      if (parentToCancelFinal != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            Runnable removeRunnable=new Runnable(){
              @Override public void run(){
                performRemoveNotification(parentToCancelFinal,true);
              }
            }
;
            if (isCollapsing()) {
              addPostCollapseAction(removeRunnable);
            }
 else {
              removeRunnable.run();
            }
          }
        }
);
      }
    }
  }
.start();
  animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_RECENTS_PANEL,true,true);
  visibilityChanged(false);
  return true;
}",0.7844002943340692
191518,"public boolean isOnlyChildInSuppressedGroup(StatusBarNotification sbn){
  return isGroupSuppressed(sbn.getGroupKey()) && !sbn.getNotification().isGroupSummary() && getTotalNumberOfChildren(sbn) == 1;
}","public boolean isOnlyChildInSuppressedGroup(StatusBarNotification sbn){
  return isGroupSuppressed(sbn.getGroupKey()) && isOnlyChildInGroup(sbn);
}",0.7816091954022989
191519,"public void addPostCollapseAction(Runnable r){
  mPostCollapseRunnables.add(r);
}","@Override public void addPostCollapseAction(Runnable r){
  mPostCollapseRunnables.add(r);
}",0.9418604651162792
191520,"public boolean isCollapsing(){
  return mNotificationPanel.isCollapsing();
}","@Override public boolean isCollapsing(){
  return mNotificationPanel.isCollapsing();
}",0.9382716049382716
191521,"/** 
 * @hide 
 */
public ActivityOptions(Bundle opts){
  opts.setDefusable(true);
  mPackageName=opts.getString(KEY_PACKAGE_NAME);
  try {
    mUsageTimeReport=opts.getParcelable(KEY_USAGE_TIME_REPORT);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,e);
  }
  mLaunchBounds=opts.getParcelable(KEY_LAUNCH_BOUNDS);
  mAnimationType=opts.getInt(KEY_ANIM_TYPE);
switch (mAnimationType) {
case ANIM_CUSTOM:
    mCustomEnterResId=opts.getInt(KEY_ANIM_ENTER_RES_ID,0);
  mCustomExitResId=opts.getInt(KEY_ANIM_EXIT_RES_ID,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_CUSTOM_IN_PLACE:
mCustomInPlaceResId=opts.getInt(KEY_ANIM_IN_PLACE_RES_ID,0);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
mThumbnail=(Bitmap)opts.getParcelable(KEY_ANIM_THUMBNAIL);
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_SCENE_TRANSITION:
mTransitionReceiver=opts.getParcelable(KEY_TRANSITION_COMPLETE_LISTENER);
mIsReturning=opts.getBoolean(KEY_TRANSITION_IS_RETURNING,false);
mSharedElementNames=opts.getStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS);
mResultData=opts.getParcelable(KEY_RESULT_DATA);
mResultCode=opts.getInt(KEY_RESULT_CODE);
mExitCoordinatorIndex=opts.getInt(KEY_EXIT_COORDINATOR_INDEX);
break;
}
mLaunchStackId=opts.getInt(KEY_LAUNCH_STACK_ID,INVALID_STACK_ID);
mLaunchTaskId=opts.getInt(KEY_LAUNCH_TASK_ID,-1);
mAvoidMoveToFront=opts.getBoolean(KEY_DONT_MOVE_TO_FRONT,false);
mDockCreateMode=opts.getInt(KEY_DOCK_CREATE_MODE,DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT);
if (opts.containsKey(KEY_ANIM_SPECS)) {
Parcelable[] specs=opts.getParcelableArray(KEY_ANIM_SPECS);
mAnimSpecs=new AppTransitionAnimationSpec[specs.length];
for (int i=specs.length - 1; i >= 0; i--) {
mAnimSpecs[i]=(AppTransitionAnimationSpec)specs[i];
}
}
if (opts.containsKey(KEY_ANIMATION_FINISHED_LISTENER)) {
mAnimationFinishedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIMATION_FINISHED_LISTENER));
}
}","/** 
 * @hide 
 */
public ActivityOptions(Bundle opts){
  opts.setDefusable(true);
  mPackageName=opts.getString(KEY_PACKAGE_NAME);
  try {
    mUsageTimeReport=opts.getParcelable(KEY_USAGE_TIME_REPORT);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,e);
  }
  mLaunchBounds=opts.getParcelable(KEY_LAUNCH_BOUNDS);
  mAnimationType=opts.getInt(KEY_ANIM_TYPE);
switch (mAnimationType) {
case ANIM_CUSTOM:
    mCustomEnterResId=opts.getInt(KEY_ANIM_ENTER_RES_ID,0);
  mCustomExitResId=opts.getInt(KEY_ANIM_EXIT_RES_ID,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_CUSTOM_IN_PLACE:
mCustomInPlaceResId=opts.getInt(KEY_ANIM_IN_PLACE_RES_ID,0);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
mThumbnail=(Bitmap)opts.getParcelable(KEY_ANIM_THUMBNAIL);
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_SCENE_TRANSITION:
mTransitionReceiver=opts.getParcelable(KEY_TRANSITION_COMPLETE_LISTENER);
mIsReturning=opts.getBoolean(KEY_TRANSITION_IS_RETURNING,false);
mSharedElementNames=opts.getStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS);
mResultData=opts.getParcelable(KEY_RESULT_DATA);
mResultCode=opts.getInt(KEY_RESULT_CODE);
mExitCoordinatorIndex=opts.getInt(KEY_EXIT_COORDINATOR_INDEX);
break;
}
mLaunchStackId=opts.getInt(KEY_LAUNCH_STACK_ID,INVALID_STACK_ID);
mLaunchTaskId=opts.getInt(KEY_LAUNCH_TASK_ID,-1);
mTaskOverlay=opts.getBoolean(KEY_TASK_OVERLAY,false);
mDockCreateMode=opts.getInt(KEY_DOCK_CREATE_MODE,DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT);
if (opts.containsKey(KEY_ANIM_SPECS)) {
Parcelable[] specs=opts.getParcelableArray(KEY_ANIM_SPECS);
mAnimSpecs=new AppTransitionAnimationSpec[specs.length];
for (int i=specs.length - 1; i >= 0; i--) {
mAnimSpecs[i]=(AppTransitionAnimationSpec)specs[i];
}
}
if (opts.containsKey(KEY_ANIMATION_FINISHED_LISTENER)) {
mAnimationFinishedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIMATION_FINISHED_LISTENER));
}
}",0.990194116469882
191522,"/** 
 * Returns the created options as a Bundle, which can be passed to  {@link android.content.Context#startActivity(android.content.Intent,android.os.Bundle) Context.startActivity(Intent, Bundle)} and related methods.Note that the returned Bundle is still owned by the ActivityOptions object; you must not modify it, but can supply it to the startActivity methods that take an options Bundle.
 */
public Bundle toBundle(){
  if (mAnimationType == ANIM_DEFAULT) {
    return null;
  }
  Bundle b=new Bundle();
  if (mPackageName != null) {
    b.putString(KEY_PACKAGE_NAME,mPackageName);
  }
  if (mLaunchBounds != null) {
    b.putParcelable(KEY_LAUNCH_BOUNDS,mLaunchBounds);
  }
  b.putInt(KEY_ANIM_TYPE,mAnimationType);
  if (mUsageTimeReport != null) {
    b.putParcelable(KEY_USAGE_TIME_REPORT,mUsageTimeReport);
  }
switch (mAnimationType) {
case ANIM_CUSTOM:
    b.putInt(KEY_ANIM_ENTER_RES_ID,mCustomEnterResId);
  b.putInt(KEY_ANIM_EXIT_RES_ID,mCustomExitResId);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_CUSTOM_IN_PLACE:
b.putInt(KEY_ANIM_IN_PLACE_RES_ID,mCustomInPlaceResId);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
b.putParcelable(KEY_ANIM_THUMBNAIL,mThumbnail);
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_SCENE_TRANSITION:
if (mTransitionReceiver != null) {
b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER,mTransitionReceiver);
}
b.putBoolean(KEY_TRANSITION_IS_RETURNING,mIsReturning);
b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS,mSharedElementNames);
b.putParcelable(KEY_RESULT_DATA,mResultData);
b.putInt(KEY_RESULT_CODE,mResultCode);
b.putInt(KEY_EXIT_COORDINATOR_INDEX,mExitCoordinatorIndex);
break;
}
b.putInt(KEY_LAUNCH_STACK_ID,mLaunchStackId);
b.putInt(KEY_LAUNCH_TASK_ID,mLaunchTaskId);
b.putBoolean(KEY_DONT_MOVE_TO_FRONT,mAvoidMoveToFront);
b.putInt(KEY_DOCK_CREATE_MODE,mDockCreateMode);
if (mAnimSpecs != null) {
b.putParcelableArray(KEY_ANIM_SPECS,mAnimSpecs);
}
if (mAnimationFinishedListener != null) {
b.putBinder(KEY_ANIMATION_FINISHED_LISTENER,mAnimationFinishedListener.asBinder());
}
return b;
}","/** 
 * Returns the created options as a Bundle, which can be passed to  {@link android.content.Context#startActivity(android.content.Intent,android.os.Bundle) Context.startActivity(Intent, Bundle)} and related methods.Note that the returned Bundle is still owned by the ActivityOptions object; you must not modify it, but can supply it to the startActivity methods that take an options Bundle.
 */
public Bundle toBundle(){
  if (mAnimationType == ANIM_DEFAULT) {
    return null;
  }
  Bundle b=new Bundle();
  if (mPackageName != null) {
    b.putString(KEY_PACKAGE_NAME,mPackageName);
  }
  if (mLaunchBounds != null) {
    b.putParcelable(KEY_LAUNCH_BOUNDS,mLaunchBounds);
  }
  b.putInt(KEY_ANIM_TYPE,mAnimationType);
  if (mUsageTimeReport != null) {
    b.putParcelable(KEY_USAGE_TIME_REPORT,mUsageTimeReport);
  }
switch (mAnimationType) {
case ANIM_CUSTOM:
    b.putInt(KEY_ANIM_ENTER_RES_ID,mCustomEnterResId);
  b.putInt(KEY_ANIM_EXIT_RES_ID,mCustomExitResId);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_CUSTOM_IN_PLACE:
b.putInt(KEY_ANIM_IN_PLACE_RES_ID,mCustomInPlaceResId);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
b.putParcelable(KEY_ANIM_THUMBNAIL,mThumbnail);
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_SCENE_TRANSITION:
if (mTransitionReceiver != null) {
b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER,mTransitionReceiver);
}
b.putBoolean(KEY_TRANSITION_IS_RETURNING,mIsReturning);
b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS,mSharedElementNames);
b.putParcelable(KEY_RESULT_DATA,mResultData);
b.putInt(KEY_RESULT_CODE,mResultCode);
b.putInt(KEY_EXIT_COORDINATOR_INDEX,mExitCoordinatorIndex);
break;
}
b.putInt(KEY_LAUNCH_STACK_ID,mLaunchStackId);
b.putInt(KEY_LAUNCH_TASK_ID,mLaunchTaskId);
b.putBoolean(KEY_TASK_OVERLAY,mTaskOverlay);
b.putInt(KEY_DOCK_CREATE_MODE,mDockCreateMode);
if (mAnimSpecs != null) {
b.putParcelableArray(KEY_ANIM_SPECS,mAnimSpecs);
}
if (mAnimationFinishedListener != null) {
b.putBinder(KEY_ANIMATION_FINISHED_LISTENER,mAnimationFinishedListener.asBinder());
}
return b;
}",0.9824759751271904
191523,"/** 
 * @hide 
 */
public ActivityOptions(Bundle opts){
  opts.setDefusable(true);
  mPackageName=opts.getString(KEY_PACKAGE_NAME);
  try {
    mUsageTimeReport=opts.getParcelable(KEY_USAGE_TIME_REPORT);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,e);
  }
  mLaunchBounds=opts.getParcelable(KEY_LAUNCH_BOUNDS);
  mAnimationType=opts.getInt(KEY_ANIM_TYPE);
switch (mAnimationType) {
case ANIM_CUSTOM:
    mCustomEnterResId=opts.getInt(KEY_ANIM_ENTER_RES_ID,0);
  mCustomExitResId=opts.getInt(KEY_ANIM_EXIT_RES_ID,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_CUSTOM_IN_PLACE:
mCustomInPlaceResId=opts.getInt(KEY_ANIM_IN_PLACE_RES_ID,0);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
mThumbnail=(Bitmap)opts.getParcelable(KEY_ANIM_THUMBNAIL);
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_SCENE_TRANSITION:
mTransitionReceiver=opts.getParcelable(KEY_TRANSITION_COMPLETE_LISTENER);
mIsReturning=opts.getBoolean(KEY_TRANSITION_IS_RETURNING,false);
mSharedElementNames=opts.getStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS);
mResultData=opts.getParcelable(KEY_RESULT_DATA);
mResultCode=opts.getInt(KEY_RESULT_CODE);
mExitCoordinatorIndex=opts.getInt(KEY_EXIT_COORDINATOR_INDEX);
break;
}
mLaunchStackId=opts.getInt(KEY_LAUNCH_STACK_ID,INVALID_STACK_ID);
mLaunchTaskId=opts.getInt(KEY_LAUNCH_TASK_ID,-1);
mAvoidMoveToFront=opts.getBoolean(KEY_DONT_MOVE_TO_FRONT,false);
mDockCreateMode=opts.getInt(KEY_DOCK_CREATE_MODE,DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT);
if (opts.containsKey(KEY_ANIM_SPECS)) {
Parcelable[] specs=opts.getParcelableArray(KEY_ANIM_SPECS);
mAnimSpecs=new AppTransitionAnimationSpec[specs.length];
for (int i=specs.length - 1; i >= 0; i--) {
mAnimSpecs[i]=(AppTransitionAnimationSpec)specs[i];
}
}
if (opts.containsKey(KEY_ANIMATION_FINISHED_LISTENER)) {
mAnimationFinishedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIMATION_FINISHED_LISTENER));
}
}","/** 
 * @hide 
 */
public ActivityOptions(Bundle opts){
  opts.setDefusable(true);
  mPackageName=opts.getString(KEY_PACKAGE_NAME);
  try {
    mUsageTimeReport=opts.getParcelable(KEY_USAGE_TIME_REPORT);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,e);
  }
  mLaunchBounds=opts.getParcelable(KEY_LAUNCH_BOUNDS);
  mAnimationType=opts.getInt(KEY_ANIM_TYPE);
switch (mAnimationType) {
case ANIM_CUSTOM:
    mCustomEnterResId=opts.getInt(KEY_ANIM_ENTER_RES_ID,0);
  mCustomExitResId=opts.getInt(KEY_ANIM_EXIT_RES_ID,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_CUSTOM_IN_PLACE:
mCustomInPlaceResId=opts.getInt(KEY_ANIM_IN_PLACE_RES_ID,0);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
mThumbnail=(Bitmap)opts.getParcelable(KEY_ANIM_THUMBNAIL);
mStartX=opts.getInt(KEY_ANIM_START_X,0);
mStartY=opts.getInt(KEY_ANIM_START_Y,0);
mWidth=opts.getInt(KEY_ANIM_WIDTH,0);
mHeight=opts.getInt(KEY_ANIM_HEIGHT,0);
mAnimationStartedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIM_START_LISTENER));
break;
case ANIM_SCENE_TRANSITION:
mTransitionReceiver=opts.getParcelable(KEY_TRANSITION_COMPLETE_LISTENER);
mIsReturning=opts.getBoolean(KEY_TRANSITION_IS_RETURNING,false);
mSharedElementNames=opts.getStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS);
mResultData=opts.getParcelable(KEY_RESULT_DATA);
mResultCode=opts.getInt(KEY_RESULT_CODE);
mExitCoordinatorIndex=opts.getInt(KEY_EXIT_COORDINATOR_INDEX);
break;
}
mLaunchStackId=opts.getInt(KEY_LAUNCH_STACK_ID,INVALID_STACK_ID);
mLaunchTaskId=opts.getInt(KEY_LAUNCH_TASK_ID,-1);
mTaskOverlay=opts.getBoolean(KEY_TASK_OVERLAY,false);
mDockCreateMode=opts.getInt(KEY_DOCK_CREATE_MODE,DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT);
if (opts.containsKey(KEY_ANIM_SPECS)) {
Parcelable[] specs=opts.getParcelableArray(KEY_ANIM_SPECS);
mAnimSpecs=new AppTransitionAnimationSpec[specs.length];
for (int i=specs.length - 1; i >= 0; i--) {
mAnimSpecs[i]=(AppTransitionAnimationSpec)specs[i];
}
}
if (opts.containsKey(KEY_ANIMATION_FINISHED_LISTENER)) {
mAnimationFinishedListener=IRemoteCallback.Stub.asInterface(opts.getBinder(KEY_ANIMATION_FINISHED_LISTENER));
}
}",0.990194116469882
191524,"/** 
 * Returns the created options as a Bundle, which can be passed to  {@link android.content.Context#startActivity(android.content.Intent,android.os.Bundle) Context.startActivity(Intent, Bundle)} and related methods.Note that the returned Bundle is still owned by the ActivityOptions object; you must not modify it, but can supply it to the startActivity methods that take an options Bundle.
 */
public Bundle toBundle(){
  if (mAnimationType == ANIM_DEFAULT) {
    return null;
  }
  Bundle b=new Bundle();
  if (mPackageName != null) {
    b.putString(KEY_PACKAGE_NAME,mPackageName);
  }
  if (mLaunchBounds != null) {
    b.putParcelable(KEY_LAUNCH_BOUNDS,mLaunchBounds);
  }
  b.putInt(KEY_ANIM_TYPE,mAnimationType);
  if (mUsageTimeReport != null) {
    b.putParcelable(KEY_USAGE_TIME_REPORT,mUsageTimeReport);
  }
switch (mAnimationType) {
case ANIM_CUSTOM:
    b.putInt(KEY_ANIM_ENTER_RES_ID,mCustomEnterResId);
  b.putInt(KEY_ANIM_EXIT_RES_ID,mCustomExitResId);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_CUSTOM_IN_PLACE:
b.putInt(KEY_ANIM_IN_PLACE_RES_ID,mCustomInPlaceResId);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
b.putParcelable(KEY_ANIM_THUMBNAIL,mThumbnail);
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_SCENE_TRANSITION:
if (mTransitionReceiver != null) {
b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER,mTransitionReceiver);
}
b.putBoolean(KEY_TRANSITION_IS_RETURNING,mIsReturning);
b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS,mSharedElementNames);
b.putParcelable(KEY_RESULT_DATA,mResultData);
b.putInt(KEY_RESULT_CODE,mResultCode);
b.putInt(KEY_EXIT_COORDINATOR_INDEX,mExitCoordinatorIndex);
break;
}
b.putInt(KEY_LAUNCH_STACK_ID,mLaunchStackId);
b.putInt(KEY_LAUNCH_TASK_ID,mLaunchTaskId);
b.putBoolean(KEY_DONT_MOVE_TO_FRONT,mAvoidMoveToFront);
b.putInt(KEY_DOCK_CREATE_MODE,mDockCreateMode);
if (mAnimSpecs != null) {
b.putParcelableArray(KEY_ANIM_SPECS,mAnimSpecs);
}
if (mAnimationFinishedListener != null) {
b.putBinder(KEY_ANIMATION_FINISHED_LISTENER,mAnimationFinishedListener.asBinder());
}
return b;
}","/** 
 * Returns the created options as a Bundle, which can be passed to  {@link android.content.Context#startActivity(android.content.Intent,android.os.Bundle) Context.startActivity(Intent, Bundle)} and related methods.Note that the returned Bundle is still owned by the ActivityOptions object; you must not modify it, but can supply it to the startActivity methods that take an options Bundle.
 */
public Bundle toBundle(){
  if (mAnimationType == ANIM_DEFAULT) {
    return null;
  }
  Bundle b=new Bundle();
  if (mPackageName != null) {
    b.putString(KEY_PACKAGE_NAME,mPackageName);
  }
  if (mLaunchBounds != null) {
    b.putParcelable(KEY_LAUNCH_BOUNDS,mLaunchBounds);
  }
  b.putInt(KEY_ANIM_TYPE,mAnimationType);
  if (mUsageTimeReport != null) {
    b.putParcelable(KEY_USAGE_TIME_REPORT,mUsageTimeReport);
  }
switch (mAnimationType) {
case ANIM_CUSTOM:
    b.putInt(KEY_ANIM_ENTER_RES_ID,mCustomEnterResId);
  b.putInt(KEY_ANIM_EXIT_RES_ID,mCustomExitResId);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_CUSTOM_IN_PLACE:
b.putInt(KEY_ANIM_IN_PLACE_RES_ID,mCustomInPlaceResId);
break;
case ANIM_SCALE_UP:
case ANIM_CLIP_REVEAL:
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
break;
case ANIM_THUMBNAIL_SCALE_UP:
case ANIM_THUMBNAIL_SCALE_DOWN:
case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
b.putParcelable(KEY_ANIM_THUMBNAIL,mThumbnail);
b.putInt(KEY_ANIM_START_X,mStartX);
b.putInt(KEY_ANIM_START_Y,mStartY);
b.putInt(KEY_ANIM_WIDTH,mWidth);
b.putInt(KEY_ANIM_HEIGHT,mHeight);
b.putBinder(KEY_ANIM_START_LISTENER,mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
break;
case ANIM_SCENE_TRANSITION:
if (mTransitionReceiver != null) {
b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER,mTransitionReceiver);
}
b.putBoolean(KEY_TRANSITION_IS_RETURNING,mIsReturning);
b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS,mSharedElementNames);
b.putParcelable(KEY_RESULT_DATA,mResultData);
b.putInt(KEY_RESULT_CODE,mResultCode);
b.putInt(KEY_EXIT_COORDINATOR_INDEX,mExitCoordinatorIndex);
break;
}
b.putInt(KEY_LAUNCH_STACK_ID,mLaunchStackId);
b.putInt(KEY_LAUNCH_TASK_ID,mLaunchTaskId);
b.putBoolean(KEY_TASK_OVERLAY,mTaskOverlay);
b.putInt(KEY_DOCK_CREATE_MODE,mDockCreateMode);
if (mAnimSpecs != null) {
b.putParcelableArray(KEY_ANIM_SPECS,mAnimSpecs);
}
if (mAnimationFinishedListener != null) {
b.putBinder(KEY_ANIMATION_FINISHED_LISTENER,mAnimationFinishedListener.asBinder());
}
return b;
}",0.9824759751271904
191525,"@Override public int send(int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options){
  try {
    mResult.offer(intent,5,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return 0;
}","@Override public void send(int code,Intent intent,String resolvedType,IIntentReceiver finishedReceiver,String requiredPermission,Bundle options){
  try {
    mResult.offer(intent,5,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}",0.9667250437828372
191526,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean moveHomeStackFront=data.readInt() != 0;
final boolean res=moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds,moveHomeStackFront);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
final int animationDuration=data.readInt();
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate,animationDuration);
reply.writeNoException();
return true;
}
case RESIZE_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempPinnedTaskBounds=data.readInt() != 0;
Rect tempPinnedTaskBounds=null;
if (hasTempPinnedTaskBounds) {
tempPinnedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
resizePinnedStack(bounds,tempPinnedTaskBounds);
return true;
}
case SWAP_DOCKED_AND_FULLSCREEN_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
swapDockedAndFullscreenStack();
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
int sflags=data.readInt();
setServiceForeground(className,token,id,notification,sflags);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean showing=data.readInt() != 0;
final boolean occluded=data.readInt() != 0;
setLockScreenShown(showing,occluded);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
boolean imAMonkey=data.readInt() != 0;
setActivityController(watcher,imAMonkey);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
IProgressListener listener=IProgressListener.Stub.asInterface(data.readStrongBinder());
boolean result=unlockUser(userId,token,secret,listener);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt());
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
Bundle receiverExtras=data.readBundle();
IBinder activityToken=data.readStrongBinder();
boolean focused=data.readInt() == 1;
boolean newSessionId=data.readInt() == 1;
boolean res=requestAssistContextExtras(requestType,receiver,receiverExtras,activityToken,focused,newSessionId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
startSystemLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopSystemLockTaskMode();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=isInMultiWindowMode(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=isInPictureInPictureMode(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPictureMode(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
int res=setVrMode(token,enable,packageName);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IS_VR_PACKAGE_ENABLED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
boolean res=isVrModePackageEnabled(packageName);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
case NOTIFY_LOCKED_PROFILE:
{
data.enforceInterface(IActivityManager.descriptor);
final int userId=data.readInt();
notifyLockedProfile(userId);
reply.writeNoException();
return true;
}
case START_CONFIRM_DEVICE_CREDENTIAL_INTENT:
{
data.enforceInterface(IActivityManager.descriptor);
final Intent intent=Intent.CREATOR.createFromParcel(data);
startConfirmDeviceCredentialIntent(intent);
reply.writeNoException();
return true;
}
case SEND_IDLE_JOB_TRIGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
sendIdleJobTrigger();
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean moveHomeStackFront=data.readInt() != 0;
final boolean res=moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds,moveHomeStackFront);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
final int animationDuration=data.readInt();
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate,animationDuration);
reply.writeNoException();
return true;
}
case RESIZE_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempPinnedTaskBounds=data.readInt() != 0;
Rect tempPinnedTaskBounds=null;
if (hasTempPinnedTaskBounds) {
tempPinnedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
resizePinnedStack(bounds,tempPinnedTaskBounds);
return true;
}
case SWAP_DOCKED_AND_FULLSCREEN_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
swapDockedAndFullscreenStack();
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
int sflags=data.readInt();
setServiceForeground(className,token,id,notification,sflags);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean showing=data.readInt() != 0;
final boolean occluded=data.readInt() != 0;
setLockScreenShown(showing,occluded);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
boolean imAMonkey=data.readInt() != 0;
setActivityController(watcher,imAMonkey);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
IProgressListener listener=IProgressListener.Stub.asInterface(data.readStrongBinder());
boolean result=unlockUser(userId,token,secret,listener);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt());
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
Bundle receiverExtras=data.readBundle();
IBinder activityToken=data.readStrongBinder();
boolean focused=data.readInt() == 1;
boolean newSessionId=data.readInt() == 1;
boolean res=requestAssistContextExtras(requestType,receiver,receiverExtras,activityToken,focused,newSessionId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
startSystemLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_SYSTEM_LOCK_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopSystemLockTaskMode();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=isInMultiWindowMode(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=isInPictureInPictureMode(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPictureMode(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
int res=setVrMode(token,enable,packageName);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IS_VR_PACKAGE_ENABLED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final ComponentName packageName=ComponentName.CREATOR.createFromParcel(data);
boolean res=isVrModePackageEnabled(packageName);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
case NOTIFY_LOCKED_PROFILE:
{
data.enforceInterface(IActivityManager.descriptor);
final int userId=data.readInt();
notifyLockedProfile(userId);
reply.writeNoException();
return true;
}
case START_CONFIRM_DEVICE_CREDENTIAL_INTENT:
{
data.enforceInterface(IActivityManager.descriptor);
final Intent intent=Intent.CREATOR.createFromParcel(data);
startConfirmDeviceCredentialIntent(intent);
reply.writeNoException();
return true;
}
case SEND_IDLE_JOB_TRIGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
sendIdleJobTrigger();
reply.writeNoException();
return true;
}
case SEND_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender sender=IIntentSender.Stub.asInterface(data.readStrongBinder());
int scode=data.readInt();
Intent intent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String resolvedType=data.readString();
IIntentReceiver finishedReceiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
String requiredPermission=data.readString();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=sendIntentSender(sender,scode,intent,resolvedType,finishedReceiver,requiredPermission,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9957213304970024
191527,"/** 
 * Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed. <p>For the intent parameter, a PendingIntent often has restrictions on which fields can be supplied here, based on how the PendingIntent was retrieved in   {@link #getActivity},  {@link #getBroadcast}, or   {@link #getService}.
 * @param context The Context of the caller.  This may be null if<var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn Intent.fillIn()} for information on how this is applied to theoriginal Intent.  Use null to not modify the original Intent. If flag  {@link #FLAG_IMMUTABLE} was set when this pending intent wascreated, this argument will be ignored.
 * @param onFinished The object to call back on when the send hascompleted, or null for no callback.
 * @param handler Handler identifying the thread on which the callbackshould happen.  If null, the callback will happen from the thread pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntentis required to hold.  This is only valid for broadcast intents, and corresponds to the permission argument in {@link Context#sendBroadcast(Intent,String) Context.sendOrderedBroadcast(Intent, String)}. If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sendingbehavior.  May be built from an  {@link ActivityOptions} to apply to an activity start.
 * @see #send()
 * @see #send(int)
 * @see #send(Context,int,Intent)
 * @see #send(int,android.app.PendingIntent.OnFinished,Handler)
 * @see #send(Context,int,Intent,OnFinished,Handler)
 * @throws CanceledException Throws CanceledException if the PendingIntentis no longer allowing more intents to be sent through it.
 */
public void send(Context context,int code,@Nullable Intent intent,@Nullable OnFinished onFinished,@Nullable Handler handler,@Nullable String requiredPermission,@Nullable Bundle options) throws CanceledException {
  try {
    String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    int res=mTarget.send(code,intent,resolvedType,onFinished != null ? new FinishedDispatcher(this,onFinished,handler) : null,requiredPermission,options);
    if (res < 0) {
      throw new CanceledException();
    }
  }
 catch (  RemoteException e) {
    throw new CanceledException(e);
  }
}","/** 
 * Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed. <p>For the intent parameter, a PendingIntent often has restrictions on which fields can be supplied here, based on how the PendingIntent was retrieved in   {@link #getActivity},  {@link #getBroadcast}, or   {@link #getService}.
 * @param context The Context of the caller.  This may be null if<var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn Intent.fillIn()} for information on how this is applied to theoriginal Intent.  Use null to not modify the original Intent. If flag  {@link #FLAG_IMMUTABLE} was set when this pending intent wascreated, this argument will be ignored.
 * @param onFinished The object to call back on when the send hascompleted, or null for no callback.
 * @param handler Handler identifying the thread on which the callbackshould happen.  If null, the callback will happen from the thread pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntentis required to hold.  This is only valid for broadcast intents, and corresponds to the permission argument in {@link Context#sendBroadcast(Intent,String) Context.sendOrderedBroadcast(Intent, String)}. If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sendingbehavior.  May be built from an  {@link ActivityOptions} to apply to an activity start.
 * @see #send()
 * @see #send(int)
 * @see #send(Context,int,Intent)
 * @see #send(int,android.app.PendingIntent.OnFinished,Handler)
 * @see #send(Context,int,Intent,OnFinished,Handler)
 * @throws CanceledException Throws CanceledException if the PendingIntentis no longer allowing more intents to be sent through it.
 */
public void send(Context context,int code,@Nullable Intent intent,@Nullable OnFinished onFinished,@Nullable Handler handler,@Nullable String requiredPermission,@Nullable Bundle options) throws CanceledException {
  try {
    String resolvedType=intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    int res=ActivityManagerNative.getDefault().sendIntentSender(mTarget,code,intent,resolvedType,onFinished != null ? new FinishedDispatcher(this,onFinished,handler) : null,requiredPermission,options);
    if (res < 0) {
      throw new CanceledException();
    }
  }
 catch (  RemoteException e) {
    throw new CanceledException(e);
  }
}",0.9886560276869832
191528,"final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          app.kill(""String_Node_Str"",false);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,true,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          addAppLocked(app.info,false,null);
        }
      }
    }
    updateOomAdjLocked();
  }
}","final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.toShortString() + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          app.kill(""String_Node_Str"",false);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,true,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          addAppLocked(app.info,false,null);
        }
      }
    }
    updateOomAdjLocked();
  }
}",0.985244040862656
191529,"boolean removeProcessLocked(ProcessRecord app,boolean callerWillRestart,boolean allowRestart,String reason){
  final String name=app.processName;
  final int uid=app.uid;
  if (DEBUG_PROCESSES)   Slog.d(TAG_PROCESSES,""String_Node_Str"" + app.toShortString() + ""String_Node_Str""+ name+ ""String_Node_Str""+ uid+ ""String_Node_Str"");
  removeProcessNameLocked(name,uid);
  if (mHeavyWeightProcess == app) {
    mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,mHeavyWeightProcess.userId,0));
    mHeavyWeightProcess=null;
  }
  boolean needRestart=false;
  if (app.pid > 0 && app.pid != MY_PID) {
    int pid=app.pid;
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    mBatteryStatsService.noteProcessFinish(app.processName,app.info.uid);
    if (app.isolated) {
      mBatteryStatsService.removeIsolatedUid(app.uid,app.info.uid);
    }
    boolean willRestart=false;
    if (app.persistent && !app.isolated) {
      if (!callerWillRestart) {
        willRestart=true;
      }
 else {
        needRestart=true;
      }
    }
    app.kill(reason,true);
    handleAppDiedLocked(app,willRestart,allowRestart);
    if (willRestart) {
      removeLruProcessLocked(app);
      addAppLocked(app.info,false,null);
    }
  }
 else {
    mRemovedProcesses.add(app);
  }
  return needRestart;
}","boolean removeProcessLocked(ProcessRecord app,boolean callerWillRestart,boolean allowRestart,String reason){
  final String name=app.processName;
  final int uid=app.uid;
  if (DEBUG_PROCESSES)   Slog.d(TAG_PROCESSES,""String_Node_Str"" + app.toShortString() + ""String_Node_Str""+ name+ ""String_Node_Str""+ uid+ ""String_Node_Str"");
  ProcessRecord old=mProcessNames.get(name,uid);
  if (old != app) {
    Slog.w(TAG,""String_Node_Str"" + app);
    return false;
  }
  removeProcessNameLocked(name,uid);
  if (mHeavyWeightProcess == app) {
    mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,mHeavyWeightProcess.userId,0));
    mHeavyWeightProcess=null;
  }
  boolean needRestart=false;
  if (app.pid > 0 && app.pid != MY_PID) {
    int pid=app.pid;
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    mBatteryStatsService.noteProcessFinish(app.processName,app.info.uid);
    if (app.isolated) {
      mBatteryStatsService.removeIsolatedUid(app.uid,app.info.uid);
    }
    boolean willRestart=false;
    if (app.persistent && !app.isolated) {
      if (!callerWillRestart) {
        willRestart=true;
      }
 else {
        needRestart=true;
      }
    }
    app.kill(reason,true);
    handleAppDiedLocked(app,willRestart,allowRestart);
    if (willRestart) {
      removeLruProcessLocked(app);
      addAppLocked(app.info,false,null);
    }
  }
 else {
    mRemovedProcesses.add(app);
  }
  return needRestart;
}",0.9546079779917468
191530,"final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          app.kill(""String_Node_Str"",false);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,true,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          addAppLocked(app.info,false,null);
        }
      }
    }
    updateOomAdjLocked();
  }
}","final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.toShortString() + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          app.kill(""String_Node_Str"",false);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,true,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          addAppLocked(app.info,false,null);
        }
      }
    }
    updateOomAdjLocked();
  }
}",0.985244040862656
191531,"boolean removeProcessLocked(ProcessRecord app,boolean callerWillRestart,boolean allowRestart,String reason){
  final String name=app.processName;
  final int uid=app.uid;
  if (DEBUG_PROCESSES)   Slog.d(TAG_PROCESSES,""String_Node_Str"" + app.toShortString() + ""String_Node_Str""+ name+ ""String_Node_Str""+ uid+ ""String_Node_Str"");
  removeProcessNameLocked(name,uid);
  if (mHeavyWeightProcess == app) {
    mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,mHeavyWeightProcess.userId,0));
    mHeavyWeightProcess=null;
  }
  boolean needRestart=false;
  if (app.pid > 0 && app.pid != MY_PID) {
    int pid=app.pid;
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    mBatteryStatsService.noteProcessFinish(app.processName,app.info.uid);
    if (app.isolated) {
      mBatteryStatsService.removeIsolatedUid(app.uid,app.info.uid);
    }
    boolean willRestart=false;
    if (app.persistent && !app.isolated) {
      if (!callerWillRestart) {
        willRestart=true;
      }
 else {
        needRestart=true;
      }
    }
    app.kill(reason,true);
    handleAppDiedLocked(app,willRestart,allowRestart);
    if (willRestart) {
      removeLruProcessLocked(app);
      addAppLocked(app.info,false,null);
    }
  }
 else {
    mRemovedProcesses.add(app);
  }
  return needRestart;
}","boolean removeProcessLocked(ProcessRecord app,boolean callerWillRestart,boolean allowRestart,String reason){
  final String name=app.processName;
  final int uid=app.uid;
  if (DEBUG_PROCESSES)   Slog.d(TAG_PROCESSES,""String_Node_Str"" + app.toShortString() + ""String_Node_Str""+ name+ ""String_Node_Str""+ uid+ ""String_Node_Str"");
  ProcessRecord old=mProcessNames.get(name,uid);
  if (old != app) {
    Slog.w(TAG,""String_Node_Str"" + app);
    return false;
  }
  removeProcessNameLocked(name,uid);
  if (mHeavyWeightProcess == app) {
    mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,mHeavyWeightProcess.userId,0));
    mHeavyWeightProcess=null;
  }
  boolean needRestart=false;
  if (app.pid > 0 && app.pid != MY_PID) {
    int pid=app.pid;
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    mBatteryStatsService.noteProcessFinish(app.processName,app.info.uid);
    if (app.isolated) {
      mBatteryStatsService.removeIsolatedUid(app.uid,app.info.uid);
    }
    boolean willRestart=false;
    if (app.persistent && !app.isolated) {
      if (!callerWillRestart) {
        willRestart=true;
      }
 else {
        needRestart=true;
      }
    }
    app.kill(reason,true);
    handleAppDiedLocked(app,willRestart,allowRestart);
    if (willRestart) {
      removeLruProcessLocked(app);
      addAppLocked(app.info,false,null);
    }
  }
 else {
    mRemovedProcesses.add(app);
  }
  return needRestart;
}",0.9546079779917468
191532,"final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          app.kill(""String_Node_Str"",false);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,true,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          addAppLocked(app.info,false,null);
        }
      }
    }
    updateOomAdjLocked();
  }
}","final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.toShortString() + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          app.kill(""String_Node_Str"",false);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,true,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          addAppLocked(app.info,false,null);
        }
      }
    }
    updateOomAdjLocked();
  }
}",0.985244040862656
191533,"boolean removeProcessLocked(ProcessRecord app,boolean callerWillRestart,boolean allowRestart,String reason){
  final String name=app.processName;
  final int uid=app.uid;
  if (DEBUG_PROCESSES)   Slog.d(TAG_PROCESSES,""String_Node_Str"" + app.toShortString() + ""String_Node_Str""+ name+ ""String_Node_Str""+ uid+ ""String_Node_Str"");
  removeProcessNameLocked(name,uid);
  if (mHeavyWeightProcess == app) {
    mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,mHeavyWeightProcess.userId,0));
    mHeavyWeightProcess=null;
  }
  boolean needRestart=false;
  if (app.pid > 0 && app.pid != MY_PID) {
    int pid=app.pid;
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    mBatteryStatsService.noteProcessFinish(app.processName,app.info.uid);
    if (app.isolated) {
      mBatteryStatsService.removeIsolatedUid(app.uid,app.info.uid);
    }
    boolean willRestart=false;
    if (app.persistent && !app.isolated) {
      if (!callerWillRestart) {
        willRestart=true;
      }
 else {
        needRestart=true;
      }
    }
    app.kill(reason,true);
    handleAppDiedLocked(app,willRestart,allowRestart);
    if (willRestart) {
      removeLruProcessLocked(app);
      addAppLocked(app.info,false,null);
    }
  }
 else {
    mRemovedProcesses.add(app);
  }
  return needRestart;
}","boolean removeProcessLocked(ProcessRecord app,boolean callerWillRestart,boolean allowRestart,String reason){
  final String name=app.processName;
  final int uid=app.uid;
  if (DEBUG_PROCESSES)   Slog.d(TAG_PROCESSES,""String_Node_Str"" + app.toShortString() + ""String_Node_Str""+ name+ ""String_Node_Str""+ uid+ ""String_Node_Str"");
  ProcessRecord old=mProcessNames.get(name,uid);
  if (old != app) {
    Slog.w(TAG,""String_Node_Str"" + app);
    return false;
  }
  removeProcessNameLocked(name,uid);
  if (mHeavyWeightProcess == app) {
    mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,mHeavyWeightProcess.userId,0));
    mHeavyWeightProcess=null;
  }
  boolean needRestart=false;
  if (app.pid > 0 && app.pid != MY_PID) {
    int pid=app.pid;
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    mBatteryStatsService.noteProcessFinish(app.processName,app.info.uid);
    if (app.isolated) {
      mBatteryStatsService.removeIsolatedUid(app.uid,app.info.uid);
    }
    boolean willRestart=false;
    if (app.persistent && !app.isolated) {
      if (!callerWillRestart) {
        willRestart=true;
      }
 else {
        needRestart=true;
      }
    }
    app.kill(reason,true);
    handleAppDiedLocked(app,willRestart,allowRestart);
    if (willRestart) {
      removeLruProcessLocked(app);
      addAppLocked(app.info,false,null);
    }
  }
 else {
    mRemovedProcesses.add(app);
  }
  return needRestart;
}",0.9546079779917468
191534,"/** 
 * NOTE: Must be called with Surface transaction open.
 */
private void adjustBounds(){
  final int dw, dh;
  final float xPos, yPos;
  if (!mUser.isFullscreen()) {
    dw=mBounds.width();
    dh=mBounds.height();
    xPos=mBounds.left;
    yPos=mBounds.top;
  }
 else {
    final DisplayInfo info=mUser.getDisplayInfo();
    dw=(int)(info.logicalWidth * 1.5);
    dh=(int)(info.logicalHeight * 1.5);
    xPos=-1 * dw / 6;
    yPos=-1 * dh / 6;
  }
  if (mDimSurface != null) {
    mDimSurface.setPosition(xPos,yPos);
    mDimSurface.setSize(dw,dh);
  }
  mLastBounds.set(mBounds);
}","/** 
 * NOTE: Must be called with Surface transaction open.
 */
private void adjustBounds(){
  if (mUser.dimFullscreen()) {
    getBoundsForFullscreen(mBounds);
  }
  if (mDimSurface != null) {
    mDimSurface.setPosition(mBounds.left,mBounds.top);
    mDimSurface.setSize(mBounds.width(),mBounds.height());
    if (DEBUG_DIM_LAYER)     Slog.v(TAG,""String_Node_Str"" + mUser.toShortString() + ""String_Node_Str""+ mBounds);
  }
  mLastBounds.set(mBounds);
}",0.4817658349328215
191535,"void startDimmingIfNeeded(DimLayer.DimLayerUser dimLayerUser,WindowStateAnimator newWinAnimator,boolean aboveApp){
  DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  state.dimAbove=aboveApp;
  if (DEBUG_DIM_LAYER)   Slog.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + dimLayerUser.toShortString() + ""String_Node_Str""+ newWinAnimator+ ""String_Node_Str""+ state.animator);
  if (newWinAnimator.getShown() && (state.animator == null || !state.animator.getShown() || state.animator.mAnimLayer <= newWinAnimator.mAnimLayer)) {
    state.animator=newWinAnimator;
    if (state.animator.mWin.mAppToken == null && !dimLayerUser.isFullscreen()) {
      mDisplayContent.getLogicalDisplayRect(mTmpBounds);
    }
 else {
      dimLayerUser.getDimBounds(mTmpBounds);
    }
    state.dimLayer.setBounds(mTmpBounds);
  }
}","void startDimmingIfNeeded(DimLayer.DimLayerUser dimLayerUser,WindowStateAnimator newWinAnimator,boolean aboveApp){
  DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  state.dimAbove=aboveApp;
  if (DEBUG_DIM_LAYER)   Slog.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + dimLayerUser.toShortString() + ""String_Node_Str""+ newWinAnimator+ ""String_Node_Str""+ state.animator);
  if (newWinAnimator.getShown() && (state.animator == null || !state.animator.getShown() || state.animator.mAnimLayer <= newWinAnimator.mAnimLayer)) {
    state.animator=newWinAnimator;
    if (state.animator.mWin.mAppToken == null && !dimLayerUser.dimFullscreen()) {
      mDisplayContent.getLogicalDisplayRect(mTmpBounds);
    }
 else {
      dimLayerUser.getDimBounds(mTmpBounds);
    }
    state.dimLayer.setBounds(mTmpBounds);
  }
}",0.9969456322541234
191536,"/** 
 * Updates the dim layer bounds, recreating it if needed. 
 */
void updateDimLayer(DimLayer.DimLayerUser dimLayerUser){
  DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  final boolean previousFullscreen=state.dimLayer != null && state.dimLayer == mSharedFullScreenDimLayer;
  DimLayer newDimLayer;
  final int displayId=mDisplayContent.getDisplayId();
  if (dimLayerUser.isFullscreen()) {
    if (previousFullscreen) {
      return;
    }
    newDimLayer=mSharedFullScreenDimLayer;
    if (newDimLayer == null) {
      if (state.dimLayer != null) {
        newDimLayer=state.dimLayer;
      }
 else {
        newDimLayer=new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser));
      }
      dimLayerUser.getDimBounds(mTmpBounds);
      newDimLayer.setBounds(mTmpBounds);
      mSharedFullScreenDimLayer=newDimLayer;
    }
 else     if (state.dimLayer != null) {
      state.dimLayer.destroySurface();
    }
  }
 else {
    newDimLayer=(state.dimLayer == null || previousFullscreen) ? new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser)) : state.dimLayer;
    dimLayerUser.getDimBounds(mTmpBounds);
    newDimLayer.setBounds(mTmpBounds);
  }
  state.dimLayer=newDimLayer;
}","/** 
 * Updates the dim layer bounds, recreating it if needed. 
 */
void updateDimLayer(DimLayer.DimLayerUser dimLayerUser){
  final DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  final boolean previousFullscreen=state.dimLayer != null && state.dimLayer == mSharedFullScreenDimLayer;
  DimLayer newDimLayer;
  final int displayId=mDisplayContent.getDisplayId();
  if (dimLayerUser.dimFullscreen()) {
    if (previousFullscreen && mSharedFullScreenDimLayer != null) {
      mSharedFullScreenDimLayer.setBoundsForFullscreen();
      return;
    }
    newDimLayer=mSharedFullScreenDimLayer;
    if (newDimLayer == null) {
      if (state.dimLayer != null) {
        newDimLayer=state.dimLayer;
      }
 else {
        newDimLayer=new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser));
      }
      dimLayerUser.getDimBounds(mTmpBounds);
      newDimLayer.setBounds(mTmpBounds);
      mSharedFullScreenDimLayer=newDimLayer;
    }
 else     if (state.dimLayer != null) {
      state.dimLayer.destroySurface();
    }
  }
 else {
    newDimLayer=(state.dimLayer == null || previousFullscreen) ? new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser)) : state.dimLayer;
    dimLayerUser.getDimBounds(mTmpBounds);
    newDimLayer.setBounds(mTmpBounds);
  }
  state.dimLayer=newDimLayer;
}",0.959726443768997
191537,"void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"");
  for (int i=0, n=mState.size(); i < n; i++) {
    pw.println(prefix + ""String_Node_Str"" + mState.keyAt(i).toShortString());
    pw.print(prefix + ""String_Node_Str"");
    DimLayerState state=mState.valueAt(i);
    pw.print(""String_Node_Str"" + (state.dimLayer == mSharedFullScreenDimLayer ? ""String_Node_Str"" : state.dimLayer));
    pw.print(""String_Node_Str"" + state.animator);
    pw.println(""String_Node_Str"" + state.continueDimming + ""String_Node_Str"");
  }
}","void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"");
  final String doubleSpace=""String_Node_Str"";
  final String prefixPlusDoubleSpace=prefix + doubleSpace;
  for (int i=0, n=mState.size(); i < n; i++) {
    pw.println(prefixPlusDoubleSpace + mState.keyAt(i).toShortString());
    DimLayerState state=mState.valueAt(i);
    pw.println(prefixPlusDoubleSpace + doubleSpace + ""String_Node_Str""+ (state.dimLayer == mSharedFullScreenDimLayer ? ""String_Node_Str"" : state.dimLayer)+ ""String_Node_Str""+ state.animator+ ""String_Node_Str""+ state.continueDimming);
    if (state.dimLayer != null) {
      state.dimLayer.printTo(prefixPlusDoubleSpace + doubleSpace,pw);
    }
  }
}",0.5108433734939759
191538,"@Override public boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}","boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}",0.9186602870813396
191539,"@Override public boolean isFullscreen(){
  return false;
}","boolean isFullscreen(){
  return false;
}",0.8282828282828283
191540,"@Override public boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}","boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}",0.9186602870813396
191541,"/** 
 * NOTE: Must be called with Surface transaction open.
 */
private void adjustBounds(){
  final int dw, dh;
  final float xPos, yPos;
  if (!mUser.isFullscreen()) {
    dw=mBounds.width();
    dh=mBounds.height();
    xPos=mBounds.left;
    yPos=mBounds.top;
  }
 else {
    final DisplayInfo info=mUser.getDisplayInfo();
    dw=(int)(info.logicalWidth * 1.5);
    dh=(int)(info.logicalHeight * 1.5);
    xPos=-1 * dw / 6;
    yPos=-1 * dh / 6;
  }
  if (mDimSurface != null) {
    mDimSurface.setPosition(xPos,yPos);
    mDimSurface.setSize(dw,dh);
  }
  mLastBounds.set(mBounds);
}","/** 
 * NOTE: Must be called with Surface transaction open.
 */
private void adjustBounds(){
  if (mUser.dimFullscreen()) {
    getBoundsForFullscreen(mBounds);
  }
  if (mDimSurface != null) {
    mDimSurface.setPosition(mBounds.left,mBounds.top);
    mDimSurface.setSize(mBounds.width(),mBounds.height());
    if (DEBUG_DIM_LAYER)     Slog.v(TAG,""String_Node_Str"" + mUser.toShortString() + ""String_Node_Str""+ mBounds);
  }
  mLastBounds.set(mBounds);
}",0.4817658349328215
191542,"void startDimmingIfNeeded(DimLayer.DimLayerUser dimLayerUser,WindowStateAnimator newWinAnimator,boolean aboveApp){
  DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  state.dimAbove=aboveApp;
  if (DEBUG_DIM_LAYER)   Slog.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + dimLayerUser.toShortString() + ""String_Node_Str""+ newWinAnimator+ ""String_Node_Str""+ state.animator);
  if (newWinAnimator.getShown() && (state.animator == null || !state.animator.getShown() || state.animator.mAnimLayer <= newWinAnimator.mAnimLayer)) {
    state.animator=newWinAnimator;
    if (state.animator.mWin.mAppToken == null && !dimLayerUser.isFullscreen()) {
      mDisplayContent.getLogicalDisplayRect(mTmpBounds);
    }
 else {
      dimLayerUser.getDimBounds(mTmpBounds);
    }
    state.dimLayer.setBounds(mTmpBounds);
  }
}","void startDimmingIfNeeded(DimLayer.DimLayerUser dimLayerUser,WindowStateAnimator newWinAnimator,boolean aboveApp){
  DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  state.dimAbove=aboveApp;
  if (DEBUG_DIM_LAYER)   Slog.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + dimLayerUser.toShortString() + ""String_Node_Str""+ newWinAnimator+ ""String_Node_Str""+ state.animator);
  if (newWinAnimator.getShown() && (state.animator == null || !state.animator.getShown() || state.animator.mAnimLayer <= newWinAnimator.mAnimLayer)) {
    state.animator=newWinAnimator;
    if (state.animator.mWin.mAppToken == null && !dimLayerUser.dimFullscreen()) {
      mDisplayContent.getLogicalDisplayRect(mTmpBounds);
    }
 else {
      dimLayerUser.getDimBounds(mTmpBounds);
    }
    state.dimLayer.setBounds(mTmpBounds);
  }
}",0.9969456322541234
191543,"/** 
 * Updates the dim layer bounds, recreating it if needed. 
 */
void updateDimLayer(DimLayer.DimLayerUser dimLayerUser){
  DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  final boolean previousFullscreen=state.dimLayer != null && state.dimLayer == mSharedFullScreenDimLayer;
  DimLayer newDimLayer;
  final int displayId=mDisplayContent.getDisplayId();
  if (dimLayerUser.isFullscreen()) {
    if (previousFullscreen) {
      return;
    }
    newDimLayer=mSharedFullScreenDimLayer;
    if (newDimLayer == null) {
      if (state.dimLayer != null) {
        newDimLayer=state.dimLayer;
      }
 else {
        newDimLayer=new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser));
      }
      dimLayerUser.getDimBounds(mTmpBounds);
      newDimLayer.setBounds(mTmpBounds);
      mSharedFullScreenDimLayer=newDimLayer;
    }
 else     if (state.dimLayer != null) {
      state.dimLayer.destroySurface();
    }
  }
 else {
    newDimLayer=(state.dimLayer == null || previousFullscreen) ? new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser)) : state.dimLayer;
    dimLayerUser.getDimBounds(mTmpBounds);
    newDimLayer.setBounds(mTmpBounds);
  }
  state.dimLayer=newDimLayer;
}","/** 
 * Updates the dim layer bounds, recreating it if needed. 
 */
void updateDimLayer(DimLayer.DimLayerUser dimLayerUser){
  final DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  final boolean previousFullscreen=state.dimLayer != null && state.dimLayer == mSharedFullScreenDimLayer;
  DimLayer newDimLayer;
  final int displayId=mDisplayContent.getDisplayId();
  if (dimLayerUser.dimFullscreen()) {
    if (previousFullscreen && mSharedFullScreenDimLayer != null) {
      mSharedFullScreenDimLayer.setBoundsForFullscreen();
      return;
    }
    newDimLayer=mSharedFullScreenDimLayer;
    if (newDimLayer == null) {
      if (state.dimLayer != null) {
        newDimLayer=state.dimLayer;
      }
 else {
        newDimLayer=new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser));
      }
      dimLayerUser.getDimBounds(mTmpBounds);
      newDimLayer.setBounds(mTmpBounds);
      mSharedFullScreenDimLayer=newDimLayer;
    }
 else     if (state.dimLayer != null) {
      state.dimLayer.destroySurface();
    }
  }
 else {
    newDimLayer=(state.dimLayer == null || previousFullscreen) ? new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser)) : state.dimLayer;
    dimLayerUser.getDimBounds(mTmpBounds);
    newDimLayer.setBounds(mTmpBounds);
  }
  state.dimLayer=newDimLayer;
}",0.959726443768997
191544,"void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"");
  for (int i=0, n=mState.size(); i < n; i++) {
    pw.println(prefix + ""String_Node_Str"" + mState.keyAt(i).toShortString());
    pw.print(prefix + ""String_Node_Str"");
    DimLayerState state=mState.valueAt(i);
    pw.print(""String_Node_Str"" + (state.dimLayer == mSharedFullScreenDimLayer ? ""String_Node_Str"" : state.dimLayer));
    pw.print(""String_Node_Str"" + state.animator);
    pw.println(""String_Node_Str"" + state.continueDimming + ""String_Node_Str"");
  }
}","void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"");
  final String doubleSpace=""String_Node_Str"";
  final String prefixPlusDoubleSpace=prefix + doubleSpace;
  for (int i=0, n=mState.size(); i < n; i++) {
    pw.println(prefixPlusDoubleSpace + mState.keyAt(i).toShortString());
    DimLayerState state=mState.valueAt(i);
    pw.println(prefixPlusDoubleSpace + doubleSpace + ""String_Node_Str""+ (state.dimLayer == mSharedFullScreenDimLayer ? ""String_Node_Str"" : state.dimLayer)+ ""String_Node_Str""+ state.animator+ ""String_Node_Str""+ state.continueDimming);
    if (state.dimLayer != null) {
      state.dimLayer.printTo(prefixPlusDoubleSpace + doubleSpace,pw);
    }
  }
}",0.5108433734939759
191545,"@Override public boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}","boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}",0.9186602870813396
191546,"@Override public boolean isFullscreen(){
  return false;
}","boolean isFullscreen(){
  return false;
}",0.8282828282828283
191547,"@Override public boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}","boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}",0.9186602870813396
191548,"/** 
 * General method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.SQL doesn't allow inserting a completely empty row without naming at least one column name.  If your provided <code>initialValues</code> is empty, no column names are known and an empty row can't be inserted. If not set to null, the <code>nullColumnHack</code> parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted rowOR the primary key of the existing row if the input param 'conflictAlgorithm' = {@link #CONFLICT_IGNORE}OR -1 if any error
 */
public long insertWithOnConflict(String table,String nullColumnHack,ContentValues initialValues,int conflictAlgorithm){
  acquireReference();
  try {
    StringBuilder sql=new StringBuilder();
    sql.append(""String_Node_Str"");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append(""String_Node_Str"");
    sql.append(table);
    sql.append('(');
    Object[] bindArgs=null;
    int size=(initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
    if (size > 0) {
      bindArgs=new Object[size];
      int i=0;
      for (      String colName : initialValues.keySet()) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
        sql.append(colName);
        bindArgs[i++]=initialValues.get(colName);
      }
      sql.append(')');
      sql.append(""String_Node_Str"");
      for (i=0; i < size; i++) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
 else {
      sql.append(nullColumnHack + ""String_Node_Str"");
    }
    sql.append(')');
    SQLiteStatement statement=new SQLiteStatement(this,sql.toString(),bindArgs);
    try {
      return statement.executeInsert();
    }
  finally {
      statement.close();
    }
  }
  finally {
    releaseReference();
  }
}","/** 
 * General method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.SQL doesn't allow inserting a completely empty row without naming at least one column name.  If your provided <code>initialValues</code> is empty, no column names are known and an empty row can't be inserted. If not set to null, the <code>nullColumnHack</code> parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row OR <code>-1</code> if either theinput parameter <code>conflictAlgorithm</code> =  {@link #CONFLICT_IGNORE}or an error occurred.
 */
public long insertWithOnConflict(String table,String nullColumnHack,ContentValues initialValues,int conflictAlgorithm){
  acquireReference();
  try {
    StringBuilder sql=new StringBuilder();
    sql.append(""String_Node_Str"");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append(""String_Node_Str"");
    sql.append(table);
    sql.append('(');
    Object[] bindArgs=null;
    int size=(initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
    if (size > 0) {
      bindArgs=new Object[size];
      int i=0;
      for (      String colName : initialValues.keySet()) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
        sql.append(colName);
        bindArgs[i++]=initialValues.get(colName);
      }
      sql.append(')');
      sql.append(""String_Node_Str"");
      for (i=0; i < size; i++) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
 else {
      sql.append(nullColumnHack + ""String_Node_Str"");
    }
    sql.append(')');
    SQLiteStatement statement=new SQLiteStatement(this,sql.toString(),bindArgs);
    try {
      return statement.executeInsert();
    }
  finally {
      statement.close();
    }
  }
  finally {
    releaseReference();
  }
}",0.9643179765130984
191549,"/** 
 * General method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.SQL doesn't allow inserting a completely empty row without naming at least one column name.  If your provided <code>initialValues</code> is empty, no column names are known and an empty row can't be inserted. If not set to null, the <code>nullColumnHack</code> parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted rowOR the primary key of the existing row if the input param 'conflictAlgorithm' = {@link #CONFLICT_IGNORE}OR -1 if any error
 */
public long insertWithOnConflict(String table,String nullColumnHack,ContentValues initialValues,int conflictAlgorithm){
  acquireReference();
  try {
    StringBuilder sql=new StringBuilder();
    sql.append(""String_Node_Str"");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append(""String_Node_Str"");
    sql.append(table);
    sql.append('(');
    Object[] bindArgs=null;
    int size=(initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
    if (size > 0) {
      bindArgs=new Object[size];
      int i=0;
      for (      String colName : initialValues.keySet()) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
        sql.append(colName);
        bindArgs[i++]=initialValues.get(colName);
      }
      sql.append(')');
      sql.append(""String_Node_Str"");
      for (i=0; i < size; i++) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
 else {
      sql.append(nullColumnHack + ""String_Node_Str"");
    }
    sql.append(')');
    SQLiteStatement statement=new SQLiteStatement(this,sql.toString(),bindArgs);
    try {
      return statement.executeInsert();
    }
  finally {
      statement.close();
    }
  }
  finally {
    releaseReference();
  }
}","/** 
 * General method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.SQL doesn't allow inserting a completely empty row without naming at least one column name.  If your provided <code>initialValues</code> is empty, no column names are known and an empty row can't be inserted. If not set to null, the <code>nullColumnHack</code> parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row OR <code>-1</code> if either theinput parameter <code>conflictAlgorithm</code> =  {@link #CONFLICT_IGNORE}or an error occurred.
 */
public long insertWithOnConflict(String table,String nullColumnHack,ContentValues initialValues,int conflictAlgorithm){
  acquireReference();
  try {
    StringBuilder sql=new StringBuilder();
    sql.append(""String_Node_Str"");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append(""String_Node_Str"");
    sql.append(table);
    sql.append('(');
    Object[] bindArgs=null;
    int size=(initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
    if (size > 0) {
      bindArgs=new Object[size];
      int i=0;
      for (      String colName : initialValues.keySet()) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
        sql.append(colName);
        bindArgs[i++]=initialValues.get(colName);
      }
      sql.append(')');
      sql.append(""String_Node_Str"");
      for (i=0; i < size; i++) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
 else {
      sql.append(nullColumnHack + ""String_Node_Str"");
    }
    sql.append(')');
    SQLiteStatement statement=new SQLiteStatement(this,sql.toString(),bindArgs);
    try {
      return statement.executeInsert();
    }
  finally {
      statement.close();
    }
  }
  finally {
    releaseReference();
  }
}",0.9643179765130984
191550,"/** 
 * NOTE: Must be called with Surface transaction open.
 */
private void adjustBounds(){
  final int dw, dh;
  final float xPos, yPos;
  if (!mUser.isFullscreen()) {
    dw=mBounds.width();
    dh=mBounds.height();
    xPos=mBounds.left;
    yPos=mBounds.top;
  }
 else {
    final DisplayInfo info=mUser.getDisplayInfo();
    dw=(int)(info.logicalWidth * 1.5);
    dh=(int)(info.logicalHeight * 1.5);
    xPos=-1 * dw / 6;
    yPos=-1 * dh / 6;
  }
  if (mDimSurface != null) {
    mDimSurface.setPosition(xPos,yPos);
    mDimSurface.setSize(dw,dh);
  }
  mLastBounds.set(mBounds);
}","/** 
 * NOTE: Must be called with Surface transaction open.
 */
private void adjustBounds(){
  if (mUser.dimFullscreen()) {
    getBoundsForFullscreen(mBounds);
  }
  if (mDimSurface != null) {
    mDimSurface.setPosition(mBounds.left,mBounds.top);
    mDimSurface.setSize(mBounds.width(),mBounds.height());
    if (DEBUG_DIM_LAYER)     Slog.v(TAG,""String_Node_Str"" + mUser.toShortString() + ""String_Node_Str""+ mBounds);
  }
  mLastBounds.set(mBounds);
}",0.4817658349328215
191551,"void startDimmingIfNeeded(DimLayer.DimLayerUser dimLayerUser,WindowStateAnimator newWinAnimator,boolean aboveApp){
  DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  state.dimAbove=aboveApp;
  if (DEBUG_DIM_LAYER)   Slog.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + dimLayerUser.toShortString() + ""String_Node_Str""+ newWinAnimator+ ""String_Node_Str""+ state.animator);
  if (newWinAnimator.getShown() && (state.animator == null || !state.animator.getShown() || state.animator.mAnimLayer <= newWinAnimator.mAnimLayer)) {
    state.animator=newWinAnimator;
    if (state.animator.mWin.mAppToken == null && !dimLayerUser.isFullscreen()) {
      mDisplayContent.getLogicalDisplayRect(mTmpBounds);
    }
 else {
      dimLayerUser.getDimBounds(mTmpBounds);
    }
    state.dimLayer.setBounds(mTmpBounds);
  }
}","void startDimmingIfNeeded(DimLayer.DimLayerUser dimLayerUser,WindowStateAnimator newWinAnimator,boolean aboveApp){
  DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  state.dimAbove=aboveApp;
  if (DEBUG_DIM_LAYER)   Slog.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + dimLayerUser.toShortString() + ""String_Node_Str""+ newWinAnimator+ ""String_Node_Str""+ state.animator);
  if (newWinAnimator.getShown() && (state.animator == null || !state.animator.getShown() || state.animator.mAnimLayer <= newWinAnimator.mAnimLayer)) {
    state.animator=newWinAnimator;
    if (state.animator.mWin.mAppToken == null && !dimLayerUser.dimFullscreen()) {
      mDisplayContent.getLogicalDisplayRect(mTmpBounds);
    }
 else {
      dimLayerUser.getDimBounds(mTmpBounds);
    }
    state.dimLayer.setBounds(mTmpBounds);
  }
}",0.9969456322541234
191552,"/** 
 * Updates the dim layer bounds, recreating it if needed. 
 */
void updateDimLayer(DimLayer.DimLayerUser dimLayerUser){
  DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  final boolean previousFullscreen=state.dimLayer != null && state.dimLayer == mSharedFullScreenDimLayer;
  DimLayer newDimLayer;
  final int displayId=mDisplayContent.getDisplayId();
  if (dimLayerUser.isFullscreen()) {
    if (previousFullscreen) {
      return;
    }
    newDimLayer=mSharedFullScreenDimLayer;
    if (newDimLayer == null) {
      if (state.dimLayer != null) {
        newDimLayer=state.dimLayer;
      }
 else {
        newDimLayer=new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser));
      }
      dimLayerUser.getDimBounds(mTmpBounds);
      newDimLayer.setBounds(mTmpBounds);
      mSharedFullScreenDimLayer=newDimLayer;
    }
 else     if (state.dimLayer != null) {
      state.dimLayer.destroySurface();
    }
  }
 else {
    newDimLayer=(state.dimLayer == null || previousFullscreen) ? new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser)) : state.dimLayer;
    dimLayerUser.getDimBounds(mTmpBounds);
    newDimLayer.setBounds(mTmpBounds);
  }
  state.dimLayer=newDimLayer;
}","/** 
 * Updates the dim layer bounds, recreating it if needed. 
 */
void updateDimLayer(DimLayer.DimLayerUser dimLayerUser){
  final DimLayerState state=getOrCreateDimLayerState(dimLayerUser);
  final boolean previousFullscreen=state.dimLayer != null && state.dimLayer == mSharedFullScreenDimLayer;
  DimLayer newDimLayer;
  final int displayId=mDisplayContent.getDisplayId();
  if (dimLayerUser.dimFullscreen()) {
    if (previousFullscreen && mSharedFullScreenDimLayer != null) {
      mSharedFullScreenDimLayer.setBoundsForFullscreen();
      return;
    }
    newDimLayer=mSharedFullScreenDimLayer;
    if (newDimLayer == null) {
      if (state.dimLayer != null) {
        newDimLayer=state.dimLayer;
      }
 else {
        newDimLayer=new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser));
      }
      dimLayerUser.getDimBounds(mTmpBounds);
      newDimLayer.setBounds(mTmpBounds);
      mSharedFullScreenDimLayer=newDimLayer;
    }
 else     if (state.dimLayer != null) {
      state.dimLayer.destroySurface();
    }
  }
 else {
    newDimLayer=(state.dimLayer == null || previousFullscreen) ? new DimLayer(mDisplayContent.mService,dimLayerUser,displayId,getDimLayerTag(dimLayerUser)) : state.dimLayer;
    dimLayerUser.getDimBounds(mTmpBounds);
    newDimLayer.setBounds(mTmpBounds);
  }
  state.dimLayer=newDimLayer;
}",0.959726443768997
191553,"void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"");
  for (int i=0, n=mState.size(); i < n; i++) {
    pw.println(prefix + ""String_Node_Str"" + mState.keyAt(i).toShortString());
    pw.print(prefix + ""String_Node_Str"");
    DimLayerState state=mState.valueAt(i);
    pw.print(""String_Node_Str"" + (state.dimLayer == mSharedFullScreenDimLayer ? ""String_Node_Str"" : state.dimLayer));
    pw.print(""String_Node_Str"" + state.animator);
    pw.println(""String_Node_Str"" + state.continueDimming + ""String_Node_Str"");
  }
}","void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"");
  final String doubleSpace=""String_Node_Str"";
  final String prefixPlusDoubleSpace=prefix + doubleSpace;
  for (int i=0, n=mState.size(); i < n; i++) {
    pw.println(prefixPlusDoubleSpace + mState.keyAt(i).toShortString());
    DimLayerState state=mState.valueAt(i);
    pw.println(prefixPlusDoubleSpace + doubleSpace + ""String_Node_Str""+ (state.dimLayer == mSharedFullScreenDimLayer ? ""String_Node_Str"" : state.dimLayer)+ ""String_Node_Str""+ state.animator+ ""String_Node_Str""+ state.continueDimming);
    if (state.dimLayer != null) {
      state.dimLayer.printTo(prefixPlusDoubleSpace + doubleSpace,pw);
    }
  }
}",0.5108433734939759
191554,"@Override public boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}","boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}",0.9186602870813396
191555,"@Override public boolean isFullscreen(){
  return false;
}","boolean isFullscreen(){
  return false;
}",0.8282828282828283
191556,"@Override public boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}","boolean isFullscreen(){
  if (useCurrentBounds()) {
    return mFullscreen;
  }
  return true;
}",0.9186602870813396
191557,"/** 
 * Reloads the stack views upon launching Recents.
 */
private void reloadStackView(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan loadPlan=RecentsImpl.consumeInstanceLoadPlan();
  if (loadPlan == null) {
    loadPlan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!loadPlan.hasTasks()) {
    loader.preloadTasks(loadPlan,launchState.launchedToTaskId,launchState.launchedFromHome);
  }
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=launchState.launchedNumVisibleTasks;
  loadOpts.numVisibleTaskThumbnails=launchState.launchedNumVisibleThumbnails;
  loader.loadTasks(this,loadPlan,loadOpts);
  TaskStack stack=loadPlan.getTaskStack();
  mRecentsView.onReload(mIsVisible,stack.getTaskCount() == 0);
  mRecentsView.updateStack(stack,true);
  boolean animateNavBarScrim=!launchState.launchedViaDockGesture;
  mScrimViews.updateNavBarScrim(animateNavBarScrim,stack.getTaskCount() > 0,null);
  boolean wasLaunchedByAm=!launchState.launchedFromHome && !launchState.launchedFromApp;
  if (wasLaunchedByAm) {
    EventBus.getDefault().send(new EnterRecentsWindowAnimationCompletedEvent());
  }
  if (launchState.launchedWithAltTab) {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  if (launchState.launchedFromApp) {
    Task launchTarget=stack.getLaunchTarget();
    int launchTaskIndexInStack=launchTarget != null ? stack.indexOfStackTask(launchTarget) : 0;
    MetricsLogger.count(this,""String_Node_Str"",1);
    MetricsLogger.histogram(this,""String_Node_Str"",launchTaskIndexInStack);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  int taskCount=mRecentsView.getStack().getTaskCount();
  MetricsLogger.histogram(this,""String_Node_Str"",taskCount);
  mIsVisible=true;
}","/** 
 * Reloads the stack views upon launching Recents.
 */
private void reloadStackView(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan loadPlan=RecentsImpl.consumeInstanceLoadPlan();
  if (loadPlan == null) {
    loadPlan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!loadPlan.hasTasks()) {
    loader.preloadTasks(loadPlan,launchState.launchedToTaskId,!launchState.launchedFromHome);
  }
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=launchState.launchedNumVisibleTasks;
  loadOpts.numVisibleTaskThumbnails=launchState.launchedNumVisibleThumbnails;
  loader.loadTasks(this,loadPlan,loadOpts);
  TaskStack stack=loadPlan.getTaskStack();
  mRecentsView.onReload(mIsVisible,stack.getTaskCount() == 0);
  mRecentsView.updateStack(stack,true);
  boolean animateNavBarScrim=!launchState.launchedViaDockGesture;
  mScrimViews.updateNavBarScrim(animateNavBarScrim,stack.getTaskCount() > 0,null);
  boolean wasLaunchedByAm=!launchState.launchedFromHome && !launchState.launchedFromApp;
  if (wasLaunchedByAm) {
    EventBus.getDefault().send(new EnterRecentsWindowAnimationCompletedEvent());
  }
  if (launchState.launchedWithAltTab) {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  if (launchState.launchedFromApp) {
    Task launchTarget=stack.getLaunchTarget();
    int launchTaskIndexInStack=launchTarget != null ? stack.indexOfStackTask(launchTarget) : 0;
    MetricsLogger.count(this,""String_Node_Str"",1);
    MetricsLogger.histogram(this,""String_Node_Str"",launchTaskIndexInStack);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  int taskCount=mRecentsView.getStack().getTaskCount();
  MetricsLogger.histogram(this,""String_Node_Str"",taskCount);
  mIsVisible=true;
}",0.9997519225998512
191558,"/** 
 * Transitions to the next affiliated task.
 */
public void showRelativeAffiliatedTask(boolean showNextTask){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,true);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  if (SystemServicesProxy.isHomeStack(runningTask.stackId))   return;
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  int numAffiliatedTasks=0;
  for (int i=0; i < taskCount; i++) {
    Task task=tasks.get(i);
    if (task.key.id == runningTask.id) {
      TaskGrouping group=task.group;
      Task.TaskKey toTaskKey;
      if (showNextTask) {
        toTaskKey=group.getNextTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_launch_next_affiliated_task_source);
      }
 else {
        toTaskKey=group.getPrevTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      }
      if (toTaskKey != null) {
        toTask=focusedStack.findTaskWithId(toTaskKey.id);
      }
      numAffiliatedTasks=group.getTaskCount();
      break;
    }
  }
  if (toTask == null) {
    if (numAffiliatedTasks > 1) {
      if (showNextTask) {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_next_affiliated_task_bounce));
      }
 else {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
      }
    }
    return;
  }
  MetricsLogger.count(mContext,""String_Node_Str"",1);
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}","/** 
 * Transitions to the next affiliated task.
 */
public void showRelativeAffiliatedTask(boolean showNextTask){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,false);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  if (SystemServicesProxy.isHomeStack(runningTask.stackId))   return;
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  int numAffiliatedTasks=0;
  for (int i=0; i < taskCount; i++) {
    Task task=tasks.get(i);
    if (task.key.id == runningTask.id) {
      TaskGrouping group=task.group;
      Task.TaskKey toTaskKey;
      if (showNextTask) {
        toTaskKey=group.getNextTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_launch_next_affiliated_task_source);
      }
 else {
        toTaskKey=group.getPrevTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      }
      if (toTaskKey != null) {
        toTask=focusedStack.findTaskWithId(toTaskKey.id);
      }
      numAffiliatedTasks=group.getTaskCount();
      break;
    }
  }
  if (toTask == null) {
    if (numAffiliatedTasks > 1) {
      if (showNextTask) {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_next_affiliated_task_bounce));
      }
 else {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
      }
    }
    return;
  }
  MetricsLogger.count(mContext,""String_Node_Str"",1);
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}",0.9984
191559,"public void preloadRecents(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  MutableBoolean isHomeStackVisible=new MutableBoolean(true);
  if (!ssp.isRecentsActivityVisible(isHomeStackVisible)) {
    ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
    RecentsTaskLoader loader=Recents.getTaskLoader();
    sInstanceLoadPlan=loader.createLoadPlan(mContext);
    sInstanceLoadPlan.preloadRawTasks(isHomeStackVisible.value);
    loader.preloadTasks(sInstanceLoadPlan,runningTask.id,isHomeStackVisible.value);
    TaskStack stack=sInstanceLoadPlan.getTaskStack();
    if (stack.getTaskCount() > 0) {
      preloadIcon(runningTask);
      updateHeaderBarLayout(stack,null);
    }
  }
}","public void preloadRecents(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  MutableBoolean isHomeStackVisible=new MutableBoolean(true);
  if (!ssp.isRecentsActivityVisible(isHomeStackVisible)) {
    ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
    RecentsTaskLoader loader=Recents.getTaskLoader();
    sInstanceLoadPlan=loader.createLoadPlan(mContext);
    sInstanceLoadPlan.preloadRawTasks(!isHomeStackVisible.value);
    loader.preloadTasks(sInstanceLoadPlan,runningTask.id,!isHomeStackVisible.value);
    TaskStack stack=sInstanceLoadPlan.getTaskStack();
    if (stack.getTaskCount() > 0) {
      preloadIcon(runningTask);
      updateHeaderBarLayout(stack,null);
    }
  }
}",0.998589562764457
191560,"public RecentsImpl(Context context){
  mContext=context;
  mHandler=new Handler();
  ForegroundThread.get();
  mTaskStackListener=new TaskStackListenerImpl();
  SystemServicesProxy ssp=Recents.getSystemServices();
  ssp.registerTaskStackListener(mTaskStackListener);
  LayoutInflater inflater=LayoutInflater.from(mContext);
  mDummyStackView=new TaskStackView(mContext);
  mHeaderBar=(TaskViewHeader)inflater.inflate(R.layout.recents_task_view_header,null,false);
  reloadResources();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,true);
  RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
  launchOpts.numVisibleTasks=loader.getIconCacheSize();
  launchOpts.numVisibleTaskThumbnails=loader.getThumbnailCacheSize();
  launchOpts.onlyLoadForCache=true;
  loader.loadTasks(mContext,plan,launchOpts);
}","public RecentsImpl(Context context){
  mContext=context;
  mHandler=new Handler();
  ForegroundThread.get();
  mTaskStackListener=new TaskStackListenerImpl();
  SystemServicesProxy ssp=Recents.getSystemServices();
  ssp.registerTaskStackListener(mTaskStackListener);
  LayoutInflater inflater=LayoutInflater.from(mContext);
  mDummyStackView=new TaskStackView(mContext);
  mHeaderBar=(TaskViewHeader)inflater.inflate(R.layout.recents_task_view_header,null,false);
  reloadResources();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,false);
  RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
  launchOpts.numVisibleTasks=loader.getIconCacheSize();
  launchOpts.numVisibleTaskThumbnails=loader.getThumbnailCacheSize();
  launchOpts.onlyLoadForCache=true;
  loader.loadTasks(mContext,plan,launchOpts);
}",0.9961935834692768
191561,"/** 
 * Transitions to the next recent task in the stack.
 */
public void showNextTask(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,true);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  boolean isRunningTaskInHomeStack=SystemServicesProxy.isHomeStack(runningTask.stackId);
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  for (int i=taskCount - 1; i >= 1; i--) {
    Task task=tasks.get(i);
    if (isRunningTaskInHomeStack) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_fast_toggle_app_home_exit);
      break;
    }
 else     if (task.key.id == runningTask.id) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      break;
    }
  }
  if (toTask == null) {
    ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
    return;
  }
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}","/** 
 * Transitions to the next recent task in the stack.
 */
public void showNextTask(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,false);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  boolean isRunningTaskInHomeStack=SystemServicesProxy.isHomeStack(runningTask.stackId);
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  for (int i=taskCount - 1; i >= 1; i--) {
    Task task=tasks.get(i);
    if (isRunningTaskInHomeStack) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_fast_toggle_app_home_exit);
      break;
    }
 else     if (task.key.id == runningTask.id) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      break;
    }
  }
  if (toTask == null) {
    ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
    return;
  }
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}",0.9978118161925602
191562,"@Override public void onTaskStackChanged(){
  RecentsConfiguration config=Recents.getConfiguration();
  if (config.svelteLevel == RecentsConfiguration.SVELTE_NONE) {
    RecentsTaskLoader loader=Recents.getTaskLoader();
    SystemServicesProxy ssp=Recents.getSystemServices();
    ActivityManager.RunningTaskInfo runningTaskInfo=ssp.getRunningTask();
    RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
    loader.preloadTasks(plan,-1,true);
    RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
    if (runningTaskInfo != null) {
      launchOpts.runningTaskId=runningTaskInfo.id;
    }
    launchOpts.numVisibleTasks=2;
    launchOpts.numVisibleTaskThumbnails=2;
    launchOpts.onlyLoadForCache=true;
    launchOpts.onlyLoadPausedActivities=true;
    loader.loadTasks(mContext,plan,launchOpts);
  }
}","@Override public void onTaskStackChanged(){
  RecentsConfiguration config=Recents.getConfiguration();
  if (config.svelteLevel == RecentsConfiguration.SVELTE_NONE) {
    RecentsTaskLoader loader=Recents.getTaskLoader();
    SystemServicesProxy ssp=Recents.getSystemServices();
    ActivityManager.RunningTaskInfo runningTaskInfo=ssp.getRunningTask();
    RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
    loader.preloadTasks(plan,-1,false);
    RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
    if (runningTaskInfo != null) {
      launchOpts.runningTaskId=runningTaskInfo.id;
    }
    launchOpts.numVisibleTasks=2;
    launchOpts.numVisibleTaskThumbnails=2;
    launchOpts.onlyLoadForCache=true;
    launchOpts.onlyLoadPausedActivities=true;
    loader.loadTasks(mContext,plan,launchOpts);
  }
}",0.99581589958159
191563,"/** 
 * Returns a list of the recents tasks.
 * @param isHomeStackVisible whether or not the home stack is currently visible.  If it isvisible, then we ignore all excluded tasks (even the first one).
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean isHomeStackVisible,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=i;
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  List<ActivityManager.RecentTaskInfo> tasks=mAm.getRecentTasksForUser(numTasksToQuery,ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES| ActivityManager.RECENT_WITH_EXCLUDED,userId);
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    boolean isBlackListed=sRecentsBlacklist.contains(t.realActivity.getClassName());
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isBlackListed || (isExcluded && (isHomeStackVisible || !isFirstValidTask))) {
      iter.remove();
      continue;
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}","/** 
 * Returns a list of the recents tasks.
 * @param includeFrontMostExcludedTask if set, will ensure that the front most excluded taskwill be visible, otherwise no excluded tasks will be visible.
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean includeFrontMostExcludedTask,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=i;
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  int flags=ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES;
  if (includeFrontMostExcludedTask) {
    flags|=ActivityManager.RECENT_WITH_EXCLUDED;
  }
  List<ActivityManager.RecentTaskInfo> tasks=mAm.getRecentTasksForUser(numTasksToQuery,flags,userId);
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    if (sRecentsBlacklist.contains(t.realActivity.getClassName())) {
      iter.remove();
    }
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isExcluded && (!isFirstValidTask || !includeFrontMostExcludedTask)) {
      iter.remove();
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}",0.8510786360473208
191564,"/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean isHomeStackVisible){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(isHomeStackVisible);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  long lastStackActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    lastStackActiveTime=0;
  }
  long newLastStackActiveTime=-1;
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=SystemServicesProxy.isFreeformStack(t.stackId);
    boolean isStackTask=isFreeformTask || !isHistoricalTask(t) || (t.lastActiveTime >= lastStackActiveTime && i >= (taskCount - MIN_NUM_TASKS));
    boolean isLaunchTarget=taskKey.id == runningTaskId;
    if (isStackTask && newLastStackActiveTime < 0) {
      newLastStackActiveTime=t.lastActiveTime;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (newLastStackActiveTime != -1) {
    Prefs.putLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,newLastStackActiveTime);
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}","/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean includeFrontMostExcludedTask){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(includeFrontMostExcludedTask);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  long lastStackActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    lastStackActiveTime=0;
  }
  long newLastStackActiveTime=-1;
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=SystemServicesProxy.isFreeformStack(t.stackId);
    boolean isStackTask=isFreeformTask || !isHistoricalTask(t) || (t.lastActiveTime >= lastStackActiveTime && i >= (taskCount - MIN_NUM_TASKS));
    boolean isLaunchTarget=taskKey.id == runningTaskId;
    if (isStackTask && newLastStackActiveTime < 0) {
      newLastStackActiveTime=t.lastActiveTime;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (newLastStackActiveTime != -1) {
    Prefs.putLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,newLastStackActiveTime);
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}",0.9865894544346236
191565,"/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean isHomeStackVisible){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  SystemServicesProxy ssp=Recents.getSystemServices();
  mRawTasks=ssp.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,isHomeStackVisible,mCurrentQuietProfiles);
  Collections.reverse(mRawTasks);
}","/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean includeFrontMostExcludedTask){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  SystemServicesProxy ssp=Recents.getSystemServices();
  mRawTasks=ssp.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,includeFrontMostExcludedTask,mCurrentQuietProfiles);
  Collections.reverse(mRawTasks);
}",0.9152215799614644
191566,"/** 
 * Preloads recents tasks using the specified plan to store the output. 
 */
public void preloadTasks(RecentsTaskLoadPlan plan,int runningTaskId,boolean isHomeStackVisible){
  plan.preloadPlan(this,runningTaskId,isHomeStackVisible);
}","/** 
 * Preloads recents tasks using the specified plan to store the output. 
 */
public void preloadTasks(RecentsTaskLoadPlan plan,int runningTaskId,boolean includeFrontMostExcludedTask){
  plan.preloadPlan(this,runningTaskId,includeFrontMostExcludedTask);
}",0.8232931726907631
191567,"private void updateRecentsTasks(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=RecentsImpl.consumeInstanceLoadPlan();
  if (plan == null) {
    plan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!plan.hasTasks()) {
    loader.preloadTasks(plan,-1,launchState.launchedFromHome);
  }
  mLaunchedFromHome=launchState.launchedFromHome;
  TaskStack stack=plan.getTaskStack();
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=stack.getStackTaskCount();
  loadOpts.numVisibleTaskThumbnails=stack.getStackTaskCount();
  loader.loadTasks(this,plan,loadOpts);
  mRecentsView.setTaskStack(stack);
  List stackTasks=stack.getStackTasks();
  Collections.reverse(stackTasks);
  if (mTaskStackViewAdapter == null) {
    mTaskStackViewAdapter=new TaskStackHorizontalViewAdapter(stackTasks);
    mTaskStackHorizontalGridView=mRecentsView.setTaskStackViewAdapter(mTaskStackViewAdapter);
  }
 else {
    mTaskStackViewAdapter.setNewStackTasks(stackTasks);
  }
  if (launchState.launchedToTaskId != -1) {
    ArrayList<Task> tasks=stack.getStackTasks();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      Task t=tasks.get(i);
      if (t.key.id == launchState.launchedToTaskId) {
        t.isLaunchTarget=true;
        break;
      }
    }
  }
}","private void updateRecentsTasks(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=RecentsImpl.consumeInstanceLoadPlan();
  if (plan == null) {
    plan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!plan.hasTasks()) {
    loader.preloadTasks(plan,-1,!launchState.launchedFromHome);
  }
  mLaunchedFromHome=launchState.launchedFromHome;
  TaskStack stack=plan.getTaskStack();
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=stack.getStackTaskCount();
  loadOpts.numVisibleTaskThumbnails=stack.getStackTaskCount();
  loader.loadTasks(this,plan,loadOpts);
  mRecentsView.setTaskStack(stack);
  List stackTasks=stack.getStackTasks();
  Collections.reverse(stackTasks);
  if (mTaskStackViewAdapter == null) {
    mTaskStackViewAdapter=new TaskStackHorizontalViewAdapter(stackTasks);
    mTaskStackHorizontalGridView=mRecentsView.setTaskStackViewAdapter(mTaskStackViewAdapter);
  }
 else {
    mTaskStackViewAdapter.setNewStackTasks(stackTasks);
  }
  if (launchState.launchedToTaskId != -1) {
    ArrayList<Task> tasks=stack.getStackTasks();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      Task t=tasks.get(i);
      if (t.key.id == launchState.launchedToTaskId) {
        t.isLaunchTarget=true;
        break;
      }
    }
  }
}",0.9996692027786966
191568,"/** 
 * General method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.SQL doesn't allow inserting a completely empty row without naming at least one column name.  If your provided <code>initialValues</code> is empty, no column names are known and an empty row can't be inserted. If not set to null, the <code>nullColumnHack</code> parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted rowOR the primary key of the existing row if the input param 'conflictAlgorithm' = {@link #CONFLICT_IGNORE}OR -1 if any error
 */
public long insertWithOnConflict(String table,String nullColumnHack,ContentValues initialValues,int conflictAlgorithm){
  acquireReference();
  try {
    StringBuilder sql=new StringBuilder();
    sql.append(""String_Node_Str"");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append(""String_Node_Str"");
    sql.append(table);
    sql.append('(');
    Object[] bindArgs=null;
    int size=(initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
    if (size > 0) {
      bindArgs=new Object[size];
      int i=0;
      for (      String colName : initialValues.keySet()) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
        sql.append(colName);
        bindArgs[i++]=initialValues.get(colName);
      }
      sql.append(')');
      sql.append(""String_Node_Str"");
      for (i=0; i < size; i++) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
 else {
      sql.append(nullColumnHack + ""String_Node_Str"");
    }
    sql.append(')');
    SQLiteStatement statement=new SQLiteStatement(this,sql.toString(),bindArgs);
    try {
      return statement.executeInsert();
    }
  finally {
      statement.close();
    }
  }
  finally {
    releaseReference();
  }
}","/** 
 * General method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.SQL doesn't allow inserting a completely empty row without naming at least one column name.  If your provided <code>initialValues</code> is empty, no column names are known and an empty row can't be inserted. If not set to null, the <code>nullColumnHack</code> parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row OR <code>-1</code> if either theinput parameter <code>conflictAlgorithm</code> =  {@link #CONFLICT_IGNORE}or an error occurred.
 */
public long insertWithOnConflict(String table,String nullColumnHack,ContentValues initialValues,int conflictAlgorithm){
  acquireReference();
  try {
    StringBuilder sql=new StringBuilder();
    sql.append(""String_Node_Str"");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append(""String_Node_Str"");
    sql.append(table);
    sql.append('(');
    Object[] bindArgs=null;
    int size=(initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
    if (size > 0) {
      bindArgs=new Object[size];
      int i=0;
      for (      String colName : initialValues.keySet()) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
        sql.append(colName);
        bindArgs[i++]=initialValues.get(colName);
      }
      sql.append(')');
      sql.append(""String_Node_Str"");
      for (i=0; i < size; i++) {
        sql.append((i > 0) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
 else {
      sql.append(nullColumnHack + ""String_Node_Str"");
    }
    sql.append(')');
    SQLiteStatement statement=new SQLiteStatement(this,sql.toString(),bindArgs);
    try {
      return statement.executeInsert();
    }
  finally {
      statement.close();
    }
  }
  finally {
    releaseReference();
  }
}",0.9643179765130984
191569,"/** 
 * Reloads the stack views upon launching Recents.
 */
private void reloadStackView(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan loadPlan=RecentsImpl.consumeInstanceLoadPlan();
  if (loadPlan == null) {
    loadPlan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!loadPlan.hasTasks()) {
    loader.preloadTasks(loadPlan,launchState.launchedToTaskId,launchState.launchedFromHome);
  }
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=launchState.launchedNumVisibleTasks;
  loadOpts.numVisibleTaskThumbnails=launchState.launchedNumVisibleThumbnails;
  loader.loadTasks(this,loadPlan,loadOpts);
  TaskStack stack=loadPlan.getTaskStack();
  mRecentsView.onReload(mIsVisible,stack.getTaskCount() == 0);
  mRecentsView.updateStack(stack,true);
  boolean animateNavBarScrim=!launchState.launchedViaDockGesture;
  mScrimViews.updateNavBarScrim(animateNavBarScrim,stack.getTaskCount() > 0,null);
  boolean wasLaunchedByAm=!launchState.launchedFromHome && !launchState.launchedFromApp;
  if (wasLaunchedByAm) {
    EventBus.getDefault().send(new EnterRecentsWindowAnimationCompletedEvent());
  }
  if (launchState.launchedWithAltTab) {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  if (launchState.launchedFromApp) {
    Task launchTarget=stack.getLaunchTarget();
    int launchTaskIndexInStack=launchTarget != null ? stack.indexOfStackTask(launchTarget) : 0;
    MetricsLogger.count(this,""String_Node_Str"",1);
    MetricsLogger.histogram(this,""String_Node_Str"",launchTaskIndexInStack);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  int taskCount=mRecentsView.getStack().getTaskCount();
  MetricsLogger.histogram(this,""String_Node_Str"",taskCount);
  mIsVisible=true;
}","/** 
 * Reloads the stack views upon launching Recents.
 */
private void reloadStackView(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan loadPlan=RecentsImpl.consumeInstanceLoadPlan();
  if (loadPlan == null) {
    loadPlan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!loadPlan.hasTasks()) {
    loader.preloadTasks(loadPlan,launchState.launchedToTaskId,!launchState.launchedFromHome);
  }
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=launchState.launchedNumVisibleTasks;
  loadOpts.numVisibleTaskThumbnails=launchState.launchedNumVisibleThumbnails;
  loader.loadTasks(this,loadPlan,loadOpts);
  TaskStack stack=loadPlan.getTaskStack();
  mRecentsView.onReload(mIsVisible,stack.getTaskCount() == 0);
  mRecentsView.updateStack(stack,true);
  boolean animateNavBarScrim=!launchState.launchedViaDockGesture;
  mScrimViews.updateNavBarScrim(animateNavBarScrim,stack.getTaskCount() > 0,null);
  boolean wasLaunchedByAm=!launchState.launchedFromHome && !launchState.launchedFromApp;
  if (wasLaunchedByAm) {
    EventBus.getDefault().send(new EnterRecentsWindowAnimationCompletedEvent());
  }
  if (launchState.launchedWithAltTab) {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  if (launchState.launchedFromApp) {
    Task launchTarget=stack.getLaunchTarget();
    int launchTaskIndexInStack=launchTarget != null ? stack.indexOfStackTask(launchTarget) : 0;
    MetricsLogger.count(this,""String_Node_Str"",1);
    MetricsLogger.histogram(this,""String_Node_Str"",launchTaskIndexInStack);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  int taskCount=mRecentsView.getStack().getTaskCount();
  MetricsLogger.histogram(this,""String_Node_Str"",taskCount);
  mIsVisible=true;
}",0.9997519225998512
191570,"/** 
 * Transitions to the next affiliated task.
 */
public void showRelativeAffiliatedTask(boolean showNextTask){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,true);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  if (SystemServicesProxy.isHomeStack(runningTask.stackId))   return;
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  int numAffiliatedTasks=0;
  for (int i=0; i < taskCount; i++) {
    Task task=tasks.get(i);
    if (task.key.id == runningTask.id) {
      TaskGrouping group=task.group;
      Task.TaskKey toTaskKey;
      if (showNextTask) {
        toTaskKey=group.getNextTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_launch_next_affiliated_task_source);
      }
 else {
        toTaskKey=group.getPrevTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      }
      if (toTaskKey != null) {
        toTask=focusedStack.findTaskWithId(toTaskKey.id);
      }
      numAffiliatedTasks=group.getTaskCount();
      break;
    }
  }
  if (toTask == null) {
    if (numAffiliatedTasks > 1) {
      if (showNextTask) {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_next_affiliated_task_bounce));
      }
 else {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
      }
    }
    return;
  }
  MetricsLogger.count(mContext,""String_Node_Str"",1);
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}","/** 
 * Transitions to the next affiliated task.
 */
public void showRelativeAffiliatedTask(boolean showNextTask){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,false);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  if (SystemServicesProxy.isHomeStack(runningTask.stackId))   return;
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  int numAffiliatedTasks=0;
  for (int i=0; i < taskCount; i++) {
    Task task=tasks.get(i);
    if (task.key.id == runningTask.id) {
      TaskGrouping group=task.group;
      Task.TaskKey toTaskKey;
      if (showNextTask) {
        toTaskKey=group.getNextTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_launch_next_affiliated_task_source);
      }
 else {
        toTaskKey=group.getPrevTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      }
      if (toTaskKey != null) {
        toTask=focusedStack.findTaskWithId(toTaskKey.id);
      }
      numAffiliatedTasks=group.getTaskCount();
      break;
    }
  }
  if (toTask == null) {
    if (numAffiliatedTasks > 1) {
      if (showNextTask) {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_next_affiliated_task_bounce));
      }
 else {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
      }
    }
    return;
  }
  MetricsLogger.count(mContext,""String_Node_Str"",1);
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}",0.9984
191571,"public void preloadRecents(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  MutableBoolean isHomeStackVisible=new MutableBoolean(true);
  if (!ssp.isRecentsActivityVisible(isHomeStackVisible)) {
    ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
    RecentsTaskLoader loader=Recents.getTaskLoader();
    sInstanceLoadPlan=loader.createLoadPlan(mContext);
    sInstanceLoadPlan.preloadRawTasks(isHomeStackVisible.value);
    loader.preloadTasks(sInstanceLoadPlan,runningTask.id,isHomeStackVisible.value);
    TaskStack stack=sInstanceLoadPlan.getTaskStack();
    if (stack.getTaskCount() > 0) {
      preloadIcon(runningTask);
      updateHeaderBarLayout(stack,null);
    }
  }
}","public void preloadRecents(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  MutableBoolean isHomeStackVisible=new MutableBoolean(true);
  if (!ssp.isRecentsActivityVisible(isHomeStackVisible)) {
    ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
    RecentsTaskLoader loader=Recents.getTaskLoader();
    sInstanceLoadPlan=loader.createLoadPlan(mContext);
    sInstanceLoadPlan.preloadRawTasks(!isHomeStackVisible.value);
    loader.preloadTasks(sInstanceLoadPlan,runningTask.id,!isHomeStackVisible.value);
    TaskStack stack=sInstanceLoadPlan.getTaskStack();
    if (stack.getTaskCount() > 0) {
      preloadIcon(runningTask);
      updateHeaderBarLayout(stack,null);
    }
  }
}",0.998589562764457
191572,"public RecentsImpl(Context context){
  mContext=context;
  mHandler=new Handler();
  ForegroundThread.get();
  mTaskStackListener=new TaskStackListenerImpl();
  SystemServicesProxy ssp=Recents.getSystemServices();
  ssp.registerTaskStackListener(mTaskStackListener);
  LayoutInflater inflater=LayoutInflater.from(mContext);
  mDummyStackView=new TaskStackView(mContext);
  mHeaderBar=(TaskViewHeader)inflater.inflate(R.layout.recents_task_view_header,null,false);
  reloadResources();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,true);
  RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
  launchOpts.numVisibleTasks=loader.getIconCacheSize();
  launchOpts.numVisibleTaskThumbnails=loader.getThumbnailCacheSize();
  launchOpts.onlyLoadForCache=true;
  loader.loadTasks(mContext,plan,launchOpts);
}","public RecentsImpl(Context context){
  mContext=context;
  mHandler=new Handler();
  ForegroundThread.get();
  mTaskStackListener=new TaskStackListenerImpl();
  SystemServicesProxy ssp=Recents.getSystemServices();
  ssp.registerTaskStackListener(mTaskStackListener);
  LayoutInflater inflater=LayoutInflater.from(mContext);
  mDummyStackView=new TaskStackView(mContext);
  mHeaderBar=(TaskViewHeader)inflater.inflate(R.layout.recents_task_view_header,null,false);
  reloadResources();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,false);
  RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
  launchOpts.numVisibleTasks=loader.getIconCacheSize();
  launchOpts.numVisibleTaskThumbnails=loader.getThumbnailCacheSize();
  launchOpts.onlyLoadForCache=true;
  loader.loadTasks(mContext,plan,launchOpts);
}",0.9961935834692768
191573,"/** 
 * Transitions to the next recent task in the stack.
 */
public void showNextTask(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,true);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  boolean isRunningTaskInHomeStack=SystemServicesProxy.isHomeStack(runningTask.stackId);
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  for (int i=taskCount - 1; i >= 1; i--) {
    Task task=tasks.get(i);
    if (isRunningTaskInHomeStack) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_fast_toggle_app_home_exit);
      break;
    }
 else     if (task.key.id == runningTask.id) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      break;
    }
  }
  if (toTask == null) {
    ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
    return;
  }
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}","/** 
 * Transitions to the next recent task in the stack.
 */
public void showNextTask(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,false);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  boolean isRunningTaskInHomeStack=SystemServicesProxy.isHomeStack(runningTask.stackId);
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  for (int i=taskCount - 1; i >= 1; i--) {
    Task task=tasks.get(i);
    if (isRunningTaskInHomeStack) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_fast_toggle_app_home_exit);
      break;
    }
 else     if (task.key.id == runningTask.id) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      break;
    }
  }
  if (toTask == null) {
    ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
    return;
  }
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}",0.9978118161925602
191574,"@Override public void onTaskStackChanged(){
  RecentsConfiguration config=Recents.getConfiguration();
  if (config.svelteLevel == RecentsConfiguration.SVELTE_NONE) {
    RecentsTaskLoader loader=Recents.getTaskLoader();
    SystemServicesProxy ssp=Recents.getSystemServices();
    ActivityManager.RunningTaskInfo runningTaskInfo=ssp.getRunningTask();
    RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
    loader.preloadTasks(plan,-1,true);
    RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
    if (runningTaskInfo != null) {
      launchOpts.runningTaskId=runningTaskInfo.id;
    }
    launchOpts.numVisibleTasks=2;
    launchOpts.numVisibleTaskThumbnails=2;
    launchOpts.onlyLoadForCache=true;
    launchOpts.onlyLoadPausedActivities=true;
    loader.loadTasks(mContext,plan,launchOpts);
  }
}","@Override public void onTaskStackChanged(){
  RecentsConfiguration config=Recents.getConfiguration();
  if (config.svelteLevel == RecentsConfiguration.SVELTE_NONE) {
    RecentsTaskLoader loader=Recents.getTaskLoader();
    SystemServicesProxy ssp=Recents.getSystemServices();
    ActivityManager.RunningTaskInfo runningTaskInfo=ssp.getRunningTask();
    RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
    loader.preloadTasks(plan,-1,false);
    RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
    if (runningTaskInfo != null) {
      launchOpts.runningTaskId=runningTaskInfo.id;
    }
    launchOpts.numVisibleTasks=2;
    launchOpts.numVisibleTaskThumbnails=2;
    launchOpts.onlyLoadForCache=true;
    launchOpts.onlyLoadPausedActivities=true;
    loader.loadTasks(mContext,plan,launchOpts);
  }
}",0.99581589958159
191575,"/** 
 * Returns a list of the recents tasks.
 * @param isHomeStackVisible whether or not the home stack is currently visible.  If it isvisible, then we ignore all excluded tasks (even the first one).
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean isHomeStackVisible,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=i;
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  List<ActivityManager.RecentTaskInfo> tasks=mAm.getRecentTasksForUser(numTasksToQuery,ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES| ActivityManager.RECENT_WITH_EXCLUDED,userId);
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    boolean isBlackListed=sRecentsBlacklist.contains(t.realActivity.getClassName());
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isBlackListed || (isExcluded && (isHomeStackVisible || !isFirstValidTask))) {
      iter.remove();
      continue;
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}","/** 
 * Returns a list of the recents tasks.
 * @param includeFrontMostExcludedTask if set, will ensure that the front most excluded taskwill be visible, otherwise no excluded tasks will be visible.
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean includeFrontMostExcludedTask,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=i;
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  int flags=ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES;
  if (includeFrontMostExcludedTask) {
    flags|=ActivityManager.RECENT_WITH_EXCLUDED;
  }
  List<ActivityManager.RecentTaskInfo> tasks=mAm.getRecentTasksForUser(numTasksToQuery,flags,userId);
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    if (sRecentsBlacklist.contains(t.realActivity.getClassName())) {
      iter.remove();
    }
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isExcluded && (!isFirstValidTask || !includeFrontMostExcludedTask)) {
      iter.remove();
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}",0.8510786360473208
191576,"/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean isHomeStackVisible){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(isHomeStackVisible);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  long lastStackActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    lastStackActiveTime=0;
  }
  long newLastStackActiveTime=-1;
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=SystemServicesProxy.isFreeformStack(t.stackId);
    boolean isStackTask=isFreeformTask || !isHistoricalTask(t) || (t.lastActiveTime >= lastStackActiveTime && i >= (taskCount - MIN_NUM_TASKS));
    boolean isLaunchTarget=taskKey.id == runningTaskId;
    if (isStackTask && newLastStackActiveTime < 0) {
      newLastStackActiveTime=t.lastActiveTime;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (newLastStackActiveTime != -1) {
    Prefs.putLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,newLastStackActiveTime);
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}","/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean includeFrontMostExcludedTask){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(includeFrontMostExcludedTask);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  long lastStackActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    lastStackActiveTime=0;
  }
  long newLastStackActiveTime=-1;
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=SystemServicesProxy.isFreeformStack(t.stackId);
    boolean isStackTask=isFreeformTask || !isHistoricalTask(t) || (t.lastActiveTime >= lastStackActiveTime && i >= (taskCount - MIN_NUM_TASKS));
    boolean isLaunchTarget=taskKey.id == runningTaskId;
    if (isStackTask && newLastStackActiveTime < 0) {
      newLastStackActiveTime=t.lastActiveTime;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (newLastStackActiveTime != -1) {
    Prefs.putLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,newLastStackActiveTime);
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}",0.9865894544346236
191577,"/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean isHomeStackVisible){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  SystemServicesProxy ssp=Recents.getSystemServices();
  mRawTasks=ssp.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,isHomeStackVisible,mCurrentQuietProfiles);
  Collections.reverse(mRawTasks);
}","/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean includeFrontMostExcludedTask){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  SystemServicesProxy ssp=Recents.getSystemServices();
  mRawTasks=ssp.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,includeFrontMostExcludedTask,mCurrentQuietProfiles);
  Collections.reverse(mRawTasks);
}",0.9152215799614644
191578,"/** 
 * Preloads recents tasks using the specified plan to store the output. 
 */
public void preloadTasks(RecentsTaskLoadPlan plan,int runningTaskId,boolean isHomeStackVisible){
  plan.preloadPlan(this,runningTaskId,isHomeStackVisible);
}","/** 
 * Preloads recents tasks using the specified plan to store the output. 
 */
public void preloadTasks(RecentsTaskLoadPlan plan,int runningTaskId,boolean includeFrontMostExcludedTask){
  plan.preloadPlan(this,runningTaskId,includeFrontMostExcludedTask);
}",0.8232931726907631
191579,"private void updateRecentsTasks(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=RecentsImpl.consumeInstanceLoadPlan();
  if (plan == null) {
    plan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!plan.hasTasks()) {
    loader.preloadTasks(plan,-1,launchState.launchedFromHome);
  }
  mLaunchedFromHome=launchState.launchedFromHome;
  TaskStack stack=plan.getTaskStack();
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=stack.getStackTaskCount();
  loadOpts.numVisibleTaskThumbnails=stack.getStackTaskCount();
  loader.loadTasks(this,plan,loadOpts);
  mRecentsView.setTaskStack(stack);
  List stackTasks=stack.getStackTasks();
  Collections.reverse(stackTasks);
  if (mTaskStackViewAdapter == null) {
    mTaskStackViewAdapter=new TaskStackHorizontalViewAdapter(stackTasks);
    mTaskStackHorizontalGridView=mRecentsView.setTaskStackViewAdapter(mTaskStackViewAdapter);
  }
 else {
    mTaskStackViewAdapter.setNewStackTasks(stackTasks);
  }
  if (launchState.launchedToTaskId != -1) {
    ArrayList<Task> tasks=stack.getStackTasks();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      Task t=tasks.get(i);
      if (t.key.id == launchState.launchedToTaskId) {
        t.isLaunchTarget=true;
        break;
      }
    }
  }
}","private void updateRecentsTasks(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=RecentsImpl.consumeInstanceLoadPlan();
  if (plan == null) {
    plan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!plan.hasTasks()) {
    loader.preloadTasks(plan,-1,!launchState.launchedFromHome);
  }
  mLaunchedFromHome=launchState.launchedFromHome;
  TaskStack stack=plan.getTaskStack();
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=stack.getStackTaskCount();
  loadOpts.numVisibleTaskThumbnails=stack.getStackTaskCount();
  loader.loadTasks(this,plan,loadOpts);
  mRecentsView.setTaskStack(stack);
  List stackTasks=stack.getStackTasks();
  Collections.reverse(stackTasks);
  if (mTaskStackViewAdapter == null) {
    mTaskStackViewAdapter=new TaskStackHorizontalViewAdapter(stackTasks);
    mTaskStackHorizontalGridView=mRecentsView.setTaskStackViewAdapter(mTaskStackViewAdapter);
  }
 else {
    mTaskStackViewAdapter.setNewStackTasks(stackTasks);
  }
  if (launchState.launchedToTaskId != -1) {
    ArrayList<Task> tasks=stack.getStackTasks();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      Task t=tasks.get(i);
      if (t.key.id == launchState.launchedToTaskId) {
        t.isLaunchTarget=true;
        break;
      }
    }
  }
}",0.9996692027786966
191580,"public void add(ProcessStats other){
  ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=other.mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> versions=uids.valueAt(iu);
      for (int iv=0; iv < versions.size(); iv++) {
        final int vers=versions.keyAt(iv);
        final PackageState otherState=versions.valueAt(iv);
        final int NPROCS=otherState.mProcesses.size();
        final int NSRVS=otherState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState otherProc=otherState.mProcesses.valueAt(iproc);
          if (otherProc.getCommonProcess() != otherProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ vers+ ""String_Node_Str""+ otherProc.getName());
            ProcessState thisProc=getProcessStateLocked(pkgName,uid,vers,otherProc.getName());
            if (thisProc.getCommonProcess() == thisProc) {
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"");
              thisProc.setMultiPackage(true);
              long now=SystemClock.uptimeMillis();
              final PackageState pkgState=getPackageStateLocked(pkgName,uid,vers);
              thisProc=thisProc.clone(now);
              pkgState.mProcesses.put(thisProc.getName(),thisProc);
            }
            thisProc.add(otherProc);
          }
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          ServiceState otherSvc=otherState.mServices.valueAt(isvc);
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ otherSvc.getName());
          ServiceState thisSvc=getServiceStateLocked(pkgName,uid,vers,otherSvc.getProcessName(),otherSvc.getName());
          thisSvc.add(otherSvc);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=other.mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      ProcessState otherProc=uids.valueAt(iu);
      final String name=otherProc.getName();
      final String pkg=otherProc.getPackage();
      final int vers=otherProc.getVersion();
      ProcessState thisProc=mProcesses.get(name,uid);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ name);
      if (thisProc == null) {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"");
        thisProc=new ProcessState(this,pkg,uid,vers,name);
        mProcesses.put(name,uid,thisProc);
        PackageState thisState=getPackageStateLocked(pkg,uid,vers);
        if (!thisState.mProcesses.containsKey(name)) {
          thisState.mProcesses.put(name,thisProc);
        }
      }
      thisProc.add(otherProc);
    }
  }
  for (int i=0; i < ADJ_COUNT; i++) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ other.mMemFactorDurations[i]+ ""String_Node_Str""+ mMemFactorDurations[i]);
    mMemFactorDurations[i]+=other.mMemFactorDurations[i];
  }
  mSysMemUsage.mergeStats(other.mSysMemUsage);
  if (other.mTimePeriodStartClock < mTimePeriodStartClock) {
    mTimePeriodStartClock=other.mTimePeriodStartClock;
    mTimePeriodStartClockStr=other.mTimePeriodStartClockStr;
  }
  mTimePeriodEndRealtime+=other.mTimePeriodEndRealtime - other.mTimePeriodStartRealtime;
  mTimePeriodEndUptime+=other.mTimePeriodEndUptime - other.mTimePeriodStartUptime;
}","public void add(ProcessStats other){
  ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=other.mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> versions=uids.valueAt(iu);
      for (int iv=0; iv < versions.size(); iv++) {
        final int vers=versions.keyAt(iv);
        final PackageState otherState=versions.valueAt(iv);
        final int NPROCS=otherState.mProcesses.size();
        final int NSRVS=otherState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState otherProc=otherState.mProcesses.valueAt(iproc);
          if (otherProc.getCommonProcess() != otherProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ vers+ ""String_Node_Str""+ otherProc.getName());
            ProcessState thisProc=getProcessStateLocked(pkgName,uid,vers,otherProc.getName());
            if (thisProc.getCommonProcess() == thisProc) {
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"");
              thisProc.setMultiPackage(true);
              long now=SystemClock.uptimeMillis();
              final PackageState pkgState=getPackageStateLocked(pkgName,uid,vers);
              thisProc=thisProc.clone(now);
              pkgState.mProcesses.put(thisProc.getName(),thisProc);
            }
            thisProc.add(otherProc);
          }
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          ServiceState otherSvc=otherState.mServices.valueAt(isvc);
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ otherSvc.getName());
          ServiceState thisSvc=getServiceStateLocked(pkgName,uid,vers,otherSvc.getProcessName(),otherSvc.getName());
          thisSvc.add(otherSvc);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=other.mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      ProcessState otherProc=uids.valueAt(iu);
      final String name=otherProc.getName();
      final String pkg=otherProc.getPackage();
      final int vers=otherProc.getVersion();
      ProcessState thisProc=mProcesses.get(name,uid);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ name);
      if (thisProc == null) {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"");
        thisProc=new ProcessState(this,pkg,uid,vers,name);
        mProcesses.put(name,uid,thisProc);
        PackageState thisState=getPackageStateLocked(pkg,uid,vers);
        if (!thisState.mProcesses.containsKey(name)) {
          thisState.mProcesses.put(name,thisProc);
        }
      }
      thisProc.add(otherProc);
    }
  }
  for (int i=0; i < ADJ_COUNT; i++) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ other.mMemFactorDurations[i]+ ""String_Node_Str""+ mMemFactorDurations[i]);
    mMemFactorDurations[i]+=other.mMemFactorDurations[i];
  }
  mSysMemUsage.mergeStats(other.mSysMemUsage);
  if (other.mTimePeriodStartClock < mTimePeriodStartClock) {
    mTimePeriodStartClock=other.mTimePeriodStartClock;
    mTimePeriodStartClockStr=other.mTimePeriodStartClockStr;
  }
  mTimePeriodEndRealtime+=other.mTimePeriodEndRealtime - other.mTimePeriodStartRealtime;
  mTimePeriodEndUptime+=other.mTimePeriodEndUptime - other.mTimePeriodStartUptime;
  mHasSwappedOutPss|=other.mHasSwappedOutPss;
}",0.9938535542490646
191581,"public void computeTotalMemoryUse(TotalMemoryUseCollection data,long now){
  data.totalTime=0;
  for (int i=0; i < STATE_COUNT; i++) {
    data.processStateWeight[i]=0;
    data.processStatePss[i]=0;
    data.processStateTime[i]=0;
    data.processStateSamples[i]=0;
  }
  for (int i=0; i < SYS_MEM_USAGE_COUNT; i++) {
    data.sysMemUsage[i]=0;
  }
  data.sysMemCachedWeight=0;
  data.sysMemFreeWeight=0;
  data.sysMemZRamWeight=0;
  data.sysMemKernelWeight=0;
  data.sysMemNativeWeight=0;
  data.sysMemSamples=0;
  final long[] totalMemUsage=mSysMemUsage.getTotalMemUsage();
  for (int is=0; is < data.screenStates.length; is++) {
    for (int im=0; im < data.memStates.length; im++) {
      int memBucket=data.screenStates[is] + data.memStates[im];
      int stateBucket=memBucket * STATE_COUNT;
      long memTime=mMemFactorDurations[memBucket];
      if (mMemFactor == memBucket) {
        memTime+=now - mStartTime;
      }
      data.totalTime+=memTime;
      final int sysKey=mSysMemUsage.getKey((byte)stateBucket);
      long[] longs=totalMemUsage;
      int idx=0;
      if (sysKey != SparseMappingTable.INVALID_KEY) {
        final long[] tmpLongs=mSysMemUsage.getArrayForKey(sysKey);
        final int tmpIndex=SparseMappingTable.getIndexFromKey(sysKey);
        if (tmpLongs[tmpIndex + SYS_MEM_USAGE_SAMPLE_COUNT] >= 3) {
          SysMemUsageTable.mergeSysMemUsage(data.sysMemUsage,0,longs,idx);
          longs=tmpLongs;
          idx=tmpIndex;
        }
      }
      data.sysMemCachedWeight+=longs[idx + SYS_MEM_USAGE_CACHED_AVERAGE] * (double)memTime;
      data.sysMemFreeWeight+=longs[idx + SYS_MEM_USAGE_FREE_AVERAGE] * (double)memTime;
      data.sysMemZRamWeight+=longs[idx + SYS_MEM_USAGE_ZRAM_AVERAGE] * (double)memTime;
      data.sysMemKernelWeight+=longs[idx + SYS_MEM_USAGE_KERNEL_AVERAGE] * (double)memTime;
      data.sysMemNativeWeight+=longs[idx + SYS_MEM_USAGE_NATIVE_AVERAGE] * (double)memTime;
      data.sysMemSamples+=longs[idx + SYS_MEM_USAGE_SAMPLE_COUNT];
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int iproc=0; iproc < procMap.size(); iproc++) {
    SparseArray<ProcessState> uids=procMap.valueAt(iproc);
    for (int iu=0; iu < uids.size(); iu++) {
      final ProcessState proc=uids.valueAt(iu);
      proc.aggregatePss(data,now);
    }
  }
}","public void computeTotalMemoryUse(TotalMemoryUseCollection data,long now){
  data.totalTime=0;
  for (int i=0; i < STATE_COUNT; i++) {
    data.processStateWeight[i]=0;
    data.processStatePss[i]=0;
    data.processStateTime[i]=0;
    data.processStateSamples[i]=0;
  }
  for (int i=0; i < SYS_MEM_USAGE_COUNT; i++) {
    data.sysMemUsage[i]=0;
  }
  data.sysMemCachedWeight=0;
  data.sysMemFreeWeight=0;
  data.sysMemZRamWeight=0;
  data.sysMemKernelWeight=0;
  data.sysMemNativeWeight=0;
  data.sysMemSamples=0;
  final long[] totalMemUsage=mSysMemUsage.getTotalMemUsage();
  for (int is=0; is < data.screenStates.length; is++) {
    for (int im=0; im < data.memStates.length; im++) {
      int memBucket=data.screenStates[is] + data.memStates[im];
      int stateBucket=memBucket * STATE_COUNT;
      long memTime=mMemFactorDurations[memBucket];
      if (mMemFactor == memBucket) {
        memTime+=now - mStartTime;
      }
      data.totalTime+=memTime;
      final int sysKey=mSysMemUsage.getKey((byte)stateBucket);
      long[] longs=totalMemUsage;
      int idx=0;
      if (sysKey != SparseMappingTable.INVALID_KEY) {
        final long[] tmpLongs=mSysMemUsage.getArrayForKey(sysKey);
        final int tmpIndex=SparseMappingTable.getIndexFromKey(sysKey);
        if (tmpLongs[tmpIndex + SYS_MEM_USAGE_SAMPLE_COUNT] >= 3) {
          SysMemUsageTable.mergeSysMemUsage(data.sysMemUsage,0,longs,idx);
          longs=tmpLongs;
          idx=tmpIndex;
        }
      }
      data.sysMemCachedWeight+=longs[idx + SYS_MEM_USAGE_CACHED_AVERAGE] * (double)memTime;
      data.sysMemFreeWeight+=longs[idx + SYS_MEM_USAGE_FREE_AVERAGE] * (double)memTime;
      data.sysMemZRamWeight+=longs[idx + SYS_MEM_USAGE_ZRAM_AVERAGE] * (double)memTime;
      data.sysMemKernelWeight+=longs[idx + SYS_MEM_USAGE_KERNEL_AVERAGE] * (double)memTime;
      data.sysMemNativeWeight+=longs[idx + SYS_MEM_USAGE_NATIVE_AVERAGE] * (double)memTime;
      data.sysMemSamples+=longs[idx + SYS_MEM_USAGE_SAMPLE_COUNT];
    }
  }
  data.hasSwappedOutPss=mHasSwappedOutPss;
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int iproc=0; iproc < procMap.size(); iproc++) {
    SparseArray<ProcessState> uids=procMap.valueAt(iproc);
    for (int iu=0; iu < uids.size(); iu++) {
      final ProcessState proc=uids.valueAt(iu);
      proc.aggregatePss(data,now);
    }
  }
}",0.990872426236468
191582,"public void readFromParcel(Parcel in){
  final boolean hadData=mPackages.getMap().size() > 0 || mProcesses.getMap().size() > 0;
  if (hadData) {
    resetSafely();
  }
  if (!readCheckedInt(in,MAGIC,""String_Node_Str"")) {
    return;
  }
  int version=in.readInt();
  if (version != PARCEL_VERSION) {
    mReadError=""String_Node_Str"" + version;
    return;
  }
  if (!readCheckedInt(in,STATE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,ADJ_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,PSS_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SYS_MEM_USAGE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SparseMappingTable.ARRAY_SIZE,""String_Node_Str"")) {
    return;
  }
  mIndexToCommonString=new ArrayList<String>();
  mTimePeriodStartClock=in.readLong();
  buildTimePeriodStartClockStr();
  mTimePeriodStartRealtime=in.readLong();
  mTimePeriodEndRealtime=in.readLong();
  mTimePeriodStartUptime=in.readLong();
  mTimePeriodEndUptime=in.readLong();
  mRuntime=in.readString();
  mFlags=in.readInt();
  mTableData.readFromParcel(in);
  readCompactedLongArray(in,version,mMemFactorDurations,mMemFactorDurations.length);
  if (!mSysMemUsage.readFromParcel(in)) {
    return;
  }
  int NPROC=in.readInt();
  if (NPROC < 0) {
    mReadError=""String_Node_Str"" + NPROC;
    return;
  }
  while (NPROC > 0) {
    NPROC--;
    final String procName=readCommonString(in,version);
    if (procName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      final String pkgName=readCommonString(in,version);
      if (pkgName == null) {
        mReadError=""String_Node_Str"";
        return;
      }
      final int vers=in.readInt();
      ProcessState proc=hadData ? mProcesses.get(procName,uid) : null;
      if (proc != null) {
        if (!proc.readFromParcel(in,false)) {
          return;
        }
      }
 else {
        proc=new ProcessState(this,pkgName,uid,vers,procName);
        if (!proc.readFromParcel(in,true)) {
          return;
        }
      }
      if (DEBUG_PARCEL)       Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
      mProcesses.put(procName,uid,proc);
    }
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + mProcesses.getMap().size() + ""String_Node_Str"");
  int NPKG=in.readInt();
  if (NPKG < 0) {
    mReadError=""String_Node_Str"" + NPKG;
    return;
  }
  while (NPKG > 0) {
    NPKG--;
    final String pkgName=readCommonString(in,version);
    if (pkgName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      int NVERS=in.readInt();
      if (NVERS < 0) {
        mReadError=""String_Node_Str"" + NVERS;
        return;
      }
      while (NVERS > 0) {
        NVERS--;
        final int vers=in.readInt();
        PackageState pkgState=new PackageState(pkgName,uid);
        SparseArray<PackageState> vpkg=mPackages.get(pkgName,uid);
        if (vpkg == null) {
          vpkg=new SparseArray<PackageState>();
          mPackages.put(pkgName,uid,vpkg);
        }
        vpkg.put(vers,pkgState);
        int NPROCS=in.readInt();
        if (NPROCS < 0) {
          mReadError=""String_Node_Str"" + NPROCS;
          return;
        }
        while (NPROCS > 0) {
          NPROCS--;
          String procName=readCommonString(in,version);
          if (procName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          int hasProc=in.readInt();
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ procName+ ""String_Node_Str""+ hasProc);
          ProcessState commonProc=mProcesses.get(procName,uid);
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
          if (commonProc == null) {
            mReadError=""String_Node_Str"" + procName;
            return;
          }
          if (hasProc != 0) {
            ProcessState proc=hadData ? pkgState.mProcesses.get(procName) : null;
            if (proc != null) {
              if (!proc.readFromParcel(in,false)) {
                return;
              }
            }
 else {
              proc=new ProcessState(commonProc,pkgName,uid,vers,procName,0);
              if (!proc.readFromParcel(in,true)) {
                return;
              }
            }
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
            pkgState.mProcesses.put(procName,proc);
          }
 else {
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
            pkgState.mProcesses.put(procName,commonProc);
          }
        }
        int NSRVS=in.readInt();
        if (NSRVS < 0) {
          mReadError=""String_Node_Str"" + NSRVS;
          return;
        }
        while (NSRVS > 0) {
          NSRVS--;
          String serviceName=in.readString();
          if (serviceName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          String processName=version > 9 ? readCommonString(in,version) : null;
          ServiceState serv=hadData ? pkgState.mServices.get(serviceName) : null;
          if (serv == null) {
            serv=new ServiceState(this,pkgName,serviceName,processName,null);
          }
          if (!serv.readFromParcel(in)) {
            return;
          }
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ serv);
          pkgState.mServices.put(serviceName,serv);
        }
      }
    }
  }
  mIndexToCommonString=null;
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"");
}","public void readFromParcel(Parcel in){
  final boolean hadData=mPackages.getMap().size() > 0 || mProcesses.getMap().size() > 0;
  if (hadData) {
    resetSafely();
  }
  if (!readCheckedInt(in,MAGIC,""String_Node_Str"")) {
    return;
  }
  int version=in.readInt();
  if (version != PARCEL_VERSION) {
    mReadError=""String_Node_Str"" + version;
    return;
  }
  if (!readCheckedInt(in,STATE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,ADJ_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,PSS_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SYS_MEM_USAGE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SparseMappingTable.ARRAY_SIZE,""String_Node_Str"")) {
    return;
  }
  mIndexToCommonString=new ArrayList<String>();
  mTimePeriodStartClock=in.readLong();
  buildTimePeriodStartClockStr();
  mTimePeriodStartRealtime=in.readLong();
  mTimePeriodEndRealtime=in.readLong();
  mTimePeriodStartUptime=in.readLong();
  mTimePeriodEndUptime=in.readLong();
  mRuntime=in.readString();
  mHasSwappedOutPss=in.readInt() != 0;
  mFlags=in.readInt();
  mTableData.readFromParcel(in);
  readCompactedLongArray(in,version,mMemFactorDurations,mMemFactorDurations.length);
  if (!mSysMemUsage.readFromParcel(in)) {
    return;
  }
  int NPROC=in.readInt();
  if (NPROC < 0) {
    mReadError=""String_Node_Str"" + NPROC;
    return;
  }
  while (NPROC > 0) {
    NPROC--;
    final String procName=readCommonString(in,version);
    if (procName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      final String pkgName=readCommonString(in,version);
      if (pkgName == null) {
        mReadError=""String_Node_Str"";
        return;
      }
      final int vers=in.readInt();
      ProcessState proc=hadData ? mProcesses.get(procName,uid) : null;
      if (proc != null) {
        if (!proc.readFromParcel(in,false)) {
          return;
        }
      }
 else {
        proc=new ProcessState(this,pkgName,uid,vers,procName);
        if (!proc.readFromParcel(in,true)) {
          return;
        }
      }
      if (DEBUG_PARCEL)       Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
      mProcesses.put(procName,uid,proc);
    }
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + mProcesses.getMap().size() + ""String_Node_Str"");
  int NPKG=in.readInt();
  if (NPKG < 0) {
    mReadError=""String_Node_Str"" + NPKG;
    return;
  }
  while (NPKG > 0) {
    NPKG--;
    final String pkgName=readCommonString(in,version);
    if (pkgName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      int NVERS=in.readInt();
      if (NVERS < 0) {
        mReadError=""String_Node_Str"" + NVERS;
        return;
      }
      while (NVERS > 0) {
        NVERS--;
        final int vers=in.readInt();
        PackageState pkgState=new PackageState(pkgName,uid);
        SparseArray<PackageState> vpkg=mPackages.get(pkgName,uid);
        if (vpkg == null) {
          vpkg=new SparseArray<PackageState>();
          mPackages.put(pkgName,uid,vpkg);
        }
        vpkg.put(vers,pkgState);
        int NPROCS=in.readInt();
        if (NPROCS < 0) {
          mReadError=""String_Node_Str"" + NPROCS;
          return;
        }
        while (NPROCS > 0) {
          NPROCS--;
          String procName=readCommonString(in,version);
          if (procName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          int hasProc=in.readInt();
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ procName+ ""String_Node_Str""+ hasProc);
          ProcessState commonProc=mProcesses.get(procName,uid);
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
          if (commonProc == null) {
            mReadError=""String_Node_Str"" + procName;
            return;
          }
          if (hasProc != 0) {
            ProcessState proc=hadData ? pkgState.mProcesses.get(procName) : null;
            if (proc != null) {
              if (!proc.readFromParcel(in,false)) {
                return;
              }
            }
 else {
              proc=new ProcessState(commonProc,pkgName,uid,vers,procName,0);
              if (!proc.readFromParcel(in,true)) {
                return;
              }
            }
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
            pkgState.mProcesses.put(procName,proc);
          }
 else {
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
            pkgState.mProcesses.put(procName,commonProc);
          }
        }
        int NSRVS=in.readInt();
        if (NSRVS < 0) {
          mReadError=""String_Node_Str"" + NSRVS;
          return;
        }
        while (NSRVS > 0) {
          NSRVS--;
          String serviceName=in.readString();
          if (serviceName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          String processName=version > 9 ? readCommonString(in,version) : null;
          ServiceState serv=hadData ? pkgState.mServices.get(serviceName) : null;
          if (serv == null) {
            serv=new ServiceState(this,pkgName,serviceName,processName,null);
          }
          if (!serv.readFromParcel(in)) {
            return;
          }
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ serv);
          pkgState.mServices.put(serviceName,serv);
        }
      }
    }
  }
  mIndexToCommonString=null;
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"");
}",0.9969821248936006
191583,"public void dumpCheckinLocked(PrintWriter pw,String reqPackage){
  final long now=SystemClock.uptimeMillis();
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartClockStr);
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartRealtime);
  pw.print(""String_Node_Str"");
  pw.print(mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.println(mRuntime);
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      for (int iv=0; iv < vpkgs.size(); iv++) {
        final int vers=vpkgs.keyAt(iv);
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        final int NSRVS=pkgState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          proc.dumpPackageProcCheckin(pw,pkgName,uid,vers,pkgState.mProcesses.keyAt(iproc),now);
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          final String serviceName=DumpUtils.collapseString(pkgName,pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          svc.dumpTimesCheckin(pw,pkgName,uid,vers,serviceName,now);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final ProcessState procState=uids.valueAt(iu);
      procState.dumpProcCheckin(pw,procName,uid,now);
    }
  }
  pw.print(""String_Node_Str"");
  DumpUtils.dumpAdjTimesCheckin(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  final int sysMemUsageCount=mSysMemUsage.getKeyCount();
  if (sysMemUsageCount > 0) {
    pw.print(""String_Node_Str"");
    for (int i=0; i < sysMemUsageCount; i++) {
      final int key=mSysMemUsage.getKeyAt(i);
      final int type=SparseMappingTable.getIdFromKey(key);
      pw.print(""String_Node_Str"");
      DumpUtils.printProcStateTag(pw,type);
      for (int j=SYS_MEM_USAGE_SAMPLE_COUNT; j < SYS_MEM_USAGE_COUNT; j++) {
        if (j > SYS_MEM_USAGE_CACHED_MINIMUM) {
          pw.print(""String_Node_Str"");
        }
        pw.print(mSysMemUsage.getValue(key,j));
      }
    }
  }
  pw.println();
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.totalTime);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemCachedWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemFreeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemZRamWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemKernelWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemNativeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateWeight[i]);
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateSamples[i]);
  }
  pw.println();
}","public void dumpCheckinLocked(PrintWriter pw,String reqPackage){
  final long now=SystemClock.uptimeMillis();
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartClockStr);
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartRealtime);
  pw.print(""String_Node_Str"");
  pw.print(mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  if (mHasSwappedOutPss) {
    pw.print(""String_Node_Str"");
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.println(mRuntime);
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      for (int iv=0; iv < vpkgs.size(); iv++) {
        final int vers=vpkgs.keyAt(iv);
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        final int NSRVS=pkgState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          proc.dumpPackageProcCheckin(pw,pkgName,uid,vers,pkgState.mProcesses.keyAt(iproc),now);
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          final String serviceName=DumpUtils.collapseString(pkgName,pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          svc.dumpTimesCheckin(pw,pkgName,uid,vers,serviceName,now);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final ProcessState procState=uids.valueAt(iu);
      procState.dumpProcCheckin(pw,procName,uid,now);
    }
  }
  pw.print(""String_Node_Str"");
  DumpUtils.dumpAdjTimesCheckin(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  final int sysMemUsageCount=mSysMemUsage.getKeyCount();
  if (sysMemUsageCount > 0) {
    pw.print(""String_Node_Str"");
    for (int i=0; i < sysMemUsageCount; i++) {
      final int key=mSysMemUsage.getKeyAt(i);
      final int type=SparseMappingTable.getIdFromKey(key);
      pw.print(""String_Node_Str"");
      DumpUtils.printProcStateTag(pw,type);
      for (int j=SYS_MEM_USAGE_SAMPLE_COUNT; j < SYS_MEM_USAGE_COUNT; j++) {
        if (j > SYS_MEM_USAGE_CACHED_MINIMUM) {
          pw.print(""String_Node_Str"");
        }
        pw.print(mSysMemUsage.getValue(key,j));
      }
    }
  }
  pw.println();
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.totalTime);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemCachedWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemFreeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemZRamWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemKernelWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemNativeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateWeight[i]);
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateSamples[i]);
  }
  pw.println();
}",0.9927206551410374
191584,"/** 
 * @hide 
 */
public void writeToParcel(Parcel out,long now,int flags){
  out.writeInt(MAGIC);
  out.writeInt(PARCEL_VERSION);
  out.writeInt(STATE_COUNT);
  out.writeInt(ADJ_COUNT);
  out.writeInt(PSS_COUNT);
  out.writeInt(SYS_MEM_USAGE_COUNT);
  out.writeInt(SparseMappingTable.ARRAY_SIZE);
  mCommonStringToIndex=new ArrayMap<String,Integer>(mProcesses.size());
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  final int NPROC=procMap.size();
  for (int ip=0; ip < NPROC; ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      uids.valueAt(iu).commitStateTime(now);
    }
  }
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  final int NPKG=pkgMap.size();
  for (int ip=0; ip < NPKG; ip++) {
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      for (int iv=0; iv < NVERS; iv++) {
        PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() != proc) {
            proc.commitStateTime(now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        for (int isvc=0; isvc < NSRVS; isvc++) {
          pkgState.mServices.valueAt(isvc).commitStateTime(now);
        }
      }
    }
  }
  out.writeLong(mTimePeriodStartClock);
  out.writeLong(mTimePeriodStartRealtime);
  out.writeLong(mTimePeriodEndRealtime);
  out.writeLong(mTimePeriodStartUptime);
  out.writeLong(mTimePeriodEndUptime);
  out.writeString(mRuntime);
  out.writeInt(mFlags);
  mTableData.writeToParcel(out);
  if (mMemFactor != STATE_NOTHING) {
    mMemFactorDurations[mMemFactor]+=now - mStartTime;
    mStartTime=now;
  }
  writeCompactedLongArray(out,mMemFactorDurations,mMemFactorDurations.length);
  mSysMemUsage.writeToParcel(out);
  out.writeInt(NPROC);
  for (int ip=0; ip < NPROC; ip++) {
    writeCommonString(out,procMap.keyAt(ip));
    final SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final ProcessState proc=uids.valueAt(iu);
      writeCommonString(out,proc.getPackage());
      out.writeInt(proc.getVersion());
      proc.writeToParcel(out,now);
    }
  }
  out.writeInt(NPKG);
  for (int ip=0; ip < NPKG; ip++) {
    writeCommonString(out,pkgMap.keyAt(ip));
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      out.writeInt(NVERS);
      for (int iv=0; iv < NVERS; iv++) {
        out.writeInt(vpkgs.keyAt(iv));
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        out.writeInt(NPROCS);
        for (int iproc=0; iproc < NPROCS; iproc++) {
          writeCommonString(out,pkgState.mProcesses.keyAt(iproc));
          final ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() == proc) {
            out.writeInt(0);
          }
 else {
            out.writeInt(1);
            proc.writeToParcel(out,now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        out.writeInt(NSRVS);
        for (int isvc=0; isvc < NSRVS; isvc++) {
          out.writeString(pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          writeCommonString(out,svc.getProcessName());
          svc.writeToParcel(out,now);
        }
      }
    }
  }
  mCommonStringToIndex=null;
}","/** 
 * @hide 
 */
public void writeToParcel(Parcel out,long now,int flags){
  out.writeInt(MAGIC);
  out.writeInt(PARCEL_VERSION);
  out.writeInt(STATE_COUNT);
  out.writeInt(ADJ_COUNT);
  out.writeInt(PSS_COUNT);
  out.writeInt(SYS_MEM_USAGE_COUNT);
  out.writeInt(SparseMappingTable.ARRAY_SIZE);
  mCommonStringToIndex=new ArrayMap<String,Integer>(mProcesses.size());
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  final int NPROC=procMap.size();
  for (int ip=0; ip < NPROC; ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      uids.valueAt(iu).commitStateTime(now);
    }
  }
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  final int NPKG=pkgMap.size();
  for (int ip=0; ip < NPKG; ip++) {
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      for (int iv=0; iv < NVERS; iv++) {
        PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() != proc) {
            proc.commitStateTime(now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        for (int isvc=0; isvc < NSRVS; isvc++) {
          pkgState.mServices.valueAt(isvc).commitStateTime(now);
        }
      }
    }
  }
  out.writeLong(mTimePeriodStartClock);
  out.writeLong(mTimePeriodStartRealtime);
  out.writeLong(mTimePeriodEndRealtime);
  out.writeLong(mTimePeriodStartUptime);
  out.writeLong(mTimePeriodEndUptime);
  out.writeString(mRuntime);
  out.writeInt(mHasSwappedOutPss ? 1 : 0);
  out.writeInt(mFlags);
  mTableData.writeToParcel(out);
  if (mMemFactor != STATE_NOTHING) {
    mMemFactorDurations[mMemFactor]+=now - mStartTime;
    mStartTime=now;
  }
  writeCompactedLongArray(out,mMemFactorDurations,mMemFactorDurations.length);
  mSysMemUsage.writeToParcel(out);
  out.writeInt(NPROC);
  for (int ip=0; ip < NPROC; ip++) {
    writeCommonString(out,procMap.keyAt(ip));
    final SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final ProcessState proc=uids.valueAt(iu);
      writeCommonString(out,proc.getPackage());
      out.writeInt(proc.getVersion());
      proc.writeToParcel(out,now);
    }
  }
  out.writeInt(NPKG);
  for (int ip=0; ip < NPKG; ip++) {
    writeCommonString(out,pkgMap.keyAt(ip));
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      out.writeInt(NVERS);
      for (int iv=0; iv < NVERS; iv++) {
        out.writeInt(vpkgs.keyAt(iv));
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        out.writeInt(NPROCS);
        for (int iproc=0; iproc < NPROCS; iproc++) {
          writeCommonString(out,pkgState.mProcesses.keyAt(iproc));
          final ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() == proc) {
            out.writeInt(0);
          }
 else {
            out.writeInt(1);
            proc.writeToParcel(out,now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        out.writeInt(NSRVS);
        for (int isvc=0; isvc < NSRVS; isvc++) {
          out.writeString(pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          writeCommonString(out,svc.getProcessName());
          svc.writeToParcel(out,now);
        }
      }
    }
  }
  mCommonStringToIndex=null;
}",0.9947771164824488
191585,"void dumpTotalsLocked(PrintWriter pw,long now){
  pw.println(""String_Node_Str"");
  DumpUtils.dumpSingleTime(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  pw.println(""String_Node_Str"");
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  long totalPss=0;
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemKernelWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemNativeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    if (i != STATE_SERVICE_RESTARTING) {
      totalPss=printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[i],totalMem.processStateWeight[i],totalMem.totalTime,totalPss,totalMem.processStateSamples[i]);
    }
  }
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemCachedWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemFreeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemZRamWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,totalPss);
  pw.println();
  printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[STATE_SERVICE_RESTARTING],totalMem.processStateWeight[STATE_SERVICE_RESTARTING],totalMem.totalTime,totalPss,totalMem.processStateSamples[STATE_SERVICE_RESTARTING]);
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(DateFormat.format(""String_Node_Str"",mTimePeriodStartClock));
  pw.println();
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration((mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime) - mTimePeriodStartRealtime,pw);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  pw.print(' ');
  pw.print(mRuntime);
  pw.println();
}","void dumpTotalsLocked(PrintWriter pw,long now){
  pw.println(""String_Node_Str"");
  DumpUtils.dumpSingleTime(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  pw.println(""String_Node_Str"");
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  long totalPss=0;
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemKernelWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemNativeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    if (i != STATE_SERVICE_RESTARTING) {
      totalPss=printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[i],totalMem.processStateWeight[i],totalMem.totalTime,totalPss,totalMem.processStateSamples[i]);
    }
  }
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemCachedWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemFreeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemZRamWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,totalPss);
  pw.println();
  printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[STATE_SERVICE_RESTARTING],totalMem.processStateWeight[STATE_SERVICE_RESTARTING],totalMem.totalTime,totalPss,totalMem.processStateSamples[STATE_SERVICE_RESTARTING]);
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(DateFormat.format(""String_Node_Str"",mTimePeriodStartClock));
  pw.println();
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration((mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime) - mTimePeriodStartRealtime,pw);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  if (mHasSwappedOutPss) {
    pw.print(""String_Node_Str"");
  }
  pw.print(' ');
  pw.print(mRuntime);
  pw.println();
}",0.986975986975987
191586,"public void add(ProcessStats other){
  ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=other.mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> versions=uids.valueAt(iu);
      for (int iv=0; iv < versions.size(); iv++) {
        final int vers=versions.keyAt(iv);
        final PackageState otherState=versions.valueAt(iv);
        final int NPROCS=otherState.mProcesses.size();
        final int NSRVS=otherState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState otherProc=otherState.mProcesses.valueAt(iproc);
          if (otherProc.getCommonProcess() != otherProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ vers+ ""String_Node_Str""+ otherProc.getName());
            ProcessState thisProc=getProcessStateLocked(pkgName,uid,vers,otherProc.getName());
            if (thisProc.getCommonProcess() == thisProc) {
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"");
              thisProc.setMultiPackage(true);
              long now=SystemClock.uptimeMillis();
              final PackageState pkgState=getPackageStateLocked(pkgName,uid,vers);
              thisProc=thisProc.clone(now);
              pkgState.mProcesses.put(thisProc.getName(),thisProc);
            }
            thisProc.add(otherProc);
          }
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          ServiceState otherSvc=otherState.mServices.valueAt(isvc);
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ otherSvc.getName());
          ServiceState thisSvc=getServiceStateLocked(pkgName,uid,vers,otherSvc.getProcessName(),otherSvc.getName());
          thisSvc.add(otherSvc);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=other.mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      ProcessState otherProc=uids.valueAt(iu);
      final String name=otherProc.getName();
      final String pkg=otherProc.getPackage();
      final int vers=otherProc.getVersion();
      ProcessState thisProc=mProcesses.get(name,uid);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ name);
      if (thisProc == null) {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"");
        thisProc=new ProcessState(this,pkg,uid,vers,name);
        mProcesses.put(name,uid,thisProc);
        PackageState thisState=getPackageStateLocked(pkg,uid,vers);
        if (!thisState.mProcesses.containsKey(name)) {
          thisState.mProcesses.put(name,thisProc);
        }
      }
      thisProc.add(otherProc);
    }
  }
  for (int i=0; i < ADJ_COUNT; i++) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ other.mMemFactorDurations[i]+ ""String_Node_Str""+ mMemFactorDurations[i]);
    mMemFactorDurations[i]+=other.mMemFactorDurations[i];
  }
  mSysMemUsage.mergeStats(other.mSysMemUsage);
  if (other.mTimePeriodStartClock < mTimePeriodStartClock) {
    mTimePeriodStartClock=other.mTimePeriodStartClock;
    mTimePeriodStartClockStr=other.mTimePeriodStartClockStr;
  }
  mTimePeriodEndRealtime+=other.mTimePeriodEndRealtime - other.mTimePeriodStartRealtime;
  mTimePeriodEndUptime+=other.mTimePeriodEndUptime - other.mTimePeriodStartUptime;
}","public void add(ProcessStats other){
  ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=other.mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> versions=uids.valueAt(iu);
      for (int iv=0; iv < versions.size(); iv++) {
        final int vers=versions.keyAt(iv);
        final PackageState otherState=versions.valueAt(iv);
        final int NPROCS=otherState.mProcesses.size();
        final int NSRVS=otherState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState otherProc=otherState.mProcesses.valueAt(iproc);
          if (otherProc.getCommonProcess() != otherProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ vers+ ""String_Node_Str""+ otherProc.getName());
            ProcessState thisProc=getProcessStateLocked(pkgName,uid,vers,otherProc.getName());
            if (thisProc.getCommonProcess() == thisProc) {
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"");
              thisProc.setMultiPackage(true);
              long now=SystemClock.uptimeMillis();
              final PackageState pkgState=getPackageStateLocked(pkgName,uid,vers);
              thisProc=thisProc.clone(now);
              pkgState.mProcesses.put(thisProc.getName(),thisProc);
            }
            thisProc.add(otherProc);
          }
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          ServiceState otherSvc=otherState.mServices.valueAt(isvc);
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ otherSvc.getName());
          ServiceState thisSvc=getServiceStateLocked(pkgName,uid,vers,otherSvc.getProcessName(),otherSvc.getName());
          thisSvc.add(otherSvc);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=other.mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      ProcessState otherProc=uids.valueAt(iu);
      final String name=otherProc.getName();
      final String pkg=otherProc.getPackage();
      final int vers=otherProc.getVersion();
      ProcessState thisProc=mProcesses.get(name,uid);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ name);
      if (thisProc == null) {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"");
        thisProc=new ProcessState(this,pkg,uid,vers,name);
        mProcesses.put(name,uid,thisProc);
        PackageState thisState=getPackageStateLocked(pkg,uid,vers);
        if (!thisState.mProcesses.containsKey(name)) {
          thisState.mProcesses.put(name,thisProc);
        }
      }
      thisProc.add(otherProc);
    }
  }
  for (int i=0; i < ADJ_COUNT; i++) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ other.mMemFactorDurations[i]+ ""String_Node_Str""+ mMemFactorDurations[i]);
    mMemFactorDurations[i]+=other.mMemFactorDurations[i];
  }
  mSysMemUsage.mergeStats(other.mSysMemUsage);
  if (other.mTimePeriodStartClock < mTimePeriodStartClock) {
    mTimePeriodStartClock=other.mTimePeriodStartClock;
    mTimePeriodStartClockStr=other.mTimePeriodStartClockStr;
  }
  mTimePeriodEndRealtime+=other.mTimePeriodEndRealtime - other.mTimePeriodStartRealtime;
  mTimePeriodEndUptime+=other.mTimePeriodEndUptime - other.mTimePeriodStartUptime;
  mHasSwappedOutPss|=other.mHasSwappedOutPss;
}",0.9938535542490646
191587,"public void computeTotalMemoryUse(TotalMemoryUseCollection data,long now){
  data.totalTime=0;
  for (int i=0; i < STATE_COUNT; i++) {
    data.processStateWeight[i]=0;
    data.processStatePss[i]=0;
    data.processStateTime[i]=0;
    data.processStateSamples[i]=0;
  }
  for (int i=0; i < SYS_MEM_USAGE_COUNT; i++) {
    data.sysMemUsage[i]=0;
  }
  data.sysMemCachedWeight=0;
  data.sysMemFreeWeight=0;
  data.sysMemZRamWeight=0;
  data.sysMemKernelWeight=0;
  data.sysMemNativeWeight=0;
  data.sysMemSamples=0;
  final long[] totalMemUsage=mSysMemUsage.getTotalMemUsage();
  for (int is=0; is < data.screenStates.length; is++) {
    for (int im=0; im < data.memStates.length; im++) {
      int memBucket=data.screenStates[is] + data.memStates[im];
      int stateBucket=memBucket * STATE_COUNT;
      long memTime=mMemFactorDurations[memBucket];
      if (mMemFactor == memBucket) {
        memTime+=now - mStartTime;
      }
      data.totalTime+=memTime;
      final int sysKey=mSysMemUsage.getKey((byte)stateBucket);
      long[] longs=totalMemUsage;
      int idx=0;
      if (sysKey != SparseMappingTable.INVALID_KEY) {
        final long[] tmpLongs=mSysMemUsage.getArrayForKey(sysKey);
        final int tmpIndex=SparseMappingTable.getIndexFromKey(sysKey);
        if (tmpLongs[tmpIndex + SYS_MEM_USAGE_SAMPLE_COUNT] >= 3) {
          SysMemUsageTable.mergeSysMemUsage(data.sysMemUsage,0,longs,idx);
          longs=tmpLongs;
          idx=tmpIndex;
        }
      }
      data.sysMemCachedWeight+=longs[idx + SYS_MEM_USAGE_CACHED_AVERAGE] * (double)memTime;
      data.sysMemFreeWeight+=longs[idx + SYS_MEM_USAGE_FREE_AVERAGE] * (double)memTime;
      data.sysMemZRamWeight+=longs[idx + SYS_MEM_USAGE_ZRAM_AVERAGE] * (double)memTime;
      data.sysMemKernelWeight+=longs[idx + SYS_MEM_USAGE_KERNEL_AVERAGE] * (double)memTime;
      data.sysMemNativeWeight+=longs[idx + SYS_MEM_USAGE_NATIVE_AVERAGE] * (double)memTime;
      data.sysMemSamples+=longs[idx + SYS_MEM_USAGE_SAMPLE_COUNT];
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int iproc=0; iproc < procMap.size(); iproc++) {
    SparseArray<ProcessState> uids=procMap.valueAt(iproc);
    for (int iu=0; iu < uids.size(); iu++) {
      final ProcessState proc=uids.valueAt(iu);
      proc.aggregatePss(data,now);
    }
  }
}","public void computeTotalMemoryUse(TotalMemoryUseCollection data,long now){
  data.totalTime=0;
  for (int i=0; i < STATE_COUNT; i++) {
    data.processStateWeight[i]=0;
    data.processStatePss[i]=0;
    data.processStateTime[i]=0;
    data.processStateSamples[i]=0;
  }
  for (int i=0; i < SYS_MEM_USAGE_COUNT; i++) {
    data.sysMemUsage[i]=0;
  }
  data.sysMemCachedWeight=0;
  data.sysMemFreeWeight=0;
  data.sysMemZRamWeight=0;
  data.sysMemKernelWeight=0;
  data.sysMemNativeWeight=0;
  data.sysMemSamples=0;
  final long[] totalMemUsage=mSysMemUsage.getTotalMemUsage();
  for (int is=0; is < data.screenStates.length; is++) {
    for (int im=0; im < data.memStates.length; im++) {
      int memBucket=data.screenStates[is] + data.memStates[im];
      int stateBucket=memBucket * STATE_COUNT;
      long memTime=mMemFactorDurations[memBucket];
      if (mMemFactor == memBucket) {
        memTime+=now - mStartTime;
      }
      data.totalTime+=memTime;
      final int sysKey=mSysMemUsage.getKey((byte)stateBucket);
      long[] longs=totalMemUsage;
      int idx=0;
      if (sysKey != SparseMappingTable.INVALID_KEY) {
        final long[] tmpLongs=mSysMemUsage.getArrayForKey(sysKey);
        final int tmpIndex=SparseMappingTable.getIndexFromKey(sysKey);
        if (tmpLongs[tmpIndex + SYS_MEM_USAGE_SAMPLE_COUNT] >= 3) {
          SysMemUsageTable.mergeSysMemUsage(data.sysMemUsage,0,longs,idx);
          longs=tmpLongs;
          idx=tmpIndex;
        }
      }
      data.sysMemCachedWeight+=longs[idx + SYS_MEM_USAGE_CACHED_AVERAGE] * (double)memTime;
      data.sysMemFreeWeight+=longs[idx + SYS_MEM_USAGE_FREE_AVERAGE] * (double)memTime;
      data.sysMemZRamWeight+=longs[idx + SYS_MEM_USAGE_ZRAM_AVERAGE] * (double)memTime;
      data.sysMemKernelWeight+=longs[idx + SYS_MEM_USAGE_KERNEL_AVERAGE] * (double)memTime;
      data.sysMemNativeWeight+=longs[idx + SYS_MEM_USAGE_NATIVE_AVERAGE] * (double)memTime;
      data.sysMemSamples+=longs[idx + SYS_MEM_USAGE_SAMPLE_COUNT];
    }
  }
  data.hasSwappedOutPss=mHasSwappedOutPss;
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int iproc=0; iproc < procMap.size(); iproc++) {
    SparseArray<ProcessState> uids=procMap.valueAt(iproc);
    for (int iu=0; iu < uids.size(); iu++) {
      final ProcessState proc=uids.valueAt(iu);
      proc.aggregatePss(data,now);
    }
  }
}",0.990872426236468
191588,"public void readFromParcel(Parcel in){
  final boolean hadData=mPackages.getMap().size() > 0 || mProcesses.getMap().size() > 0;
  if (hadData) {
    resetSafely();
  }
  if (!readCheckedInt(in,MAGIC,""String_Node_Str"")) {
    return;
  }
  int version=in.readInt();
  if (version != PARCEL_VERSION) {
    mReadError=""String_Node_Str"" + version;
    return;
  }
  if (!readCheckedInt(in,STATE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,ADJ_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,PSS_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SYS_MEM_USAGE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SparseMappingTable.ARRAY_SIZE,""String_Node_Str"")) {
    return;
  }
  mIndexToCommonString=new ArrayList<String>();
  mTimePeriodStartClock=in.readLong();
  buildTimePeriodStartClockStr();
  mTimePeriodStartRealtime=in.readLong();
  mTimePeriodEndRealtime=in.readLong();
  mTimePeriodStartUptime=in.readLong();
  mTimePeriodEndUptime=in.readLong();
  mRuntime=in.readString();
  mFlags=in.readInt();
  mTableData.readFromParcel(in);
  readCompactedLongArray(in,version,mMemFactorDurations,mMemFactorDurations.length);
  if (!mSysMemUsage.readFromParcel(in)) {
    return;
  }
  int NPROC=in.readInt();
  if (NPROC < 0) {
    mReadError=""String_Node_Str"" + NPROC;
    return;
  }
  while (NPROC > 0) {
    NPROC--;
    final String procName=readCommonString(in,version);
    if (procName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      final String pkgName=readCommonString(in,version);
      if (pkgName == null) {
        mReadError=""String_Node_Str"";
        return;
      }
      final int vers=in.readInt();
      ProcessState proc=hadData ? mProcesses.get(procName,uid) : null;
      if (proc != null) {
        if (!proc.readFromParcel(in,false)) {
          return;
        }
      }
 else {
        proc=new ProcessState(this,pkgName,uid,vers,procName);
        if (!proc.readFromParcel(in,true)) {
          return;
        }
      }
      if (DEBUG_PARCEL)       Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
      mProcesses.put(procName,uid,proc);
    }
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + mProcesses.getMap().size() + ""String_Node_Str"");
  int NPKG=in.readInt();
  if (NPKG < 0) {
    mReadError=""String_Node_Str"" + NPKG;
    return;
  }
  while (NPKG > 0) {
    NPKG--;
    final String pkgName=readCommonString(in,version);
    if (pkgName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      int NVERS=in.readInt();
      if (NVERS < 0) {
        mReadError=""String_Node_Str"" + NVERS;
        return;
      }
      while (NVERS > 0) {
        NVERS--;
        final int vers=in.readInt();
        PackageState pkgState=new PackageState(pkgName,uid);
        SparseArray<PackageState> vpkg=mPackages.get(pkgName,uid);
        if (vpkg == null) {
          vpkg=new SparseArray<PackageState>();
          mPackages.put(pkgName,uid,vpkg);
        }
        vpkg.put(vers,pkgState);
        int NPROCS=in.readInt();
        if (NPROCS < 0) {
          mReadError=""String_Node_Str"" + NPROCS;
          return;
        }
        while (NPROCS > 0) {
          NPROCS--;
          String procName=readCommonString(in,version);
          if (procName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          int hasProc=in.readInt();
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ procName+ ""String_Node_Str""+ hasProc);
          ProcessState commonProc=mProcesses.get(procName,uid);
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
          if (commonProc == null) {
            mReadError=""String_Node_Str"" + procName;
            return;
          }
          if (hasProc != 0) {
            ProcessState proc=hadData ? pkgState.mProcesses.get(procName) : null;
            if (proc != null) {
              if (!proc.readFromParcel(in,false)) {
                return;
              }
            }
 else {
              proc=new ProcessState(commonProc,pkgName,uid,vers,procName,0);
              if (!proc.readFromParcel(in,true)) {
                return;
              }
            }
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
            pkgState.mProcesses.put(procName,proc);
          }
 else {
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
            pkgState.mProcesses.put(procName,commonProc);
          }
        }
        int NSRVS=in.readInt();
        if (NSRVS < 0) {
          mReadError=""String_Node_Str"" + NSRVS;
          return;
        }
        while (NSRVS > 0) {
          NSRVS--;
          String serviceName=in.readString();
          if (serviceName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          String processName=version > 9 ? readCommonString(in,version) : null;
          ServiceState serv=hadData ? pkgState.mServices.get(serviceName) : null;
          if (serv == null) {
            serv=new ServiceState(this,pkgName,serviceName,processName,null);
          }
          if (!serv.readFromParcel(in)) {
            return;
          }
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ serv);
          pkgState.mServices.put(serviceName,serv);
        }
      }
    }
  }
  mIndexToCommonString=null;
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"");
}","public void readFromParcel(Parcel in){
  final boolean hadData=mPackages.getMap().size() > 0 || mProcesses.getMap().size() > 0;
  if (hadData) {
    resetSafely();
  }
  if (!readCheckedInt(in,MAGIC,""String_Node_Str"")) {
    return;
  }
  int version=in.readInt();
  if (version != PARCEL_VERSION) {
    mReadError=""String_Node_Str"" + version;
    return;
  }
  if (!readCheckedInt(in,STATE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,ADJ_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,PSS_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SYS_MEM_USAGE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SparseMappingTable.ARRAY_SIZE,""String_Node_Str"")) {
    return;
  }
  mIndexToCommonString=new ArrayList<String>();
  mTimePeriodStartClock=in.readLong();
  buildTimePeriodStartClockStr();
  mTimePeriodStartRealtime=in.readLong();
  mTimePeriodEndRealtime=in.readLong();
  mTimePeriodStartUptime=in.readLong();
  mTimePeriodEndUptime=in.readLong();
  mRuntime=in.readString();
  mHasSwappedOutPss=in.readInt() != 0;
  mFlags=in.readInt();
  mTableData.readFromParcel(in);
  readCompactedLongArray(in,version,mMemFactorDurations,mMemFactorDurations.length);
  if (!mSysMemUsage.readFromParcel(in)) {
    return;
  }
  int NPROC=in.readInt();
  if (NPROC < 0) {
    mReadError=""String_Node_Str"" + NPROC;
    return;
  }
  while (NPROC > 0) {
    NPROC--;
    final String procName=readCommonString(in,version);
    if (procName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      final String pkgName=readCommonString(in,version);
      if (pkgName == null) {
        mReadError=""String_Node_Str"";
        return;
      }
      final int vers=in.readInt();
      ProcessState proc=hadData ? mProcesses.get(procName,uid) : null;
      if (proc != null) {
        if (!proc.readFromParcel(in,false)) {
          return;
        }
      }
 else {
        proc=new ProcessState(this,pkgName,uid,vers,procName);
        if (!proc.readFromParcel(in,true)) {
          return;
        }
      }
      if (DEBUG_PARCEL)       Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
      mProcesses.put(procName,uid,proc);
    }
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + mProcesses.getMap().size() + ""String_Node_Str"");
  int NPKG=in.readInt();
  if (NPKG < 0) {
    mReadError=""String_Node_Str"" + NPKG;
    return;
  }
  while (NPKG > 0) {
    NPKG--;
    final String pkgName=readCommonString(in,version);
    if (pkgName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      int NVERS=in.readInt();
      if (NVERS < 0) {
        mReadError=""String_Node_Str"" + NVERS;
        return;
      }
      while (NVERS > 0) {
        NVERS--;
        final int vers=in.readInt();
        PackageState pkgState=new PackageState(pkgName,uid);
        SparseArray<PackageState> vpkg=mPackages.get(pkgName,uid);
        if (vpkg == null) {
          vpkg=new SparseArray<PackageState>();
          mPackages.put(pkgName,uid,vpkg);
        }
        vpkg.put(vers,pkgState);
        int NPROCS=in.readInt();
        if (NPROCS < 0) {
          mReadError=""String_Node_Str"" + NPROCS;
          return;
        }
        while (NPROCS > 0) {
          NPROCS--;
          String procName=readCommonString(in,version);
          if (procName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          int hasProc=in.readInt();
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ procName+ ""String_Node_Str""+ hasProc);
          ProcessState commonProc=mProcesses.get(procName,uid);
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
          if (commonProc == null) {
            mReadError=""String_Node_Str"" + procName;
            return;
          }
          if (hasProc != 0) {
            ProcessState proc=hadData ? pkgState.mProcesses.get(procName) : null;
            if (proc != null) {
              if (!proc.readFromParcel(in,false)) {
                return;
              }
            }
 else {
              proc=new ProcessState(commonProc,pkgName,uid,vers,procName,0);
              if (!proc.readFromParcel(in,true)) {
                return;
              }
            }
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
            pkgState.mProcesses.put(procName,proc);
          }
 else {
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
            pkgState.mProcesses.put(procName,commonProc);
          }
        }
        int NSRVS=in.readInt();
        if (NSRVS < 0) {
          mReadError=""String_Node_Str"" + NSRVS;
          return;
        }
        while (NSRVS > 0) {
          NSRVS--;
          String serviceName=in.readString();
          if (serviceName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          String processName=version > 9 ? readCommonString(in,version) : null;
          ServiceState serv=hadData ? pkgState.mServices.get(serviceName) : null;
          if (serv == null) {
            serv=new ServiceState(this,pkgName,serviceName,processName,null);
          }
          if (!serv.readFromParcel(in)) {
            return;
          }
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ serv);
          pkgState.mServices.put(serviceName,serv);
        }
      }
    }
  }
  mIndexToCommonString=null;
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"");
}",0.9969821248936006
191589,"public void dumpCheckinLocked(PrintWriter pw,String reqPackage){
  final long now=SystemClock.uptimeMillis();
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartClockStr);
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartRealtime);
  pw.print(""String_Node_Str"");
  pw.print(mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.println(mRuntime);
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      for (int iv=0; iv < vpkgs.size(); iv++) {
        final int vers=vpkgs.keyAt(iv);
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        final int NSRVS=pkgState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          proc.dumpPackageProcCheckin(pw,pkgName,uid,vers,pkgState.mProcesses.keyAt(iproc),now);
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          final String serviceName=DumpUtils.collapseString(pkgName,pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          svc.dumpTimesCheckin(pw,pkgName,uid,vers,serviceName,now);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final ProcessState procState=uids.valueAt(iu);
      procState.dumpProcCheckin(pw,procName,uid,now);
    }
  }
  pw.print(""String_Node_Str"");
  DumpUtils.dumpAdjTimesCheckin(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  final int sysMemUsageCount=mSysMemUsage.getKeyCount();
  if (sysMemUsageCount > 0) {
    pw.print(""String_Node_Str"");
    for (int i=0; i < sysMemUsageCount; i++) {
      final int key=mSysMemUsage.getKeyAt(i);
      final int type=SparseMappingTable.getIdFromKey(key);
      pw.print(""String_Node_Str"");
      DumpUtils.printProcStateTag(pw,type);
      for (int j=SYS_MEM_USAGE_SAMPLE_COUNT; j < SYS_MEM_USAGE_COUNT; j++) {
        if (j > SYS_MEM_USAGE_CACHED_MINIMUM) {
          pw.print(""String_Node_Str"");
        }
        pw.print(mSysMemUsage.getValue(key,j));
      }
    }
  }
  pw.println();
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.totalTime);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemCachedWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemFreeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemZRamWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemKernelWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemNativeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateWeight[i]);
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateSamples[i]);
  }
  pw.println();
}","public void dumpCheckinLocked(PrintWriter pw,String reqPackage){
  final long now=SystemClock.uptimeMillis();
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartClockStr);
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartRealtime);
  pw.print(""String_Node_Str"");
  pw.print(mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  if (mHasSwappedOutPss) {
    pw.print(""String_Node_Str"");
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.println(mRuntime);
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      for (int iv=0; iv < vpkgs.size(); iv++) {
        final int vers=vpkgs.keyAt(iv);
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        final int NSRVS=pkgState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          proc.dumpPackageProcCheckin(pw,pkgName,uid,vers,pkgState.mProcesses.keyAt(iproc),now);
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          final String serviceName=DumpUtils.collapseString(pkgName,pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          svc.dumpTimesCheckin(pw,pkgName,uid,vers,serviceName,now);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final ProcessState procState=uids.valueAt(iu);
      procState.dumpProcCheckin(pw,procName,uid,now);
    }
  }
  pw.print(""String_Node_Str"");
  DumpUtils.dumpAdjTimesCheckin(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  final int sysMemUsageCount=mSysMemUsage.getKeyCount();
  if (sysMemUsageCount > 0) {
    pw.print(""String_Node_Str"");
    for (int i=0; i < sysMemUsageCount; i++) {
      final int key=mSysMemUsage.getKeyAt(i);
      final int type=SparseMappingTable.getIdFromKey(key);
      pw.print(""String_Node_Str"");
      DumpUtils.printProcStateTag(pw,type);
      for (int j=SYS_MEM_USAGE_SAMPLE_COUNT; j < SYS_MEM_USAGE_COUNT; j++) {
        if (j > SYS_MEM_USAGE_CACHED_MINIMUM) {
          pw.print(""String_Node_Str"");
        }
        pw.print(mSysMemUsage.getValue(key,j));
      }
    }
  }
  pw.println();
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.totalTime);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemCachedWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemFreeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemZRamWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemKernelWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemNativeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateWeight[i]);
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateSamples[i]);
  }
  pw.println();
}",0.9927206551410374
191590,"/** 
 * @hide 
 */
public void writeToParcel(Parcel out,long now,int flags){
  out.writeInt(MAGIC);
  out.writeInt(PARCEL_VERSION);
  out.writeInt(STATE_COUNT);
  out.writeInt(ADJ_COUNT);
  out.writeInt(PSS_COUNT);
  out.writeInt(SYS_MEM_USAGE_COUNT);
  out.writeInt(SparseMappingTable.ARRAY_SIZE);
  mCommonStringToIndex=new ArrayMap<String,Integer>(mProcesses.size());
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  final int NPROC=procMap.size();
  for (int ip=0; ip < NPROC; ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      uids.valueAt(iu).commitStateTime(now);
    }
  }
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  final int NPKG=pkgMap.size();
  for (int ip=0; ip < NPKG; ip++) {
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      for (int iv=0; iv < NVERS; iv++) {
        PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() != proc) {
            proc.commitStateTime(now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        for (int isvc=0; isvc < NSRVS; isvc++) {
          pkgState.mServices.valueAt(isvc).commitStateTime(now);
        }
      }
    }
  }
  out.writeLong(mTimePeriodStartClock);
  out.writeLong(mTimePeriodStartRealtime);
  out.writeLong(mTimePeriodEndRealtime);
  out.writeLong(mTimePeriodStartUptime);
  out.writeLong(mTimePeriodEndUptime);
  out.writeString(mRuntime);
  out.writeInt(mFlags);
  mTableData.writeToParcel(out);
  if (mMemFactor != STATE_NOTHING) {
    mMemFactorDurations[mMemFactor]+=now - mStartTime;
    mStartTime=now;
  }
  writeCompactedLongArray(out,mMemFactorDurations,mMemFactorDurations.length);
  mSysMemUsage.writeToParcel(out);
  out.writeInt(NPROC);
  for (int ip=0; ip < NPROC; ip++) {
    writeCommonString(out,procMap.keyAt(ip));
    final SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final ProcessState proc=uids.valueAt(iu);
      writeCommonString(out,proc.getPackage());
      out.writeInt(proc.getVersion());
      proc.writeToParcel(out,now);
    }
  }
  out.writeInt(NPKG);
  for (int ip=0; ip < NPKG; ip++) {
    writeCommonString(out,pkgMap.keyAt(ip));
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      out.writeInt(NVERS);
      for (int iv=0; iv < NVERS; iv++) {
        out.writeInt(vpkgs.keyAt(iv));
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        out.writeInt(NPROCS);
        for (int iproc=0; iproc < NPROCS; iproc++) {
          writeCommonString(out,pkgState.mProcesses.keyAt(iproc));
          final ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() == proc) {
            out.writeInt(0);
          }
 else {
            out.writeInt(1);
            proc.writeToParcel(out,now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        out.writeInt(NSRVS);
        for (int isvc=0; isvc < NSRVS; isvc++) {
          out.writeString(pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          writeCommonString(out,svc.getProcessName());
          svc.writeToParcel(out,now);
        }
      }
    }
  }
  mCommonStringToIndex=null;
}","/** 
 * @hide 
 */
public void writeToParcel(Parcel out,long now,int flags){
  out.writeInt(MAGIC);
  out.writeInt(PARCEL_VERSION);
  out.writeInt(STATE_COUNT);
  out.writeInt(ADJ_COUNT);
  out.writeInt(PSS_COUNT);
  out.writeInt(SYS_MEM_USAGE_COUNT);
  out.writeInt(SparseMappingTable.ARRAY_SIZE);
  mCommonStringToIndex=new ArrayMap<String,Integer>(mProcesses.size());
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  final int NPROC=procMap.size();
  for (int ip=0; ip < NPROC; ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      uids.valueAt(iu).commitStateTime(now);
    }
  }
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  final int NPKG=pkgMap.size();
  for (int ip=0; ip < NPKG; ip++) {
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      for (int iv=0; iv < NVERS; iv++) {
        PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() != proc) {
            proc.commitStateTime(now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        for (int isvc=0; isvc < NSRVS; isvc++) {
          pkgState.mServices.valueAt(isvc).commitStateTime(now);
        }
      }
    }
  }
  out.writeLong(mTimePeriodStartClock);
  out.writeLong(mTimePeriodStartRealtime);
  out.writeLong(mTimePeriodEndRealtime);
  out.writeLong(mTimePeriodStartUptime);
  out.writeLong(mTimePeriodEndUptime);
  out.writeString(mRuntime);
  out.writeInt(mHasSwappedOutPss ? 1 : 0);
  out.writeInt(mFlags);
  mTableData.writeToParcel(out);
  if (mMemFactor != STATE_NOTHING) {
    mMemFactorDurations[mMemFactor]+=now - mStartTime;
    mStartTime=now;
  }
  writeCompactedLongArray(out,mMemFactorDurations,mMemFactorDurations.length);
  mSysMemUsage.writeToParcel(out);
  out.writeInt(NPROC);
  for (int ip=0; ip < NPROC; ip++) {
    writeCommonString(out,procMap.keyAt(ip));
    final SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final ProcessState proc=uids.valueAt(iu);
      writeCommonString(out,proc.getPackage());
      out.writeInt(proc.getVersion());
      proc.writeToParcel(out,now);
    }
  }
  out.writeInt(NPKG);
  for (int ip=0; ip < NPKG; ip++) {
    writeCommonString(out,pkgMap.keyAt(ip));
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      out.writeInt(NVERS);
      for (int iv=0; iv < NVERS; iv++) {
        out.writeInt(vpkgs.keyAt(iv));
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        out.writeInt(NPROCS);
        for (int iproc=0; iproc < NPROCS; iproc++) {
          writeCommonString(out,pkgState.mProcesses.keyAt(iproc));
          final ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() == proc) {
            out.writeInt(0);
          }
 else {
            out.writeInt(1);
            proc.writeToParcel(out,now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        out.writeInt(NSRVS);
        for (int isvc=0; isvc < NSRVS; isvc++) {
          out.writeString(pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          writeCommonString(out,svc.getProcessName());
          svc.writeToParcel(out,now);
        }
      }
    }
  }
  mCommonStringToIndex=null;
}",0.9947771164824488
191591,"void dumpTotalsLocked(PrintWriter pw,long now){
  pw.println(""String_Node_Str"");
  DumpUtils.dumpSingleTime(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  pw.println(""String_Node_Str"");
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  long totalPss=0;
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemKernelWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemNativeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    if (i != STATE_SERVICE_RESTARTING) {
      totalPss=printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[i],totalMem.processStateWeight[i],totalMem.totalTime,totalPss,totalMem.processStateSamples[i]);
    }
  }
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemCachedWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemFreeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemZRamWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,totalPss);
  pw.println();
  printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[STATE_SERVICE_RESTARTING],totalMem.processStateWeight[STATE_SERVICE_RESTARTING],totalMem.totalTime,totalPss,totalMem.processStateSamples[STATE_SERVICE_RESTARTING]);
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(DateFormat.format(""String_Node_Str"",mTimePeriodStartClock));
  pw.println();
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration((mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime) - mTimePeriodStartRealtime,pw);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  pw.print(' ');
  pw.print(mRuntime);
  pw.println();
}","void dumpTotalsLocked(PrintWriter pw,long now){
  pw.println(""String_Node_Str"");
  DumpUtils.dumpSingleTime(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  pw.println(""String_Node_Str"");
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  long totalPss=0;
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemKernelWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemNativeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    if (i != STATE_SERVICE_RESTARTING) {
      totalPss=printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[i],totalMem.processStateWeight[i],totalMem.totalTime,totalPss,totalMem.processStateSamples[i]);
    }
  }
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemCachedWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemFreeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemZRamWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,totalPss);
  pw.println();
  printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[STATE_SERVICE_RESTARTING],totalMem.processStateWeight[STATE_SERVICE_RESTARTING],totalMem.totalTime,totalPss,totalMem.processStateSamples[STATE_SERVICE_RESTARTING]);
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(DateFormat.format(""String_Node_Str"",mTimePeriodStartClock));
  pw.println();
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration((mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime) - mTimePeriodStartRealtime,pw);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  if (mHasSwappedOutPss) {
    pw.print(""String_Node_Str"");
  }
  pw.print(' ');
  pw.print(mRuntime);
  pw.println();
}",0.986975986975987
191592,"@Override public void flingTopOverscroll(float velocity,boolean open){
  mLastOverscroll=0f;
  setQsExpansion(mQsExpansionHeight);
  flingSettings(!mQsExpansionEnabled && open ? 0f : velocity,open && mQsExpansionEnabled,new Runnable(){
    @Override public void run(){
      mStackScrollerOverscrolling=false;
      setOverScrolling(false);
      updateQsState();
    }
  }
,false);
}","@Override public void flingTopOverscroll(float velocity,boolean open){
  mLastOverscroll=0f;
  mQsExpansionFromOverscroll=false;
  setQsExpansion(mQsExpansionHeight);
  flingSettings(!mQsExpansionEnabled && open ? 0f : velocity,open && mQsExpansionEnabled,new Runnable(){
    @Override public void run(){
      mStackScrollerOverscrolling=false;
      setOverScrolling(false);
      updateQsState();
    }
  }
,false);
}",0.9552238805970148
191593,"@Override public void flingTopOverscroll(float velocity,boolean open){
  mLastOverscroll=0f;
  setQsExpansion(mQsExpansionHeight);
  flingSettings(!mQsExpansionEnabled && open ? 0f : velocity,open && mQsExpansionEnabled,new Runnable(){
    @Override public void run(){
      mStackScrollerOverscrolling=false;
      setOverScrolling(false);
      updateQsState();
    }
  }
,false);
}","@Override public void flingTopOverscroll(float velocity,boolean open){
  mLastOverscroll=0f;
  mQsExpansionFromOverscroll=false;
  setQsExpansion(mQsExpansionHeight);
  flingSettings(!mQsExpansionEnabled && open ? 0f : velocity,open && mQsExpansionEnabled,new Runnable(){
    @Override public void run(){
      mStackScrollerOverscrolling=false;
      setOverScrolling(false);
      updateQsState();
    }
  }
,false);
}",0.9552238805970148
191594,"public void add(ProcessStats other){
  ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=other.mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> versions=uids.valueAt(iu);
      for (int iv=0; iv < versions.size(); iv++) {
        final int vers=versions.keyAt(iv);
        final PackageState otherState=versions.valueAt(iv);
        final int NPROCS=otherState.mProcesses.size();
        final int NSRVS=otherState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState otherProc=otherState.mProcesses.valueAt(iproc);
          if (otherProc.getCommonProcess() != otherProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ vers+ ""String_Node_Str""+ otherProc.getName());
            ProcessState thisProc=getProcessStateLocked(pkgName,uid,vers,otherProc.getName());
            if (thisProc.getCommonProcess() == thisProc) {
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"");
              thisProc.setMultiPackage(true);
              long now=SystemClock.uptimeMillis();
              final PackageState pkgState=getPackageStateLocked(pkgName,uid,vers);
              thisProc=thisProc.clone(now);
              pkgState.mProcesses.put(thisProc.getName(),thisProc);
            }
            thisProc.add(otherProc);
          }
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          ServiceState otherSvc=otherState.mServices.valueAt(isvc);
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ otherSvc.getName());
          ServiceState thisSvc=getServiceStateLocked(pkgName,uid,vers,otherSvc.getProcessName(),otherSvc.getName());
          thisSvc.add(otherSvc);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=other.mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      ProcessState otherProc=uids.valueAt(iu);
      final String name=otherProc.getName();
      final String pkg=otherProc.getPackage();
      final int vers=otherProc.getVersion();
      ProcessState thisProc=mProcesses.get(name,uid);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ name);
      if (thisProc == null) {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"");
        thisProc=new ProcessState(this,pkg,uid,vers,name);
        mProcesses.put(name,uid,thisProc);
        PackageState thisState=getPackageStateLocked(pkg,uid,vers);
        if (!thisState.mProcesses.containsKey(name)) {
          thisState.mProcesses.put(name,thisProc);
        }
      }
      thisProc.add(otherProc);
    }
  }
  for (int i=0; i < ADJ_COUNT; i++) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ other.mMemFactorDurations[i]+ ""String_Node_Str""+ mMemFactorDurations[i]);
    mMemFactorDurations[i]+=other.mMemFactorDurations[i];
  }
  mSysMemUsage.mergeStats(other.mSysMemUsage);
  if (other.mTimePeriodStartClock < mTimePeriodStartClock) {
    mTimePeriodStartClock=other.mTimePeriodStartClock;
    mTimePeriodStartClockStr=other.mTimePeriodStartClockStr;
  }
  mTimePeriodEndRealtime+=other.mTimePeriodEndRealtime - other.mTimePeriodStartRealtime;
  mTimePeriodEndUptime+=other.mTimePeriodEndUptime - other.mTimePeriodStartUptime;
}","public void add(ProcessStats other){
  ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=other.mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> versions=uids.valueAt(iu);
      for (int iv=0; iv < versions.size(); iv++) {
        final int vers=versions.keyAt(iv);
        final PackageState otherState=versions.valueAt(iv);
        final int NPROCS=otherState.mProcesses.size();
        final int NSRVS=otherState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState otherProc=otherState.mProcesses.valueAt(iproc);
          if (otherProc.getCommonProcess() != otherProc) {
            if (DEBUG)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ vers+ ""String_Node_Str""+ otherProc.getName());
            ProcessState thisProc=getProcessStateLocked(pkgName,uid,vers,otherProc.getName());
            if (thisProc.getCommonProcess() == thisProc) {
              if (DEBUG)               Slog.d(TAG,""String_Node_Str"");
              thisProc.setMultiPackage(true);
              long now=SystemClock.uptimeMillis();
              final PackageState pkgState=getPackageStateLocked(pkgName,uid,vers);
              thisProc=thisProc.clone(now);
              pkgState.mProcesses.put(thisProc.getName(),thisProc);
            }
            thisProc.add(otherProc);
          }
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          ServiceState otherSvc=otherState.mServices.valueAt(isvc);
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ otherSvc.getName());
          ServiceState thisSvc=getServiceStateLocked(pkgName,uid,vers,otherSvc.getProcessName(),otherSvc.getName());
          thisSvc.add(otherSvc);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=other.mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      ProcessState otherProc=uids.valueAt(iu);
      final String name=otherProc.getName();
      final String pkg=otherProc.getPackage();
      final int vers=otherProc.getVersion();
      ProcessState thisProc=mProcesses.get(name,uid);
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + uid + ""String_Node_Str""+ name);
      if (thisProc == null) {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"");
        thisProc=new ProcessState(this,pkg,uid,vers,name);
        mProcesses.put(name,uid,thisProc);
        PackageState thisState=getPackageStateLocked(pkg,uid,vers);
        if (!thisState.mProcesses.containsKey(name)) {
          thisState.mProcesses.put(name,thisProc);
        }
      }
      thisProc.add(otherProc);
    }
  }
  for (int i=0; i < ADJ_COUNT; i++) {
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ other.mMemFactorDurations[i]+ ""String_Node_Str""+ mMemFactorDurations[i]);
    mMemFactorDurations[i]+=other.mMemFactorDurations[i];
  }
  mSysMemUsage.mergeStats(other.mSysMemUsage);
  if (other.mTimePeriodStartClock < mTimePeriodStartClock) {
    mTimePeriodStartClock=other.mTimePeriodStartClock;
    mTimePeriodStartClockStr=other.mTimePeriodStartClockStr;
  }
  mTimePeriodEndRealtime+=other.mTimePeriodEndRealtime - other.mTimePeriodStartRealtime;
  mTimePeriodEndUptime+=other.mTimePeriodEndUptime - other.mTimePeriodStartUptime;
  mHasSwappedOutPss|=other.mHasSwappedOutPss;
}",0.9938535542490646
191595,"public void computeTotalMemoryUse(TotalMemoryUseCollection data,long now){
  data.totalTime=0;
  for (int i=0; i < STATE_COUNT; i++) {
    data.processStateWeight[i]=0;
    data.processStatePss[i]=0;
    data.processStateTime[i]=0;
    data.processStateSamples[i]=0;
  }
  for (int i=0; i < SYS_MEM_USAGE_COUNT; i++) {
    data.sysMemUsage[i]=0;
  }
  data.sysMemCachedWeight=0;
  data.sysMemFreeWeight=0;
  data.sysMemZRamWeight=0;
  data.sysMemKernelWeight=0;
  data.sysMemNativeWeight=0;
  data.sysMemSamples=0;
  final long[] totalMemUsage=mSysMemUsage.getTotalMemUsage();
  for (int is=0; is < data.screenStates.length; is++) {
    for (int im=0; im < data.memStates.length; im++) {
      int memBucket=data.screenStates[is] + data.memStates[im];
      int stateBucket=memBucket * STATE_COUNT;
      long memTime=mMemFactorDurations[memBucket];
      if (mMemFactor == memBucket) {
        memTime+=now - mStartTime;
      }
      data.totalTime+=memTime;
      final int sysKey=mSysMemUsage.getKey((byte)stateBucket);
      long[] longs=totalMemUsage;
      int idx=0;
      if (sysKey != SparseMappingTable.INVALID_KEY) {
        final long[] tmpLongs=mSysMemUsage.getArrayForKey(sysKey);
        final int tmpIndex=SparseMappingTable.getIndexFromKey(sysKey);
        if (tmpLongs[tmpIndex + SYS_MEM_USAGE_SAMPLE_COUNT] >= 3) {
          SysMemUsageTable.mergeSysMemUsage(data.sysMemUsage,0,longs,idx);
          longs=tmpLongs;
          idx=tmpIndex;
        }
      }
      data.sysMemCachedWeight+=longs[idx + SYS_MEM_USAGE_CACHED_AVERAGE] * (double)memTime;
      data.sysMemFreeWeight+=longs[idx + SYS_MEM_USAGE_FREE_AVERAGE] * (double)memTime;
      data.sysMemZRamWeight+=longs[idx + SYS_MEM_USAGE_ZRAM_AVERAGE] * (double)memTime;
      data.sysMemKernelWeight+=longs[idx + SYS_MEM_USAGE_KERNEL_AVERAGE] * (double)memTime;
      data.sysMemNativeWeight+=longs[idx + SYS_MEM_USAGE_NATIVE_AVERAGE] * (double)memTime;
      data.sysMemSamples+=longs[idx + SYS_MEM_USAGE_SAMPLE_COUNT];
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int iproc=0; iproc < procMap.size(); iproc++) {
    SparseArray<ProcessState> uids=procMap.valueAt(iproc);
    for (int iu=0; iu < uids.size(); iu++) {
      final ProcessState proc=uids.valueAt(iu);
      proc.aggregatePss(data,now);
    }
  }
}","public void computeTotalMemoryUse(TotalMemoryUseCollection data,long now){
  data.totalTime=0;
  for (int i=0; i < STATE_COUNT; i++) {
    data.processStateWeight[i]=0;
    data.processStatePss[i]=0;
    data.processStateTime[i]=0;
    data.processStateSamples[i]=0;
  }
  for (int i=0; i < SYS_MEM_USAGE_COUNT; i++) {
    data.sysMemUsage[i]=0;
  }
  data.sysMemCachedWeight=0;
  data.sysMemFreeWeight=0;
  data.sysMemZRamWeight=0;
  data.sysMemKernelWeight=0;
  data.sysMemNativeWeight=0;
  data.sysMemSamples=0;
  final long[] totalMemUsage=mSysMemUsage.getTotalMemUsage();
  for (int is=0; is < data.screenStates.length; is++) {
    for (int im=0; im < data.memStates.length; im++) {
      int memBucket=data.screenStates[is] + data.memStates[im];
      int stateBucket=memBucket * STATE_COUNT;
      long memTime=mMemFactorDurations[memBucket];
      if (mMemFactor == memBucket) {
        memTime+=now - mStartTime;
      }
      data.totalTime+=memTime;
      final int sysKey=mSysMemUsage.getKey((byte)stateBucket);
      long[] longs=totalMemUsage;
      int idx=0;
      if (sysKey != SparseMappingTable.INVALID_KEY) {
        final long[] tmpLongs=mSysMemUsage.getArrayForKey(sysKey);
        final int tmpIndex=SparseMappingTable.getIndexFromKey(sysKey);
        if (tmpLongs[tmpIndex + SYS_MEM_USAGE_SAMPLE_COUNT] >= 3) {
          SysMemUsageTable.mergeSysMemUsage(data.sysMemUsage,0,longs,idx);
          longs=tmpLongs;
          idx=tmpIndex;
        }
      }
      data.sysMemCachedWeight+=longs[idx + SYS_MEM_USAGE_CACHED_AVERAGE] * (double)memTime;
      data.sysMemFreeWeight+=longs[idx + SYS_MEM_USAGE_FREE_AVERAGE] * (double)memTime;
      data.sysMemZRamWeight+=longs[idx + SYS_MEM_USAGE_ZRAM_AVERAGE] * (double)memTime;
      data.sysMemKernelWeight+=longs[idx + SYS_MEM_USAGE_KERNEL_AVERAGE] * (double)memTime;
      data.sysMemNativeWeight+=longs[idx + SYS_MEM_USAGE_NATIVE_AVERAGE] * (double)memTime;
      data.sysMemSamples+=longs[idx + SYS_MEM_USAGE_SAMPLE_COUNT];
    }
  }
  data.hasSwappedOutPss=mHasSwappedOutPss;
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int iproc=0; iproc < procMap.size(); iproc++) {
    SparseArray<ProcessState> uids=procMap.valueAt(iproc);
    for (int iu=0; iu < uids.size(); iu++) {
      final ProcessState proc=uids.valueAt(iu);
      proc.aggregatePss(data,now);
    }
  }
}",0.990872426236468
191596,"public void readFromParcel(Parcel in){
  final boolean hadData=mPackages.getMap().size() > 0 || mProcesses.getMap().size() > 0;
  if (hadData) {
    resetSafely();
  }
  if (!readCheckedInt(in,MAGIC,""String_Node_Str"")) {
    return;
  }
  int version=in.readInt();
  if (version != PARCEL_VERSION) {
    mReadError=""String_Node_Str"" + version;
    return;
  }
  if (!readCheckedInt(in,STATE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,ADJ_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,PSS_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SYS_MEM_USAGE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SparseMappingTable.ARRAY_SIZE,""String_Node_Str"")) {
    return;
  }
  mIndexToCommonString=new ArrayList<String>();
  mTimePeriodStartClock=in.readLong();
  buildTimePeriodStartClockStr();
  mTimePeriodStartRealtime=in.readLong();
  mTimePeriodEndRealtime=in.readLong();
  mTimePeriodStartUptime=in.readLong();
  mTimePeriodEndUptime=in.readLong();
  mRuntime=in.readString();
  mFlags=in.readInt();
  mTableData.readFromParcel(in);
  readCompactedLongArray(in,version,mMemFactorDurations,mMemFactorDurations.length);
  if (!mSysMemUsage.readFromParcel(in)) {
    return;
  }
  int NPROC=in.readInt();
  if (NPROC < 0) {
    mReadError=""String_Node_Str"" + NPROC;
    return;
  }
  while (NPROC > 0) {
    NPROC--;
    final String procName=readCommonString(in,version);
    if (procName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      final String pkgName=readCommonString(in,version);
      if (pkgName == null) {
        mReadError=""String_Node_Str"";
        return;
      }
      final int vers=in.readInt();
      ProcessState proc=hadData ? mProcesses.get(procName,uid) : null;
      if (proc != null) {
        if (!proc.readFromParcel(in,false)) {
          return;
        }
      }
 else {
        proc=new ProcessState(this,pkgName,uid,vers,procName);
        if (!proc.readFromParcel(in,true)) {
          return;
        }
      }
      if (DEBUG_PARCEL)       Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
      mProcesses.put(procName,uid,proc);
    }
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + mProcesses.getMap().size() + ""String_Node_Str"");
  int NPKG=in.readInt();
  if (NPKG < 0) {
    mReadError=""String_Node_Str"" + NPKG;
    return;
  }
  while (NPKG > 0) {
    NPKG--;
    final String pkgName=readCommonString(in,version);
    if (pkgName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      int NVERS=in.readInt();
      if (NVERS < 0) {
        mReadError=""String_Node_Str"" + NVERS;
        return;
      }
      while (NVERS > 0) {
        NVERS--;
        final int vers=in.readInt();
        PackageState pkgState=new PackageState(pkgName,uid);
        SparseArray<PackageState> vpkg=mPackages.get(pkgName,uid);
        if (vpkg == null) {
          vpkg=new SparseArray<PackageState>();
          mPackages.put(pkgName,uid,vpkg);
        }
        vpkg.put(vers,pkgState);
        int NPROCS=in.readInt();
        if (NPROCS < 0) {
          mReadError=""String_Node_Str"" + NPROCS;
          return;
        }
        while (NPROCS > 0) {
          NPROCS--;
          String procName=readCommonString(in,version);
          if (procName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          int hasProc=in.readInt();
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ procName+ ""String_Node_Str""+ hasProc);
          ProcessState commonProc=mProcesses.get(procName,uid);
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
          if (commonProc == null) {
            mReadError=""String_Node_Str"" + procName;
            return;
          }
          if (hasProc != 0) {
            ProcessState proc=hadData ? pkgState.mProcesses.get(procName) : null;
            if (proc != null) {
              if (!proc.readFromParcel(in,false)) {
                return;
              }
            }
 else {
              proc=new ProcessState(commonProc,pkgName,uid,vers,procName,0);
              if (!proc.readFromParcel(in,true)) {
                return;
              }
            }
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
            pkgState.mProcesses.put(procName,proc);
          }
 else {
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
            pkgState.mProcesses.put(procName,commonProc);
          }
        }
        int NSRVS=in.readInt();
        if (NSRVS < 0) {
          mReadError=""String_Node_Str"" + NSRVS;
          return;
        }
        while (NSRVS > 0) {
          NSRVS--;
          String serviceName=in.readString();
          if (serviceName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          String processName=version > 9 ? readCommonString(in,version) : null;
          ServiceState serv=hadData ? pkgState.mServices.get(serviceName) : null;
          if (serv == null) {
            serv=new ServiceState(this,pkgName,serviceName,processName,null);
          }
          if (!serv.readFromParcel(in)) {
            return;
          }
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ serv);
          pkgState.mServices.put(serviceName,serv);
        }
      }
    }
  }
  mIndexToCommonString=null;
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"");
}","public void readFromParcel(Parcel in){
  final boolean hadData=mPackages.getMap().size() > 0 || mProcesses.getMap().size() > 0;
  if (hadData) {
    resetSafely();
  }
  if (!readCheckedInt(in,MAGIC,""String_Node_Str"")) {
    return;
  }
  int version=in.readInt();
  if (version != PARCEL_VERSION) {
    mReadError=""String_Node_Str"" + version;
    return;
  }
  if (!readCheckedInt(in,STATE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,ADJ_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,PSS_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SYS_MEM_USAGE_COUNT,""String_Node_Str"")) {
    return;
  }
  if (!readCheckedInt(in,SparseMappingTable.ARRAY_SIZE,""String_Node_Str"")) {
    return;
  }
  mIndexToCommonString=new ArrayList<String>();
  mTimePeriodStartClock=in.readLong();
  buildTimePeriodStartClockStr();
  mTimePeriodStartRealtime=in.readLong();
  mTimePeriodEndRealtime=in.readLong();
  mTimePeriodStartUptime=in.readLong();
  mTimePeriodEndUptime=in.readLong();
  mRuntime=in.readString();
  mHasSwappedOutPss=in.readInt() != 0;
  mFlags=in.readInt();
  mTableData.readFromParcel(in);
  readCompactedLongArray(in,version,mMemFactorDurations,mMemFactorDurations.length);
  if (!mSysMemUsage.readFromParcel(in)) {
    return;
  }
  int NPROC=in.readInt();
  if (NPROC < 0) {
    mReadError=""String_Node_Str"" + NPROC;
    return;
  }
  while (NPROC > 0) {
    NPROC--;
    final String procName=readCommonString(in,version);
    if (procName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      final String pkgName=readCommonString(in,version);
      if (pkgName == null) {
        mReadError=""String_Node_Str"";
        return;
      }
      final int vers=in.readInt();
      ProcessState proc=hadData ? mProcesses.get(procName,uid) : null;
      if (proc != null) {
        if (!proc.readFromParcel(in,false)) {
          return;
        }
      }
 else {
        proc=new ProcessState(this,pkgName,uid,vers,procName);
        if (!proc.readFromParcel(in,true)) {
          return;
        }
      }
      if (DEBUG_PARCEL)       Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
      mProcesses.put(procName,uid,proc);
    }
  }
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"" + mProcesses.getMap().size() + ""String_Node_Str"");
  int NPKG=in.readInt();
  if (NPKG < 0) {
    mReadError=""String_Node_Str"" + NPKG;
    return;
  }
  while (NPKG > 0) {
    NPKG--;
    final String pkgName=readCommonString(in,version);
    if (pkgName == null) {
      mReadError=""String_Node_Str"";
      return;
    }
    int NUID=in.readInt();
    if (NUID < 0) {
      mReadError=""String_Node_Str"" + NUID;
      return;
    }
    while (NUID > 0) {
      NUID--;
      final int uid=in.readInt();
      if (uid < 0) {
        mReadError=""String_Node_Str"" + uid;
        return;
      }
      int NVERS=in.readInt();
      if (NVERS < 0) {
        mReadError=""String_Node_Str"" + NVERS;
        return;
      }
      while (NVERS > 0) {
        NVERS--;
        final int vers=in.readInt();
        PackageState pkgState=new PackageState(pkgName,uid);
        SparseArray<PackageState> vpkg=mPackages.get(pkgName,uid);
        if (vpkg == null) {
          vpkg=new SparseArray<PackageState>();
          mPackages.put(pkgName,uid,vpkg);
        }
        vpkg.put(vers,pkgState);
        int NPROCS=in.readInt();
        if (NPROCS < 0) {
          mReadError=""String_Node_Str"" + NPROCS;
          return;
        }
        while (NPROCS > 0) {
          NPROCS--;
          String procName=readCommonString(in,version);
          if (procName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          int hasProc=in.readInt();
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ procName+ ""String_Node_Str""+ hasProc);
          ProcessState commonProc=mProcesses.get(procName,uid);
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + procName + ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
          if (commonProc == null) {
            mReadError=""String_Node_Str"" + procName;
            return;
          }
          if (hasProc != 0) {
            ProcessState proc=hadData ? pkgState.mProcesses.get(procName) : null;
            if (proc != null) {
              if (!proc.readFromParcel(in,false)) {
                return;
              }
            }
 else {
              proc=new ProcessState(commonProc,pkgName,uid,vers,procName,0);
              if (!proc.readFromParcel(in,true)) {
                return;
              }
            }
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ proc);
            pkgState.mProcesses.put(procName,proc);
          }
 else {
            if (DEBUG_PARCEL)             Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ procName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ commonProc);
            pkgState.mProcesses.put(procName,commonProc);
          }
        }
        int NSRVS=in.readInt();
        if (NSRVS < 0) {
          mReadError=""String_Node_Str"" + NSRVS;
          return;
        }
        while (NSRVS > 0) {
          NSRVS--;
          String serviceName=in.readString();
          if (serviceName == null) {
            mReadError=""String_Node_Str"";
            return;
          }
          String processName=version > 9 ? readCommonString(in,version) : null;
          ServiceState serv=hadData ? pkgState.mServices.get(serviceName) : null;
          if (serv == null) {
            serv=new ServiceState(this,pkgName,serviceName,processName,null);
          }
          if (!serv.readFromParcel(in)) {
            return;
          }
          if (DEBUG_PARCEL)           Slog.d(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ serv);
          pkgState.mServices.put(serviceName,serv);
        }
      }
    }
  }
  mIndexToCommonString=null;
  if (DEBUG_PARCEL)   Slog.d(TAG,""String_Node_Str"");
}",0.9969821248936006
191597,"public void dumpCheckinLocked(PrintWriter pw,String reqPackage){
  final long now=SystemClock.uptimeMillis();
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartClockStr);
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartRealtime);
  pw.print(""String_Node_Str"");
  pw.print(mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.println(mRuntime);
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      for (int iv=0; iv < vpkgs.size(); iv++) {
        final int vers=vpkgs.keyAt(iv);
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        final int NSRVS=pkgState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          proc.dumpPackageProcCheckin(pw,pkgName,uid,vers,pkgState.mProcesses.keyAt(iproc),now);
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          final String serviceName=DumpUtils.collapseString(pkgName,pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          svc.dumpTimesCheckin(pw,pkgName,uid,vers,serviceName,now);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final ProcessState procState=uids.valueAt(iu);
      procState.dumpProcCheckin(pw,procName,uid,now);
    }
  }
  pw.print(""String_Node_Str"");
  DumpUtils.dumpAdjTimesCheckin(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  final int sysMemUsageCount=mSysMemUsage.getKeyCount();
  if (sysMemUsageCount > 0) {
    pw.print(""String_Node_Str"");
    for (int i=0; i < sysMemUsageCount; i++) {
      final int key=mSysMemUsage.getKeyAt(i);
      final int type=SparseMappingTable.getIdFromKey(key);
      pw.print(""String_Node_Str"");
      DumpUtils.printProcStateTag(pw,type);
      for (int j=SYS_MEM_USAGE_SAMPLE_COUNT; j < SYS_MEM_USAGE_COUNT; j++) {
        if (j > SYS_MEM_USAGE_CACHED_MINIMUM) {
          pw.print(""String_Node_Str"");
        }
        pw.print(mSysMemUsage.getValue(key,j));
      }
    }
  }
  pw.println();
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.totalTime);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemCachedWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemFreeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemZRamWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemKernelWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemNativeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateWeight[i]);
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateSamples[i]);
  }
  pw.println();
}","public void dumpCheckinLocked(PrintWriter pw,String reqPackage){
  final long now=SystemClock.uptimeMillis();
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartClockStr);
  pw.print(""String_Node_Str"");
  pw.print(mTimePeriodStartRealtime);
  pw.print(""String_Node_Str"");
  pw.print(mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  if (mHasSwappedOutPss) {
    pw.print(""String_Node_Str"");
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.println(mRuntime);
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      for (int iv=0; iv < vpkgs.size(); iv++) {
        final int vers=vpkgs.keyAt(iv);
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        final int NSRVS=pkgState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          proc.dumpPackageProcCheckin(pw,pkgName,uid,vers,pkgState.mProcesses.keyAt(iproc),now);
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          final String serviceName=DumpUtils.collapseString(pkgName,pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          svc.dumpTimesCheckin(pw,pkgName,uid,vers,serviceName,now);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final ProcessState procState=uids.valueAt(iu);
      procState.dumpProcCheckin(pw,procName,uid,now);
    }
  }
  pw.print(""String_Node_Str"");
  DumpUtils.dumpAdjTimesCheckin(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  final int sysMemUsageCount=mSysMemUsage.getKeyCount();
  if (sysMemUsageCount > 0) {
    pw.print(""String_Node_Str"");
    for (int i=0; i < sysMemUsageCount; i++) {
      final int key=mSysMemUsage.getKeyAt(i);
      final int type=SparseMappingTable.getIdFromKey(key);
      pw.print(""String_Node_Str"");
      DumpUtils.printProcStateTag(pw,type);
      for (int j=SYS_MEM_USAGE_SAMPLE_COUNT; j < SYS_MEM_USAGE_COUNT; j++) {
        if (j > SYS_MEM_USAGE_CACHED_MINIMUM) {
          pw.print(""String_Node_Str"");
        }
        pw.print(mSysMemUsage.getValue(key,j));
      }
    }
  }
  pw.println();
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.totalTime);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemCachedWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemFreeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemZRamWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemKernelWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemNativeWeight);
  pw.print(""String_Node_Str"");
  pw.print(totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateWeight[i]);
    pw.print(""String_Node_Str"");
    pw.print(totalMem.processStateSamples[i]);
  }
  pw.println();
}",0.9927206551410374
191598,"/** 
 * @hide 
 */
public void writeToParcel(Parcel out,long now,int flags){
  out.writeInt(MAGIC);
  out.writeInt(PARCEL_VERSION);
  out.writeInt(STATE_COUNT);
  out.writeInt(ADJ_COUNT);
  out.writeInt(PSS_COUNT);
  out.writeInt(SYS_MEM_USAGE_COUNT);
  out.writeInt(SparseMappingTable.ARRAY_SIZE);
  mCommonStringToIndex=new ArrayMap<String,Integer>(mProcesses.size());
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  final int NPROC=procMap.size();
  for (int ip=0; ip < NPROC; ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      uids.valueAt(iu).commitStateTime(now);
    }
  }
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  final int NPKG=pkgMap.size();
  for (int ip=0; ip < NPKG; ip++) {
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      for (int iv=0; iv < NVERS; iv++) {
        PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() != proc) {
            proc.commitStateTime(now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        for (int isvc=0; isvc < NSRVS; isvc++) {
          pkgState.mServices.valueAt(isvc).commitStateTime(now);
        }
      }
    }
  }
  out.writeLong(mTimePeriodStartClock);
  out.writeLong(mTimePeriodStartRealtime);
  out.writeLong(mTimePeriodEndRealtime);
  out.writeLong(mTimePeriodStartUptime);
  out.writeLong(mTimePeriodEndUptime);
  out.writeString(mRuntime);
  out.writeInt(mFlags);
  mTableData.writeToParcel(out);
  if (mMemFactor != STATE_NOTHING) {
    mMemFactorDurations[mMemFactor]+=now - mStartTime;
    mStartTime=now;
  }
  writeCompactedLongArray(out,mMemFactorDurations,mMemFactorDurations.length);
  mSysMemUsage.writeToParcel(out);
  out.writeInt(NPROC);
  for (int ip=0; ip < NPROC; ip++) {
    writeCommonString(out,procMap.keyAt(ip));
    final SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final ProcessState proc=uids.valueAt(iu);
      writeCommonString(out,proc.getPackage());
      out.writeInt(proc.getVersion());
      proc.writeToParcel(out,now);
    }
  }
  out.writeInt(NPKG);
  for (int ip=0; ip < NPKG; ip++) {
    writeCommonString(out,pkgMap.keyAt(ip));
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      out.writeInt(NVERS);
      for (int iv=0; iv < NVERS; iv++) {
        out.writeInt(vpkgs.keyAt(iv));
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        out.writeInt(NPROCS);
        for (int iproc=0; iproc < NPROCS; iproc++) {
          writeCommonString(out,pkgState.mProcesses.keyAt(iproc));
          final ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() == proc) {
            out.writeInt(0);
          }
 else {
            out.writeInt(1);
            proc.writeToParcel(out,now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        out.writeInt(NSRVS);
        for (int isvc=0; isvc < NSRVS; isvc++) {
          out.writeString(pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          writeCommonString(out,svc.getProcessName());
          svc.writeToParcel(out,now);
        }
      }
    }
  }
  mCommonStringToIndex=null;
}","/** 
 * @hide 
 */
public void writeToParcel(Parcel out,long now,int flags){
  out.writeInt(MAGIC);
  out.writeInt(PARCEL_VERSION);
  out.writeInt(STATE_COUNT);
  out.writeInt(ADJ_COUNT);
  out.writeInt(PSS_COUNT);
  out.writeInt(SYS_MEM_USAGE_COUNT);
  out.writeInt(SparseMappingTable.ARRAY_SIZE);
  mCommonStringToIndex=new ArrayMap<String,Integer>(mProcesses.size());
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  final int NPROC=procMap.size();
  for (int ip=0; ip < NPROC; ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      uids.valueAt(iu).commitStateTime(now);
    }
  }
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  final int NPKG=pkgMap.size();
  for (int ip=0; ip < NPKG; ip++) {
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    for (int iu=0; iu < NUID; iu++) {
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      for (int iv=0; iv < NVERS; iv++) {
        PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() != proc) {
            proc.commitStateTime(now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        for (int isvc=0; isvc < NSRVS; isvc++) {
          pkgState.mServices.valueAt(isvc).commitStateTime(now);
        }
      }
    }
  }
  out.writeLong(mTimePeriodStartClock);
  out.writeLong(mTimePeriodStartRealtime);
  out.writeLong(mTimePeriodEndRealtime);
  out.writeLong(mTimePeriodStartUptime);
  out.writeLong(mTimePeriodEndUptime);
  out.writeString(mRuntime);
  out.writeInt(mHasSwappedOutPss ? 1 : 0);
  out.writeInt(mFlags);
  mTableData.writeToParcel(out);
  if (mMemFactor != STATE_NOTHING) {
    mMemFactorDurations[mMemFactor]+=now - mStartTime;
    mStartTime=now;
  }
  writeCompactedLongArray(out,mMemFactorDurations,mMemFactorDurations.length);
  mSysMemUsage.writeToParcel(out);
  out.writeInt(NPROC);
  for (int ip=0; ip < NPROC; ip++) {
    writeCommonString(out,procMap.keyAt(ip));
    final SparseArray<ProcessState> uids=procMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final ProcessState proc=uids.valueAt(iu);
      writeCommonString(out,proc.getPackage());
      out.writeInt(proc.getVersion());
      proc.writeToParcel(out,now);
    }
  }
  out.writeInt(NPKG);
  for (int ip=0; ip < NPKG; ip++) {
    writeCommonString(out,pkgMap.keyAt(ip));
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    final int NUID=uids.size();
    out.writeInt(NUID);
    for (int iu=0; iu < NUID; iu++) {
      out.writeInt(uids.keyAt(iu));
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      final int NVERS=vpkgs.size();
      out.writeInt(NVERS);
      for (int iv=0; iv < NVERS; iv++) {
        out.writeInt(vpkgs.keyAt(iv));
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        out.writeInt(NPROCS);
        for (int iproc=0; iproc < NPROCS; iproc++) {
          writeCommonString(out,pkgState.mProcesses.keyAt(iproc));
          final ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (proc.getCommonProcess() == proc) {
            out.writeInt(0);
          }
 else {
            out.writeInt(1);
            proc.writeToParcel(out,now);
          }
        }
        final int NSRVS=pkgState.mServices.size();
        out.writeInt(NSRVS);
        for (int isvc=0; isvc < NSRVS; isvc++) {
          out.writeString(pkgState.mServices.keyAt(isvc));
          final ServiceState svc=pkgState.mServices.valueAt(isvc);
          writeCommonString(out,svc.getProcessName());
          svc.writeToParcel(out,now);
        }
      }
    }
  }
  mCommonStringToIndex=null;
}",0.9947771164824488
191599,"void dumpTotalsLocked(PrintWriter pw,long now){
  pw.println(""String_Node_Str"");
  DumpUtils.dumpSingleTime(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  pw.println(""String_Node_Str"");
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  long totalPss=0;
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemKernelWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemNativeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    if (i != STATE_SERVICE_RESTARTING) {
      totalPss=printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[i],totalMem.processStateWeight[i],totalMem.totalTime,totalPss,totalMem.processStateSamples[i]);
    }
  }
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemCachedWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemFreeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemZRamWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,totalPss);
  pw.println();
  printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[STATE_SERVICE_RESTARTING],totalMem.processStateWeight[STATE_SERVICE_RESTARTING],totalMem.totalTime,totalPss,totalMem.processStateSamples[STATE_SERVICE_RESTARTING]);
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(DateFormat.format(""String_Node_Str"",mTimePeriodStartClock));
  pw.println();
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration((mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime) - mTimePeriodStartRealtime,pw);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  pw.print(' ');
  pw.print(mRuntime);
  pw.println();
}","void dumpTotalsLocked(PrintWriter pw,long now){
  pw.println(""String_Node_Str"");
  DumpUtils.dumpSingleTime(pw,""String_Node_Str"",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
  pw.println(""String_Node_Str"");
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  long totalPss=0;
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemKernelWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemNativeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    if (i != STATE_SERVICE_RESTARTING) {
      totalPss=printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[i],totalMem.processStateWeight[i],totalMem.totalTime,totalPss,totalMem.processStateSamples[i]);
    }
  }
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemCachedWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemFreeWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  totalPss=printMemoryCategory(pw,""String_Node_Str"",""String_Node_Str"",totalMem.sysMemZRamWeight,totalMem.totalTime,totalPss,totalMem.sysMemSamples);
  pw.print(""String_Node_Str"");
  DebugUtils.printSizeValue(pw,totalPss);
  pw.println();
  printMemoryCategory(pw,""String_Node_Str"",DumpUtils.STATE_NAMES[STATE_SERVICE_RESTARTING],totalMem.processStateWeight[STATE_SERVICE_RESTARTING],totalMem.totalTime,totalPss,totalMem.processStateSamples[STATE_SERVICE_RESTARTING]);
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(DateFormat.format(""String_Node_Str"",mTimePeriodStartClock));
  pw.println();
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration((mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime) - mTimePeriodStartRealtime,pw);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(""String_Node_Str"");
    partial=false;
  }
  if (partial) {
    pw.print(""String_Node_Str"");
  }
  if (mHasSwappedOutPss) {
    pw.print(""String_Node_Str"");
  }
  pw.print(' ');
  pw.print(mRuntime);
  pw.println();
}",0.986975986975987
191600,"@Override public void flingTopOverscroll(float velocity,boolean open){
  mLastOverscroll=0f;
  setQsExpansion(mQsExpansionHeight);
  flingSettings(!mQsExpansionEnabled && open ? 0f : velocity,open && mQsExpansionEnabled,new Runnable(){
    @Override public void run(){
      mStackScrollerOverscrolling=false;
      setOverScrolling(false);
      updateQsState();
    }
  }
,false);
}","@Override public void flingTopOverscroll(float velocity,boolean open){
  mLastOverscroll=0f;
  mQsExpansionFromOverscroll=false;
  setQsExpansion(mQsExpansionHeight);
  flingSettings(!mQsExpansionEnabled && open ? 0f : velocity,open && mQsExpansionEnabled,new Runnable(){
    @Override public void run(){
      mStackScrollerOverscrolling=false;
      setOverScrolling(false);
      updateQsState();
    }
  }
,false);
}",0.9552238805970148
191601,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification) && !entry.row.isRemoved();
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && !childWithVisibleSummary && (visibleNotifications >= maxNotifications || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification) && !entry.row.isRemoved();
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && !childWithVisibleSummary && (visibleNotifications >= maxNotifications || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification && !entry.row.isRemoved()) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9944774851316908
191602,"private boolean shouldShowOnKeyguard(StatusBarNotification sbn){
  return mShowLockscreenNotifications && !mNotificationData.isAmbient(sbn.getKey());
}","public boolean shouldShowOnKeyguard(StatusBarNotification sbn){
  return mShowLockscreenNotifications && !mNotificationData.isAmbient(sbn.getKey());
}",0.9700996677740864
191603,"/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(((ExpandableNotificationRow)child).getStatusBarNotification());
    if (suppressedSummary) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}","/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    ExpandableNotificationRow row=(ExpandableNotificationRow)child;
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(row.getStatusBarNotification());
    if (suppressedSummary) {
      continue;
    }
    if (!mStatusBar.shouldShowOnKeyguard(row.getStatusBarNotification())) {
      continue;
    }
    if (row.isRemoved()) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}",0.8821052631578947
191604,"/** 
 * Ensures that the group children are cancelled immediately when the group summary is cancelled instead of waiting for the notification manager to send all cancels. Otherwise this could lead to flickers. This also ensures that the animation looks nice and only consists of a single disappear animation instead of multiple.
 * @param key the key of the notification was removed
 * @param ranking the current ranking
 */
private void handleGroupSummaryRemoved(String key,RankingMap ranking){
  Entry entry=mNotificationData.get(key);
  if (entry != null && entry.row != null && entry.row.isSummaryWithChildren()) {
    if (entry.notification.getOverrideGroupKey() != null && !entry.row.isDismissed()) {
      return;
    }
    entry.row.setRemoved(true);
    List<ExpandableNotificationRow> notificationChildren=entry.row.getNotificationChildren();
    ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>(notificationChildren);
    for (int i=0; i < toRemove.size(); i++) {
      toRemove.get(i).setKeepInParent(true);
    }
    for (int i=0; i < toRemove.size(); i++) {
      removeNotification(toRemove.get(i).getStatusBarNotification().getKey(),ranking);
      mStackScroller.removeViewStateForView(toRemove.get(i));
    }
  }
}","/** 
 * Ensures that the group children are cancelled immediately when the group summary is cancelled instead of waiting for the notification manager to send all cancels. Otherwise this could lead to flickers. This also ensures that the animation looks nice and only consists of a single disappear animation instead of multiple.
 * @param key the key of the notification was removed
 * @param ranking the current ranking
 */
private void handleGroupSummaryRemoved(String key,RankingMap ranking){
  Entry entry=mNotificationData.get(key);
  if (entry != null && entry.row != null && entry.row.isSummaryWithChildren()) {
    if (entry.notification.getOverrideGroupKey() != null && !entry.row.isDismissed()) {
      return;
    }
    entry.row.setRemoved(true);
    List<ExpandableNotificationRow> notificationChildren=entry.row.getNotificationChildren();
    ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>(notificationChildren);
    for (int i=0; i < toRemove.size(); i++) {
      toRemove.get(i).setKeepInParent(true);
      toRemove.get(i).setRemoved(true);
    }
    for (int i=0; i < toRemove.size(); i++) {
      removeNotification(toRemove.get(i).getStatusBarNotification().getKey(),ranking);
      mStackScroller.removeViewStateForView(toRemove.get(i));
    }
  }
}",0.984189723320158
191605,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  for (int i=0; i < childCount; i++) {
    View child=mChildren.get(i);
    if (child.getVisibility() == View.GONE) {
      continue;
    }
    child.layout(0,0,child.getMeasuredWidth(),child.getMeasuredHeight());
    mDividers.get(i).layout(0,0,getWidth(),mDividerHeight);
  }
  if (mOverflowNumber != null) {
    mOverflowNumber.layout(getWidth() - mOverflowNumber.getMeasuredWidth(),0,getWidth(),mOverflowNumber.getMeasuredHeight());
  }
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  for (int i=0; i < childCount; i++) {
    View child=mChildren.get(i);
    child.layout(0,0,child.getMeasuredWidth(),child.getMeasuredHeight());
    mDividers.get(i).layout(0,0,getWidth(),mDividerHeight);
  }
  if (mOverflowNumber != null) {
    mOverflowNumber.layout(getWidth() - mOverflowNumber.getMeasuredWidth(),0,getWidth(),mOverflowNumber.getMeasuredHeight());
  }
}",0.9404553415061296
191606,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxNotificationHeight;
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int size=MeasureSpec.getSize(heightMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    ownMaxHeight=Math.min(ownMaxHeight,size);
  }
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (mOverflowNumber != null) {
    mOverflowNumber.measure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.AT_MOST),newHeightSpec);
  }
  int dividerHeightSpec=MeasureSpec.makeMeasureSpec(mDividerHeight,MeasureSpec.EXACTLY);
  int height=mNotificationHeaderHeight + mNotificatonTopPadding;
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  int collapsedChildren=getMaxAllowedVisibleChildren(true);
  int overflowIndex=childCount > collapsedChildren ? collapsedChildren - 1 : -1;
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    boolean isOverflow=i == overflowIndex;
    child.setSingleLineWidthIndention(isOverflow && mOverflowNumber != null ? mOverflowNumber.getMeasuredWidth() : 0);
    child.measure(widthMeasureSpec,newHeightSpec);
    height+=child.getMeasuredHeight();
    View divider=mDividers.get(i);
    divider.measure(widthMeasureSpec,dividerHeightSpec);
    height+=mDividerHeight;
  }
  mRealHeight=height;
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    height=Math.min(height,size);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxNotificationHeight;
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int size=MeasureSpec.getSize(heightMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    ownMaxHeight=Math.min(ownMaxHeight,size);
  }
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (mOverflowNumber != null) {
    mOverflowNumber.measure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.AT_MOST),newHeightSpec);
  }
  int dividerHeightSpec=MeasureSpec.makeMeasureSpec(mDividerHeight,MeasureSpec.EXACTLY);
  int height=mNotificationHeaderHeight + mNotificatonTopPadding;
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  int collapsedChildren=getMaxAllowedVisibleChildren(true);
  int overflowIndex=childCount > collapsedChildren ? collapsedChildren - 1 : -1;
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    boolean isOverflow=i == overflowIndex;
    child.setSingleLineWidthIndention(isOverflow && mOverflowNumber != null ? mOverflowNumber.getMeasuredWidth() : 0);
    child.measure(widthMeasureSpec,newHeightSpec);
    View divider=mDividers.get(i);
    divider.measure(widthMeasureSpec,dividerHeightSpec);
    if (child.getVisibility() != GONE) {
      height+=child.getMeasuredHeight() + mDividerHeight;
    }
  }
  mRealHeight=height;
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    height=Math.min(height,size);
  }
  setMeasuredDimension(width,height);
}",0.9225880993645292
191607,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  float centerX=getWidth() / 2.0f;
  for (int i=0; i < getChildCount(); i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == GONE) {
      continue;
    }
    float width=child.getMeasuredWidth();
    float height=child.getMeasuredHeight();
    child.layout((int)(centerX - width / 2.0f),0,(int)(centerX + width / 2.0f),(int)height);
  }
  setMaxLayoutHeight(getHeight());
  updateContentHeight();
  clampScrollPosition();
  if (mRequestViewResizeAnimationOnLayout) {
    requestAnimationOnViewResize(null);
    mRequestViewResizeAnimationOnLayout=false;
  }
  requestChildrenUpdate();
  updateFirstAndLastBackgroundViews();
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  float centerX=getWidth() / 2.0f;
  for (int i=0; i < getChildCount(); i++) {
    View child=getChildAt(i);
    float width=child.getMeasuredWidth();
    float height=child.getMeasuredHeight();
    child.layout((int)(centerX - width / 2.0f),0,(int)(centerX + width / 2.0f),(int)height);
  }
  setMaxLayoutHeight(getHeight());
  updateContentHeight();
  clampScrollPosition();
  if (mRequestViewResizeAnimationOnLayout) {
    requestAnimationOnViewResize(null);
    mRequestViewResizeAnimationOnLayout=false;
  }
  requestChildrenUpdate();
  updateFirstAndLastBackgroundViews();
}",0.954181818181818
191608,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  measureChildren(widthMeasureSpec,heightMeasureSpec);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  final int size=getChildCount();
  for (int i=0; i < size; i++) {
    measureChild(getChildAt(i),widthMeasureSpec,heightMeasureSpec);
  }
}",0.8025751072961373
191609,"private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if (mIsHeadsUp && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || !mContainingNotification.isExpanded(true)))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}","private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if (mIsHeadsUp && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || isGroupExpanded() || !mContainingNotification.isExpanded(true)))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}",0.9866666666666668
191610,"/** 
 * Sets the intent of a shortcut.  This is a mandatory field.  The extras must only contain persistable information.  (See   {@link PersistableBundle}).
 */
@NonNull public Builder setIntent(@NonNull Intent intent){
  mIntent=Preconditions.checkNotNull(intent,""String_Node_Str"");
  return this;
}","/** 
 * Sets the intent of a shortcut.  This is a mandatory field.  The extras must only contain persistable information.  (See   {@link PersistableBundle}).
 */
@NonNull public Builder setIntent(@NonNull Intent intent){
  mIntent=Preconditions.checkNotNull(intent,""String_Node_Str"");
  Preconditions.checkNotNull(mIntent.getAction(),""String_Node_Str"");
  return this;
}",0.8643815201192251
191611,"/** 
 * Publish a single dynamic shortcut.  If there's already dynamic or pinned shortcuts with the same ID, they will all be updated. <p>This API will be rate-limited.
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 * @throws IllegalArgumentException if the caller application has already published themax number of dynamic shortcuts.
 */
public boolean addDynamicShortcuts(@NonNull List<ShortcutInfo> shortcutInfoList){
  try {
    return mService.addDynamicShortcuts(mContext.getPackageName(),new ParceledListSlice(shortcutInfoList),injectMyUserId());
  }
 catch (  RemoteException e) {
    throw e.rethrowFromSystemServer();
  }
}","/** 
 * Publish list of dynamic shortcuts.  If there's already dynamic or pinned shortcuts with the same IDs, they will all be updated. <p>This API will be rate-limited.
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 * @throws IllegalArgumentException if the caller application has already published themax number of dynamic shortcuts.
 */
public boolean addDynamicShortcuts(@NonNull List<ShortcutInfo> shortcutInfoList){
  try {
    return mService.addDynamicShortcuts(mContext.getPackageName(),new ParceledListSlice(shortcutInfoList),injectMyUserId());
  }
 catch (  RemoteException e) {
    throw e.rethrowFromSystemServer();
  }
}",0.962582538517975
191612,"/** 
 * Delete a single dynamic shortcut by ID.
 */
public void removeDynamicShortcuts(@NonNull List<String> shortcutIds){
  try {
    mService.removeDynamicShortcuts(mContext.getPackageName(),shortcutIds,injectMyUserId());
  }
 catch (  RemoteException e) {
    throw e.rethrowFromSystemServer();
  }
}","/** 
 * Delete dynamic shortcuts by ID.
 */
public void removeDynamicShortcuts(@NonNull List<String> shortcutIds){
  try {
    mService.removeDynamicShortcuts(mContext.getPackageName(),shortcutIds,injectMyUserId());
  }
 catch (  RemoteException e) {
    throw e.rethrowFromSystemServer();
  }
}",0.9297658862876256
191613,"public void pinShortcuts(@NonNull ShortcutService s,@UserIdInt int packageUserId,@NonNull String packageName,@NonNull List<String> ids){
  final ShortcutPackage packageShortcuts=s.getPackageShortcutsLocked(packageName,packageUserId);
  final PackageWithUser pu=PackageWithUser.of(packageUserId,packageName);
  final int idSize=ids.size();
  if (idSize == 0) {
    mPinnedShortcuts.remove(pu);
  }
 else {
    final ArraySet<String> prevSet=mPinnedShortcuts.get(pu);
    final ArraySet<String> newSet=new ArraySet<>();
    for (int i=0; i < idSize; i++) {
      final String id=ids.get(i);
      final ShortcutInfo si=packageShortcuts.findShortcutById(id);
      if (si == null) {
        continue;
      }
      if (si.isDynamic() || (prevSet != null && prevSet.contains(id))) {
        newSet.add(id);
      }
    }
    mPinnedShortcuts.put(pu,newSet);
  }
  packageShortcuts.refreshPinnedFlags(s);
}","public void pinShortcuts(@UserIdInt int packageUserId,@NonNull String packageName,@NonNull List<String> ids){
  final ShortcutPackage packageShortcuts=mShortcutUser.getPackageShortcutsIfExists(packageName);
  if (packageShortcuts == null) {
    return;
  }
  final PackageWithUser pu=PackageWithUser.of(packageUserId,packageName);
  final int idSize=ids.size();
  if (idSize == 0) {
    mPinnedShortcuts.remove(pu);
  }
 else {
    final ArraySet<String> prevSet=mPinnedShortcuts.get(pu);
    final ArraySet<String> newSet=new ArraySet<>();
    for (int i=0; i < idSize; i++) {
      final String id=ids.get(i);
      final ShortcutInfo si=packageShortcuts.findShortcutById(id);
      if (si == null) {
        continue;
      }
      if (si.isDynamic() || (prevSet != null && prevSet.contains(id))) {
        newSet.add(id);
      }
    }
    mPinnedShortcuts.put(pu,newSet);
  }
  packageShortcuts.refreshPinnedFlags();
}",0.9320175438596492
191614,"/** 
 * Called when the new package can't receive the backup, due to signature or version mismatch.
 */
@Override protected void onRestoreBlocked(ShortcutService s){
  final ArrayList<PackageWithUser> pinnedPackages=new ArrayList<>(mPinnedShortcuts.keySet());
  mPinnedShortcuts.clear();
  for (int i=pinnedPackages.size() - 1; i >= 0; i--) {
    final PackageWithUser pu=pinnedPackages.get(i);
    s.getPackageShortcutsLocked(pu.packageName,pu.userId).refreshPinnedFlags(s);
  }
}","/** 
 * Called when the new package can't receive the backup, due to signature or version mismatch.
 */
@Override protected void onRestoreBlocked(){
  final ArrayList<PackageWithUser> pinnedPackages=new ArrayList<>(mPinnedShortcuts.keySet());
  mPinnedShortcuts.clear();
  for (int i=pinnedPackages.size() - 1; i >= 0; i--) {
    final PackageWithUser pu=pinnedPackages.get(i);
    final ShortcutPackage p=mShortcutUser.getPackageShortcutsIfExists(pu.packageName);
    if (p != null) {
      p.refreshPinnedFlags();
    }
  }
}",0.8531746031746031
191615,"public void dump(@NonNull ShortcutService s,@NonNull PrintWriter pw,@NonNull String prefix){
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(getPackageName());
  pw.print(""String_Node_Str"");
  pw.print(getPackageUserId());
  pw.print(""String_Node_Str"");
  pw.print(getOwnerUserId());
  pw.println();
  getPackageInfo().dump(s,pw,prefix + ""String_Node_Str"");
  pw.println();
  final int size=mPinnedShortcuts.size();
  for (int i=0; i < size; i++) {
    pw.println();
    final PackageWithUser pu=mPinnedShortcuts.keyAt(i);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.print(pu.packageName);
    pw.print(""String_Node_Str"");
    pw.println(pu.userId);
    final ArraySet<String> ids=mPinnedShortcuts.valueAt(i);
    final int idSize=ids.size();
    for (int j=0; j < idSize; j++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(ids.valueAt(j));
      pw.println();
    }
  }
}","public void dump(@NonNull PrintWriter pw,@NonNull String prefix){
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(getPackageName());
  pw.print(""String_Node_Str"");
  pw.print(getPackageUserId());
  pw.print(""String_Node_Str"");
  pw.print(getOwnerUserId());
  pw.println();
  getPackageInfo().dump(pw,prefix + ""String_Node_Str"");
  pw.println();
  final int size=mPinnedShortcuts.size();
  for (int i=0; i < size; i++) {
    pw.println();
    final PackageWithUser pu=mPinnedShortcuts.keyAt(i);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.print(pu.packageName);
    pw.print(""String_Node_Str"");
    pw.println(pu.userId);
    final ArraySet<String> ids=mPinnedShortcuts.valueAt(i);
    final int idSize=ids.size();
    for (int j=0; j < idSize; j++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(ids.valueAt(j));
      pw.println();
    }
  }
}",0.9705730511099638
191616,"@Override protected void onRestored(ShortcutService s){
}","@Override protected void onRestored(){
}",0.8247422680412371
191617,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification) && !entry.row.isRemoved();
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && !childWithVisibleSummary && (visibleNotifications >= maxNotifications || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification) && !entry.row.isRemoved();
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && !childWithVisibleSummary && (visibleNotifications >= maxNotifications || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification && !entry.row.isRemoved()) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9944774851316908
191618,"private boolean shouldShowOnKeyguard(StatusBarNotification sbn){
  return mShowLockscreenNotifications && !mNotificationData.isAmbient(sbn.getKey());
}","public boolean shouldShowOnKeyguard(StatusBarNotification sbn){
  return mShowLockscreenNotifications && !mNotificationData.isAmbient(sbn.getKey());
}",0.9700996677740864
191619,"/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(((ExpandableNotificationRow)child).getStatusBarNotification());
    if (suppressedSummary) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}","/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    ExpandableNotificationRow row=(ExpandableNotificationRow)child;
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(row.getStatusBarNotification());
    if (suppressedSummary) {
      continue;
    }
    if (!mStatusBar.shouldShowOnKeyguard(row.getStatusBarNotification())) {
      continue;
    }
    if (row.isRemoved()) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}",0.8821052631578947
191620,"/** 
 * Ensures that the group children are cancelled immediately when the group summary is cancelled instead of waiting for the notification manager to send all cancels. Otherwise this could lead to flickers. This also ensures that the animation looks nice and only consists of a single disappear animation instead of multiple.
 * @param key the key of the notification was removed
 * @param ranking the current ranking
 */
private void handleGroupSummaryRemoved(String key,RankingMap ranking){
  Entry entry=mNotificationData.get(key);
  if (entry != null && entry.row != null && entry.row.isSummaryWithChildren()) {
    if (entry.notification.getOverrideGroupKey() != null && !entry.row.isDismissed()) {
      return;
    }
    entry.row.setRemoved(true);
    List<ExpandableNotificationRow> notificationChildren=entry.row.getNotificationChildren();
    ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>(notificationChildren);
    for (int i=0; i < toRemove.size(); i++) {
      toRemove.get(i).setKeepInParent(true);
    }
    for (int i=0; i < toRemove.size(); i++) {
      removeNotification(toRemove.get(i).getStatusBarNotification().getKey(),ranking);
      mStackScroller.removeViewStateForView(toRemove.get(i));
    }
  }
}","/** 
 * Ensures that the group children are cancelled immediately when the group summary is cancelled instead of waiting for the notification manager to send all cancels. Otherwise this could lead to flickers. This also ensures that the animation looks nice and only consists of a single disappear animation instead of multiple.
 * @param key the key of the notification was removed
 * @param ranking the current ranking
 */
private void handleGroupSummaryRemoved(String key,RankingMap ranking){
  Entry entry=mNotificationData.get(key);
  if (entry != null && entry.row != null && entry.row.isSummaryWithChildren()) {
    if (entry.notification.getOverrideGroupKey() != null && !entry.row.isDismissed()) {
      return;
    }
    entry.row.setRemoved(true);
    List<ExpandableNotificationRow> notificationChildren=entry.row.getNotificationChildren();
    ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>(notificationChildren);
    for (int i=0; i < toRemove.size(); i++) {
      toRemove.get(i).setKeepInParent(true);
      toRemove.get(i).setRemoved(true);
    }
    for (int i=0; i < toRemove.size(); i++) {
      removeNotification(toRemove.get(i).getStatusBarNotification().getKey(),ranking);
      mStackScroller.removeViewStateForView(toRemove.get(i));
    }
  }
}",0.984189723320158
191621,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  for (int i=0; i < childCount; i++) {
    View child=mChildren.get(i);
    if (child.getVisibility() == View.GONE) {
      continue;
    }
    child.layout(0,0,child.getMeasuredWidth(),child.getMeasuredHeight());
    mDividers.get(i).layout(0,0,getWidth(),mDividerHeight);
  }
  if (mOverflowNumber != null) {
    mOverflowNumber.layout(getWidth() - mOverflowNumber.getMeasuredWidth(),0,getWidth(),mOverflowNumber.getMeasuredHeight());
  }
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  for (int i=0; i < childCount; i++) {
    View child=mChildren.get(i);
    child.layout(0,0,child.getMeasuredWidth(),child.getMeasuredHeight());
    mDividers.get(i).layout(0,0,getWidth(),mDividerHeight);
  }
  if (mOverflowNumber != null) {
    mOverflowNumber.layout(getWidth() - mOverflowNumber.getMeasuredWidth(),0,getWidth(),mOverflowNumber.getMeasuredHeight());
  }
}",0.9404553415061296
191622,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxNotificationHeight;
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int size=MeasureSpec.getSize(heightMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    ownMaxHeight=Math.min(ownMaxHeight,size);
  }
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (mOverflowNumber != null) {
    mOverflowNumber.measure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.AT_MOST),newHeightSpec);
  }
  int dividerHeightSpec=MeasureSpec.makeMeasureSpec(mDividerHeight,MeasureSpec.EXACTLY);
  int height=mNotificationHeaderHeight + mNotificatonTopPadding;
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  int collapsedChildren=getMaxAllowedVisibleChildren(true);
  int overflowIndex=childCount > collapsedChildren ? collapsedChildren - 1 : -1;
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    boolean isOverflow=i == overflowIndex;
    child.setSingleLineWidthIndention(isOverflow && mOverflowNumber != null ? mOverflowNumber.getMeasuredWidth() : 0);
    child.measure(widthMeasureSpec,newHeightSpec);
    height+=child.getMeasuredHeight();
    View divider=mDividers.get(i);
    divider.measure(widthMeasureSpec,dividerHeightSpec);
    height+=mDividerHeight;
  }
  mRealHeight=height;
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    height=Math.min(height,size);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxNotificationHeight;
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int size=MeasureSpec.getSize(heightMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    ownMaxHeight=Math.min(ownMaxHeight,size);
  }
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (mOverflowNumber != null) {
    mOverflowNumber.measure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.AT_MOST),newHeightSpec);
  }
  int dividerHeightSpec=MeasureSpec.makeMeasureSpec(mDividerHeight,MeasureSpec.EXACTLY);
  int height=mNotificationHeaderHeight + mNotificatonTopPadding;
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  int collapsedChildren=getMaxAllowedVisibleChildren(true);
  int overflowIndex=childCount > collapsedChildren ? collapsedChildren - 1 : -1;
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    boolean isOverflow=i == overflowIndex;
    child.setSingleLineWidthIndention(isOverflow && mOverflowNumber != null ? mOverflowNumber.getMeasuredWidth() : 0);
    child.measure(widthMeasureSpec,newHeightSpec);
    View divider=mDividers.get(i);
    divider.measure(widthMeasureSpec,dividerHeightSpec);
    if (child.getVisibility() != GONE) {
      height+=child.getMeasuredHeight() + mDividerHeight;
    }
  }
  mRealHeight=height;
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    height=Math.min(height,size);
  }
  setMeasuredDimension(width,height);
}",0.9225880993645292
191623,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  float centerX=getWidth() / 2.0f;
  for (int i=0; i < getChildCount(); i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == GONE) {
      continue;
    }
    float width=child.getMeasuredWidth();
    float height=child.getMeasuredHeight();
    child.layout((int)(centerX - width / 2.0f),0,(int)(centerX + width / 2.0f),(int)height);
  }
  setMaxLayoutHeight(getHeight());
  updateContentHeight();
  clampScrollPosition();
  if (mRequestViewResizeAnimationOnLayout) {
    requestAnimationOnViewResize(null);
    mRequestViewResizeAnimationOnLayout=false;
  }
  requestChildrenUpdate();
  updateFirstAndLastBackgroundViews();
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  float centerX=getWidth() / 2.0f;
  for (int i=0; i < getChildCount(); i++) {
    View child=getChildAt(i);
    float width=child.getMeasuredWidth();
    float height=child.getMeasuredHeight();
    child.layout((int)(centerX - width / 2.0f),0,(int)(centerX + width / 2.0f),(int)height);
  }
  setMaxLayoutHeight(getHeight());
  updateContentHeight();
  clampScrollPosition();
  if (mRequestViewResizeAnimationOnLayout) {
    requestAnimationOnViewResize(null);
    mRequestViewResizeAnimationOnLayout=false;
  }
  requestChildrenUpdate();
  updateFirstAndLastBackgroundViews();
}",0.954181818181818
191624,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  measureChildren(widthMeasureSpec,heightMeasureSpec);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  final int size=getChildCount();
  for (int i=0; i < size; i++) {
    measureChild(getChildAt(i),widthMeasureSpec,heightMeasureSpec);
  }
}",0.8025751072961373
191625,"/** 
 * Sets the intent of a shortcut.  This is a mandatory field.  The extras must only contain persistable information.  (See   {@link PersistableBundle}).
 */
@NonNull public Builder setIntent(@NonNull Intent intent){
  mIntent=Preconditions.checkNotNull(intent,""String_Node_Str"");
  return this;
}","/** 
 * Sets the intent of a shortcut.  This is a mandatory field.  The extras must only contain persistable information.  (See   {@link PersistableBundle}).
 */
@NonNull public Builder setIntent(@NonNull Intent intent){
  mIntent=Preconditions.checkNotNull(intent,""String_Node_Str"");
  Preconditions.checkNotNull(mIntent.getAction(),""String_Node_Str"");
  return this;
}",0.8643815201192251
191626,"/** 
 * Publish a single dynamic shortcut.  If there's already dynamic or pinned shortcuts with the same ID, they will all be updated. <p>This API will be rate-limited.
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 * @throws IllegalArgumentException if the caller application has already published themax number of dynamic shortcuts.
 */
public boolean addDynamicShortcuts(@NonNull List<ShortcutInfo> shortcutInfoList){
  try {
    return mService.addDynamicShortcuts(mContext.getPackageName(),new ParceledListSlice(shortcutInfoList),injectMyUserId());
  }
 catch (  RemoteException e) {
    throw e.rethrowFromSystemServer();
  }
}","/** 
 * Publish list of dynamic shortcuts.  If there's already dynamic or pinned shortcuts with the same IDs, they will all be updated. <p>This API will be rate-limited.
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 * @throws IllegalArgumentException if the caller application has already published themax number of dynamic shortcuts.
 */
public boolean addDynamicShortcuts(@NonNull List<ShortcutInfo> shortcutInfoList){
  try {
    return mService.addDynamicShortcuts(mContext.getPackageName(),new ParceledListSlice(shortcutInfoList),injectMyUserId());
  }
 catch (  RemoteException e) {
    throw e.rethrowFromSystemServer();
  }
}",0.962582538517975
191627,"/** 
 * Delete a single dynamic shortcut by ID.
 */
public void removeDynamicShortcuts(@NonNull List<String> shortcutIds){
  try {
    mService.removeDynamicShortcuts(mContext.getPackageName(),shortcutIds,injectMyUserId());
  }
 catch (  RemoteException e) {
    throw e.rethrowFromSystemServer();
  }
}","/** 
 * Delete dynamic shortcuts by ID.
 */
public void removeDynamicShortcuts(@NonNull List<String> shortcutIds){
  try {
    mService.removeDynamicShortcuts(mContext.getPackageName(),shortcutIds,injectMyUserId());
  }
 catch (  RemoteException e) {
    throw e.rethrowFromSystemServer();
  }
}",0.9297658862876256
191628,"public void pinShortcuts(@NonNull ShortcutService s,@UserIdInt int packageUserId,@NonNull String packageName,@NonNull List<String> ids){
  final ShortcutPackage packageShortcuts=s.getPackageShortcutsLocked(packageName,packageUserId);
  final PackageWithUser pu=PackageWithUser.of(packageUserId,packageName);
  final int idSize=ids.size();
  if (idSize == 0) {
    mPinnedShortcuts.remove(pu);
  }
 else {
    final ArraySet<String> prevSet=mPinnedShortcuts.get(pu);
    final ArraySet<String> newSet=new ArraySet<>();
    for (int i=0; i < idSize; i++) {
      final String id=ids.get(i);
      final ShortcutInfo si=packageShortcuts.findShortcutById(id);
      if (si == null) {
        continue;
      }
      if (si.isDynamic() || (prevSet != null && prevSet.contains(id))) {
        newSet.add(id);
      }
    }
    mPinnedShortcuts.put(pu,newSet);
  }
  packageShortcuts.refreshPinnedFlags(s);
}","public void pinShortcuts(@UserIdInt int packageUserId,@NonNull String packageName,@NonNull List<String> ids){
  final ShortcutPackage packageShortcuts=mShortcutUser.getPackageShortcutsIfExists(packageName);
  if (packageShortcuts == null) {
    return;
  }
  final PackageWithUser pu=PackageWithUser.of(packageUserId,packageName);
  final int idSize=ids.size();
  if (idSize == 0) {
    mPinnedShortcuts.remove(pu);
  }
 else {
    final ArraySet<String> prevSet=mPinnedShortcuts.get(pu);
    final ArraySet<String> newSet=new ArraySet<>();
    for (int i=0; i < idSize; i++) {
      final String id=ids.get(i);
      final ShortcutInfo si=packageShortcuts.findShortcutById(id);
      if (si == null) {
        continue;
      }
      if (si.isDynamic() || (prevSet != null && prevSet.contains(id))) {
        newSet.add(id);
      }
    }
    mPinnedShortcuts.put(pu,newSet);
  }
  packageShortcuts.refreshPinnedFlags();
}",0.9320175438596492
191629,"/** 
 * Called when the new package can't receive the backup, due to signature or version mismatch.
 */
@Override protected void onRestoreBlocked(ShortcutService s){
  final ArrayList<PackageWithUser> pinnedPackages=new ArrayList<>(mPinnedShortcuts.keySet());
  mPinnedShortcuts.clear();
  for (int i=pinnedPackages.size() - 1; i >= 0; i--) {
    final PackageWithUser pu=pinnedPackages.get(i);
    s.getPackageShortcutsLocked(pu.packageName,pu.userId).refreshPinnedFlags(s);
  }
}","/** 
 * Called when the new package can't receive the backup, due to signature or version mismatch.
 */
@Override protected void onRestoreBlocked(){
  final ArrayList<PackageWithUser> pinnedPackages=new ArrayList<>(mPinnedShortcuts.keySet());
  mPinnedShortcuts.clear();
  for (int i=pinnedPackages.size() - 1; i >= 0; i--) {
    final PackageWithUser pu=pinnedPackages.get(i);
    final ShortcutPackage p=mShortcutUser.getPackageShortcutsIfExists(pu.packageName);
    if (p != null) {
      p.refreshPinnedFlags();
    }
  }
}",0.8531746031746031
191630,"public void dump(@NonNull ShortcutService s,@NonNull PrintWriter pw,@NonNull String prefix){
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(getPackageName());
  pw.print(""String_Node_Str"");
  pw.print(getPackageUserId());
  pw.print(""String_Node_Str"");
  pw.print(getOwnerUserId());
  pw.println();
  getPackageInfo().dump(s,pw,prefix + ""String_Node_Str"");
  pw.println();
  final int size=mPinnedShortcuts.size();
  for (int i=0; i < size; i++) {
    pw.println();
    final PackageWithUser pu=mPinnedShortcuts.keyAt(i);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.print(pu.packageName);
    pw.print(""String_Node_Str"");
    pw.println(pu.userId);
    final ArraySet<String> ids=mPinnedShortcuts.valueAt(i);
    final int idSize=ids.size();
    for (int j=0; j < idSize; j++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(ids.valueAt(j));
      pw.println();
    }
  }
}","public void dump(@NonNull PrintWriter pw,@NonNull String prefix){
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(getPackageName());
  pw.print(""String_Node_Str"");
  pw.print(getPackageUserId());
  pw.print(""String_Node_Str"");
  pw.print(getOwnerUserId());
  pw.println();
  getPackageInfo().dump(pw,prefix + ""String_Node_Str"");
  pw.println();
  final int size=mPinnedShortcuts.size();
  for (int i=0; i < size; i++) {
    pw.println();
    final PackageWithUser pu=mPinnedShortcuts.keyAt(i);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.print(pu.packageName);
    pw.print(""String_Node_Str"");
    pw.println(pu.userId);
    final ArraySet<String> ids=mPinnedShortcuts.valueAt(i);
    final int idSize=ids.size();
    for (int j=0; j < idSize; j++) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(ids.valueAt(j));
      pw.println();
    }
  }
}",0.9705730511099638
191631,"@Override protected void onRestored(ShortcutService s){
}","@Override protected void onRestored(){
}",0.8247422680412371
191632,"private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if (mIsHeadsUp && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || !mContainingNotification.isExpanded(true)))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}","private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if (mIsHeadsUp && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || isGroupExpanded() || !mContainingNotification.isExpanded(true)))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}",0.9866666666666668
191633,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification _foregroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerInternal nm=LocalServices.getService(NotificationManagerInternal.class);
        if (nm == null) {
          return;
        }
        Notification localForegroundNoti=_foregroundNoti;
        try {
          if (localForegroundNoti.getSmallIcon() == null) {
            Slog.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ localForegroundNoti+ ""String_Node_Str"");
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Notification.Builder notiBuilder=new Notification.Builder(ctx);
              notiBuilder.setSmallIcon(appInfo.icon);
              notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE,true);
              notiBuilder.setPriority(Notification.PRIORITY_MIN);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              notiBuilder.setColor(ams.mContext.getColor(com.android.internal.R.color.system_notification_accent_color));
              notiBuilder.setContentTitle(ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName));
              notiBuilder.setContentText(ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName));
              notiBuilder.setContentIntent(pi);
              localForegroundNoti=notiBuilder.build();
            }
 catch (            PackageManager.NameNotFoundException e) {
            }
          }
          if (localForegroundNoti.getSmallIcon() == null) {
            throw new RuntimeException(""String_Node_Str"" + foregroundNoti);
          }
          int[] outId=new int[1];
          nm.enqueueNotification(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
          foregroundNoti=localForegroundNoti;
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,0);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification _foregroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerInternal nm=LocalServices.getService(NotificationManagerInternal.class);
        if (nm == null) {
          return;
        }
        Notification localForegroundNoti=_foregroundNoti;
        try {
          if (localForegroundNoti.getSmallIcon() == null) {
            Slog.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ localForegroundNoti+ ""String_Node_Str"");
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContextAsUser(appInfo.packageName,0,new UserHandle(userId));
              Notification.Builder notiBuilder=new Notification.Builder(ctx);
              notiBuilder.setSmallIcon(appInfo.icon);
              notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE,true);
              notiBuilder.setPriority(Notification.PRIORITY_MIN);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              notiBuilder.setColor(ams.mContext.getColor(com.android.internal.R.color.system_notification_accent_color));
              notiBuilder.setContentTitle(ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName));
              notiBuilder.setContentText(ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName));
              notiBuilder.setContentIntent(pi);
              localForegroundNoti=notiBuilder.build();
            }
 catch (            PackageManager.NameNotFoundException e) {
            }
          }
          if (localForegroundNoti.getSmallIcon() == null) {
            throw new RuntimeException(""String_Node_Str"" + foregroundNoti);
          }
          int[] outId=new int[1];
          nm.enqueueNotification(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
          foregroundNoti=localForegroundNoti;
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,0);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}",0.9950008619203584
191634,"private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if (mIsHeadsUp && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || !mContainingNotification.isExpanded(true)))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}","private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if (mIsHeadsUp && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || isGroupExpanded() || !mContainingNotification.isExpanded(true)))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}",0.9866666666666668
191635,"/** 
 * Reloads the stack views upon launching Recents.
 */
private void reloadStackView(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan loadPlan=RecentsImpl.consumeInstanceLoadPlan();
  if (loadPlan == null) {
    loadPlan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!loadPlan.hasTasks()) {
    loader.preloadTasks(loadPlan,launchState.launchedToTaskId,launchState.launchedFromHome);
  }
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=launchState.launchedNumVisibleTasks;
  loadOpts.numVisibleTaskThumbnails=launchState.launchedNumVisibleThumbnails;
  loader.loadTasks(this,loadPlan,loadOpts);
  TaskStack stack=loadPlan.getTaskStack();
  mRecentsView.onReload(mIsVisible,stack.getTaskCount() == 0);
  mRecentsView.updateStack(stack,true);
  boolean animateNavBarScrim=!launchState.launchedViaDockGesture;
  mScrimViews.updateNavBarScrim(animateNavBarScrim,stack.getTaskCount() > 0,null);
  boolean wasLaunchedByAm=!launchState.launchedFromHome && !launchState.launchedFromApp;
  if (wasLaunchedByAm) {
    EventBus.getDefault().send(new EnterRecentsWindowAnimationCompletedEvent());
  }
  if (launchState.launchedWithAltTab) {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  if (launchState.launchedFromApp) {
    Task launchTarget=stack.getLaunchTarget();
    int launchTaskIndexInStack=launchTarget != null ? stack.indexOfStackTask(launchTarget) : 0;
    MetricsLogger.count(this,""String_Node_Str"",1);
    MetricsLogger.histogram(this,""String_Node_Str"",launchTaskIndexInStack);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  int taskCount=mRecentsView.getStack().getTaskCount();
  MetricsLogger.histogram(this,""String_Node_Str"",taskCount);
  mIsVisible=true;
}","/** 
 * Reloads the stack views upon launching Recents.
 */
private void reloadStackView(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan loadPlan=RecentsImpl.consumeInstanceLoadPlan();
  if (loadPlan == null) {
    loadPlan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!loadPlan.hasTasks()) {
    loader.preloadTasks(loadPlan,launchState.launchedToTaskId,!launchState.launchedFromHome);
  }
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=launchState.launchedNumVisibleTasks;
  loadOpts.numVisibleTaskThumbnails=launchState.launchedNumVisibleThumbnails;
  loader.loadTasks(this,loadPlan,loadOpts);
  TaskStack stack=loadPlan.getTaskStack();
  mRecentsView.onReload(mIsVisible,stack.getTaskCount() == 0);
  mRecentsView.updateStack(stack,true);
  boolean animateNavBarScrim=!launchState.launchedViaDockGesture;
  mScrimViews.updateNavBarScrim(animateNavBarScrim,stack.getTaskCount() > 0,null);
  boolean wasLaunchedByAm=!launchState.launchedFromHome && !launchState.launchedFromApp;
  if (wasLaunchedByAm) {
    EventBus.getDefault().send(new EnterRecentsWindowAnimationCompletedEvent());
  }
  if (launchState.launchedWithAltTab) {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  if (launchState.launchedFromApp) {
    Task launchTarget=stack.getLaunchTarget();
    int launchTaskIndexInStack=launchTarget != null ? stack.indexOfStackTask(launchTarget) : 0;
    MetricsLogger.count(this,""String_Node_Str"",1);
    MetricsLogger.histogram(this,""String_Node_Str"",launchTaskIndexInStack);
  }
 else {
    MetricsLogger.count(this,""String_Node_Str"",1);
  }
  int taskCount=mRecentsView.getStack().getTaskCount();
  MetricsLogger.histogram(this,""String_Node_Str"",taskCount);
  mIsVisible=true;
}",0.9997519225998512
191636,"/** 
 * Transitions to the next affiliated task.
 */
public void showRelativeAffiliatedTask(boolean showNextTask){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,true);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  if (SystemServicesProxy.isHomeStack(runningTask.stackId))   return;
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  int numAffiliatedTasks=0;
  for (int i=0; i < taskCount; i++) {
    Task task=tasks.get(i);
    if (task.key.id == runningTask.id) {
      TaskGrouping group=task.group;
      Task.TaskKey toTaskKey;
      if (showNextTask) {
        toTaskKey=group.getNextTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_launch_next_affiliated_task_source);
      }
 else {
        toTaskKey=group.getPrevTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      }
      if (toTaskKey != null) {
        toTask=focusedStack.findTaskWithId(toTaskKey.id);
      }
      numAffiliatedTasks=group.getTaskCount();
      break;
    }
  }
  if (toTask == null) {
    if (numAffiliatedTasks > 1) {
      if (showNextTask) {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_next_affiliated_task_bounce));
      }
 else {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
      }
    }
    return;
  }
  MetricsLogger.count(mContext,""String_Node_Str"",1);
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}","/** 
 * Transitions to the next affiliated task.
 */
public void showRelativeAffiliatedTask(boolean showNextTask){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,false);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  if (SystemServicesProxy.isHomeStack(runningTask.stackId))   return;
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  int numAffiliatedTasks=0;
  for (int i=0; i < taskCount; i++) {
    Task task=tasks.get(i);
    if (task.key.id == runningTask.id) {
      TaskGrouping group=task.group;
      Task.TaskKey toTaskKey;
      if (showNextTask) {
        toTaskKey=group.getNextTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_launch_next_affiliated_task_source);
      }
 else {
        toTaskKey=group.getPrevTaskInGroup(task);
        launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      }
      if (toTaskKey != null) {
        toTask=focusedStack.findTaskWithId(toTaskKey.id);
      }
      numAffiliatedTasks=group.getTaskCount();
      break;
    }
  }
  if (toTask == null) {
    if (numAffiliatedTasks > 1) {
      if (showNextTask) {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_next_affiliated_task_bounce));
      }
 else {
        ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
      }
    }
    return;
  }
  MetricsLogger.count(mContext,""String_Node_Str"",1);
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}",0.9984
191637,"public void preloadRecents(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  MutableBoolean isHomeStackVisible=new MutableBoolean(true);
  if (!ssp.isRecentsActivityVisible(isHomeStackVisible)) {
    ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
    RecentsTaskLoader loader=Recents.getTaskLoader();
    sInstanceLoadPlan=loader.createLoadPlan(mContext);
    sInstanceLoadPlan.preloadRawTasks(isHomeStackVisible.value);
    loader.preloadTasks(sInstanceLoadPlan,runningTask.id,isHomeStackVisible.value);
    TaskStack stack=sInstanceLoadPlan.getTaskStack();
    if (stack.getTaskCount() > 0) {
      preloadIcon(runningTask);
      updateHeaderBarLayout(stack,null);
    }
  }
}","public void preloadRecents(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  MutableBoolean isHomeStackVisible=new MutableBoolean(true);
  if (!ssp.isRecentsActivityVisible(isHomeStackVisible)) {
    ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
    RecentsTaskLoader loader=Recents.getTaskLoader();
    sInstanceLoadPlan=loader.createLoadPlan(mContext);
    sInstanceLoadPlan.preloadRawTasks(!isHomeStackVisible.value);
    loader.preloadTasks(sInstanceLoadPlan,runningTask.id,!isHomeStackVisible.value);
    TaskStack stack=sInstanceLoadPlan.getTaskStack();
    if (stack.getTaskCount() > 0) {
      preloadIcon(runningTask);
      updateHeaderBarLayout(stack,null);
    }
  }
}",0.998589562764457
191638,"public RecentsImpl(Context context){
  mContext=context;
  mHandler=new Handler();
  ForegroundThread.get();
  mTaskStackListener=new TaskStackListenerImpl();
  SystemServicesProxy ssp=Recents.getSystemServices();
  ssp.registerTaskStackListener(mTaskStackListener);
  LayoutInflater inflater=LayoutInflater.from(mContext);
  mDummyStackView=new TaskStackView(mContext);
  mHeaderBar=(TaskViewHeader)inflater.inflate(R.layout.recents_task_view_header,null,false);
  reloadResources();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,true);
  RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
  launchOpts.numVisibleTasks=loader.getIconCacheSize();
  launchOpts.numVisibleTaskThumbnails=loader.getThumbnailCacheSize();
  launchOpts.onlyLoadForCache=true;
  loader.loadTasks(mContext,plan,launchOpts);
}","public RecentsImpl(Context context){
  mContext=context;
  mHandler=new Handler();
  ForegroundThread.get();
  mTaskStackListener=new TaskStackListenerImpl();
  SystemServicesProxy ssp=Recents.getSystemServices();
  ssp.registerTaskStackListener(mTaskStackListener);
  LayoutInflater inflater=LayoutInflater.from(mContext);
  mDummyStackView=new TaskStackView(mContext);
  mHeaderBar=(TaskViewHeader)inflater.inflate(R.layout.recents_task_view_header,null,false);
  reloadResources();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,false);
  RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
  launchOpts.numVisibleTasks=loader.getIconCacheSize();
  launchOpts.numVisibleTaskThumbnails=loader.getThumbnailCacheSize();
  launchOpts.onlyLoadForCache=true;
  loader.loadTasks(mContext,plan,launchOpts);
}",0.9961935834692768
191639,"/** 
 * Transitions to the next recent task in the stack.
 */
public void showNextTask(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,true);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  boolean isRunningTaskInHomeStack=SystemServicesProxy.isHomeStack(runningTask.stackId);
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  for (int i=taskCount - 1; i >= 1; i--) {
    Task task=tasks.get(i);
    if (isRunningTaskInHomeStack) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_fast_toggle_app_home_exit);
      break;
    }
 else     if (task.key.id == runningTask.id) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      break;
    }
  }
  if (toTask == null) {
    ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
    return;
  }
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}","/** 
 * Transitions to the next recent task in the stack.
 */
public void showNextTask(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
  loader.preloadTasks(plan,-1,false);
  TaskStack focusedStack=plan.getTaskStack();
  if (focusedStack == null || focusedStack.getTaskCount() == 0)   return;
  ActivityManager.RunningTaskInfo runningTask=ssp.getRunningTask();
  if (runningTask == null)   return;
  boolean isRunningTaskInHomeStack=SystemServicesProxy.isHomeStack(runningTask.stackId);
  ArrayList<Task> tasks=focusedStack.getStackTasks();
  Task toTask=null;
  ActivityOptions launchOpts=null;
  int taskCount=tasks.size();
  for (int i=taskCount - 1; i >= 1; i--) {
    Task task=tasks.get(i);
    if (isRunningTaskInHomeStack) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_next_affiliated_task_target,R.anim.recents_fast_toggle_app_home_exit);
      break;
    }
 else     if (task.key.id == runningTask.id) {
      toTask=tasks.get(i - 1);
      launchOpts=ActivityOptions.makeCustomAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_target,R.anim.recents_launch_prev_affiliated_task_source);
      break;
    }
  }
  if (toTask == null) {
    ssp.startInPlaceAnimationOnFrontMostApplication(ActivityOptions.makeCustomInPlaceAnimation(mContext,R.anim.recents_launch_prev_affiliated_task_bounce));
    return;
  }
  ssp.startActivityFromRecents(mContext,toTask.key,toTask.title,launchOpts);
}",0.9978118161925602
191640,"@Override public void onTaskStackChanged(){
  RecentsConfiguration config=Recents.getConfiguration();
  if (config.svelteLevel == RecentsConfiguration.SVELTE_NONE) {
    RecentsTaskLoader loader=Recents.getTaskLoader();
    SystemServicesProxy ssp=Recents.getSystemServices();
    ActivityManager.RunningTaskInfo runningTaskInfo=ssp.getRunningTask();
    RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
    loader.preloadTasks(plan,-1,true);
    RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
    if (runningTaskInfo != null) {
      launchOpts.runningTaskId=runningTaskInfo.id;
    }
    launchOpts.numVisibleTasks=2;
    launchOpts.numVisibleTaskThumbnails=2;
    launchOpts.onlyLoadForCache=true;
    launchOpts.onlyLoadPausedActivities=true;
    loader.loadTasks(mContext,plan,launchOpts);
  }
}","@Override public void onTaskStackChanged(){
  RecentsConfiguration config=Recents.getConfiguration();
  if (config.svelteLevel == RecentsConfiguration.SVELTE_NONE) {
    RecentsTaskLoader loader=Recents.getTaskLoader();
    SystemServicesProxy ssp=Recents.getSystemServices();
    ActivityManager.RunningTaskInfo runningTaskInfo=ssp.getRunningTask();
    RecentsTaskLoadPlan plan=loader.createLoadPlan(mContext);
    loader.preloadTasks(plan,-1,false);
    RecentsTaskLoadPlan.Options launchOpts=new RecentsTaskLoadPlan.Options();
    if (runningTaskInfo != null) {
      launchOpts.runningTaskId=runningTaskInfo.id;
    }
    launchOpts.numVisibleTasks=2;
    launchOpts.numVisibleTaskThumbnails=2;
    launchOpts.onlyLoadForCache=true;
    launchOpts.onlyLoadPausedActivities=true;
    loader.loadTasks(mContext,plan,launchOpts);
  }
}",0.99581589958159
191641,"/** 
 * Returns a list of the recents tasks.
 * @param isHomeStackVisible whether or not the home stack is currently visible.  If it isvisible, then we ignore all excluded tasks (even the first one).
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean isHomeStackVisible,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=i;
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  List<ActivityManager.RecentTaskInfo> tasks=mAm.getRecentTasksForUser(numTasksToQuery,ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES| ActivityManager.RECENT_WITH_EXCLUDED,userId);
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    boolean isBlackListed=sRecentsBlacklist.contains(t.realActivity.getClassName());
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isBlackListed || (isExcluded && (isHomeStackVisible || !isFirstValidTask))) {
      iter.remove();
      continue;
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}","/** 
 * Returns a list of the recents tasks.
 * @param includeFrontMostExcludedTask if set, will ensure that the front most excluded taskwill be visible, otherwise no excluded tasks will be visible.
 */
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int numLatestTasks,int userId,boolean includeFrontMostExcludedTask,ArraySet<Integer> quietProfileIds){
  if (mAm == null)   return null;
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    ArrayList<ActivityManager.RecentTaskInfo> tasks=new ArrayList<ActivityManager.RecentTaskInfo>();
    int count=Math.min(numLatestTasks,RecentsDebugFlags.Static.MockTaskCount);
    for (int i=0; i < count; i++) {
      int packageIndex=i % RecentsDebugFlags.Static.MockTasksPackageCount;
      ComponentName cn=new ComponentName(""String_Node_Str"" + packageIndex,""String_Node_Str"" + i + ""String_Node_Str"");
      String description=""String_Node_Str"" + i + ""String_Node_Str""+ Long.toString(Math.abs(new Random().nextLong()),36);
      ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
      rti.id=rti.persistentId=rti.affiliatedTaskId=i;
      rti.baseIntent=new Intent();
      rti.baseIntent.setComponent(cn);
      rti.description=description;
      rti.firstActiveTime=rti.lastActiveTime=i;
      if (i % 2 == 0) {
        rti.taskDescription=new ActivityManager.TaskDescription(description,Bitmap.createBitmap(mDummyIcon),null,0xFF000000 | (0xFFFFFF & new Random().nextInt()),0xFF000000 | (0xFFFFFF & new Random().nextInt()));
      }
 else {
        rti.taskDescription=new ActivityManager.TaskDescription();
      }
      tasks.add(rti);
    }
    return tasks;
  }
  int minNumTasksToQuery=10;
  int numTasksToQuery=Math.max(minNumTasksToQuery,numLatestTasks);
  int flags=ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS| ActivityManager.RECENT_IGNORE_UNAVAILABLE| ActivityManager.RECENT_INCLUDE_PROFILES;
  if (includeFrontMostExcludedTask) {
    flags|=ActivityManager.RECENT_WITH_EXCLUDED;
  }
  List<ActivityManager.RecentTaskInfo> tasks=mAm.getRecentTasksForUser(numTasksToQuery,flags,userId);
  if (tasks == null) {
    return new ArrayList<>();
  }
  boolean isFirstValidTask=true;
  Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
  while (iter.hasNext()) {
    ActivityManager.RecentTaskInfo t=iter.next();
    if (sRecentsBlacklist.contains(t.realActivity.getClassName())) {
      iter.remove();
    }
    boolean isExcluded=(t.baseIntent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
    isExcluded|=quietProfileIds.contains(t.userId);
    if (isExcluded && (!isFirstValidTask || !includeFrontMostExcludedTask)) {
      iter.remove();
    }
    isFirstValidTask=false;
  }
  return tasks.subList(0,Math.min(tasks.size(),numLatestTasks));
}",0.8510786360473208
191642,"/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean isHomeStackVisible){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(isHomeStackVisible);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  long lastStackActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    lastStackActiveTime=0;
  }
  long newLastStackActiveTime=-1;
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=SystemServicesProxy.isFreeformStack(t.stackId);
    boolean isStackTask=isFreeformTask || !isHistoricalTask(t) || (t.lastActiveTime >= lastStackActiveTime && i >= (taskCount - MIN_NUM_TASKS));
    boolean isLaunchTarget=taskKey.id == runningTaskId;
    if (isStackTask && newLastStackActiveTime < 0) {
      newLastStackActiveTime=t.lastActiveTime;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (newLastStackActiveTime != -1) {
    Prefs.putLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,newLastStackActiveTime);
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}","/** 
 * Preloads the list of recent tasks from the system. After this call, the TaskStack will have a list of all the recent tasks with their metadata, not including icons or thumbnails which were not cached and have to be loaded. The tasks will be ordered by: - least-recent to most-recent stack tasks - least-recent to most-recent freeform tasks
 */
public synchronized void preloadPlan(RecentsTaskLoader loader,int runningTaskId,boolean includeFrontMostExcludedTask){
  Resources res=mContext.getResources();
  ArrayList<Task> allTasks=new ArrayList<>();
  if (mRawTasks == null) {
    preloadRawTasks(includeFrontMostExcludedTask);
  }
  SparseArray<Task.TaskKey> affiliatedTasks=new SparseArray<>();
  SparseIntArray affiliatedTaskCounts=new SparseIntArray();
  String dismissDescFormat=mContext.getString(R.string.accessibility_recents_item_will_be_dismissed);
  String appInfoDescFormat=mContext.getString(R.string.accessibility_recents_item_open_app_info);
  long lastStackActiveTime=Prefs.getLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,0);
  if (RecentsDebugFlags.Static.EnableMockTasks) {
    lastStackActiveTime=0;
  }
  long newLastStackActiveTime=-1;
  int taskCount=mRawTasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=mRawTasks.get(i);
    Task.TaskKey taskKey=new Task.TaskKey(t.persistentId,t.stackId,t.baseIntent,t.userId,t.firstActiveTime,t.lastActiveTime);
    boolean isFreeformTask=SystemServicesProxy.isFreeformStack(t.stackId);
    boolean isStackTask=isFreeformTask || !isHistoricalTask(t) || (t.lastActiveTime >= lastStackActiveTime && i >= (taskCount - MIN_NUM_TASKS));
    boolean isLaunchTarget=taskKey.id == runningTaskId;
    if (isStackTask && newLastStackActiveTime < 0) {
      newLastStackActiveTime=t.lastActiveTime;
    }
    ActivityInfo info=loader.getAndUpdateActivityInfo(taskKey);
    String title=loader.getAndUpdateActivityTitle(taskKey,t.taskDescription);
    String titleDescription=loader.getAndUpdateContentDescription(taskKey,res);
    String dismissDescription=String.format(dismissDescFormat,titleDescription);
    String appInfoDescription=String.format(appInfoDescFormat,titleDescription);
    Drawable icon=isStackTask ? loader.getAndUpdateActivityIcon(taskKey,t.taskDescription,res,false) : null;
    Bitmap thumbnail=loader.getAndUpdateThumbnail(taskKey,false);
    int activityColor=loader.getActivityPrimaryColor(t.taskDescription);
    int backgroundColor=loader.getActivityBackgroundColor(t.taskDescription);
    boolean isSystemApp=(info != null) && ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);
    Task task=new Task(taskKey,t.affiliatedTaskId,t.affiliatedTaskColor,icon,thumbnail,title,titleDescription,dismissDescription,appInfoDescription,activityColor,backgroundColor,isLaunchTarget,isStackTask,isSystemApp,t.isDockable,t.bounds,t.taskDescription,t.resizeMode,t.topActivity);
    allTasks.add(task);
    affiliatedTaskCounts.put(taskKey.id,affiliatedTaskCounts.get(taskKey.id,0) + 1);
    affiliatedTasks.put(taskKey.id,taskKey);
  }
  if (newLastStackActiveTime != -1) {
    Prefs.putLong(mContext,Prefs.Key.OVERVIEW_LAST_STACK_TASK_ACTIVE_TIME,newLastStackActiveTime);
  }
  mStack=new TaskStack();
  mStack.setTasks(mContext,allTasks,false);
}",0.9865894544346236
191643,"/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean isHomeStackVisible){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  SystemServicesProxy ssp=Recents.getSystemServices();
  mRawTasks=ssp.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,isHomeStackVisible,mCurrentQuietProfiles);
  Collections.reverse(mRawTasks);
}","/** 
 * An optimization to preload the raw list of tasks. The raw tasks are saved in least-recent to most-recent order.
 */
public synchronized void preloadRawTasks(boolean includeFrontMostExcludedTask){
  int currentUserId=UserHandle.USER_CURRENT;
  updateCurrentQuietProfilesCache(currentUserId);
  SystemServicesProxy ssp=Recents.getSystemServices();
  mRawTasks=ssp.getRecentTasks(ActivityManager.getMaxRecentTasksStatic(),currentUserId,includeFrontMostExcludedTask,mCurrentQuietProfiles);
  Collections.reverse(mRawTasks);
}",0.9152215799614644
191644,"/** 
 * Preloads recents tasks using the specified plan to store the output. 
 */
public void preloadTasks(RecentsTaskLoadPlan plan,int runningTaskId,boolean isHomeStackVisible){
  plan.preloadPlan(this,runningTaskId,isHomeStackVisible);
}","/** 
 * Preloads recents tasks using the specified plan to store the output. 
 */
public void preloadTasks(RecentsTaskLoadPlan plan,int runningTaskId,boolean includeFrontMostExcludedTask){
  plan.preloadPlan(this,runningTaskId,includeFrontMostExcludedTask);
}",0.8232931726907631
191645,"private void updateRecentsTasks(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=RecentsImpl.consumeInstanceLoadPlan();
  if (plan == null) {
    plan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!plan.hasTasks()) {
    loader.preloadTasks(plan,-1,launchState.launchedFromHome);
  }
  mLaunchedFromHome=launchState.launchedFromHome;
  TaskStack stack=plan.getTaskStack();
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=stack.getStackTaskCount();
  loadOpts.numVisibleTaskThumbnails=stack.getStackTaskCount();
  loader.loadTasks(this,plan,loadOpts);
  mRecentsView.setTaskStack(stack);
  List stackTasks=stack.getStackTasks();
  Collections.reverse(stackTasks);
  if (mTaskStackViewAdapter == null) {
    mTaskStackViewAdapter=new TaskStackHorizontalViewAdapter(stackTasks);
    mTaskStackHorizontalGridView=mRecentsView.setTaskStackViewAdapter(mTaskStackViewAdapter);
  }
 else {
    mTaskStackViewAdapter.setNewStackTasks(stackTasks);
  }
  if (launchState.launchedToTaskId != -1) {
    ArrayList<Task> tasks=stack.getStackTasks();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      Task t=tasks.get(i);
      if (t.key.id == launchState.launchedToTaskId) {
        t.isLaunchTarget=true;
        break;
      }
    }
  }
}","private void updateRecentsTasks(){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  RecentsTaskLoadPlan plan=RecentsImpl.consumeInstanceLoadPlan();
  if (plan == null) {
    plan=loader.createLoadPlan(this);
  }
  RecentsConfiguration config=Recents.getConfiguration();
  RecentsActivityLaunchState launchState=config.getLaunchState();
  if (!plan.hasTasks()) {
    loader.preloadTasks(plan,-1,!launchState.launchedFromHome);
  }
  mLaunchedFromHome=launchState.launchedFromHome;
  TaskStack stack=plan.getTaskStack();
  RecentsTaskLoadPlan.Options loadOpts=new RecentsTaskLoadPlan.Options();
  loadOpts.runningTaskId=launchState.launchedToTaskId;
  loadOpts.numVisibleTasks=stack.getStackTaskCount();
  loadOpts.numVisibleTaskThumbnails=stack.getStackTaskCount();
  loader.loadTasks(this,plan,loadOpts);
  mRecentsView.setTaskStack(stack);
  List stackTasks=stack.getStackTasks();
  Collections.reverse(stackTasks);
  if (mTaskStackViewAdapter == null) {
    mTaskStackViewAdapter=new TaskStackHorizontalViewAdapter(stackTasks);
    mTaskStackHorizontalGridView=mRecentsView.setTaskStackViewAdapter(mTaskStackViewAdapter);
  }
 else {
    mTaskStackViewAdapter.setNewStackTasks(stackTasks);
  }
  if (launchState.launchedToTaskId != -1) {
    ArrayList<Task> tasks=stack.getStackTasks();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      Task t=tasks.get(i);
      if (t.key.id == launchState.launchedToTaskId) {
        t.isLaunchTarget=true;
        break;
      }
    }
  }
}",0.9996692027786966
191646,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification) && !entry.row.isRemoved();
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && !childWithVisibleSummary && (visibleNotifications >= maxNotifications || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification) && !entry.row.isRemoved();
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && !childWithVisibleSummary && (visibleNotifications >= maxNotifications || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification && !entry.row.isRemoved()) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9944774851316908
191647,"private boolean shouldShowOnKeyguard(StatusBarNotification sbn){
  return mShowLockscreenNotifications && !mNotificationData.isAmbient(sbn.getKey());
}","public boolean shouldShowOnKeyguard(StatusBarNotification sbn){
  return mShowLockscreenNotifications && !mNotificationData.isAmbient(sbn.getKey());
}",0.9700996677740864
191648,"/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(((ExpandableNotificationRow)child).getStatusBarNotification());
    if (suppressedSummary) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}","/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    ExpandableNotificationRow row=(ExpandableNotificationRow)child;
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(row.getStatusBarNotification());
    if (suppressedSummary) {
      continue;
    }
    if (!mStatusBar.shouldShowOnKeyguard(row.getStatusBarNotification())) {
      continue;
    }
    if (row.isRemoved()) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}",0.8821052631578947
191649,"/** 
 * Ensures that the group children are cancelled immediately when the group summary is cancelled instead of waiting for the notification manager to send all cancels. Otherwise this could lead to flickers. This also ensures that the animation looks nice and only consists of a single disappear animation instead of multiple.
 * @param key the key of the notification was removed
 * @param ranking the current ranking
 */
private void handleGroupSummaryRemoved(String key,RankingMap ranking){
  Entry entry=mNotificationData.get(key);
  if (entry != null && entry.row != null && entry.row.isSummaryWithChildren()) {
    if (entry.notification.getOverrideGroupKey() != null && !entry.row.isDismissed()) {
      return;
    }
    entry.row.setRemoved(true);
    List<ExpandableNotificationRow> notificationChildren=entry.row.getNotificationChildren();
    ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>(notificationChildren);
    for (int i=0; i < toRemove.size(); i++) {
      toRemove.get(i).setKeepInParent(true);
    }
    for (int i=0; i < toRemove.size(); i++) {
      removeNotification(toRemove.get(i).getStatusBarNotification().getKey(),ranking);
      mStackScroller.removeViewStateForView(toRemove.get(i));
    }
  }
}","/** 
 * Ensures that the group children are cancelled immediately when the group summary is cancelled instead of waiting for the notification manager to send all cancels. Otherwise this could lead to flickers. This also ensures that the animation looks nice and only consists of a single disappear animation instead of multiple.
 * @param key the key of the notification was removed
 * @param ranking the current ranking
 */
private void handleGroupSummaryRemoved(String key,RankingMap ranking){
  Entry entry=mNotificationData.get(key);
  if (entry != null && entry.row != null && entry.row.isSummaryWithChildren()) {
    if (entry.notification.getOverrideGroupKey() != null && !entry.row.isDismissed()) {
      return;
    }
    entry.row.setRemoved(true);
    List<ExpandableNotificationRow> notificationChildren=entry.row.getNotificationChildren();
    ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>(notificationChildren);
    for (int i=0; i < toRemove.size(); i++) {
      toRemove.get(i).setKeepInParent(true);
      toRemove.get(i).setRemoved(true);
    }
    for (int i=0; i < toRemove.size(); i++) {
      removeNotification(toRemove.get(i).getStatusBarNotification().getKey(),ranking);
      mStackScroller.removeViewStateForView(toRemove.get(i));
    }
  }
}",0.984189723320158
191650,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  for (int i=0; i < childCount; i++) {
    View child=mChildren.get(i);
    if (child.getVisibility() == View.GONE) {
      continue;
    }
    child.layout(0,0,child.getMeasuredWidth(),child.getMeasuredHeight());
    mDividers.get(i).layout(0,0,getWidth(),mDividerHeight);
  }
  if (mOverflowNumber != null) {
    mOverflowNumber.layout(getWidth() - mOverflowNumber.getMeasuredWidth(),0,getWidth(),mOverflowNumber.getMeasuredHeight());
  }
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  for (int i=0; i < childCount; i++) {
    View child=mChildren.get(i);
    child.layout(0,0,child.getMeasuredWidth(),child.getMeasuredHeight());
    mDividers.get(i).layout(0,0,getWidth(),mDividerHeight);
  }
  if (mOverflowNumber != null) {
    mOverflowNumber.layout(getWidth() - mOverflowNumber.getMeasuredWidth(),0,getWidth(),mOverflowNumber.getMeasuredHeight());
  }
}",0.9404553415061296
191651,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxNotificationHeight;
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int size=MeasureSpec.getSize(heightMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    ownMaxHeight=Math.min(ownMaxHeight,size);
  }
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (mOverflowNumber != null) {
    mOverflowNumber.measure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.AT_MOST),newHeightSpec);
  }
  int dividerHeightSpec=MeasureSpec.makeMeasureSpec(mDividerHeight,MeasureSpec.EXACTLY);
  int height=mNotificationHeaderHeight + mNotificatonTopPadding;
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  int collapsedChildren=getMaxAllowedVisibleChildren(true);
  int overflowIndex=childCount > collapsedChildren ? collapsedChildren - 1 : -1;
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    boolean isOverflow=i == overflowIndex;
    child.setSingleLineWidthIndention(isOverflow && mOverflowNumber != null ? mOverflowNumber.getMeasuredWidth() : 0);
    child.measure(widthMeasureSpec,newHeightSpec);
    height+=child.getMeasuredHeight();
    View divider=mDividers.get(i);
    divider.measure(widthMeasureSpec,dividerHeightSpec);
    height+=mDividerHeight;
  }
  mRealHeight=height;
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    height=Math.min(height,size);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int ownMaxHeight=mMaxNotificationHeight;
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int size=MeasureSpec.getSize(heightMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    ownMaxHeight=Math.min(ownMaxHeight,size);
  }
  int newHeightSpec=MeasureSpec.makeMeasureSpec(ownMaxHeight,MeasureSpec.AT_MOST);
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (mOverflowNumber != null) {
    mOverflowNumber.measure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.AT_MOST),newHeightSpec);
  }
  int dividerHeightSpec=MeasureSpec.makeMeasureSpec(mDividerHeight,MeasureSpec.EXACTLY);
  int height=mNotificationHeaderHeight + mNotificatonTopPadding;
  int childCount=Math.min(mChildren.size(),NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED);
  int collapsedChildren=getMaxAllowedVisibleChildren(true);
  int overflowIndex=childCount > collapsedChildren ? collapsedChildren - 1 : -1;
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    boolean isOverflow=i == overflowIndex;
    child.setSingleLineWidthIndention(isOverflow && mOverflowNumber != null ? mOverflowNumber.getMeasuredWidth() : 0);
    child.measure(widthMeasureSpec,newHeightSpec);
    View divider=mDividers.get(i);
    divider.measure(widthMeasureSpec,dividerHeightSpec);
    if (child.getVisibility() != GONE) {
      height+=child.getMeasuredHeight() + mDividerHeight;
    }
  }
  mRealHeight=height;
  if (heightMode != MeasureSpec.UNSPECIFIED) {
    height=Math.min(height,size);
  }
  setMeasuredDimension(width,height);
}",0.9225880993645292
191652,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  float centerX=getWidth() / 2.0f;
  for (int i=0; i < getChildCount(); i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == GONE) {
      continue;
    }
    float width=child.getMeasuredWidth();
    float height=child.getMeasuredHeight();
    child.layout((int)(centerX - width / 2.0f),0,(int)(centerX + width / 2.0f),(int)height);
  }
  setMaxLayoutHeight(getHeight());
  updateContentHeight();
  clampScrollPosition();
  if (mRequestViewResizeAnimationOnLayout) {
    requestAnimationOnViewResize(null);
    mRequestViewResizeAnimationOnLayout=false;
  }
  requestChildrenUpdate();
  updateFirstAndLastBackgroundViews();
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  float centerX=getWidth() / 2.0f;
  for (int i=0; i < getChildCount(); i++) {
    View child=getChildAt(i);
    float width=child.getMeasuredWidth();
    float height=child.getMeasuredHeight();
    child.layout((int)(centerX - width / 2.0f),0,(int)(centerX + width / 2.0f),(int)height);
  }
  setMaxLayoutHeight(getHeight());
  updateContentHeight();
  clampScrollPosition();
  if (mRequestViewResizeAnimationOnLayout) {
    requestAnimationOnViewResize(null);
    mRequestViewResizeAnimationOnLayout=false;
  }
  requestChildrenUpdate();
  updateFirstAndLastBackgroundViews();
}",0.954181818181818
191653,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  measureChildren(widthMeasureSpec,heightMeasureSpec);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  final int size=getChildCount();
  for (int i=0; i < size; i++) {
    measureChild(getChildAt(i),widthMeasureSpec,heightMeasureSpec);
  }
}",0.8025751072961373
191654,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification _foregroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerInternal nm=LocalServices.getService(NotificationManagerInternal.class);
        if (nm == null) {
          return;
        }
        Notification localForegroundNoti=_foregroundNoti;
        try {
          if (localForegroundNoti.getSmallIcon() == null) {
            Slog.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ localForegroundNoti+ ""String_Node_Str"");
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Notification.Builder notiBuilder=new Notification.Builder(ctx);
              notiBuilder.setSmallIcon(appInfo.icon);
              notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE,true);
              notiBuilder.setPriority(Notification.PRIORITY_MIN);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              notiBuilder.setColor(ams.mContext.getColor(com.android.internal.R.color.system_notification_accent_color));
              notiBuilder.setContentTitle(ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName));
              notiBuilder.setContentText(ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName));
              notiBuilder.setContentIntent(pi);
              localForegroundNoti=notiBuilder.build();
            }
 catch (            PackageManager.NameNotFoundException e) {
            }
          }
          if (localForegroundNoti.getSmallIcon() == null) {
            throw new RuntimeException(""String_Node_Str"" + foregroundNoti);
          }
          int[] outId=new int[1];
          nm.enqueueNotification(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
          foregroundNoti=localForegroundNoti;
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,0);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification _foregroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerInternal nm=LocalServices.getService(NotificationManagerInternal.class);
        if (nm == null) {
          return;
        }
        Notification localForegroundNoti=_foregroundNoti;
        try {
          if (localForegroundNoti.getSmallIcon() == null) {
            Slog.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ localForegroundNoti+ ""String_Node_Str"");
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContextAsUser(appInfo.packageName,0,new UserHandle(userId));
              Notification.Builder notiBuilder=new Notification.Builder(ctx);
              notiBuilder.setSmallIcon(appInfo.icon);
              notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE,true);
              notiBuilder.setPriority(Notification.PRIORITY_MIN);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              notiBuilder.setColor(ams.mContext.getColor(com.android.internal.R.color.system_notification_accent_color));
              notiBuilder.setContentTitle(ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName));
              notiBuilder.setContentText(ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName));
              notiBuilder.setContentIntent(pi);
              localForegroundNoti=notiBuilder.build();
            }
 catch (            PackageManager.NameNotFoundException e) {
            }
          }
          if (localForegroundNoti.getSmallIcon() == null) {
            throw new RuntimeException(""String_Node_Str"" + foregroundNoti);
          }
          int[] outId=new int[1];
          nm.enqueueNotification(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
          foregroundNoti=localForegroundNoti;
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,0);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}",0.9950008619203584
191655,"void setTouchExcludeRegion(Task focusedTask){
  mTouchExcludeRegion.set(mBaseDisplayRect);
  final int delta=mService.dipToPixel(RESIZE_HANDLE_WIDTH_IN_DP,mDisplayMetrics);
  boolean addBackFocusedTask=false;
  mNonResizeableRegion.setEmpty();
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    TaskStack stack=mStacks.get(stackNdx);
    final ArrayList<Task> tasks=stack.getTasks();
    for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
      final Task task=tasks.get(taskNdx);
      AppWindowToken token=task.getTopVisibleAppToken();
      if (token == null || !token.isVisible()) {
        continue;
      }
      if (task == focusedTask) {
        addBackFocusedTask=true;
        mTmpRect2.set(mTmpRect);
      }
      final boolean isFreeformed=task.inFreeformWorkspace();
      if (task != focusedTask || isFreeformed) {
        task.getDimBounds(mTmpRect);
        if (isFreeformed) {
          mTmpRect.inset(-delta,-delta);
          mTmpRect.intersect(mContentRect);
        }
        mTouchExcludeRegion.op(mTmpRect,Region.Op.DIFFERENCE);
      }
      if (task.isTwoFingerScrollMode()) {
        stack.getBounds(mTmpRect);
        mNonResizeableRegion.op(mTmpRect,Region.Op.UNION);
        break;
      }
    }
  }
  if (addBackFocusedTask) {
    mTouchExcludeRegion.op(mTmpRect2,Region.Op.UNION);
  }
  final WindowState inputMethod=mService.mInputMethodWindow;
  if (inputMethod != null && inputMethod.isVisibleLw()) {
    inputMethod.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  for (int i=mTapExcludedWindows.size() - 1; i >= 0; i--) {
    WindowState win=mTapExcludedWindows.get(i);
    win.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  if (getDockedStackVisibleForUserLocked() != null) {
    mDividerControllerLocked.getTouchRegion(mTmpRect);
    mTmpRegion.set(mTmpRect);
    mTouchExcludeRegion.op(mTmpRegion,Op.UNION);
  }
  if (mTapDetector != null) {
    mTapDetector.setTouchExcludeRegion(mTouchExcludeRegion,mNonResizeableRegion);
  }
}","void setTouchExcludeRegion(Task focusedTask){
  mTouchExcludeRegion.set(mBaseDisplayRect);
  final int delta=mService.dipToPixel(RESIZE_HANDLE_WIDTH_IN_DP,mDisplayMetrics);
  boolean addBackFocusedTask=false;
  mNonResizeableRegion.setEmpty();
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    TaskStack stack=mStacks.get(stackNdx);
    final ArrayList<Task> tasks=stack.getTasks();
    for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
      final Task task=tasks.get(taskNdx);
      AppWindowToken token=task.getTopVisibleAppToken();
      if (token == null || !token.isVisible()) {
        continue;
      }
      task.getDimBounds(mTmpRect);
      if (task == focusedTask) {
        addBackFocusedTask=true;
        mTmpRect2.set(mTmpRect);
      }
      final boolean isFreeformed=task.inFreeformWorkspace();
      if (task != focusedTask || isFreeformed) {
        if (isFreeformed) {
          mTmpRect.inset(-delta,-delta);
          mTmpRect.intersect(mContentRect);
        }
        mTouchExcludeRegion.op(mTmpRect,Region.Op.DIFFERENCE);
      }
      if (task.isTwoFingerScrollMode()) {
        stack.getBounds(mTmpRect);
        mNonResizeableRegion.op(mTmpRect,Region.Op.UNION);
        break;
      }
    }
  }
  if (addBackFocusedTask) {
    mTouchExcludeRegion.op(mTmpRect2,Region.Op.UNION);
  }
  final WindowState inputMethod=mService.mInputMethodWindow;
  if (inputMethod != null && inputMethod.isVisibleLw()) {
    inputMethod.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  for (int i=mTapExcludedWindows.size() - 1; i >= 0; i--) {
    WindowState win=mTapExcludedWindows.get(i);
    win.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  if (getDockedStackVisibleForUserLocked() != null) {
    mDividerControllerLocked.getTouchRegion(mTmpRect);
    mTmpRegion.set(mTmpRect);
    mTouchExcludeRegion.op(mTmpRegion,Op.UNION);
  }
  if (mTapDetector != null) {
    mTapDetector.setTouchExcludeRegion(mTouchExcludeRegion,mNonResizeableRegion);
  }
}",0.9827998088867654
191656,"void setTouchExcludeRegion(Task focusedTask){
  mTouchExcludeRegion.set(mBaseDisplayRect);
  final int delta=mService.dipToPixel(RESIZE_HANDLE_WIDTH_IN_DP,mDisplayMetrics);
  boolean addBackFocusedTask=false;
  mNonResizeableRegion.setEmpty();
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    TaskStack stack=mStacks.get(stackNdx);
    final ArrayList<Task> tasks=stack.getTasks();
    for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
      final Task task=tasks.get(taskNdx);
      AppWindowToken token=task.getTopVisibleAppToken();
      if (token == null || !token.isVisible()) {
        continue;
      }
      if (task == focusedTask) {
        addBackFocusedTask=true;
        mTmpRect2.set(mTmpRect);
      }
      final boolean isFreeformed=task.inFreeformWorkspace();
      if (task != focusedTask || isFreeformed) {
        task.getDimBounds(mTmpRect);
        if (isFreeformed) {
          mTmpRect.inset(-delta,-delta);
          mTmpRect.intersect(mContentRect);
        }
        mTouchExcludeRegion.op(mTmpRect,Region.Op.DIFFERENCE);
      }
      if (task.isTwoFingerScrollMode()) {
        stack.getBounds(mTmpRect);
        mNonResizeableRegion.op(mTmpRect,Region.Op.UNION);
        break;
      }
    }
  }
  if (addBackFocusedTask) {
    mTouchExcludeRegion.op(mTmpRect2,Region.Op.UNION);
  }
  final WindowState inputMethod=mService.mInputMethodWindow;
  if (inputMethod != null && inputMethod.isVisibleLw()) {
    inputMethod.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  for (int i=mTapExcludedWindows.size() - 1; i >= 0; i--) {
    WindowState win=mTapExcludedWindows.get(i);
    win.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  if (getDockedStackVisibleForUserLocked() != null) {
    mDividerControllerLocked.getTouchRegion(mTmpRect);
    mTmpRegion.set(mTmpRect);
    mTouchExcludeRegion.op(mTmpRegion,Op.UNION);
  }
  if (mTapDetector != null) {
    mTapDetector.setTouchExcludeRegion(mTouchExcludeRegion,mNonResizeableRegion);
  }
}","void setTouchExcludeRegion(Task focusedTask){
  mTouchExcludeRegion.set(mBaseDisplayRect);
  final int delta=mService.dipToPixel(RESIZE_HANDLE_WIDTH_IN_DP,mDisplayMetrics);
  boolean addBackFocusedTask=false;
  mNonResizeableRegion.setEmpty();
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    TaskStack stack=mStacks.get(stackNdx);
    final ArrayList<Task> tasks=stack.getTasks();
    for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
      final Task task=tasks.get(taskNdx);
      AppWindowToken token=task.getTopVisibleAppToken();
      if (token == null || !token.isVisible()) {
        continue;
      }
      task.getDimBounds(mTmpRect);
      if (task == focusedTask) {
        addBackFocusedTask=true;
        mTmpRect2.set(mTmpRect);
      }
      final boolean isFreeformed=task.inFreeformWorkspace();
      if (task != focusedTask || isFreeformed) {
        if (isFreeformed) {
          mTmpRect.inset(-delta,-delta);
          mTmpRect.intersect(mContentRect);
        }
        mTouchExcludeRegion.op(mTmpRect,Region.Op.DIFFERENCE);
      }
      if (task.isTwoFingerScrollMode()) {
        stack.getBounds(mTmpRect);
        mNonResizeableRegion.op(mTmpRect,Region.Op.UNION);
        break;
      }
    }
  }
  if (addBackFocusedTask) {
    mTouchExcludeRegion.op(mTmpRect2,Region.Op.UNION);
  }
  final WindowState inputMethod=mService.mInputMethodWindow;
  if (inputMethod != null && inputMethod.isVisibleLw()) {
    inputMethod.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  for (int i=mTapExcludedWindows.size() - 1; i >= 0; i--) {
    WindowState win=mTapExcludedWindows.get(i);
    win.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  if (getDockedStackVisibleForUserLocked() != null) {
    mDividerControllerLocked.getTouchRegion(mTmpRect);
    mTmpRegion.set(mTmpRect);
    mTouchExcludeRegion.op(mTmpRegion,Op.UNION);
  }
  if (mTapDetector != null) {
    mTapDetector.setTouchExcludeRegion(mTouchExcludeRegion,mNonResizeableRegion);
  }
}",0.9827998088867654
191657,"void setTouchExcludeRegion(Task focusedTask){
  mTouchExcludeRegion.set(mBaseDisplayRect);
  final int delta=mService.dipToPixel(RESIZE_HANDLE_WIDTH_IN_DP,mDisplayMetrics);
  boolean addBackFocusedTask=false;
  mNonResizeableRegion.setEmpty();
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    TaskStack stack=mStacks.get(stackNdx);
    final ArrayList<Task> tasks=stack.getTasks();
    for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
      final Task task=tasks.get(taskNdx);
      AppWindowToken token=task.getTopVisibleAppToken();
      if (token == null || !token.isVisible()) {
        continue;
      }
      if (task == focusedTask) {
        addBackFocusedTask=true;
        mTmpRect2.set(mTmpRect);
      }
      final boolean isFreeformed=task.inFreeformWorkspace();
      if (task != focusedTask || isFreeformed) {
        task.getDimBounds(mTmpRect);
        if (isFreeformed) {
          mTmpRect.inset(-delta,-delta);
          mTmpRect.intersect(mContentRect);
        }
        mTouchExcludeRegion.op(mTmpRect,Region.Op.DIFFERENCE);
      }
      if (task.isTwoFingerScrollMode()) {
        stack.getBounds(mTmpRect);
        mNonResizeableRegion.op(mTmpRect,Region.Op.UNION);
        break;
      }
    }
  }
  if (addBackFocusedTask) {
    mTouchExcludeRegion.op(mTmpRect2,Region.Op.UNION);
  }
  final WindowState inputMethod=mService.mInputMethodWindow;
  if (inputMethod != null && inputMethod.isVisibleLw()) {
    inputMethod.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  for (int i=mTapExcludedWindows.size() - 1; i >= 0; i--) {
    WindowState win=mTapExcludedWindows.get(i);
    win.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  if (getDockedStackVisibleForUserLocked() != null) {
    mDividerControllerLocked.getTouchRegion(mTmpRect);
    mTmpRegion.set(mTmpRect);
    mTouchExcludeRegion.op(mTmpRegion,Op.UNION);
  }
  if (mTapDetector != null) {
    mTapDetector.setTouchExcludeRegion(mTouchExcludeRegion,mNonResizeableRegion);
  }
}","void setTouchExcludeRegion(Task focusedTask){
  mTouchExcludeRegion.set(mBaseDisplayRect);
  final int delta=mService.dipToPixel(RESIZE_HANDLE_WIDTH_IN_DP,mDisplayMetrics);
  boolean addBackFocusedTask=false;
  mNonResizeableRegion.setEmpty();
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    TaskStack stack=mStacks.get(stackNdx);
    final ArrayList<Task> tasks=stack.getTasks();
    for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
      final Task task=tasks.get(taskNdx);
      AppWindowToken token=task.getTopVisibleAppToken();
      if (token == null || !token.isVisible()) {
        continue;
      }
      task.getDimBounds(mTmpRect);
      if (task == focusedTask) {
        addBackFocusedTask=true;
        mTmpRect2.set(mTmpRect);
      }
      final boolean isFreeformed=task.inFreeformWorkspace();
      if (task != focusedTask || isFreeformed) {
        if (isFreeformed) {
          mTmpRect.inset(-delta,-delta);
          mTmpRect.intersect(mContentRect);
        }
        mTouchExcludeRegion.op(mTmpRect,Region.Op.DIFFERENCE);
      }
      if (task.isTwoFingerScrollMode()) {
        stack.getBounds(mTmpRect);
        mNonResizeableRegion.op(mTmpRect,Region.Op.UNION);
        break;
      }
    }
  }
  if (addBackFocusedTask) {
    mTouchExcludeRegion.op(mTmpRect2,Region.Op.UNION);
  }
  final WindowState inputMethod=mService.mInputMethodWindow;
  if (inputMethod != null && inputMethod.isVisibleLw()) {
    inputMethod.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  for (int i=mTapExcludedWindows.size() - 1; i >= 0; i--) {
    WindowState win=mTapExcludedWindows.get(i);
    win.getTouchableRegion(mTmpRegion);
    mTouchExcludeRegion.op(mTmpRegion,Region.Op.UNION);
  }
  if (getDockedStackVisibleForUserLocked() != null) {
    mDividerControllerLocked.getTouchRegion(mTmpRect);
    mTmpRegion.set(mTmpRect);
    mTouchExcludeRegion.op(mTmpRegion,Op.UNION);
  }
  if (mTapDetector != null) {
    mTapDetector.setTouchExcludeRegion(mTouchExcludeRegion,mNonResizeableRegion);
  }
}",0.9827998088867654
191658,"public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
}","public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
  mIsolatedEntries.remove(removed.key);
}",0.8540145985401459
191659,"public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}","public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (mGroupManager != null) {
    mGroupManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}",0.9866061293984107
191660,"@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf,Rect dcf,Rect sf,Rect osf){
  if (mWillReplaceWindow && (mAnimatingExit || !mReplacingRemoveRequested)) {
    return;
  }
  mHaveFrame=true;
  final Task task=getTask();
  final boolean fullscreenTask=!isInMultiWindowMode();
  final boolean windowsAreFloating=task != null && task.isFloating();
  if (fullscreenTask) {
    mInsetFrame.setEmpty();
  }
 else {
    task.getTempInsetBounds(mInsetFrame);
  }
  final Rect layoutContainingFrame;
  final Rect layoutDisplayFrame;
  final int layoutXDiff;
  final int layoutYDiff;
  if (mInsetFrame.isEmpty() && (fullscreenTask || layoutInParentFrame())) {
    mContainingFrame.set(pf);
    mDisplayFrame.set(df);
    layoutDisplayFrame=df;
    layoutContainingFrame=pf;
    layoutXDiff=0;
    layoutYDiff=0;
  }
 else {
    task.getBounds(mContainingFrame);
    if (mAppToken != null && !mAppToken.mFrozenBounds.isEmpty()) {
      Rect frozen=mAppToken.mFrozenBounds.peek();
      mContainingFrame.right=mContainingFrame.left + frozen.width();
      mContainingFrame.bottom=mContainingFrame.top + frozen.height();
    }
    final WindowState imeWin=mService.mInputMethodWindow;
    if (imeWin != null && imeWin.isVisibleNow() && mService.mInputMethodTarget == this) {
      if (windowsAreFloating && mContainingFrame.bottom > cf.bottom) {
        mContainingFrame.top-=mContainingFrame.bottom - cf.bottom;
      }
 else       if (mContainingFrame.bottom > pf.bottom) {
        mContainingFrame.bottom=pf.bottom;
      }
    }
    if (windowsAreFloating) {
      if (mContainingFrame.isEmpty()) {
        mContainingFrame.set(cf);
      }
    }
    mDisplayFrame.set(mContainingFrame);
    layoutXDiff=!mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : 0;
    layoutYDiff=!mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : 0;
    layoutContainingFrame=!mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame;
    mTmpRect.set(0,0,mDisplayContent.getDisplayInfo().logicalWidth,mDisplayContent.getDisplayInfo().logicalHeight);
    subtractInsets(mDisplayFrame,layoutContainingFrame,df,mTmpRect);
    if (!layoutInParentFrame()) {
      subtractInsets(mContainingFrame,layoutContainingFrame,pf,mTmpRect);
      subtractInsets(mInsetFrame,layoutContainingFrame,pf,mTmpRect);
    }
    layoutDisplayFrame=df;
    layoutDisplayFrame.intersect(layoutContainingFrame);
  }
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  mDecorFrame.set(dcf);
  mStableFrame.set(sf);
  final boolean hasOutsets=osf != null;
  if (hasOutsets) {
    mOutsetFrame.set(osf);
  }
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  applyGravityAndUpdateFrame(layoutContainingFrame,layoutDisplayFrame);
  if (hasOutsets) {
    mOutsets.set(Math.max(mContentFrame.left - mOutsetFrame.left,0),Math.max(mContentFrame.top - mOutsetFrame.top,0),Math.max(mOutsetFrame.right - mContentFrame.right,0),Math.max(mOutsetFrame.bottom - mContentFrame.bottom,0));
  }
 else {
    mOutsets.set(0,0,0,0);
  }
  if (windowsAreFloating && !mFrame.isEmpty()) {
    final int height=Math.min(mFrame.height(),mContentFrame.height());
    final int width=Math.min(mContentFrame.width(),mFrame.width());
    final DisplayMetrics displayMetrics=getDisplayContent().getDisplayMetrics();
    final int minVisibleHeight=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_HEIGHT_IN_DP,displayMetrics);
    final int minVisibleWidth=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_WIDTH_IN_DP,displayMetrics);
    final int top=Math.max(mContentFrame.top,Math.min(mFrame.top,mContentFrame.bottom - minVisibleHeight));
    final int left=Math.max(mContentFrame.left + minVisibleWidth - width,Math.min(mFrame.left,mContentFrame.right - minVisibleWidth));
    mFrame.set(left,top,left + width,top + height);
    mContentFrame.set(mFrame);
    mVisibleFrame.set(mContentFrame);
    mStableFrame.set(mContentFrame);
  }
 else   if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame);
    mContentFrame.set(mFrame);
    if (!mFrame.equals(mLastFrame)) {
      mMovedByResize=true;
    }
  }
 else {
    mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
    mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
    mStableFrame.set(Math.max(mStableFrame.left,mFrame.left),Math.max(mStableFrame.top,mFrame.top),Math.min(mStableFrame.right,mFrame.right),Math.min(mStableFrame.bottom,mFrame.bottom));
  }
  if (fullscreenTask && !windowsAreFloating) {
    mOverscanInsets.set(Math.max(mOverscanFrame.left - layoutContainingFrame.left,0),Math.max(mOverscanFrame.top - layoutContainingFrame.top,0),Math.max(layoutContainingFrame.right - mOverscanFrame.right,0),Math.max(layoutContainingFrame.bottom - mOverscanFrame.bottom,0));
  }
  if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mStableInsets.set(Math.max(mStableFrame.left - mDisplayFrame.left,0),Math.max(mStableFrame.top - mDisplayFrame.top,0),Math.max(mDisplayFrame.right - mStableFrame.right,0),Math.max(mDisplayFrame.bottom - mStableFrame.bottom,0));
    mContentInsets.setEmpty();
    mVisibleInsets.setEmpty();
  }
 else {
    getDisplayContent().getLogicalDisplayRect(mTmpRect);
    boolean overrideRightInset=!fullscreenTask && mFrame.right > mTmpRect.right;
    boolean overrideBottomInset=!fullscreenTask && mFrame.bottom > mTmpRect.bottom;
    mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mContentFrame.right : mFrame.right - mContentFrame.right,overrideBottomInset ? mTmpRect.bottom - mContentFrame.bottom : mFrame.bottom - mContentFrame.bottom);
    mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mVisibleFrame.right : mFrame.right - mVisibleFrame.right,overrideBottomInset ? mTmpRect.bottom - mVisibleFrame.bottom : mFrame.bottom - mVisibleFrame.bottom);
    mStableInsets.set(Math.max(mStableFrame.left - mFrame.left,0),Math.max(mStableFrame.top - mFrame.top,0),overrideRightInset ? Math.max(mTmpRect.right - mStableFrame.right,0) : Math.max(mFrame.right - mStableFrame.right,0),overrideBottomInset ? Math.max(mTmpRect.bottom - mStableFrame.bottom,0) : Math.max(mFrame.bottom - mStableFrame.bottom,0));
  }
  mFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.offset(-layoutXDiff,-layoutYDiff);
  mContentFrame.offset(-layoutXDiff,-layoutYDiff);
  mVisibleFrame.offset(-layoutXDiff,-layoutYDiff);
  mStableFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mStableInsets.scale(mInvGlobalScale);
    mOutsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayContent displayContent=getDisplayContent();
    if (displayContent != null) {
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      mService.mWallpaperControllerLocked.updateWallpaperOffset(this,displayInfo.logicalWidth,displayInfo.logicalHeight,false);
    }
  }
  if (DEBUG_LAYOUT || WindowManagerService.localLOGV)   Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString()+ ""String_Node_Str""+ mStableInsets.toShortString()+ ""String_Node_Str""+ mOutsets.toShortString());
}","@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf,Rect dcf,Rect sf,Rect osf){
  if (mWillReplaceWindow && (mAnimatingExit || !mReplacingRemoveRequested)) {
    return;
  }
  mHaveFrame=true;
  final Task task=getTask();
  final boolean fullscreenTask=!isInMultiWindowMode();
  final boolean windowsAreFloating=task != null && task.isFloating();
  if (fullscreenTask) {
    mInsetFrame.setEmpty();
  }
 else {
    task.getTempInsetBounds(mInsetFrame);
  }
  final Rect layoutContainingFrame;
  final Rect layoutDisplayFrame;
  final int layoutXDiff;
  final int layoutYDiff;
  if (fullscreenTask || layoutInParentFrame()) {
    mContainingFrame.set(pf);
    mDisplayFrame.set(df);
    layoutDisplayFrame=df;
    layoutContainingFrame=pf;
    layoutXDiff=0;
    layoutYDiff=0;
  }
 else {
    task.getBounds(mContainingFrame);
    if (mAppToken != null && !mAppToken.mFrozenBounds.isEmpty()) {
      Rect frozen=mAppToken.mFrozenBounds.peek();
      mContainingFrame.right=mContainingFrame.left + frozen.width();
      mContainingFrame.bottom=mContainingFrame.top + frozen.height();
    }
    final WindowState imeWin=mService.mInputMethodWindow;
    if (imeWin != null && imeWin.isVisibleNow() && mService.mInputMethodTarget == this) {
      if (windowsAreFloating && mContainingFrame.bottom > cf.bottom) {
        mContainingFrame.top-=mContainingFrame.bottom - cf.bottom;
      }
 else       if (mContainingFrame.bottom > pf.bottom) {
        mContainingFrame.bottom=pf.bottom;
      }
    }
    if (windowsAreFloating) {
      if (mContainingFrame.isEmpty()) {
        mContainingFrame.set(cf);
      }
    }
    mDisplayFrame.set(mContainingFrame);
    layoutXDiff=!mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : 0;
    layoutYDiff=!mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : 0;
    layoutContainingFrame=!mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame;
    mTmpRect.set(0,0,mDisplayContent.getDisplayInfo().logicalWidth,mDisplayContent.getDisplayInfo().logicalHeight);
    subtractInsets(mDisplayFrame,layoutContainingFrame,df,mTmpRect);
    if (!layoutInParentFrame()) {
      subtractInsets(mContainingFrame,layoutContainingFrame,pf,mTmpRect);
      subtractInsets(mInsetFrame,layoutContainingFrame,pf,mTmpRect);
    }
    layoutDisplayFrame=df;
    layoutDisplayFrame.intersect(layoutContainingFrame);
  }
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  mDecorFrame.set(dcf);
  mStableFrame.set(sf);
  final boolean hasOutsets=osf != null;
  if (hasOutsets) {
    mOutsetFrame.set(osf);
  }
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  applyGravityAndUpdateFrame(layoutContainingFrame,layoutDisplayFrame);
  if (hasOutsets) {
    mOutsets.set(Math.max(mContentFrame.left - mOutsetFrame.left,0),Math.max(mContentFrame.top - mOutsetFrame.top,0),Math.max(mOutsetFrame.right - mContentFrame.right,0),Math.max(mOutsetFrame.bottom - mContentFrame.bottom,0));
  }
 else {
    mOutsets.set(0,0,0,0);
  }
  if (windowsAreFloating && !mFrame.isEmpty()) {
    final int height=Math.min(mFrame.height(),mContentFrame.height());
    final int width=Math.min(mContentFrame.width(),mFrame.width());
    final DisplayMetrics displayMetrics=getDisplayContent().getDisplayMetrics();
    final int minVisibleHeight=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_HEIGHT_IN_DP,displayMetrics);
    final int minVisibleWidth=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_WIDTH_IN_DP,displayMetrics);
    final int top=Math.max(mContentFrame.top,Math.min(mFrame.top,mContentFrame.bottom - minVisibleHeight));
    final int left=Math.max(mContentFrame.left + minVisibleWidth - width,Math.min(mFrame.left,mContentFrame.right - minVisibleWidth));
    mFrame.set(left,top,left + width,top + height);
    mContentFrame.set(mFrame);
    mVisibleFrame.set(mContentFrame);
    mStableFrame.set(mContentFrame);
  }
 else   if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame);
    mContentFrame.set(mFrame);
    if (!mFrame.equals(mLastFrame)) {
      mMovedByResize=true;
    }
  }
 else {
    mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
    mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
    mStableFrame.set(Math.max(mStableFrame.left,mFrame.left),Math.max(mStableFrame.top,mFrame.top),Math.min(mStableFrame.right,mFrame.right),Math.min(mStableFrame.bottom,mFrame.bottom));
  }
  if (fullscreenTask && !windowsAreFloating) {
    mOverscanInsets.set(Math.max(mOverscanFrame.left - layoutContainingFrame.left,0),Math.max(mOverscanFrame.top - layoutContainingFrame.top,0),Math.max(layoutContainingFrame.right - mOverscanFrame.right,0),Math.max(layoutContainingFrame.bottom - mOverscanFrame.bottom,0));
  }
  if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mStableInsets.set(Math.max(mStableFrame.left - mDisplayFrame.left,0),Math.max(mStableFrame.top - mDisplayFrame.top,0),Math.max(mDisplayFrame.right - mStableFrame.right,0),Math.max(mDisplayFrame.bottom - mStableFrame.bottom,0));
    mContentInsets.setEmpty();
    mVisibleInsets.setEmpty();
  }
 else {
    getDisplayContent().getLogicalDisplayRect(mTmpRect);
    boolean overrideRightInset=!fullscreenTask && mFrame.right > mTmpRect.right;
    boolean overrideBottomInset=!fullscreenTask && mFrame.bottom > mTmpRect.bottom;
    mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mContentFrame.right : mFrame.right - mContentFrame.right,overrideBottomInset ? mTmpRect.bottom - mContentFrame.bottom : mFrame.bottom - mContentFrame.bottom);
    mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mVisibleFrame.right : mFrame.right - mVisibleFrame.right,overrideBottomInset ? mTmpRect.bottom - mVisibleFrame.bottom : mFrame.bottom - mVisibleFrame.bottom);
    mStableInsets.set(Math.max(mStableFrame.left - mFrame.left,0),Math.max(mStableFrame.top - mFrame.top,0),overrideRightInset ? Math.max(mTmpRect.right - mStableFrame.right,0) : Math.max(mFrame.right - mStableFrame.right,0),overrideBottomInset ? Math.max(mTmpRect.bottom - mStableFrame.bottom,0) : Math.max(mFrame.bottom - mStableFrame.bottom,0));
  }
  mFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.offset(-layoutXDiff,-layoutYDiff);
  mContentFrame.offset(-layoutXDiff,-layoutYDiff);
  mVisibleFrame.offset(-layoutXDiff,-layoutYDiff);
  mStableFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mStableInsets.scale(mInvGlobalScale);
    mOutsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayContent displayContent=getDisplayContent();
    if (displayContent != null) {
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      mService.mWallpaperControllerLocked.updateWallpaperOffset(this,displayInfo.logicalWidth,displayInfo.logicalHeight,false);
    }
  }
  if (DEBUG_LAYOUT || WindowManagerService.localLOGV)   Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString()+ ""String_Node_Str""+ mStableInsets.toShortString()+ ""String_Node_Str""+ mOutsets.toShortString());
}",0.9983798379837984
191661,"@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf,Rect dcf,Rect sf,Rect osf){
  if (mWillReplaceWindow && (mAnimatingExit || !mReplacingRemoveRequested)) {
    return;
  }
  mHaveFrame=true;
  final Task task=getTask();
  final boolean fullscreenTask=!isInMultiWindowMode();
  final boolean windowsAreFloating=task != null && task.isFloating();
  if (fullscreenTask) {
    mInsetFrame.setEmpty();
  }
 else {
    task.getTempInsetBounds(mInsetFrame);
  }
  final Rect layoutContainingFrame;
  final Rect layoutDisplayFrame;
  final int layoutXDiff;
  final int layoutYDiff;
  if (mInsetFrame.isEmpty() && (fullscreenTask || layoutInParentFrame())) {
    mContainingFrame.set(pf);
    mDisplayFrame.set(df);
    layoutDisplayFrame=df;
    layoutContainingFrame=pf;
    layoutXDiff=0;
    layoutYDiff=0;
  }
 else {
    task.getBounds(mContainingFrame);
    if (mAppToken != null && !mAppToken.mFrozenBounds.isEmpty()) {
      Rect frozen=mAppToken.mFrozenBounds.peek();
      mContainingFrame.right=mContainingFrame.left + frozen.width();
      mContainingFrame.bottom=mContainingFrame.top + frozen.height();
    }
    final WindowState imeWin=mService.mInputMethodWindow;
    if (imeWin != null && imeWin.isVisibleNow() && mService.mInputMethodTarget == this) {
      if (windowsAreFloating && mContainingFrame.bottom > cf.bottom) {
        mContainingFrame.top-=mContainingFrame.bottom - cf.bottom;
      }
 else       if (mContainingFrame.bottom > pf.bottom) {
        mContainingFrame.bottom=pf.bottom;
      }
    }
    if (windowsAreFloating) {
      if (mContainingFrame.isEmpty()) {
        mContainingFrame.set(cf);
      }
    }
    mDisplayFrame.set(mContainingFrame);
    layoutXDiff=!mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : 0;
    layoutYDiff=!mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : 0;
    layoutContainingFrame=!mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame;
    mTmpRect.set(0,0,mDisplayContent.getDisplayInfo().logicalWidth,mDisplayContent.getDisplayInfo().logicalHeight);
    subtractInsets(mDisplayFrame,layoutContainingFrame,df,mTmpRect);
    if (!layoutInParentFrame()) {
      subtractInsets(mContainingFrame,layoutContainingFrame,pf,mTmpRect);
      subtractInsets(mInsetFrame,layoutContainingFrame,pf,mTmpRect);
    }
    layoutDisplayFrame=df;
    layoutDisplayFrame.intersect(layoutContainingFrame);
  }
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  mDecorFrame.set(dcf);
  mStableFrame.set(sf);
  final boolean hasOutsets=osf != null;
  if (hasOutsets) {
    mOutsetFrame.set(osf);
  }
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  applyGravityAndUpdateFrame(layoutContainingFrame,layoutDisplayFrame);
  if (hasOutsets) {
    mOutsets.set(Math.max(mContentFrame.left - mOutsetFrame.left,0),Math.max(mContentFrame.top - mOutsetFrame.top,0),Math.max(mOutsetFrame.right - mContentFrame.right,0),Math.max(mOutsetFrame.bottom - mContentFrame.bottom,0));
  }
 else {
    mOutsets.set(0,0,0,0);
  }
  if (windowsAreFloating && !mFrame.isEmpty()) {
    final int height=Math.min(mFrame.height(),mContentFrame.height());
    final int width=Math.min(mContentFrame.width(),mFrame.width());
    final DisplayMetrics displayMetrics=getDisplayContent().getDisplayMetrics();
    final int minVisibleHeight=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_HEIGHT_IN_DP,displayMetrics);
    final int minVisibleWidth=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_WIDTH_IN_DP,displayMetrics);
    final int top=Math.max(mContentFrame.top,Math.min(mFrame.top,mContentFrame.bottom - minVisibleHeight));
    final int left=Math.max(mContentFrame.left + minVisibleWidth - width,Math.min(mFrame.left,mContentFrame.right - minVisibleWidth));
    mFrame.set(left,top,left + width,top + height);
    mContentFrame.set(mFrame);
    mVisibleFrame.set(mContentFrame);
    mStableFrame.set(mContentFrame);
  }
 else   if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame);
    mContentFrame.set(mFrame);
    if (!mFrame.equals(mLastFrame)) {
      mMovedByResize=true;
    }
  }
 else {
    mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
    mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
    mStableFrame.set(Math.max(mStableFrame.left,mFrame.left),Math.max(mStableFrame.top,mFrame.top),Math.min(mStableFrame.right,mFrame.right),Math.min(mStableFrame.bottom,mFrame.bottom));
  }
  if (fullscreenTask && !windowsAreFloating) {
    mOverscanInsets.set(Math.max(mOverscanFrame.left - layoutContainingFrame.left,0),Math.max(mOverscanFrame.top - layoutContainingFrame.top,0),Math.max(layoutContainingFrame.right - mOverscanFrame.right,0),Math.max(layoutContainingFrame.bottom - mOverscanFrame.bottom,0));
  }
  if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mStableInsets.set(Math.max(mStableFrame.left - mDisplayFrame.left,0),Math.max(mStableFrame.top - mDisplayFrame.top,0),Math.max(mDisplayFrame.right - mStableFrame.right,0),Math.max(mDisplayFrame.bottom - mStableFrame.bottom,0));
    mContentInsets.setEmpty();
    mVisibleInsets.setEmpty();
  }
 else {
    getDisplayContent().getLogicalDisplayRect(mTmpRect);
    boolean overrideRightInset=!fullscreenTask && mFrame.right > mTmpRect.right;
    boolean overrideBottomInset=!fullscreenTask && mFrame.bottom > mTmpRect.bottom;
    mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mContentFrame.right : mFrame.right - mContentFrame.right,overrideBottomInset ? mTmpRect.bottom - mContentFrame.bottom : mFrame.bottom - mContentFrame.bottom);
    mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mVisibleFrame.right : mFrame.right - mVisibleFrame.right,overrideBottomInset ? mTmpRect.bottom - mVisibleFrame.bottom : mFrame.bottom - mVisibleFrame.bottom);
    mStableInsets.set(Math.max(mStableFrame.left - mFrame.left,0),Math.max(mStableFrame.top - mFrame.top,0),overrideRightInset ? Math.max(mTmpRect.right - mStableFrame.right,0) : Math.max(mFrame.right - mStableFrame.right,0),overrideBottomInset ? Math.max(mTmpRect.bottom - mStableFrame.bottom,0) : Math.max(mFrame.bottom - mStableFrame.bottom,0));
  }
  mFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.offset(-layoutXDiff,-layoutYDiff);
  mContentFrame.offset(-layoutXDiff,-layoutYDiff);
  mVisibleFrame.offset(-layoutXDiff,-layoutYDiff);
  mStableFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mStableInsets.scale(mInvGlobalScale);
    mOutsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayContent displayContent=getDisplayContent();
    if (displayContent != null) {
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      mService.mWallpaperControllerLocked.updateWallpaperOffset(this,displayInfo.logicalWidth,displayInfo.logicalHeight,false);
    }
  }
  if (DEBUG_LAYOUT || WindowManagerService.localLOGV)   Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString()+ ""String_Node_Str""+ mStableInsets.toShortString()+ ""String_Node_Str""+ mOutsets.toShortString());
}","@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf,Rect dcf,Rect sf,Rect osf){
  if (mWillReplaceWindow && (mAnimatingExit || !mReplacingRemoveRequested)) {
    return;
  }
  mHaveFrame=true;
  final Task task=getTask();
  final boolean fullscreenTask=!isInMultiWindowMode();
  final boolean windowsAreFloating=task != null && task.isFloating();
  if (fullscreenTask) {
    mInsetFrame.setEmpty();
  }
 else {
    task.getTempInsetBounds(mInsetFrame);
  }
  final Rect layoutContainingFrame;
  final Rect layoutDisplayFrame;
  final int layoutXDiff;
  final int layoutYDiff;
  if (fullscreenTask || layoutInParentFrame()) {
    mContainingFrame.set(pf);
    mDisplayFrame.set(df);
    layoutDisplayFrame=df;
    layoutContainingFrame=pf;
    layoutXDiff=0;
    layoutYDiff=0;
  }
 else {
    task.getBounds(mContainingFrame);
    if (mAppToken != null && !mAppToken.mFrozenBounds.isEmpty()) {
      Rect frozen=mAppToken.mFrozenBounds.peek();
      mContainingFrame.right=mContainingFrame.left + frozen.width();
      mContainingFrame.bottom=mContainingFrame.top + frozen.height();
    }
    final WindowState imeWin=mService.mInputMethodWindow;
    if (imeWin != null && imeWin.isVisibleNow() && mService.mInputMethodTarget == this) {
      if (windowsAreFloating && mContainingFrame.bottom > cf.bottom) {
        mContainingFrame.top-=mContainingFrame.bottom - cf.bottom;
      }
 else       if (mContainingFrame.bottom > pf.bottom) {
        mContainingFrame.bottom=pf.bottom;
      }
    }
    if (windowsAreFloating) {
      if (mContainingFrame.isEmpty()) {
        mContainingFrame.set(cf);
      }
    }
    mDisplayFrame.set(mContainingFrame);
    layoutXDiff=!mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : 0;
    layoutYDiff=!mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : 0;
    layoutContainingFrame=!mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame;
    mTmpRect.set(0,0,mDisplayContent.getDisplayInfo().logicalWidth,mDisplayContent.getDisplayInfo().logicalHeight);
    subtractInsets(mDisplayFrame,layoutContainingFrame,df,mTmpRect);
    if (!layoutInParentFrame()) {
      subtractInsets(mContainingFrame,layoutContainingFrame,pf,mTmpRect);
      subtractInsets(mInsetFrame,layoutContainingFrame,pf,mTmpRect);
    }
    layoutDisplayFrame=df;
    layoutDisplayFrame.intersect(layoutContainingFrame);
  }
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  mDecorFrame.set(dcf);
  mStableFrame.set(sf);
  final boolean hasOutsets=osf != null;
  if (hasOutsets) {
    mOutsetFrame.set(osf);
  }
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  applyGravityAndUpdateFrame(layoutContainingFrame,layoutDisplayFrame);
  if (hasOutsets) {
    mOutsets.set(Math.max(mContentFrame.left - mOutsetFrame.left,0),Math.max(mContentFrame.top - mOutsetFrame.top,0),Math.max(mOutsetFrame.right - mContentFrame.right,0),Math.max(mOutsetFrame.bottom - mContentFrame.bottom,0));
  }
 else {
    mOutsets.set(0,0,0,0);
  }
  if (windowsAreFloating && !mFrame.isEmpty()) {
    final int height=Math.min(mFrame.height(),mContentFrame.height());
    final int width=Math.min(mContentFrame.width(),mFrame.width());
    final DisplayMetrics displayMetrics=getDisplayContent().getDisplayMetrics();
    final int minVisibleHeight=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_HEIGHT_IN_DP,displayMetrics);
    final int minVisibleWidth=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_WIDTH_IN_DP,displayMetrics);
    final int top=Math.max(mContentFrame.top,Math.min(mFrame.top,mContentFrame.bottom - minVisibleHeight));
    final int left=Math.max(mContentFrame.left + minVisibleWidth - width,Math.min(mFrame.left,mContentFrame.right - minVisibleWidth));
    mFrame.set(left,top,left + width,top + height);
    mContentFrame.set(mFrame);
    mVisibleFrame.set(mContentFrame);
    mStableFrame.set(mContentFrame);
  }
 else   if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame);
    mContentFrame.set(mFrame);
    if (!mFrame.equals(mLastFrame)) {
      mMovedByResize=true;
    }
  }
 else {
    mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
    mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
    mStableFrame.set(Math.max(mStableFrame.left,mFrame.left),Math.max(mStableFrame.top,mFrame.top),Math.min(mStableFrame.right,mFrame.right),Math.min(mStableFrame.bottom,mFrame.bottom));
  }
  if (fullscreenTask && !windowsAreFloating) {
    mOverscanInsets.set(Math.max(mOverscanFrame.left - layoutContainingFrame.left,0),Math.max(mOverscanFrame.top - layoutContainingFrame.top,0),Math.max(layoutContainingFrame.right - mOverscanFrame.right,0),Math.max(layoutContainingFrame.bottom - mOverscanFrame.bottom,0));
  }
  if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mStableInsets.set(Math.max(mStableFrame.left - mDisplayFrame.left,0),Math.max(mStableFrame.top - mDisplayFrame.top,0),Math.max(mDisplayFrame.right - mStableFrame.right,0),Math.max(mDisplayFrame.bottom - mStableFrame.bottom,0));
    mContentInsets.setEmpty();
    mVisibleInsets.setEmpty();
  }
 else {
    getDisplayContent().getLogicalDisplayRect(mTmpRect);
    boolean overrideRightInset=!fullscreenTask && mFrame.right > mTmpRect.right;
    boolean overrideBottomInset=!fullscreenTask && mFrame.bottom > mTmpRect.bottom;
    mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mContentFrame.right : mFrame.right - mContentFrame.right,overrideBottomInset ? mTmpRect.bottom - mContentFrame.bottom : mFrame.bottom - mContentFrame.bottom);
    mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mVisibleFrame.right : mFrame.right - mVisibleFrame.right,overrideBottomInset ? mTmpRect.bottom - mVisibleFrame.bottom : mFrame.bottom - mVisibleFrame.bottom);
    mStableInsets.set(Math.max(mStableFrame.left - mFrame.left,0),Math.max(mStableFrame.top - mFrame.top,0),overrideRightInset ? Math.max(mTmpRect.right - mStableFrame.right,0) : Math.max(mFrame.right - mStableFrame.right,0),overrideBottomInset ? Math.max(mTmpRect.bottom - mStableFrame.bottom,0) : Math.max(mFrame.bottom - mStableFrame.bottom,0));
  }
  mFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.offset(-layoutXDiff,-layoutYDiff);
  mContentFrame.offset(-layoutXDiff,-layoutYDiff);
  mVisibleFrame.offset(-layoutXDiff,-layoutYDiff);
  mStableFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mStableInsets.scale(mInvGlobalScale);
    mOutsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayContent displayContent=getDisplayContent();
    if (displayContent != null) {
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      mService.mWallpaperControllerLocked.updateWallpaperOffset(this,displayInfo.logicalWidth,displayInfo.logicalHeight,false);
    }
  }
  if (DEBUG_LAYOUT || WindowManagerService.localLOGV)   Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString()+ ""String_Node_Str""+ mStableInsets.toShortString()+ ""String_Node_Str""+ mOutsets.toShortString());
}",0.9983798379837984
191662,"private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(getTransientView(0));
  }
}","private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(viewGroup.getTransientView(0));
  }
}",0.9740932642487048
191663,"private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(getTransientView(0));
  }
}","private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(viewGroup.getTransientView(0));
  }
}",0.9740932642487048
191664,"private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(getTransientView(0));
  }
}","private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(viewGroup.getTransientView(0));
  }
}",0.9740932642487048
191665,"private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(getTransientView(0));
  }
}","private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(viewGroup.getTransientView(0));
  }
}",0.9740932642487048
191666,"private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(getTransientView(0));
  }
}","private void clearTransientViews(ViewGroup viewGroup){
  while (viewGroup != null && viewGroup.getTransientViewCount() != 0) {
    viewGroup.removeTransientView(viewGroup.getTransientView(0));
  }
}",0.9740932642487048
191667,"public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
}","public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
  mIsolatedEntries.remove(removed.key);
}",0.8540145985401459
191668,"public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}","public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (mGroupManager != null) {
    mGroupManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}",0.9866061293984107
191669,"public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
}","public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
  mIsolatedEntries.remove(removed.key);
}",0.8540145985401459
191670,"public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}","public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (mGroupManager != null) {
    mGroupManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}",0.9866061293984107
191671,"private void updateHideSensitiveForChild(View child){
  if (mAmbientState.isHideSensitive() && child instanceof ExpandableView) {
    ExpandableView expandableView=(ExpandableView)child;
    expandableView.setHideSensitiveForIntrinsicHeight(true);
  }
}","private void updateHideSensitiveForChild(View child){
  if (child instanceof ExpandableView) {
    ExpandableView expandableView=(ExpandableView)child;
    expandableView.setHideSensitiveForIntrinsicHeight(mAmbientState.isHideSensitive());
  }
}",0.393574297188755
191672,"private void updateHideSensitiveForChild(View child){
  if (mAmbientState.isHideSensitive() && child instanceof ExpandableView) {
    ExpandableView expandableView=(ExpandableView)child;
    expandableView.setHideSensitiveForIntrinsicHeight(true);
  }
}","private void updateHideSensitiveForChild(View child){
  if (child instanceof ExpandableView) {
    ExpandableView expandableView=(ExpandableView)child;
    expandableView.setHideSensitiveForIntrinsicHeight(mAmbientState.isHideSensitive());
  }
}",0.393574297188755
191673,"public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
}","public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
  mIsolatedEntries.remove(removed.key);
}",0.8540145985401459
191674,"public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}","public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (mGroupManager != null) {
    mGroupManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}",0.9866061293984107
191675,"public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    String oldKey=oldNotification.getGroupKey();
    String newKey=entry.notification.getGroupKey();
    if (!oldKey.equals(newKey)) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
}","public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    String oldKey=oldNotification.getGroupKey();
    String newKey=entry.notification.getGroupKey();
    if (!oldKey.equals(newKey)) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!isGroupChild(oldNotification) && isGroupChild(entry.notification)) {
    onEntryBecomingChild(entry);
  }
}",0.9059288537549408
191676,"public void onEntryAdded(final NotificationData.Entry added){
  final StatusBarNotification sbn=added.notification;
  boolean isGroupChild=isGroupChild(sbn);
  String groupKey=getGroupKey(sbn);
  NotificationGroup group=mGroupMap.get(groupKey);
  if (group == null) {
    group=new NotificationGroup();
    mGroupMap.put(groupKey,group);
  }
  if (isGroupChild) {
    group.children.add(added);
    updateSuppression(group);
  }
 else {
    group.summary=added;
    group.expanded=added.row.areChildrenExpanded();
    updateSuppression(group);
    if (!group.children.isEmpty()) {
      mListener.onGroupCreatedFromChildren(group);
    }
  }
}","public void onEntryAdded(final NotificationData.Entry added){
  final StatusBarNotification sbn=added.notification;
  boolean isGroupChild=isGroupChild(sbn);
  String groupKey=getGroupKey(sbn);
  NotificationGroup group=mGroupMap.get(groupKey);
  if (group == null) {
    group=new NotificationGroup();
    mGroupMap.put(groupKey,group);
  }
  if (isGroupChild) {
    group.children.add(added);
    updateSuppression(group);
  }
 else {
    group.summary=added;
    group.expanded=added.row.areChildrenExpanded();
    updateSuppression(group);
    if (!group.children.isEmpty()) {
      HashSet<NotificationData.Entry> childrenCopy=(HashSet<NotificationData.Entry>)group.children.clone();
      for (      NotificationData.Entry child : childrenCopy) {
        onEntryBecomingChild(child);
      }
      mListener.onGroupCreatedFromChildren(group);
    }
  }
}",0.8556220891550232
191677,"public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    String oldKey=oldNotification.getGroupKey();
    String newKey=entry.notification.getGroupKey();
    if (!oldKey.equals(newKey)) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
}","public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    String oldKey=oldNotification.getGroupKey();
    String newKey=entry.notification.getGroupKey();
    if (!oldKey.equals(newKey)) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!isGroupChild(oldNotification) && isGroupChild(entry.notification)) {
    onEntryBecomingChild(entry);
  }
}",0.9059288537549408
191678,"public void onEntryAdded(final NotificationData.Entry added){
  final StatusBarNotification sbn=added.notification;
  boolean isGroupChild=isGroupChild(sbn);
  String groupKey=getGroupKey(sbn);
  NotificationGroup group=mGroupMap.get(groupKey);
  if (group == null) {
    group=new NotificationGroup();
    mGroupMap.put(groupKey,group);
  }
  if (isGroupChild) {
    group.children.add(added);
    updateSuppression(group);
  }
 else {
    group.summary=added;
    group.expanded=added.row.areChildrenExpanded();
    updateSuppression(group);
    if (!group.children.isEmpty()) {
      mListener.onGroupCreatedFromChildren(group);
    }
  }
}","public void onEntryAdded(final NotificationData.Entry added){
  final StatusBarNotification sbn=added.notification;
  boolean isGroupChild=isGroupChild(sbn);
  String groupKey=getGroupKey(sbn);
  NotificationGroup group=mGroupMap.get(groupKey);
  if (group == null) {
    group=new NotificationGroup();
    mGroupMap.put(groupKey,group);
  }
  if (isGroupChild) {
    group.children.add(added);
    updateSuppression(group);
  }
 else {
    group.summary=added;
    group.expanded=added.row.areChildrenExpanded();
    updateSuppression(group);
    if (!group.children.isEmpty()) {
      HashSet<NotificationData.Entry> childrenCopy=(HashSet<NotificationData.Entry>)group.children.clone();
      for (      NotificationData.Entry child : childrenCopy) {
        onEntryBecomingChild(child);
      }
      mListener.onGroupCreatedFromChildren(group);
    }
  }
}",0.8556220891550232
191679,"public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
}","public void onEntryRemoved(NotificationData.Entry removed){
  onEntryRemovedInternal(removed,removed.notification);
  mIsolatedEntries.remove(removed.key);
}",0.8540145985401459
191680,"public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}","public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
synchronized (mQueueLock) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + mExpandedVisible + ""String_Node_Str""+ mTrackingPosition);
    pw.println(""String_Node_Str"" + mTracking);
    pw.println(""String_Node_Str"" + mDisplayMetrics);
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller));
    pw.println(""String_Node_Str"" + viewInfo(mStackScroller) + ""String_Node_Str""+ mStackScroller.getScrollX()+ ""String_Node_Str""+ mStackScroller.getScrollY());
  }
  pw.print(""String_Node_Str"");
  pw.println(mInteractingWindows);
  pw.print(""String_Node_Str"");
  pw.println(windowStateToString(mStatusBarWindowState));
  pw.print(""String_Node_Str"");
  pw.println(BarTransitions.modeToString(mStatusBarMode));
  pw.print(""String_Node_Str"");
  pw.println(mDozing);
  pw.print(""String_Node_Str"");
  pw.println(Settings.Global.zenModeToString(mZenMode));
  pw.print(""String_Node_Str"");
  pw.println(mUseHeadsUp);
  dumpBarTransitions(pw,""String_Node_Str"",mStatusBarView.getBarTransitions());
  if (mNavigationBarView != null) {
    pw.print(""String_Node_Str"");
    pw.println(windowStateToString(mNavigationBarWindowState));
    pw.print(""String_Node_Str"");
    pw.println(BarTransitions.modeToString(mNavigationBarMode));
    dumpBarTransitions(pw,""String_Node_Str"",mNavigationBarView.getBarTransitions());
  }
  pw.print(""String_Node_Str"");
  if (mNavigationBarView == null) {
    pw.println(""String_Node_Str"");
  }
 else {
    mNavigationBarView.dump(fd,pw,args);
  }
  pw.print(""String_Node_Str"");
  pw.println(mMediaSessionManager);
  pw.print(""String_Node_Str"");
  pw.println(mMediaNotificationKey);
  pw.print(""String_Node_Str"");
  pw.print(mMediaController);
  if (mMediaController != null) {
    pw.print(""String_Node_Str"" + mMediaController.getPlaybackState());
  }
  pw.println();
  pw.print(""String_Node_Str"");
  pw.print(mMediaMetadata);
  if (mMediaMetadata != null) {
    pw.print(""String_Node_Str"" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
  }
  pw.println();
  pw.println(""String_Node_Str"");
  if (mNotificationPanel != null) {
    pw.println(""String_Node_Str"" + mNotificationPanel + ""String_Node_Str""+ mNotificationPanel.getLayoutParams().debug(""String_Node_Str""));
    pw.print(""String_Node_Str"");
    mNotificationPanel.dump(fd,pw,args);
  }
  DozeLog.dump(pw);
  if (DUMPTRUCK) {
synchronized (mNotificationData) {
      mNotificationData.dump(pw,""String_Node_Str"");
    }
    mIconController.dump(pw);
    if (false) {
      pw.println(""String_Node_Str"");
      mHandler.post(new Runnable(){
        public void run(){
          mStatusBarView.getLocationOnScreen(mAbsPos);
          Log.d(TAG,""String_Node_Str"" + mAbsPos[0] + ""String_Node_Str""+ mAbsPos[1]+ ""String_Node_Str""+ mStatusBarView.getWidth()+ ""String_Node_Str""+ getStatusBarHeight());
          mStatusBarView.debug();
        }
      }
);
    }
  }
  if (DEBUG_GESTURES) {
    pw.print(""String_Node_Str"");
    mGestureRec.dump(fd,pw,args);
  }
  if (mStatusBarWindowManager != null) {
    mStatusBarWindowManager.dump(fd,pw,args);
  }
  if (mNetworkController != null) {
    mNetworkController.dump(fd,pw,args);
  }
  if (mBluetoothController != null) {
    mBluetoothController.dump(fd,pw,args);
  }
  if (mHotspotController != null) {
    mHotspotController.dump(fd,pw,args);
  }
  if (mCastController != null) {
    mCastController.dump(fd,pw,args);
  }
  if (mUserSwitcherController != null) {
    mUserSwitcherController.dump(fd,pw,args);
  }
  if (mBatteryController != null) {
    mBatteryController.dump(fd,pw,args);
  }
  if (mNextAlarmController != null) {
    mNextAlarmController.dump(fd,pw,args);
  }
  if (mSecurityController != null) {
    mSecurityController.dump(fd,pw,args);
  }
  if (mHeadsUpManager != null) {
    mHeadsUpManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (mGroupManager != null) {
    mGroupManager.dump(fd,pw,args);
  }
 else {
    pw.println(""String_Node_Str"");
  }
  if (KeyguardUpdateMonitor.getInstance(mContext) != null) {
    KeyguardUpdateMonitor.getInstance(mContext).dump(fd,pw,args);
  }
  FalsingManager.getInstance(mContext).dump(pw);
  FalsingLog.dump(pw);
  pw.println(""String_Node_Str"");
  for (  Map.Entry<String,?> entry : Prefs.getAll(mContext).entrySet()) {
    pw.print(""String_Node_Str"");
    pw.print(entry.getKey());
    pw.print(""String_Node_Str"");
    pw.println(entry.getValue());
  }
}",0.9866061293984107
191681,"@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf,Rect dcf,Rect sf,Rect osf){
  if (mWillReplaceWindow && (mAnimatingExit || !mReplacingRemoveRequested)) {
    return;
  }
  mHaveFrame=true;
  final Task task=getTask();
  final boolean fullscreenTask=!isInMultiWindowMode();
  final boolean windowsAreFloating=task != null && task.isFloating();
  if (fullscreenTask) {
    mInsetFrame.setEmpty();
  }
 else {
    task.getTempInsetBounds(mInsetFrame);
  }
  final Rect layoutContainingFrame;
  final Rect layoutDisplayFrame;
  final int layoutXDiff;
  final int layoutYDiff;
  if (mInsetFrame.isEmpty() && (fullscreenTask || layoutInParentFrame())) {
    mContainingFrame.set(pf);
    mDisplayFrame.set(df);
    layoutDisplayFrame=df;
    layoutContainingFrame=pf;
    layoutXDiff=0;
    layoutYDiff=0;
  }
 else {
    task.getBounds(mContainingFrame);
    if (mAppToken != null && !mAppToken.mFrozenBounds.isEmpty()) {
      Rect frozen=mAppToken.mFrozenBounds.peek();
      mContainingFrame.right=mContainingFrame.left + frozen.width();
      mContainingFrame.bottom=mContainingFrame.top + frozen.height();
    }
    final WindowState imeWin=mService.mInputMethodWindow;
    if (imeWin != null && imeWin.isVisibleNow() && mService.mInputMethodTarget == this) {
      if (windowsAreFloating && mContainingFrame.bottom > cf.bottom) {
        mContainingFrame.top-=mContainingFrame.bottom - cf.bottom;
      }
 else       if (mContainingFrame.bottom > pf.bottom) {
        mContainingFrame.bottom=pf.bottom;
      }
    }
    if (windowsAreFloating) {
      if (mContainingFrame.isEmpty()) {
        mContainingFrame.set(cf);
      }
    }
    mDisplayFrame.set(mContainingFrame);
    layoutXDiff=!mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : 0;
    layoutYDiff=!mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : 0;
    layoutContainingFrame=!mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame;
    mTmpRect.set(0,0,mDisplayContent.getDisplayInfo().logicalWidth,mDisplayContent.getDisplayInfo().logicalHeight);
    subtractInsets(mDisplayFrame,layoutContainingFrame,df,mTmpRect);
    if (!layoutInParentFrame()) {
      subtractInsets(mContainingFrame,layoutContainingFrame,pf,mTmpRect);
      subtractInsets(mInsetFrame,layoutContainingFrame,pf,mTmpRect);
    }
    layoutDisplayFrame=df;
    layoutDisplayFrame.intersect(layoutContainingFrame);
  }
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  mDecorFrame.set(dcf);
  mStableFrame.set(sf);
  final boolean hasOutsets=osf != null;
  if (hasOutsets) {
    mOutsetFrame.set(osf);
  }
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  applyGravityAndUpdateFrame(layoutContainingFrame,layoutDisplayFrame);
  if (hasOutsets) {
    mOutsets.set(Math.max(mContentFrame.left - mOutsetFrame.left,0),Math.max(mContentFrame.top - mOutsetFrame.top,0),Math.max(mOutsetFrame.right - mContentFrame.right,0),Math.max(mOutsetFrame.bottom - mContentFrame.bottom,0));
  }
 else {
    mOutsets.set(0,0,0,0);
  }
  if (windowsAreFloating && !mFrame.isEmpty()) {
    final int height=Math.min(mFrame.height(),mContentFrame.height());
    final int width=Math.min(mContentFrame.width(),mFrame.width());
    final DisplayMetrics displayMetrics=getDisplayContent().getDisplayMetrics();
    final int minVisibleHeight=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_HEIGHT_IN_DP,displayMetrics);
    final int minVisibleWidth=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_WIDTH_IN_DP,displayMetrics);
    final int top=Math.max(mContentFrame.top,Math.min(mFrame.top,mContentFrame.bottom - minVisibleHeight));
    final int left=Math.max(mContentFrame.left + minVisibleWidth - width,Math.min(mFrame.left,mContentFrame.right - minVisibleWidth));
    mFrame.set(left,top,left + width,top + height);
    mContentFrame.set(mFrame);
    mVisibleFrame.set(mContentFrame);
    mStableFrame.set(mContentFrame);
  }
 else   if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame);
    mContentFrame.set(mFrame);
    if (!mFrame.equals(mLastFrame)) {
      mMovedByResize=true;
    }
  }
 else {
    mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
    mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
    mStableFrame.set(Math.max(mStableFrame.left,mFrame.left),Math.max(mStableFrame.top,mFrame.top),Math.min(mStableFrame.right,mFrame.right),Math.min(mStableFrame.bottom,mFrame.bottom));
  }
  if (fullscreenTask && !windowsAreFloating) {
    mOverscanInsets.set(Math.max(mOverscanFrame.left - layoutContainingFrame.left,0),Math.max(mOverscanFrame.top - layoutContainingFrame.top,0),Math.max(layoutContainingFrame.right - mOverscanFrame.right,0),Math.max(layoutContainingFrame.bottom - mOverscanFrame.bottom,0));
  }
  if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mStableInsets.set(Math.max(mStableFrame.left - mDisplayFrame.left,0),Math.max(mStableFrame.top - mDisplayFrame.top,0),Math.max(mDisplayFrame.right - mStableFrame.right,0),Math.max(mDisplayFrame.bottom - mStableFrame.bottom,0));
    mContentInsets.setEmpty();
    mVisibleInsets.setEmpty();
  }
 else {
    getDisplayContent().getLogicalDisplayRect(mTmpRect);
    boolean overrideRightInset=!fullscreenTask && mFrame.right > mTmpRect.right;
    boolean overrideBottomInset=!fullscreenTask && mFrame.bottom > mTmpRect.bottom;
    mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mContentFrame.right : mFrame.right - mContentFrame.right,overrideBottomInset ? mTmpRect.bottom - mContentFrame.bottom : mFrame.bottom - mContentFrame.bottom);
    mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mVisibleFrame.right : mFrame.right - mVisibleFrame.right,overrideBottomInset ? mTmpRect.bottom - mVisibleFrame.bottom : mFrame.bottom - mVisibleFrame.bottom);
    mStableInsets.set(Math.max(mStableFrame.left - mFrame.left,0),Math.max(mStableFrame.top - mFrame.top,0),overrideRightInset ? Math.max(mTmpRect.right - mStableFrame.right,0) : Math.max(mFrame.right - mStableFrame.right,0),overrideBottomInset ? Math.max(mTmpRect.bottom - mStableFrame.bottom,0) : Math.max(mFrame.bottom - mStableFrame.bottom,0));
  }
  mFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.offset(-layoutXDiff,-layoutYDiff);
  mContentFrame.offset(-layoutXDiff,-layoutYDiff);
  mVisibleFrame.offset(-layoutXDiff,-layoutYDiff);
  mStableFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mStableInsets.scale(mInvGlobalScale);
    mOutsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayContent displayContent=getDisplayContent();
    if (displayContent != null) {
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      mService.mWallpaperControllerLocked.updateWallpaperOffset(this,displayInfo.logicalWidth,displayInfo.logicalHeight,false);
    }
  }
  if (DEBUG_LAYOUT || WindowManagerService.localLOGV)   Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString()+ ""String_Node_Str""+ mStableInsets.toShortString()+ ""String_Node_Str""+ mOutsets.toShortString());
}","@Override public void computeFrameLw(Rect pf,Rect df,Rect of,Rect cf,Rect vf,Rect dcf,Rect sf,Rect osf){
  if (mWillReplaceWindow && (mAnimatingExit || !mReplacingRemoveRequested)) {
    return;
  }
  mHaveFrame=true;
  final Task task=getTask();
  final boolean fullscreenTask=!isInMultiWindowMode();
  final boolean windowsAreFloating=task != null && task.isFloating();
  if (fullscreenTask) {
    mInsetFrame.setEmpty();
  }
 else {
    task.getTempInsetBounds(mInsetFrame);
  }
  final Rect layoutContainingFrame;
  final Rect layoutDisplayFrame;
  final int layoutXDiff;
  final int layoutYDiff;
  if (fullscreenTask || layoutInParentFrame()) {
    mContainingFrame.set(pf);
    mDisplayFrame.set(df);
    layoutDisplayFrame=df;
    layoutContainingFrame=pf;
    layoutXDiff=0;
    layoutYDiff=0;
  }
 else {
    task.getBounds(mContainingFrame);
    if (mAppToken != null && !mAppToken.mFrozenBounds.isEmpty()) {
      Rect frozen=mAppToken.mFrozenBounds.peek();
      mContainingFrame.right=mContainingFrame.left + frozen.width();
      mContainingFrame.bottom=mContainingFrame.top + frozen.height();
    }
    final WindowState imeWin=mService.mInputMethodWindow;
    if (imeWin != null && imeWin.isVisibleNow() && mService.mInputMethodTarget == this) {
      if (windowsAreFloating && mContainingFrame.bottom > cf.bottom) {
        mContainingFrame.top-=mContainingFrame.bottom - cf.bottom;
      }
 else       if (mContainingFrame.bottom > pf.bottom) {
        mContainingFrame.bottom=pf.bottom;
      }
    }
    if (windowsAreFloating) {
      if (mContainingFrame.isEmpty()) {
        mContainingFrame.set(cf);
      }
    }
    mDisplayFrame.set(mContainingFrame);
    layoutXDiff=!mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : 0;
    layoutYDiff=!mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : 0;
    layoutContainingFrame=!mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame;
    mTmpRect.set(0,0,mDisplayContent.getDisplayInfo().logicalWidth,mDisplayContent.getDisplayInfo().logicalHeight);
    subtractInsets(mDisplayFrame,layoutContainingFrame,df,mTmpRect);
    if (!layoutInParentFrame()) {
      subtractInsets(mContainingFrame,layoutContainingFrame,pf,mTmpRect);
      subtractInsets(mInsetFrame,layoutContainingFrame,pf,mTmpRect);
    }
    layoutDisplayFrame=df;
    layoutDisplayFrame.intersect(layoutContainingFrame);
  }
  final int pw=mContainingFrame.width();
  final int ph=mContainingFrame.height();
  if (!mParentFrame.equals(pf)) {
    mParentFrame.set(pf);
    mContentChanged=true;
  }
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    mLastRequestedWidth=mRequestedWidth;
    mLastRequestedHeight=mRequestedHeight;
    mContentChanged=true;
  }
  mOverscanFrame.set(of);
  mContentFrame.set(cf);
  mVisibleFrame.set(vf);
  mDecorFrame.set(dcf);
  mStableFrame.set(sf);
  final boolean hasOutsets=osf != null;
  if (hasOutsets) {
    mOutsetFrame.set(osf);
  }
  final int fw=mFrame.width();
  final int fh=mFrame.height();
  applyGravityAndUpdateFrame(layoutContainingFrame,layoutDisplayFrame);
  if (hasOutsets) {
    mOutsets.set(Math.max(mContentFrame.left - mOutsetFrame.left,0),Math.max(mContentFrame.top - mOutsetFrame.top,0),Math.max(mOutsetFrame.right - mContentFrame.right,0),Math.max(mOutsetFrame.bottom - mContentFrame.bottom,0));
  }
 else {
    mOutsets.set(0,0,0,0);
  }
  if (windowsAreFloating && !mFrame.isEmpty()) {
    final int height=Math.min(mFrame.height(),mContentFrame.height());
    final int width=Math.min(mContentFrame.width(),mFrame.width());
    final DisplayMetrics displayMetrics=getDisplayContent().getDisplayMetrics();
    final int minVisibleHeight=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_HEIGHT_IN_DP,displayMetrics);
    final int minVisibleWidth=WindowManagerService.dipToPixel(MINIMUM_VISIBLE_WIDTH_IN_DP,displayMetrics);
    final int top=Math.max(mContentFrame.top,Math.min(mFrame.top,mContentFrame.bottom - minVisibleHeight));
    final int left=Math.max(mContentFrame.left + minVisibleWidth - width,Math.min(mFrame.left,mContentFrame.right - minVisibleWidth));
    mFrame.set(left,top,left + width,top + height);
    mContentFrame.set(mFrame);
    mVisibleFrame.set(mContentFrame);
    mStableFrame.set(mContentFrame);
  }
 else   if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame);
    mContentFrame.set(mFrame);
    if (!mFrame.equals(mLastFrame)) {
      mMovedByResize=true;
    }
  }
 else {
    mContentFrame.set(Math.max(mContentFrame.left,mFrame.left),Math.max(mContentFrame.top,mFrame.top),Math.min(mContentFrame.right,mFrame.right),Math.min(mContentFrame.bottom,mFrame.bottom));
    mVisibleFrame.set(Math.max(mVisibleFrame.left,mFrame.left),Math.max(mVisibleFrame.top,mFrame.top),Math.min(mVisibleFrame.right,mFrame.right),Math.min(mVisibleFrame.bottom,mFrame.bottom));
    mStableFrame.set(Math.max(mStableFrame.left,mFrame.left),Math.max(mStableFrame.top,mFrame.top),Math.min(mStableFrame.right,mFrame.right),Math.min(mStableFrame.bottom,mFrame.bottom));
  }
  if (fullscreenTask && !windowsAreFloating) {
    mOverscanInsets.set(Math.max(mOverscanFrame.left - layoutContainingFrame.left,0),Math.max(mOverscanFrame.top - layoutContainingFrame.top,0),Math.max(layoutContainingFrame.right - mOverscanFrame.right,0),Math.max(layoutContainingFrame.bottom - mOverscanFrame.bottom,0));
  }
  if (mAttrs.type == TYPE_DOCK_DIVIDER) {
    mStableInsets.set(Math.max(mStableFrame.left - mDisplayFrame.left,0),Math.max(mStableFrame.top - mDisplayFrame.top,0),Math.max(mDisplayFrame.right - mStableFrame.right,0),Math.max(mDisplayFrame.bottom - mStableFrame.bottom,0));
    mContentInsets.setEmpty();
    mVisibleInsets.setEmpty();
  }
 else {
    getDisplayContent().getLogicalDisplayRect(mTmpRect);
    boolean overrideRightInset=!fullscreenTask && mFrame.right > mTmpRect.right;
    boolean overrideBottomInset=!fullscreenTask && mFrame.bottom > mTmpRect.bottom;
    mContentInsets.set(mContentFrame.left - mFrame.left,mContentFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mContentFrame.right : mFrame.right - mContentFrame.right,overrideBottomInset ? mTmpRect.bottom - mContentFrame.bottom : mFrame.bottom - mContentFrame.bottom);
    mVisibleInsets.set(mVisibleFrame.left - mFrame.left,mVisibleFrame.top - mFrame.top,overrideRightInset ? mTmpRect.right - mVisibleFrame.right : mFrame.right - mVisibleFrame.right,overrideBottomInset ? mTmpRect.bottom - mVisibleFrame.bottom : mFrame.bottom - mVisibleFrame.bottom);
    mStableInsets.set(Math.max(mStableFrame.left - mFrame.left,0),Math.max(mStableFrame.top - mFrame.top,0),overrideRightInset ? Math.max(mTmpRect.right - mStableFrame.right,0) : Math.max(mFrame.right - mStableFrame.right,0),overrideBottomInset ? Math.max(mTmpRect.bottom - mStableFrame.bottom,0) : Math.max(mFrame.bottom - mStableFrame.bottom,0));
  }
  mFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.offset(-layoutXDiff,-layoutYDiff);
  mContentFrame.offset(-layoutXDiff,-layoutYDiff);
  mVisibleFrame.offset(-layoutXDiff,-layoutYDiff);
  mStableFrame.offset(-layoutXDiff,-layoutYDiff);
  mCompatFrame.set(mFrame);
  if (mEnforceSizeCompat) {
    mOverscanInsets.scale(mInvGlobalScale);
    mContentInsets.scale(mInvGlobalScale);
    mVisibleInsets.scale(mInvGlobalScale);
    mStableInsets.scale(mInvGlobalScale);
    mOutsets.scale(mInvGlobalScale);
    mCompatFrame.scale(mInvGlobalScale);
  }
  if (mIsWallpaper && (fw != mFrame.width() || fh != mFrame.height())) {
    final DisplayContent displayContent=getDisplayContent();
    if (displayContent != null) {
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      mService.mWallpaperControllerLocked.updateWallpaperOffset(this,displayInfo.logicalWidth,displayInfo.logicalHeight,false);
    }
  }
  if (DEBUG_LAYOUT || WindowManagerService.localLOGV)   Slog.v(TAG,""String_Node_Str"" + mRequestedWidth + ""String_Node_Str""+ mRequestedHeight+ ""String_Node_Str""+ ""String_Node_Str""+ pw+ ""String_Node_Str""+ ph+ ""String_Node_Str""+ mFrame.toShortString()+ ""String_Node_Str""+ mContentInsets.toShortString()+ ""String_Node_Str""+ mVisibleInsets.toShortString()+ ""String_Node_Str""+ mStableInsets.toShortString()+ ""String_Node_Str""+ mOutsets.toShortString());
}",0.9983798379837984
191682,"/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  try {
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,""String_Node_Str"");
    final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
    classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ key);
    }
synchronized (this) {
      final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
      if (overrideConfig != null) {
        activityResources.overrideConfig.setTo(overrideConfig);
      }
 else {
        activityResources.overrideConfig.setToDefaults();
      }
    }
    updateResourcesForActivity(activityToken,overrideConfig);
    return getOrCreateResources(activityToken,key,classLoader);
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
  }
}","/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  try {
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,""String_Node_Str"");
    final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
    classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ key);
    }
synchronized (this) {
      getOrCreateActivityResourcesStructLocked(activityToken);
    }
    updateResourcesForActivity(activityToken,overrideConfig);
    return getOrCreateResources(activityToken,key,classLoader);
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
  }
}",0.9521571977787272
191683,"public boolean dumpHistory(PrintWriter pw,String prefix,int filterUid){
  if (mEventCmds[0] == EVENT_NULL) {
    return false;
  }
  pw.println(""String_Node_Str"");
  long now=SystemClock.elapsedRealtime();
  for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
    int uid=mEventUids[i];
    if (filterUid != -1 && filterUid != UserHandle.getAppId(filterUid)) {
      continue;
    }
    int cmd=mEventCmds[i];
    if (cmd == EVENT_NULL) {
      continue;
    }
    String label;
switch (mEventCmds[i]) {
case EVENT_START_JOB:
      label=""String_Node_Str"";
    break;
case EVENT_STOP_JOB:
  label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(prefix);
TimeUtils.formatDuration(mEventTimes[i] - now,pw,TimeUtils.HUNDRED_DAY_FIELD_LEN);
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
UserHandle.formatUid(pw,uid);
pw.print(""String_Node_Str"");
pw.println(mEventTags[i]);
}
return true;
}","public boolean dumpHistory(PrintWriter pw,String prefix,int filterUid){
  final int size=mEventIndices.size();
  if (size <= 0) {
    return false;
  }
  pw.println(""String_Node_Str"");
  final long now=SystemClock.elapsedRealtime();
  for (int i=0; i < size; i++) {
    final int index=mEventIndices.indexOf(i);
    final int uid=mEventUids[index];
    if (filterUid != -1 && filterUid != UserHandle.getAppId(filterUid)) {
      continue;
    }
    final int cmd=mEventCmds[index];
    if (cmd == EVENT_NULL) {
      continue;
    }
    final String label;
switch (mEventCmds[index]) {
case EVENT_START_JOB:
      label=""String_Node_Str"";
    break;
case EVENT_STOP_JOB:
  label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(prefix);
TimeUtils.formatDuration(mEventTimes[index] - now,pw,TimeUtils.HUNDRED_DAY_FIELD_LEN);
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
UserHandle.formatUid(pw,uid);
pw.print(""String_Node_Str"");
pw.println(mEventTags[index]);
}
return true;
}",0.6019221041982802
191684,"public long getActiveTopTime(long now){
  long time=pastActiveTopTime;
  if (activeTopCount > 0) {
    time+=now - activeTopStartTime;
  }
  return time;
}","public long getActiveTopTime(long now){
  long time=pastActiveTopTime;
  if (activeTopNesting > 0) {
    time+=now - activeTopStartTime;
  }
  return time;
}",0.967948717948718
191685,"void decActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeCount == 1) {
    pe.pastActiveTime+=now - pe.activeStartTime;
  }
  pe.activeCount--;
}","void decActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeNesting == 1) {
    pe.pastActiveTime+=now - pe.activeStartTime;
  }
  pe.activeNesting--;
}",0.9487179487179488
191686,"void printDuration(PrintWriter pw,long period,long duration,String suffix){
  float fraction=duration / (float)period;
  int percent=(int)((fraction * 100) + .5f);
  if (percent > 0) {
    pw.print(""String_Node_Str"");
    pw.print(percent);
    pw.print(""String_Node_Str"");
    pw.print(suffix);
  }
}","void printDuration(PrintWriter pw,long period,long duration,int count,String suffix){
  float fraction=duration / (float)period;
  int percent=(int)((fraction * 100) + .5f);
  if (percent > 0) {
    pw.print(""String_Node_Str"");
    pw.print(percent);
    pw.print(""String_Node_Str"");
    pw.print(count);
    pw.print(""String_Node_Str"");
    pw.print(suffix);
  }
 else   if (count > 0) {
    pw.print(""String_Node_Str"");
    pw.print(count);
    pw.print(""String_Node_Str"");
    pw.print(suffix);
  }
}",0.7487562189054726
191687,"public void addEvent(int cmd,int uid,String tag){
  System.arraycopy(mEventCmds,0,mEventCmds,1,EVENT_BUFFER_SIZE - 1);
  System.arraycopy(mEventTimes,0,mEventTimes,1,EVENT_BUFFER_SIZE - 1);
  System.arraycopy(mEventUids,0,mEventUids,1,EVENT_BUFFER_SIZE - 1);
  System.arraycopy(mEventTags,0,mEventTags,1,EVENT_BUFFER_SIZE - 1);
  mEventCmds[0]=cmd;
  mEventTimes[0]=SystemClock.elapsedRealtime();
  mEventUids[0]=uid;
  mEventTags[0]=tag;
}","public void addEvent(int cmd,int uid,String tag){
  int index=mEventIndices.add();
  mEventCmds[index]=cmd;
  mEventTimes[index]=SystemClock.elapsedRealtime();
  mEventUids[index]=uid;
  mEventTags[index]=tag;
}",0.3809523809523809
191688,"void finish(DataSet next,long now){
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      if (pe.activeCount > 0 || pe.activeTopCount > 0 || pe.pendingCount > 0) {
        PackageEntry nextPe=next.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
        nextPe.activeStartTime=now;
        nextPe.activeCount=pe.activeCount;
        nextPe.activeTopStartTime=now;
        nextPe.activeTopCount=pe.activeTopCount;
        nextPe.pendingStartTime=now;
        nextPe.pendingCount=pe.pendingCount;
        if (pe.activeCount > 0) {
          pe.pastActiveTime+=now - pe.activeStartTime;
          pe.activeCount=0;
        }
        if (pe.activeTopCount > 0) {
          pe.pastActiveTopTime+=now - pe.activeTopStartTime;
          pe.activeTopCount=0;
        }
        if (pe.pendingCount > 0) {
          pe.pastPendingTime+=now - pe.pendingStartTime;
          pe.pendingCount=0;
        }
      }
    }
  }
}","void finish(DataSet next,long now){
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      if (pe.activeNesting > 0 || pe.activeTopNesting > 0 || pe.pendingNesting > 0) {
        PackageEntry nextPe=next.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
        nextPe.activeStartTime=now;
        nextPe.activeNesting=pe.activeNesting;
        nextPe.activeTopStartTime=now;
        nextPe.activeTopNesting=pe.activeTopNesting;
        nextPe.pendingStartTime=now;
        nextPe.pendingNesting=pe.pendingNesting;
        if (pe.activeNesting > 0) {
          pe.pastActiveTime+=now - pe.activeStartTime;
          pe.activeNesting=0;
        }
        if (pe.activeTopNesting > 0) {
          pe.pastActiveTopTime+=now - pe.activeTopStartTime;
          pe.activeTopNesting=0;
        }
        if (pe.pendingNesting > 0) {
          pe.pastPendingTime+=now - pe.pendingStartTime;
          pe.pendingNesting=0;
        }
      }
    }
  }
}",0.8855032317636196
191689,"void incActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopCount == 0) {
    pe.activeTopStartTime=now;
  }
  pe.activeTopCount++;
}","void incActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopNesting == 0) {
    pe.activeTopStartTime=now;
    pe.activeTopCount++;
  }
  pe.activeTopNesting++;
}",0.8765743073047859
191690,"void decActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopCount == 1) {
    pe.pastActiveTopTime+=now - pe.activeTopStartTime;
  }
  pe.activeTopCount--;
}","void decActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopNesting == 1) {
    pe.pastActiveTopTime+=now - pe.activeTopStartTime;
  }
  pe.activeTopNesting--;
}",0.9428571428571428
191691,"void incActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeCount == 0) {
    pe.activeStartTime=now;
  }
  pe.activeCount++;
}","void incActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeNesting == 0) {
    pe.activeStartTime=now;
    pe.activeCount++;
  }
  pe.activeNesting++;
}",0.8972972972972973
191692,"void decPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingCount == 1) {
    pe.pastPendingTime+=now - pe.pendingStartTime;
  }
  pe.pendingCount--;
}","void decPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingNesting == 1) {
    pe.pastPendingTime+=now - pe.pendingStartTime;
  }
  pe.pendingNesting--;
}",0.94
191693,"void addTo(DataSet out,long now){
  out.mSummedTime+=getTotalTime(now);
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      PackageEntry outPe=out.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
      outPe.pastActiveTime+=pe.pastActiveTime;
      outPe.pastActiveTopTime+=pe.pastActiveTopTime;
      outPe.pastPendingTime+=pe.pastPendingTime;
      if (pe.activeCount > 0) {
        outPe.pastActiveTime+=now - pe.activeStartTime;
        outPe.hadActive=true;
      }
      if (pe.activeTopCount > 0) {
        outPe.pastActiveTopTime+=now - pe.activeTopStartTime;
        outPe.hadActiveTop=true;
      }
      if (pe.pendingCount > 0) {
        outPe.pastPendingTime+=now - pe.pendingStartTime;
        outPe.hadPending=true;
      }
    }
  }
}","void addTo(DataSet out,long now){
  out.mSummedTime+=getTotalTime(now);
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      PackageEntry outPe=out.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
      outPe.pastActiveTime+=pe.pastActiveTime;
      outPe.activeCount+=pe.activeCount;
      outPe.pastActiveTopTime+=pe.pastActiveTopTime;
      outPe.activeTopCount+=pe.activeTopCount;
      outPe.pastPendingTime+=pe.pastPendingTime;
      outPe.pendingCount+=pe.pendingCount;
      if (pe.activeNesting > 0) {
        outPe.pastActiveTime+=now - pe.activeStartTime;
        outPe.hadActive=true;
      }
      if (pe.activeTopNesting > 0) {
        outPe.pastActiveTopTime+=now - pe.activeTopStartTime;
        outPe.hadActiveTop=true;
      }
      if (pe.pendingNesting > 0) {
        outPe.pastPendingTime+=now - pe.pendingStartTime;
        outPe.hadPending=true;
      }
    }
  }
}",0.8429667519181586
191694,"public long getActiveTime(long now){
  long time=pastActiveTime;
  if (activeCount > 0) {
    time+=now - activeStartTime;
  }
  return time;
}","public long getActiveTime(long now){
  long time=pastActiveTime;
  if (activeNesting > 0) {
    time+=now - activeStartTime;
  }
  return time;
}",0.9652777777777778
191695,"void incPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingCount == 0) {
    pe.pendingStartTime=now;
  }
  pe.pendingCount++;
}","void incPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingNesting == 0) {
    pe.pendingStartTime=now;
    pe.pendingCount++;
  }
  pe.pendingNesting++;
}",0.8759894459102903
191696,"public long getPendingTime(long now){
  long time=pastPendingTime;
  if (pendingCount > 0) {
    time+=now - pendingStartTime;
  }
  return time;
}","public long getPendingTime(long now){
  long time=pastPendingTime;
  if (pendingNesting > 0) {
    time+=now - pendingStartTime;
  }
  return time;
}",0.9662162162162162
191697,"/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  try {
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,""String_Node_Str"");
    final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
    classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ key);
    }
synchronized (this) {
      final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
      if (overrideConfig != null) {
        activityResources.overrideConfig.setTo(overrideConfig);
      }
 else {
        activityResources.overrideConfig.setToDefaults();
      }
    }
    updateResourcesForActivity(activityToken,overrideConfig);
    return getOrCreateResources(activityToken,key,classLoader);
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
  }
}","/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  try {
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,""String_Node_Str"");
    final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
    classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ key);
    }
synchronized (this) {
      getOrCreateActivityResourcesStructLocked(activityToken);
    }
    updateResourcesForActivity(activityToken,overrideConfig);
    return getOrCreateResources(activityToken,key,classLoader);
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
  }
}",0.9521571977787272
191698,"/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  try {
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,""String_Node_Str"");
    final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
    classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ key);
    }
synchronized (this) {
      final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
      if (overrideConfig != null) {
        activityResources.overrideConfig.setTo(overrideConfig);
      }
 else {
        activityResources.overrideConfig.setToDefaults();
      }
    }
    updateResourcesForActivity(activityToken,overrideConfig);
    return getOrCreateResources(activityToken,key,classLoader);
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
  }
}","/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  try {
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES,""String_Node_Str"");
    final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
    classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ key);
    }
synchronized (this) {
      getOrCreateActivityResourcesStructLocked(activityToken);
    }
    updateResourcesForActivity(activityToken,overrideConfig);
    return getOrCreateResources(activityToken,key,classLoader);
  }
  finally {
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
  }
}",0.9521571977787272
191699,"public boolean dumpHistory(PrintWriter pw,String prefix,int filterUid){
  if (mEventCmds[0] == EVENT_NULL) {
    return false;
  }
  pw.println(""String_Node_Str"");
  long now=SystemClock.elapsedRealtime();
  for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
    int uid=mEventUids[i];
    if (filterUid != -1 && filterUid != UserHandle.getAppId(filterUid)) {
      continue;
    }
    int cmd=mEventCmds[i];
    if (cmd == EVENT_NULL) {
      continue;
    }
    String label;
switch (mEventCmds[i]) {
case EVENT_START_JOB:
      label=""String_Node_Str"";
    break;
case EVENT_STOP_JOB:
  label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(prefix);
TimeUtils.formatDuration(mEventTimes[i] - now,pw,TimeUtils.HUNDRED_DAY_FIELD_LEN);
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
UserHandle.formatUid(pw,uid);
pw.print(""String_Node_Str"");
pw.println(mEventTags[i]);
}
return true;
}","public boolean dumpHistory(PrintWriter pw,String prefix,int filterUid){
  final int size=mEventIndices.size();
  if (size <= 0) {
    return false;
  }
  pw.println(""String_Node_Str"");
  final long now=SystemClock.elapsedRealtime();
  for (int i=0; i < size; i++) {
    final int index=mEventIndices.indexOf(i);
    final int uid=mEventUids[index];
    if (filterUid != -1 && filterUid != UserHandle.getAppId(filterUid)) {
      continue;
    }
    final int cmd=mEventCmds[index];
    if (cmd == EVENT_NULL) {
      continue;
    }
    final String label;
switch (mEventCmds[index]) {
case EVENT_START_JOB:
      label=""String_Node_Str"";
    break;
case EVENT_STOP_JOB:
  label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(prefix);
TimeUtils.formatDuration(mEventTimes[index] - now,pw,TimeUtils.HUNDRED_DAY_FIELD_LEN);
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
UserHandle.formatUid(pw,uid);
pw.print(""String_Node_Str"");
pw.println(mEventTags[index]);
}
return true;
}",0.6019221041982802
191700,"public long getActiveTopTime(long now){
  long time=pastActiveTopTime;
  if (activeTopCount > 0) {
    time+=now - activeTopStartTime;
  }
  return time;
}","public long getActiveTopTime(long now){
  long time=pastActiveTopTime;
  if (activeTopNesting > 0) {
    time+=now - activeTopStartTime;
  }
  return time;
}",0.967948717948718
191701,"void decActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeCount == 1) {
    pe.pastActiveTime+=now - pe.activeStartTime;
  }
  pe.activeCount--;
}","void decActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeNesting == 1) {
    pe.pastActiveTime+=now - pe.activeStartTime;
  }
  pe.activeNesting--;
}",0.9487179487179488
191702,"void printDuration(PrintWriter pw,long period,long duration,String suffix){
  float fraction=duration / (float)period;
  int percent=(int)((fraction * 100) + .5f);
  if (percent > 0) {
    pw.print(""String_Node_Str"");
    pw.print(percent);
    pw.print(""String_Node_Str"");
    pw.print(suffix);
  }
}","void printDuration(PrintWriter pw,long period,long duration,int count,String suffix){
  float fraction=duration / (float)period;
  int percent=(int)((fraction * 100) + .5f);
  if (percent > 0) {
    pw.print(""String_Node_Str"");
    pw.print(percent);
    pw.print(""String_Node_Str"");
    pw.print(count);
    pw.print(""String_Node_Str"");
    pw.print(suffix);
  }
 else   if (count > 0) {
    pw.print(""String_Node_Str"");
    pw.print(count);
    pw.print(""String_Node_Str"");
    pw.print(suffix);
  }
}",0.7487562189054726
191703,"public void addEvent(int cmd,int uid,String tag){
  System.arraycopy(mEventCmds,0,mEventCmds,1,EVENT_BUFFER_SIZE - 1);
  System.arraycopy(mEventTimes,0,mEventTimes,1,EVENT_BUFFER_SIZE - 1);
  System.arraycopy(mEventUids,0,mEventUids,1,EVENT_BUFFER_SIZE - 1);
  System.arraycopy(mEventTags,0,mEventTags,1,EVENT_BUFFER_SIZE - 1);
  mEventCmds[0]=cmd;
  mEventTimes[0]=SystemClock.elapsedRealtime();
  mEventUids[0]=uid;
  mEventTags[0]=tag;
}","public void addEvent(int cmd,int uid,String tag){
  int index=mEventIndices.add();
  mEventCmds[index]=cmd;
  mEventTimes[index]=SystemClock.elapsedRealtime();
  mEventUids[index]=uid;
  mEventTags[index]=tag;
}",0.3809523809523809
191704,"void finish(DataSet next,long now){
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      if (pe.activeCount > 0 || pe.activeTopCount > 0 || pe.pendingCount > 0) {
        PackageEntry nextPe=next.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
        nextPe.activeStartTime=now;
        nextPe.activeCount=pe.activeCount;
        nextPe.activeTopStartTime=now;
        nextPe.activeTopCount=pe.activeTopCount;
        nextPe.pendingStartTime=now;
        nextPe.pendingCount=pe.pendingCount;
        if (pe.activeCount > 0) {
          pe.pastActiveTime+=now - pe.activeStartTime;
          pe.activeCount=0;
        }
        if (pe.activeTopCount > 0) {
          pe.pastActiveTopTime+=now - pe.activeTopStartTime;
          pe.activeTopCount=0;
        }
        if (pe.pendingCount > 0) {
          pe.pastPendingTime+=now - pe.pendingStartTime;
          pe.pendingCount=0;
        }
      }
    }
  }
}","void finish(DataSet next,long now){
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      if (pe.activeNesting > 0 || pe.activeTopNesting > 0 || pe.pendingNesting > 0) {
        PackageEntry nextPe=next.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
        nextPe.activeStartTime=now;
        nextPe.activeNesting=pe.activeNesting;
        nextPe.activeTopStartTime=now;
        nextPe.activeTopNesting=pe.activeTopNesting;
        nextPe.pendingStartTime=now;
        nextPe.pendingNesting=pe.pendingNesting;
        if (pe.activeNesting > 0) {
          pe.pastActiveTime+=now - pe.activeStartTime;
          pe.activeNesting=0;
        }
        if (pe.activeTopNesting > 0) {
          pe.pastActiveTopTime+=now - pe.activeTopStartTime;
          pe.activeTopNesting=0;
        }
        if (pe.pendingNesting > 0) {
          pe.pastPendingTime+=now - pe.pendingStartTime;
          pe.pendingNesting=0;
        }
      }
    }
  }
}",0.8855032317636196
191705,"void incActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopCount == 0) {
    pe.activeTopStartTime=now;
  }
  pe.activeTopCount++;
}","void incActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopNesting == 0) {
    pe.activeTopStartTime=now;
    pe.activeTopCount++;
  }
  pe.activeTopNesting++;
}",0.8765743073047859
191706,"void decActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopCount == 1) {
    pe.pastActiveTopTime+=now - pe.activeTopStartTime;
  }
  pe.activeTopCount--;
}","void decActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopNesting == 1) {
    pe.pastActiveTopTime+=now - pe.activeTopStartTime;
  }
  pe.activeTopNesting--;
}",0.9428571428571428
191707,"void incActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeCount == 0) {
    pe.activeStartTime=now;
  }
  pe.activeCount++;
}","void incActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeNesting == 0) {
    pe.activeStartTime=now;
    pe.activeCount++;
  }
  pe.activeNesting++;
}",0.8972972972972973
191708,"void decPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingCount == 1) {
    pe.pastPendingTime+=now - pe.pendingStartTime;
  }
  pe.pendingCount--;
}","void decPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingNesting == 1) {
    pe.pastPendingTime+=now - pe.pendingStartTime;
  }
  pe.pendingNesting--;
}",0.94
191709,"void addTo(DataSet out,long now){
  out.mSummedTime+=getTotalTime(now);
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      PackageEntry outPe=out.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
      outPe.pastActiveTime+=pe.pastActiveTime;
      outPe.pastActiveTopTime+=pe.pastActiveTopTime;
      outPe.pastPendingTime+=pe.pastPendingTime;
      if (pe.activeCount > 0) {
        outPe.pastActiveTime+=now - pe.activeStartTime;
        outPe.hadActive=true;
      }
      if (pe.activeTopCount > 0) {
        outPe.pastActiveTopTime+=now - pe.activeTopStartTime;
        outPe.hadActiveTop=true;
      }
      if (pe.pendingCount > 0) {
        outPe.pastPendingTime+=now - pe.pendingStartTime;
        outPe.hadPending=true;
      }
    }
  }
}","void addTo(DataSet out,long now){
  out.mSummedTime+=getTotalTime(now);
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      PackageEntry outPe=out.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
      outPe.pastActiveTime+=pe.pastActiveTime;
      outPe.activeCount+=pe.activeCount;
      outPe.pastActiveTopTime+=pe.pastActiveTopTime;
      outPe.activeTopCount+=pe.activeTopCount;
      outPe.pastPendingTime+=pe.pastPendingTime;
      outPe.pendingCount+=pe.pendingCount;
      if (pe.activeNesting > 0) {
        outPe.pastActiveTime+=now - pe.activeStartTime;
        outPe.hadActive=true;
      }
      if (pe.activeTopNesting > 0) {
        outPe.pastActiveTopTime+=now - pe.activeTopStartTime;
        outPe.hadActiveTop=true;
      }
      if (pe.pendingNesting > 0) {
        outPe.pastPendingTime+=now - pe.pendingStartTime;
        outPe.hadPending=true;
      }
    }
  }
}",0.8429667519181586
191710,"public long getActiveTime(long now){
  long time=pastActiveTime;
  if (activeCount > 0) {
    time+=now - activeStartTime;
  }
  return time;
}","public long getActiveTime(long now){
  long time=pastActiveTime;
  if (activeNesting > 0) {
    time+=now - activeStartTime;
  }
  return time;
}",0.9652777777777778
191711,"void incPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingCount == 0) {
    pe.pendingStartTime=now;
  }
  pe.pendingCount++;
}","void incPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingNesting == 0) {
    pe.pendingStartTime=now;
    pe.pendingCount++;
  }
  pe.pendingNesting++;
}",0.8759894459102903
191712,"public long getPendingTime(long now){
  long time=pastPendingTime;
  if (pendingCount > 0) {
    time+=now - pendingStartTime;
  }
  return time;
}","public long getPendingTime(long now){
  long time=pastPendingTime;
  if (pendingNesting > 0) {
    time+=now - pendingStartTime;
  }
  return time;
}",0.9662162162162162
191713,"public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification _foregroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerInternal nm=LocalServices.getService(NotificationManagerInternal.class);
        if (nm == null) {
          return;
        }
        Notification localForegroundNoti=_foregroundNoti;
        try {
          if (localForegroundNoti.getSmallIcon() == null) {
            Slog.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ localForegroundNoti+ ""String_Node_Str"");
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContext(appInfo.packageName,0);
              Notification.Builder notiBuilder=new Notification.Builder(ctx);
              notiBuilder.setSmallIcon(appInfo.icon);
              notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE,true);
              notiBuilder.setPriority(Notification.PRIORITY_MIN);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              notiBuilder.setColor(ams.mContext.getColor(com.android.internal.R.color.system_notification_accent_color));
              notiBuilder.setContentTitle(ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName));
              notiBuilder.setContentText(ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName));
              notiBuilder.setContentIntent(pi);
              localForegroundNoti=notiBuilder.build();
            }
 catch (            PackageManager.NameNotFoundException e) {
            }
          }
          if (localForegroundNoti.getSmallIcon() == null) {
            throw new RuntimeException(""String_Node_Str"" + foregroundNoti);
          }
          int[] outId=new int[1];
          nm.enqueueNotification(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
          foregroundNoti=localForegroundNoti;
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,0);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}","public void postNotification(){
  final int appUid=appInfo.uid;
  final int appPid=app.pid;
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification _foregroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        NotificationManagerInternal nm=LocalServices.getService(NotificationManagerInternal.class);
        if (nm == null) {
          return;
        }
        Notification localForegroundNoti=_foregroundNoti;
        try {
          if (localForegroundNoti.getSmallIcon() == null) {
            Slog.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ localForegroundNoti+ ""String_Node_Str"");
            CharSequence appName=appInfo.loadLabel(ams.mContext.getPackageManager());
            if (appName == null) {
              appName=appInfo.packageName;
            }
            Context ctx=null;
            try {
              ctx=ams.mContext.createPackageContextAsUser(appInfo.packageName,0,new UserHandle(userId));
              Notification.Builder notiBuilder=new Notification.Builder(ctx);
              notiBuilder.setSmallIcon(appInfo.icon);
              notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE,true);
              notiBuilder.setPriority(Notification.PRIORITY_MIN);
              Intent runningIntent=new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
              runningIntent.setData(Uri.fromParts(""String_Node_Str"",appInfo.packageName,null));
              PendingIntent pi=PendingIntent.getActivity(ams.mContext,0,runningIntent,PendingIntent.FLAG_UPDATE_CURRENT);
              notiBuilder.setColor(ams.mContext.getColor(com.android.internal.R.color.system_notification_accent_color));
              notiBuilder.setContentTitle(ams.mContext.getString(com.android.internal.R.string.app_running_notification_title,appName));
              notiBuilder.setContentText(ams.mContext.getString(com.android.internal.R.string.app_running_notification_text,appName));
              notiBuilder.setContentIntent(pi);
              localForegroundNoti=notiBuilder.build();
            }
 catch (            PackageManager.NameNotFoundException e) {
            }
          }
          if (localForegroundNoti.getSmallIcon() == null) {
            throw new RuntimeException(""String_Node_Str"" + foregroundNoti);
          }
          int[] outId=new int[1];
          nm.enqueueNotification(localPackageName,localPackageName,appUid,appPid,null,localForegroundId,localForegroundNoti,outId,userId);
          foregroundNoti=localForegroundNoti;
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,0,null,0);
          ams.crashApplication(appUid,appPid,localPackageName,""String_Node_Str"" + e);
        }
      }
    }
);
  }
}",0.9950008619203584
191714,"public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    String oldKey=oldNotification.getGroupKey();
    String newKey=entry.notification.getGroupKey();
    if (!oldKey.equals(newKey)) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
}","public void onEntryUpdated(NotificationData.Entry entry,StatusBarNotification oldNotification){
  if (mGroupMap.get(getGroupKey(oldNotification)) != null) {
    onEntryRemovedInternal(entry,oldNotification);
  }
  onEntryAdded(entry);
  if (isIsolated(entry.notification)) {
    mIsolatedEntries.put(entry.key,entry.notification);
    String oldKey=oldNotification.getGroupKey();
    String newKey=entry.notification.getGroupKey();
    if (!oldKey.equals(newKey)) {
      updateSuppression(mGroupMap.get(oldKey));
      updateSuppression(mGroupMap.get(newKey));
    }
  }
 else   if (!isGroupChild(oldNotification) && isGroupChild(entry.notification)) {
    onEntryBecomingChild(entry);
  }
}",0.9059288537549408
191715,"public void onEntryAdded(final NotificationData.Entry added){
  final StatusBarNotification sbn=added.notification;
  boolean isGroupChild=isGroupChild(sbn);
  String groupKey=getGroupKey(sbn);
  NotificationGroup group=mGroupMap.get(groupKey);
  if (group == null) {
    group=new NotificationGroup();
    mGroupMap.put(groupKey,group);
  }
  if (isGroupChild) {
    group.children.add(added);
    updateSuppression(group);
  }
 else {
    group.summary=added;
    group.expanded=added.row.areChildrenExpanded();
    updateSuppression(group);
    if (!group.children.isEmpty()) {
      mListener.onGroupCreatedFromChildren(group);
    }
  }
}","public void onEntryAdded(final NotificationData.Entry added){
  final StatusBarNotification sbn=added.notification;
  boolean isGroupChild=isGroupChild(sbn);
  String groupKey=getGroupKey(sbn);
  NotificationGroup group=mGroupMap.get(groupKey);
  if (group == null) {
    group=new NotificationGroup();
    mGroupMap.put(groupKey,group);
  }
  if (isGroupChild) {
    group.children.add(added);
    updateSuppression(group);
  }
 else {
    group.summary=added;
    group.expanded=added.row.areChildrenExpanded();
    updateSuppression(group);
    if (!group.children.isEmpty()) {
      HashSet<NotificationData.Entry> childrenCopy=(HashSet<NotificationData.Entry>)group.children.clone();
      for (      NotificationData.Entry child : childrenCopy) {
        onEntryBecomingChild(child);
      }
      mListener.onGroupCreatedFromChildren(group);
    }
  }
}",0.8556220891550232
191716,"private void updateHideSensitiveForChild(View child){
  if (mAmbientState.isHideSensitive() && child instanceof ExpandableView) {
    ExpandableView expandableView=(ExpandableView)child;
    expandableView.setHideSensitiveForIntrinsicHeight(true);
  }
}","private void updateHideSensitiveForChild(View child){
  if (child instanceof ExpandableView) {
    ExpandableView expandableView=(ExpandableView)child;
    expandableView.setHideSensitiveForIntrinsicHeight(mAmbientState.isHideSensitive());
  }
}",0.393574297188755
191717,"@Override public void toggleRecents(int growTarget) throws RemoteException {
  mHandler.sendMessage(mHandler.obtainMessage(MSG_TOGGLE_RECENTS,growTarget));
}","@Override public void toggleRecents(int growTarget) throws RemoteException {
  SomeArgs args=SomeArgs.obtain();
  args.argi1=growTarget;
  mHandler.sendMessage(mHandler.obtainMessage(MSG_TOGGLE_RECENTS,args));
}",0.7989130434782609
191718,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_PRELOAD_RECENTS:
    mImpl.preloadRecents();
  break;
case MSG_CANCEL_PRELOADING_RECENTS:
mImpl.cancelPreloadingRecents();
break;
case MSG_SHOW_RECENTS:
SomeArgs args=(SomeArgs)msg.obj;
mImpl.showRecents(args.argi1 != 0,args.argi2 != 0,args.argi3 != 0,args.argi4 != 0,args.argi5 != 0,args.argi6);
break;
case MSG_HIDE_RECENTS:
mImpl.hideRecents(msg.arg1 != 0,msg.arg2 != 0);
break;
case MSG_TOGGLE_RECENTS:
mImpl.toggleRecents(msg.arg1);
break;
case MSG_ON_CONFIGURATION_CHANGED:
mImpl.onConfigurationChanged();
break;
case MSG_DOCK_TOP_TASK:
args=(SomeArgs)msg.obj;
mImpl.dockTopTask(args.argi1,args.argi2,args.argi3=0,(Rect)args.arg1);
break;
case MSG_ON_DRAGGING_IN_RECENTS:
mImpl.onDraggingInRecents((Float)msg.obj);
break;
case MSG_ON_DRAGGING_IN_RECENTS_ENDED:
mImpl.onDraggingInRecentsEnded((Float)msg.obj);
break;
default :
super.handleMessage(msg);
}
super.handleMessage(msg);
}","@Override public void handleMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_PRELOAD_RECENTS:
    mImpl.preloadRecents();
  break;
case MSG_CANCEL_PRELOADING_RECENTS:
mImpl.cancelPreloadingRecents();
break;
case MSG_SHOW_RECENTS:
args=(SomeArgs)msg.obj;
mImpl.showRecents(args.argi1 != 0,args.argi2 != 0,args.argi3 != 0,args.argi4 != 0,args.argi5 != 0,args.argi6);
break;
case MSG_HIDE_RECENTS:
mImpl.hideRecents(msg.arg1 != 0,msg.arg2 != 0);
break;
case MSG_TOGGLE_RECENTS:
args=(SomeArgs)msg.obj;
mImpl.toggleRecents(args.argi1);
break;
case MSG_ON_CONFIGURATION_CHANGED:
mImpl.onConfigurationChanged();
break;
case MSG_DOCK_TOP_TASK:
args=(SomeArgs)msg.obj;
mImpl.dockTopTask(args.argi1,args.argi2,args.argi3=0,(Rect)args.arg1);
break;
case MSG_ON_DRAGGING_IN_RECENTS:
mImpl.onDraggingInRecents((Float)msg.obj);
break;
case MSG_ON_DRAGGING_IN_RECENTS_ENDED:
mImpl.onDraggingInRecentsEnded((Float)msg.obj);
break;
default :
super.handleMessage(msg);
}
super.handleMessage(msg);
}",0.9460834181078333
191719,"public boolean dumpHistory(PrintWriter pw,String prefix,int filterUid){
  if (mEventCmds[0] == EVENT_NULL) {
    return false;
  }
  pw.println(""String_Node_Str"");
  long now=SystemClock.elapsedRealtime();
  for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
    int uid=mEventUids[i];
    if (filterUid != -1 && filterUid != UserHandle.getAppId(filterUid)) {
      continue;
    }
    int cmd=mEventCmds[i];
    if (cmd == EVENT_NULL) {
      continue;
    }
    String label;
switch (mEventCmds[i]) {
case EVENT_START_JOB:
      label=""String_Node_Str"";
    break;
case EVENT_STOP_JOB:
  label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(prefix);
TimeUtils.formatDuration(mEventTimes[i] - now,pw,TimeUtils.HUNDRED_DAY_FIELD_LEN);
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
UserHandle.formatUid(pw,uid);
pw.print(""String_Node_Str"");
pw.println(mEventTags[i]);
}
return true;
}","public boolean dumpHistory(PrintWriter pw,String prefix,int filterUid){
  final int size=mEventIndices.size();
  if (size <= 0) {
    return false;
  }
  pw.println(""String_Node_Str"");
  final long now=SystemClock.elapsedRealtime();
  for (int i=0; i < size; i++) {
    final int index=mEventIndices.indexOf(i);
    final int uid=mEventUids[index];
    if (filterUid != -1 && filterUid != UserHandle.getAppId(filterUid)) {
      continue;
    }
    final int cmd=mEventCmds[index];
    if (cmd == EVENT_NULL) {
      continue;
    }
    final String label;
switch (mEventCmds[index]) {
case EVENT_START_JOB:
      label=""String_Node_Str"";
    break;
case EVENT_STOP_JOB:
  label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(prefix);
TimeUtils.formatDuration(mEventTimes[index] - now,pw,TimeUtils.HUNDRED_DAY_FIELD_LEN);
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
UserHandle.formatUid(pw,uid);
pw.print(""String_Node_Str"");
pw.println(mEventTags[index]);
}
return true;
}",0.6019221041982802
191720,"public long getActiveTopTime(long now){
  long time=pastActiveTopTime;
  if (activeTopCount > 0) {
    time+=now - activeTopStartTime;
  }
  return time;
}","public long getActiveTopTime(long now){
  long time=pastActiveTopTime;
  if (activeTopNesting > 0) {
    time+=now - activeTopStartTime;
  }
  return time;
}",0.967948717948718
191721,"void decActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeCount == 1) {
    pe.pastActiveTime+=now - pe.activeStartTime;
  }
  pe.activeCount--;
}","void decActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeNesting == 1) {
    pe.pastActiveTime+=now - pe.activeStartTime;
  }
  pe.activeNesting--;
}",0.9487179487179488
191722,"void printDuration(PrintWriter pw,long period,long duration,String suffix){
  float fraction=duration / (float)period;
  int percent=(int)((fraction * 100) + .5f);
  if (percent > 0) {
    pw.print(""String_Node_Str"");
    pw.print(percent);
    pw.print(""String_Node_Str"");
    pw.print(suffix);
  }
}","void printDuration(PrintWriter pw,long period,long duration,int count,String suffix){
  float fraction=duration / (float)period;
  int percent=(int)((fraction * 100) + .5f);
  if (percent > 0) {
    pw.print(""String_Node_Str"");
    pw.print(percent);
    pw.print(""String_Node_Str"");
    pw.print(count);
    pw.print(""String_Node_Str"");
    pw.print(suffix);
  }
 else   if (count > 0) {
    pw.print(""String_Node_Str"");
    pw.print(count);
    pw.print(""String_Node_Str"");
    pw.print(suffix);
  }
}",0.7487562189054726
191723,"public void addEvent(int cmd,int uid,String tag){
  System.arraycopy(mEventCmds,0,mEventCmds,1,EVENT_BUFFER_SIZE - 1);
  System.arraycopy(mEventTimes,0,mEventTimes,1,EVENT_BUFFER_SIZE - 1);
  System.arraycopy(mEventUids,0,mEventUids,1,EVENT_BUFFER_SIZE - 1);
  System.arraycopy(mEventTags,0,mEventTags,1,EVENT_BUFFER_SIZE - 1);
  mEventCmds[0]=cmd;
  mEventTimes[0]=SystemClock.elapsedRealtime();
  mEventUids[0]=uid;
  mEventTags[0]=tag;
}","public void addEvent(int cmd,int uid,String tag){
  int index=mEventIndices.add();
  mEventCmds[index]=cmd;
  mEventTimes[index]=SystemClock.elapsedRealtime();
  mEventUids[index]=uid;
  mEventTags[index]=tag;
}",0.3809523809523809
191724,"void finish(DataSet next,long now){
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      if (pe.activeCount > 0 || pe.activeTopCount > 0 || pe.pendingCount > 0) {
        PackageEntry nextPe=next.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
        nextPe.activeStartTime=now;
        nextPe.activeCount=pe.activeCount;
        nextPe.activeTopStartTime=now;
        nextPe.activeTopCount=pe.activeTopCount;
        nextPe.pendingStartTime=now;
        nextPe.pendingCount=pe.pendingCount;
        if (pe.activeCount > 0) {
          pe.pastActiveTime+=now - pe.activeStartTime;
          pe.activeCount=0;
        }
        if (pe.activeTopCount > 0) {
          pe.pastActiveTopTime+=now - pe.activeTopStartTime;
          pe.activeTopCount=0;
        }
        if (pe.pendingCount > 0) {
          pe.pastPendingTime+=now - pe.pendingStartTime;
          pe.pendingCount=0;
        }
      }
    }
  }
}","void finish(DataSet next,long now){
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      if (pe.activeNesting > 0 || pe.activeTopNesting > 0 || pe.pendingNesting > 0) {
        PackageEntry nextPe=next.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
        nextPe.activeStartTime=now;
        nextPe.activeNesting=pe.activeNesting;
        nextPe.activeTopStartTime=now;
        nextPe.activeTopNesting=pe.activeTopNesting;
        nextPe.pendingStartTime=now;
        nextPe.pendingNesting=pe.pendingNesting;
        if (pe.activeNesting > 0) {
          pe.pastActiveTime+=now - pe.activeStartTime;
          pe.activeNesting=0;
        }
        if (pe.activeTopNesting > 0) {
          pe.pastActiveTopTime+=now - pe.activeTopStartTime;
          pe.activeTopNesting=0;
        }
        if (pe.pendingNesting > 0) {
          pe.pastPendingTime+=now - pe.pendingStartTime;
          pe.pendingNesting=0;
        }
      }
    }
  }
}",0.8855032317636196
191725,"void incActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopCount == 0) {
    pe.activeTopStartTime=now;
  }
  pe.activeTopCount++;
}","void incActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopNesting == 0) {
    pe.activeTopStartTime=now;
    pe.activeTopCount++;
  }
  pe.activeTopNesting++;
}",0.8765743073047859
191726,"void decActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopCount == 1) {
    pe.pastActiveTopTime+=now - pe.activeTopStartTime;
  }
  pe.activeTopCount--;
}","void decActiveTop(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeTopNesting == 1) {
    pe.pastActiveTopTime+=now - pe.activeTopStartTime;
  }
  pe.activeTopNesting--;
}",0.9428571428571428
191727,"void incActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeCount == 0) {
    pe.activeStartTime=now;
  }
  pe.activeCount++;
}","void incActive(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.activeNesting == 0) {
    pe.activeStartTime=now;
    pe.activeCount++;
  }
  pe.activeNesting++;
}",0.8972972972972973
191728,"void decPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingCount == 1) {
    pe.pastPendingTime+=now - pe.pendingStartTime;
  }
  pe.pendingCount--;
}","void decPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingNesting == 1) {
    pe.pastPendingTime+=now - pe.pendingStartTime;
  }
  pe.pendingNesting--;
}",0.94
191729,"void addTo(DataSet out,long now){
  out.mSummedTime+=getTotalTime(now);
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      PackageEntry outPe=out.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
      outPe.pastActiveTime+=pe.pastActiveTime;
      outPe.pastActiveTopTime+=pe.pastActiveTopTime;
      outPe.pastPendingTime+=pe.pastPendingTime;
      if (pe.activeCount > 0) {
        outPe.pastActiveTime+=now - pe.activeStartTime;
        outPe.hadActive=true;
      }
      if (pe.activeTopCount > 0) {
        outPe.pastActiveTopTime+=now - pe.activeTopStartTime;
        outPe.hadActiveTop=true;
      }
      if (pe.pendingCount > 0) {
        outPe.pastPendingTime+=now - pe.pendingStartTime;
        outPe.hadPending=true;
      }
    }
  }
}","void addTo(DataSet out,long now){
  out.mSummedTime+=getTotalTime(now);
  for (int i=mEntries.size() - 1; i >= 0; i--) {
    ArrayMap<String,PackageEntry> uidMap=mEntries.valueAt(i);
    for (int j=uidMap.size() - 1; j >= 0; j--) {
      PackageEntry pe=uidMap.valueAt(j);
      PackageEntry outPe=out.getOrCreateEntry(mEntries.keyAt(i),uidMap.keyAt(j));
      outPe.pastActiveTime+=pe.pastActiveTime;
      outPe.activeCount+=pe.activeCount;
      outPe.pastActiveTopTime+=pe.pastActiveTopTime;
      outPe.activeTopCount+=pe.activeTopCount;
      outPe.pastPendingTime+=pe.pastPendingTime;
      outPe.pendingCount+=pe.pendingCount;
      if (pe.activeNesting > 0) {
        outPe.pastActiveTime+=now - pe.activeStartTime;
        outPe.hadActive=true;
      }
      if (pe.activeTopNesting > 0) {
        outPe.pastActiveTopTime+=now - pe.activeTopStartTime;
        outPe.hadActiveTop=true;
      }
      if (pe.pendingNesting > 0) {
        outPe.pastPendingTime+=now - pe.pendingStartTime;
        outPe.hadPending=true;
      }
    }
  }
}",0.8429667519181586
191730,"public long getActiveTime(long now){
  long time=pastActiveTime;
  if (activeCount > 0) {
    time+=now - activeStartTime;
  }
  return time;
}","public long getActiveTime(long now){
  long time=pastActiveTime;
  if (activeNesting > 0) {
    time+=now - activeStartTime;
  }
  return time;
}",0.9652777777777778
191731,"void incPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingCount == 0) {
    pe.pendingStartTime=now;
  }
  pe.pendingCount++;
}","void incPending(int uid,String pkg,long now){
  PackageEntry pe=getOrCreateEntry(uid,pkg);
  if (pe.pendingNesting == 0) {
    pe.pendingStartTime=now;
    pe.pendingCount++;
  }
  pe.pendingNesting++;
}",0.8759894459102903
191732,"public long getPendingTime(long now){
  long time=pastPendingTime;
  if (pendingCount > 0) {
    time+=now - pendingStartTime;
  }
  return time;
}","public long getPendingTime(long now){
  long time=pastPendingTime;
  if (pendingNesting > 0) {
    time+=now - pendingStartTime;
  }
  return time;
}",0.9662162162162162
191733,"@Override public void toggleRecents(int growTarget) throws RemoteException {
  mHandler.sendMessage(mHandler.obtainMessage(MSG_TOGGLE_RECENTS,growTarget));
}","@Override public void toggleRecents(int growTarget) throws RemoteException {
  SomeArgs args=SomeArgs.obtain();
  args.argi1=growTarget;
  mHandler.sendMessage(mHandler.obtainMessage(MSG_TOGGLE_RECENTS,args));
}",0.7989130434782609
191734,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_PRELOAD_RECENTS:
    mImpl.preloadRecents();
  break;
case MSG_CANCEL_PRELOADING_RECENTS:
mImpl.cancelPreloadingRecents();
break;
case MSG_SHOW_RECENTS:
SomeArgs args=(SomeArgs)msg.obj;
mImpl.showRecents(args.argi1 != 0,args.argi2 != 0,args.argi3 != 0,args.argi4 != 0,args.argi5 != 0,args.argi6);
break;
case MSG_HIDE_RECENTS:
mImpl.hideRecents(msg.arg1 != 0,msg.arg2 != 0);
break;
case MSG_TOGGLE_RECENTS:
mImpl.toggleRecents(msg.arg1);
break;
case MSG_ON_CONFIGURATION_CHANGED:
mImpl.onConfigurationChanged();
break;
case MSG_DOCK_TOP_TASK:
args=(SomeArgs)msg.obj;
mImpl.dockTopTask(args.argi1,args.argi2,args.argi3=0,(Rect)args.arg1);
break;
case MSG_ON_DRAGGING_IN_RECENTS:
mImpl.onDraggingInRecents((Float)msg.obj);
break;
case MSG_ON_DRAGGING_IN_RECENTS_ENDED:
mImpl.onDraggingInRecentsEnded((Float)msg.obj);
break;
default :
super.handleMessage(msg);
}
super.handleMessage(msg);
}","@Override public void handleMessage(Message msg){
  SomeArgs args;
switch (msg.what) {
case MSG_PRELOAD_RECENTS:
    mImpl.preloadRecents();
  break;
case MSG_CANCEL_PRELOADING_RECENTS:
mImpl.cancelPreloadingRecents();
break;
case MSG_SHOW_RECENTS:
args=(SomeArgs)msg.obj;
mImpl.showRecents(args.argi1 != 0,args.argi2 != 0,args.argi3 != 0,args.argi4 != 0,args.argi5 != 0,args.argi6);
break;
case MSG_HIDE_RECENTS:
mImpl.hideRecents(msg.arg1 != 0,msg.arg2 != 0);
break;
case MSG_TOGGLE_RECENTS:
args=(SomeArgs)msg.obj;
mImpl.toggleRecents(args.argi1);
break;
case MSG_ON_CONFIGURATION_CHANGED:
mImpl.onConfigurationChanged();
break;
case MSG_DOCK_TOP_TASK:
args=(SomeArgs)msg.obj;
mImpl.dockTopTask(args.argi1,args.argi2,args.argi3=0,(Rect)args.arg1);
break;
case MSG_ON_DRAGGING_IN_RECENTS:
mImpl.onDraggingInRecents((Float)msg.obj);
break;
case MSG_ON_DRAGGING_IN_RECENTS_ENDED:
mImpl.onDraggingInRecentsEnded((Float)msg.obj);
break;
default :
super.handleMessage(msg);
}
super.handleMessage(msg);
}",0.9460834181078333
191735,"@Override public void onAnimationEnd(Animator animation){
  if (mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
    mKeyguardFadingOutInProgress=false;
  }
  scrim.setTag(TAG_KEY_ANIM,null);
  scrim.setTag(TAG_KEY_ANIM_TARGET,null);
}","@Override public void onAnimationEnd(Animator animation){
  if (mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mKeyguardFadingOutInProgress=false;
  scrim.setTag(TAG_KEY_ANIM,null);
  scrim.setTag(TAG_KEY_ANIM_TARGET,null);
}",0.9892857142857144
191736,"private void startScrimAnimation(final View scrim,float target){
  float current=getCurrentScrimAlpha(scrim);
  ValueAnimator anim=ValueAnimator.ofFloat(current,target);
  anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float alpha=(float)animation.getAnimatedValue();
      setCurrentScrimAlpha(scrim,alpha);
      updateScrimColor(scrim);
    }
  }
);
  anim.setInterpolator(getInterpolator());
  anim.setStartDelay(mAnimationDelay);
  anim.setDuration(mDurationOverride != -1 ? mDurationOverride : ANIMATION_DURATION);
  anim.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mOnAnimationFinished != null) {
        mOnAnimationFinished.run();
        mOnAnimationFinished=null;
        mKeyguardFadingOutInProgress=false;
      }
      scrim.setTag(TAG_KEY_ANIM,null);
      scrim.setTag(TAG_KEY_ANIM_TARGET,null);
    }
  }
);
  anim.start();
  if (mAnimateKeyguardFadingOut) {
    mKeyguardFadingOutInProgress=true;
  }
  if (mSkipFirstFrame) {
    anim.setCurrentPlayTime(16);
  }
  scrim.setTag(TAG_KEY_ANIM,anim);
  scrim.setTag(TAG_KEY_ANIM_TARGET,target);
}","private void startScrimAnimation(final View scrim,float target){
  float current=getCurrentScrimAlpha(scrim);
  ValueAnimator anim=ValueAnimator.ofFloat(current,target);
  anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float alpha=(float)animation.getAnimatedValue();
      setCurrentScrimAlpha(scrim,alpha);
      updateScrimColor(scrim);
    }
  }
);
  anim.setInterpolator(getInterpolator());
  anim.setStartDelay(mAnimationDelay);
  anim.setDuration(mDurationOverride != -1 ? mDurationOverride : ANIMATION_DURATION);
  anim.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mOnAnimationFinished != null) {
        mOnAnimationFinished.run();
        mOnAnimationFinished=null;
      }
      mKeyguardFadingOutInProgress=false;
      scrim.setTag(TAG_KEY_ANIM,null);
      scrim.setTag(TAG_KEY_ANIM_TARGET,null);
    }
  }
);
  anim.start();
  if (mAnimateKeyguardFadingOut) {
    mKeyguardFadingOutInProgress=true;
  }
  if (mSkipFirstFrame) {
    anim.setCurrentPlayTime(16);
  }
  scrim.setTag(TAG_KEY_ANIM,anim);
  scrim.setTag(TAG_KEY_ANIM_TARGET,target);
}",0.994331983805668
191737,"private void endAnimateKeyguardFadingOut(boolean force){
  mAnimateKeyguardFadingOut=false;
  if ((force || (!isAnimating(mScrimInFront) && !isAnimating(mScrimBehind))) && mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
    mKeyguardFadingOutInProgress=false;
  }
}","private void endAnimateKeyguardFadingOut(boolean force){
  mAnimateKeyguardFadingOut=false;
  if (force || (!isAnimating(mScrimInFront) && !isAnimating(mScrimBehind))) {
    if (mOnAnimationFinished != null) {
      mOnAnimationFinished.run();
      mOnAnimationFinished=null;
    }
    mKeyguardFadingOutInProgress=false;
  }
}",0.9625
191738,"@Override public void onAnimationEnd(Animator animation){
  if (mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mKeyguardFadingOutInProgress=false;
  scrim.setTag(TAG_KEY_ANIM,null);
  scrim.setTag(TAG_KEY_ANIM_TARGET,null);
}","@Override public void onAnimationEnd(Animator animation){
  if (mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  if (mKeyguardFadingOutInProgress) {
    mKeyguardFadeoutAnimation=null;
    mKeyguardFadingOutInProgress=false;
  }
  scrim.setTag(TAG_KEY_ANIM,null);
  scrim.setTag(TAG_KEY_ANIM_TARGET,null);
}",0.8746081504702194
191739,"private void startScrimAnimation(final View scrim,float target){
  float current=getCurrentScrimAlpha(scrim);
  ValueAnimator anim=ValueAnimator.ofFloat(current,target);
  anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float alpha=(float)animation.getAnimatedValue();
      setCurrentScrimAlpha(scrim,alpha);
      updateScrimColor(scrim);
    }
  }
);
  anim.setInterpolator(getInterpolator());
  anim.setStartDelay(mAnimationDelay);
  anim.setDuration(mDurationOverride != -1 ? mDurationOverride : ANIMATION_DURATION);
  anim.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mOnAnimationFinished != null) {
        mOnAnimationFinished.run();
        mOnAnimationFinished=null;
      }
      mKeyguardFadingOutInProgress=false;
      scrim.setTag(TAG_KEY_ANIM,null);
      scrim.setTag(TAG_KEY_ANIM_TARGET,null);
    }
  }
);
  anim.start();
  if (mAnimateKeyguardFadingOut) {
    mKeyguardFadingOutInProgress=true;
  }
  if (mSkipFirstFrame) {
    anim.setCurrentPlayTime(16);
  }
  scrim.setTag(TAG_KEY_ANIM,anim);
  scrim.setTag(TAG_KEY_ANIM_TARGET,target);
}","private void startScrimAnimation(final View scrim,float target){
  float current=getCurrentScrimAlpha(scrim);
  ValueAnimator anim=ValueAnimator.ofFloat(current,target);
  anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float alpha=(float)animation.getAnimatedValue();
      setCurrentScrimAlpha(scrim,alpha);
      updateScrimColor(scrim);
    }
  }
);
  anim.setInterpolator(getInterpolator());
  anim.setStartDelay(mAnimationDelay);
  anim.setDuration(mDurationOverride != -1 ? mDurationOverride : ANIMATION_DURATION);
  anim.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mOnAnimationFinished != null) {
        mOnAnimationFinished.run();
        mOnAnimationFinished=null;
      }
      if (mKeyguardFadingOutInProgress) {
        mKeyguardFadeoutAnimation=null;
        mKeyguardFadingOutInProgress=false;
      }
      scrim.setTag(TAG_KEY_ANIM,null);
      scrim.setTag(TAG_KEY_ANIM_TARGET,null);
    }
  }
);
  anim.start();
  if (mAnimateKeyguardFadingOut) {
    mKeyguardFadingOutInProgress=true;
    mKeyguardFadeoutAnimation=anim;
  }
  if (mSkipFirstFrame) {
    anim.setCurrentPlayTime(16);
  }
  scrim.setTag(TAG_KEY_ANIM,anim);
  scrim.setTag(TAG_KEY_ANIM_TARGET,target);
}",0.950693374422188
191740,"public void setPanelExpansion(float fraction){
  if (mFraction != fraction) {
    mFraction=fraction;
    scheduleUpdate();
    if (mPinnedHeadsUpCount != 0) {
      updateHeadsUpScrim(false);
    }
  }
}","public void setPanelExpansion(float fraction){
  if (mFraction != fraction) {
    mFraction=fraction;
    scheduleUpdate();
    if (mPinnedHeadsUpCount != 0) {
      updateHeadsUpScrim(false);
    }
    if (mKeyguardFadeoutAnimation != null) {
      mKeyguardFadeoutAnimation.cancel();
    }
  }
}",0.8023952095808383
191741,"@Override protected void onDensityOrFontScaleChanged(){
  super.onDensityOrFontScaleChanged();
  mScrimController.onDensityOrFontScaleChanged();
  mStatusBarView.onDensityOrFontScaleChanged();
  mBrightnessMirrorController.onDensityOrFontScaleChanged();
  inflateSignalClusters();
  mIconController.onDensityOrFontScaleChanged();
  inflateDismissView();
  updateClearAll();
  inflateEmptyShadeView();
  updateEmptyShadeView();
  inflateOverflowContainer();
}","@Override protected void onDensityOrFontScaleChanged(){
  super.onDensityOrFontScaleChanged();
  mScrimController.onDensityOrFontScaleChanged();
  mStatusBarView.onDensityOrFontScaleChanged();
  mBrightnessMirrorController.onDensityOrFontScaleChanged();
  inflateSignalClusters();
  mIconController.onDensityOrFontScaleChanged();
  inflateDismissView();
  updateClearAll();
  inflateEmptyShadeView();
  updateEmptyShadeView();
  inflateOverflowContainer();
  mStatusBarKeyguardViewManager.onDensityOrFontScaleChanged();
}",0.9356486210418796
191742,"@Override public void onAnimationEnd(Animator animation){
  if (mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
    mKeyguardFadingOutInProgress=false;
  }
  scrim.setTag(TAG_KEY_ANIM,null);
  scrim.setTag(TAG_KEY_ANIM_TARGET,null);
}","@Override public void onAnimationEnd(Animator animation){
  if (mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mKeyguardFadingOutInProgress=false;
  scrim.setTag(TAG_KEY_ANIM,null);
  scrim.setTag(TAG_KEY_ANIM_TARGET,null);
}",0.9892857142857144
191743,"private void startScrimAnimation(final View scrim,float target){
  float current=getCurrentScrimAlpha(scrim);
  ValueAnimator anim=ValueAnimator.ofFloat(current,target);
  anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float alpha=(float)animation.getAnimatedValue();
      setCurrentScrimAlpha(scrim,alpha);
      updateScrimColor(scrim);
    }
  }
);
  anim.setInterpolator(getInterpolator());
  anim.setStartDelay(mAnimationDelay);
  anim.setDuration(mDurationOverride != -1 ? mDurationOverride : ANIMATION_DURATION);
  anim.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mOnAnimationFinished != null) {
        mOnAnimationFinished.run();
        mOnAnimationFinished=null;
        mKeyguardFadingOutInProgress=false;
      }
      scrim.setTag(TAG_KEY_ANIM,null);
      scrim.setTag(TAG_KEY_ANIM_TARGET,null);
    }
  }
);
  anim.start();
  if (mAnimateKeyguardFadingOut) {
    mKeyguardFadingOutInProgress=true;
  }
  if (mSkipFirstFrame) {
    anim.setCurrentPlayTime(16);
  }
  scrim.setTag(TAG_KEY_ANIM,anim);
  scrim.setTag(TAG_KEY_ANIM_TARGET,target);
}","private void startScrimAnimation(final View scrim,float target){
  float current=getCurrentScrimAlpha(scrim);
  ValueAnimator anim=ValueAnimator.ofFloat(current,target);
  anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float alpha=(float)animation.getAnimatedValue();
      setCurrentScrimAlpha(scrim,alpha);
      updateScrimColor(scrim);
    }
  }
);
  anim.setInterpolator(getInterpolator());
  anim.setStartDelay(mAnimationDelay);
  anim.setDuration(mDurationOverride != -1 ? mDurationOverride : ANIMATION_DURATION);
  anim.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mOnAnimationFinished != null) {
        mOnAnimationFinished.run();
        mOnAnimationFinished=null;
      }
      mKeyguardFadingOutInProgress=false;
      scrim.setTag(TAG_KEY_ANIM,null);
      scrim.setTag(TAG_KEY_ANIM_TARGET,null);
    }
  }
);
  anim.start();
  if (mAnimateKeyguardFadingOut) {
    mKeyguardFadingOutInProgress=true;
  }
  if (mSkipFirstFrame) {
    anim.setCurrentPlayTime(16);
  }
  scrim.setTag(TAG_KEY_ANIM,anim);
  scrim.setTag(TAG_KEY_ANIM_TARGET,target);
}",0.994331983805668
191744,"private void endAnimateKeyguardFadingOut(boolean force){
  mAnimateKeyguardFadingOut=false;
  if ((force || (!isAnimating(mScrimInFront) && !isAnimating(mScrimBehind))) && mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
    mKeyguardFadingOutInProgress=false;
  }
}","private void endAnimateKeyguardFadingOut(boolean force){
  mAnimateKeyguardFadingOut=false;
  if (force || (!isAnimating(mScrimInFront) && !isAnimating(mScrimBehind))) {
    if (mOnAnimationFinished != null) {
      mOnAnimationFinished.run();
      mOnAnimationFinished=null;
    }
    mKeyguardFadingOutInProgress=false;
  }
}",0.9625
191745,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification);
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxNotifications && !childWithVisibleSummary || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification) && !entry.row.isRemoved();
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxNotifications && !childWithVisibleSummary || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9944158075601376
191746,"public void removeAllChildren(){
  List<ExpandableNotificationRow> notificationChildren=mChildrenContainer.getNotificationChildren();
  ArrayList<ExpandableNotificationRow> clonedList=new ArrayList<>(notificationChildren);
  for (int i=0; i < clonedList.size(); i++) {
    ExpandableNotificationRow row=clonedList.get(i);
    mChildrenContainer.removeNotification(row);
    mHeaderUtil.restoreNotificationHeader(row);
    row.setIsChildInGroup(false,null);
  }
  onChildrenCountChanged();
}","public void removeAllChildren(){
  List<ExpandableNotificationRow> notificationChildren=mChildrenContainer.getNotificationChildren();
  ArrayList<ExpandableNotificationRow> clonedList=new ArrayList<>(notificationChildren);
  for (int i=0; i < clonedList.size(); i++) {
    ExpandableNotificationRow row=clonedList.get(i);
    if (row.keepInParent()) {
      continue;
    }
    mChildrenContainer.removeNotification(row);
    mHeaderUtil.restoreNotificationHeader(row);
    row.setIsChildInGroup(false,null);
  }
  onChildrenCountChanged();
}",0.9496124031007752
191747,"/** 
 * @return whether a given notification is a child in a group which has a summary
 */
public boolean isChildInGroupWithSummary(StatusBarNotification sbn){
  if (!isGroupChild(sbn)) {
    return false;
  }
  NotificationGroup group=mGroupMap.get(getGroupKey(sbn));
  if (group == null || group.summary == null || group.suppressed) {
    return false;
  }
  return true;
}","/** 
 * @return whether a given notification is a child in a group which has a summary
 */
public boolean isChildInGroupWithSummary(StatusBarNotification sbn){
  if (!isGroupChild(sbn)) {
    return false;
  }
  NotificationGroup group=mGroupMap.get(getGroupKey(sbn));
  if (group == null || group.summary == null || group.suppressed) {
    return false;
  }
  if (group.children.isEmpty()) {
    return false;
  }
  return true;
}",0.9057071960297768
191748,"private void removeNotificationChildren(){
  ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>();
  for (int i=0; i < mStackScroller.getChildCount(); i++) {
    View view=mStackScroller.getChildAt(i);
    if (!(view instanceof ExpandableNotificationRow)) {
      continue;
    }
    ExpandableNotificationRow parent=(ExpandableNotificationRow)view;
    List<ExpandableNotificationRow> children=parent.getNotificationChildren();
    List<ExpandableNotificationRow> orderedChildren=mTmpChildOrderMap.get(parent);
    if (children != null) {
      toRemove.clear();
      for (      ExpandableNotificationRow childRow : children) {
        if (orderedChildren == null || !orderedChildren.contains(childRow)) {
          toRemove.add(childRow);
        }
      }
      for (      ExpandableNotificationRow remove : toRemove) {
        parent.removeChildNotification(remove);
        if (mNotificationData.get(remove.getStatusBarNotification().getKey()) == null) {
          mStackScroller.notifyGroupChildRemoved(remove);
        }
      }
    }
  }
}","private void removeNotificationChildren(){
  ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>();
  for (int i=0; i < mStackScroller.getChildCount(); i++) {
    View view=mStackScroller.getChildAt(i);
    if (!(view instanceof ExpandableNotificationRow)) {
      continue;
    }
    ExpandableNotificationRow parent=(ExpandableNotificationRow)view;
    List<ExpandableNotificationRow> children=parent.getNotificationChildren();
    List<ExpandableNotificationRow> orderedChildren=mTmpChildOrderMap.get(parent);
    if (children != null) {
      toRemove.clear();
      for (      ExpandableNotificationRow childRow : children) {
        if ((orderedChildren == null || !orderedChildren.contains(childRow)) && !childRow.keepInParent()) {
          toRemove.add(childRow);
        }
      }
      for (      ExpandableNotificationRow remove : toRemove) {
        parent.removeChildNotification(remove);
        if (mNotificationData.get(remove.getStatusBarNotification().getKey()) == null) {
          mStackScroller.notifyGroupChildRemoved(remove);
        }
      }
    }
  }
}",0.9860335195530726
191749,"@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}","@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}",0.991522002422285
191750,"private void performDismiss(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (mGroupManager.isOnlyChildInSuppressedGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=mGroupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary);
      }
    }
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}","private void performDismiss(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (mGroupManager.isOnlyChildInSuppressedGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=mGroupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary);
      }
    }
    row.setDismissed(true);
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}",0.9782270606531882
191751,"/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
          cancelNotificationLocked(r,sendDelete,reason);
          updateLightsLocked();
        }
      }
    }
  }
);
}","/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelNotificationLocked(r,sendDelete,reason);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
          updateLightsLocked();
        }
      }
    }
  }
);
}",0.9393732970027248
191752,"/** 
 * Constructs a Bundle containing a copy of the mappings from the given Bundle.
 * @param b a Bundle to be copied.
 */
BaseBundle(BaseBundle b){
  if (b.mParcelledData != null) {
    if (b.isEmptyParcel()) {
      mParcelledData=NoImagePreloadHolder.EMPTY_PARCEL;
    }
 else {
      mParcelledData=Parcel.obtain();
      mParcelledData.appendFrom(b.mParcelledData,0,b.mParcelledData.dataSize());
      mParcelledData.setDataPosition(0);
    }
  }
 else {
    mParcelledData=null;
  }
  if (b.mMap != null) {
    mMap=new ArrayMap<String,Object>(b.mMap);
  }
 else {
    mMap=null;
  }
  mClassLoader=b.mClassLoader;
}","/** 
 * Constructs a Bundle containing a copy of the mappings from the given Bundle.
 * @param b a Bundle to be copied.
 */
BaseBundle(BaseBundle b){
  if (b.mParcelledData != null) {
    if (b.isEmptyParcel()) {
      mParcelledData=NoImagePreloadHolder.EMPTY_PARCEL;
    }
 else {
      mParcelledData=Parcel.obtain();
      mParcelledData.appendFrom(b.mParcelledData,0,b.mParcelledData.dataSize());
      mParcelledData.setDataPosition(0);
    }
  }
 else {
    mParcelledData=null;
  }
  if (b.mMap != null) {
    mMap=new ArrayMap<>(b.mMap);
  }
 else {
    mMap=null;
  }
  mClassLoader=b.mClassLoader;
}",0.989456609894566
191753,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
void writeToParcelInner(Parcel parcel,int flags){
  if (mParcelledData != null) {
    if (isEmptyParcel()) {
      parcel.writeInt(0);
    }
 else {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
  }
 else {
    if (mMap == null || mMap.size() <= 0) {
      parcel.writeInt(0);
      return;
    }
    int lengthPos=parcel.dataPosition();
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos=parcel.dataPosition();
    parcel.writeArrayMapInternal(mMap);
    int endPos=parcel.dataPosition();
    parcel.setDataPosition(lengthPos);
    int length=endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
void writeToParcelInner(Parcel parcel,int flags){
  final Parcel parcelledData;
synchronized (this) {
    parcelledData=mParcelledData;
  }
  if (parcelledData != null) {
    if (isEmptyParcel()) {
      parcel.writeInt(0);
    }
 else {
      int length=parcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(parcelledData,0,length);
    }
  }
 else {
    if (mMap == null || mMap.size() <= 0) {
      parcel.writeInt(0);
      return;
    }
    int lengthPos=parcel.dataPosition();
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos=parcel.dataPosition();
    parcel.writeArrayMapInternal(mMap);
    int endPos=parcel.dataPosition();
    parcel.setDataPosition(lengthPos);
    int length=endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
  }
}",0.9494241362043064
191754,"/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
    return;
  }
  if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
    Slog.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"",new Throwable());
  }
  if (isEmptyParcel()) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
    if (mMap == null) {
      mMap=new ArrayMap<String,Object>(1);
    }
 else {
      mMap.erase();
    }
    mParcelledData=null;
    return;
  }
  int N=mParcelledData.readInt();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ N+ ""String_Node_Str"");
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  try {
    mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  }
 catch (  BadParcelableException e) {
    if (sShouldDefuse) {
      Log.w(TAG,""String_Node_Str"",e);
      mMap.erase();
    }
 else {
      throw e;
    }
  }
 finally {
    mParcelledData.recycle();
    mParcelledData=null;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ mMap);
}","/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
synchronized (this) {
    final Parcel parcelledData=mParcelledData;
    if (parcelledData == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
      return;
    }
    if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
      Slog.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"",new Throwable());
    }
    if (isEmptyParcel()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
      if (mMap == null) {
        mMap=new ArrayMap<>(1);
      }
 else {
        mMap.erase();
      }
      mParcelledData=null;
      return;
    }
    int N=parcelledData.readInt();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ N+ ""String_Node_Str"");
    if (N < 0) {
      return;
    }
    ArrayMap<String,Object> map=mMap;
    if (map == null) {
      map=new ArrayMap<>(N);
    }
 else {
      map.erase();
      map.ensureCapacity(N);
    }
    try {
      parcelledData.readArrayMapInternal(map,N,mClassLoader);
    }
 catch (    BadParcelableException e) {
      if (sShouldDefuse) {
        Log.w(TAG,""String_Node_Str"",e);
        map.erase();
      }
 else {
        throw e;
      }
    }
 finally {
      mMap=map;
      parcelledData.recycle();
      mParcelledData=null;
    }
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ mMap);
  }
}",0.7902076231794236
191755,"@Override public void onAnimationEnd(Animator animation){
  if (mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
    mKeyguardFadingOutInProgress=false;
  }
  scrim.setTag(TAG_KEY_ANIM,null);
  scrim.setTag(TAG_KEY_ANIM_TARGET,null);
}","@Override public void onAnimationEnd(Animator animation){
  if (mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
  }
  mKeyguardFadingOutInProgress=false;
  scrim.setTag(TAG_KEY_ANIM,null);
  scrim.setTag(TAG_KEY_ANIM_TARGET,null);
}",0.9892857142857144
191756,"private void startScrimAnimation(final View scrim,float target){
  float current=getCurrentScrimAlpha(scrim);
  ValueAnimator anim=ValueAnimator.ofFloat(current,target);
  anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float alpha=(float)animation.getAnimatedValue();
      setCurrentScrimAlpha(scrim,alpha);
      updateScrimColor(scrim);
    }
  }
);
  anim.setInterpolator(getInterpolator());
  anim.setStartDelay(mAnimationDelay);
  anim.setDuration(mDurationOverride != -1 ? mDurationOverride : ANIMATION_DURATION);
  anim.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mOnAnimationFinished != null) {
        mOnAnimationFinished.run();
        mOnAnimationFinished=null;
        mKeyguardFadingOutInProgress=false;
      }
      scrim.setTag(TAG_KEY_ANIM,null);
      scrim.setTag(TAG_KEY_ANIM_TARGET,null);
    }
  }
);
  anim.start();
  if (mAnimateKeyguardFadingOut) {
    mKeyguardFadingOutInProgress=true;
  }
  if (mSkipFirstFrame) {
    anim.setCurrentPlayTime(16);
  }
  scrim.setTag(TAG_KEY_ANIM,anim);
  scrim.setTag(TAG_KEY_ANIM_TARGET,target);
}","private void startScrimAnimation(final View scrim,float target){
  float current=getCurrentScrimAlpha(scrim);
  ValueAnimator anim=ValueAnimator.ofFloat(current,target);
  anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float alpha=(float)animation.getAnimatedValue();
      setCurrentScrimAlpha(scrim,alpha);
      updateScrimColor(scrim);
    }
  }
);
  anim.setInterpolator(getInterpolator());
  anim.setStartDelay(mAnimationDelay);
  anim.setDuration(mDurationOverride != -1 ? mDurationOverride : ANIMATION_DURATION);
  anim.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mOnAnimationFinished != null) {
        mOnAnimationFinished.run();
        mOnAnimationFinished=null;
      }
      mKeyguardFadingOutInProgress=false;
      scrim.setTag(TAG_KEY_ANIM,null);
      scrim.setTag(TAG_KEY_ANIM_TARGET,null);
    }
  }
);
  anim.start();
  if (mAnimateKeyguardFadingOut) {
    mKeyguardFadingOutInProgress=true;
  }
  if (mSkipFirstFrame) {
    anim.setCurrentPlayTime(16);
  }
  scrim.setTag(TAG_KEY_ANIM,anim);
  scrim.setTag(TAG_KEY_ANIM_TARGET,target);
}",0.994331983805668
191757,"private void endAnimateKeyguardFadingOut(boolean force){
  mAnimateKeyguardFadingOut=false;
  if ((force || (!isAnimating(mScrimInFront) && !isAnimating(mScrimBehind))) && mOnAnimationFinished != null) {
    mOnAnimationFinished.run();
    mOnAnimationFinished=null;
    mKeyguardFadingOutInProgress=false;
  }
}","private void endAnimateKeyguardFadingOut(boolean force){
  mAnimateKeyguardFadingOut=false;
  if (force || (!isAnimating(mScrimInFront) && !isAnimating(mScrimBehind))) {
    if (mOnAnimationFinished != null) {
      mOnAnimationFinished.run();
      mOnAnimationFinished=null;
    }
    mKeyguardFadingOutInProgress=false;
  }
}",0.9625
191758,"/** 
 * Set this notification to be pinned to the top if   {@link #isHeadsUp()} is true. By doing thisthe notification will be rendered on top of the screen.
 * @param pinned whether it is pinned
 */
public void setPinned(boolean pinned){
  mIsPinned=pinned;
  if (pinned) {
    setIconAnimationRunning(true);
    mExpandedWhenPinned=false;
  }
 else   if (mExpandedWhenPinned) {
    setUserExpanded(true);
  }
  setChronometerRunning(mLastChronometerRunning);
}","/** 
 * Set this notification to be pinned to the top if   {@link #isHeadsUp()} is true. By doing thisthe notification will be rendered on top of the screen.
 * @param pinned whether it is pinned
 */
public void setPinned(boolean pinned){
  int intrinsicHeight=getIntrinsicHeight();
  mIsPinned=pinned;
  if (intrinsicHeight != getIntrinsicHeight()) {
    notifyHeightChanged(false);
  }
  if (pinned) {
    setIconAnimationRunning(true);
    mExpandedWhenPinned=false;
  }
 else   if (mExpandedWhenPinned) {
    setUserExpanded(true);
  }
  setChronometerRunning(mLastChronometerRunning);
}",0.8755935422602089
191759,"@Override public boolean onInterceptTouchEvent(MotionEvent event){
  if (!mTouchingHeadsUpView && event.getActionMasked() != MotionEvent.ACTION_DOWN) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float x=event.getX(pointerIndex);
  final float y=event.getY(pointerIndex);
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mInitialTouchY=y;
  mInitialTouchX=x;
setTrackingHeadsUp(false);
ExpandableView child=mStackScroller.getChildAtRawPosition(x,y);
mTouchingHeadsUpView=false;
if (child instanceof ExpandableNotificationRow) {
mPickedChild=(ExpandableNotificationRow)child;
mTouchingHeadsUpView=!mStackScroller.isExpanded() && mPickedChild.isHeadsUp() && mPickedChild.isPinned();
}
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
mTrackingPointer=event.getPointerId(newIndex);
mInitialTouchX=event.getX(newIndex);
mInitialTouchY=event.getY(newIndex);
}
break;
case MotionEvent.ACTION_MOVE:
final float h=y - mInitialTouchY;
if (mTouchingHeadsUpView && Math.abs(h) > mTouchSlop && Math.abs(h) > Math.abs(x - mInitialTouchX)) {
setTrackingHeadsUp(true);
mCollapseSnoozes=h < 0;
mInitialTouchX=x;
mInitialTouchY=y;
int expandedHeight=mPickedChild.getActualHeight();
mHeadsUpManager.unpinAll();
mPanel.setPanelScrimMinFraction((float)expandedHeight / mPanel.getMaxPanelHeight());
mPanel.startExpandMotion(x,y,true,expandedHeight);
mPanel.clearNotificationEffects();
return true;
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mPickedChild != null && mTouchingHeadsUpView) {
if (mHeadsUpManager.shouldSwallowClick(mPickedChild.getStatusBarNotification().getKey())) {
endMotion();
return true;
}
}
endMotion();
break;
}
return false;
}","@Override public boolean onInterceptTouchEvent(MotionEvent event){
  if (!mTouchingHeadsUpView && event.getActionMasked() != MotionEvent.ACTION_DOWN) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float x=event.getX(pointerIndex);
  final float y=event.getY(pointerIndex);
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mInitialTouchY=y;
  mInitialTouchX=x;
setTrackingHeadsUp(false);
ExpandableView child=mStackScroller.getChildAtRawPosition(x,y);
mTouchingHeadsUpView=false;
if (child instanceof ExpandableNotificationRow) {
mPickedChild=(ExpandableNotificationRow)child;
mTouchingHeadsUpView=!mStackScroller.isExpanded() && mPickedChild.isHeadsUp() && mPickedChild.isPinned();
}
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
mTrackingPointer=event.getPointerId(newIndex);
mInitialTouchX=event.getX(newIndex);
mInitialTouchY=event.getY(newIndex);
}
break;
case MotionEvent.ACTION_MOVE:
final float h=y - mInitialTouchY;
if (mTouchingHeadsUpView && Math.abs(h) > mTouchSlop && Math.abs(h) > Math.abs(x - mInitialTouchX)) {
setTrackingHeadsUp(true);
mCollapseSnoozes=h < 0;
mInitialTouchX=x;
mInitialTouchY=y;
int expandedHeight=mPickedChild.getActualHeight();
mPanel.setPanelScrimMinFraction((float)expandedHeight / mPanel.getMaxPanelHeight());
mPanel.startExpandMotion(x,y,true,expandedHeight);
mHeadsUpManager.unpinAll();
mPanel.clearNotificationEffects();
return true;
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mPickedChild != null && mTouchingHeadsUpView) {
if (mHeadsUpManager.shouldSwallowClick(mPickedChild.getStatusBarNotification().getKey())) {
endMotion();
return true;
}
}
endMotion();
break;
}
return false;
}",0.9859084046300955
191760,"protected void startExpandMotion(float newX,float newY,boolean startTracking,float expandedHeight){
  mInitialOffsetOnTouch=expandedHeight;
  mInitialTouchY=newY;
  mInitialTouchX=newX;
  if (startTracking) {
    mTouchSlopExceeded=true;
    onTrackingStarted();
  }
}","protected void startExpandMotion(float newX,float newY,boolean startTracking,float expandedHeight){
  mInitialOffsetOnTouch=expandedHeight;
  mInitialTouchY=newY;
  mInitialTouchX=newX;
  if (startTracking) {
    mTouchSlopExceeded=true;
    setExpandedHeight(mInitialOffsetOnTouch);
    onTrackingStarted();
  }
}",0.9209621993127148
191761,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification);
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxNotifications && !childWithVisibleSummary || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification) && !entry.row.isRemoved();
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxNotifications && !childWithVisibleSummary || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9944158075601376
191762,"public void removeAllChildren(){
  List<ExpandableNotificationRow> notificationChildren=mChildrenContainer.getNotificationChildren();
  ArrayList<ExpandableNotificationRow> clonedList=new ArrayList<>(notificationChildren);
  for (int i=0; i < clonedList.size(); i++) {
    ExpandableNotificationRow row=clonedList.get(i);
    mChildrenContainer.removeNotification(row);
    mHeaderUtil.restoreNotificationHeader(row);
    row.setIsChildInGroup(false,null);
  }
  onChildrenCountChanged();
}","public void removeAllChildren(){
  List<ExpandableNotificationRow> notificationChildren=mChildrenContainer.getNotificationChildren();
  ArrayList<ExpandableNotificationRow> clonedList=new ArrayList<>(notificationChildren);
  for (int i=0; i < clonedList.size(); i++) {
    ExpandableNotificationRow row=clonedList.get(i);
    if (row.keepInParent()) {
      continue;
    }
    mChildrenContainer.removeNotification(row);
    mHeaderUtil.restoreNotificationHeader(row);
    row.setIsChildInGroup(false,null);
  }
  onChildrenCountChanged();
}",0.9496124031007752
191763,"/** 
 * @return whether a given notification is a child in a group which has a summary
 */
public boolean isChildInGroupWithSummary(StatusBarNotification sbn){
  if (!isGroupChild(sbn)) {
    return false;
  }
  NotificationGroup group=mGroupMap.get(getGroupKey(sbn));
  if (group == null || group.summary == null || group.suppressed) {
    return false;
  }
  return true;
}","/** 
 * @return whether a given notification is a child in a group which has a summary
 */
public boolean isChildInGroupWithSummary(StatusBarNotification sbn){
  if (!isGroupChild(sbn)) {
    return false;
  }
  NotificationGroup group=mGroupMap.get(getGroupKey(sbn));
  if (group == null || group.summary == null || group.suppressed) {
    return false;
  }
  if (group.children.isEmpty()) {
    return false;
  }
  return true;
}",0.9057071960297768
191764,"private void removeNotificationChildren(){
  ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>();
  for (int i=0; i < mStackScroller.getChildCount(); i++) {
    View view=mStackScroller.getChildAt(i);
    if (!(view instanceof ExpandableNotificationRow)) {
      continue;
    }
    ExpandableNotificationRow parent=(ExpandableNotificationRow)view;
    List<ExpandableNotificationRow> children=parent.getNotificationChildren();
    List<ExpandableNotificationRow> orderedChildren=mTmpChildOrderMap.get(parent);
    if (children != null) {
      toRemove.clear();
      for (      ExpandableNotificationRow childRow : children) {
        if (orderedChildren == null || !orderedChildren.contains(childRow)) {
          toRemove.add(childRow);
        }
      }
      for (      ExpandableNotificationRow remove : toRemove) {
        parent.removeChildNotification(remove);
        if (mNotificationData.get(remove.getStatusBarNotification().getKey()) == null) {
          mStackScroller.notifyGroupChildRemoved(remove);
        }
      }
    }
  }
}","private void removeNotificationChildren(){
  ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>();
  for (int i=0; i < mStackScroller.getChildCount(); i++) {
    View view=mStackScroller.getChildAt(i);
    if (!(view instanceof ExpandableNotificationRow)) {
      continue;
    }
    ExpandableNotificationRow parent=(ExpandableNotificationRow)view;
    List<ExpandableNotificationRow> children=parent.getNotificationChildren();
    List<ExpandableNotificationRow> orderedChildren=mTmpChildOrderMap.get(parent);
    if (children != null) {
      toRemove.clear();
      for (      ExpandableNotificationRow childRow : children) {
        if ((orderedChildren == null || !orderedChildren.contains(childRow)) && !childRow.keepInParent()) {
          toRemove.add(childRow);
        }
      }
      for (      ExpandableNotificationRow remove : toRemove) {
        parent.removeChildNotification(remove);
        if (mNotificationData.get(remove.getStatusBarNotification().getKey()) == null) {
          mStackScroller.notifyGroupChildRemoved(remove);
        }
      }
    }
  }
}",0.9860335195530726
191765,"@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}","@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    boolean ignoreEarliestRemovalTime=mRemoteInputController.isSpinning(key) && !FORCE_REMOTE_INPUT_HISTORY;
    deferRemoval=!mHeadsUpManager.removeNotification(key,ignoreEarliestRemovalTime);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}",0.991522002422285
191766,"private void performDismiss(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (mGroupManager.isOnlyChildInSuppressedGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=mGroupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary);
      }
    }
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}","private void performDismiss(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (mGroupManager.isOnlyChildInSuppressedGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=mGroupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary);
      }
    }
    row.setDismissed(true);
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}",0.9782270606531882
191767,"/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
          cancelNotificationLocked(r,sendDelete,reason);
          updateLightsLocked();
        }
      }
    }
  }
);
}","/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelNotificationLocked(r,sendDelete,reason);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
          updateLightsLocked();
        }
      }
    }
  }
);
}",0.9393732970027248
191768,"/** 
 * Constructs a Bundle containing a copy of the mappings from the given Bundle.
 * @param b a Bundle to be copied.
 */
BaseBundle(BaseBundle b){
  if (b.mParcelledData != null) {
    if (b.isEmptyParcel()) {
      mParcelledData=NoImagePreloadHolder.EMPTY_PARCEL;
    }
 else {
      mParcelledData=Parcel.obtain();
      mParcelledData.appendFrom(b.mParcelledData,0,b.mParcelledData.dataSize());
      mParcelledData.setDataPosition(0);
    }
  }
 else {
    mParcelledData=null;
  }
  if (b.mMap != null) {
    mMap=new ArrayMap<String,Object>(b.mMap);
  }
 else {
    mMap=null;
  }
  mClassLoader=b.mClassLoader;
}","/** 
 * Constructs a Bundle containing a copy of the mappings from the given Bundle.
 * @param b a Bundle to be copied.
 */
BaseBundle(BaseBundle b){
  if (b.mParcelledData != null) {
    if (b.isEmptyParcel()) {
      mParcelledData=NoImagePreloadHolder.EMPTY_PARCEL;
    }
 else {
      mParcelledData=Parcel.obtain();
      mParcelledData.appendFrom(b.mParcelledData,0,b.mParcelledData.dataSize());
      mParcelledData.setDataPosition(0);
    }
  }
 else {
    mParcelledData=null;
  }
  if (b.mMap != null) {
    mMap=new ArrayMap<>(b.mMap);
  }
 else {
    mMap=null;
  }
  mClassLoader=b.mClassLoader;
}",0.989456609894566
191769,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
void writeToParcelInner(Parcel parcel,int flags){
  if (mParcelledData != null) {
    if (isEmptyParcel()) {
      parcel.writeInt(0);
    }
 else {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
  }
 else {
    if (mMap == null || mMap.size() <= 0) {
      parcel.writeInt(0);
      return;
    }
    int lengthPos=parcel.dataPosition();
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos=parcel.dataPosition();
    parcel.writeArrayMapInternal(mMap);
    int endPos=parcel.dataPosition();
    parcel.setDataPosition(lengthPos);
    int length=endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
void writeToParcelInner(Parcel parcel,int flags){
  final Parcel parcelledData;
synchronized (this) {
    parcelledData=mParcelledData;
  }
  if (parcelledData != null) {
    if (isEmptyParcel()) {
      parcel.writeInt(0);
    }
 else {
      int length=parcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(parcelledData,0,length);
    }
  }
 else {
    if (mMap == null || mMap.size() <= 0) {
      parcel.writeInt(0);
      return;
    }
    int lengthPos=parcel.dataPosition();
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos=parcel.dataPosition();
    parcel.writeArrayMapInternal(mMap);
    int endPos=parcel.dataPosition();
    parcel.setDataPosition(lengthPos);
    int length=endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
  }
}",0.9494241362043064
191770,"/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
    return;
  }
  if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
    Slog.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"",new Throwable());
  }
  if (isEmptyParcel()) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
    if (mMap == null) {
      mMap=new ArrayMap<String,Object>(1);
    }
 else {
      mMap.erase();
    }
    mParcelledData=null;
    return;
  }
  int N=mParcelledData.readInt();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ N+ ""String_Node_Str"");
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  try {
    mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  }
 catch (  BadParcelableException e) {
    if (sShouldDefuse) {
      Log.w(TAG,""String_Node_Str"",e);
      mMap.erase();
    }
 else {
      throw e;
    }
  }
 finally {
    mParcelledData.recycle();
    mParcelledData=null;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ mMap);
}","/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
synchronized (this) {
    final Parcel parcelledData=mParcelledData;
    if (parcelledData == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
      return;
    }
    if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
      Slog.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"",new Throwable());
    }
    if (isEmptyParcel()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
      if (mMap == null) {
        mMap=new ArrayMap<>(1);
      }
 else {
        mMap.erase();
      }
      mParcelledData=null;
      return;
    }
    int N=parcelledData.readInt();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ N+ ""String_Node_Str"");
    if (N < 0) {
      return;
    }
    ArrayMap<String,Object> map=mMap;
    if (map == null) {
      map=new ArrayMap<>(N);
    }
 else {
      map.erase();
      map.ensureCapacity(N);
    }
    try {
      parcelledData.readArrayMapInternal(map,N,mClassLoader);
    }
 catch (    BadParcelableException e) {
      if (sShouldDefuse) {
        Log.w(TAG,""String_Node_Str"",e);
        map.erase();
      }
 else {
        throw e;
      }
    }
 finally {
      mMap=map;
      parcelledData.recycle();
      mParcelledData=null;
    }
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ mMap);
  }
}",0.7902076231794236
191771,"/** 
 * If non-null, returns only shortcuts associated with the activity.
 */
public void setActivity(@Nullable ComponentName activity){
  mActivity=activity;
}","/** 
 * If non-null, returns only shortcuts associated with the activity, which are  {@link ShortcutInfo}s that have null   {@link ShortcutInfo#getActivityComponent()}, or  {@link ShortcutInfo#getActivityComponent()} equals to {@code activity}.
 */
public void setActivity(@Nullable ComponentName activity){
  mActivity=activity;
}",0.6517311608961304
191772,"private void notifyListeners(@NonNull String packageName,@UserIdInt int userId){
  if (!mUserManager.isUserRunning(userId)) {
    return;
  }
  postToHandler(() -> {
    final ArrayList<ShortcutChangeListener> copy;
synchronized (mLock) {
      copy=new ArrayList<>(mListeners);
    }
    for (int i=copy.size() - 1; i >= 0; i--) {
      copy.get(i).onShortcutChanged(packageName,userId);
    }
  }
);
}","private void notifyListeners(@NonNull String packageName,@UserIdInt int userId){
  final long token=injectClearCallingIdentity();
  try {
    if (!mUserManager.isUserRunning(userId)) {
      return;
    }
  }
  finally {
    injectRestoreCallingIdentity(token);
  }
  postToHandler(() -> {
    final ArrayList<ShortcutChangeListener> copy;
synchronized (mLock) {
      copy=new ArrayList<>(mListeners);
    }
    for (int i=copy.size() - 1; i >= 0; i--) {
      copy.get(i).onShortcutChanged(packageName,userId);
    }
  }
);
}",0.853763440860215
191773,"private void getShortcutsInnerLocked(int launcherUserId,@NonNull String callingPackage,@Nullable String packageName,@Nullable List<String> shortcutIds,long changedSince,@Nullable ComponentName componentName,int queryFlags,int userId,ArrayList<ShortcutInfo> ret,int cloneFlag){
  final ArraySet<String> ids=shortcutIds == null ? null : new ArraySet<>(shortcutIds);
  getPackageShortcutsLocked(packageName,userId).findAll(ShortcutService.this,ret,(  ShortcutInfo si) -> {
    if (si.getLastChangedTimestamp() < changedSince) {
      return false;
    }
    if (ids != null && !ids.contains(si.getId())) {
      return false;
    }
    if (componentName != null && !componentName.equals(si.getActivityComponent())) {
      return false;
    }
    final boolean matchDynamic=((queryFlags & ShortcutQuery.FLAG_GET_DYNAMIC) != 0) && si.isDynamic();
    final boolean matchPinned=((queryFlags & ShortcutQuery.FLAG_GET_PINNED) != 0) && si.isPinned();
    return matchDynamic || matchPinned;
  }
,cloneFlag,callingPackage,launcherUserId);
}","private void getShortcutsInnerLocked(int launcherUserId,@NonNull String callingPackage,@Nullable String packageName,@Nullable List<String> shortcutIds,long changedSince,@Nullable ComponentName componentName,int queryFlags,int userId,ArrayList<ShortcutInfo> ret,int cloneFlag){
  final ArraySet<String> ids=shortcutIds == null ? null : new ArraySet<>(shortcutIds);
  getPackageShortcutsLocked(packageName,userId).findAll(ShortcutService.this,ret,(  ShortcutInfo si) -> {
    if (si.getLastChangedTimestamp() < changedSince) {
      return false;
    }
    if (ids != null && !ids.contains(si.getId())) {
      return false;
    }
    if (componentName != null) {
      if (si.getActivityComponent() != null && !si.getActivityComponent().equals(componentName)) {
        return false;
      }
    }
    final boolean matchDynamic=((queryFlags & ShortcutQuery.FLAG_GET_DYNAMIC) != 0) && si.isDynamic();
    final boolean matchPinned=((queryFlags & ShortcutQuery.FLAG_GET_PINNED) != 0) && si.isPinned();
    return matchDynamic || matchPinned;
  }
,cloneFlag,callingPackage,launcherUserId);
}",0.9523360075507314
191774,"@Override protected void setUp() throws Exception {
  super.setUp();
  mServiceContext=spy(new ServiceContext());
  mClientContext=new ClientContext();
  mMockPackageManager=mock(PackageManager.class);
  mMockPackageManagerInternal=mock(PackageManagerInternal.class);
  mMockUserManager=mock(UserManager.class);
  mInjectedCurrentTimeLillis=START_TIME;
  mInjectedPackages=new HashMap<>();
  ;
  addPackage(CALLING_PACKAGE_1,CALLING_UID_1,1);
  addPackage(CALLING_PACKAGE_2,CALLING_UID_2,2);
  addPackage(CALLING_PACKAGE_3,CALLING_UID_3,3);
  addPackage(CALLING_PACKAGE_4,CALLING_UID_4,10);
  addPackage(LAUNCHER_1,LAUNCHER_UID_1,4);
  addPackage(LAUNCHER_2,LAUNCHER_UID_2,5);
  addPackage(LAUNCHER_3,LAUNCHER_UID_3,6);
  addPackage(LAUNCHER_4,LAUNCHER_UID_4,10);
  updatePackageInfo(CALLING_PACKAGE_3,pi -> pi.applicationInfo.flags&=~ApplicationInfo.FLAG_ALLOW_BACKUP);
  updatePackageInfo(LAUNCHER_3,pi -> pi.applicationInfo.flags&=~ApplicationInfo.FLAG_ALLOW_BACKUP);
  mUninstalledPackages=new HashSet<>();
  mInjectedFilePathRoot=new File(getTestContext().getCacheDir(),""String_Node_Str"");
  deleteAllSavedFiles();
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_0;
  }
).when(mMockUserManager).getUserInfo(eq(USER_0));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_10;
  }
).when(mMockUserManager).getUserInfo(eq(USER_10));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_11;
  }
).when(mMockUserManager).getUserInfo(eq(USER_11));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_P0;
  }
).when(mMockUserManager).getUserInfo(eq(USER_P0));
  when(mMockUserManager.isUserRunning(eq(USER_0))).thenReturn(true);
  initService();
  setCaller(CALLING_PACKAGE_1);
  mInternal.onSystemLocaleChangedNoLock();
}","@Override protected void setUp() throws Exception {
  super.setUp();
  mServiceContext=spy(new ServiceContext());
  mClientContext=new ClientContext();
  mMockPackageManager=mock(PackageManager.class);
  mMockPackageManagerInternal=mock(PackageManagerInternal.class);
  mMockUserManager=mock(UserManager.class);
  mInjectedCurrentTimeLillis=START_TIME;
  mInjectedPackages=new HashMap<>();
  ;
  addPackage(CALLING_PACKAGE_1,CALLING_UID_1,1);
  addPackage(CALLING_PACKAGE_2,CALLING_UID_2,2);
  addPackage(CALLING_PACKAGE_3,CALLING_UID_3,3);
  addPackage(CALLING_PACKAGE_4,CALLING_UID_4,10);
  addPackage(LAUNCHER_1,LAUNCHER_UID_1,4);
  addPackage(LAUNCHER_2,LAUNCHER_UID_2,5);
  addPackage(LAUNCHER_3,LAUNCHER_UID_3,6);
  addPackage(LAUNCHER_4,LAUNCHER_UID_4,10);
  updatePackageInfo(CALLING_PACKAGE_3,pi -> pi.applicationInfo.flags&=~ApplicationInfo.FLAG_ALLOW_BACKUP);
  updatePackageInfo(LAUNCHER_3,pi -> pi.applicationInfo.flags&=~ApplicationInfo.FLAG_ALLOW_BACKUP);
  mUninstalledPackages=new HashSet<>();
  mInjectedFilePathRoot=new File(getTestContext().getCacheDir(),""String_Node_Str"");
  deleteAllSavedFiles();
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_0;
  }
).when(mMockUserManager).getUserInfo(eq(USER_0));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_10;
  }
).when(mMockUserManager).getUserInfo(eq(USER_10));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_11;
  }
).when(mMockUserManager).getUserInfo(eq(USER_11));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_P0;
  }
).when(mMockUserManager).getUserInfo(eq(USER_P0));
  when(mMockUserManager.isUserRunning(eq(USER_0))).thenAnswer(new AnswerIsUserRunning(true));
  initService();
  setCaller(CALLING_PACKAGE_1);
  mInternal.onSystemLocaleChangedNoLock();
}",0.9901269393511988
191775,"public void testLauncherCallback_crossProfile() throws Throwable {
  prepareCrossProfileDataSet();
  final Handler h=new Handler(Looper.getMainLooper());
  final LauncherApps.Callback c0_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_2=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_3=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_4=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback cP0_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c10_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c10_2=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c11_1=mock(LauncherApps.Callback.class);
  final List<LauncherApps.Callback> all=list(c0_1,c0_2,c0_3,c0_4,cP0_1,c10_1,c11_1);
  setDefaultLauncherChecker((pkg,userId) -> {
switch (userId) {
case USER_0:
      return LAUNCHER_2.equals(pkg);
case USER_P0:
    return LAUNCHER_1.equals(pkg);
case USER_10:
  return LAUNCHER_1.equals(pkg);
case USER_11:
return LAUNCHER_1.equals(pkg);
default :
return false;
}
}
);
runWithCaller(LAUNCHER_1,USER_0,() -> mLauncherApps.registerCallback(c0_1,h));
runWithCaller(LAUNCHER_2,USER_0,() -> mLauncherApps.registerCallback(c0_2,h));
runWithCaller(LAUNCHER_3,USER_0,() -> mLauncherApps.registerCallback(c0_3,h));
runWithCaller(LAUNCHER_4,USER_0,() -> mLauncherApps.registerCallback(c0_4,h));
runWithCaller(LAUNCHER_1,USER_P0,() -> mLauncherApps.registerCallback(cP0_1,h));
runWithCaller(LAUNCHER_1,USER_10,() -> mLauncherApps.registerCallback(c10_1,h));
runWithCaller(LAUNCHER_2,USER_10,() -> mLauncherApps.registerCallback(c10_2,h));
runWithCaller(LAUNCHER_1,USER_11,() -> mLauncherApps.registerCallback(c11_1,h));
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
resetAll(all);
runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_0,CALLING_PACKAGE_3,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_0,CALLING_PACKAGE_3,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_P0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_2);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(cP0_1);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
when(mMockUserManager.isUserRunning(anyInt())).thenReturn(false);
when(mMockUserManager.isUserRunning(eq(USER_P0))).thenReturn(true);
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_P0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_P0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_P0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
when(mMockUserManager.isUserRunning(anyInt())).thenReturn(false);
when(mMockUserManager.isUserRunning(eq(USER_10))).thenReturn(true);
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_10,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_2);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(cP0_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c10_1,HANDLE_USER_10,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","public void testLauncherCallback_crossProfile() throws Throwable {
  prepareCrossProfileDataSet();
  final Handler h=new Handler(Looper.getMainLooper());
  final LauncherApps.Callback c0_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_2=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_3=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_4=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback cP0_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c10_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c10_2=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c11_1=mock(LauncherApps.Callback.class);
  final List<LauncherApps.Callback> all=list(c0_1,c0_2,c0_3,c0_4,cP0_1,c10_1,c11_1);
  setDefaultLauncherChecker((pkg,userId) -> {
switch (userId) {
case USER_0:
      return LAUNCHER_2.equals(pkg);
case USER_P0:
    return LAUNCHER_1.equals(pkg);
case USER_10:
  return LAUNCHER_1.equals(pkg);
case USER_11:
return LAUNCHER_1.equals(pkg);
default :
return false;
}
}
);
runWithCaller(LAUNCHER_1,USER_0,() -> mLauncherApps.registerCallback(c0_1,h));
runWithCaller(LAUNCHER_2,USER_0,() -> mLauncherApps.registerCallback(c0_2,h));
runWithCaller(LAUNCHER_3,USER_0,() -> mLauncherApps.registerCallback(c0_3,h));
runWithCaller(LAUNCHER_4,USER_0,() -> mLauncherApps.registerCallback(c0_4,h));
runWithCaller(LAUNCHER_1,USER_P0,() -> mLauncherApps.registerCallback(cP0_1,h));
runWithCaller(LAUNCHER_1,USER_10,() -> mLauncherApps.registerCallback(c10_1,h));
runWithCaller(LAUNCHER_2,USER_10,() -> mLauncherApps.registerCallback(c10_2,h));
runWithCaller(LAUNCHER_1,USER_11,() -> mLauncherApps.registerCallback(c11_1,h));
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
resetAll(all);
runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_0,CALLING_PACKAGE_3,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_0,CALLING_PACKAGE_3,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_P0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_2);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(cP0_1);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
doAnswer(new AnswerIsUserRunning(false)).when(mMockUserManager).isUserRunning(anyInt());
doAnswer(new AnswerIsUserRunning(true)).when(mMockUserManager).isUserRunning(eq(USER_P0));
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_P0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_P0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_P0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
doAnswer(new AnswerIsUserRunning(false)).when(mMockUserManager).isUserRunning(anyInt());
doAnswer(new AnswerIsUserRunning(true)).when(mMockUserManager).isUserRunning(eq(USER_10));
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_10,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_2);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(cP0_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c10_1,HANDLE_USER_10,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.974020532160067
191776,"public void testHandlePackageUpdate() throws Throwable {
  final Icon res32x32=Icon.createWithResource(getTestContext(),R.drawable.black_32x32);
  final Icon bmp32x32=Icon.createWithBitmap(BitmapFactory.decodeResource(getTestContext().getResources(),R.drawable.black_32x32));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcut(""String_Node_Str""),makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcut(""String_Node_Str""),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",res32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_1,USER_10,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",res32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",bmp32x32),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  LauncherApps.Callback c0=mock(LauncherApps.Callback.class);
  LauncherApps.Callback c10=mock(LauncherApps.Callback.class);
  runWithCaller(LAUNCHER_1,USER_0,() -> {
    mLauncherApps.registerCallback(c0,new Handler(Looper.getMainLooper()));
  }
);
  runWithCaller(LAUNCHER_1,USER_10,() -> {
    mLauncherApps.registerCallback(c10,new Handler(Looper.getMainLooper()));
  }
);
  mInjectedCurrentTimeLillis=START_TIME + 100;
  ArgumentCaptor<List> shortcuts;
  reset(c0);
  reset(c10);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_0));
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_10));
  waitOnMainThread();
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_1,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_0));
  waitOnMainThread();
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0).onShortcutsChanged(eq(CALLING_PACKAGE_1),shortcuts.capture(),eq(HANDLE_USER_0));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(START_TIME,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 100,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 100,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  mInjectedCurrentTimeLillis=START_TIME + 200;
  when(mMockUserManager.isUserRunning(eq(USER_10))).thenReturn(true);
  reset(c0);
  reset(c10);
  mService.handleUnlockUser(USER_10);
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10).onShortcutsChanged(eq(CALLING_PACKAGE_1),shortcuts.capture(),eq(HANDLE_USER_10));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"",""String_Node_Str"");
  assertEquals(START_TIME + 200,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 200,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  mInjectedCurrentTimeLillis=START_TIME + 300;
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_2,10);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_2,USER_0));
  mService.handleUnlockUser(USER_10);
  waitOnMainThread();
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  mInjectedCurrentTimeLillis=START_TIME + 400;
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_3,100);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_3,USER_0));
  mService.handleUnlockUser(USER_10);
  waitOnMainThread();
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0).onShortcutsChanged(eq(CALLING_PACKAGE_3),shortcuts.capture(),eq(HANDLE_USER_0));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_3),any(List.class),any(UserHandle.class));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"");
  assertEquals(START_TIME + 400,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
}","public void testHandlePackageUpdate() throws Throwable {
  final Icon res32x32=Icon.createWithResource(getTestContext(),R.drawable.black_32x32);
  final Icon bmp32x32=Icon.createWithBitmap(BitmapFactory.decodeResource(getTestContext().getResources(),R.drawable.black_32x32));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcut(""String_Node_Str""),makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcut(""String_Node_Str""),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",res32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_1,USER_10,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",res32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",bmp32x32),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  LauncherApps.Callback c0=mock(LauncherApps.Callback.class);
  LauncherApps.Callback c10=mock(LauncherApps.Callback.class);
  runWithCaller(LAUNCHER_1,USER_0,() -> {
    mLauncherApps.registerCallback(c0,new Handler(Looper.getMainLooper()));
  }
);
  runWithCaller(LAUNCHER_1,USER_10,() -> {
    mLauncherApps.registerCallback(c10,new Handler(Looper.getMainLooper()));
  }
);
  mInjectedCurrentTimeLillis=START_TIME + 100;
  ArgumentCaptor<List> shortcuts;
  reset(c0);
  reset(c10);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_0));
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_10));
  waitOnMainThread();
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_1,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_0));
  waitOnMainThread();
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0).onShortcutsChanged(eq(CALLING_PACKAGE_1),shortcuts.capture(),eq(HANDLE_USER_0));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(START_TIME,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 100,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 100,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  mInjectedCurrentTimeLillis=START_TIME + 200;
  doAnswer(new AnswerIsUserRunning(true)).when(mMockUserManager).isUserRunning(eq(USER_10));
  reset(c0);
  reset(c10);
  mService.handleUnlockUser(USER_10);
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10).onShortcutsChanged(eq(CALLING_PACKAGE_1),shortcuts.capture(),eq(HANDLE_USER_10));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"",""String_Node_Str"");
  assertEquals(START_TIME + 200,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 200,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  mInjectedCurrentTimeLillis=START_TIME + 300;
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_2,10);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_2,USER_0));
  mService.handleUnlockUser(USER_10);
  waitOnMainThread();
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  mInjectedCurrentTimeLillis=START_TIME + 400;
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_3,100);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_3,USER_0));
  mService.handleUnlockUser(USER_10);
  waitOnMainThread();
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0).onShortcutsChanged(eq(CALLING_PACKAGE_3),shortcuts.capture(),eq(HANDLE_USER_0));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_3),any(List.class),any(UserHandle.class));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"");
  assertEquals(START_TIME + 400,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
}",0.994327468512643
191777,"public void testGetShortcuts(){
  setCaller(CALLING_PACKAGE_1);
  final ShortcutInfo s1_1=makeShortcutWithTimestamp(""String_Node_Str"",5000);
  final ShortcutInfo s1_2=makeShortcutWithTimestamp(""String_Node_Str"",1000);
  assertTrue(mManager.setDynamicShortcuts(list(s1_1,s1_2)));
  setCaller(CALLING_PACKAGE_2);
  final ShortcutInfo s2_2=makeShortcutWithTimestamp(""String_Node_Str"",1500);
  final ShortcutInfo s2_3=makeShortcutWithTimestamp(""String_Node_Str"",3000);
  final ShortcutInfo s2_4=makeShortcutWithTimestamp(""String_Node_Str"",500);
  assertTrue(mManager.setDynamicShortcuts(list(s2_2,s2_3,s2_4)));
  setCaller(CALLING_PACKAGE_3);
  final ShortcutInfo s3_2=makeShortcutWithTimestamp(""String_Node_Str"",START_TIME + 5000);
  assertTrue(mManager.setDynamicShortcuts(list(s3_2)));
  setCaller(LAUNCHER_1);
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_1,null,ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertShortcutIds(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_1,null,ShortcutQuery.FLAG_GET_PINNED),getCallingUser()));
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_PINNED | ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser()))))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser()))))));
  mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),getCallingUser());
  assertAllPinned(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_PINNED),getCallingUser())),""String_Node_Str""))));
  assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(5000,null,null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_PINNED),getCallingUser())),""String_Node_Str"",""String_Node_Str"");
  assertExpectException(IllegalArgumentException.class,""String_Node_Str"",() -> {
    mLauncherApps.getShortcuts(buildQuery(0,null,list(""String_Node_Str""),null,0),getCallingUser());
  }
);
}","public void testGetShortcuts(){
  setCaller(CALLING_PACKAGE_1);
  final ShortcutInfo s1_1=makeShortcutWithTimestamp(""String_Node_Str"",5000);
  final ShortcutInfo s1_2=makeShortcutWithTimestamp(""String_Node_Str"",1000);
  assertTrue(mManager.setDynamicShortcuts(list(s1_1,s1_2)));
  setCaller(CALLING_PACKAGE_2);
  final ShortcutInfo s2_2=makeShortcutWithTimestamp(""String_Node_Str"",1500);
  final ShortcutInfo s2_3=makeShortcutWithTimestampWithActivity(""String_Node_Str"",3000,makeComponent(ShortcutActivity2.class));
  final ShortcutInfo s2_4=makeShortcutWithTimestampWithActivity(""String_Node_Str"",500,makeComponent(ShortcutActivity.class));
  assertTrue(mManager.setDynamicShortcuts(list(s2_2,s2_3,s2_4)));
  setCaller(CALLING_PACKAGE_3);
  final ShortcutInfo s3_2=makeShortcutWithTimestamp(""String_Node_Str"",START_TIME + 5000);
  assertTrue(mManager.setDynamicShortcuts(list(s3_2)));
  setCaller(LAUNCHER_1);
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_1,null,ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertShortcutIds(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_1,null,ShortcutQuery.FLAG_GET_PINNED),getCallingUser()));
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_PINNED | ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_2,new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),ShortcutQuery.FLAG_GET_PINNED | ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser()))))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser()))))));
  mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),getCallingUser());
  assertAllPinned(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_PINNED),getCallingUser())),""String_Node_Str""))));
  assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(5000,null,null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_PINNED),getCallingUser())),""String_Node_Str"",""String_Node_Str"");
  assertExpectException(IllegalArgumentException.class,""String_Node_Str"",() -> {
    mLauncherApps.getShortcuts(buildQuery(0,null,list(""String_Node_Str""),null,0),getCallingUser());
  }
);
}",0.9434659440817836
191778,"/** 
 * Constructs a Bundle containing a copy of the mappings from the given Bundle.
 * @param b a Bundle to be copied.
 */
BaseBundle(BaseBundle b){
  if (b.mParcelledData != null) {
    if (b.isEmptyParcel()) {
      mParcelledData=NoImagePreloadHolder.EMPTY_PARCEL;
    }
 else {
      mParcelledData=Parcel.obtain();
      mParcelledData.appendFrom(b.mParcelledData,0,b.mParcelledData.dataSize());
      mParcelledData.setDataPosition(0);
    }
  }
 else {
    mParcelledData=null;
  }
  if (b.mMap != null) {
    mMap=new ArrayMap<String,Object>(b.mMap);
  }
 else {
    mMap=null;
  }
  mClassLoader=b.mClassLoader;
}","/** 
 * Constructs a Bundle containing a copy of the mappings from the given Bundle.
 * @param b a Bundle to be copied.
 */
BaseBundle(BaseBundle b){
  if (b.mParcelledData != null) {
    if (b.isEmptyParcel()) {
      mParcelledData=NoImagePreloadHolder.EMPTY_PARCEL;
    }
 else {
      mParcelledData=Parcel.obtain();
      mParcelledData.appendFrom(b.mParcelledData,0,b.mParcelledData.dataSize());
      mParcelledData.setDataPosition(0);
    }
  }
 else {
    mParcelledData=null;
  }
  if (b.mMap != null) {
    mMap=new ArrayMap<>(b.mMap);
  }
 else {
    mMap=null;
  }
  mClassLoader=b.mClassLoader;
}",0.989456609894566
191779,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
void writeToParcelInner(Parcel parcel,int flags){
  if (mParcelledData != null) {
    if (isEmptyParcel()) {
      parcel.writeInt(0);
    }
 else {
      int length=mParcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(mParcelledData,0,length);
    }
  }
 else {
    if (mMap == null || mMap.size() <= 0) {
      parcel.writeInt(0);
      return;
    }
    int lengthPos=parcel.dataPosition();
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos=parcel.dataPosition();
    parcel.writeArrayMapInternal(mMap);
    int endPos=parcel.dataPosition();
    parcel.setDataPosition(lengthPos);
    int length=endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
  }
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
void writeToParcelInner(Parcel parcel,int flags){
  final Parcel parcelledData;
synchronized (this) {
    parcelledData=mParcelledData;
  }
  if (parcelledData != null) {
    if (isEmptyParcel()) {
      parcel.writeInt(0);
    }
 else {
      int length=parcelledData.dataSize();
      parcel.writeInt(length);
      parcel.writeInt(BUNDLE_MAGIC);
      parcel.appendFrom(parcelledData,0,length);
    }
  }
 else {
    if (mMap == null || mMap.size() <= 0) {
      parcel.writeInt(0);
      return;
    }
    int lengthPos=parcel.dataPosition();
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos=parcel.dataPosition();
    parcel.writeArrayMapInternal(mMap);
    int endPos=parcel.dataPosition();
    parcel.setDataPosition(lengthPos);
    int length=endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
  }
}",0.9494241362043064
191780,"/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
    return;
  }
  if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
    Slog.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"",new Throwable());
  }
  if (isEmptyParcel()) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
    if (mMap == null) {
      mMap=new ArrayMap<String,Object>(1);
    }
 else {
      mMap.erase();
    }
    mParcelledData=null;
    return;
  }
  int N=mParcelledData.readInt();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ N+ ""String_Node_Str"");
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  try {
    mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  }
 catch (  BadParcelableException e) {
    if (sShouldDefuse) {
      Log.w(TAG,""String_Node_Str"",e);
      mMap.erase();
    }
 else {
      throw e;
    }
  }
 finally {
    mParcelledData.recycle();
    mParcelledData=null;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ mMap);
}","/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
synchronized (this) {
    final Parcel parcelledData=mParcelledData;
    if (parcelledData == null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
      return;
    }
    if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
      Slog.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"",new Throwable());
    }
    if (isEmptyParcel()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str"");
      if (mMap == null) {
        mMap=new ArrayMap<>(1);
      }
 else {
        mMap.erase();
      }
      mParcelledData=null;
      return;
    }
    int N=parcelledData.readInt();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ N+ ""String_Node_Str"");
    if (N < 0) {
      return;
    }
    ArrayMap<String,Object> map=mMap;
    if (map == null) {
      map=new ArrayMap<>(N);
    }
 else {
      map.erase();
      map.ensureCapacity(N);
    }
    try {
      parcelledData.readArrayMapInternal(map,N,mClassLoader);
    }
 catch (    BadParcelableException e) {
      if (sShouldDefuse) {
        Log.w(TAG,""String_Node_Str"",e);
        map.erase();
      }
 else {
        throw e;
      }
    }
 finally {
      mMap=map;
      parcelledData.recycle();
      mParcelledData=null;
    }
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + Integer.toHexString(System.identityHashCode(this)) + ""String_Node_Str""+ mMap);
  }
}",0.7902076231794236
191781,"/** 
 * If non-null, returns only shortcuts associated with the activity.
 */
public void setActivity(@Nullable ComponentName activity){
  mActivity=activity;
}","/** 
 * If non-null, returns only shortcuts associated with the activity, which are  {@link ShortcutInfo}s that have null   {@link ShortcutInfo#getActivityComponent()}, or  {@link ShortcutInfo#getActivityComponent()} equals to {@code activity}.
 */
public void setActivity(@Nullable ComponentName activity){
  mActivity=activity;
}",0.6517311608961304
191782,"private void notifyListeners(@NonNull String packageName,@UserIdInt int userId){
  if (!mUserManager.isUserRunning(userId)) {
    return;
  }
  postToHandler(() -> {
    final ArrayList<ShortcutChangeListener> copy;
synchronized (mLock) {
      copy=new ArrayList<>(mListeners);
    }
    for (int i=copy.size() - 1; i >= 0; i--) {
      copy.get(i).onShortcutChanged(packageName,userId);
    }
  }
);
}","private void notifyListeners(@NonNull String packageName,@UserIdInt int userId){
  final long token=injectClearCallingIdentity();
  try {
    if (!mUserManager.isUserRunning(userId)) {
      return;
    }
  }
  finally {
    injectRestoreCallingIdentity(token);
  }
  postToHandler(() -> {
    final ArrayList<ShortcutChangeListener> copy;
synchronized (mLock) {
      copy=new ArrayList<>(mListeners);
    }
    for (int i=copy.size() - 1; i >= 0; i--) {
      copy.get(i).onShortcutChanged(packageName,userId);
    }
  }
);
}",0.853763440860215
191783,"private void getShortcutsInnerLocked(int launcherUserId,@NonNull String callingPackage,@Nullable String packageName,@Nullable List<String> shortcutIds,long changedSince,@Nullable ComponentName componentName,int queryFlags,int userId,ArrayList<ShortcutInfo> ret,int cloneFlag){
  final ArraySet<String> ids=shortcutIds == null ? null : new ArraySet<>(shortcutIds);
  getPackageShortcutsLocked(packageName,userId).findAll(ShortcutService.this,ret,(  ShortcutInfo si) -> {
    if (si.getLastChangedTimestamp() < changedSince) {
      return false;
    }
    if (ids != null && !ids.contains(si.getId())) {
      return false;
    }
    if (componentName != null && !componentName.equals(si.getActivityComponent())) {
      return false;
    }
    final boolean matchDynamic=((queryFlags & ShortcutQuery.FLAG_GET_DYNAMIC) != 0) && si.isDynamic();
    final boolean matchPinned=((queryFlags & ShortcutQuery.FLAG_GET_PINNED) != 0) && si.isPinned();
    return matchDynamic || matchPinned;
  }
,cloneFlag,callingPackage,launcherUserId);
}","private void getShortcutsInnerLocked(int launcherUserId,@NonNull String callingPackage,@Nullable String packageName,@Nullable List<String> shortcutIds,long changedSince,@Nullable ComponentName componentName,int queryFlags,int userId,ArrayList<ShortcutInfo> ret,int cloneFlag){
  final ArraySet<String> ids=shortcutIds == null ? null : new ArraySet<>(shortcutIds);
  getPackageShortcutsLocked(packageName,userId).findAll(ShortcutService.this,ret,(  ShortcutInfo si) -> {
    if (si.getLastChangedTimestamp() < changedSince) {
      return false;
    }
    if (ids != null && !ids.contains(si.getId())) {
      return false;
    }
    if (componentName != null) {
      if (si.getActivityComponent() != null && !si.getActivityComponent().equals(componentName)) {
        return false;
      }
    }
    final boolean matchDynamic=((queryFlags & ShortcutQuery.FLAG_GET_DYNAMIC) != 0) && si.isDynamic();
    final boolean matchPinned=((queryFlags & ShortcutQuery.FLAG_GET_PINNED) != 0) && si.isPinned();
    return matchDynamic || matchPinned;
  }
,cloneFlag,callingPackage,launcherUserId);
}",0.9523360075507314
191784,"@Override protected void setUp() throws Exception {
  super.setUp();
  mServiceContext=spy(new ServiceContext());
  mClientContext=new ClientContext();
  mMockPackageManager=mock(PackageManager.class);
  mMockPackageManagerInternal=mock(PackageManagerInternal.class);
  mMockUserManager=mock(UserManager.class);
  mInjectedCurrentTimeLillis=START_TIME;
  mInjectedPackages=new HashMap<>();
  ;
  addPackage(CALLING_PACKAGE_1,CALLING_UID_1,1);
  addPackage(CALLING_PACKAGE_2,CALLING_UID_2,2);
  addPackage(CALLING_PACKAGE_3,CALLING_UID_3,3);
  addPackage(CALLING_PACKAGE_4,CALLING_UID_4,10);
  addPackage(LAUNCHER_1,LAUNCHER_UID_1,4);
  addPackage(LAUNCHER_2,LAUNCHER_UID_2,5);
  addPackage(LAUNCHER_3,LAUNCHER_UID_3,6);
  addPackage(LAUNCHER_4,LAUNCHER_UID_4,10);
  updatePackageInfo(CALLING_PACKAGE_3,pi -> pi.applicationInfo.flags&=~ApplicationInfo.FLAG_ALLOW_BACKUP);
  updatePackageInfo(LAUNCHER_3,pi -> pi.applicationInfo.flags&=~ApplicationInfo.FLAG_ALLOW_BACKUP);
  mUninstalledPackages=new HashSet<>();
  mInjectedFilePathRoot=new File(getTestContext().getCacheDir(),""String_Node_Str"");
  deleteAllSavedFiles();
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_0;
  }
).when(mMockUserManager).getUserInfo(eq(USER_0));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_10;
  }
).when(mMockUserManager).getUserInfo(eq(USER_10));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_11;
  }
).when(mMockUserManager).getUserInfo(eq(USER_11));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_P0;
  }
).when(mMockUserManager).getUserInfo(eq(USER_P0));
  when(mMockUserManager.isUserRunning(eq(USER_0))).thenReturn(true);
  initService();
  setCaller(CALLING_PACKAGE_1);
  mInternal.onSystemLocaleChangedNoLock();
}","@Override protected void setUp() throws Exception {
  super.setUp();
  mServiceContext=spy(new ServiceContext());
  mClientContext=new ClientContext();
  mMockPackageManager=mock(PackageManager.class);
  mMockPackageManagerInternal=mock(PackageManagerInternal.class);
  mMockUserManager=mock(UserManager.class);
  mInjectedCurrentTimeLillis=START_TIME;
  mInjectedPackages=new HashMap<>();
  ;
  addPackage(CALLING_PACKAGE_1,CALLING_UID_1,1);
  addPackage(CALLING_PACKAGE_2,CALLING_UID_2,2);
  addPackage(CALLING_PACKAGE_3,CALLING_UID_3,3);
  addPackage(CALLING_PACKAGE_4,CALLING_UID_4,10);
  addPackage(LAUNCHER_1,LAUNCHER_UID_1,4);
  addPackage(LAUNCHER_2,LAUNCHER_UID_2,5);
  addPackage(LAUNCHER_3,LAUNCHER_UID_3,6);
  addPackage(LAUNCHER_4,LAUNCHER_UID_4,10);
  updatePackageInfo(CALLING_PACKAGE_3,pi -> pi.applicationInfo.flags&=~ApplicationInfo.FLAG_ALLOW_BACKUP);
  updatePackageInfo(LAUNCHER_3,pi -> pi.applicationInfo.flags&=~ApplicationInfo.FLAG_ALLOW_BACKUP);
  mUninstalledPackages=new HashSet<>();
  mInjectedFilePathRoot=new File(getTestContext().getCacheDir(),""String_Node_Str"");
  deleteAllSavedFiles();
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_0;
  }
).when(mMockUserManager).getUserInfo(eq(USER_0));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_10;
  }
).when(mMockUserManager).getUserInfo(eq(USER_10));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_11;
  }
).when(mMockUserManager).getUserInfo(eq(USER_11));
  doAnswer(inv -> {
    assertSystem();
    return USER_INFO_P0;
  }
).when(mMockUserManager).getUserInfo(eq(USER_P0));
  when(mMockUserManager.isUserRunning(eq(USER_0))).thenAnswer(new AnswerIsUserRunning(true));
  initService();
  setCaller(CALLING_PACKAGE_1);
  mInternal.onSystemLocaleChangedNoLock();
}",0.9901269393511988
191785,"public void testLauncherCallback_crossProfile() throws Throwable {
  prepareCrossProfileDataSet();
  final Handler h=new Handler(Looper.getMainLooper());
  final LauncherApps.Callback c0_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_2=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_3=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_4=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback cP0_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c10_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c10_2=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c11_1=mock(LauncherApps.Callback.class);
  final List<LauncherApps.Callback> all=list(c0_1,c0_2,c0_3,c0_4,cP0_1,c10_1,c11_1);
  setDefaultLauncherChecker((pkg,userId) -> {
switch (userId) {
case USER_0:
      return LAUNCHER_2.equals(pkg);
case USER_P0:
    return LAUNCHER_1.equals(pkg);
case USER_10:
  return LAUNCHER_1.equals(pkg);
case USER_11:
return LAUNCHER_1.equals(pkg);
default :
return false;
}
}
);
runWithCaller(LAUNCHER_1,USER_0,() -> mLauncherApps.registerCallback(c0_1,h));
runWithCaller(LAUNCHER_2,USER_0,() -> mLauncherApps.registerCallback(c0_2,h));
runWithCaller(LAUNCHER_3,USER_0,() -> mLauncherApps.registerCallback(c0_3,h));
runWithCaller(LAUNCHER_4,USER_0,() -> mLauncherApps.registerCallback(c0_4,h));
runWithCaller(LAUNCHER_1,USER_P0,() -> mLauncherApps.registerCallback(cP0_1,h));
runWithCaller(LAUNCHER_1,USER_10,() -> mLauncherApps.registerCallback(c10_1,h));
runWithCaller(LAUNCHER_2,USER_10,() -> mLauncherApps.registerCallback(c10_2,h));
runWithCaller(LAUNCHER_1,USER_11,() -> mLauncherApps.registerCallback(c11_1,h));
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
resetAll(all);
runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_0,CALLING_PACKAGE_3,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_0,CALLING_PACKAGE_3,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_P0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_2);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(cP0_1);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
when(mMockUserManager.isUserRunning(anyInt())).thenReturn(false);
when(mMockUserManager.isUserRunning(eq(USER_P0))).thenReturn(true);
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_P0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_P0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_P0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
when(mMockUserManager.isUserRunning(anyInt())).thenReturn(false);
when(mMockUserManager.isUserRunning(eq(USER_10))).thenReturn(true);
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_10,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_2);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(cP0_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c10_1,HANDLE_USER_10,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","public void testLauncherCallback_crossProfile() throws Throwable {
  prepareCrossProfileDataSet();
  final Handler h=new Handler(Looper.getMainLooper());
  final LauncherApps.Callback c0_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_2=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_3=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c0_4=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback cP0_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c10_1=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c10_2=mock(LauncherApps.Callback.class);
  final LauncherApps.Callback c11_1=mock(LauncherApps.Callback.class);
  final List<LauncherApps.Callback> all=list(c0_1,c0_2,c0_3,c0_4,cP0_1,c10_1,c11_1);
  setDefaultLauncherChecker((pkg,userId) -> {
switch (userId) {
case USER_0:
      return LAUNCHER_2.equals(pkg);
case USER_P0:
    return LAUNCHER_1.equals(pkg);
case USER_10:
  return LAUNCHER_1.equals(pkg);
case USER_11:
return LAUNCHER_1.equals(pkg);
default :
return false;
}
}
);
runWithCaller(LAUNCHER_1,USER_0,() -> mLauncherApps.registerCallback(c0_1,h));
runWithCaller(LAUNCHER_2,USER_0,() -> mLauncherApps.registerCallback(c0_2,h));
runWithCaller(LAUNCHER_3,USER_0,() -> mLauncherApps.registerCallback(c0_3,h));
runWithCaller(LAUNCHER_4,USER_0,() -> mLauncherApps.registerCallback(c0_4,h));
runWithCaller(LAUNCHER_1,USER_P0,() -> mLauncherApps.registerCallback(cP0_1,h));
runWithCaller(LAUNCHER_1,USER_10,() -> mLauncherApps.registerCallback(c10_1,h));
runWithCaller(LAUNCHER_2,USER_10,() -> mLauncherApps.registerCallback(c10_2,h));
runWithCaller(LAUNCHER_1,USER_11,() -> mLauncherApps.registerCallback(c11_1,h));
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
resetAll(all);
runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_0,CALLING_PACKAGE_3,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_0,CALLING_PACKAGE_3,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_P0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_2);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(cP0_1);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
doAnswer(new AnswerIsUserRunning(false)).when(mMockUserManager).isUserRunning(anyInt());
doAnswer(new AnswerIsUserRunning(true)).when(mMockUserManager).isUserRunning(eq(USER_P0));
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_P0,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(c10_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c0_2,HANDLE_USER_P0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
assertCallbackReceived(cP0_1,HANDLE_USER_P0,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
doAnswer(new AnswerIsUserRunning(false)).when(mMockUserManager).isUserRunning(anyInt());
doAnswer(new AnswerIsUserRunning(true)).when(mMockUserManager).isUserRunning(eq(USER_10));
resetAll(all);
runWithCaller(CALLING_PACKAGE_1,USER_10,() -> {
mManager.removeDynamicShortcuts(list());
}
);
waitOnMainThread();
assertCallbackNotReceived(c0_1);
assertCallbackNotReceived(c0_2);
assertCallbackNotReceived(c0_3);
assertCallbackNotReceived(c0_4);
assertCallbackNotReceived(cP0_1);
assertCallbackNotReceived(c10_2);
assertCallbackNotReceived(c11_1);
assertCallbackReceived(c10_1,HANDLE_USER_10,CALLING_PACKAGE_1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.974020532160067
191786,"public void testHandlePackageUpdate() throws Throwable {
  final Icon res32x32=Icon.createWithResource(getTestContext(),R.drawable.black_32x32);
  final Icon bmp32x32=Icon.createWithBitmap(BitmapFactory.decodeResource(getTestContext().getResources(),R.drawable.black_32x32));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcut(""String_Node_Str""),makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcut(""String_Node_Str""),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",res32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_1,USER_10,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",res32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",bmp32x32),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  LauncherApps.Callback c0=mock(LauncherApps.Callback.class);
  LauncherApps.Callback c10=mock(LauncherApps.Callback.class);
  runWithCaller(LAUNCHER_1,USER_0,() -> {
    mLauncherApps.registerCallback(c0,new Handler(Looper.getMainLooper()));
  }
);
  runWithCaller(LAUNCHER_1,USER_10,() -> {
    mLauncherApps.registerCallback(c10,new Handler(Looper.getMainLooper()));
  }
);
  mInjectedCurrentTimeLillis=START_TIME + 100;
  ArgumentCaptor<List> shortcuts;
  reset(c0);
  reset(c10);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_0));
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_10));
  waitOnMainThread();
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_1,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_0));
  waitOnMainThread();
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0).onShortcutsChanged(eq(CALLING_PACKAGE_1),shortcuts.capture(),eq(HANDLE_USER_0));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(START_TIME,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 100,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 100,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  mInjectedCurrentTimeLillis=START_TIME + 200;
  when(mMockUserManager.isUserRunning(eq(USER_10))).thenReturn(true);
  reset(c0);
  reset(c10);
  mService.handleUnlockUser(USER_10);
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10).onShortcutsChanged(eq(CALLING_PACKAGE_1),shortcuts.capture(),eq(HANDLE_USER_10));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"",""String_Node_Str"");
  assertEquals(START_TIME + 200,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 200,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  mInjectedCurrentTimeLillis=START_TIME + 300;
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_2,10);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_2,USER_0));
  mService.handleUnlockUser(USER_10);
  waitOnMainThread();
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  mInjectedCurrentTimeLillis=START_TIME + 400;
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_3,100);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_3,USER_0));
  mService.handleUnlockUser(USER_10);
  waitOnMainThread();
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0).onShortcutsChanged(eq(CALLING_PACKAGE_3),shortcuts.capture(),eq(HANDLE_USER_0));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_3),any(List.class),any(UserHandle.class));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"");
  assertEquals(START_TIME + 400,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
}","public void testHandlePackageUpdate() throws Throwable {
  final Icon res32x32=Icon.createWithResource(getTestContext(),R.drawable.black_32x32);
  final Icon bmp32x32=Icon.createWithBitmap(BitmapFactory.decodeResource(getTestContext().getResources(),R.drawable.black_32x32));
  runWithCaller(CALLING_PACKAGE_1,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcut(""String_Node_Str""),makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcut(""String_Node_Str""),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_3,USER_0,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",res32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_1,USER_10,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",res32x32),makeShortcutWithIcon(""String_Node_Str"",res32x32))));
  }
);
  runWithCaller(CALLING_PACKAGE_2,USER_10,() -> {
    assertTrue(mManager.setDynamicShortcuts(list(makeShortcutWithIcon(""String_Node_Str"",bmp32x32),makeShortcutWithIcon(""String_Node_Str"",bmp32x32))));
  }
);
  LauncherApps.Callback c0=mock(LauncherApps.Callback.class);
  LauncherApps.Callback c10=mock(LauncherApps.Callback.class);
  runWithCaller(LAUNCHER_1,USER_0,() -> {
    mLauncherApps.registerCallback(c0,new Handler(Looper.getMainLooper()));
  }
);
  runWithCaller(LAUNCHER_1,USER_10,() -> {
    mLauncherApps.registerCallback(c10,new Handler(Looper.getMainLooper()));
  }
);
  mInjectedCurrentTimeLillis=START_TIME + 100;
  ArgumentCaptor<List> shortcuts;
  reset(c0);
  reset(c10);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_0));
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_10));
  waitOnMainThread();
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_1,1);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_1,USER_0));
  waitOnMainThread();
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0).onShortcutsChanged(eq(CALLING_PACKAGE_1),shortcuts.capture(),eq(HANDLE_USER_0));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(START_TIME,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 100,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 100,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  mInjectedCurrentTimeLillis=START_TIME + 200;
  doAnswer(new AnswerIsUserRunning(true)).when(mMockUserManager).isUserRunning(eq(USER_10));
  reset(c0);
  reset(c10);
  mService.handleUnlockUser(USER_10);
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10).onShortcutsChanged(eq(CALLING_PACKAGE_1),shortcuts.capture(),eq(HANDLE_USER_10));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"",""String_Node_Str"");
  assertEquals(START_TIME + 200,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  assertEquals(START_TIME + 200,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
  mInjectedCurrentTimeLillis=START_TIME + 300;
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_2,10);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_2,USER_0));
  mService.handleUnlockUser(USER_10);
  waitOnMainThread();
  verify(c0,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_1),any(List.class),any(UserHandle.class));
  mInjectedCurrentTimeLillis=START_TIME + 400;
  reset(c0);
  reset(c10);
  updatePackageVersion(CALLING_PACKAGE_3,100);
  mService.mPackageMonitor.onReceive(getTestContext(),genPackageUpdateIntent(CALLING_PACKAGE_3,USER_0));
  mService.handleUnlockUser(USER_10);
  waitOnMainThread();
  shortcuts=ArgumentCaptor.forClass(List.class);
  verify(c0).onShortcutsChanged(eq(CALLING_PACKAGE_3),shortcuts.capture(),eq(HANDLE_USER_0));
  verify(c10,times(0)).onShortcutsChanged(eq(CALLING_PACKAGE_3),any(List.class),any(UserHandle.class));
  assertShortcutIds(shortcuts.getValue(),""String_Node_Str"");
  assertEquals(START_TIME + 400,findShortcut(shortcuts.getValue(),""String_Node_Str"").getLastChangedTimestamp());
}",0.994327468512643
191787,"public void testGetShortcuts(){
  setCaller(CALLING_PACKAGE_1);
  final ShortcutInfo s1_1=makeShortcutWithTimestamp(""String_Node_Str"",5000);
  final ShortcutInfo s1_2=makeShortcutWithTimestamp(""String_Node_Str"",1000);
  assertTrue(mManager.setDynamicShortcuts(list(s1_1,s1_2)));
  setCaller(CALLING_PACKAGE_2);
  final ShortcutInfo s2_2=makeShortcutWithTimestamp(""String_Node_Str"",1500);
  final ShortcutInfo s2_3=makeShortcutWithTimestamp(""String_Node_Str"",3000);
  final ShortcutInfo s2_4=makeShortcutWithTimestamp(""String_Node_Str"",500);
  assertTrue(mManager.setDynamicShortcuts(list(s2_2,s2_3,s2_4)));
  setCaller(CALLING_PACKAGE_3);
  final ShortcutInfo s3_2=makeShortcutWithTimestamp(""String_Node_Str"",START_TIME + 5000);
  assertTrue(mManager.setDynamicShortcuts(list(s3_2)));
  setCaller(LAUNCHER_1);
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_1,null,ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertShortcutIds(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_1,null,ShortcutQuery.FLAG_GET_PINNED),getCallingUser()));
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_PINNED | ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser()))))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser()))))));
  mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),getCallingUser());
  assertAllPinned(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_PINNED),getCallingUser())),""String_Node_Str""))));
  assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(5000,null,null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_PINNED),getCallingUser())),""String_Node_Str"",""String_Node_Str"");
  assertExpectException(IllegalArgumentException.class,""String_Node_Str"",() -> {
    mLauncherApps.getShortcuts(buildQuery(0,null,list(""String_Node_Str""),null,0),getCallingUser());
  }
);
}","public void testGetShortcuts(){
  setCaller(CALLING_PACKAGE_1);
  final ShortcutInfo s1_1=makeShortcutWithTimestamp(""String_Node_Str"",5000);
  final ShortcutInfo s1_2=makeShortcutWithTimestamp(""String_Node_Str"",1000);
  assertTrue(mManager.setDynamicShortcuts(list(s1_1,s1_2)));
  setCaller(CALLING_PACKAGE_2);
  final ShortcutInfo s2_2=makeShortcutWithTimestamp(""String_Node_Str"",1500);
  final ShortcutInfo s2_3=makeShortcutWithTimestampWithActivity(""String_Node_Str"",3000,makeComponent(ShortcutActivity2.class));
  final ShortcutInfo s2_4=makeShortcutWithTimestampWithActivity(""String_Node_Str"",500,makeComponent(ShortcutActivity.class));
  assertTrue(mManager.setDynamicShortcuts(list(s2_2,s2_3,s2_4)));
  setCaller(CALLING_PACKAGE_3);
  final ShortcutInfo s3_2=makeShortcutWithTimestamp(""String_Node_Str"",START_TIME + 5000);
  assertTrue(mManager.setDynamicShortcuts(list(s3_2)));
  setCaller(LAUNCHER_1);
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_1,null,ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertShortcutIds(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_1,null,ShortcutQuery.FLAG_GET_PINNED),getCallingUser()));
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_PINNED | ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(0,CALLING_PACKAGE_2,new ComponentName(CALLING_PACKAGE_2,ShortcutActivity.class.getName()),ShortcutQuery.FLAG_GET_PINNED | ShortcutQuery.FLAG_GET_DYNAMIC),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser())),""String_Node_Str"",""String_Node_Str""))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser()))))));
  assertAllDynamic(assertAllNotHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,list(),null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_KEY_FIELDS_ONLY),getCallingUser()))))));
  mLauncherApps.pinShortcuts(CALLING_PACKAGE_2,list(""String_Node_Str"",""String_Node_Str""),getCallingUser());
  assertAllPinned(assertAllHaveTitle(assertAllNotHaveIntents(assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(1000,CALLING_PACKAGE_2,null,ShortcutQuery.FLAG_GET_PINNED),getCallingUser())),""String_Node_Str""))));
  assertShortcutIds(assertAllNotKeyFieldsOnly(mLauncherApps.getShortcuts(buildQuery(5000,null,null,ShortcutQuery.FLAG_GET_DYNAMIC | ShortcutQuery.FLAG_GET_PINNED),getCallingUser())),""String_Node_Str"",""String_Node_Str"");
  assertExpectException(IllegalArgumentException.class,""String_Node_Str"",() -> {
    mLauncherApps.getShortcuts(buildQuery(0,null,list(""String_Node_Str""),null,0),getCallingUser());
  }
);
}",0.9434659440817836
191788,"/** 
 * Callback for when a job is completed.
 * @param needsReschedule Whether the implementing class should reschedule this job.
 */
public void onJobCompleted(JobStatus jobStatus,boolean needsReschedule);","/** 
 * Callback for when a job is completed.
 * @param needsReschedule Whether the implementing class should reschedule this job.
 */
void onJobCompleted(JobStatus jobStatus,boolean needsReschedule);",0.9828009828009828
191789,"public void noteInactive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.decActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.decActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
  rebatchIfNeeded(now);
}","public void noteInactive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.decActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.decActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
  rebatchIfNeeded(now);
  addEvent(EVENT_STOP_JOB,job.getSourceUid(),job.getBatteryName());
}",0.9112271540469974
191790,"public void noteActive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  rebatchIfNeeded(now);
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.incActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.incActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
}","public void noteActive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  rebatchIfNeeded(now);
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.incActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.incActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
  addEvent(EVENT_START_JOB,job.getSourceUid(),job.getBatteryName());
}",0.90956749672346
191791,"public void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  final long nowEllapsed=SystemClock.elapsedRealtime();
  final DataSet total;
  if (mLastDataSets[0] != null) {
    total=new DataSet(mLastDataSets[0]);
    mLastDataSets[0].addTo(total,now);
  }
 else {
    total=new DataSet(mCurDataSet);
  }
  mCurDataSet.addTo(total,now);
  for (int i=1; i < mLastDataSets.length; i++) {
    if (mLastDataSets[i] != null) {
      mLastDataSets[i].dump(pw,""String_Node_Str"",prefix,now,nowEllapsed);
      pw.println();
    }
  }
  total.dump(pw,""String_Node_Str"",prefix,now,nowEllapsed);
}","public void dump(PrintWriter pw,String prefix,int filterUid){
  final long now=SystemClock.uptimeMillis();
  final long nowEllapsed=SystemClock.elapsedRealtime();
  final DataSet total;
  if (mLastDataSets[0] != null) {
    total=new DataSet(mLastDataSets[0]);
    mLastDataSets[0].addTo(total,now);
  }
 else {
    total=new DataSet(mCurDataSet);
  }
  mCurDataSet.addTo(total,now);
  for (int i=1; i < mLastDataSets.length; i++) {
    if (mLastDataSets[i] != null) {
      mLastDataSets[i].dump(pw,""String_Node_Str"",prefix,now,nowEllapsed,filterUid);
      pw.println();
    }
  }
  total.dump(pw,""String_Node_Str"",prefix,now,nowEllapsed,filterUid);
}",0.9732704402515724
191792,"void dumpInternal(final PrintWriter pw,String[] args){
  int filterUid=-1;
  if (!ArrayUtils.isEmpty(args)) {
    try {
      filterUid=getContext().getPackageManager().getPackageUid(args[0],PackageManager.MATCH_UNINSTALLED_PACKAGES);
    }
 catch (    NameNotFoundException ignored) {
    }
  }
  final int filterUidFinal=filterUid;
  final long now=SystemClock.elapsedRealtime();
synchronized (mLock) {
    pw.println(""String_Node_Str"" + Arrays.toString(mStartedUsers));
    pw.println(""String_Node_Str"");
    if (mJobs.size() > 0) {
      mJobs.forEachJob(new JobStatusFunctor(){
        private int index=0;
        @Override public void process(        JobStatus job){
          pw.print(""String_Node_Str"");
          pw.print(index++);
          pw.print(""String_Node_Str"");
          pw.println(job.toShortString());
          if (filterUidFinal != -1 && job.getUid() != filterUidFinal && job.getSourceUid() != filterUidFinal) {
            return;
          }
          job.dump(pw,""String_Node_Str"",true);
          pw.print(""String_Node_Str"");
          pw.print(mHandler.isReadyToBeExecutedLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(job.isReady());
          pw.print(""String_Node_Str"");
          pw.print(mPendingJobs.contains(job));
          pw.print(""String_Node_Str"");
          pw.print(isCurrentlyActiveLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
          pw.println(""String_Node_Str"");
        }
      }
);
    }
 else {
      pw.println(""String_Node_Str"");
    }
    for (int i=0; i < mControllers.size(); i++) {
      pw.println();
      mControllers.get(i).dumpControllerStateLocked(pw);
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mUidPriorityOverride.size(); i++) {
      pw.print(""String_Node_Str"");
      pw.print(UserHandle.formatUid(mUidPriorityOverride.keyAt(i)));
      pw.print(""String_Node_Str"");
      pw.println(mUidPriorityOverride.valueAt(i));
    }
    pw.println();
    mJobPackageTracker.dump(pw,""String_Node_Str"");
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mPendingJobs.size(); i++) {
      JobStatus job=mPendingJobs.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      pw.println(job.toShortString());
      job.dump(pw,""String_Node_Str"",false);
      int priority=evaluateJobPriorityLocked(job);
      if (priority != JobInfo.PRIORITY_DEFAULT) {
        pw.print(""String_Node_Str"");
        pw.println(priority);
      }
      pw.print(""String_Node_Str"");
      pw.println(job.getTag());
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mActiveServices.size(); i++) {
      JobServiceContext jsc=mActiveServices.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      if (jsc.getRunningJob() == null) {
        pw.println(""String_Node_Str"");
        continue;
      }
 else {
        pw.println(jsc.getRunningJob().toShortString());
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(now - jsc.getExecutionStartTimeElapsed(),pw);
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(jsc.getTimeoutElapsed() - now,pw);
        pw.println();
        jsc.getRunningJob().dump(pw,""String_Node_Str"",false);
        int priority=evaluateJobPriorityLocked(jsc.getRunningJob());
        if (priority != JobInfo.PRIORITY_DEFAULT) {
          pw.print(""String_Node_Str"");
          pw.println(priority);
        }
      }
    }
    pw.println();
    pw.print(""String_Node_Str"");
    pw.println(mReadyToRock);
    pw.print(""String_Node_Str"");
    pw.println(mReportedActive);
    pw.print(""String_Node_Str"");
    pw.println(mMaxActiveJobs);
  }
  pw.println();
}","void dumpInternal(final PrintWriter pw,String[] args){
  int filterUid=-1;
  if (!ArrayUtils.isEmpty(args)) {
    int opti=0;
    while (opti < args.length) {
      String arg=args[opti];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        break;
      }
      opti++;
    }
    if (opti < args.length) {
      String pkg=args[opti];
      try {
        filterUid=getContext().getPackageManager().getPackageUid(pkg,PackageManager.MATCH_UNINSTALLED_PACKAGES);
      }
 catch (      NameNotFoundException ignored) {
        pw.println(""String_Node_Str"" + pkg);
        return;
      }
    }
  }
  final int filterUidFinal=UserHandle.getAppId(filterUid);
  final long now=SystemClock.elapsedRealtime();
synchronized (mLock) {
    pw.println(""String_Node_Str"" + Arrays.toString(mStartedUsers));
    pw.println(""String_Node_Str"");
    if (mJobs.size() > 0) {
      mJobs.forEachJob(new JobStatusFunctor(){
        private int index=0;
        @Override public void process(        JobStatus job){
          pw.print(""String_Node_Str"");
          pw.print(index++);
          pw.print(""String_Node_Str"");
          pw.println(job.toShortString());
          if (!job.shouldDump(filterUidFinal)) {
            return;
          }
          job.dump(pw,""String_Node_Str"",true);
          pw.print(""String_Node_Str"");
          pw.print(mHandler.isReadyToBeExecutedLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(job.isReady());
          pw.print(""String_Node_Str"");
          pw.print(mPendingJobs.contains(job));
          pw.print(""String_Node_Str"");
          pw.print(isCurrentlyActiveLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
          pw.println(""String_Node_Str"");
        }
      }
);
    }
 else {
      pw.println(""String_Node_Str"");
    }
    for (int i=0; i < mControllers.size(); i++) {
      pw.println();
      mControllers.get(i).dumpControllerStateLocked(pw,filterUidFinal);
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mUidPriorityOverride.size(); i++) {
      int uid=mUidPriorityOverride.keyAt(i);
      if (filterUidFinal == -1 || filterUidFinal == UserHandle.getAppId(uid)) {
        pw.print(""String_Node_Str"");
        pw.print(UserHandle.formatUid(uid));
        pw.print(""String_Node_Str"");
        pw.println(mUidPriorityOverride.valueAt(i));
      }
    }
    pw.println();
    mJobPackageTracker.dump(pw,""String_Node_Str"",filterUidFinal);
    pw.println();
    if (mJobPackageTracker.dumpHistory(pw,""String_Node_Str"",filterUidFinal)) {
      pw.println();
    }
    pw.println(""String_Node_Str"");
    for (int i=0; i < mPendingJobs.size(); i++) {
      JobStatus job=mPendingJobs.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      pw.println(job.toShortString());
      job.dump(pw,""String_Node_Str"",false);
      int priority=evaluateJobPriorityLocked(job);
      if (priority != JobInfo.PRIORITY_DEFAULT) {
        pw.print(""String_Node_Str"");
        pw.println(priority);
      }
      pw.print(""String_Node_Str"");
      pw.println(job.getTag());
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mActiveServices.size(); i++) {
      JobServiceContext jsc=mActiveServices.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      if (jsc.getRunningJob() == null) {
        pw.println(""String_Node_Str"");
        continue;
      }
 else {
        pw.println(jsc.getRunningJob().toShortString());
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(now - jsc.getExecutionStartTimeElapsed(),pw);
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(jsc.getTimeoutElapsed() - now,pw);
        pw.println();
        jsc.getRunningJob().dump(pw,""String_Node_Str"",false);
        int priority=evaluateJobPriorityLocked(jsc.getRunningJob());
        if (priority != JobInfo.PRIORITY_DEFAULT) {
          pw.print(""String_Node_Str"");
          pw.println(priority);
        }
      }
    }
    if (filterUid == -1) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.println(mReadyToRock);
      pw.print(""String_Node_Str"");
      pw.println(mReportedActive);
      pw.print(""String_Node_Str"");
      pw.println(mMaxActiveJobs);
    }
  }
  pw.println();
}",0.8584916794523781
191793,"@Override public void process(JobStatus job){
  pw.print(""String_Node_Str"");
  pw.print(index++);
  pw.print(""String_Node_Str"");
  pw.println(job.toShortString());
  if (filterUidFinal != -1 && job.getUid() != filterUidFinal && job.getSourceUid() != filterUidFinal) {
    return;
  }
  job.dump(pw,""String_Node_Str"",true);
  pw.print(""String_Node_Str"");
  pw.print(mHandler.isReadyToBeExecutedLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(job.isReady());
  pw.print(""String_Node_Str"");
  pw.print(mPendingJobs.contains(job));
  pw.print(""String_Node_Str"");
  pw.print(isCurrentlyActiveLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
  pw.println(""String_Node_Str"");
}","@Override public void process(JobStatus job){
  pw.print(""String_Node_Str"");
  pw.print(index++);
  pw.print(""String_Node_Str"");
  pw.println(job.toShortString());
  if (!job.shouldDump(filterUidFinal)) {
    return;
  }
  job.dump(pw,""String_Node_Str"",true);
  pw.print(""String_Node_Str"");
  pw.print(mHandler.isReadyToBeExecutedLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(job.isReady());
  pw.print(""String_Node_Str"");
  pw.print(mPendingJobs.contains(job));
  pw.print(""String_Node_Str"");
  pw.print(isCurrentlyActiveLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
  pw.println(""String_Node_Str"");
}",0.9313517338995048
191794,"@Override public void process(JobStatus jobStatus){
  pw.print(""String_Node_Str"");
  pw.print(jobStatus.getSourcePackageName());
  pw.print(""String_Node_Str"");
  pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
}","@Override public void process(JobStatus jobStatus){
  if (!jobStatus.shouldDump(filterUid)) {
    return;
  }
  pw.print(""String_Node_Str"");
  pw.print(jobStatus.getSourcePackageName());
  pw.print(""String_Node_Str"");
  pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
}",0.8960573476702509
191795,"@Override public void dumpControllerStateLocked(final PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mAppIdleParoleOn);
  mJobSchedulerService.getJobStore().forEachJob(new JobStore.JobStatusFunctor(){
    @Override public void process(    JobStatus jobStatus){
      pw.print(""String_Node_Str"");
      pw.print(jobStatus.getSourcePackageName());
      pw.print(""String_Node_Str"");
      pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
    }
  }
);
  pw.println();
}","@Override public void dumpControllerStateLocked(final PrintWriter pw,final int filterUid){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mAppIdleParoleOn);
  mJobSchedulerService.getJobStore().forEachJob(new JobStore.JobStatusFunctor(){
    @Override public void process(    JobStatus jobStatus){
      if (!jobStatus.shouldDump(filterUid)) {
        return;
      }
      pw.print(""String_Node_Str"");
      pw.print(jobStatus.getSourcePackageName());
      pw.print(""String_Node_Str"");
      pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
    }
  }
);
  pw.println();
}",0.9230769230769232
191796,"@Override public void dumpControllerStateLocked(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mChargeTracker.isOnStablePower());
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  if (it.hasNext()) {
    pw.print(String.valueOf(it.next().hashCode()));
  }
  while (it.hasNext()) {
    pw.print(""String_Node_Str"" + String.valueOf(it.next().hashCode()));
  }
  pw.println();
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mChargeTracker.isOnStablePower());
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  if (it.hasNext()) {
    JobStatus jobStatus=it.next();
    if (jobStatus.shouldDump(filterUid)) {
      pw.print(String.valueOf(jobStatus.hashCode()));
    }
  }
  while (it.hasNext()) {
    JobStatus jobStatus=it.next();
    if (jobStatus.shouldDump(filterUid)) {
      pw.print(""String_Node_Str"" + String.valueOf(jobStatus.hashCode()));
    }
  }
  pw.println();
}",0.6936758893280632
191797,"@Override public void dumpControllerStateLocked(PrintWriter pw){
  pw.println(""String_Node_Str"");
  for (int i=0; i < mTrackedJobs.size(); i++) {
    final JobStatus js=mTrackedJobs.get(i);
    pw.println(String.valueOf(js.getJobId() + ""String_Node_Str"" + js.getUid()) + ""String_Node_Str"" + js.hasConnectivityConstraint()+ ""String_Node_Str""+ js.hasUnmeteredConstraint()+ ""String_Node_Str""+ js.hasNotRoamingConstraint());
  }
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  for (int i=0; i < mTrackedJobs.size(); i++) {
    final JobStatus js=mTrackedJobs.get(i);
    if (js.shouldDump(filterUid)) {
      pw.println(String.valueOf(js.getJobId() + ""String_Node_Str"" + js.getUid()) + ""String_Node_Str"" + js.hasConnectivityConstraint()+ ""String_Node_Str""+ js.hasUnmeteredConstraint()+ ""String_Node_Str""+ js.hasNotRoamingConstraint());
    }
  }
}",0.9362637362637364
191798,"@Override public void dumpControllerStateLocked(PrintWriter pw){
  pw.println(""String_Node_Str"");
  boolean printed=false;
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    if (!printed) {
      pw.print(""String_Node_Str"");
      printed=true;
    }
 else {
      pw.print(""String_Node_Str"");
    }
    pw.print(System.identityHashCode(it.next()));
  }
  if (printed) {
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      pw.print(""String_Node_Str"");
      pw.print(mObservers.keyAt(i));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      int M=obs.mJobs.size();
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        pw.print(System.identityHashCode(inst.mJobStatus));
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  boolean printed=false;
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    JobStatus js=it.next();
    if (!js.shouldDump(filterUid)) {
      continue;
    }
    if (!printed) {
      pw.print(""String_Node_Str"");
      printed=true;
    }
 else {
      pw.print(""String_Node_Str"");
    }
    pw.print(System.identityHashCode(it.next()));
  }
  if (printed) {
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      int M=obs.mJobs.size();
      boolean shouldDump=false;
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        if (inst.mJobStatus.shouldDump(filterUid)) {
          shouldDump=true;
          break;
        }
      }
      if (!shouldDump) {
        continue;
      }
      pw.print(""String_Node_Str"");
      pw.print(mObservers.keyAt(i));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        pw.print(System.identityHashCode(inst.mJobStatus));
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}",0.8101092896174863
191799,"/** 
 * Callback for when a job is completed.
 * @param needsReschedule Whether the implementing class should reschedule this job.
 */
public void onJobCompleted(JobStatus jobStatus,boolean needsReschedule);","/** 
 * Callback for when a job is completed.
 * @param needsReschedule Whether the implementing class should reschedule this job.
 */
void onJobCompleted(JobStatus jobStatus,boolean needsReschedule);",0.9828009828009828
191800,"public void noteInactive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.decActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.decActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
  rebatchIfNeeded(now);
}","public void noteInactive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.decActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.decActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
  rebatchIfNeeded(now);
  addEvent(EVENT_STOP_JOB,job.getSourceUid(),job.getBatteryName());
}",0.9112271540469974
191801,"public void noteActive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  rebatchIfNeeded(now);
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.incActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.incActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
}","public void noteActive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  rebatchIfNeeded(now);
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.incActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.incActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
  addEvent(EVENT_START_JOB,job.getSourceUid(),job.getBatteryName());
}",0.90956749672346
191802,"public void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  final long nowEllapsed=SystemClock.elapsedRealtime();
  final DataSet total;
  if (mLastDataSets[0] != null) {
    total=new DataSet(mLastDataSets[0]);
    mLastDataSets[0].addTo(total,now);
  }
 else {
    total=new DataSet(mCurDataSet);
  }
  mCurDataSet.addTo(total,now);
  for (int i=1; i < mLastDataSets.length; i++) {
    if (mLastDataSets[i] != null) {
      mLastDataSets[i].dump(pw,""String_Node_Str"",prefix,now,nowEllapsed);
      pw.println();
    }
  }
  total.dump(pw,""String_Node_Str"",prefix,now,nowEllapsed);
}","public void dump(PrintWriter pw,String prefix,int filterUid){
  final long now=SystemClock.uptimeMillis();
  final long nowEllapsed=SystemClock.elapsedRealtime();
  final DataSet total;
  if (mLastDataSets[0] != null) {
    total=new DataSet(mLastDataSets[0]);
    mLastDataSets[0].addTo(total,now);
  }
 else {
    total=new DataSet(mCurDataSet);
  }
  mCurDataSet.addTo(total,now);
  for (int i=1; i < mLastDataSets.length; i++) {
    if (mLastDataSets[i] != null) {
      mLastDataSets[i].dump(pw,""String_Node_Str"",prefix,now,nowEllapsed,filterUid);
      pw.println();
    }
  }
  total.dump(pw,""String_Node_Str"",prefix,now,nowEllapsed,filterUid);
}",0.9732704402515724
191803,"void dumpInternal(final PrintWriter pw,String[] args){
  int filterUid=-1;
  if (!ArrayUtils.isEmpty(args)) {
    try {
      filterUid=getContext().getPackageManager().getPackageUid(args[0],PackageManager.MATCH_UNINSTALLED_PACKAGES);
    }
 catch (    NameNotFoundException ignored) {
    }
  }
  final int filterUidFinal=filterUid;
  final long now=SystemClock.elapsedRealtime();
synchronized (mLock) {
    pw.println(""String_Node_Str"" + Arrays.toString(mStartedUsers));
    pw.println(""String_Node_Str"");
    if (mJobs.size() > 0) {
      mJobs.forEachJob(new JobStatusFunctor(){
        private int index=0;
        @Override public void process(        JobStatus job){
          pw.print(""String_Node_Str"");
          pw.print(index++);
          pw.print(""String_Node_Str"");
          pw.println(job.toShortString());
          if (filterUidFinal != -1 && job.getUid() != filterUidFinal && job.getSourceUid() != filterUidFinal) {
            return;
          }
          job.dump(pw,""String_Node_Str"",true);
          pw.print(""String_Node_Str"");
          pw.print(mHandler.isReadyToBeExecutedLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(job.isReady());
          pw.print(""String_Node_Str"");
          pw.print(mPendingJobs.contains(job));
          pw.print(""String_Node_Str"");
          pw.print(isCurrentlyActiveLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
          pw.println(""String_Node_Str"");
        }
      }
);
    }
 else {
      pw.println(""String_Node_Str"");
    }
    for (int i=0; i < mControllers.size(); i++) {
      pw.println();
      mControllers.get(i).dumpControllerStateLocked(pw);
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mUidPriorityOverride.size(); i++) {
      pw.print(""String_Node_Str"");
      pw.print(UserHandle.formatUid(mUidPriorityOverride.keyAt(i)));
      pw.print(""String_Node_Str"");
      pw.println(mUidPriorityOverride.valueAt(i));
    }
    pw.println();
    mJobPackageTracker.dump(pw,""String_Node_Str"");
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mPendingJobs.size(); i++) {
      JobStatus job=mPendingJobs.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      pw.println(job.toShortString());
      job.dump(pw,""String_Node_Str"",false);
      int priority=evaluateJobPriorityLocked(job);
      if (priority != JobInfo.PRIORITY_DEFAULT) {
        pw.print(""String_Node_Str"");
        pw.println(priority);
      }
      pw.print(""String_Node_Str"");
      pw.println(job.getTag());
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mActiveServices.size(); i++) {
      JobServiceContext jsc=mActiveServices.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      if (jsc.getRunningJob() == null) {
        pw.println(""String_Node_Str"");
        continue;
      }
 else {
        pw.println(jsc.getRunningJob().toShortString());
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(now - jsc.getExecutionStartTimeElapsed(),pw);
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(jsc.getTimeoutElapsed() - now,pw);
        pw.println();
        jsc.getRunningJob().dump(pw,""String_Node_Str"",false);
        int priority=evaluateJobPriorityLocked(jsc.getRunningJob());
        if (priority != JobInfo.PRIORITY_DEFAULT) {
          pw.print(""String_Node_Str"");
          pw.println(priority);
        }
      }
    }
    pw.println();
    pw.print(""String_Node_Str"");
    pw.println(mReadyToRock);
    pw.print(""String_Node_Str"");
    pw.println(mReportedActive);
    pw.print(""String_Node_Str"");
    pw.println(mMaxActiveJobs);
  }
  pw.println();
}","void dumpInternal(final PrintWriter pw,String[] args){
  int filterUid=-1;
  if (!ArrayUtils.isEmpty(args)) {
    int opti=0;
    while (opti < args.length) {
      String arg=args[opti];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        break;
      }
      opti++;
    }
    if (opti < args.length) {
      String pkg=args[opti];
      try {
        filterUid=getContext().getPackageManager().getPackageUid(pkg,PackageManager.MATCH_UNINSTALLED_PACKAGES);
      }
 catch (      NameNotFoundException ignored) {
        pw.println(""String_Node_Str"" + pkg);
        return;
      }
    }
  }
  final int filterUidFinal=UserHandle.getAppId(filterUid);
  final long now=SystemClock.elapsedRealtime();
synchronized (mLock) {
    pw.println(""String_Node_Str"" + Arrays.toString(mStartedUsers));
    pw.println(""String_Node_Str"");
    if (mJobs.size() > 0) {
      mJobs.forEachJob(new JobStatusFunctor(){
        private int index=0;
        @Override public void process(        JobStatus job){
          pw.print(""String_Node_Str"");
          pw.print(index++);
          pw.print(""String_Node_Str"");
          pw.println(job.toShortString());
          if (!job.shouldDump(filterUidFinal)) {
            return;
          }
          job.dump(pw,""String_Node_Str"",true);
          pw.print(""String_Node_Str"");
          pw.print(mHandler.isReadyToBeExecutedLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(job.isReady());
          pw.print(""String_Node_Str"");
          pw.print(mPendingJobs.contains(job));
          pw.print(""String_Node_Str"");
          pw.print(isCurrentlyActiveLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
          pw.println(""String_Node_Str"");
        }
      }
);
    }
 else {
      pw.println(""String_Node_Str"");
    }
    for (int i=0; i < mControllers.size(); i++) {
      pw.println();
      mControllers.get(i).dumpControllerStateLocked(pw,filterUidFinal);
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mUidPriorityOverride.size(); i++) {
      int uid=mUidPriorityOverride.keyAt(i);
      if (filterUidFinal == -1 || filterUidFinal == UserHandle.getAppId(uid)) {
        pw.print(""String_Node_Str"");
        pw.print(UserHandle.formatUid(uid));
        pw.print(""String_Node_Str"");
        pw.println(mUidPriorityOverride.valueAt(i));
      }
    }
    pw.println();
    mJobPackageTracker.dump(pw,""String_Node_Str"",filterUidFinal);
    pw.println();
    if (mJobPackageTracker.dumpHistory(pw,""String_Node_Str"",filterUidFinal)) {
      pw.println();
    }
    pw.println(""String_Node_Str"");
    for (int i=0; i < mPendingJobs.size(); i++) {
      JobStatus job=mPendingJobs.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      pw.println(job.toShortString());
      job.dump(pw,""String_Node_Str"",false);
      int priority=evaluateJobPriorityLocked(job);
      if (priority != JobInfo.PRIORITY_DEFAULT) {
        pw.print(""String_Node_Str"");
        pw.println(priority);
      }
      pw.print(""String_Node_Str"");
      pw.println(job.getTag());
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mActiveServices.size(); i++) {
      JobServiceContext jsc=mActiveServices.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      if (jsc.getRunningJob() == null) {
        pw.println(""String_Node_Str"");
        continue;
      }
 else {
        pw.println(jsc.getRunningJob().toShortString());
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(now - jsc.getExecutionStartTimeElapsed(),pw);
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(jsc.getTimeoutElapsed() - now,pw);
        pw.println();
        jsc.getRunningJob().dump(pw,""String_Node_Str"",false);
        int priority=evaluateJobPriorityLocked(jsc.getRunningJob());
        if (priority != JobInfo.PRIORITY_DEFAULT) {
          pw.print(""String_Node_Str"");
          pw.println(priority);
        }
      }
    }
    if (filterUid == -1) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.println(mReadyToRock);
      pw.print(""String_Node_Str"");
      pw.println(mReportedActive);
      pw.print(""String_Node_Str"");
      pw.println(mMaxActiveJobs);
    }
  }
  pw.println();
}",0.8584916794523781
191804,"@Override public void process(JobStatus job){
  pw.print(""String_Node_Str"");
  pw.print(index++);
  pw.print(""String_Node_Str"");
  pw.println(job.toShortString());
  if (filterUidFinal != -1 && job.getUid() != filterUidFinal && job.getSourceUid() != filterUidFinal) {
    return;
  }
  job.dump(pw,""String_Node_Str"",true);
  pw.print(""String_Node_Str"");
  pw.print(mHandler.isReadyToBeExecutedLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(job.isReady());
  pw.print(""String_Node_Str"");
  pw.print(mPendingJobs.contains(job));
  pw.print(""String_Node_Str"");
  pw.print(isCurrentlyActiveLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
  pw.println(""String_Node_Str"");
}","@Override public void process(JobStatus job){
  pw.print(""String_Node_Str"");
  pw.print(index++);
  pw.print(""String_Node_Str"");
  pw.println(job.toShortString());
  if (!job.shouldDump(filterUidFinal)) {
    return;
  }
  job.dump(pw,""String_Node_Str"",true);
  pw.print(""String_Node_Str"");
  pw.print(mHandler.isReadyToBeExecutedLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(job.isReady());
  pw.print(""String_Node_Str"");
  pw.print(mPendingJobs.contains(job));
  pw.print(""String_Node_Str"");
  pw.print(isCurrentlyActiveLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
  pw.println(""String_Node_Str"");
}",0.9313517338995048
191805,"@Override public void process(JobStatus jobStatus){
  pw.print(""String_Node_Str"");
  pw.print(jobStatus.getSourcePackageName());
  pw.print(""String_Node_Str"");
  pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
}","@Override public void process(JobStatus jobStatus){
  if (!jobStatus.shouldDump(filterUid)) {
    return;
  }
  pw.print(""String_Node_Str"");
  pw.print(jobStatus.getSourcePackageName());
  pw.print(""String_Node_Str"");
  pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
}",0.8960573476702509
191806,"@Override public void dumpControllerStateLocked(final PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mAppIdleParoleOn);
  mJobSchedulerService.getJobStore().forEachJob(new JobStore.JobStatusFunctor(){
    @Override public void process(    JobStatus jobStatus){
      pw.print(""String_Node_Str"");
      pw.print(jobStatus.getSourcePackageName());
      pw.print(""String_Node_Str"");
      pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
    }
  }
);
  pw.println();
}","@Override public void dumpControllerStateLocked(final PrintWriter pw,final int filterUid){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mAppIdleParoleOn);
  mJobSchedulerService.getJobStore().forEachJob(new JobStore.JobStatusFunctor(){
    @Override public void process(    JobStatus jobStatus){
      if (!jobStatus.shouldDump(filterUid)) {
        return;
      }
      pw.print(""String_Node_Str"");
      pw.print(jobStatus.getSourcePackageName());
      pw.print(""String_Node_Str"");
      pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
    }
  }
);
  pw.println();
}",0.9230769230769232
191807,"@Override public void dumpControllerStateLocked(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mChargeTracker.isOnStablePower());
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  if (it.hasNext()) {
    pw.print(String.valueOf(it.next().hashCode()));
  }
  while (it.hasNext()) {
    pw.print(""String_Node_Str"" + String.valueOf(it.next().hashCode()));
  }
  pw.println();
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mChargeTracker.isOnStablePower());
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  if (it.hasNext()) {
    JobStatus jobStatus=it.next();
    if (jobStatus.shouldDump(filterUid)) {
      pw.print(String.valueOf(jobStatus.hashCode()));
    }
  }
  while (it.hasNext()) {
    JobStatus jobStatus=it.next();
    if (jobStatus.shouldDump(filterUid)) {
      pw.print(""String_Node_Str"" + String.valueOf(jobStatus.hashCode()));
    }
  }
  pw.println();
}",0.6936758893280632
191808,"@Override public void dumpControllerStateLocked(PrintWriter pw){
  pw.println(""String_Node_Str"");
  for (int i=0; i < mTrackedJobs.size(); i++) {
    final JobStatus js=mTrackedJobs.get(i);
    pw.println(String.valueOf(js.getJobId() + ""String_Node_Str"" + js.getUid()) + ""String_Node_Str"" + js.hasConnectivityConstraint()+ ""String_Node_Str""+ js.hasUnmeteredConstraint()+ ""String_Node_Str""+ js.hasNotRoamingConstraint());
  }
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  for (int i=0; i < mTrackedJobs.size(); i++) {
    final JobStatus js=mTrackedJobs.get(i);
    if (js.shouldDump(filterUid)) {
      pw.println(String.valueOf(js.getJobId() + ""String_Node_Str"" + js.getUid()) + ""String_Node_Str"" + js.hasConnectivityConstraint()+ ""String_Node_Str""+ js.hasUnmeteredConstraint()+ ""String_Node_Str""+ js.hasNotRoamingConstraint());
    }
  }
}",0.9362637362637364
191809,"@Override public void dumpControllerStateLocked(PrintWriter pw){
  pw.println(""String_Node_Str"");
  boolean printed=false;
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    if (!printed) {
      pw.print(""String_Node_Str"");
      printed=true;
    }
 else {
      pw.print(""String_Node_Str"");
    }
    pw.print(System.identityHashCode(it.next()));
  }
  if (printed) {
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      pw.print(""String_Node_Str"");
      pw.print(mObservers.keyAt(i));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      int M=obs.mJobs.size();
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        pw.print(System.identityHashCode(inst.mJobStatus));
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  boolean printed=false;
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    JobStatus js=it.next();
    if (!js.shouldDump(filterUid)) {
      continue;
    }
    if (!printed) {
      pw.print(""String_Node_Str"");
      printed=true;
    }
 else {
      pw.print(""String_Node_Str"");
    }
    pw.print(System.identityHashCode(it.next()));
  }
  if (printed) {
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      int M=obs.mJobs.size();
      boolean shouldDump=false;
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        if (inst.mJobStatus.shouldDump(filterUid)) {
          shouldDump=true;
          break;
        }
      }
      if (!shouldDump) {
        continue;
      }
      pw.print(""String_Node_Str"");
      pw.print(mObservers.keyAt(i));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        pw.print(System.identityHashCode(inst.mJobStatus));
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}",0.8101092896174863
191810,"/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification);
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxNotifications && !childWithVisibleSummary || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}","/** 
 * Updates expanded, dimmed and locked states of notification rows.
 */
protected void updateRowStates(){
  mKeyguardIconOverflowContainer.getIconsView().removeAllViews();
  ArrayList<Entry> activeNotifications=mNotificationData.getActiveNotifications();
  final int N=activeNotifications.size();
  int visibleNotifications=0;
  boolean onKeyguard=mState == StatusBarState.KEYGUARD;
  int maxNotifications=0;
  if (onKeyguard) {
    maxNotifications=getMaxKeyguardNotifications(true);
  }
  for (int i=0; i < N; i++) {
    NotificationData.Entry entry=activeNotifications.get(i);
    boolean childNotification=mGroupManager.isChildInGroupWithSummary(entry.notification);
    if (onKeyguard) {
      entry.row.setOnKeyguard(true);
    }
 else {
      entry.row.setOnKeyguard(false);
      entry.row.setSystemExpanded(visibleNotifications == 0 && !childNotification);
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(entry.notification) && !entry.row.isRemoved();
    boolean childWithVisibleSummary=childNotification && mGroupManager.getGroupSummary(entry.notification).getVisibility() == View.VISIBLE;
    boolean showOnKeyguard=shouldShowOnKeyguard(entry.notification);
    if (suppressedSummary || (isLockscreenPublicMode() && !mShowLockscreenNotifications) || (onKeyguard && (visibleNotifications >= maxNotifications && !childWithVisibleSummary || !showOnKeyguard))) {
      entry.row.setVisibility(View.GONE);
      if (onKeyguard && showOnKeyguard && !childNotification&& !suppressedSummary) {
        mKeyguardIconOverflowContainer.getIconsView().addNotification(entry);
      }
    }
 else {
      boolean wasGone=entry.row.getVisibility() == View.GONE;
      entry.row.setVisibility(View.VISIBLE);
      if (!childNotification) {
        if (wasGone) {
          mStackScroller.generateAddAnimation(entry.row,!showOnKeyguard);
        }
        visibleNotifications++;
      }
    }
  }
  mStackScroller.updateOverflowContainerVisibility(onKeyguard && mKeyguardIconOverflowContainer.getIconsView().getChildCount() > 0);
  mStackScroller.changeViewPosition(mDismissView,mStackScroller.getChildCount() - 1);
  mStackScroller.changeViewPosition(mEmptyShadeView,mStackScroller.getChildCount() - 2);
  mStackScroller.changeViewPosition(mKeyguardIconOverflowContainer,mStackScroller.getChildCount() - 3);
}",0.9944158075601376
191811,"public void removeAllChildren(){
  List<ExpandableNotificationRow> notificationChildren=mChildrenContainer.getNotificationChildren();
  ArrayList<ExpandableNotificationRow> clonedList=new ArrayList<>(notificationChildren);
  for (int i=0; i < clonedList.size(); i++) {
    ExpandableNotificationRow row=clonedList.get(i);
    mChildrenContainer.removeNotification(row);
    mHeaderUtil.restoreNotificationHeader(row);
    row.setIsChildInGroup(false,null);
  }
  onChildrenCountChanged();
}","public void removeAllChildren(){
  List<ExpandableNotificationRow> notificationChildren=mChildrenContainer.getNotificationChildren();
  ArrayList<ExpandableNotificationRow> clonedList=new ArrayList<>(notificationChildren);
  for (int i=0; i < clonedList.size(); i++) {
    ExpandableNotificationRow row=clonedList.get(i);
    if (row.keepInParent()) {
      continue;
    }
    mChildrenContainer.removeNotification(row);
    mHeaderUtil.restoreNotificationHeader(row);
    row.setIsChildInGroup(false,null);
  }
  onChildrenCountChanged();
}",0.9496124031007752
191812,"/** 
 * @return whether a given notification is a child in a group which has a summary
 */
public boolean isChildInGroupWithSummary(StatusBarNotification sbn){
  if (!isGroupChild(sbn)) {
    return false;
  }
  NotificationGroup group=mGroupMap.get(getGroupKey(sbn));
  if (group == null || group.summary == null || group.suppressed) {
    return false;
  }
  return true;
}","/** 
 * @return whether a given notification is a child in a group which has a summary
 */
public boolean isChildInGroupWithSummary(StatusBarNotification sbn){
  if (!isGroupChild(sbn)) {
    return false;
  }
  NotificationGroup group=mGroupMap.get(getGroupKey(sbn));
  if (group == null || group.summary == null || group.suppressed) {
    return false;
  }
  if (group.children.isEmpty()) {
    return false;
  }
  return true;
}",0.9057071960297768
191813,"private void removeNotificationChildren(){
  ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>();
  for (int i=0; i < mStackScroller.getChildCount(); i++) {
    View view=mStackScroller.getChildAt(i);
    if (!(view instanceof ExpandableNotificationRow)) {
      continue;
    }
    ExpandableNotificationRow parent=(ExpandableNotificationRow)view;
    List<ExpandableNotificationRow> children=parent.getNotificationChildren();
    List<ExpandableNotificationRow> orderedChildren=mTmpChildOrderMap.get(parent);
    if (children != null) {
      toRemove.clear();
      for (      ExpandableNotificationRow childRow : children) {
        if (orderedChildren == null || !orderedChildren.contains(childRow)) {
          toRemove.add(childRow);
        }
      }
      for (      ExpandableNotificationRow remove : toRemove) {
        parent.removeChildNotification(remove);
        if (mNotificationData.get(remove.getStatusBarNotification().getKey()) == null) {
          mStackScroller.notifyGroupChildRemoved(remove);
        }
      }
    }
  }
}","private void removeNotificationChildren(){
  ArrayList<ExpandableNotificationRow> toRemove=new ArrayList<>();
  for (int i=0; i < mStackScroller.getChildCount(); i++) {
    View view=mStackScroller.getChildAt(i);
    if (!(view instanceof ExpandableNotificationRow)) {
      continue;
    }
    ExpandableNotificationRow parent=(ExpandableNotificationRow)view;
    List<ExpandableNotificationRow> children=parent.getNotificationChildren();
    List<ExpandableNotificationRow> orderedChildren=mTmpChildOrderMap.get(parent);
    if (children != null) {
      toRemove.clear();
      for (      ExpandableNotificationRow childRow : children) {
        if ((orderedChildren == null || !orderedChildren.contains(childRow)) && !childRow.keepInParent()) {
          toRemove.add(childRow);
        }
      }
      for (      ExpandableNotificationRow remove : toRemove) {
        parent.removeChildNotification(remove);
        if (mNotificationData.get(remove.getStatusBarNotification().getKey()) == null) {
          mStackScroller.notifyGroupChildRemoved(remove);
        }
      }
    }
  }
}",0.9860335195530726
191814,"@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    deferRemoval=!mHeadsUpManager.removeNotification(key);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}","@Override public void removeNotification(String key,RankingMap ranking){
  boolean deferRemoval=false;
  if (mHeadsUpManager.isHeadsUp(key)) {
    deferRemoval=!mHeadsUpManager.removeNotification(key);
  }
  if (key.equals(mMediaNotificationKey)) {
    clearCurrentMediaNotification();
    updateMediaMetaData(true,true);
  }
  if (FORCE_REMOTE_INPUT_HISTORY && mRemoteInputController.isSpinning(key)) {
    Entry entry=mNotificationData.get(key);
    StatusBarNotification sbn=entry.notification;
    Notification.Builder b=Notification.Builder.recoverBuilder(mContext,sbn.getNotification().clone());
    CharSequence[] oldHistory=sbn.getNotification().extras.getCharSequenceArray(Notification.EXTRA_REMOTE_INPUT_HISTORY);
    CharSequence[] newHistory;
    if (oldHistory == null) {
      newHistory=new CharSequence[1];
    }
 else {
      newHistory=new CharSequence[oldHistory.length + 1];
      for (int i=0; i < oldHistory.length; i++) {
        newHistory[i + 1]=oldHistory[i];
      }
    }
    newHistory[0]=String.valueOf(entry.remoteInputText);
    b.setRemoteInputHistory(newHistory);
    Notification newNotification=b.build();
    newNotification.contentView=sbn.getNotification().contentView;
    newNotification.bigContentView=sbn.getNotification().bigContentView;
    newNotification.headsUpContentView=sbn.getNotification().headsUpContentView;
    StatusBarNotification newSbn=new StatusBarNotification(sbn.getPackageName(),sbn.getOpPkg(),sbn.getId(),sbn.getTag(),sbn.getUid(),sbn.getInitialPid(),0,newNotification,sbn.getUser(),sbn.getPostTime());
    updateNotification(newSbn,null);
    mKeysKeptForRemoteInput.add(entry.key);
    return;
  }
  if (deferRemoval) {
    mLatestRankingMap=ranking;
    mHeadsUpEntriesToRemoveOnSwitch.add(mHeadsUpManager.getEntry(key));
    return;
  }
  handleGroupSummaryRemoved(key,ranking);
  StatusBarNotification old=removeNotificationViews(key,ranking);
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ old);
  if (old != null) {
    if (CLOSE_PANEL_WHEN_EMPTIED && !hasActiveNotifications() && !mNotificationPanel.isTracking()&& !mNotificationPanel.isQsExpanded()) {
      if (mState == StatusBarState.SHADE) {
        animateCollapsePanels();
      }
 else       if (mState == StatusBarState.SHADE_LOCKED) {
        goToKeyguard();
      }
    }
  }
  setAreThereNotifications();
}",0.9910333048676344
191815,"private void performDismiss(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (mGroupManager.isOnlyChildInSuppressedGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=mGroupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary);
      }
    }
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}","private void performDismiss(View v){
  if (v instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)v;
    if (mGroupManager.isOnlyChildInSuppressedGroup(row.getStatusBarNotification())) {
      ExpandableNotificationRow groupSummary=mGroupManager.getLogicalGroupSummary(row.getStatusBarNotification());
      if (groupSummary.isClearable()) {
        performDismiss(groupSummary);
      }
    }
    row.setDismissed(true);
  }
  final View veto=v.findViewById(R.id.veto);
  if (veto != null && veto.getVisibility() != View.GONE) {
    veto.performClick();
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + v);
}",0.9782270606531882
191816,"/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
          cancelNotificationLocked(r,sendDelete,reason);
          updateLightsLocked();
        }
      }
    }
  }
);
}","/** 
 * Cancels a notification ONLY if it has all of the   {@code mustHaveFlags}and none of the   {@code mustNotHaveFlags}.
 */
void cancelNotification(final int callingUid,final int callingPid,final String pkg,final String tag,final int id,final int mustHaveFlags,final int mustNotHaveFlags,final boolean sendDelete,final int userId,final int reason,final ManagedServiceInfo listener){
  mHandler.post(new Runnable(){
    @Override public void run(){
      String listenerName=listener == null ? null : listener.component.toShortString();
      if (DBG)       EventLogTags.writeNotificationCancel(callingUid,callingPid,pkg,id,tag,userId,mustHaveFlags,mustNotHaveFlags,reason,listenerName);
synchronized (mNotificationList) {
        int index=indexOfNotificationLocked(pkg,tag,id,userId);
        if (index >= 0) {
          NotificationRecord r=mNotificationList.get(index);
          if (reason == REASON_DELEGATE_CLICK) {
            mUsageStats.registerClickedByUser(r);
          }
          if ((r.getNotification().flags & mustHaveFlags) != mustHaveFlags) {
            return;
          }
          if ((r.getNotification().flags & mustNotHaveFlags) != 0) {
            return;
          }
          mNotificationList.remove(index);
          cancelNotificationLocked(r,sendDelete,reason);
          cancelGroupChildrenLocked(r,callingUid,callingPid,listenerName,REASON_GROUP_SUMMARY_CANCELED);
          updateLightsLocked();
        }
      }
    }
  }
);
}",0.9393732970027248
191817,"/** 
 * Callback for when a job is completed.
 * @param needsReschedule Whether the implementing class should reschedule this job.
 */
public void onJobCompleted(JobStatus jobStatus,boolean needsReschedule);","/** 
 * Callback for when a job is completed.
 * @param needsReschedule Whether the implementing class should reschedule this job.
 */
void onJobCompleted(JobStatus jobStatus,boolean needsReschedule);",0.9828009828009828
191818,"public void noteInactive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.decActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.decActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
  rebatchIfNeeded(now);
}","public void noteInactive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.decActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.decActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
  rebatchIfNeeded(now);
  addEvent(EVENT_STOP_JOB,job.getSourceUid(),job.getBatteryName());
}",0.9112271540469974
191819,"public void noteActive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  rebatchIfNeeded(now);
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.incActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.incActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
}","public void noteActive(JobStatus job){
  final long now=SystemClock.uptimeMillis();
  rebatchIfNeeded(now);
  if (job.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
    mCurDataSet.incActiveTop(job.getSourceUid(),job.getSourcePackageName(),now);
  }
 else {
    mCurDataSet.incActive(job.getSourceUid(),job.getSourcePackageName(),now);
  }
  addEvent(EVENT_START_JOB,job.getSourceUid(),job.getBatteryName());
}",0.90956749672346
191820,"public void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  final long nowEllapsed=SystemClock.elapsedRealtime();
  final DataSet total;
  if (mLastDataSets[0] != null) {
    total=new DataSet(mLastDataSets[0]);
    mLastDataSets[0].addTo(total,now);
  }
 else {
    total=new DataSet(mCurDataSet);
  }
  mCurDataSet.addTo(total,now);
  for (int i=1; i < mLastDataSets.length; i++) {
    if (mLastDataSets[i] != null) {
      mLastDataSets[i].dump(pw,""String_Node_Str"",prefix,now,nowEllapsed);
      pw.println();
    }
  }
  total.dump(pw,""String_Node_Str"",prefix,now,nowEllapsed);
}","public void dump(PrintWriter pw,String prefix,int filterUid){
  final long now=SystemClock.uptimeMillis();
  final long nowEllapsed=SystemClock.elapsedRealtime();
  final DataSet total;
  if (mLastDataSets[0] != null) {
    total=new DataSet(mLastDataSets[0]);
    mLastDataSets[0].addTo(total,now);
  }
 else {
    total=new DataSet(mCurDataSet);
  }
  mCurDataSet.addTo(total,now);
  for (int i=1; i < mLastDataSets.length; i++) {
    if (mLastDataSets[i] != null) {
      mLastDataSets[i].dump(pw,""String_Node_Str"",prefix,now,nowEllapsed,filterUid);
      pw.println();
    }
  }
  total.dump(pw,""String_Node_Str"",prefix,now,nowEllapsed,filterUid);
}",0.9732704402515724
191821,"void dumpInternal(final PrintWriter pw,String[] args){
  int filterUid=-1;
  if (!ArrayUtils.isEmpty(args)) {
    try {
      filterUid=getContext().getPackageManager().getPackageUid(args[0],PackageManager.MATCH_UNINSTALLED_PACKAGES);
    }
 catch (    NameNotFoundException ignored) {
    }
  }
  final int filterUidFinal=filterUid;
  final long now=SystemClock.elapsedRealtime();
synchronized (mLock) {
    pw.println(""String_Node_Str"" + Arrays.toString(mStartedUsers));
    pw.println(""String_Node_Str"");
    if (mJobs.size() > 0) {
      mJobs.forEachJob(new JobStatusFunctor(){
        private int index=0;
        @Override public void process(        JobStatus job){
          pw.print(""String_Node_Str"");
          pw.print(index++);
          pw.print(""String_Node_Str"");
          pw.println(job.toShortString());
          if (filterUidFinal != -1 && job.getUid() != filterUidFinal && job.getSourceUid() != filterUidFinal) {
            return;
          }
          job.dump(pw,""String_Node_Str"",true);
          pw.print(""String_Node_Str"");
          pw.print(mHandler.isReadyToBeExecutedLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(job.isReady());
          pw.print(""String_Node_Str"");
          pw.print(mPendingJobs.contains(job));
          pw.print(""String_Node_Str"");
          pw.print(isCurrentlyActiveLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
          pw.println(""String_Node_Str"");
        }
      }
);
    }
 else {
      pw.println(""String_Node_Str"");
    }
    for (int i=0; i < mControllers.size(); i++) {
      pw.println();
      mControllers.get(i).dumpControllerStateLocked(pw);
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mUidPriorityOverride.size(); i++) {
      pw.print(""String_Node_Str"");
      pw.print(UserHandle.formatUid(mUidPriorityOverride.keyAt(i)));
      pw.print(""String_Node_Str"");
      pw.println(mUidPriorityOverride.valueAt(i));
    }
    pw.println();
    mJobPackageTracker.dump(pw,""String_Node_Str"");
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mPendingJobs.size(); i++) {
      JobStatus job=mPendingJobs.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      pw.println(job.toShortString());
      job.dump(pw,""String_Node_Str"",false);
      int priority=evaluateJobPriorityLocked(job);
      if (priority != JobInfo.PRIORITY_DEFAULT) {
        pw.print(""String_Node_Str"");
        pw.println(priority);
      }
      pw.print(""String_Node_Str"");
      pw.println(job.getTag());
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mActiveServices.size(); i++) {
      JobServiceContext jsc=mActiveServices.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      if (jsc.getRunningJob() == null) {
        pw.println(""String_Node_Str"");
        continue;
      }
 else {
        pw.println(jsc.getRunningJob().toShortString());
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(now - jsc.getExecutionStartTimeElapsed(),pw);
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(jsc.getTimeoutElapsed() - now,pw);
        pw.println();
        jsc.getRunningJob().dump(pw,""String_Node_Str"",false);
        int priority=evaluateJobPriorityLocked(jsc.getRunningJob());
        if (priority != JobInfo.PRIORITY_DEFAULT) {
          pw.print(""String_Node_Str"");
          pw.println(priority);
        }
      }
    }
    pw.println();
    pw.print(""String_Node_Str"");
    pw.println(mReadyToRock);
    pw.print(""String_Node_Str"");
    pw.println(mReportedActive);
    pw.print(""String_Node_Str"");
    pw.println(mMaxActiveJobs);
  }
  pw.println();
}","void dumpInternal(final PrintWriter pw,String[] args){
  int filterUid=-1;
  if (!ArrayUtils.isEmpty(args)) {
    int opti=0;
    while (opti < args.length) {
      String arg=args[opti];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        break;
      }
      opti++;
    }
    if (opti < args.length) {
      String pkg=args[opti];
      try {
        filterUid=getContext().getPackageManager().getPackageUid(pkg,PackageManager.MATCH_UNINSTALLED_PACKAGES);
      }
 catch (      NameNotFoundException ignored) {
        pw.println(""String_Node_Str"" + pkg);
        return;
      }
    }
  }
  final int filterUidFinal=UserHandle.getAppId(filterUid);
  final long now=SystemClock.elapsedRealtime();
synchronized (mLock) {
    pw.println(""String_Node_Str"" + Arrays.toString(mStartedUsers));
    pw.println(""String_Node_Str"");
    if (mJobs.size() > 0) {
      mJobs.forEachJob(new JobStatusFunctor(){
        private int index=0;
        @Override public void process(        JobStatus job){
          pw.print(""String_Node_Str"");
          pw.print(index++);
          pw.print(""String_Node_Str"");
          pw.println(job.toShortString());
          if (!job.shouldDump(filterUidFinal)) {
            return;
          }
          job.dump(pw,""String_Node_Str"",true);
          pw.print(""String_Node_Str"");
          pw.print(mHandler.isReadyToBeExecutedLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(job.isReady());
          pw.print(""String_Node_Str"");
          pw.print(mPendingJobs.contains(job));
          pw.print(""String_Node_Str"");
          pw.print(isCurrentlyActiveLocked(job));
          pw.print(""String_Node_Str"");
          pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
          pw.println(""String_Node_Str"");
        }
      }
);
    }
 else {
      pw.println(""String_Node_Str"");
    }
    for (int i=0; i < mControllers.size(); i++) {
      pw.println();
      mControllers.get(i).dumpControllerStateLocked(pw,filterUidFinal);
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mUidPriorityOverride.size(); i++) {
      int uid=mUidPriorityOverride.keyAt(i);
      if (filterUidFinal == -1 || filterUidFinal == UserHandle.getAppId(uid)) {
        pw.print(""String_Node_Str"");
        pw.print(UserHandle.formatUid(uid));
        pw.print(""String_Node_Str"");
        pw.println(mUidPriorityOverride.valueAt(i));
      }
    }
    pw.println();
    mJobPackageTracker.dump(pw,""String_Node_Str"",filterUidFinal);
    pw.println();
    if (mJobPackageTracker.dumpHistory(pw,""String_Node_Str"",filterUidFinal)) {
      pw.println();
    }
    pw.println(""String_Node_Str"");
    for (int i=0; i < mPendingJobs.size(); i++) {
      JobStatus job=mPendingJobs.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      pw.println(job.toShortString());
      job.dump(pw,""String_Node_Str"",false);
      int priority=evaluateJobPriorityLocked(job);
      if (priority != JobInfo.PRIORITY_DEFAULT) {
        pw.print(""String_Node_Str"");
        pw.println(priority);
      }
      pw.print(""String_Node_Str"");
      pw.println(job.getTag());
    }
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=0; i < mActiveServices.size(); i++) {
      JobServiceContext jsc=mActiveServices.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(""String_Node_Str"");
      if (jsc.getRunningJob() == null) {
        pw.println(""String_Node_Str"");
        continue;
      }
 else {
        pw.println(jsc.getRunningJob().toShortString());
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(now - jsc.getExecutionStartTimeElapsed(),pw);
        pw.print(""String_Node_Str"");
        TimeUtils.formatDuration(jsc.getTimeoutElapsed() - now,pw);
        pw.println();
        jsc.getRunningJob().dump(pw,""String_Node_Str"",false);
        int priority=evaluateJobPriorityLocked(jsc.getRunningJob());
        if (priority != JobInfo.PRIORITY_DEFAULT) {
          pw.print(""String_Node_Str"");
          pw.println(priority);
        }
      }
    }
    if (filterUid == -1) {
      pw.println();
      pw.print(""String_Node_Str"");
      pw.println(mReadyToRock);
      pw.print(""String_Node_Str"");
      pw.println(mReportedActive);
      pw.print(""String_Node_Str"");
      pw.println(mMaxActiveJobs);
    }
  }
  pw.println();
}",0.8584916794523781
191822,"@Override public void process(JobStatus job){
  pw.print(""String_Node_Str"");
  pw.print(index++);
  pw.print(""String_Node_Str"");
  pw.println(job.toShortString());
  if (filterUidFinal != -1 && job.getUid() != filterUidFinal && job.getSourceUid() != filterUidFinal) {
    return;
  }
  job.dump(pw,""String_Node_Str"",true);
  pw.print(""String_Node_Str"");
  pw.print(mHandler.isReadyToBeExecutedLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(job.isReady());
  pw.print(""String_Node_Str"");
  pw.print(mPendingJobs.contains(job));
  pw.print(""String_Node_Str"");
  pw.print(isCurrentlyActiveLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
  pw.println(""String_Node_Str"");
}","@Override public void process(JobStatus job){
  pw.print(""String_Node_Str"");
  pw.print(index++);
  pw.print(""String_Node_Str"");
  pw.println(job.toShortString());
  if (!job.shouldDump(filterUidFinal)) {
    return;
  }
  job.dump(pw,""String_Node_Str"",true);
  pw.print(""String_Node_Str"");
  pw.print(mHandler.isReadyToBeExecutedLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(job.isReady());
  pw.print(""String_Node_Str"");
  pw.print(mPendingJobs.contains(job));
  pw.print(""String_Node_Str"");
  pw.print(isCurrentlyActiveLocked(job));
  pw.print(""String_Node_Str"");
  pw.print(ArrayUtils.contains(mStartedUsers,job.getUserId()));
  pw.println(""String_Node_Str"");
}",0.9313517338995048
191823,"@Override public void process(JobStatus jobStatus){
  pw.print(""String_Node_Str"");
  pw.print(jobStatus.getSourcePackageName());
  pw.print(""String_Node_Str"");
  pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
}","@Override public void process(JobStatus jobStatus){
  if (!jobStatus.shouldDump(filterUid)) {
    return;
  }
  pw.print(""String_Node_Str"");
  pw.print(jobStatus.getSourcePackageName());
  pw.print(""String_Node_Str"");
  pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
}",0.8960573476702509
191824,"@Override public void dumpControllerStateLocked(final PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mAppIdleParoleOn);
  mJobSchedulerService.getJobStore().forEachJob(new JobStore.JobStatusFunctor(){
    @Override public void process(    JobStatus jobStatus){
      pw.print(""String_Node_Str"");
      pw.print(jobStatus.getSourcePackageName());
      pw.print(""String_Node_Str"");
      pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
    }
  }
);
  pw.println();
}","@Override public void dumpControllerStateLocked(final PrintWriter pw,final int filterUid){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mAppIdleParoleOn);
  mJobSchedulerService.getJobStore().forEachJob(new JobStore.JobStatusFunctor(){
    @Override public void process(    JobStatus jobStatus){
      if (!jobStatus.shouldDump(filterUid)) {
        return;
      }
      pw.print(""String_Node_Str"");
      pw.print(jobStatus.getSourcePackageName());
      pw.print(""String_Node_Str"");
      pw.println((jobStatus.satisfiedConstraints & JobStatus.CONSTRAINT_APP_NOT_IDLE) != 0);
    }
  }
);
  pw.println();
}",0.9230769230769232
191825,"@Override public void dumpControllerStateLocked(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mChargeTracker.isOnStablePower());
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  if (it.hasNext()) {
    pw.print(String.valueOf(it.next().hashCode()));
  }
  while (it.hasNext()) {
    pw.print(""String_Node_Str"" + String.valueOf(it.next().hashCode()));
  }
  pw.println();
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mChargeTracker.isOnStablePower());
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  if (it.hasNext()) {
    JobStatus jobStatus=it.next();
    if (jobStatus.shouldDump(filterUid)) {
      pw.print(String.valueOf(jobStatus.hashCode()));
    }
  }
  while (it.hasNext()) {
    JobStatus jobStatus=it.next();
    if (jobStatus.shouldDump(filterUid)) {
      pw.print(""String_Node_Str"" + String.valueOf(jobStatus.hashCode()));
    }
  }
  pw.println();
}",0.6936758893280632
191826,"@Override public void dumpControllerStateLocked(PrintWriter pw){
  pw.println(""String_Node_Str"");
  for (int i=0; i < mTrackedJobs.size(); i++) {
    final JobStatus js=mTrackedJobs.get(i);
    pw.println(String.valueOf(js.getJobId() + ""String_Node_Str"" + js.getUid()) + ""String_Node_Str"" + js.hasConnectivityConstraint()+ ""String_Node_Str""+ js.hasUnmeteredConstraint()+ ""String_Node_Str""+ js.hasNotRoamingConstraint());
  }
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  for (int i=0; i < mTrackedJobs.size(); i++) {
    final JobStatus js=mTrackedJobs.get(i);
    if (js.shouldDump(filterUid)) {
      pw.println(String.valueOf(js.getJobId() + ""String_Node_Str"" + js.getUid()) + ""String_Node_Str"" + js.hasConnectivityConstraint()+ ""String_Node_Str""+ js.hasUnmeteredConstraint()+ ""String_Node_Str""+ js.hasNotRoamingConstraint());
    }
  }
}",0.9362637362637364
191827,"@Override public void dumpControllerStateLocked(PrintWriter pw){
  pw.println(""String_Node_Str"");
  boolean printed=false;
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    if (!printed) {
      pw.print(""String_Node_Str"");
      printed=true;
    }
 else {
      pw.print(""String_Node_Str"");
    }
    pw.print(System.identityHashCode(it.next()));
  }
  if (printed) {
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      pw.print(""String_Node_Str"");
      pw.print(mObservers.keyAt(i));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      int M=obs.mJobs.size();
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        pw.print(System.identityHashCode(inst.mJobStatus));
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}","@Override public void dumpControllerStateLocked(PrintWriter pw,int filterUid){
  pw.println(""String_Node_Str"");
  boolean printed=false;
  Iterator<JobStatus> it=mTrackedTasks.iterator();
  while (it.hasNext()) {
    JobStatus js=it.next();
    if (!js.shouldDump(filterUid)) {
      continue;
    }
    if (!printed) {
      pw.print(""String_Node_Str"");
      printed=true;
    }
 else {
      pw.print(""String_Node_Str"");
    }
    pw.print(System.identityHashCode(it.next()));
  }
  if (printed) {
    pw.println();
  }
  int N=mObservers.size();
  if (N > 0) {
    pw.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ObserverInstance obs=mObservers.valueAt(i);
      int M=obs.mJobs.size();
      boolean shouldDump=false;
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        if (inst.mJobStatus.shouldDump(filterUid)) {
          shouldDump=true;
          break;
        }
      }
      if (!shouldDump) {
        continue;
      }
      pw.print(""String_Node_Str"");
      pw.print(mObservers.keyAt(i));
      pw.print(""String_Node_Str"");
      pw.print(System.identityHashCode(obs));
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      for (int j=0; j < M; j++) {
        JobInstance inst=obs.mJobs.valueAt(j);
        pw.print(""String_Node_Str"");
        pw.print(System.identityHashCode(inst.mJobStatus));
        if (inst.mChangedAuthorities != null) {
          pw.println(""String_Node_Str"");
          if (inst.mTriggerPending) {
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentUpdateDelay(),pw);
            pw.print(""String_Node_Str"");
            TimeUtils.formatDuration(inst.mJobStatus.getTriggerContentMaxDelay(),pw);
            pw.println();
          }
          pw.println(""String_Node_Str"");
          for (int k=0; k < inst.mChangedAuthorities.size(); k++) {
            pw.print(""String_Node_Str"");
            pw.println(inst.mChangedAuthorities.valueAt(k));
          }
          if (inst.mChangedUris != null) {
            pw.println(""String_Node_Str"");
            for (int k=0; k < inst.mChangedUris.size(); k++) {
              pw.print(""String_Node_Str"");
              pw.println(inst.mChangedUris.valueAt(k));
            }
          }
        }
 else {
          pw.println();
        }
      }
    }
  }
}",0.8101092896174863
191828,"void positionTask(final TaskRecord task,int position){
  final ActivityRecord topRunningActivity=task.topRunningActivityLocked();
  final boolean wasResumed=topRunningActivity == task.stack.mResumedActivity;
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"");
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
  if (wasResumed) {
    if (mResumedActivity != null) {
      Log.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"" + mResumedActivity + ""String_Node_Str""+ topRunningActivity);
    }
    mResumedActivity=topRunningActivity;
  }
}","void positionTask(final TaskRecord task,int position){
  final ActivityRecord topRunningActivity=task.topRunningActivityLocked();
  final boolean wasResumed=topRunningActivity == task.stack.mResumedActivity;
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"",ON_TOP);
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
  if (wasResumed) {
    if (mResumedActivity != null) {
      Log.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"" + mResumedActivity + ""String_Node_Str""+ topRunningActivity);
    }
    mResumedActivity=topRunningActivity;
  }
}",0.9941027801179444
191829,"void addTask(final TaskRecord task,final boolean toTop,String reason){
  final ActivityStack prevStack=preAddTask(task,reason);
  task.stack=this;
  if (toTop) {
    insertTaskAtTop(task,null);
  }
 else {
    mTaskHistory.add(0,task);
    updateTaskMovement(task,false);
  }
  postAddTask(task,prevStack);
}","void addTask(final TaskRecord task,final boolean toTop,String reason){
  final ActivityStack prevStack=preAddTask(task,reason,toTop);
  task.stack=this;
  if (toTop) {
    insertTaskAtTop(task,null);
  }
 else {
    mTaskHistory.add(0,task);
    updateTaskMovement(task,false);
  }
  postAddTask(task,prevStack);
}",0.990353697749196
191830,"/** 
 * Removes the input task from this stack.
 * @param task to remove.
 * @param reason for removal.
 * @param moving task to another stack. In the case we are moving we don't want to performsome operations on the task like removing it from window manager or recents.
 */
void removeTask(TaskRecord task,String reason,boolean moving){
  if (!moving) {
    mStackSupervisor.removeLockedTaskLocked(task);
    mWindowManager.removeTask(task.taskId);
    if (!StackId.persistTaskBounds(mStackId)) {
      task.updateOverrideConfiguration(null);
    }
  }
  final ActivityRecord r=mResumedActivity;
  if (r != null && r.task == task) {
    mResumedActivity=null;
  }
  final int taskNdx=mTaskHistory.indexOf(task);
  final int topTaskNdx=mTaskHistory.size() - 1;
  if (task.isOverHomeStack() && taskNdx < topTaskNdx) {
    final TaskRecord nextTask=mTaskHistory.get(taskNdx + 1);
    if (!nextTask.isOverHomeStack()) {
      nextTask.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
    }
  }
  mTaskHistory.remove(task);
  updateTaskMovement(task,true);
  if (!moving && task.mActivities.isEmpty()) {
    final boolean isVoiceSession=task.voiceSession != null;
    if (isVoiceSession) {
      try {
        task.voiceSession.taskFinished(task.intent,task.taskId);
      }
 catch (      RemoteException e) {
      }
    }
    if (task.autoRemoveFromRecents() || isVoiceSession) {
      mRecentTasks.remove(task);
      task.removedFromRecents();
    }
  }
  if (mTaskHistory.isEmpty()) {
    if (DEBUG_STACK)     Slog.i(TAG_STACK,""String_Node_Str"" + this);
    if (isOnHomeDisplay() && mStackSupervisor.isFocusedStack(this)) {
      String myReason=reason + ""String_Node_Str"";
      if (mFullscreen || !adjustFocusToNextFocusableStackLocked(task.getTaskToReturnTo(),myReason)) {
        mStackSupervisor.moveHomeStackToFront(myReason);
      }
    }
    if (mStacks != null) {
      mStacks.remove(this);
      mStacks.add(0,this);
    }
    if (!isHomeStack()) {
      mActivityContainer.onTaskListEmptyLocked();
    }
  }
  task.stack=null;
}","/** 
 * Removes the input task from this stack.
 * @param task to remove.
 * @param reason for removal.
 * @param mode task removal mode. Either {@link #REMOVE_TASK_MODE_DESTROYING},  {@link #REMOVE_TASK_MODE_MOVING},   {@link #REMOVE_TASK_MODE_MOVING_TO_TOP}.
 */
void removeTask(TaskRecord task,String reason,int mode){
  if (mode == REMOVE_TASK_MODE_DESTROYING) {
    mStackSupervisor.removeLockedTaskLocked(task);
    mWindowManager.removeTask(task.taskId);
    if (!StackId.persistTaskBounds(mStackId)) {
      task.updateOverrideConfiguration(null);
    }
  }
  final ActivityRecord r=mResumedActivity;
  if (r != null && r.task == task) {
    mResumedActivity=null;
  }
  final int taskNdx=mTaskHistory.indexOf(task);
  final int topTaskNdx=mTaskHistory.size() - 1;
  if (task.isOverHomeStack() && taskNdx < topTaskNdx) {
    final TaskRecord nextTask=mTaskHistory.get(taskNdx + 1);
    if (!nextTask.isOverHomeStack()) {
      nextTask.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
    }
  }
  mTaskHistory.remove(task);
  updateTaskMovement(task,true);
  if (mode == REMOVE_TASK_MODE_DESTROYING && task.mActivities.isEmpty()) {
    final boolean isVoiceSession=task.voiceSession != null;
    if (isVoiceSession) {
      try {
        task.voiceSession.taskFinished(task.intent,task.taskId);
      }
 catch (      RemoteException e) {
      }
    }
    if (task.autoRemoveFromRecents() || isVoiceSession) {
      mRecentTasks.remove(task);
      task.removedFromRecents();
    }
  }
  if (mTaskHistory.isEmpty()) {
    if (DEBUG_STACK)     Slog.i(TAG_STACK,""String_Node_Str"" + this);
    if (isOnHomeDisplay() && mode != REMOVE_TASK_MODE_MOVING_TO_TOP && mStackSupervisor.isFocusedStack(this)) {
      String myReason=reason + ""String_Node_Str"";
      if (mFullscreen || !adjustFocusToNextFocusableStackLocked(task.getTaskToReturnTo(),myReason)) {
        mStackSupervisor.moveHomeStackToFront(myReason);
      }
    }
    if (mStacks != null) {
      mStacks.remove(this);
      mStacks.add(0,this);
    }
    if (!isHomeStack()) {
      mActivityContainer.onTaskListEmptyLocked();
    }
  }
  task.stack=null;
}",0.8958031837916064
191831,"private ActivityStack preAddTask(TaskRecord task,String reason){
  final ActivityStack prevStack=task.stack;
  if (prevStack != null && prevStack != this) {
    prevStack.removeTask(task,reason,MOVING);
  }
  return prevStack;
}","private ActivityStack preAddTask(TaskRecord task,String reason,boolean toTop){
  final ActivityStack prevStack=task.stack;
  if (prevStack != null && prevStack != this) {
    prevStack.removeTask(task,reason,toTop ? REMOVE_TASK_MODE_MOVING_TO_TOP : REMOVE_TASK_MODE_MOVING);
  }
  return prevStack;
}",0.8636363636363636
191832,"void moveTasksToFullscreenStackLocked(int fromStackId,boolean onTop){
  final ActivityStack stack=getStack(fromStackId);
  if (stack == null) {
    return;
  }
  mWindowManager.deferSurfaceLayout();
  try {
    if (fromStackId == DOCKED_STACK_ID) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,null,null,null,PRESERVE_WINDOWS,true,DEFER_RESUME);
          }
        }
      }
      mAllowDockedStackResize=false;
    }
    final ArrayList<TaskRecord> tasks=stack.getAllTasks();
    final int size=tasks.size();
    if (onTop) {
      for (int i=0; i < size; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,onTop,onTop,""String_Node_Str"",ANIMATE);
      }
    }
 else {
      for (int i=size - 1; i >= 0; i--) {
        positionTaskInStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,0);
      }
    }
  }
  finally {
    mAllowDockedStackResize=true;
    mWindowManager.continueSurfaceLayout();
  }
}","void moveTasksToFullscreenStackLocked(int fromStackId,boolean onTop){
  final ActivityStack stack=getStack(fromStackId);
  if (stack == null) {
    return;
  }
  mWindowManager.deferSurfaceLayout();
  try {
    if (fromStackId == DOCKED_STACK_ID) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,null,null,null,PRESERVE_WINDOWS,true,DEFER_RESUME);
          }
        }
      }
      mAllowDockedStackResize=false;
    }
    final ArrayList<TaskRecord> tasks=stack.getAllTasks();
    final int size=tasks.size();
    if (onTop) {
      for (int i=0; i < size; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,onTop,onTop,""String_Node_Str"",ANIMATE,DEFER_RESUME);
      }
      ensureActivitiesVisibleLocked(null,0,PRESERVE_WINDOWS);
      resumeFocusedStackTopActivityLocked();
    }
 else {
      for (int i=size - 1; i >= 0; i--) {
        positionTaskInStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,0);
      }
    }
  }
  finally {
    mAllowDockedStackResize=true;
    mWindowManager.continueSurfaceLayout();
  }
}",0.9502899751449876
191833,"/** 
 * Restores a recent task to a stack
 * @param task The recent task to be restored.
 * @param stackId The stack to restore the task to (default launch stack will be usedif stackId is  {@link android.app.ActivityManager.StackId#INVALID_STACK_ID}).
 * @return true if the task has been restored successfully.
 */
private boolean restoreRecentTaskLocked(TaskRecord task,int stackId){
  if (stackId == INVALID_STACK_ID) {
    stackId=task.getLaunchStackId();
  }
 else   if (stackId == DOCKED_STACK_ID && !task.canGoInDockedStack()) {
    stackId=FULLSCREEN_WORKSPACE_STACK_ID;
  }
  if (task.stack != null) {
    if (task.stack.mStackId == stackId) {
      return true;
    }
    task.stack.removeTask(task,""String_Node_Str"",MOVING);
  }
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,!ON_TOP);
  if (stack == null) {
    if (DEBUG_RECENTS)     Slog.v(TAG_RECENTS,""String_Node_Str"" + task);
    return false;
  }
  stack.addTask(task,false,""String_Node_Str"");
  if (DEBUG_RECENTS)   Slog.v(TAG_RECENTS,""String_Node_Str"" + task + ""String_Node_Str""+ stack);
  final ArrayList<ActivityRecord> activities=task.mActivities;
  for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
    stack.addConfigOverride(activities.get(activityNdx),task);
  }
  return true;
}","/** 
 * Restores a recent task to a stack
 * @param task The recent task to be restored.
 * @param stackId The stack to restore the task to (default launch stack will be usedif stackId is  {@link android.app.ActivityManager.StackId#INVALID_STACK_ID}).
 * @return true if the task has been restored successfully.
 */
private boolean restoreRecentTaskLocked(TaskRecord task,int stackId){
  if (stackId == INVALID_STACK_ID) {
    stackId=task.getLaunchStackId();
  }
 else   if (stackId == DOCKED_STACK_ID && !task.canGoInDockedStack()) {
    stackId=FULLSCREEN_WORKSPACE_STACK_ID;
  }
  if (task.stack != null) {
    if (task.stack.mStackId == stackId) {
      return true;
    }
    task.stack.removeTask(task,""String_Node_Str"",REMOVE_TASK_MODE_MOVING);
  }
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,!ON_TOP);
  if (stack == null) {
    if (DEBUG_RECENTS)     Slog.v(TAG_RECENTS,""String_Node_Str"" + task);
    return false;
  }
  stack.addTask(task,false,""String_Node_Str"");
  if (DEBUG_RECENTS)   Slog.v(TAG_RECENTS,""String_Node_Str"" + task + ""String_Node_Str""+ stack);
  final ArrayList<ActivityRecord> activities=task.mActivities;
  for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
    stack.addConfigOverride(activities.get(activityNdx),task);
  }
  return true;
}",0.9935040122277417
191834,"boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack,ActivityRecord target,ActivityOptions targetOptions){
  if (targetStack != null && isFocusedStack(targetStack)) {
    return targetStack.resumeTopActivityUncheckedLocked(target,targetOptions);
  }
  mFocusedStack.resumeTopActivityUncheckedLocked(null,null);
  return false;
}","boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack,ActivityRecord target,ActivityOptions targetOptions){
  if (targetStack != null && isFocusedStack(targetStack)) {
    return targetStack.resumeTopActivityUncheckedLocked(target,targetOptions);
  }
  final ActivityRecord r=mFocusedStack.topRunningActivityLocked();
  if (r == null || r.state != RESUMED) {
    mFocusedStack.resumeTopActivityUncheckedLocked(null,null);
  }
  return false;
}",0.8482587064676617
191835,"/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.getTopActivity();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}","/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.topRunningActivityLocked();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}",0.9946004319654428
191836,"void positionTask(final TaskRecord task,int position){
  final ActivityRecord topRunningActivity=task.topRunningActivityLocked();
  final boolean wasResumed=topRunningActivity == task.stack.mResumedActivity;
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"");
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
  if (wasResumed) {
    if (mResumedActivity != null) {
      Log.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"" + mResumedActivity + ""String_Node_Str""+ topRunningActivity);
    }
    mResumedActivity=topRunningActivity;
  }
}","void positionTask(final TaskRecord task,int position){
  final ActivityRecord topRunningActivity=task.topRunningActivityLocked();
  final boolean wasResumed=topRunningActivity == task.stack.mResumedActivity;
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"",ON_TOP);
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
  if (wasResumed) {
    if (mResumedActivity != null) {
      Log.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"" + mResumedActivity + ""String_Node_Str""+ topRunningActivity);
    }
    mResumedActivity=topRunningActivity;
  }
}",0.9941027801179444
191837,"void addTask(final TaskRecord task,final boolean toTop,String reason){
  final ActivityStack prevStack=preAddTask(task,reason);
  task.stack=this;
  if (toTop) {
    insertTaskAtTop(task,null);
  }
 else {
    mTaskHistory.add(0,task);
    updateTaskMovement(task,false);
  }
  postAddTask(task,prevStack);
}","void addTask(final TaskRecord task,final boolean toTop,String reason){
  final ActivityStack prevStack=preAddTask(task,reason,toTop);
  task.stack=this;
  if (toTop) {
    insertTaskAtTop(task,null);
  }
 else {
    mTaskHistory.add(0,task);
    updateTaskMovement(task,false);
  }
  postAddTask(task,prevStack);
}",0.990353697749196
191838,"/** 
 * Removes the input task from this stack.
 * @param task to remove.
 * @param reason for removal.
 * @param moving task to another stack. In the case we are moving we don't want to performsome operations on the task like removing it from window manager or recents.
 */
void removeTask(TaskRecord task,String reason,boolean moving){
  if (!moving) {
    mStackSupervisor.removeLockedTaskLocked(task);
    mWindowManager.removeTask(task.taskId);
    if (!StackId.persistTaskBounds(mStackId)) {
      task.updateOverrideConfiguration(null);
    }
  }
  final ActivityRecord r=mResumedActivity;
  if (r != null && r.task == task) {
    mResumedActivity=null;
  }
  final int taskNdx=mTaskHistory.indexOf(task);
  final int topTaskNdx=mTaskHistory.size() - 1;
  if (task.isOverHomeStack() && taskNdx < topTaskNdx) {
    final TaskRecord nextTask=mTaskHistory.get(taskNdx + 1);
    if (!nextTask.isOverHomeStack()) {
      nextTask.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
    }
  }
  mTaskHistory.remove(task);
  updateTaskMovement(task,true);
  if (!moving && task.mActivities.isEmpty()) {
    final boolean isVoiceSession=task.voiceSession != null;
    if (isVoiceSession) {
      try {
        task.voiceSession.taskFinished(task.intent,task.taskId);
      }
 catch (      RemoteException e) {
      }
    }
    if (task.autoRemoveFromRecents() || isVoiceSession) {
      mRecentTasks.remove(task);
      task.removedFromRecents();
    }
  }
  if (mTaskHistory.isEmpty()) {
    if (DEBUG_STACK)     Slog.i(TAG_STACK,""String_Node_Str"" + this);
    if (isOnHomeDisplay() && mStackSupervisor.isFocusedStack(this)) {
      String myReason=reason + ""String_Node_Str"";
      if (mFullscreen || !adjustFocusToNextFocusableStackLocked(task.getTaskToReturnTo(),myReason)) {
        mStackSupervisor.moveHomeStackToFront(myReason);
      }
    }
    if (mStacks != null) {
      mStacks.remove(this);
      mStacks.add(0,this);
    }
    if (!isHomeStack()) {
      mActivityContainer.onTaskListEmptyLocked();
    }
  }
  task.stack=null;
}","/** 
 * Removes the input task from this stack.
 * @param task to remove.
 * @param reason for removal.
 * @param mode task removal mode. Either {@link #REMOVE_TASK_MODE_DESTROYING},  {@link #REMOVE_TASK_MODE_MOVING},   {@link #REMOVE_TASK_MODE_MOVING_TO_TOP}.
 */
void removeTask(TaskRecord task,String reason,int mode){
  if (mode == REMOVE_TASK_MODE_DESTROYING) {
    mStackSupervisor.removeLockedTaskLocked(task);
    mWindowManager.removeTask(task.taskId);
    if (!StackId.persistTaskBounds(mStackId)) {
      task.updateOverrideConfiguration(null);
    }
  }
  final ActivityRecord r=mResumedActivity;
  if (r != null && r.task == task) {
    mResumedActivity=null;
  }
  final int taskNdx=mTaskHistory.indexOf(task);
  final int topTaskNdx=mTaskHistory.size() - 1;
  if (task.isOverHomeStack() && taskNdx < topTaskNdx) {
    final TaskRecord nextTask=mTaskHistory.get(taskNdx + 1);
    if (!nextTask.isOverHomeStack()) {
      nextTask.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
    }
  }
  mTaskHistory.remove(task);
  updateTaskMovement(task,true);
  if (mode == REMOVE_TASK_MODE_DESTROYING && task.mActivities.isEmpty()) {
    final boolean isVoiceSession=task.voiceSession != null;
    if (isVoiceSession) {
      try {
        task.voiceSession.taskFinished(task.intent,task.taskId);
      }
 catch (      RemoteException e) {
      }
    }
    if (task.autoRemoveFromRecents() || isVoiceSession) {
      mRecentTasks.remove(task);
      task.removedFromRecents();
    }
  }
  if (mTaskHistory.isEmpty()) {
    if (DEBUG_STACK)     Slog.i(TAG_STACK,""String_Node_Str"" + this);
    if (isOnHomeDisplay() && mode != REMOVE_TASK_MODE_MOVING_TO_TOP && mStackSupervisor.isFocusedStack(this)) {
      String myReason=reason + ""String_Node_Str"";
      if (mFullscreen || !adjustFocusToNextFocusableStackLocked(task.getTaskToReturnTo(),myReason)) {
        mStackSupervisor.moveHomeStackToFront(myReason);
      }
    }
    if (mStacks != null) {
      mStacks.remove(this);
      mStacks.add(0,this);
    }
    if (!isHomeStack()) {
      mActivityContainer.onTaskListEmptyLocked();
    }
  }
  task.stack=null;
}",0.8958031837916064
191839,"private ActivityStack preAddTask(TaskRecord task,String reason){
  final ActivityStack prevStack=task.stack;
  if (prevStack != null && prevStack != this) {
    prevStack.removeTask(task,reason,MOVING);
  }
  return prevStack;
}","private ActivityStack preAddTask(TaskRecord task,String reason,boolean toTop){
  final ActivityStack prevStack=task.stack;
  if (prevStack != null && prevStack != this) {
    prevStack.removeTask(task,reason,toTop ? REMOVE_TASK_MODE_MOVING_TO_TOP : REMOVE_TASK_MODE_MOVING);
  }
  return prevStack;
}",0.8636363636363636
191840,"void moveTasksToFullscreenStackLocked(int fromStackId,boolean onTop){
  final ActivityStack stack=getStack(fromStackId);
  if (stack == null) {
    return;
  }
  mWindowManager.deferSurfaceLayout();
  try {
    if (fromStackId == DOCKED_STACK_ID) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,null,null,null,PRESERVE_WINDOWS,true,DEFER_RESUME);
          }
        }
      }
      mAllowDockedStackResize=false;
    }
    final ArrayList<TaskRecord> tasks=stack.getAllTasks();
    final int size=tasks.size();
    if (onTop) {
      for (int i=0; i < size; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,onTop,onTop,""String_Node_Str"",ANIMATE);
      }
    }
 else {
      for (int i=size - 1; i >= 0; i--) {
        positionTaskInStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,0);
      }
    }
  }
  finally {
    mAllowDockedStackResize=true;
    mWindowManager.continueSurfaceLayout();
  }
}","void moveTasksToFullscreenStackLocked(int fromStackId,boolean onTop){
  final ActivityStack stack=getStack(fromStackId);
  if (stack == null) {
    return;
  }
  mWindowManager.deferSurfaceLayout();
  try {
    if (fromStackId == DOCKED_STACK_ID) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,null,null,null,PRESERVE_WINDOWS,true,DEFER_RESUME);
          }
        }
      }
      mAllowDockedStackResize=false;
    }
    final ArrayList<TaskRecord> tasks=stack.getAllTasks();
    final int size=tasks.size();
    if (onTop) {
      for (int i=0; i < size; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,onTop,onTop,""String_Node_Str"",ANIMATE,DEFER_RESUME);
      }
      ensureActivitiesVisibleLocked(null,0,PRESERVE_WINDOWS);
      resumeFocusedStackTopActivityLocked();
    }
 else {
      for (int i=size - 1; i >= 0; i--) {
        positionTaskInStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,0);
      }
    }
  }
  finally {
    mAllowDockedStackResize=true;
    mWindowManager.continueSurfaceLayout();
  }
}",0.9502899751449876
191841,"/** 
 * Restores a recent task to a stack
 * @param task The recent task to be restored.
 * @param stackId The stack to restore the task to (default launch stack will be usedif stackId is  {@link android.app.ActivityManager.StackId#INVALID_STACK_ID}).
 * @return true if the task has been restored successfully.
 */
private boolean restoreRecentTaskLocked(TaskRecord task,int stackId){
  if (stackId == INVALID_STACK_ID) {
    stackId=task.getLaunchStackId();
  }
 else   if (stackId == DOCKED_STACK_ID && !task.canGoInDockedStack()) {
    stackId=FULLSCREEN_WORKSPACE_STACK_ID;
  }
  if (task.stack != null) {
    if (task.stack.mStackId == stackId) {
      return true;
    }
    task.stack.removeTask(task,""String_Node_Str"",MOVING);
  }
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,!ON_TOP);
  if (stack == null) {
    if (DEBUG_RECENTS)     Slog.v(TAG_RECENTS,""String_Node_Str"" + task);
    return false;
  }
  stack.addTask(task,false,""String_Node_Str"");
  if (DEBUG_RECENTS)   Slog.v(TAG_RECENTS,""String_Node_Str"" + task + ""String_Node_Str""+ stack);
  final ArrayList<ActivityRecord> activities=task.mActivities;
  for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
    stack.addConfigOverride(activities.get(activityNdx),task);
  }
  return true;
}","/** 
 * Restores a recent task to a stack
 * @param task The recent task to be restored.
 * @param stackId The stack to restore the task to (default launch stack will be usedif stackId is  {@link android.app.ActivityManager.StackId#INVALID_STACK_ID}).
 * @return true if the task has been restored successfully.
 */
private boolean restoreRecentTaskLocked(TaskRecord task,int stackId){
  if (stackId == INVALID_STACK_ID) {
    stackId=task.getLaunchStackId();
  }
 else   if (stackId == DOCKED_STACK_ID && !task.canGoInDockedStack()) {
    stackId=FULLSCREEN_WORKSPACE_STACK_ID;
  }
  if (task.stack != null) {
    if (task.stack.mStackId == stackId) {
      return true;
    }
    task.stack.removeTask(task,""String_Node_Str"",REMOVE_TASK_MODE_MOVING);
  }
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,!ON_TOP);
  if (stack == null) {
    if (DEBUG_RECENTS)     Slog.v(TAG_RECENTS,""String_Node_Str"" + task);
    return false;
  }
  stack.addTask(task,false,""String_Node_Str"");
  if (DEBUG_RECENTS)   Slog.v(TAG_RECENTS,""String_Node_Str"" + task + ""String_Node_Str""+ stack);
  final ArrayList<ActivityRecord> activities=task.mActivities;
  for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
    stack.addConfigOverride(activities.get(activityNdx),task);
  }
  return true;
}",0.9935040122277417
191842,"boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack,ActivityRecord target,ActivityOptions targetOptions){
  if (targetStack != null && isFocusedStack(targetStack)) {
    return targetStack.resumeTopActivityUncheckedLocked(target,targetOptions);
  }
  mFocusedStack.resumeTopActivityUncheckedLocked(null,null);
  return false;
}","boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack,ActivityRecord target,ActivityOptions targetOptions){
  if (targetStack != null && isFocusedStack(targetStack)) {
    return targetStack.resumeTopActivityUncheckedLocked(target,targetOptions);
  }
  final ActivityRecord r=mFocusedStack.topRunningActivityLocked();
  if (r == null || r.state != RESUMED) {
    mFocusedStack.resumeTopActivityUncheckedLocked(null,null);
  }
  return false;
}",0.8482587064676617
191843,"/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.getTopActivity();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}","/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.topRunningActivityLocked();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}",0.9946004319654428
191844,"void positionTask(final TaskRecord task,int position){
  final ActivityRecord topRunningActivity=task.topRunningActivityLocked();
  final boolean wasResumed=topRunningActivity == task.stack.mResumedActivity;
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"");
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
  if (wasResumed) {
    if (mResumedActivity != null) {
      Log.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"" + mResumedActivity + ""String_Node_Str""+ topRunningActivity);
    }
    mResumedActivity=topRunningActivity;
  }
}","void positionTask(final TaskRecord task,int position){
  final ActivityRecord topRunningActivity=task.topRunningActivityLocked();
  final boolean wasResumed=topRunningActivity == task.stack.mResumedActivity;
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"",ON_TOP);
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
  if (wasResumed) {
    if (mResumedActivity != null) {
      Log.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"" + mResumedActivity + ""String_Node_Str""+ topRunningActivity);
    }
    mResumedActivity=topRunningActivity;
  }
}",0.9941027801179444
191845,"void addTask(final TaskRecord task,final boolean toTop,String reason){
  final ActivityStack prevStack=preAddTask(task,reason);
  task.stack=this;
  if (toTop) {
    insertTaskAtTop(task,null);
  }
 else {
    mTaskHistory.add(0,task);
    updateTaskMovement(task,false);
  }
  postAddTask(task,prevStack);
}","void addTask(final TaskRecord task,final boolean toTop,String reason){
  final ActivityStack prevStack=preAddTask(task,reason,toTop);
  task.stack=this;
  if (toTop) {
    insertTaskAtTop(task,null);
  }
 else {
    mTaskHistory.add(0,task);
    updateTaskMovement(task,false);
  }
  postAddTask(task,prevStack);
}",0.990353697749196
191846,"/** 
 * Removes the input task from this stack.
 * @param task to remove.
 * @param reason for removal.
 * @param moving task to another stack. In the case we are moving we don't want to performsome operations on the task like removing it from window manager or recents.
 */
void removeTask(TaskRecord task,String reason,boolean moving){
  if (!moving) {
    mStackSupervisor.removeLockedTaskLocked(task);
    mWindowManager.removeTask(task.taskId);
    if (!StackId.persistTaskBounds(mStackId)) {
      task.updateOverrideConfiguration(null);
    }
  }
  final ActivityRecord r=mResumedActivity;
  if (r != null && r.task == task) {
    mResumedActivity=null;
  }
  final int taskNdx=mTaskHistory.indexOf(task);
  final int topTaskNdx=mTaskHistory.size() - 1;
  if (task.isOverHomeStack() && taskNdx < topTaskNdx) {
    final TaskRecord nextTask=mTaskHistory.get(taskNdx + 1);
    if (!nextTask.isOverHomeStack()) {
      nextTask.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
    }
  }
  mTaskHistory.remove(task);
  updateTaskMovement(task,true);
  if (!moving && task.mActivities.isEmpty()) {
    final boolean isVoiceSession=task.voiceSession != null;
    if (isVoiceSession) {
      try {
        task.voiceSession.taskFinished(task.intent,task.taskId);
      }
 catch (      RemoteException e) {
      }
    }
    if (task.autoRemoveFromRecents() || isVoiceSession) {
      mRecentTasks.remove(task);
      task.removedFromRecents();
    }
  }
  if (mTaskHistory.isEmpty()) {
    if (DEBUG_STACK)     Slog.i(TAG_STACK,""String_Node_Str"" + this);
    if (isOnHomeDisplay() && mStackSupervisor.isFocusedStack(this)) {
      String myReason=reason + ""String_Node_Str"";
      if (mFullscreen || !adjustFocusToNextFocusableStackLocked(task.getTaskToReturnTo(),myReason)) {
        mStackSupervisor.moveHomeStackToFront(myReason);
      }
    }
    if (mStacks != null) {
      mStacks.remove(this);
      mStacks.add(0,this);
    }
    if (!isHomeStack()) {
      mActivityContainer.onTaskListEmptyLocked();
    }
  }
  task.stack=null;
}","/** 
 * Removes the input task from this stack.
 * @param task to remove.
 * @param reason for removal.
 * @param mode task removal mode. Either {@link #REMOVE_TASK_MODE_DESTROYING},  {@link #REMOVE_TASK_MODE_MOVING},   {@link #REMOVE_TASK_MODE_MOVING_TO_TOP}.
 */
void removeTask(TaskRecord task,String reason,int mode){
  if (mode == REMOVE_TASK_MODE_DESTROYING) {
    mStackSupervisor.removeLockedTaskLocked(task);
    mWindowManager.removeTask(task.taskId);
    if (!StackId.persistTaskBounds(mStackId)) {
      task.updateOverrideConfiguration(null);
    }
  }
  final ActivityRecord r=mResumedActivity;
  if (r != null && r.task == task) {
    mResumedActivity=null;
  }
  final int taskNdx=mTaskHistory.indexOf(task);
  final int topTaskNdx=mTaskHistory.size() - 1;
  if (task.isOverHomeStack() && taskNdx < topTaskNdx) {
    final TaskRecord nextTask=mTaskHistory.get(taskNdx + 1);
    if (!nextTask.isOverHomeStack()) {
      nextTask.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
    }
  }
  mTaskHistory.remove(task);
  updateTaskMovement(task,true);
  if (mode == REMOVE_TASK_MODE_DESTROYING && task.mActivities.isEmpty()) {
    final boolean isVoiceSession=task.voiceSession != null;
    if (isVoiceSession) {
      try {
        task.voiceSession.taskFinished(task.intent,task.taskId);
      }
 catch (      RemoteException e) {
      }
    }
    if (task.autoRemoveFromRecents() || isVoiceSession) {
      mRecentTasks.remove(task);
      task.removedFromRecents();
    }
  }
  if (mTaskHistory.isEmpty()) {
    if (DEBUG_STACK)     Slog.i(TAG_STACK,""String_Node_Str"" + this);
    if (isOnHomeDisplay() && mode != REMOVE_TASK_MODE_MOVING_TO_TOP && mStackSupervisor.isFocusedStack(this)) {
      String myReason=reason + ""String_Node_Str"";
      if (mFullscreen || !adjustFocusToNextFocusableStackLocked(task.getTaskToReturnTo(),myReason)) {
        mStackSupervisor.moveHomeStackToFront(myReason);
      }
    }
    if (mStacks != null) {
      mStacks.remove(this);
      mStacks.add(0,this);
    }
    if (!isHomeStack()) {
      mActivityContainer.onTaskListEmptyLocked();
    }
  }
  task.stack=null;
}",0.8958031837916064
191847,"private ActivityStack preAddTask(TaskRecord task,String reason){
  final ActivityStack prevStack=task.stack;
  if (prevStack != null && prevStack != this) {
    prevStack.removeTask(task,reason,MOVING);
  }
  return prevStack;
}","private ActivityStack preAddTask(TaskRecord task,String reason,boolean toTop){
  final ActivityStack prevStack=task.stack;
  if (prevStack != null && prevStack != this) {
    prevStack.removeTask(task,reason,toTop ? REMOVE_TASK_MODE_MOVING_TO_TOP : REMOVE_TASK_MODE_MOVING);
  }
  return prevStack;
}",0.8636363636363636
191848,"void moveTasksToFullscreenStackLocked(int fromStackId,boolean onTop){
  final ActivityStack stack=getStack(fromStackId);
  if (stack == null) {
    return;
  }
  mWindowManager.deferSurfaceLayout();
  try {
    if (fromStackId == DOCKED_STACK_ID) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,null,null,null,PRESERVE_WINDOWS,true,DEFER_RESUME);
          }
        }
      }
      mAllowDockedStackResize=false;
    }
    final ArrayList<TaskRecord> tasks=stack.getAllTasks();
    final int size=tasks.size();
    if (onTop) {
      for (int i=0; i < size; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,onTop,onTop,""String_Node_Str"",ANIMATE);
      }
    }
 else {
      for (int i=size - 1; i >= 0; i--) {
        positionTaskInStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,0);
      }
    }
  }
  finally {
    mAllowDockedStackResize=true;
    mWindowManager.continueSurfaceLayout();
  }
}","void moveTasksToFullscreenStackLocked(int fromStackId,boolean onTop){
  final ActivityStack stack=getStack(fromStackId);
  if (stack == null) {
    return;
  }
  mWindowManager.deferSurfaceLayout();
  try {
    if (fromStackId == DOCKED_STACK_ID) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,null,null,null,PRESERVE_WINDOWS,true,DEFER_RESUME);
          }
        }
      }
      mAllowDockedStackResize=false;
    }
    final ArrayList<TaskRecord> tasks=stack.getAllTasks();
    final int size=tasks.size();
    if (onTop) {
      for (int i=0; i < size; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,onTop,onTop,""String_Node_Str"",ANIMATE,DEFER_RESUME);
      }
      ensureActivitiesVisibleLocked(null,0,PRESERVE_WINDOWS);
      resumeFocusedStackTopActivityLocked();
    }
 else {
      for (int i=size - 1; i >= 0; i--) {
        positionTaskInStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,0);
      }
    }
  }
  finally {
    mAllowDockedStackResize=true;
    mWindowManager.continueSurfaceLayout();
  }
}",0.9502899751449876
191849,"/** 
 * Restores a recent task to a stack
 * @param task The recent task to be restored.
 * @param stackId The stack to restore the task to (default launch stack will be usedif stackId is  {@link android.app.ActivityManager.StackId#INVALID_STACK_ID}).
 * @return true if the task has been restored successfully.
 */
private boolean restoreRecentTaskLocked(TaskRecord task,int stackId){
  if (stackId == INVALID_STACK_ID) {
    stackId=task.getLaunchStackId();
  }
 else   if (stackId == DOCKED_STACK_ID && !task.canGoInDockedStack()) {
    stackId=FULLSCREEN_WORKSPACE_STACK_ID;
  }
  if (task.stack != null) {
    if (task.stack.mStackId == stackId) {
      return true;
    }
    task.stack.removeTask(task,""String_Node_Str"",MOVING);
  }
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,!ON_TOP);
  if (stack == null) {
    if (DEBUG_RECENTS)     Slog.v(TAG_RECENTS,""String_Node_Str"" + task);
    return false;
  }
  stack.addTask(task,false,""String_Node_Str"");
  if (DEBUG_RECENTS)   Slog.v(TAG_RECENTS,""String_Node_Str"" + task + ""String_Node_Str""+ stack);
  final ArrayList<ActivityRecord> activities=task.mActivities;
  for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
    stack.addConfigOverride(activities.get(activityNdx),task);
  }
  return true;
}","/** 
 * Restores a recent task to a stack
 * @param task The recent task to be restored.
 * @param stackId The stack to restore the task to (default launch stack will be usedif stackId is  {@link android.app.ActivityManager.StackId#INVALID_STACK_ID}).
 * @return true if the task has been restored successfully.
 */
private boolean restoreRecentTaskLocked(TaskRecord task,int stackId){
  if (stackId == INVALID_STACK_ID) {
    stackId=task.getLaunchStackId();
  }
 else   if (stackId == DOCKED_STACK_ID && !task.canGoInDockedStack()) {
    stackId=FULLSCREEN_WORKSPACE_STACK_ID;
  }
  if (task.stack != null) {
    if (task.stack.mStackId == stackId) {
      return true;
    }
    task.stack.removeTask(task,""String_Node_Str"",REMOVE_TASK_MODE_MOVING);
  }
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,!ON_TOP);
  if (stack == null) {
    if (DEBUG_RECENTS)     Slog.v(TAG_RECENTS,""String_Node_Str"" + task);
    return false;
  }
  stack.addTask(task,false,""String_Node_Str"");
  if (DEBUG_RECENTS)   Slog.v(TAG_RECENTS,""String_Node_Str"" + task + ""String_Node_Str""+ stack);
  final ArrayList<ActivityRecord> activities=task.mActivities;
  for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
    stack.addConfigOverride(activities.get(activityNdx),task);
  }
  return true;
}",0.9935040122277417
191850,"boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack,ActivityRecord target,ActivityOptions targetOptions){
  if (targetStack != null && isFocusedStack(targetStack)) {
    return targetStack.resumeTopActivityUncheckedLocked(target,targetOptions);
  }
  mFocusedStack.resumeTopActivityUncheckedLocked(null,null);
  return false;
}","boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack,ActivityRecord target,ActivityOptions targetOptions){
  if (targetStack != null && isFocusedStack(targetStack)) {
    return targetStack.resumeTopActivityUncheckedLocked(target,targetOptions);
  }
  final ActivityRecord r=mFocusedStack.topRunningActivityLocked();
  if (r == null || r.state != RESUMED) {
    mFocusedStack.resumeTopActivityUncheckedLocked(null,null);
  }
  return false;
}",0.8482587064676617
191851,"/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.getTopActivity();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}","/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.topRunningActivityLocked();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}",0.9946004319654428
191852,"public TaskViewDismissedEvent(Task task,TaskView taskView){
  this.task=task;
  this.taskView=taskView;
}","public TaskViewDismissedEvent(Task task,TaskView taskView,AnimationProps animation){
  this.task=task;
  this.taskView=taskView;
  this.animation=animation;
}",0.7984790874524715
191853,"/** 
 * Starts the delete animation for the specified   {@link TaskView}.
 */
public void startDeleteTaskAnimation(final TaskView deleteTaskView,final ReferenceCountedTrigger postAnimationTrigger){
  TaskStackViewTouchHandler touchHandler=mStackView.getTouchHandler();
  touchHandler.onBeginDrag(deleteTaskView);
  postAnimationTrigger.increment();
  postAnimationTrigger.addLastDecrementRunnable(() -> {
    touchHandler.onChildDismissed(deleteTaskView);
  }
);
  final float dismissSize=touchHandler.getScaledDismissSize();
  ValueAnimator animator=ValueAnimator.ofFloat(0f,1f);
  animator.setDuration(400);
  animator.addUpdateListener((animation) -> {
    float progress=(Float)animation.getAnimatedValue();
    deleteTaskView.setTranslationX(progress * dismissSize);
    touchHandler.updateSwipeProgress(deleteTaskView,true,progress);
  }
);
  animator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      postAnimationTrigger.decrement();
    }
  }
);
  animator.start();
}","/** 
 * Starts the delete animation for the specified   {@link TaskView}.
 */
public void startDeleteTaskAnimation(final TaskView deleteTaskView,final ReferenceCountedTrigger postAnimationTrigger){
  TaskStackViewTouchHandler touchHandler=mStackView.getTouchHandler();
  touchHandler.onBeginManualDrag(deleteTaskView);
  postAnimationTrigger.increment();
  postAnimationTrigger.addLastDecrementRunnable(() -> {
    touchHandler.onChildDismissed(deleteTaskView);
  }
);
  final float dismissSize=touchHandler.getScaledDismissSize();
  ValueAnimator animator=ValueAnimator.ofFloat(0f,1f);
  animator.setDuration(400);
  animator.addUpdateListener((animation) -> {
    float progress=(Float)animation.getAnimatedValue();
    deleteTaskView.setTranslationX(progress * dismissSize);
    touchHandler.updateSwipeProgress(deleteTaskView,true,progress);
  }
);
  animator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      postAnimationTrigger.decrement();
    }
  }
);
  animator.start();
}",0.9971264367816092
191854,"/** 
 * Starts an in-app animation to hide all the task views so that we can transition back home.
 */
public void startExitToHomeAnimation(boolean animated,ReferenceCountedTrigger postAnimationTrigger){
  TaskStackLayoutAlgorithm stackLayout=mStackView.getStackAlgorithm();
  TaskStack stack=mStackView.getStack();
  if (stack.getTaskCount() == 0) {
    return;
  }
  int offscreenYOffset=stackLayout.mStackRect.height();
  List<TaskView> taskViews=mStackView.getTaskViews();
  int taskViewCount=taskViews.size();
  for (int i=0; i < taskViewCount; i++) {
    int taskIndexFromFront=taskViewCount - i - 1;
    TaskView tv=taskViews.get(i);
    AnimationProps taskAnimation;
    if (animated) {
      int delay=Math.min(ENTER_EXIT_NUM_ANIMATING_TASKS,taskIndexFromFront) * DOUBLE_FRAME_OFFSET_MS;
      taskAnimation=new AnimationProps().setStartDelay(AnimationProps.BOUNDS,delay).setDuration(AnimationProps.BOUNDS,EXIT_TO_HOME_TRANSLATION_DURATION).setInterpolator(AnimationProps.BOUNDS,EXIT_TO_HOME_TRANSLATION_INTERPOLATOR).setListener(postAnimationTrigger.decrementOnAnimationEnd());
      postAnimationTrigger.increment();
    }
 else {
      taskAnimation=AnimationProps.IMMEDIATE;
    }
    mTmpTransform.fillIn(tv);
    mTmpTransform.rect.offset(0,offscreenYOffset);
    mStackView.updateTaskViewToTransform(tv,mTmpTransform,taskAnimation);
  }
}","/** 
 * Starts an in-app animation to hide all the task views so that we can transition back home.
 */
public void startExitToHomeAnimation(boolean animated,ReferenceCountedTrigger postAnimationTrigger){
  TaskStackLayoutAlgorithm stackLayout=mStackView.getStackAlgorithm();
  TaskStack stack=mStackView.getStack();
  if (stack.getTaskCount() == 0) {
    return;
  }
  int offscreenYOffset=stackLayout.mStackRect.height();
  List<TaskView> taskViews=mStackView.getTaskViews();
  int taskViewCount=taskViews.size();
  for (int i=0; i < taskViewCount; i++) {
    int taskIndexFromFront=taskViewCount - i - 1;
    TaskView tv=taskViews.get(i);
    Task task=tv.getTask();
    if (mStackView.isIgnoredTask(task)) {
      continue;
    }
    AnimationProps taskAnimation;
    if (animated) {
      int delay=Math.min(ENTER_EXIT_NUM_ANIMATING_TASKS,taskIndexFromFront) * DOUBLE_FRAME_OFFSET_MS;
      taskAnimation=new AnimationProps().setStartDelay(AnimationProps.BOUNDS,delay).setDuration(AnimationProps.BOUNDS,EXIT_TO_HOME_TRANSLATION_DURATION).setInterpolator(AnimationProps.BOUNDS,EXIT_TO_HOME_TRANSLATION_INTERPOLATOR).setListener(postAnimationTrigger.decrementOnAnimationEnd());
      postAnimationTrigger.increment();
    }
 else {
      taskAnimation=AnimationProps.IMMEDIATE;
    }
    mTmpTransform.fillIn(tv);
    mTmpTransform.rect.offset(0,offscreenYOffset);
    mStackView.updateTaskViewToTransform(tv,mTmpTransform,taskAnimation);
  }
}",0.9671428571428572
191855,"/** 
 * Adds and override task progress for the given task when transitioning from focused to unfocused state.
 */
public void addUnfocusedTaskOverride(Task task,float stackScroll){
  if (mFocusState != STATE_UNFOCUSED) {
    mFocusedRange.offset(stackScroll);
    mUnfocusedRange.offset(stackScroll);
    float focusedRangeX=mFocusedRange.getNormalizedX(mTaskIndexMap.get(task.key.id));
    float focusedY=mFocusedCurveInterpolator.getInterpolation(focusedRangeX);
    float unfocusedRangeX=mUnfocusedCurveInterpolator.getX(focusedY);
    float unfocusedTaskProgress=stackScroll + mUnfocusedRange.getAbsoluteX(unfocusedRangeX);
    if (Float.compare(focusedRangeX,unfocusedRangeX) != 0) {
      mTaskIndexOverrideMap.put(task.key.id,unfocusedTaskProgress);
    }
  }
}","/** 
 * Adds and override task progress for the given task when transitioning from focused to unfocused state.
 */
public void addUnfocusedTaskOverride(TaskView taskView,float stackScroll){
  mFocusedRange.offset(stackScroll);
  mUnfocusedRange.offset(stackScroll);
  Task task=taskView.getTask();
  int top=taskView.getTop() - mTaskRect.top;
  float focusedRangeX=getNormalizedXFromFocusedY(top,FROM_TOP);
  float unfocusedRangeX=getNormalizedXFromUnfocusedY(top,FROM_TOP);
  float unfocusedTaskProgress=stackScroll + mUnfocusedRange.getAbsoluteX(unfocusedRangeX);
  if (Float.compare(focusedRangeX,unfocusedRangeX) != 0) {
    mTaskIndexOverrideMap.put(task.key.id,unfocusedTaskProgress);
  }
}",0.3617747440273037
191856,"@Override public boolean updateSwipeProgress(View v,boolean dismissable,float swipeProgress){
  updateTaskViewTransforms(Interpolators.FAST_OUT_SLOW_IN.getInterpolation(swipeProgress));
  return true;
}","@Override public boolean updateSwipeProgress(View v,boolean dismissable,float swipeProgress){
  if (mActiveTaskView == v || mSwipeHelperAnimations.containsKey(v)) {
    updateTaskViewTransforms(Interpolators.FAST_OUT_SLOW_IN.getInterpolation(swipeProgress));
  }
  return true;
}",0.83991683991684
191857,"private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      finishAnimations();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}","private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      cancelNonDismissTaskAnimations();
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}",0.9190611976310594
191858,"@Override public boolean canChildBeDismissed(View v){
  TaskView tv=(TaskView)v;
  return !mSwipeHelperAnimations.containsKey(v) && (mSv.getStack().indexOfStackTask(tv.getTask()) != -1);
}","@Override public boolean canChildBeDismissed(View v){
  TaskView tv=(TaskView)v;
  Task task=tv.getTask();
  return !mSwipeHelperAnimations.containsKey(v) && (mSv.getStack().indexOfStackTask(task) != -1);
}",0.8984771573604061
191859,"/** 
 * Called after the   {@link TaskView} is finished animating away.
 */
@Override public void onChildDismissed(View v){
  TaskView tv=(TaskView)v;
  tv.setClipViewInStack(true);
  tv.setTouchEnabled(true);
  EventBus.getDefault().send(new TaskViewDismissedEvent(tv.getTask(),tv));
  mSv.getScroller().setStackScroll(mTargetStackScroll,null);
  mSv.getStackAlgorithm().setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
  mSv.getStackAlgorithm().clearUnfocusedTaskOverrides();
  mSwipeHelperAnimations.remove(v);
  MetricsLogger.histogram(tv.getContext(),""String_Node_Str"",Constants.Metrics.DismissSourceSwipeGesture);
}","/** 
 * Called after the   {@link TaskView} is finished animating away.
 */
@Override public void onChildDismissed(View v){
  TaskView tv=(TaskView)v;
  tv.setClipViewInStack(true);
  tv.setTouchEnabled(true);
  EventBus.getDefault().send(new TaskViewDismissedEvent(tv.getTask(),tv,mSwipeHelperAnimations.containsKey(v) ? new AnimationProps(TaskStackView.DEFAULT_SYNC_STACK_DURATION,Interpolators.FAST_OUT_SLOW_IN) : null));
  if (mSwipeHelperAnimations.containsKey(v)) {
    mSv.getScroller().setStackScroll(mTargetStackScroll,null);
    mSv.getStackAlgorithm().setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
    mSv.getStackAlgorithm().clearUnfocusedTaskOverrides();
    mSwipeHelperAnimations.remove(v);
  }
  MetricsLogger.histogram(tv.getContext(),""String_Node_Str"",Constants.Metrics.DismissSourceSwipeGesture);
}",0.8634179821551132
191860,"@Override public void onBeginDrag(View v){
  TaskView tv=(TaskView)v;
  tv.setClipViewInStack(false);
  tv.setTouchEnabled(false);
  final ViewParent parent=mSv.getParent();
  if (parent != null) {
    parent.requestDisallowInterceptTouchEvent(true);
  }
  mSv.addIgnoreTask(tv.getTask());
  mCurrentTasks=mSv.getStack().getStackTasks();
  MutableBoolean isFrontMostTask=new MutableBoolean(false);
  Task anchorTask=mSv.findAnchorTask(mCurrentTasks,isFrontMostTask);
  TaskStackLayoutAlgorithm layoutAlgorithm=mSv.getStackAlgorithm();
  TaskStackViewScroller stackScroller=mSv.getScroller();
  if (anchorTask != null) {
    mSv.getCurrentTaskTransforms(mCurrentTasks,mCurrentTaskTransforms);
    float prevAnchorTaskScroll=0;
    boolean pullStackForward=mCurrentTasks.size() > 0;
    if (pullStackForward) {
      prevAnchorTaskScroll=layoutAlgorithm.getStackScrollForTask(anchorTask);
    }
    mSv.updateLayoutAlgorithm(false);
    float newStackScroll=stackScroller.getStackScroll();
    if (isFrontMostTask.value) {
      newStackScroll=stackScroller.getBoundedStackScroll(newStackScroll);
    }
 else     if (pullStackForward) {
      float anchorTaskScroll=layoutAlgorithm.getStackScrollForTaskIgnoreOverrides(anchorTask);
      float stackScrollOffset=(anchorTaskScroll - prevAnchorTaskScroll);
      if (layoutAlgorithm.getFocusState() != TaskStackLayoutAlgorithm.STATE_FOCUSED) {
        stackScrollOffset*=0.75f;
      }
      newStackScroll=stackScroller.getBoundedStackScroll(stackScroller.getStackScroll() + stackScrollOffset);
    }
    mSv.bindVisibleTaskViews(newStackScroll,true);
    mSv.getLayoutTaskTransforms(newStackScroll,TaskStackLayoutAlgorithm.STATE_UNFOCUSED,mCurrentTasks,true,mFinalTaskTransforms);
    mTargetStackScroll=newStackScroll;
  }
}","@Override public void onBeginDrag(View v){
  TaskView tv=(TaskView)v;
  tv.setClipViewInStack(false);
  tv.setTouchEnabled(false);
  final ViewParent parent=mSv.getParent();
  if (parent != null) {
    parent.requestDisallowInterceptTouchEvent(true);
  }
  mSv.addIgnoreTask(tv.getTask());
  mCurrentTasks=new ArrayList<Task>(mSv.getStack().getStackTasks());
  MutableBoolean isFrontMostTask=new MutableBoolean(false);
  Task anchorTask=mSv.findAnchorTask(mCurrentTasks,isFrontMostTask);
  TaskStackLayoutAlgorithm layoutAlgorithm=mSv.getStackAlgorithm();
  TaskStackViewScroller stackScroller=mSv.getScroller();
  if (anchorTask != null) {
    mSv.getCurrentTaskTransforms(mCurrentTasks,mCurrentTaskTransforms);
    float prevAnchorTaskScroll=0;
    boolean pullStackForward=mCurrentTasks.size() > 0;
    if (pullStackForward) {
      prevAnchorTaskScroll=layoutAlgorithm.getStackScrollForTask(anchorTask);
    }
    mSv.updateLayoutAlgorithm(false);
    float newStackScroll=stackScroller.getStackScroll();
    if (isFrontMostTask.value) {
      newStackScroll=stackScroller.getBoundedStackScroll(newStackScroll);
    }
 else     if (pullStackForward) {
      float anchorTaskScroll=layoutAlgorithm.getStackScrollForTaskIgnoreOverrides(anchorTask);
      float stackScrollOffset=(anchorTaskScroll - prevAnchorTaskScroll);
      if (layoutAlgorithm.getFocusState() != TaskStackLayoutAlgorithm.STATE_FOCUSED) {
        stackScrollOffset*=0.75f;
      }
      newStackScroll=stackScroller.getBoundedStackScroll(stackScroller.getStackScroll() + stackScrollOffset);
    }
    mSv.bindVisibleTaskViews(newStackScroll,true);
    mSv.getLayoutTaskTransforms(newStackScroll,TaskStackLayoutAlgorithm.STATE_UNFOCUSED,mCurrentTasks,true,mFinalTaskTransforms);
    mTargetStackScroll=newStackScroll;
  }
}",0.9778525371460612
191861,"/** 
 * Dismisses this task. 
 */
void dismissTask(){
  final TaskView tv=this;
  DismissTaskViewEvent dismissEvent=new DismissTaskViewEvent(tv);
  dismissEvent.addPostAnimationCallback(new Runnable(){
    @Override public void run(){
      EventBus.getDefault().send(new TaskViewDismissedEvent(mTask,tv));
    }
  }
);
  EventBus.getDefault().send(dismissEvent);
}","/** 
 * Dismisses this task. 
 */
void dismissTask(){
  final TaskView tv=this;
  DismissTaskViewEvent dismissEvent=new DismissTaskViewEvent(tv);
  dismissEvent.addPostAnimationCallback(new Runnable(){
    @Override public void run(){
      EventBus.getDefault().send(new TaskViewDismissedEvent(mTask,tv,new AnimationProps(TaskStackView.DEFAULT_SYNC_STACK_DURATION,Interpolators.FAST_OUT_SLOW_IN)));
    }
  }
);
  EventBus.getDefault().send(dismissEvent);
}",0.8869987849331713
191862,"@RemotableViewMethod public void setHasImage(boolean hasImage){
  mIndentLines=hasImage ? 2 : 0;
}","@RemotableViewMethod public void setHasImage(boolean hasImage){
  setNumIndentLines(hasImage ? 2 : 0);
}",0.9603960396039604
191863,"public static DividerSnapAlgorithm create(Context ctx,Rect insets){
  DisplayInfo displayInfo=new DisplayInfo();
  ctx.getSystemService(DisplayManager.class).getDisplay(Display.DEFAULT_DISPLAY).getDisplayInfo(displayInfo);
  int dividerWindowWidth=ctx.getResources().getDimensionPixelSize(com.android.internal.R.dimen.docked_stack_divider_thickness);
  int dividerInsets=ctx.getResources().getDimensionPixelSize(com.android.internal.R.dimen.docked_stack_divider_insets);
  return new DividerSnapAlgorithm(ctx.getResources(),displayInfo.logicalWidth,displayInfo.logicalHeight,dividerWindowWidth - 2 * dividerInsets,ctx.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT,insets);
}","public static DividerSnapAlgorithm create(Context ctx,Rect insets){
  DisplayInfo displayInfo=new DisplayInfo();
  ctx.getSystemService(DisplayManager.class).getDisplay(Display.DEFAULT_DISPLAY).getDisplayInfo(displayInfo);
  int dividerWindowWidth=ctx.getResources().getDimensionPixelSize(com.android.internal.R.dimen.docked_stack_divider_thickness);
  int dividerInsets=ctx.getResources().getDimensionPixelSize(com.android.internal.R.dimen.docked_stack_divider_insets);
  return new DividerSnapAlgorithm(ctx.getResources(),displayInfo.logicalWidth,displayInfo.logicalHeight,dividerWindowWidth - 2 * dividerInsets,ctx.getApplicationContext().getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT,insets);
}",0.9834254143646408
191864,"public final void onBusEvent(ConfigurationChangedEvent event){
  if (event.fromDisplayDensityChange) {
    updateSnapAlgorithm();
  }
}","public final void onBusEvent(ConfigurationChangedEvent event){
  if (event.fromDisplayDensityChange || event.fromDeviceOrientationChange) {
    updateSnapAlgorithm();
  }
}",0.8794788273615635
191865,"@RemotableViewMethod public void setHasImage(boolean hasImage){
  mIndentLines=hasImage ? 2 : 0;
}","@RemotableViewMethod public void setHasImage(boolean hasImage){
  setNumIndentLines(hasImage ? 2 : 0);
}",0.9603960396039604
191866,"@RemotableViewMethod public void setHasImage(boolean hasImage){
  mIndentLines=hasImage ? 2 : 0;
}","@RemotableViewMethod public void setHasImage(boolean hasImage){
  setNumIndentLines(hasImage ? 2 : 0);
}",0.9603960396039604
191867,"void positionTask(final TaskRecord task,int position){
  final ActivityRecord topRunningActivity=task.topRunningActivityLocked();
  final boolean wasResumed=topRunningActivity == task.stack.mResumedActivity;
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"");
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
  if (wasResumed) {
    if (mResumedActivity != null) {
      Log.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"" + mResumedActivity + ""String_Node_Str""+ topRunningActivity);
    }
    mResumedActivity=topRunningActivity;
  }
}","void positionTask(final TaskRecord task,int position){
  final ActivityRecord topRunningActivity=task.topRunningActivityLocked();
  final boolean wasResumed=topRunningActivity == task.stack.mResumedActivity;
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"",ON_TOP);
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
  if (wasResumed) {
    if (mResumedActivity != null) {
      Log.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"" + mResumedActivity + ""String_Node_Str""+ topRunningActivity);
    }
    mResumedActivity=topRunningActivity;
  }
}",0.9941027801179444
191868,"void addTask(final TaskRecord task,final boolean toTop,String reason){
  final ActivityStack prevStack=preAddTask(task,reason);
  task.stack=this;
  if (toTop) {
    insertTaskAtTop(task,null);
  }
 else {
    mTaskHistory.add(0,task);
    updateTaskMovement(task,false);
  }
  postAddTask(task,prevStack);
}","void addTask(final TaskRecord task,final boolean toTop,String reason){
  final ActivityStack prevStack=preAddTask(task,reason,toTop);
  task.stack=this;
  if (toTop) {
    insertTaskAtTop(task,null);
  }
 else {
    mTaskHistory.add(0,task);
    updateTaskMovement(task,false);
  }
  postAddTask(task,prevStack);
}",0.990353697749196
191869,"/** 
 * Removes the input task from this stack.
 * @param task to remove.
 * @param reason for removal.
 * @param moving task to another stack. In the case we are moving we don't want to performsome operations on the task like removing it from window manager or recents.
 */
void removeTask(TaskRecord task,String reason,boolean moving){
  if (!moving) {
    mStackSupervisor.removeLockedTaskLocked(task);
    mWindowManager.removeTask(task.taskId);
    if (!StackId.persistTaskBounds(mStackId)) {
      task.updateOverrideConfiguration(null);
    }
  }
  final ActivityRecord r=mResumedActivity;
  if (r != null && r.task == task) {
    mResumedActivity=null;
  }
  final int taskNdx=mTaskHistory.indexOf(task);
  final int topTaskNdx=mTaskHistory.size() - 1;
  if (task.isOverHomeStack() && taskNdx < topTaskNdx) {
    final TaskRecord nextTask=mTaskHistory.get(taskNdx + 1);
    if (!nextTask.isOverHomeStack()) {
      nextTask.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
    }
  }
  mTaskHistory.remove(task);
  updateTaskMovement(task,true);
  if (!moving && task.mActivities.isEmpty()) {
    final boolean isVoiceSession=task.voiceSession != null;
    if (isVoiceSession) {
      try {
        task.voiceSession.taskFinished(task.intent,task.taskId);
      }
 catch (      RemoteException e) {
      }
    }
    if (task.autoRemoveFromRecents() || isVoiceSession) {
      mRecentTasks.remove(task);
      task.removedFromRecents();
    }
  }
  if (mTaskHistory.isEmpty()) {
    if (DEBUG_STACK)     Slog.i(TAG_STACK,""String_Node_Str"" + this);
    if (isOnHomeDisplay() && mStackSupervisor.isFocusedStack(this)) {
      String myReason=reason + ""String_Node_Str"";
      if (mFullscreen || !adjustFocusToNextFocusableStackLocked(task.getTaskToReturnTo(),myReason)) {
        mStackSupervisor.moveHomeStackToFront(myReason);
      }
    }
    if (mStacks != null) {
      mStacks.remove(this);
      mStacks.add(0,this);
    }
    if (!isHomeStack()) {
      mActivityContainer.onTaskListEmptyLocked();
    }
  }
  task.stack=null;
}","/** 
 * Removes the input task from this stack.
 * @param task to remove.
 * @param reason for removal.
 * @param mode task removal mode. Either {@link #REMOVE_TASK_MODE_DESTROYING},  {@link #REMOVE_TASK_MODE_MOVING},   {@link #REMOVE_TASK_MODE_MOVING_TO_TOP}.
 */
void removeTask(TaskRecord task,String reason,int mode){
  if (mode == REMOVE_TASK_MODE_DESTROYING) {
    mStackSupervisor.removeLockedTaskLocked(task);
    mWindowManager.removeTask(task.taskId);
    if (!StackId.persistTaskBounds(mStackId)) {
      task.updateOverrideConfiguration(null);
    }
  }
  final ActivityRecord r=mResumedActivity;
  if (r != null && r.task == task) {
    mResumedActivity=null;
  }
  final int taskNdx=mTaskHistory.indexOf(task);
  final int topTaskNdx=mTaskHistory.size() - 1;
  if (task.isOverHomeStack() && taskNdx < topTaskNdx) {
    final TaskRecord nextTask=mTaskHistory.get(taskNdx + 1);
    if (!nextTask.isOverHomeStack()) {
      nextTask.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
    }
  }
  mTaskHistory.remove(task);
  updateTaskMovement(task,true);
  if (mode == REMOVE_TASK_MODE_DESTROYING && task.mActivities.isEmpty()) {
    final boolean isVoiceSession=task.voiceSession != null;
    if (isVoiceSession) {
      try {
        task.voiceSession.taskFinished(task.intent,task.taskId);
      }
 catch (      RemoteException e) {
      }
    }
    if (task.autoRemoveFromRecents() || isVoiceSession) {
      mRecentTasks.remove(task);
      task.removedFromRecents();
    }
  }
  if (mTaskHistory.isEmpty()) {
    if (DEBUG_STACK)     Slog.i(TAG_STACK,""String_Node_Str"" + this);
    if (isOnHomeDisplay() && mode != REMOVE_TASK_MODE_MOVING_TO_TOP && mStackSupervisor.isFocusedStack(this)) {
      String myReason=reason + ""String_Node_Str"";
      if (mFullscreen || !adjustFocusToNextFocusableStackLocked(task.getTaskToReturnTo(),myReason)) {
        mStackSupervisor.moveHomeStackToFront(myReason);
      }
    }
    if (mStacks != null) {
      mStacks.remove(this);
      mStacks.add(0,this);
    }
    if (!isHomeStack()) {
      mActivityContainer.onTaskListEmptyLocked();
    }
  }
  task.stack=null;
}",0.8958031837916064
191870,"private ActivityStack preAddTask(TaskRecord task,String reason){
  final ActivityStack prevStack=task.stack;
  if (prevStack != null && prevStack != this) {
    prevStack.removeTask(task,reason,MOVING);
  }
  return prevStack;
}","private ActivityStack preAddTask(TaskRecord task,String reason,boolean toTop){
  final ActivityStack prevStack=task.stack;
  if (prevStack != null && prevStack != this) {
    prevStack.removeTask(task,reason,toTop ? REMOVE_TASK_MODE_MOVING_TO_TOP : REMOVE_TASK_MODE_MOVING);
  }
  return prevStack;
}",0.8636363636363636
191871,"void moveTasksToFullscreenStackLocked(int fromStackId,boolean onTop){
  final ActivityStack stack=getStack(fromStackId);
  if (stack == null) {
    return;
  }
  mWindowManager.deferSurfaceLayout();
  try {
    if (fromStackId == DOCKED_STACK_ID) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,null,null,null,PRESERVE_WINDOWS,true,DEFER_RESUME);
          }
        }
      }
      mAllowDockedStackResize=false;
    }
    final ArrayList<TaskRecord> tasks=stack.getAllTasks();
    final int size=tasks.size();
    if (onTop) {
      for (int i=0; i < size; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,onTop,onTop,""String_Node_Str"",ANIMATE);
      }
    }
 else {
      for (int i=size - 1; i >= 0; i--) {
        positionTaskInStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,0);
      }
    }
  }
  finally {
    mAllowDockedStackResize=true;
    mWindowManager.continueSurfaceLayout();
  }
}","void moveTasksToFullscreenStackLocked(int fromStackId,boolean onTop){
  final ActivityStack stack=getStack(fromStackId);
  if (stack == null) {
    return;
  }
  mWindowManager.deferSurfaceLayout();
  try {
    if (fromStackId == DOCKED_STACK_ID) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,null,null,null,PRESERVE_WINDOWS,true,DEFER_RESUME);
          }
        }
      }
      mAllowDockedStackResize=false;
    }
    final ArrayList<TaskRecord> tasks=stack.getAllTasks();
    final int size=tasks.size();
    if (onTop) {
      for (int i=0; i < size; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,onTop,onTop,""String_Node_Str"",ANIMATE,DEFER_RESUME);
      }
      ensureActivitiesVisibleLocked(null,0,PRESERVE_WINDOWS);
      resumeFocusedStackTopActivityLocked();
    }
 else {
      for (int i=size - 1; i >= 0; i--) {
        positionTaskInStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,0);
      }
    }
  }
  finally {
    mAllowDockedStackResize=true;
    mWindowManager.continueSurfaceLayout();
  }
}",0.9502899751449876
191872,"/** 
 * Restores a recent task to a stack
 * @param task The recent task to be restored.
 * @param stackId The stack to restore the task to (default launch stack will be usedif stackId is  {@link android.app.ActivityManager.StackId#INVALID_STACK_ID}).
 * @return true if the task has been restored successfully.
 */
private boolean restoreRecentTaskLocked(TaskRecord task,int stackId){
  if (stackId == INVALID_STACK_ID) {
    stackId=task.getLaunchStackId();
  }
 else   if (stackId == DOCKED_STACK_ID && !task.canGoInDockedStack()) {
    stackId=FULLSCREEN_WORKSPACE_STACK_ID;
  }
  if (task.stack != null) {
    if (task.stack.mStackId == stackId) {
      return true;
    }
    task.stack.removeTask(task,""String_Node_Str"",MOVING);
  }
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,!ON_TOP);
  if (stack == null) {
    if (DEBUG_RECENTS)     Slog.v(TAG_RECENTS,""String_Node_Str"" + task);
    return false;
  }
  stack.addTask(task,false,""String_Node_Str"");
  if (DEBUG_RECENTS)   Slog.v(TAG_RECENTS,""String_Node_Str"" + task + ""String_Node_Str""+ stack);
  final ArrayList<ActivityRecord> activities=task.mActivities;
  for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
    stack.addConfigOverride(activities.get(activityNdx),task);
  }
  return true;
}","/** 
 * Restores a recent task to a stack
 * @param task The recent task to be restored.
 * @param stackId The stack to restore the task to (default launch stack will be usedif stackId is  {@link android.app.ActivityManager.StackId#INVALID_STACK_ID}).
 * @return true if the task has been restored successfully.
 */
private boolean restoreRecentTaskLocked(TaskRecord task,int stackId){
  if (stackId == INVALID_STACK_ID) {
    stackId=task.getLaunchStackId();
  }
 else   if (stackId == DOCKED_STACK_ID && !task.canGoInDockedStack()) {
    stackId=FULLSCREEN_WORKSPACE_STACK_ID;
  }
  if (task.stack != null) {
    if (task.stack.mStackId == stackId) {
      return true;
    }
    task.stack.removeTask(task,""String_Node_Str"",REMOVE_TASK_MODE_MOVING);
  }
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,!ON_TOP);
  if (stack == null) {
    if (DEBUG_RECENTS)     Slog.v(TAG_RECENTS,""String_Node_Str"" + task);
    return false;
  }
  stack.addTask(task,false,""String_Node_Str"");
  if (DEBUG_RECENTS)   Slog.v(TAG_RECENTS,""String_Node_Str"" + task + ""String_Node_Str""+ stack);
  final ArrayList<ActivityRecord> activities=task.mActivities;
  for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
    stack.addConfigOverride(activities.get(activityNdx),task);
  }
  return true;
}",0.9935040122277417
191873,"boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack,ActivityRecord target,ActivityOptions targetOptions){
  if (targetStack != null && isFocusedStack(targetStack)) {
    return targetStack.resumeTopActivityUncheckedLocked(target,targetOptions);
  }
  mFocusedStack.resumeTopActivityUncheckedLocked(null,null);
  return false;
}","boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack,ActivityRecord target,ActivityOptions targetOptions){
  if (targetStack != null && isFocusedStack(targetStack)) {
    return targetStack.resumeTopActivityUncheckedLocked(target,targetOptions);
  }
  final ActivityRecord r=mFocusedStack.topRunningActivityLocked();
  if (r == null || r.state != RESUMED) {
    mFocusedStack.resumeTopActivityUncheckedLocked(null,null);
  }
  return false;
}",0.8482587064676617
191874,"/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.getTopActivity();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}","/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.topRunningActivityLocked();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}",0.9946004319654428
191875,"/** 
 * Requests a copy of the pixels from a   {@link Surface} to be copied intoa provided  {@link Bitmap}. The contents of the source will be scaled to fit exactly inside the bitmap. The pixel format of the source buffer will be converted, as part of the copy, to fit the the bitmap's   {@link Bitmap.Config}. The most recently queued buffer in the Surface will be used as the source of the copy.
 * @param source The source from which to copy
 * @param dest The destination of the copy. The source will be scaled tomatch the width, height, and format of this bitmap.
 * @param listener Callback for when the pixel copy request completes
 * @param listenerThread The callback will be invoked on this Handler whenthe copy is finished.
 */
public static void request(@NonNull Surface source,@NonNull Bitmap dest,@NonNull OnPixelCopyFinishedListener listener,@NonNull Handler listenerThread){
  validateBitmapDest(dest);
  int result=ThreadedRenderer.copySurfaceInto(source,dest);
  listenerThread.post(new Runnable(){
    @Override public void run(){
      listener.onPixelCopyFinished(result);
    }
  }
);
}","/** 
 * Requests a copy of the pixels from a   {@link Surface} to be copied intoa provided  {@link Bitmap}. The contents of the source will be scaled to fit exactly inside the bitmap. The pixel format of the source buffer will be converted, as part of the copy, to fit the the bitmap's   {@link Bitmap.Config}. The most recently queued buffer in the Surface will be used as the source of the copy.
 * @param source The source from which to copy
 * @param dest The destination of the copy. The source will be scaled tomatch the width, height, and format of this bitmap.
 * @param listener Callback for when the pixel copy request completes
 * @param listenerThread The callback will be invoked on this Handler whenthe copy is finished.
 */
public static void request(@NonNull Surface source,@NonNull Bitmap dest,@NonNull OnPixelCopyFinishedListener listener,@NonNull Handler listenerThread){
  validateBitmapDest(dest);
  if (!source.isValid()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int result=ThreadedRenderer.copySurfaceInto(source,dest);
  listenerThread.post(new Runnable(){
    @Override public void run(){
      listener.onPixelCopyFinished(result);
    }
  }
);
}",0.9609713790112748
191876,"/** 
 * Requests a copy of the pixels from a   {@link Surface} to be copied intoa provided  {@link Bitmap}. The contents of the source will be scaled to fit exactly inside the bitmap. The pixel format of the source buffer will be converted, as part of the copy, to fit the the bitmap's   {@link Bitmap.Config}. The most recently queued buffer in the Surface will be used as the source of the copy.
 * @param source The source from which to copy
 * @param dest The destination of the copy. The source will be scaled tomatch the width, height, and format of this bitmap.
 * @param listener Callback for when the pixel copy request completes
 * @param listenerThread The callback will be invoked on this Handler whenthe copy is finished.
 */
public static void request(@NonNull Surface source,@NonNull Bitmap dest,@NonNull OnPixelCopyFinishedListener listener,@NonNull Handler listenerThread){
  validateBitmapDest(dest);
  int result=ThreadedRenderer.copySurfaceInto(source,dest);
  listenerThread.post(new Runnable(){
    @Override public void run(){
      listener.onPixelCopyFinished(result);
    }
  }
);
}","/** 
 * Requests a copy of the pixels from a   {@link Surface} to be copied intoa provided  {@link Bitmap}. The contents of the source will be scaled to fit exactly inside the bitmap. The pixel format of the source buffer will be converted, as part of the copy, to fit the the bitmap's   {@link Bitmap.Config}. The most recently queued buffer in the Surface will be used as the source of the copy.
 * @param source The source from which to copy
 * @param dest The destination of the copy. The source will be scaled tomatch the width, height, and format of this bitmap.
 * @param listener Callback for when the pixel copy request completes
 * @param listenerThread The callback will be invoked on this Handler whenthe copy is finished.
 */
public static void request(@NonNull Surface source,@NonNull Bitmap dest,@NonNull OnPixelCopyFinishedListener listener,@NonNull Handler listenerThread){
  validateBitmapDest(dest);
  if (!source.isValid()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int result=ThreadedRenderer.copySurfaceInto(source,dest);
  listenerThread.post(new Runnable(){
    @Override public void run(){
      listener.onPixelCopyFinished(result);
    }
  }
);
}",0.9609713790112748
191877,"private boolean animateForMinimizedDockedStack(long now){
  final TaskStack stack=mDisplayContent.getDockedStackVisibleForUserLocked();
  if (!mAnimationStarted) {
    mAnimationStarted=true;
    mAnimationStartTime=now;
    final long transitionDuration=isAnimationMaximizing() ? mService.mAppTransition.getLastClipRevealTransitionDuration() : DEFAULT_APP_TRANSITION_DURATION;
    mAnimationDuration=(long)(transitionDuration * mService.getTransitionAnimationScaleLocked());
    mMaximizeMeetFraction=getClipRevealMeetFraction(stack);
    notifyDockedStackMinimizedChanged(mMinimizedDock,(long)(mAnimationDuration * mMaximizeMeetFraction));
  }
  float t=Math.min(1f,(float)(now - mAnimationStartTime) / mAnimationDuration);
  t=(isAnimationMaximizing() ? TOUCH_RESPONSE_INTERPOLATOR : mMinimizedDockInterpolator).getInterpolation(t);
  if (stack != null) {
    if (stack.setAdjustedForMinimizedDock(getMinimizeAmount(stack,t))) {
      mService.mWindowPlacerLocked.performSurfacePlacement();
    }
  }
  if (t >= 1.0f) {
    mAnimatingForMinimizedDockedStack=false;
    return false;
  }
 else {
    return true;
  }
}","private boolean animateForMinimizedDockedStack(long now){
  final TaskStack stack=mService.mStackIdToStack.get(DOCKED_STACK_ID);
  if (!mAnimationStarted) {
    mAnimationStarted=true;
    mAnimationStartTime=now;
    final long transitionDuration=isAnimationMaximizing() ? mService.mAppTransition.getLastClipRevealTransitionDuration() : DEFAULT_APP_TRANSITION_DURATION;
    mAnimationDuration=(long)(transitionDuration * mService.getTransitionAnimationScaleLocked());
    mMaximizeMeetFraction=getClipRevealMeetFraction(stack);
    notifyDockedStackMinimizedChanged(mMinimizedDock,(long)(mAnimationDuration * mMaximizeMeetFraction));
  }
  float t=Math.min(1f,(float)(now - mAnimationStartTime) / mAnimationDuration);
  t=(isAnimationMaximizing() ? TOUCH_RESPONSE_INTERPOLATOR : mMinimizedDockInterpolator).getInterpolation(t);
  if (stack != null) {
    if (stack.setAdjustedForMinimizedDock(getMinimizeAmount(stack,t))) {
      mService.mWindowPlacerLocked.performSurfacePlacement();
    }
  }
  if (t >= 1.0f) {
    mAnimatingForMinimizedDockedStack=false;
    return false;
  }
 else {
    return true;
  }
}",0.9592476489028212
191878,"/** 
 * Notifies the docked stack divider controller of a visibility change that happens without an animation.
 */
void notifyAppVisibilityChanged(AppWindowToken wtoken,boolean visible){
  final Task task=wtoken.mTask;
  if (!task.isHomeTask() || !task.isVisibleForUser()) {
    return;
  }
  if (task.getTopVisibleAppToken() == null || task.getTopVisibleAppToken() != wtoken) {
    return;
  }
  if (isWithinDisplay(task) && mDisplayContent.getDockedStackVisibleForUserLocked() != null) {
    setMinimizedDockedStack(visible,false);
  }
}","/** 
 * Notifies the docked stack divider controller of a visibility change that happens without an animation.
 */
void notifyAppVisibilityChanged(AppWindowToken wtoken,boolean visible){
  final Task task=wtoken.mTask;
  if (!task.isHomeTask() || !task.isVisibleForUser()) {
    return;
  }
  if (task.getTopAppToken() == null || task.getTopAppToken() != wtoken) {
    return;
  }
  if (isWithinDisplay(task) && mDisplayContent.getDockedStackVisibleForUserLocked() != null) {
    setMinimizedDockedStack(visible,false);
  }
}",0.986842105263158
191879,"public void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"" + mStackId);
  pw.println(prefix + ""String_Node_Str"" + mDeferDetach);
  pw.println(prefix + ""String_Node_Str"" + mFullscreen);
  pw.println(prefix + ""String_Node_Str"" + mBounds.toShortString());
  if (!mAdjustedBounds.isEmpty()) {
    pw.println(prefix + ""String_Node_Str"" + mAdjustedBounds.toShortString());
  }
  for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; taskNdx--) {
    mTasks.get(taskNdx).dump(prefix + ""String_Node_Str"",pw);
  }
  if (mAnimationBackgroundSurface.isDimming()) {
    pw.println(prefix + ""String_Node_Str"");
    mAnimationBackgroundSurface.printTo(prefix + ""String_Node_Str"",pw);
  }
  if (!mExitingAppTokens.isEmpty()) {
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=mExitingAppTokens.size() - 1; i >= 0; i--) {
      WindowToken token=mExitingAppTokens.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(' ');
      pw.print(token);
      pw.println(':');
      token.dump(pw,""String_Node_Str"");
    }
  }
}","public void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"" + mStackId);
  pw.println(prefix + ""String_Node_Str"" + mDeferDetach);
  pw.println(prefix + ""String_Node_Str"" + mFullscreen);
  pw.println(prefix + ""String_Node_Str"" + mBounds.toShortString());
  if (mMinimizeAmount != 0f) {
    pw.println(prefix + ""String_Node_Str"" + mMinimizeAmount);
  }
  if (mAdjustedForIme) {
    pw.println(prefix + ""String_Node_Str"");
    pw.println(prefix + ""String_Node_Str"" + mAdjustImeAmount);
    pw.println(prefix + ""String_Node_Str"" + mAdjustDividerAmount);
  }
  if (!mAdjustedBounds.isEmpty()) {
    pw.println(prefix + ""String_Node_Str"" + mAdjustedBounds.toShortString());
  }
  for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; taskNdx--) {
    mTasks.get(taskNdx).dump(prefix + ""String_Node_Str"",pw);
  }
  if (mAnimationBackgroundSurface.isDimming()) {
    pw.println(prefix + ""String_Node_Str"");
    mAnimationBackgroundSurface.printTo(prefix + ""String_Node_Str"",pw);
  }
  if (!mExitingAppTokens.isEmpty()) {
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=mExitingAppTokens.size() - 1; i >= 0; i--) {
      WindowToken token=mExitingAppTokens.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(' ');
      pw.print(token);
      pw.println(':');
      token.dump(pw,""String_Node_Str"");
    }
  }
}",0.8772504091653028
191880,"boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.setNullAnimation();
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        if (!visible && win.isVisibleNow() && wtoken.mAppAnimator.isAnimating()) {
          win.mAnimatingExit=true;
          win.mRemoveOnExit=true;
          win.mWindowRemovalAllowed=true;
        }
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimationSet()) {
      delayed=true;
    }
  }
  if (visibilityChanged && !delayed) {
    if (visible) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
  }
  return delayed;
}","boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.setNullAnimation();
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        if (!visible && win.isVisibleNow() && wtoken.mAppAnimator.isAnimating()) {
          win.mAnimatingExit=true;
          win.mRemoveOnExit=true;
          win.mWindowRemovalAllowed=true;
        }
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimationSet()) {
      delayed=true;
    }
  }
  if (visibilityChanged) {
    if (visible && !delayed) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    if (!mClosingApps.contains(wtoken) && !mOpeningApps.contains(wtoken)) {
      getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
    }
  }
  return delayed;
}",0.95139911634757
191881,"private boolean animateForMinimizedDockedStack(long now){
  final TaskStack stack=mDisplayContent.getDockedStackVisibleForUserLocked();
  if (!mAnimationStarted) {
    mAnimationStarted=true;
    mAnimationStartTime=now;
    final long transitionDuration=isAnimationMaximizing() ? mService.mAppTransition.getLastClipRevealTransitionDuration() : DEFAULT_APP_TRANSITION_DURATION;
    mAnimationDuration=(long)(transitionDuration * mService.getTransitionAnimationScaleLocked());
    mMaximizeMeetFraction=getClipRevealMeetFraction(stack);
    notifyDockedStackMinimizedChanged(mMinimizedDock,(long)(mAnimationDuration * mMaximizeMeetFraction));
  }
  float t=Math.min(1f,(float)(now - mAnimationStartTime) / mAnimationDuration);
  t=(isAnimationMaximizing() ? TOUCH_RESPONSE_INTERPOLATOR : mMinimizedDockInterpolator).getInterpolation(t);
  if (stack != null) {
    if (stack.setAdjustedForMinimizedDock(getMinimizeAmount(stack,t))) {
      mService.mWindowPlacerLocked.performSurfacePlacement();
    }
  }
  if (t >= 1.0f) {
    mAnimatingForMinimizedDockedStack=false;
    return false;
  }
 else {
    return true;
  }
}","private boolean animateForMinimizedDockedStack(long now){
  final TaskStack stack=mService.mStackIdToStack.get(DOCKED_STACK_ID);
  if (!mAnimationStarted) {
    mAnimationStarted=true;
    mAnimationStartTime=now;
    final long transitionDuration=isAnimationMaximizing() ? mService.mAppTransition.getLastClipRevealTransitionDuration() : DEFAULT_APP_TRANSITION_DURATION;
    mAnimationDuration=(long)(transitionDuration * mService.getTransitionAnimationScaleLocked());
    mMaximizeMeetFraction=getClipRevealMeetFraction(stack);
    notifyDockedStackMinimizedChanged(mMinimizedDock,(long)(mAnimationDuration * mMaximizeMeetFraction));
  }
  float t=Math.min(1f,(float)(now - mAnimationStartTime) / mAnimationDuration);
  t=(isAnimationMaximizing() ? TOUCH_RESPONSE_INTERPOLATOR : mMinimizedDockInterpolator).getInterpolation(t);
  if (stack != null) {
    if (stack.setAdjustedForMinimizedDock(getMinimizeAmount(stack,t))) {
      mService.mWindowPlacerLocked.performSurfacePlacement();
    }
  }
  if (t >= 1.0f) {
    mAnimatingForMinimizedDockedStack=false;
    return false;
  }
 else {
    return true;
  }
}",0.9592476489028212
191882,"/** 
 * Notifies the docked stack divider controller of a visibility change that happens without an animation.
 */
void notifyAppVisibilityChanged(AppWindowToken wtoken,boolean visible){
  final Task task=wtoken.mTask;
  if (!task.isHomeTask() || !task.isVisibleForUser()) {
    return;
  }
  if (task.getTopVisibleAppToken() == null || task.getTopVisibleAppToken() != wtoken) {
    return;
  }
  if (isWithinDisplay(task) && mDisplayContent.getDockedStackVisibleForUserLocked() != null) {
    setMinimizedDockedStack(visible,false);
  }
}","/** 
 * Notifies the docked stack divider controller of a visibility change that happens without an animation.
 */
void notifyAppVisibilityChanged(AppWindowToken wtoken,boolean visible){
  final Task task=wtoken.mTask;
  if (!task.isHomeTask() || !task.isVisibleForUser()) {
    return;
  }
  if (task.getTopAppToken() == null || task.getTopAppToken() != wtoken) {
    return;
  }
  if (isWithinDisplay(task) && mDisplayContent.getDockedStackVisibleForUserLocked() != null) {
    setMinimizedDockedStack(visible,false);
  }
}",0.986842105263158
191883,"public void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"" + mStackId);
  pw.println(prefix + ""String_Node_Str"" + mDeferDetach);
  pw.println(prefix + ""String_Node_Str"" + mFullscreen);
  pw.println(prefix + ""String_Node_Str"" + mBounds.toShortString());
  if (!mAdjustedBounds.isEmpty()) {
    pw.println(prefix + ""String_Node_Str"" + mAdjustedBounds.toShortString());
  }
  for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; taskNdx--) {
    mTasks.get(taskNdx).dump(prefix + ""String_Node_Str"",pw);
  }
  if (mAnimationBackgroundSurface.isDimming()) {
    pw.println(prefix + ""String_Node_Str"");
    mAnimationBackgroundSurface.printTo(prefix + ""String_Node_Str"",pw);
  }
  if (!mExitingAppTokens.isEmpty()) {
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=mExitingAppTokens.size() - 1; i >= 0; i--) {
      WindowToken token=mExitingAppTokens.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(' ');
      pw.print(token);
      pw.println(':');
      token.dump(pw,""String_Node_Str"");
    }
  }
}","public void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"" + mStackId);
  pw.println(prefix + ""String_Node_Str"" + mDeferDetach);
  pw.println(prefix + ""String_Node_Str"" + mFullscreen);
  pw.println(prefix + ""String_Node_Str"" + mBounds.toShortString());
  if (mMinimizeAmount != 0f) {
    pw.println(prefix + ""String_Node_Str"" + mMinimizeAmount);
  }
  if (mAdjustedForIme) {
    pw.println(prefix + ""String_Node_Str"");
    pw.println(prefix + ""String_Node_Str"" + mAdjustImeAmount);
    pw.println(prefix + ""String_Node_Str"" + mAdjustDividerAmount);
  }
  if (!mAdjustedBounds.isEmpty()) {
    pw.println(prefix + ""String_Node_Str"" + mAdjustedBounds.toShortString());
  }
  for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; taskNdx--) {
    mTasks.get(taskNdx).dump(prefix + ""String_Node_Str"",pw);
  }
  if (mAnimationBackgroundSurface.isDimming()) {
    pw.println(prefix + ""String_Node_Str"");
    mAnimationBackgroundSurface.printTo(prefix + ""String_Node_Str"",pw);
  }
  if (!mExitingAppTokens.isEmpty()) {
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=mExitingAppTokens.size() - 1; i >= 0; i--) {
      WindowToken token=mExitingAppTokens.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(' ');
      pw.print(token);
      pw.println(':');
      token.dump(pw,""String_Node_Str"");
    }
  }
}",0.8772504091653028
191884,"boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.setNullAnimation();
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        if (!visible && win.isVisibleNow() && wtoken.mAppAnimator.isAnimating()) {
          win.mAnimatingExit=true;
          win.mRemoveOnExit=true;
          win.mWindowRemovalAllowed=true;
        }
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimationSet()) {
      delayed=true;
    }
  }
  if (visibilityChanged && !delayed) {
    if (visible) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
  }
  return delayed;
}","boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.setNullAnimation();
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        if (!visible && win.isVisibleNow() && wtoken.mAppAnimator.isAnimating()) {
          win.mAnimatingExit=true;
          win.mRemoveOnExit=true;
          win.mWindowRemovalAllowed=true;
        }
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimationSet()) {
      delayed=true;
    }
  }
  if (visibilityChanged) {
    if (visible && !delayed) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    if (!mClosingApps.contains(wtoken) && !mOpeningApps.contains(wtoken)) {
      getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
    }
  }
  return delayed;
}",0.95139911634757
191885,"/** 
 * Requests a copy of the pixels from a   {@link Surface} to be copied intoa provided  {@link Bitmap}. The contents of the source will be scaled to fit exactly inside the bitmap. The pixel format of the source buffer will be converted, as part of the copy, to fit the the bitmap's   {@link Bitmap.Config}. The most recently queued buffer in the Surface will be used as the source of the copy.
 * @param source The source from which to copy
 * @param dest The destination of the copy. The source will be scaled tomatch the width, height, and format of this bitmap.
 * @param listener Callback for when the pixel copy request completes
 * @param listenerThread The callback will be invoked on this Handler whenthe copy is finished.
 */
public static void request(@NonNull Surface source,@NonNull Bitmap dest,@NonNull OnPixelCopyFinishedListener listener,@NonNull Handler listenerThread){
  validateBitmapDest(dest);
  int result=ThreadedRenderer.copySurfaceInto(source,dest);
  listenerThread.post(new Runnable(){
    @Override public void run(){
      listener.onPixelCopyFinished(result);
    }
  }
);
}","/** 
 * Requests a copy of the pixels from a   {@link Surface} to be copied intoa provided  {@link Bitmap}. The contents of the source will be scaled to fit exactly inside the bitmap. The pixel format of the source buffer will be converted, as part of the copy, to fit the the bitmap's   {@link Bitmap.Config}. The most recently queued buffer in the Surface will be used as the source of the copy.
 * @param source The source from which to copy
 * @param dest The destination of the copy. The source will be scaled tomatch the width, height, and format of this bitmap.
 * @param listener Callback for when the pixel copy request completes
 * @param listenerThread The callback will be invoked on this Handler whenthe copy is finished.
 */
public static void request(@NonNull Surface source,@NonNull Bitmap dest,@NonNull OnPixelCopyFinishedListener listener,@NonNull Handler listenerThread){
  validateBitmapDest(dest);
  if (!source.isValid()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int result=ThreadedRenderer.copySurfaceInto(source,dest);
  listenerThread.post(new Runnable(){
    @Override public void run(){
      listener.onPixelCopyFinished(result);
    }
  }
);
}",0.9609713790112748
191886,"private boolean animateForMinimizedDockedStack(long now){
  final TaskStack stack=mDisplayContent.getDockedStackVisibleForUserLocked();
  if (!mAnimationStarted) {
    mAnimationStarted=true;
    mAnimationStartTime=now;
    final long transitionDuration=isAnimationMaximizing() ? mService.mAppTransition.getLastClipRevealTransitionDuration() : DEFAULT_APP_TRANSITION_DURATION;
    mAnimationDuration=(long)(transitionDuration * mService.getTransitionAnimationScaleLocked());
    mMaximizeMeetFraction=getClipRevealMeetFraction(stack);
    notifyDockedStackMinimizedChanged(mMinimizedDock,(long)(mAnimationDuration * mMaximizeMeetFraction));
  }
  float t=Math.min(1f,(float)(now - mAnimationStartTime) / mAnimationDuration);
  t=(isAnimationMaximizing() ? TOUCH_RESPONSE_INTERPOLATOR : mMinimizedDockInterpolator).getInterpolation(t);
  if (stack != null) {
    if (stack.setAdjustedForMinimizedDock(getMinimizeAmount(stack,t))) {
      mService.mWindowPlacerLocked.performSurfacePlacement();
    }
  }
  if (t >= 1.0f) {
    mAnimatingForMinimizedDockedStack=false;
    return false;
  }
 else {
    return true;
  }
}","private boolean animateForMinimizedDockedStack(long now){
  final TaskStack stack=mService.mStackIdToStack.get(DOCKED_STACK_ID);
  if (!mAnimationStarted) {
    mAnimationStarted=true;
    mAnimationStartTime=now;
    final long transitionDuration=isAnimationMaximizing() ? mService.mAppTransition.getLastClipRevealTransitionDuration() : DEFAULT_APP_TRANSITION_DURATION;
    mAnimationDuration=(long)(transitionDuration * mService.getTransitionAnimationScaleLocked());
    mMaximizeMeetFraction=getClipRevealMeetFraction(stack);
    notifyDockedStackMinimizedChanged(mMinimizedDock,(long)(mAnimationDuration * mMaximizeMeetFraction));
  }
  float t=Math.min(1f,(float)(now - mAnimationStartTime) / mAnimationDuration);
  t=(isAnimationMaximizing() ? TOUCH_RESPONSE_INTERPOLATOR : mMinimizedDockInterpolator).getInterpolation(t);
  if (stack != null) {
    if (stack.setAdjustedForMinimizedDock(getMinimizeAmount(stack,t))) {
      mService.mWindowPlacerLocked.performSurfacePlacement();
    }
  }
  if (t >= 1.0f) {
    mAnimatingForMinimizedDockedStack=false;
    return false;
  }
 else {
    return true;
  }
}",0.9592476489028212
191887,"/** 
 * Notifies the docked stack divider controller of a visibility change that happens without an animation.
 */
void notifyAppVisibilityChanged(AppWindowToken wtoken,boolean visible){
  final Task task=wtoken.mTask;
  if (!task.isHomeTask() || !task.isVisibleForUser()) {
    return;
  }
  if (task.getTopVisibleAppToken() == null || task.getTopVisibleAppToken() != wtoken) {
    return;
  }
  if (isWithinDisplay(task) && mDisplayContent.getDockedStackVisibleForUserLocked() != null) {
    setMinimizedDockedStack(visible,false);
  }
}","/** 
 * Notifies the docked stack divider controller of a visibility change that happens without an animation.
 */
void notifyAppVisibilityChanged(AppWindowToken wtoken,boolean visible){
  final Task task=wtoken.mTask;
  if (!task.isHomeTask() || !task.isVisibleForUser()) {
    return;
  }
  if (task.getTopAppToken() == null || task.getTopAppToken() != wtoken) {
    return;
  }
  if (isWithinDisplay(task) && mDisplayContent.getDockedStackVisibleForUserLocked() != null) {
    setMinimizedDockedStack(visible,false);
  }
}",0.986842105263158
191888,"public void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"" + mStackId);
  pw.println(prefix + ""String_Node_Str"" + mDeferDetach);
  pw.println(prefix + ""String_Node_Str"" + mFullscreen);
  pw.println(prefix + ""String_Node_Str"" + mBounds.toShortString());
  if (!mAdjustedBounds.isEmpty()) {
    pw.println(prefix + ""String_Node_Str"" + mAdjustedBounds.toShortString());
  }
  for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; taskNdx--) {
    mTasks.get(taskNdx).dump(prefix + ""String_Node_Str"",pw);
  }
  if (mAnimationBackgroundSurface.isDimming()) {
    pw.println(prefix + ""String_Node_Str"");
    mAnimationBackgroundSurface.printTo(prefix + ""String_Node_Str"",pw);
  }
  if (!mExitingAppTokens.isEmpty()) {
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=mExitingAppTokens.size() - 1; i >= 0; i--) {
      WindowToken token=mExitingAppTokens.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(' ');
      pw.print(token);
      pw.println(':');
      token.dump(pw,""String_Node_Str"");
    }
  }
}","public void dump(String prefix,PrintWriter pw){
  pw.println(prefix + ""String_Node_Str"" + mStackId);
  pw.println(prefix + ""String_Node_Str"" + mDeferDetach);
  pw.println(prefix + ""String_Node_Str"" + mFullscreen);
  pw.println(prefix + ""String_Node_Str"" + mBounds.toShortString());
  if (mMinimizeAmount != 0f) {
    pw.println(prefix + ""String_Node_Str"" + mMinimizeAmount);
  }
  if (mAdjustedForIme) {
    pw.println(prefix + ""String_Node_Str"");
    pw.println(prefix + ""String_Node_Str"" + mAdjustImeAmount);
    pw.println(prefix + ""String_Node_Str"" + mAdjustDividerAmount);
  }
  if (!mAdjustedBounds.isEmpty()) {
    pw.println(prefix + ""String_Node_Str"" + mAdjustedBounds.toShortString());
  }
  for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; taskNdx--) {
    mTasks.get(taskNdx).dump(prefix + ""String_Node_Str"",pw);
  }
  if (mAnimationBackgroundSurface.isDimming()) {
    pw.println(prefix + ""String_Node_Str"");
    mAnimationBackgroundSurface.printTo(prefix + ""String_Node_Str"",pw);
  }
  if (!mExitingAppTokens.isEmpty()) {
    pw.println();
    pw.println(""String_Node_Str"");
    for (int i=mExitingAppTokens.size() - 1; i >= 0; i--) {
      WindowToken token=mExitingAppTokens.get(i);
      pw.print(""String_Node_Str"");
      pw.print(i);
      pw.print(' ');
      pw.print(token);
      pw.println(':');
      token.dump(pw,""String_Node_Str"");
    }
  }
}",0.8772504091653028
191889,"boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.setNullAnimation();
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        if (!visible && win.isVisibleNow() && wtoken.mAppAnimator.isAnimating()) {
          win.mAnimatingExit=true;
          win.mRemoveOnExit=true;
          win.mWindowRemovalAllowed=true;
        }
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimationSet()) {
      delayed=true;
    }
  }
  if (visibilityChanged && !delayed) {
    if (visible) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
  }
  return delayed;
}","boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.setNullAnimation();
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        if (!visible && win.isVisibleNow() && wtoken.mAppAnimator.isAnimating()) {
          win.mAnimatingExit=true;
          win.mRemoveOnExit=true;
          win.mWindowRemovalAllowed=true;
        }
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimationSet()) {
      delayed=true;
    }
  }
  if (visibilityChanged) {
    if (visible && !delayed) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    if (!mClosingApps.contains(wtoken) && !mOpeningApps.contains(wtoken)) {
      getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
    }
  }
  return delayed;
}",0.95139911634757
191890,"Bitmap screenshotApplicationsInner(IBinder appToken,int displayId,int width,int height,boolean includeFullDisplay,float frameScale,Bitmap.Config config){
  final DisplayContent displayContent;
synchronized (mWindowMap) {
    displayContent=getDisplayContentLocked(displayId);
    if (displayContent == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ displayId);
      return null;
    }
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  int dw=displayInfo.logicalWidth;
  int dh=displayInfo.logicalHeight;
  if (dw == 0 || dh == 0) {
    if (DEBUG_SCREENSHOT)     Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh);
    return null;
  }
  Bitmap bm=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  final Rect stackBounds=new Rect();
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  WindowState appWin=null;
  boolean appIsImTarget;
synchronized (mWindowMap) {
    appIsImTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
  }
  final int aboveAppLayer=(mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
synchronized (mWindowMap) {
    appWin=null;
    final WindowList windows=displayContent.getWindowList();
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState ws=windows.get(i);
      if (!ws.mHasSurface) {
        continue;
      }
      if (ws.mLayer >= aboveAppLayer) {
        continue;
      }
      if (ws.mIsImWindow) {
        if (!appIsImTarget) {
          continue;
        }
      }
 else       if (ws.mIsWallpaper) {
        if (appWin == null) {
          continue;
        }
      }
 else       if (appToken != null) {
        if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
          continue;
        }
        appWin=ws;
      }
      final WindowStateAnimator winAnim=ws.mWinAnimator;
      int layer=winAnim.mSurfaceController.getLayer();
      if (maxLayer < layer) {
        maxLayer=layer;
      }
      if (minLayer > layer) {
        minLayer=layer;
      }
      if (!includeFullDisplay && !ws.mIsWallpaper) {
        final Rect wf=ws.mFrame;
        final Rect cr=ws.mContentInsets;
        int left=wf.left + cr.left;
        int top=wf.top + cr.top;
        int right=wf.right - cr.right;
        int bottom=wf.bottom - cr.bottom;
        frame.union(left,top,right,bottom);
        ws.getVisibleBounds(stackBounds);
        if (!Rect.intersects(frame,stackBounds)) {
          frame.setEmpty();
        }
      }
      if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw() && winAnim.getShown()) {
        screenshotReady=true;
      }
      if (ws.isObscuringFullscreen(displayInfo)) {
        break;
      }
    }
    if (appToken != null && appWin == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken);
      return null;
    }
    if (!screenshotReady) {
      Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
      return null;
    }
    if (maxLayer == 0) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ maxLayer);
      return null;
    }
    if (!includeFullDisplay) {
      if (!frame.intersect(0,0,dw,dh)) {
        frame.setEmpty();
      }
    }
 else {
      frame.set(0,0,dw,dh);
    }
    if (frame.isEmpty()) {
      return null;
    }
    if (width < 0) {
      width=(int)(frame.width() * frameScale);
    }
    if (height < 0) {
      height=(int)(frame.height() * frameScale);
    }
    Rect crop=new Rect(frame);
    if (width / (float)frame.width() < height / (float)frame.height()) {
      int cropWidth=(int)((float)width / (float)height * frame.height());
      crop.right=crop.left + cropWidth;
    }
 else {
      int cropHeight=(int)((float)height / (float)width * frame.width());
      crop.bottom=crop.top + cropHeight;
    }
    int rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
    if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
      rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
    }
    convertCropForSurfaceFlinger(crop,rot,dw,dh);
    if (DEBUG_SCREENSHOT) {
      Slog.i(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
      for (int i=0; i < windows.size(); i++) {
        WindowState win=windows.get(i);
        Slog.i(TAG_WM,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceController.getLayer());
      }
    }
    ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    final boolean inRotation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
    if (DEBUG_SCREENSHOT && inRotation)     Slog.v(TAG_WM,""String_Node_Str"");
    bm=SurfaceControl.screenshot(crop,width,height,minLayer,maxLayer,inRotation,rot);
    if (bm == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
      return null;
    }
  }
  if (DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    final int firstColor=buffer[0];
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != firstColor) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG_WM,""String_Node_Str"" + appWin + ""String_Node_Str""+ Integer.toHexString(firstColor)+ ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceController.getLayer() : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  Bitmap ret=bm.createAshmemBitmap(config);
  bm.recycle();
  return ret;
}","Bitmap screenshotApplicationsInner(IBinder appToken,int displayId,int width,int height,boolean includeFullDisplay,float frameScale,Bitmap.Config config){
  final DisplayContent displayContent;
synchronized (mWindowMap) {
    displayContent=getDisplayContentLocked(displayId);
    if (displayContent == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ displayId);
      return null;
    }
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  int dw=displayInfo.logicalWidth;
  int dh=displayInfo.logicalHeight;
  if (dw == 0 || dh == 0) {
    if (DEBUG_SCREENSHOT)     Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh);
    return null;
  }
  Bitmap bm=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  final Rect stackBounds=new Rect();
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  WindowState appWin=null;
  boolean appIsImTarget;
synchronized (mWindowMap) {
    appIsImTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
  }
  final int aboveAppLayer=(mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
synchronized (mWindowMap) {
    appWin=null;
    final WindowList windows=displayContent.getWindowList();
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState ws=windows.get(i);
      if (!ws.mHasSurface) {
        continue;
      }
      if (ws.mLayer >= aboveAppLayer) {
        continue;
      }
      if (ws.mIsImWindow) {
        if (!appIsImTarget) {
          continue;
        }
      }
 else       if (ws.mIsWallpaper) {
        if (appWin == null) {
          continue;
        }
      }
 else       if (appToken != null) {
        if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
          continue;
        }
        appWin=ws;
      }
      final WindowStateAnimator winAnim=ws.mWinAnimator;
      int layer=winAnim.mSurfaceController.getLayer();
      if (maxLayer < layer) {
        maxLayer=layer;
      }
      if (minLayer > layer) {
        minLayer=layer;
      }
      if (!includeFullDisplay && !ws.mIsWallpaper) {
        final Rect wf=ws.mFrame;
        final Rect cr=ws.mContentInsets;
        int left=wf.left + cr.left;
        int top=wf.top + cr.top;
        int right=wf.right - cr.right;
        int bottom=wf.bottom - cr.bottom;
        frame.union(left,top,right,bottom);
        ws.getVisibleBounds(stackBounds);
        if (!Rect.intersects(frame,stackBounds)) {
          frame.setEmpty();
        }
      }
      if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw() && winAnim.getShown()) {
        screenshotReady=true;
      }
      if (ws.isObscuringFullscreen(displayInfo)) {
        break;
      }
    }
    if (appToken != null && appWin == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken);
      return null;
    }
    if (!screenshotReady) {
      Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
      return null;
    }
    if (maxLayer == 0) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ maxLayer);
      return null;
    }
    if (!includeFullDisplay) {
      if (!frame.intersect(0,0,dw,dh)) {
        frame.setEmpty();
      }
    }
 else {
      frame.set(0,0,dw,dh);
    }
    if (frame.isEmpty()) {
      return null;
    }
    if (width < 0) {
      width=(int)(frame.width() * frameScale);
    }
    if (height < 0) {
      height=(int)(frame.height() * frameScale);
    }
    Rect crop=new Rect(frame);
    if (width / (float)frame.width() < height / (float)frame.height()) {
      int cropWidth=(int)((float)width / (float)height * frame.height());
      crop.right=crop.left + cropWidth;
    }
 else {
      int cropHeight=(int)((float)height / (float)width * frame.width());
      crop.bottom=crop.top + cropHeight;
    }
    int rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
    if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
      rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
    }
    convertCropForSurfaceFlinger(crop,rot,dw,dh);
    if (DEBUG_SCREENSHOT) {
      Slog.i(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
      for (int i=0; i < windows.size(); i++) {
        WindowState win=windows.get(i);
        WindowSurfaceController controller=win.mWinAnimator.mSurfaceController;
        Slog.i(TAG_WM,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ ((controller == null) ? ""String_Node_Str"" : controller.getLayer()));
      }
    }
    ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    final boolean inRotation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
    if (DEBUG_SCREENSHOT && inRotation)     Slog.v(TAG_WM,""String_Node_Str"");
    bm=SurfaceControl.screenshot(crop,width,height,minLayer,maxLayer,inRotation,rot);
    if (bm == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
      return null;
    }
  }
  if (DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    final int firstColor=buffer[0];
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != firstColor) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG_WM,""String_Node_Str"" + appWin + ""String_Node_Str""+ Integer.toHexString(firstColor)+ ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceController.getLayer() : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  Bitmap ret=bm.createAshmemBitmap(config);
  bm.recycle();
  return ret;
}",0.9880503144654088
191891,"/** 
 * Notify registered observers within the designated user(s) that a row was updated.
 * @hide
 */
public void notifyChange(Uri uri,ContentObserver observer,@NotifyFlags int flags,@UserIdInt int userHandle){
  try {
    getContentService().notifyChange(uri,observer == null ? null : observer.getContentObserver(),observer != null && observer.deliverSelfNotifications(),flags,userHandle);
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Notify registered observers within the designated user(s) that a row was updated.
 * @hide
 */
public void notifyChange(@NonNull Uri uri,ContentObserver observer,@NotifyFlags int flags,@UserIdInt int userHandle){
  try {
    getContentService().notifyChange(uri,observer == null ? null : observer.getContentObserver(),observer != null && observer.deliverSelfNotifications(),flags,userHandle);
  }
 catch (  RemoteException e) {
  }
}",0.9140893470790378
191892,"/** 
 * Notify registered observers within the designated user(s) that a row was updated.
 * @hide
 */
public void notifyChange(Uri uri,ContentObserver observer,@NotifyFlags int flags,@UserIdInt int userHandle){
  try {
    getContentService().notifyChange(uri,observer == null ? null : observer.getContentObserver(),observer != null && observer.deliverSelfNotifications(),flags,userHandle);
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Notify registered observers within the designated user(s) that a row was updated.
 * @hide
 */
public void notifyChange(@NonNull Uri uri,ContentObserver observer,@NotifyFlags int flags,@UserIdInt int userHandle){
  try {
    getContentService().notifyChange(uri,observer == null ? null : observer.getContentObserver(),observer != null && observer.deliverSelfNotifications(),flags,userHandle);
  }
 catch (  RemoteException e) {
  }
}",0.9140893470790378
191893,"Bitmap screenshotApplicationsInner(IBinder appToken,int displayId,int width,int height,boolean includeFullDisplay,float frameScale,Bitmap.Config config){
  final DisplayContent displayContent;
synchronized (mWindowMap) {
    displayContent=getDisplayContentLocked(displayId);
    if (displayContent == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ displayId);
      return null;
    }
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  int dw=displayInfo.logicalWidth;
  int dh=displayInfo.logicalHeight;
  if (dw == 0 || dh == 0) {
    if (DEBUG_SCREENSHOT)     Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh);
    return null;
  }
  Bitmap bm=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  final Rect stackBounds=new Rect();
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  WindowState appWin=null;
  boolean appIsImTarget;
synchronized (mWindowMap) {
    appIsImTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
  }
  final int aboveAppLayer=(mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
synchronized (mWindowMap) {
    appWin=null;
    final WindowList windows=displayContent.getWindowList();
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState ws=windows.get(i);
      if (!ws.mHasSurface) {
        continue;
      }
      if (ws.mLayer >= aboveAppLayer) {
        continue;
      }
      if (ws.mIsImWindow) {
        if (!appIsImTarget) {
          continue;
        }
      }
 else       if (ws.mIsWallpaper) {
        if (appWin == null) {
          continue;
        }
      }
 else       if (appToken != null) {
        if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
          continue;
        }
        appWin=ws;
      }
      final WindowStateAnimator winAnim=ws.mWinAnimator;
      int layer=winAnim.mSurfaceController.getLayer();
      if (maxLayer < layer) {
        maxLayer=layer;
      }
      if (minLayer > layer) {
        minLayer=layer;
      }
      if (!includeFullDisplay && !ws.mIsWallpaper) {
        final Rect wf=ws.mFrame;
        final Rect cr=ws.mContentInsets;
        int left=wf.left + cr.left;
        int top=wf.top + cr.top;
        int right=wf.right - cr.right;
        int bottom=wf.bottom - cr.bottom;
        frame.union(left,top,right,bottom);
        ws.getVisibleBounds(stackBounds);
        if (!Rect.intersects(frame,stackBounds)) {
          frame.setEmpty();
        }
      }
      if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw() && winAnim.getShown()) {
        screenshotReady=true;
      }
      if (ws.isObscuringFullscreen(displayInfo)) {
        break;
      }
    }
    if (appToken != null && appWin == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken);
      return null;
    }
    if (!screenshotReady) {
      Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
      return null;
    }
    if (maxLayer == 0) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ maxLayer);
      return null;
    }
    if (!includeFullDisplay) {
      if (!frame.intersect(0,0,dw,dh)) {
        frame.setEmpty();
      }
    }
 else {
      frame.set(0,0,dw,dh);
    }
    if (frame.isEmpty()) {
      return null;
    }
    if (width < 0) {
      width=(int)(frame.width() * frameScale);
    }
    if (height < 0) {
      height=(int)(frame.height() * frameScale);
    }
    Rect crop=new Rect(frame);
    if (width / (float)frame.width() < height / (float)frame.height()) {
      int cropWidth=(int)((float)width / (float)height * frame.height());
      crop.right=crop.left + cropWidth;
    }
 else {
      int cropHeight=(int)((float)height / (float)width * frame.width());
      crop.bottom=crop.top + cropHeight;
    }
    int rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
    if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
      rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
    }
    convertCropForSurfaceFlinger(crop,rot,dw,dh);
    if (DEBUG_SCREENSHOT) {
      Slog.i(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
      for (int i=0; i < windows.size(); i++) {
        WindowState win=windows.get(i);
        Slog.i(TAG_WM,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceController.getLayer());
      }
    }
    ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    final boolean inRotation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
    if (DEBUG_SCREENSHOT && inRotation)     Slog.v(TAG_WM,""String_Node_Str"");
    bm=SurfaceControl.screenshot(crop,width,height,minLayer,maxLayer,inRotation,rot);
    if (bm == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
      return null;
    }
  }
  if (DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    final int firstColor=buffer[0];
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != firstColor) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG_WM,""String_Node_Str"" + appWin + ""String_Node_Str""+ Integer.toHexString(firstColor)+ ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceController.getLayer() : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  Bitmap ret=bm.createAshmemBitmap(config);
  bm.recycle();
  return ret;
}","Bitmap screenshotApplicationsInner(IBinder appToken,int displayId,int width,int height,boolean includeFullDisplay,float frameScale,Bitmap.Config config){
  final DisplayContent displayContent;
synchronized (mWindowMap) {
    displayContent=getDisplayContentLocked(displayId);
    if (displayContent == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ displayId);
      return null;
    }
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  int dw=displayInfo.logicalWidth;
  int dh=displayInfo.logicalHeight;
  if (dw == 0 || dh == 0) {
    if (DEBUG_SCREENSHOT)     Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh);
    return null;
  }
  Bitmap bm=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  final Rect stackBounds=new Rect();
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  WindowState appWin=null;
  boolean appIsImTarget;
synchronized (mWindowMap) {
    appIsImTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
  }
  final int aboveAppLayer=(mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
synchronized (mWindowMap) {
    appWin=null;
    final WindowList windows=displayContent.getWindowList();
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState ws=windows.get(i);
      if (!ws.mHasSurface) {
        continue;
      }
      if (ws.mLayer >= aboveAppLayer) {
        continue;
      }
      if (ws.mIsImWindow) {
        if (!appIsImTarget) {
          continue;
        }
      }
 else       if (ws.mIsWallpaper) {
        if (appWin == null) {
          continue;
        }
      }
 else       if (appToken != null) {
        if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
          continue;
        }
        appWin=ws;
      }
      final WindowStateAnimator winAnim=ws.mWinAnimator;
      int layer=winAnim.mSurfaceController.getLayer();
      if (maxLayer < layer) {
        maxLayer=layer;
      }
      if (minLayer > layer) {
        minLayer=layer;
      }
      if (!includeFullDisplay && !ws.mIsWallpaper) {
        final Rect wf=ws.mFrame;
        final Rect cr=ws.mContentInsets;
        int left=wf.left + cr.left;
        int top=wf.top + cr.top;
        int right=wf.right - cr.right;
        int bottom=wf.bottom - cr.bottom;
        frame.union(left,top,right,bottom);
        ws.getVisibleBounds(stackBounds);
        if (!Rect.intersects(frame,stackBounds)) {
          frame.setEmpty();
        }
      }
      if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw() && winAnim.getShown()) {
        screenshotReady=true;
      }
      if (ws.isObscuringFullscreen(displayInfo)) {
        break;
      }
    }
    if (appToken != null && appWin == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken);
      return null;
    }
    if (!screenshotReady) {
      Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
      return null;
    }
    if (maxLayer == 0) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ maxLayer);
      return null;
    }
    if (!includeFullDisplay) {
      if (!frame.intersect(0,0,dw,dh)) {
        frame.setEmpty();
      }
    }
 else {
      frame.set(0,0,dw,dh);
    }
    if (frame.isEmpty()) {
      return null;
    }
    if (width < 0) {
      width=(int)(frame.width() * frameScale);
    }
    if (height < 0) {
      height=(int)(frame.height() * frameScale);
    }
    Rect crop=new Rect(frame);
    if (width / (float)frame.width() < height / (float)frame.height()) {
      int cropWidth=(int)((float)width / (float)height * frame.height());
      crop.right=crop.left + cropWidth;
    }
 else {
      int cropHeight=(int)((float)height / (float)width * frame.width());
      crop.bottom=crop.top + cropHeight;
    }
    int rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
    if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
      rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
    }
    convertCropForSurfaceFlinger(crop,rot,dw,dh);
    if (DEBUG_SCREENSHOT) {
      Slog.i(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
      for (int i=0; i < windows.size(); i++) {
        WindowState win=windows.get(i);
        WindowSurfaceController controller=win.mWinAnimator.mSurfaceController;
        Slog.i(TAG_WM,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ ((controller == null) ? ""String_Node_Str"" : controller.getLayer()));
      }
    }
    ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    final boolean inRotation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
    if (DEBUG_SCREENSHOT && inRotation)     Slog.v(TAG_WM,""String_Node_Str"");
    bm=SurfaceControl.screenshot(crop,width,height,minLayer,maxLayer,inRotation,rot);
    if (bm == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
      return null;
    }
  }
  if (DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    final int firstColor=buffer[0];
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != firstColor) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG_WM,""String_Node_Str"" + appWin + ""String_Node_Str""+ Integer.toHexString(firstColor)+ ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceController.getLayer() : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  Bitmap ret=bm.createAshmemBitmap(config);
  bm.recycle();
  return ret;
}",0.9880503144654088
191894,"/** 
 * Notify registered observers within the designated user(s) that a row was updated.
 * @hide
 */
public void notifyChange(Uri uri,ContentObserver observer,@NotifyFlags int flags,@UserIdInt int userHandle){
  try {
    getContentService().notifyChange(uri,observer == null ? null : observer.getContentObserver(),observer != null && observer.deliverSelfNotifications(),flags,userHandle);
  }
 catch (  RemoteException e) {
  }
}","/** 
 * Notify registered observers within the designated user(s) that a row was updated.
 * @hide
 */
public void notifyChange(@NonNull Uri uri,ContentObserver observer,@NotifyFlags int flags,@UserIdInt int userHandle){
  try {
    getContentService().notifyChange(uri,observer == null ? null : observer.getContentObserver(),observer != null && observer.deliverSelfNotifications(),flags,userHandle);
  }
 catch (  RemoteException e) {
  }
}",0.9140893470790378
191895,"@Override protected void updateTransformedTypes(){
  super.updateTransformedTypes();
  if (mActions != null) {
    mTransformationHelper.addTransformedView(TransformableView.TRANSFORMING_VIEW_TEXT,mActions);
  }
}","@Override protected void updateTransformedTypes(){
  super.updateTransformedTypes();
  if (mActions != null) {
    mTransformationHelper.addTransformedView(TransformableView.TRANSFORMING_VIEW_ACTIONS,mActions);
  }
}",0.9743589743589745
191896,"@Override protected void updateTransformedTypes(){
  super.updateTransformedTypes();
  if (mActions != null) {
    mTransformationHelper.addTransformedView(TransformableView.TRANSFORMING_VIEW_TEXT,mActions);
  }
}","@Override protected void updateTransformedTypes(){
  super.updateTransformedTypes();
  if (mActions != null) {
    mTransformationHelper.addTransformedView(TransformableView.TRANSFORMING_VIEW_ACTIONS,mActions);
  }
}",0.9743589743589745
191897,"private int runQueryIntentReceivers(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentReceivers(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      pw.print(result.size());
      pw.println(""String_Node_Str"");
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      for (int i=0; i < result.size(); i++) {
        pw.print(""String_Node_Str"");
        pw.print(i);
        pw.println(""String_Node_Str"");
        result.get(i).dump(pr,""String_Node_Str"");
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runQueryIntentReceivers(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentReceivers(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      if (!mComponents) {
        pw.print(result.size());
        pw.println(""String_Node_Str"");
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          pw.print(""String_Node_Str"");
          pw.print(i);
          pw.println(""String_Node_Str"");
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
 else {
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.8225490196078431
191898,"private Intent parseIntentAndUser() throws URISyntaxException {
  mTargetUser=UserHandle.USER_CURRENT;
  Intent intent=Intent.parseCommandArgs(this,new Intent.CommandOptionHandler(){
    @Override public boolean handleOption(    String opt,    ShellCommand cmd){
      if (""String_Node_Str"".equals(opt)) {
        mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
        return true;
      }
      return false;
    }
  }
);
  mTargetUser=ActivityManager.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),mTargetUser,false,false,null,null);
  return intent;
}","private Intent parseIntentAndUser() throws URISyntaxException {
  mTargetUser=UserHandle.USER_CURRENT;
  mBrief=false;
  mComponents=false;
  Intent intent=Intent.parseCommandArgs(this,new Intent.CommandOptionHandler(){
    @Override public boolean handleOption(    String opt,    ShellCommand cmd){
      if (""String_Node_Str"".equals(opt)) {
        mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
        return true;
      }
 else       if (""String_Node_Str"".equals(opt)) {
        mBrief=true;
        return true;
      }
 else       if (""String_Node_Str"".equals(opt)) {
        mComponents=true;
        return true;
      }
      return false;
    }
  }
);
  mTargetUser=ActivityManager.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),mTargetUser,false,false,null,null);
  return intent;
}",0.8305084745762712
191899,"private int runQueryIntentActivities(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentActivities(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      pw.print(result.size());
      pw.println(""String_Node_Str"");
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      for (int i=0; i < result.size(); i++) {
        pw.print(""String_Node_Str"");
        pw.print(i);
        pw.println(""String_Node_Str"");
        result.get(i).dump(pr,""String_Node_Str"");
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runQueryIntentActivities(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentActivities(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      if (!mComponents) {
        pw.print(result.size());
        pw.println(""String_Node_Str"");
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          pw.print(""String_Node_Str"");
          pw.print(i);
          pw.println(""String_Node_Str"");
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
 else {
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.8228962818003914
191900,"@Override public boolean handleOption(String opt,ShellCommand cmd){
  if (""String_Node_Str"".equals(opt)) {
    mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
    return true;
  }
  return false;
}","@Override public boolean handleOption(String opt,ShellCommand cmd){
  if (""String_Node_Str"".equals(opt)) {
    mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
    return true;
  }
 else   if (""String_Node_Str"".equals(opt)) {
    mBrief=true;
    return true;
  }
 else   if (""String_Node_Str"".equals(opt)) {
    mComponents=true;
    return true;
  }
  return false;
}",0.6621848739495798
191901,"private int runQueryIntentServices(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentServices(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      pw.print(result.size());
      pw.println(""String_Node_Str"");
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      for (int i=0; i < result.size(); i++) {
        pw.print(""String_Node_Str"");
        pw.print(i);
        pw.println(""String_Node_Str"");
        result.get(i).dump(pr,""String_Node_Str"");
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runQueryIntentServices(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentServices(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      if (!mComponents) {
        pw.print(result.size());
        pw.println(""String_Node_Str"");
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          pw.print(""String_Node_Str"");
          pw.print(i);
          pw.println(""String_Node_Str"");
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
 else {
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.8222003929273084
191902,"private int runResolveActivity(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    ResolveInfo ri=mInterface.resolveIntent(intent,null,0,mTargetUser);
    PrintWriter pw=getOutPrintWriter();
    if (ri == null) {
      pw.println(""String_Node_Str"");
    }
 else {
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      ri.dump(pr,""String_Node_Str"");
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runResolveActivity(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    ResolveInfo ri=mInterface.resolveIntent(intent,null,0,mTargetUser);
    PrintWriter pw=getOutPrintWriter();
    if (ri == null) {
      pw.println(""String_Node_Str"");
    }
 else {
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      printResolveInfo(pr,""String_Node_Str"",ri,mBrief,mComponents);
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.9622799664710812
191903,"@Override protected void updateTransformedTypes(){
  super.updateTransformedTypes();
  if (mActions != null) {
    mTransformationHelper.addTransformedView(TransformableView.TRANSFORMING_VIEW_TEXT,mActions);
  }
}","@Override protected void updateTransformedTypes(){
  super.updateTransformedTypes();
  if (mActions != null) {
    mTransformationHelper.addTransformedView(TransformableView.TRANSFORMING_VIEW_ACTIONS,mActions);
  }
}",0.9743589743589745
191904,"private int runQueryIntentReceivers(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentReceivers(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      pw.print(result.size());
      pw.println(""String_Node_Str"");
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      for (int i=0; i < result.size(); i++) {
        pw.print(""String_Node_Str"");
        pw.print(i);
        pw.println(""String_Node_Str"");
        result.get(i).dump(pr,""String_Node_Str"");
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runQueryIntentReceivers(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentReceivers(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      if (!mComponents) {
        pw.print(result.size());
        pw.println(""String_Node_Str"");
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          pw.print(""String_Node_Str"");
          pw.print(i);
          pw.println(""String_Node_Str"");
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
 else {
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.8225490196078431
191905,"private Intent parseIntentAndUser() throws URISyntaxException {
  mTargetUser=UserHandle.USER_CURRENT;
  Intent intent=Intent.parseCommandArgs(this,new Intent.CommandOptionHandler(){
    @Override public boolean handleOption(    String opt,    ShellCommand cmd){
      if (""String_Node_Str"".equals(opt)) {
        mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
        return true;
      }
      return false;
    }
  }
);
  mTargetUser=ActivityManager.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),mTargetUser,false,false,null,null);
  return intent;
}","private Intent parseIntentAndUser() throws URISyntaxException {
  mTargetUser=UserHandle.USER_CURRENT;
  mBrief=false;
  mComponents=false;
  Intent intent=Intent.parseCommandArgs(this,new Intent.CommandOptionHandler(){
    @Override public boolean handleOption(    String opt,    ShellCommand cmd){
      if (""String_Node_Str"".equals(opt)) {
        mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
        return true;
      }
 else       if (""String_Node_Str"".equals(opt)) {
        mBrief=true;
        return true;
      }
 else       if (""String_Node_Str"".equals(opt)) {
        mComponents=true;
        return true;
      }
      return false;
    }
  }
);
  mTargetUser=ActivityManager.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),mTargetUser,false,false,null,null);
  return intent;
}",0.8305084745762712
191906,"private int runQueryIntentActivities(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentActivities(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      pw.print(result.size());
      pw.println(""String_Node_Str"");
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      for (int i=0; i < result.size(); i++) {
        pw.print(""String_Node_Str"");
        pw.print(i);
        pw.println(""String_Node_Str"");
        result.get(i).dump(pr,""String_Node_Str"");
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runQueryIntentActivities(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentActivities(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      if (!mComponents) {
        pw.print(result.size());
        pw.println(""String_Node_Str"");
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          pw.print(""String_Node_Str"");
          pw.print(i);
          pw.println(""String_Node_Str"");
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
 else {
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.8228962818003914
191907,"@Override public boolean handleOption(String opt,ShellCommand cmd){
  if (""String_Node_Str"".equals(opt)) {
    mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
    return true;
  }
  return false;
}","@Override public boolean handleOption(String opt,ShellCommand cmd){
  if (""String_Node_Str"".equals(opt)) {
    mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
    return true;
  }
 else   if (""String_Node_Str"".equals(opt)) {
    mBrief=true;
    return true;
  }
 else   if (""String_Node_Str"".equals(opt)) {
    mComponents=true;
    return true;
  }
  return false;
}",0.6621848739495798
191908,"private int runQueryIntentServices(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentServices(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      pw.print(result.size());
      pw.println(""String_Node_Str"");
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      for (int i=0; i < result.size(); i++) {
        pw.print(""String_Node_Str"");
        pw.print(i);
        pw.println(""String_Node_Str"");
        result.get(i).dump(pr,""String_Node_Str"");
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runQueryIntentServices(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentServices(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      if (!mComponents) {
        pw.print(result.size());
        pw.println(""String_Node_Str"");
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          pw.print(""String_Node_Str"");
          pw.print(i);
          pw.println(""String_Node_Str"");
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
 else {
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.8222003929273084
191909,"private int runResolveActivity(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    ResolveInfo ri=mInterface.resolveIntent(intent,null,0,mTargetUser);
    PrintWriter pw=getOutPrintWriter();
    if (ri == null) {
      pw.println(""String_Node_Str"");
    }
 else {
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      ri.dump(pr,""String_Node_Str"");
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runResolveActivity(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    ResolveInfo ri=mInterface.resolveIntent(intent,null,0,mTargetUser);
    PrintWriter pw=getOutPrintWriter();
    if (ri == null) {
      pw.println(""String_Node_Str"");
    }
 else {
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      printResolveInfo(pr,""String_Node_Str"",ri,mBrief,mComponents);
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.9622799664710812
191910,"void cancel(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  if (mStarted && mLoader != null && mListenerRegistered) {
    if (!mLoader.cancelLoad()) {
      onLoadCanceled(mLoader);
    }
  }
}","boolean cancel(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  if (mStarted && mLoader != null && mListenerRegistered) {
    final boolean cancelLoadResult=mLoader.cancelLoad();
    if (!cancelLoadResult) {
      onLoadCanceled(mLoader);
    }
    return cancelLoadResult;
  }
  return false;
}",0.7049504950495049
191911,"/** 
 * Call to re-create the Loader associated with a particular ID.  If there is currently a Loader associated with this ID, it will be canceled/stopped/destroyed as appropriate.  A new Loader with the given arguments will be created and its data delivered to you once available. <p>This function does some throttling of Loaders.  If too many Loaders have been created for the given ID but not yet generated their data, new calls to this function will create and return a new Loader but not actually start it until some previous loaders have completed. <p>After calling this function, any previous Loaders associated with this ID will be considered invalid, and you will receive no further data updates from them.
 * @param id A unique (to this LoaderManager instance) identifier underwhich to manage the new Loader.
 * @param args Optional arguments that will be propagated to{@link LoaderCallbacks#onCreateLoader(int,Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.Its onCreateLoader() method will be called while inside of the function to instantiate the Loader object.
 */
@SuppressWarnings(""String_Node_Str"") public <D>Loader<D> restartLoader(int id,Bundle args,LoaderManager.LoaderCallbacks<D> callback){
  if (mCreatingLoader) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  LoaderInfo info=mLoaders.get(id);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ args);
  if (info != null) {
    LoaderInfo inactive=mInactiveLoaders.get(id);
    if (inactive != null) {
      if (info.mHaveData) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + info);
        inactive.mDeliveredData=false;
        inactive.destroy();
        info.mLoader.abandon();
        mInactiveLoaders.put(id,info);
      }
 else {
        if (!info.mStarted) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          mLoaders.put(id,null);
          info.destroy();
        }
 else {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          info.cancel();
          if (info.mPendingLoader != null) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + info.mPendingLoader);
            info.mPendingLoader.destroy();
            info.mPendingLoader=null;
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          info.mPendingLoader=createLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
          return (Loader<D>)info.mPendingLoader.mLoader;
        }
      }
    }
 else {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + info);
      info.mLoader.abandon();
      mInactiveLoaders.put(id,info);
    }
  }
  info=createAndInstallLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
  return (Loader<D>)info.mLoader;
}","/** 
 * Call to re-create the Loader associated with a particular ID.  If there is currently a Loader associated with this ID, it will be canceled/stopped/destroyed as appropriate.  A new Loader with the given arguments will be created and its data delivered to you once available. <p>This function does some throttling of Loaders.  If too many Loaders have been created for the given ID but not yet generated their data, new calls to this function will create and return a new Loader but not actually start it until some previous loaders have completed. <p>After calling this function, any previous Loaders associated with this ID will be considered invalid, and you will receive no further data updates from them.
 * @param id A unique (to this LoaderManager instance) identifier underwhich to manage the new Loader.
 * @param args Optional arguments that will be propagated to{@link LoaderCallbacks#onCreateLoader(int,Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.Its onCreateLoader() method will be called while inside of the function to instantiate the Loader object.
 */
@SuppressWarnings(""String_Node_Str"") public <D>Loader<D> restartLoader(int id,Bundle args,LoaderManager.LoaderCallbacks<D> callback){
  if (mCreatingLoader) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  LoaderInfo info=mLoaders.get(id);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ args);
  if (info != null) {
    LoaderInfo inactive=mInactiveLoaders.get(id);
    if (inactive != null) {
      if (info.mHaveData) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + info);
        inactive.mDeliveredData=false;
        inactive.destroy();
        info.mLoader.abandon();
        mInactiveLoaders.put(id,info);
      }
 else {
        if (!info.cancel()) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          mLoaders.put(id,null);
          info.destroy();
        }
 else {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          if (info.mPendingLoader != null) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + info.mPendingLoader);
            info.mPendingLoader.destroy();
            info.mPendingLoader=null;
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          info.mPendingLoader=createLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
          return (Loader<D>)info.mPendingLoader.mLoader;
        }
      }
    }
 else {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + info);
      info.mLoader.abandon();
      mInactiveLoaders.put(id,info);
    }
  }
  info=createAndInstallLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
  return (Loader<D>)info.mLoader;
}",0.992703327994305
191912,"void cancel(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  if (mStarted && mLoader != null && mListenerRegistered) {
    if (!mLoader.cancelLoad()) {
      onLoadCanceled(mLoader);
    }
  }
}","boolean cancel(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  if (mStarted && mLoader != null && mListenerRegistered) {
    final boolean cancelLoadResult=mLoader.cancelLoad();
    if (!cancelLoadResult) {
      onLoadCanceled(mLoader);
    }
    return cancelLoadResult;
  }
  return false;
}",0.7049504950495049
191913,"/** 
 * Call to re-create the Loader associated with a particular ID.  If there is currently a Loader associated with this ID, it will be canceled/stopped/destroyed as appropriate.  A new Loader with the given arguments will be created and its data delivered to you once available. <p>This function does some throttling of Loaders.  If too many Loaders have been created for the given ID but not yet generated their data, new calls to this function will create and return a new Loader but not actually start it until some previous loaders have completed. <p>After calling this function, any previous Loaders associated with this ID will be considered invalid, and you will receive no further data updates from them.
 * @param id A unique (to this LoaderManager instance) identifier underwhich to manage the new Loader.
 * @param args Optional arguments that will be propagated to{@link LoaderCallbacks#onCreateLoader(int,Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.Its onCreateLoader() method will be called while inside of the function to instantiate the Loader object.
 */
@SuppressWarnings(""String_Node_Str"") public <D>Loader<D> restartLoader(int id,Bundle args,LoaderManager.LoaderCallbacks<D> callback){
  if (mCreatingLoader) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  LoaderInfo info=mLoaders.get(id);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ args);
  if (info != null) {
    LoaderInfo inactive=mInactiveLoaders.get(id);
    if (inactive != null) {
      if (info.mHaveData) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + info);
        inactive.mDeliveredData=false;
        inactive.destroy();
        info.mLoader.abandon();
        mInactiveLoaders.put(id,info);
      }
 else {
        if (!info.mStarted) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          mLoaders.put(id,null);
          info.destroy();
        }
 else {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          info.cancel();
          if (info.mPendingLoader != null) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + info.mPendingLoader);
            info.mPendingLoader.destroy();
            info.mPendingLoader=null;
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          info.mPendingLoader=createLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
          return (Loader<D>)info.mPendingLoader.mLoader;
        }
      }
    }
 else {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + info);
      info.mLoader.abandon();
      mInactiveLoaders.put(id,info);
    }
  }
  info=createAndInstallLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
  return (Loader<D>)info.mLoader;
}","/** 
 * Call to re-create the Loader associated with a particular ID.  If there is currently a Loader associated with this ID, it will be canceled/stopped/destroyed as appropriate.  A new Loader with the given arguments will be created and its data delivered to you once available. <p>This function does some throttling of Loaders.  If too many Loaders have been created for the given ID but not yet generated their data, new calls to this function will create and return a new Loader but not actually start it until some previous loaders have completed. <p>After calling this function, any previous Loaders associated with this ID will be considered invalid, and you will receive no further data updates from them.
 * @param id A unique (to this LoaderManager instance) identifier underwhich to manage the new Loader.
 * @param args Optional arguments that will be propagated to{@link LoaderCallbacks#onCreateLoader(int,Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.Its onCreateLoader() method will be called while inside of the function to instantiate the Loader object.
 */
@SuppressWarnings(""String_Node_Str"") public <D>Loader<D> restartLoader(int id,Bundle args,LoaderManager.LoaderCallbacks<D> callback){
  if (mCreatingLoader) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  LoaderInfo info=mLoaders.get(id);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ args);
  if (info != null) {
    LoaderInfo inactive=mInactiveLoaders.get(id);
    if (inactive != null) {
      if (info.mHaveData) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + info);
        inactive.mDeliveredData=false;
        inactive.destroy();
        info.mLoader.abandon();
        mInactiveLoaders.put(id,info);
      }
 else {
        if (!info.cancel()) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          mLoaders.put(id,null);
          info.destroy();
        }
 else {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          if (info.mPendingLoader != null) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + info.mPendingLoader);
            info.mPendingLoader.destroy();
            info.mPendingLoader=null;
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          info.mPendingLoader=createLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
          return (Loader<D>)info.mPendingLoader.mLoader;
        }
      }
    }
 else {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + info);
      info.mLoader.abandon();
      mInactiveLoaders.put(id,info);
    }
  }
  info=createAndInstallLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
  return (Loader<D>)info.mLoader;
}",0.992703327994305
191914,"void cancel(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  if (mStarted && mLoader != null && mListenerRegistered) {
    if (!mLoader.cancelLoad()) {
      onLoadCanceled(mLoader);
    }
  }
}","boolean cancel(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  if (mStarted && mLoader != null && mListenerRegistered) {
    final boolean cancelLoadResult=mLoader.cancelLoad();
    if (!cancelLoadResult) {
      onLoadCanceled(mLoader);
    }
    return cancelLoadResult;
  }
  return false;
}",0.7049504950495049
191915,"/** 
 * Call to re-create the Loader associated with a particular ID.  If there is currently a Loader associated with this ID, it will be canceled/stopped/destroyed as appropriate.  A new Loader with the given arguments will be created and its data delivered to you once available. <p>This function does some throttling of Loaders.  If too many Loaders have been created for the given ID but not yet generated their data, new calls to this function will create and return a new Loader but not actually start it until some previous loaders have completed. <p>After calling this function, any previous Loaders associated with this ID will be considered invalid, and you will receive no further data updates from them.
 * @param id A unique (to this LoaderManager instance) identifier underwhich to manage the new Loader.
 * @param args Optional arguments that will be propagated to{@link LoaderCallbacks#onCreateLoader(int,Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.Its onCreateLoader() method will be called while inside of the function to instantiate the Loader object.
 */
@SuppressWarnings(""String_Node_Str"") public <D>Loader<D> restartLoader(int id,Bundle args,LoaderManager.LoaderCallbacks<D> callback){
  if (mCreatingLoader) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  LoaderInfo info=mLoaders.get(id);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ args);
  if (info != null) {
    LoaderInfo inactive=mInactiveLoaders.get(id);
    if (inactive != null) {
      if (info.mHaveData) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + info);
        inactive.mDeliveredData=false;
        inactive.destroy();
        info.mLoader.abandon();
        mInactiveLoaders.put(id,info);
      }
 else {
        if (!info.mStarted) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          mLoaders.put(id,null);
          info.destroy();
        }
 else {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          info.cancel();
          if (info.mPendingLoader != null) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + info.mPendingLoader);
            info.mPendingLoader.destroy();
            info.mPendingLoader=null;
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          info.mPendingLoader=createLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
          return (Loader<D>)info.mPendingLoader.mLoader;
        }
      }
    }
 else {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + info);
      info.mLoader.abandon();
      mInactiveLoaders.put(id,info);
    }
  }
  info=createAndInstallLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
  return (Loader<D>)info.mLoader;
}","/** 
 * Call to re-create the Loader associated with a particular ID.  If there is currently a Loader associated with this ID, it will be canceled/stopped/destroyed as appropriate.  A new Loader with the given arguments will be created and its data delivered to you once available. <p>This function does some throttling of Loaders.  If too many Loaders have been created for the given ID but not yet generated their data, new calls to this function will create and return a new Loader but not actually start it until some previous loaders have completed. <p>After calling this function, any previous Loaders associated with this ID will be considered invalid, and you will receive no further data updates from them.
 * @param id A unique (to this LoaderManager instance) identifier underwhich to manage the new Loader.
 * @param args Optional arguments that will be propagated to{@link LoaderCallbacks#onCreateLoader(int,Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.Its onCreateLoader() method will be called while inside of the function to instantiate the Loader object.
 */
@SuppressWarnings(""String_Node_Str"") public <D>Loader<D> restartLoader(int id,Bundle args,LoaderManager.LoaderCallbacks<D> callback){
  if (mCreatingLoader) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  LoaderInfo info=mLoaders.get(id);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ args);
  if (info != null) {
    LoaderInfo inactive=mInactiveLoaders.get(id);
    if (inactive != null) {
      if (info.mHaveData) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + info);
        inactive.mDeliveredData=false;
        inactive.destroy();
        info.mLoader.abandon();
        mInactiveLoaders.put(id,info);
      }
 else {
        if (!info.cancel()) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          mLoaders.put(id,null);
          info.destroy();
        }
 else {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          if (info.mPendingLoader != null) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + info.mPendingLoader);
            info.mPendingLoader.destroy();
            info.mPendingLoader=null;
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"");
          info.mPendingLoader=createLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
          return (Loader<D>)info.mPendingLoader.mLoader;
        }
      }
    }
 else {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + info);
      info.mLoader.abandon();
      mInactiveLoaders.put(id,info);
    }
  }
  info=createAndInstallLoader(id,args,(LoaderManager.LoaderCallbacks<Object>)callback);
  return (Loader<D>)info.mLoader;
}",0.992703327994305
191916,"Bitmap screenshotApplicationsInner(IBinder appToken,int displayId,int width,int height,boolean includeFullDisplay,float frameScale,Bitmap.Config config){
  final DisplayContent displayContent;
synchronized (mWindowMap) {
    displayContent=getDisplayContentLocked(displayId);
    if (displayContent == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ displayId);
      return null;
    }
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  int dw=displayInfo.logicalWidth;
  int dh=displayInfo.logicalHeight;
  if (dw == 0 || dh == 0) {
    if (DEBUG_SCREENSHOT)     Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh);
    return null;
  }
  Bitmap bm=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  final Rect stackBounds=new Rect();
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  WindowState appWin=null;
  boolean appIsImTarget;
synchronized (mWindowMap) {
    appIsImTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
  }
  final int aboveAppLayer=(mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
synchronized (mWindowMap) {
    appWin=null;
    final WindowList windows=displayContent.getWindowList();
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState ws=windows.get(i);
      if (!ws.mHasSurface) {
        continue;
      }
      if (ws.mLayer >= aboveAppLayer) {
        continue;
      }
      if (ws.mIsImWindow) {
        if (!appIsImTarget) {
          continue;
        }
      }
 else       if (ws.mIsWallpaper) {
        if (appWin == null) {
          continue;
        }
      }
 else       if (appToken != null) {
        if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
          continue;
        }
        appWin=ws;
      }
      final WindowStateAnimator winAnim=ws.mWinAnimator;
      int layer=winAnim.mSurfaceController.getLayer();
      if (maxLayer < layer) {
        maxLayer=layer;
      }
      if (minLayer > layer) {
        minLayer=layer;
      }
      if (!includeFullDisplay && !ws.mIsWallpaper) {
        final Rect wf=ws.mFrame;
        final Rect cr=ws.mContentInsets;
        int left=wf.left + cr.left;
        int top=wf.top + cr.top;
        int right=wf.right - cr.right;
        int bottom=wf.bottom - cr.bottom;
        frame.union(left,top,right,bottom);
        ws.getVisibleBounds(stackBounds);
        if (!Rect.intersects(frame,stackBounds)) {
          frame.setEmpty();
        }
      }
      if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw() && winAnim.getShown()) {
        screenshotReady=true;
      }
      if (ws.isObscuringFullscreen(displayInfo)) {
        break;
      }
    }
    if (appToken != null && appWin == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken);
      return null;
    }
    if (!screenshotReady) {
      Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
      return null;
    }
    if (maxLayer == 0) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ maxLayer);
      return null;
    }
    if (!includeFullDisplay) {
      if (!frame.intersect(0,0,dw,dh)) {
        frame.setEmpty();
      }
    }
 else {
      frame.set(0,0,dw,dh);
    }
    if (frame.isEmpty()) {
      return null;
    }
    if (width < 0) {
      width=(int)(frame.width() * frameScale);
    }
    if (height < 0) {
      height=(int)(frame.height() * frameScale);
    }
    Rect crop=new Rect(frame);
    if (width / (float)frame.width() < height / (float)frame.height()) {
      int cropWidth=(int)((float)width / (float)height * frame.height());
      crop.right=crop.left + cropWidth;
    }
 else {
      int cropHeight=(int)((float)height / (float)width * frame.width());
      crop.bottom=crop.top + cropHeight;
    }
    int rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
    if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
      rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
    }
    convertCropForSurfaceFlinger(crop,rot,dw,dh);
    if (DEBUG_SCREENSHOT) {
      Slog.i(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
      for (int i=0; i < windows.size(); i++) {
        WindowState win=windows.get(i);
        Slog.i(TAG_WM,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ win.mWinAnimator.mSurfaceController.getLayer());
      }
    }
    ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    final boolean inRotation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
    if (DEBUG_SCREENSHOT && inRotation)     Slog.v(TAG_WM,""String_Node_Str"");
    bm=SurfaceControl.screenshot(crop,width,height,minLayer,maxLayer,inRotation,rot);
    if (bm == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
      return null;
    }
  }
  if (DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    final int firstColor=buffer[0];
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != firstColor) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG_WM,""String_Node_Str"" + appWin + ""String_Node_Str""+ Integer.toHexString(firstColor)+ ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceController.getLayer() : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  Bitmap ret=bm.createAshmemBitmap(config);
  bm.recycle();
  return ret;
}","Bitmap screenshotApplicationsInner(IBinder appToken,int displayId,int width,int height,boolean includeFullDisplay,float frameScale,Bitmap.Config config){
  final DisplayContent displayContent;
synchronized (mWindowMap) {
    displayContent=getDisplayContentLocked(displayId);
    if (displayContent == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ displayId);
      return null;
    }
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  int dw=displayInfo.logicalWidth;
  int dh=displayInfo.logicalHeight;
  if (dw == 0 || dh == 0) {
    if (DEBUG_SCREENSHOT)     Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh);
    return null;
  }
  Bitmap bm=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  final Rect stackBounds=new Rect();
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  WindowState appWin=null;
  boolean appIsImTarget;
synchronized (mWindowMap) {
    appIsImTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
  }
  final int aboveAppLayer=(mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
synchronized (mWindowMap) {
    appWin=null;
    final WindowList windows=displayContent.getWindowList();
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState ws=windows.get(i);
      if (!ws.mHasSurface) {
        continue;
      }
      if (ws.mLayer >= aboveAppLayer) {
        continue;
      }
      if (ws.mIsImWindow) {
        if (!appIsImTarget) {
          continue;
        }
      }
 else       if (ws.mIsWallpaper) {
        if (appWin == null) {
          continue;
        }
      }
 else       if (appToken != null) {
        if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
          continue;
        }
        appWin=ws;
      }
      final WindowStateAnimator winAnim=ws.mWinAnimator;
      int layer=winAnim.mSurfaceController.getLayer();
      if (maxLayer < layer) {
        maxLayer=layer;
      }
      if (minLayer > layer) {
        minLayer=layer;
      }
      if (!includeFullDisplay && !ws.mIsWallpaper) {
        final Rect wf=ws.mFrame;
        final Rect cr=ws.mContentInsets;
        int left=wf.left + cr.left;
        int top=wf.top + cr.top;
        int right=wf.right - cr.right;
        int bottom=wf.bottom - cr.bottom;
        frame.union(left,top,right,bottom);
        ws.getVisibleBounds(stackBounds);
        if (!Rect.intersects(frame,stackBounds)) {
          frame.setEmpty();
        }
      }
      if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw() && winAnim.getShown()) {
        screenshotReady=true;
      }
      if (ws.isObscuringFullscreen(displayInfo)) {
        break;
      }
    }
    if (appToken != null && appWin == null) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken);
      return null;
    }
    if (!screenshotReady) {
      Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ (appWin == null ? ""String_Node_Str"" : (appWin + ""String_Node_Str"" + appWin.mWinAnimator.mDrawState)));
      return null;
    }
    if (maxLayer == 0) {
      if (DEBUG_SCREENSHOT)       Slog.i(TAG_WM,""String_Node_Str"" + appToken + ""String_Node_Str""+ maxLayer);
      return null;
    }
    if (!includeFullDisplay) {
      if (!frame.intersect(0,0,dw,dh)) {
        frame.setEmpty();
      }
    }
 else {
      frame.set(0,0,dw,dh);
    }
    if (frame.isEmpty()) {
      return null;
    }
    if (width < 0) {
      width=(int)(frame.width() * frameScale);
    }
    if (height < 0) {
      height=(int)(frame.height() * frameScale);
    }
    Rect crop=new Rect(frame);
    if (width / (float)frame.width() < height / (float)frame.height()) {
      int cropWidth=(int)((float)width / (float)height * frame.height());
      crop.right=crop.left + cropWidth;
    }
 else {
      int cropHeight=(int)((float)height / (float)width * frame.width());
      crop.bottom=crop.top + cropHeight;
    }
    int rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
    if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
      rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
    }
    convertCropForSurfaceFlinger(crop,rot,dw,dh);
    if (DEBUG_SCREENSHOT) {
      Slog.i(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer+ ""String_Node_Str""+ appToken);
      for (int i=0; i < windows.size(); i++) {
        WindowState win=windows.get(i);
        WindowSurfaceController controller=win.mWinAnimator.mSurfaceController;
        Slog.i(TAG_WM,win + ""String_Node_Str"" + win.mLayer+ ""String_Node_Str""+ win.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ ((controller == null) ? ""String_Node_Str"" : controller.getLayer()));
      }
    }
    ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    final boolean inRotation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
    if (DEBUG_SCREENSHOT && inRotation)     Slog.v(TAG_WM,""String_Node_Str"");
    bm=SurfaceControl.screenshot(crop,width,height,minLayer,maxLayer,inRotation,rot);
    if (bm == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + dw + ""String_Node_Str""+ dh+ ""String_Node_Str""+ maxLayer);
      return null;
    }
  }
  if (DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    final int firstColor=buffer[0];
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != firstColor) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG_WM,""String_Node_Str"" + appWin + ""String_Node_Str""+ Integer.toHexString(firstColor)+ ""String_Node_Str""+ (appWin != null ? appWin.mWinAnimator.mSurfaceController.getLayer() : ""String_Node_Str"")+ ""String_Node_Str""+ minLayer+ ""String_Node_Str""+ maxLayer);
    }
  }
  Bitmap ret=bm.createAshmemBitmap(config);
  bm.recycle();
  return ret;
}",0.9880503144654088
191917,"@Override public int movePackage(final String packageName,final String volumeUuid){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MOVE_PACKAGE,null);
  final int moveId=mNextMoveId.getAndIncrement();
  mHandler.post(new Runnable(){
    @Override public void run(){
      try {
        movePackageInternal(packageName,volumeUuid,moveId);
      }
 catch (      PackageManagerException e) {
        Slog.w(TAG,""String_Node_Str"" + packageName,e);
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
      }
    }
  }
);
  return moveId;
}","@Override public int movePackage(final String packageName,final String volumeUuid){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MOVE_PACKAGE,null);
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final int moveId=mNextMoveId.getAndIncrement();
  mHandler.post(new Runnable(){
    @Override public void run(){
      try {
        movePackageInternal(packageName,volumeUuid,moveId,user);
      }
 catch (      PackageManagerException e) {
        Slog.w(TAG,""String_Node_Str"" + packageName,e);
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
      }
    }
  }
);
  return moveId;
}",0.9404388714733544
191918,"private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
  final int targetSdkVersion;
  final PackageFreezer freezer;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isExternalAsec()) {
      currentAsec=true;
      currentVolumeUuid=StorageManager.UUID_PRIMARY_PHYSICAL;
    }
 else     if (pkg.applicationInfo.isForwardLocked()) {
      currentAsec=true;
      currentVolumeUuid=""String_Node_Str"";
    }
 else {
      currentAsec=false;
      currentVolumeUuid=ps.volumeUuid;
      final File probe=new File(pkg.codePath);
      final File probeOat=new File(probe,""String_Node_Str"");
      if (!probe.isDirectory() || !probeOat.isDirectory()) {
        throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
      }
    }
    if (Objects.equals(currentVolumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    if (pkg.applicationInfo.isInternal() && isPackageDeviceAdminOnAnyUser(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_DEVICE_ADMIN,""String_Node_Str"");
    }
    if (mFrozenPackages.contains(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
    targetSdkVersion=pkg.applicationInfo.targetSdkVersion;
    freezer=new PackageFreezer(packageName,""String_Node_Str"");
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    freezer.close();
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      freezer.close();
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo,targetSdkVersion);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
final InstallParams params=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null,null);
params.setTraceMethod(""String_Node_Str"").setTraceCookie(System.identityHashCode(params));
msg.obj=params;
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
mHandler.sendMessage(msg);
}","private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId,UserHandle user) throws PackageManagerException {
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
  final int targetSdkVersion;
  final PackageFreezer freezer;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isExternalAsec()) {
      currentAsec=true;
      currentVolumeUuid=StorageManager.UUID_PRIMARY_PHYSICAL;
    }
 else     if (pkg.applicationInfo.isForwardLocked()) {
      currentAsec=true;
      currentVolumeUuid=""String_Node_Str"";
    }
 else {
      currentAsec=false;
      currentVolumeUuid=ps.volumeUuid;
      final File probe=new File(pkg.codePath);
      final File probeOat=new File(probe,""String_Node_Str"");
      if (!probe.isDirectory() || !probeOat.isDirectory()) {
        throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
      }
    }
    if (Objects.equals(currentVolumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    if (pkg.applicationInfo.isInternal() && isPackageDeviceAdminOnAnyUser(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_DEVICE_ADMIN,""String_Node_Str"");
    }
    if (mFrozenPackages.contains(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
    targetSdkVersion=pkg.applicationInfo.targetSdkVersion;
    freezer=new PackageFreezer(packageName,""String_Node_Str"");
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    freezer.close();
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      freezer.close();
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo,targetSdkVersion);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
final InstallParams params=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null,null);
params.setTraceMethod(""String_Node_Str"").setTraceCookie(System.identityHashCode(params));
msg.obj=params;
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
mHandler.sendMessage(msg);
}",0.9936648947789994
191919,"private void replacePackageLIF(PackageParser.Package pkg,final int policyFlags,int scanFlags,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  final boolean isEphemeral=(policyFlags & PackageParser.PARSE_IS_EPHEMERAL) != 0;
  final PackageParser.Package oldPackage;
  final String pkgName=pkg.packageName;
  final int[] allUsers;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    final boolean oldIsEphemeral=oldPackage.applicationInfo.isEphemeralApp();
    if (isEphemeral && !oldIsEphemeral) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID);
      return;
    }
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    final PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (shouldCheckUpgradeKeySetLP(ps,scanFlags)) {
      if (!checkUpgradeKeySetLP(ps,pkg)) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
 else {
      if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
    String invalidPackageName=getParentOrChildPackageChangedSharedUser(oldPackage,pkg);
    if (invalidPackageName != null) {
      res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE,""String_Node_Str"" + invalidPackageName + ""String_Node_Str""+ oldPackage.mSharedUserId);
      return;
    }
    allUsers=sUserManager.getUserIds();
  }
  res.removedInfo=new PackageRemovedInfo();
  res.removedInfo.uid=oldPackage.applicationInfo.uid;
  res.removedInfo.removedPackage=oldPackage.packageName;
  res.removedInfo.isUpdate=true;
  final int childCount=(oldPackage.childPackages != null) ? oldPackage.childPackages.size() : 0;
  for (int i=0; i < childCount; i++) {
    boolean childPackageUpdated=false;
    PackageParser.Package childPkg=oldPackage.childPackages.get(i);
    if (res.addedChildPackages != null) {
      PackageInstalledInfo childRes=res.addedChildPackages.get(childPkg.packageName);
      if (childRes != null) {
        childRes.removedInfo.uid=childPkg.applicationInfo.uid;
        childRes.removedInfo.removedPackage=childPkg.packageName;
        childRes.removedInfo.isUpdate=true;
        childPackageUpdated=true;
      }
    }
    if (!childPackageUpdated) {
      PackageRemovedInfo childRemovedRes=new PackageRemovedInfo();
      childRemovedRes.removedPackage=childPkg.packageName;
      childRemovedRes.isUpdate=false;
      childRemovedRes.dataRemoved=true;
synchronized (mPackages) {
        PackageSetting childPs=mSettings.peekPackageLPr(childPkg.packageName);
        if (childPs != null) {
          childRemovedRes.origUsers=childPs.queryInstalledUsers(allUsers,true);
        }
      }
      if (res.removedInfo.removedChildPackages == null) {
        res.removedInfo.removedChildPackages=new ArrayMap<>();
      }
      res.removedInfo.removedChildPackages.put(childPkg.packageName,childRemovedRes);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    final boolean privileged=(oldPackage.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0;
    final int systemPolicyFlags=policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0);
    replaceSystemPackageLIF(oldPackage,pkg,systemPolicyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLIF(oldPackage,pkg,policyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
}","private void replacePackageLIF(PackageParser.Package pkg,final int policyFlags,int scanFlags,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  final boolean isEphemeral=(policyFlags & PackageParser.PARSE_IS_EPHEMERAL) != 0;
  final PackageParser.Package oldPackage;
  final String pkgName=pkg.packageName;
  final int[] allUsers;
  final int[] installedUsers;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    final boolean oldIsEphemeral=oldPackage.applicationInfo.isEphemeralApp();
    if (isEphemeral && !oldIsEphemeral) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID);
      return;
    }
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    final PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (shouldCheckUpgradeKeySetLP(ps,scanFlags)) {
      if (!checkUpgradeKeySetLP(ps,pkg)) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
 else {
      if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
    String invalidPackageName=getParentOrChildPackageChangedSharedUser(oldPackage,pkg);
    if (invalidPackageName != null) {
      res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE,""String_Node_Str"" + invalidPackageName + ""String_Node_Str""+ oldPackage.mSharedUserId);
      return;
    }
    allUsers=sUserManager.getUserIds();
    installedUsers=ps.queryInstalledUsers(allUsers,true);
  }
  res.removedInfo=new PackageRemovedInfo();
  res.removedInfo.uid=oldPackage.applicationInfo.uid;
  res.removedInfo.removedPackage=oldPackage.packageName;
  res.removedInfo.isUpdate=true;
  res.removedInfo.origUsers=installedUsers;
  final int childCount=(oldPackage.childPackages != null) ? oldPackage.childPackages.size() : 0;
  for (int i=0; i < childCount; i++) {
    boolean childPackageUpdated=false;
    PackageParser.Package childPkg=oldPackage.childPackages.get(i);
    if (res.addedChildPackages != null) {
      PackageInstalledInfo childRes=res.addedChildPackages.get(childPkg.packageName);
      if (childRes != null) {
        childRes.removedInfo.uid=childPkg.applicationInfo.uid;
        childRes.removedInfo.removedPackage=childPkg.packageName;
        childRes.removedInfo.isUpdate=true;
        childPackageUpdated=true;
      }
    }
    if (!childPackageUpdated) {
      PackageRemovedInfo childRemovedRes=new PackageRemovedInfo();
      childRemovedRes.removedPackage=childPkg.packageName;
      childRemovedRes.isUpdate=false;
      childRemovedRes.dataRemoved=true;
synchronized (mPackages) {
        PackageSetting childPs=mSettings.peekPackageLPr(childPkg.packageName);
        if (childPs != null) {
          childRemovedRes.origUsers=childPs.queryInstalledUsers(allUsers,true);
        }
      }
      if (res.removedInfo.removedChildPackages == null) {
        res.removedInfo.removedChildPackages=new ArrayMap<>();
      }
      res.removedInfo.removedChildPackages.put(childPkg.packageName,childRemovedRes);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    final boolean privileged=(oldPackage.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0;
    final int systemPolicyFlags=policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0);
    replaceSystemPackageLIF(oldPackage,pkg,systemPolicyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLIF(oldPackage,pkg,policyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
}",0.9823293172690764
191920,"@Override public int movePackage(final String packageName,final String volumeUuid){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MOVE_PACKAGE,null);
  final int moveId=mNextMoveId.getAndIncrement();
  mHandler.post(new Runnable(){
    @Override public void run(){
      try {
        movePackageInternal(packageName,volumeUuid,moveId);
      }
 catch (      PackageManagerException e) {
        Slog.w(TAG,""String_Node_Str"" + packageName,e);
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
      }
    }
  }
);
  return moveId;
}","@Override public int movePackage(final String packageName,final String volumeUuid){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MOVE_PACKAGE,null);
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final int moveId=mNextMoveId.getAndIncrement();
  mHandler.post(new Runnable(){
    @Override public void run(){
      try {
        movePackageInternal(packageName,volumeUuid,moveId,user);
      }
 catch (      PackageManagerException e) {
        Slog.w(TAG,""String_Node_Str"" + packageName,e);
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
      }
    }
  }
);
  return moveId;
}",0.9404388714733544
191921,"private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
  final int targetSdkVersion;
  final PackageFreezer freezer;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isExternalAsec()) {
      currentAsec=true;
      currentVolumeUuid=StorageManager.UUID_PRIMARY_PHYSICAL;
    }
 else     if (pkg.applicationInfo.isForwardLocked()) {
      currentAsec=true;
      currentVolumeUuid=""String_Node_Str"";
    }
 else {
      currentAsec=false;
      currentVolumeUuid=ps.volumeUuid;
      final File probe=new File(pkg.codePath);
      final File probeOat=new File(probe,""String_Node_Str"");
      if (!probe.isDirectory() || !probeOat.isDirectory()) {
        throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
      }
    }
    if (Objects.equals(currentVolumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    if (pkg.applicationInfo.isInternal() && isPackageDeviceAdminOnAnyUser(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_DEVICE_ADMIN,""String_Node_Str"");
    }
    if (mFrozenPackages.contains(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
    targetSdkVersion=pkg.applicationInfo.targetSdkVersion;
    freezer=new PackageFreezer(packageName,""String_Node_Str"");
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    freezer.close();
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      freezer.close();
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo,targetSdkVersion);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
final InstallParams params=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null,null);
params.setTraceMethod(""String_Node_Str"").setTraceCookie(System.identityHashCode(params));
msg.obj=params;
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
mHandler.sendMessage(msg);
}","private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId,UserHandle user) throws PackageManagerException {
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
  final int targetSdkVersion;
  final PackageFreezer freezer;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isExternalAsec()) {
      currentAsec=true;
      currentVolumeUuid=StorageManager.UUID_PRIMARY_PHYSICAL;
    }
 else     if (pkg.applicationInfo.isForwardLocked()) {
      currentAsec=true;
      currentVolumeUuid=""String_Node_Str"";
    }
 else {
      currentAsec=false;
      currentVolumeUuid=ps.volumeUuid;
      final File probe=new File(pkg.codePath);
      final File probeOat=new File(probe,""String_Node_Str"");
      if (!probe.isDirectory() || !probeOat.isDirectory()) {
        throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
      }
    }
    if (Objects.equals(currentVolumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    if (pkg.applicationInfo.isInternal() && isPackageDeviceAdminOnAnyUser(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_DEVICE_ADMIN,""String_Node_Str"");
    }
    if (mFrozenPackages.contains(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
    targetSdkVersion=pkg.applicationInfo.targetSdkVersion;
    freezer=new PackageFreezer(packageName,""String_Node_Str"");
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    freezer.close();
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      freezer.close();
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo,targetSdkVersion);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
final InstallParams params=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null,null);
params.setTraceMethod(""String_Node_Str"").setTraceCookie(System.identityHashCode(params));
msg.obj=params;
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
mHandler.sendMessage(msg);
}",0.9936648947789994
191922,"private void replacePackageLIF(PackageParser.Package pkg,final int policyFlags,int scanFlags,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  final boolean isEphemeral=(policyFlags & PackageParser.PARSE_IS_EPHEMERAL) != 0;
  final PackageParser.Package oldPackage;
  final String pkgName=pkg.packageName;
  final int[] allUsers;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    final boolean oldIsEphemeral=oldPackage.applicationInfo.isEphemeralApp();
    if (isEphemeral && !oldIsEphemeral) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID);
      return;
    }
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    final PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (shouldCheckUpgradeKeySetLP(ps,scanFlags)) {
      if (!checkUpgradeKeySetLP(ps,pkg)) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
 else {
      if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
    String invalidPackageName=getParentOrChildPackageChangedSharedUser(oldPackage,pkg);
    if (invalidPackageName != null) {
      res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE,""String_Node_Str"" + invalidPackageName + ""String_Node_Str""+ oldPackage.mSharedUserId);
      return;
    }
    allUsers=sUserManager.getUserIds();
  }
  res.removedInfo=new PackageRemovedInfo();
  res.removedInfo.uid=oldPackage.applicationInfo.uid;
  res.removedInfo.removedPackage=oldPackage.packageName;
  res.removedInfo.isUpdate=true;
  final int childCount=(oldPackage.childPackages != null) ? oldPackage.childPackages.size() : 0;
  for (int i=0; i < childCount; i++) {
    boolean childPackageUpdated=false;
    PackageParser.Package childPkg=oldPackage.childPackages.get(i);
    if (res.addedChildPackages != null) {
      PackageInstalledInfo childRes=res.addedChildPackages.get(childPkg.packageName);
      if (childRes != null) {
        childRes.removedInfo.uid=childPkg.applicationInfo.uid;
        childRes.removedInfo.removedPackage=childPkg.packageName;
        childRes.removedInfo.isUpdate=true;
        childPackageUpdated=true;
      }
    }
    if (!childPackageUpdated) {
      PackageRemovedInfo childRemovedRes=new PackageRemovedInfo();
      childRemovedRes.removedPackage=childPkg.packageName;
      childRemovedRes.isUpdate=false;
      childRemovedRes.dataRemoved=true;
synchronized (mPackages) {
        PackageSetting childPs=mSettings.peekPackageLPr(childPkg.packageName);
        if (childPs != null) {
          childRemovedRes.origUsers=childPs.queryInstalledUsers(allUsers,true);
        }
      }
      if (res.removedInfo.removedChildPackages == null) {
        res.removedInfo.removedChildPackages=new ArrayMap<>();
      }
      res.removedInfo.removedChildPackages.put(childPkg.packageName,childRemovedRes);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    final boolean privileged=(oldPackage.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0;
    final int systemPolicyFlags=policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0);
    replaceSystemPackageLIF(oldPackage,pkg,systemPolicyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLIF(oldPackage,pkg,policyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
}","private void replacePackageLIF(PackageParser.Package pkg,final int policyFlags,int scanFlags,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  final boolean isEphemeral=(policyFlags & PackageParser.PARSE_IS_EPHEMERAL) != 0;
  final PackageParser.Package oldPackage;
  final String pkgName=pkg.packageName;
  final int[] allUsers;
  final int[] installedUsers;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    final boolean oldIsEphemeral=oldPackage.applicationInfo.isEphemeralApp();
    if (isEphemeral && !oldIsEphemeral) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID);
      return;
    }
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    final PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (shouldCheckUpgradeKeySetLP(ps,scanFlags)) {
      if (!checkUpgradeKeySetLP(ps,pkg)) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
 else {
      if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
    String invalidPackageName=getParentOrChildPackageChangedSharedUser(oldPackage,pkg);
    if (invalidPackageName != null) {
      res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE,""String_Node_Str"" + invalidPackageName + ""String_Node_Str""+ oldPackage.mSharedUserId);
      return;
    }
    allUsers=sUserManager.getUserIds();
    installedUsers=ps.queryInstalledUsers(allUsers,true);
  }
  res.removedInfo=new PackageRemovedInfo();
  res.removedInfo.uid=oldPackage.applicationInfo.uid;
  res.removedInfo.removedPackage=oldPackage.packageName;
  res.removedInfo.isUpdate=true;
  res.removedInfo.origUsers=installedUsers;
  final int childCount=(oldPackage.childPackages != null) ? oldPackage.childPackages.size() : 0;
  for (int i=0; i < childCount; i++) {
    boolean childPackageUpdated=false;
    PackageParser.Package childPkg=oldPackage.childPackages.get(i);
    if (res.addedChildPackages != null) {
      PackageInstalledInfo childRes=res.addedChildPackages.get(childPkg.packageName);
      if (childRes != null) {
        childRes.removedInfo.uid=childPkg.applicationInfo.uid;
        childRes.removedInfo.removedPackage=childPkg.packageName;
        childRes.removedInfo.isUpdate=true;
        childPackageUpdated=true;
      }
    }
    if (!childPackageUpdated) {
      PackageRemovedInfo childRemovedRes=new PackageRemovedInfo();
      childRemovedRes.removedPackage=childPkg.packageName;
      childRemovedRes.isUpdate=false;
      childRemovedRes.dataRemoved=true;
synchronized (mPackages) {
        PackageSetting childPs=mSettings.peekPackageLPr(childPkg.packageName);
        if (childPs != null) {
          childRemovedRes.origUsers=childPs.queryInstalledUsers(allUsers,true);
        }
      }
      if (res.removedInfo.removedChildPackages == null) {
        res.removedInfo.removedChildPackages=new ArrayMap<>();
      }
      res.removedInfo.removedChildPackages.put(childPkg.packageName,childRemovedRes);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    final boolean privileged=(oldPackage.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0;
    final int systemPolicyFlags=policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0);
    replaceSystemPackageLIF(oldPackage,pkg,systemPolicyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLIF(oldPackage,pkg,policyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
}",0.9823293172690764
191923,"final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward,boolean reallyResume,int seq,String reason){
  ActivityClientRecord r=mActivities.get(token);
  if (!checkAndUpdateLifecycleSeq(seq,r,""String_Node_Str"")) {
    return;
  }
  unscheduleGcIdler();
  mSomeActivitiesChanged=true;
  r=performResumeActivity(token,clearHide,reason);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    boolean willBeVisible=!a.mStartedActivity;
    if (!willBeVisible) {
      try {
        willBeVisible=ActivityManagerNative.getDefault().willActivityBeVisible(a.getActivityToken());
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (r.window == null && !a.mFinished && willBeVisible) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (r.mPreserveWindow) {
        a.mWindowAdded=true;
        r.mPreserveWindow=false;
      }
      if (a.mVisibleFromClient && !a.mWindowAdded) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (!willBeVisible) {
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    cleanUpPendingRemoveWindows(r,false);
    if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChangedForActivity(r,r.newConfig,REPORT_TO_ACTIVITY);
        if (DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.activity.mCurrentConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    if (!r.onlyLocalRequest) {
      r.nextIdle=mNewActivities;
      mNewActivities=r;
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r);
      Looper.myQueue().addIdleHandler(new Idler());
    }
    r.onlyLocalRequest=false;
    if (reallyResume) {
      try {
        ActivityManagerNative.getDefault().activityResumed(token);
      }
 catch (      RemoteException ex) {
        throw ex.rethrowFromSystemServer();
      }
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null,Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
    }
 catch (    RemoteException ex) {
      throw ex.rethrowFromSystemServer();
    }
  }
}","final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward,boolean reallyResume,int seq,String reason){
  ActivityClientRecord r=mActivities.get(token);
  if (!checkAndUpdateLifecycleSeq(seq,r,""String_Node_Str"")) {
    return;
  }
  unscheduleGcIdler();
  mSomeActivitiesChanged=true;
  r=performResumeActivity(token,clearHide,reason);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    boolean willBeVisible=!a.mStartedActivity;
    if (!willBeVisible) {
      try {
        willBeVisible=ActivityManagerNative.getDefault().willActivityBeVisible(a.getActivityToken());
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (r.window == null && !a.mFinished && willBeVisible) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (r.mPreserveWindow) {
        a.mWindowAdded=true;
        r.mPreserveWindow=false;
        ViewRootImpl impl=decor.getViewRootImpl();
        impl.notifyChildRebuilt();
      }
      if (a.mVisibleFromClient && !a.mWindowAdded) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (!willBeVisible) {
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    cleanUpPendingRemoveWindows(r,false);
    if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChangedForActivity(r,r.newConfig,REPORT_TO_ACTIVITY);
        if (DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.activity.mCurrentConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    if (!r.onlyLocalRequest) {
      r.nextIdle=mNewActivities;
      mNewActivities=r;
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r);
      Looper.myQueue().addIdleHandler(new Idler());
    }
    r.onlyLocalRequest=false;
    if (reallyResume) {
      try {
        ActivityManagerNative.getDefault().activityResumed(token);
      }
 catch (      RemoteException ex) {
        throw ex.rethrowFromSystemServer();
      }
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null,Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
    }
 catch (    RemoteException ex) {
      throw ex.rethrowFromSystemServer();
    }
  }
}",0.9882127192982456
191924,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplayAdjustments.getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight()) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplayAdjustments.getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  final int surfaceGenerationId=mSurface.getGenerationId();
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface || surfaceGenerationId != mSurface.getGenerationId()) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight()) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}",0.996143874861114
191925,"final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward,boolean reallyResume,int seq,String reason){
  ActivityClientRecord r=mActivities.get(token);
  if (!checkAndUpdateLifecycleSeq(seq,r,""String_Node_Str"")) {
    return;
  }
  unscheduleGcIdler();
  mSomeActivitiesChanged=true;
  r=performResumeActivity(token,clearHide,reason);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    boolean willBeVisible=!a.mStartedActivity;
    if (!willBeVisible) {
      try {
        willBeVisible=ActivityManagerNative.getDefault().willActivityBeVisible(a.getActivityToken());
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (r.window == null && !a.mFinished && willBeVisible) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (r.mPreserveWindow) {
        a.mWindowAdded=true;
        r.mPreserveWindow=false;
      }
      if (a.mVisibleFromClient && !a.mWindowAdded) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (!willBeVisible) {
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    cleanUpPendingRemoveWindows(r,false);
    if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChangedForActivity(r,r.newConfig,REPORT_TO_ACTIVITY);
        if (DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.activity.mCurrentConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    if (!r.onlyLocalRequest) {
      r.nextIdle=mNewActivities;
      mNewActivities=r;
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r);
      Looper.myQueue().addIdleHandler(new Idler());
    }
    r.onlyLocalRequest=false;
    if (reallyResume) {
      try {
        ActivityManagerNative.getDefault().activityResumed(token);
      }
 catch (      RemoteException ex) {
        throw ex.rethrowFromSystemServer();
      }
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null,Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
    }
 catch (    RemoteException ex) {
      throw ex.rethrowFromSystemServer();
    }
  }
}","final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward,boolean reallyResume,int seq,String reason){
  ActivityClientRecord r=mActivities.get(token);
  if (!checkAndUpdateLifecycleSeq(seq,r,""String_Node_Str"")) {
    return;
  }
  unscheduleGcIdler();
  mSomeActivitiesChanged=true;
  r=performResumeActivity(token,clearHide,reason);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    boolean willBeVisible=!a.mStartedActivity;
    if (!willBeVisible) {
      try {
        willBeVisible=ActivityManagerNative.getDefault().willActivityBeVisible(a.getActivityToken());
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (r.window == null && !a.mFinished && willBeVisible) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (r.mPreserveWindow) {
        a.mWindowAdded=true;
        r.mPreserveWindow=false;
        ViewRootImpl impl=decor.getViewRootImpl();
        impl.notifyChildRebuilt();
      }
      if (a.mVisibleFromClient && !a.mWindowAdded) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (!willBeVisible) {
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    cleanUpPendingRemoveWindows(r,false);
    if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChangedForActivity(r,r.newConfig,REPORT_TO_ACTIVITY);
        if (DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.activity.mCurrentConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    if (!r.onlyLocalRequest) {
      r.nextIdle=mNewActivities;
      mNewActivities=r;
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r);
      Looper.myQueue().addIdleHandler(new Idler());
    }
    r.onlyLocalRequest=false;
    if (reallyResume) {
      try {
        ActivityManagerNative.getDefault().activityResumed(token);
      }
 catch (      RemoteException ex) {
        throw ex.rethrowFromSystemServer();
      }
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null,Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
    }
 catch (    RemoteException ex) {
      throw ex.rethrowFromSystemServer();
    }
  }
}",0.9882127192982456
191926,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplayAdjustments.getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight()) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplayAdjustments.getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  final int surfaceGenerationId=mSurface.getGenerationId();
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface || surfaceGenerationId != mSurface.getGenerationId()) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight()) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}",0.996143874861114
191927,"@Override public int movePackage(final String packageName,final String volumeUuid){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MOVE_PACKAGE,null);
  final int moveId=mNextMoveId.getAndIncrement();
  mHandler.post(new Runnable(){
    @Override public void run(){
      try {
        movePackageInternal(packageName,volumeUuid,moveId);
      }
 catch (      PackageManagerException e) {
        Slog.w(TAG,""String_Node_Str"" + packageName,e);
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
      }
    }
  }
);
  return moveId;
}","@Override public int movePackage(final String packageName,final String volumeUuid){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MOVE_PACKAGE,null);
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final int moveId=mNextMoveId.getAndIncrement();
  mHandler.post(new Runnable(){
    @Override public void run(){
      try {
        movePackageInternal(packageName,volumeUuid,moveId,user);
      }
 catch (      PackageManagerException e) {
        Slog.w(TAG,""String_Node_Str"" + packageName,e);
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
      }
    }
  }
);
  return moveId;
}",0.9404388714733544
191928,"private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId) throws PackageManagerException {
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
  final int targetSdkVersion;
  final PackageFreezer freezer;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isExternalAsec()) {
      currentAsec=true;
      currentVolumeUuid=StorageManager.UUID_PRIMARY_PHYSICAL;
    }
 else     if (pkg.applicationInfo.isForwardLocked()) {
      currentAsec=true;
      currentVolumeUuid=""String_Node_Str"";
    }
 else {
      currentAsec=false;
      currentVolumeUuid=ps.volumeUuid;
      final File probe=new File(pkg.codePath);
      final File probeOat=new File(probe,""String_Node_Str"");
      if (!probe.isDirectory() || !probeOat.isDirectory()) {
        throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
      }
    }
    if (Objects.equals(currentVolumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    if (pkg.applicationInfo.isInternal() && isPackageDeviceAdminOnAnyUser(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_DEVICE_ADMIN,""String_Node_Str"");
    }
    if (mFrozenPackages.contains(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
    targetSdkVersion=pkg.applicationInfo.targetSdkVersion;
    freezer=new PackageFreezer(packageName,""String_Node_Str"");
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    freezer.close();
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      freezer.close();
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo,targetSdkVersion);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
final InstallParams params=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null,null);
params.setTraceMethod(""String_Node_Str"").setTraceCookie(System.identityHashCode(params));
msg.obj=params;
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
mHandler.sendMessage(msg);
}","private void movePackageInternal(final String packageName,final String volumeUuid,final int moveId,UserHandle user) throws PackageManagerException {
  final StorageManager storage=mContext.getSystemService(StorageManager.class);
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
  final int targetSdkVersion;
  final PackageFreezer freezer;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,""String_Node_Str"");
    }
    if (pkg.applicationInfo.isExternalAsec()) {
      currentAsec=true;
      currentVolumeUuid=StorageManager.UUID_PRIMARY_PHYSICAL;
    }
 else     if (pkg.applicationInfo.isForwardLocked()) {
      currentAsec=true;
      currentVolumeUuid=""String_Node_Str"";
    }
 else {
      currentAsec=false;
      currentVolumeUuid=ps.volumeUuid;
      final File probe=new File(pkg.codePath);
      final File probeOat=new File(probe,""String_Node_Str"");
      if (!probe.isDirectory() || !probeOat.isDirectory()) {
        throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
      }
    }
    if (Objects.equals(currentVolumeUuid,volumeUuid)) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"" + volumeUuid);
    }
    if (pkg.applicationInfo.isInternal() && isPackageDeviceAdminOnAnyUser(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_DEVICE_ADMIN,""String_Node_Str"");
    }
    if (mFrozenPackages.contains(packageName)) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,""String_Node_Str"");
    }
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
    targetSdkVersion=pkg.applicationInfo.targetSdkVersion;
    freezer=new PackageFreezer(packageName,""String_Node_Str"");
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveCompleteApp;
  final File measurePath;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=!currentAsec;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveCompleteApp=false;
    measurePath=storage.getPrimaryPhysicalVolume().getPath();
  }
 else {
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveCompleteApp=true;
    measurePath=Environment.getDataAppDirectory(volumeUuid);
  }
  final PackageStats stats=new PackageStats(null,-1);
synchronized (mInstaller) {
    if (!getPackageSizeInfoLI(packageName,-1,stats)) {
      freezer.close();
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
    }
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,""String_Node_Str"" + stats.codeSize + ""String_Node_Str""+ stats.dataSize);
  final long startFreeBytes=measurePath.getFreeSpace();
  final long sizeBytes;
  if (moveCompleteApp) {
    sizeBytes=stats.codeSize + stats.dataSize;
  }
 else {
    sizeBytes=stats.codeSize;
  }
  if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
    freezer.close();
    throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,""String_Node_Str"");
  }
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  final CountDownLatch installedLatch=new CountDownLatch(1);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      if (DEBUG_INSTALL)       Slog.d(TAG,""String_Node_Str"" + PackageManager.installStatusToString(returnCode,msg));
      installedLatch.countDown();
      freezer.close();
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
final MoveInfo move;
if (moveCompleteApp) {
new Thread(){
@Override public void run(){
while (true) {
try {
if (installedLatch.await(1,TimeUnit.SECONDS)) {
  break;
}
}
 catch (InterruptedException ignored) {
}
final long deltaFreeBytes=startFreeBytes - measurePath.getFreeSpace();
final int progress=10 + (int)MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes),0,80);
mMoveCallbacks.notifyStatusChanged(moveId,progress);
}
}
}
.start();
final String dataAppName=codeFile.getName();
move=new MoveInfo(moveId,currentVolumeUuid,volumeUuid,packageName,dataAppName,appId,seinfo,targetSdkVersion);
}
 else {
move=null;
}
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
final InstallParams params=new InstallParams(origin,move,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride,null,null);
params.setTraceMethod(""String_Node_Str"").setTraceCookie(System.identityHashCode(params));
msg.obj=params;
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,""String_Node_Str"",System.identityHashCode(msg.obj));
mHandler.sendMessage(msg);
}",0.9936648947789994
191929,"private void replacePackageLIF(PackageParser.Package pkg,final int policyFlags,int scanFlags,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  final boolean isEphemeral=(policyFlags & PackageParser.PARSE_IS_EPHEMERAL) != 0;
  final PackageParser.Package oldPackage;
  final String pkgName=pkg.packageName;
  final int[] allUsers;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    final boolean oldIsEphemeral=oldPackage.applicationInfo.isEphemeralApp();
    if (isEphemeral && !oldIsEphemeral) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID);
      return;
    }
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    final PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (shouldCheckUpgradeKeySetLP(ps,scanFlags)) {
      if (!checkUpgradeKeySetLP(ps,pkg)) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
 else {
      if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
    String invalidPackageName=getParentOrChildPackageChangedSharedUser(oldPackage,pkg);
    if (invalidPackageName != null) {
      res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE,""String_Node_Str"" + invalidPackageName + ""String_Node_Str""+ oldPackage.mSharedUserId);
      return;
    }
    allUsers=sUserManager.getUserIds();
  }
  res.removedInfo=new PackageRemovedInfo();
  res.removedInfo.uid=oldPackage.applicationInfo.uid;
  res.removedInfo.removedPackage=oldPackage.packageName;
  res.removedInfo.isUpdate=true;
  final int childCount=(oldPackage.childPackages != null) ? oldPackage.childPackages.size() : 0;
  for (int i=0; i < childCount; i++) {
    boolean childPackageUpdated=false;
    PackageParser.Package childPkg=oldPackage.childPackages.get(i);
    if (res.addedChildPackages != null) {
      PackageInstalledInfo childRes=res.addedChildPackages.get(childPkg.packageName);
      if (childRes != null) {
        childRes.removedInfo.uid=childPkg.applicationInfo.uid;
        childRes.removedInfo.removedPackage=childPkg.packageName;
        childRes.removedInfo.isUpdate=true;
        childPackageUpdated=true;
      }
    }
    if (!childPackageUpdated) {
      PackageRemovedInfo childRemovedRes=new PackageRemovedInfo();
      childRemovedRes.removedPackage=childPkg.packageName;
      childRemovedRes.isUpdate=false;
      childRemovedRes.dataRemoved=true;
synchronized (mPackages) {
        PackageSetting childPs=mSettings.peekPackageLPr(childPkg.packageName);
        if (childPs != null) {
          childRemovedRes.origUsers=childPs.queryInstalledUsers(allUsers,true);
        }
      }
      if (res.removedInfo.removedChildPackages == null) {
        res.removedInfo.removedChildPackages=new ArrayMap<>();
      }
      res.removedInfo.removedChildPackages.put(childPkg.packageName,childRemovedRes);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    final boolean privileged=(oldPackage.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0;
    final int systemPolicyFlags=policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0);
    replaceSystemPackageLIF(oldPackage,pkg,systemPolicyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLIF(oldPackage,pkg,policyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
}","private void replacePackageLIF(PackageParser.Package pkg,final int policyFlags,int scanFlags,UserHandle user,String installerPackageName,PackageInstalledInfo res){
  final boolean isEphemeral=(policyFlags & PackageParser.PARSE_IS_EPHEMERAL) != 0;
  final PackageParser.Package oldPackage;
  final String pkgName=pkg.packageName;
  final int[] allUsers;
  final int[] installedUsers;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    final boolean oldIsEphemeral=oldPackage.applicationInfo.isEphemeralApp();
    if (isEphemeral && !oldIsEphemeral) {
      Slog.w(TAG,""String_Node_Str"" + pkgName);
      res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID);
      return;
    }
    if (DEBUG_INSTALL)     Slog.d(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ oldPackage);
    final PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (shouldCheckUpgradeKeySetLP(ps,scanFlags)) {
      if (!checkUpgradeKeySetLP(ps,pkg)) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
 else {
      if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,""String_Node_Str"" + pkgName);
        return;
      }
    }
    String invalidPackageName=getParentOrChildPackageChangedSharedUser(oldPackage,pkg);
    if (invalidPackageName != null) {
      res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE,""String_Node_Str"" + invalidPackageName + ""String_Node_Str""+ oldPackage.mSharedUserId);
      return;
    }
    allUsers=sUserManager.getUserIds();
    installedUsers=ps.queryInstalledUsers(allUsers,true);
  }
  res.removedInfo=new PackageRemovedInfo();
  res.removedInfo.uid=oldPackage.applicationInfo.uid;
  res.removedInfo.removedPackage=oldPackage.packageName;
  res.removedInfo.isUpdate=true;
  res.removedInfo.origUsers=installedUsers;
  final int childCount=(oldPackage.childPackages != null) ? oldPackage.childPackages.size() : 0;
  for (int i=0; i < childCount; i++) {
    boolean childPackageUpdated=false;
    PackageParser.Package childPkg=oldPackage.childPackages.get(i);
    if (res.addedChildPackages != null) {
      PackageInstalledInfo childRes=res.addedChildPackages.get(childPkg.packageName);
      if (childRes != null) {
        childRes.removedInfo.uid=childPkg.applicationInfo.uid;
        childRes.removedInfo.removedPackage=childPkg.packageName;
        childRes.removedInfo.isUpdate=true;
        childPackageUpdated=true;
      }
    }
    if (!childPackageUpdated) {
      PackageRemovedInfo childRemovedRes=new PackageRemovedInfo();
      childRemovedRes.removedPackage=childPkg.packageName;
      childRemovedRes.isUpdate=false;
      childRemovedRes.dataRemoved=true;
synchronized (mPackages) {
        PackageSetting childPs=mSettings.peekPackageLPr(childPkg.packageName);
        if (childPs != null) {
          childRemovedRes.origUsers=childPs.queryInstalledUsers(allUsers,true);
        }
      }
      if (res.removedInfo.removedChildPackages == null) {
        res.removedInfo.removedChildPackages=new ArrayMap<>();
      }
      res.removedInfo.removedChildPackages.put(childPkg.packageName,childRemovedRes);
    }
  }
  boolean sysPkg=(isSystemApp(oldPackage));
  if (sysPkg) {
    final boolean privileged=(oldPackage.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0;
    final int systemPolicyFlags=policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0);
    replaceSystemPackageLIF(oldPackage,pkg,systemPolicyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
 else {
    replaceNonSystemPackageLIF(oldPackage,pkg,policyFlags,scanFlags,user,allUsers,installerPackageName,res);
  }
}",0.9823293172690764
191930,"final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward,boolean reallyResume,int seq,String reason){
  ActivityClientRecord r=mActivities.get(token);
  if (!checkAndUpdateLifecycleSeq(seq,r,""String_Node_Str"")) {
    return;
  }
  unscheduleGcIdler();
  mSomeActivitiesChanged=true;
  r=performResumeActivity(token,clearHide,reason);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    boolean willBeVisible=!a.mStartedActivity;
    if (!willBeVisible) {
      try {
        willBeVisible=ActivityManagerNative.getDefault().willActivityBeVisible(a.getActivityToken());
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (r.window == null && !a.mFinished && willBeVisible) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (r.mPreserveWindow) {
        a.mWindowAdded=true;
        r.mPreserveWindow=false;
      }
      if (a.mVisibleFromClient && !a.mWindowAdded) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (!willBeVisible) {
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    cleanUpPendingRemoveWindows(r,false);
    if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChangedForActivity(r,r.newConfig,REPORT_TO_ACTIVITY);
        if (DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.activity.mCurrentConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    if (!r.onlyLocalRequest) {
      r.nextIdle=mNewActivities;
      mNewActivities=r;
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r);
      Looper.myQueue().addIdleHandler(new Idler());
    }
    r.onlyLocalRequest=false;
    if (reallyResume) {
      try {
        ActivityManagerNative.getDefault().activityResumed(token);
      }
 catch (      RemoteException ex) {
        throw ex.rethrowFromSystemServer();
      }
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null,Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
    }
 catch (    RemoteException ex) {
      throw ex.rethrowFromSystemServer();
    }
  }
}","final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward,boolean reallyResume,int seq,String reason){
  ActivityClientRecord r=mActivities.get(token);
  if (!checkAndUpdateLifecycleSeq(seq,r,""String_Node_Str"")) {
    return;
  }
  unscheduleGcIdler();
  mSomeActivitiesChanged=true;
  r=performResumeActivity(token,clearHide,reason);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    boolean willBeVisible=!a.mStartedActivity;
    if (!willBeVisible) {
      try {
        willBeVisible=ActivityManagerNative.getDefault().willActivityBeVisible(a.getActivityToken());
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (r.window == null && !a.mFinished && willBeVisible) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (r.mPreserveWindow) {
        a.mWindowAdded=true;
        r.mPreserveWindow=false;
        ViewRootImpl impl=decor.getViewRootImpl();
        impl.notifyChildRebuilt();
      }
      if (a.mVisibleFromClient && !a.mWindowAdded) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (!willBeVisible) {
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    cleanUpPendingRemoveWindows(r,false);
    if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChangedForActivity(r,r.newConfig,REPORT_TO_ACTIVITY);
        if (DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.activity.mCurrentConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    if (!r.onlyLocalRequest) {
      r.nextIdle=mNewActivities;
      mNewActivities=r;
      if (localLOGV)       Slog.v(TAG,""String_Node_Str"" + r);
      Looper.myQueue().addIdleHandler(new Idler());
    }
    r.onlyLocalRequest=false;
    if (reallyResume) {
      try {
        ActivityManagerNative.getDefault().activityResumed(token);
      }
 catch (      RemoteException ex) {
        throw ex.rethrowFromSystemServer();
      }
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null,Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
    }
 catch (    RemoteException ex) {
      throw ex.rethrowFromSystemServer();
    }
  }
}",0.9882127192982456
191931,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplayAdjustments.getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight()) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplayAdjustments.getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  final int surfaceGenerationId=mSurface.getGenerationId();
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface || surfaceGenerationId != mSurface.getGenerationId()) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight()) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}",0.996143874861114
191932,"private int runQueryIntentReceivers(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentReceivers(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      pw.print(result.size());
      pw.println(""String_Node_Str"");
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      for (int i=0; i < result.size(); i++) {
        pw.print(""String_Node_Str"");
        pw.print(i);
        pw.println(""String_Node_Str"");
        result.get(i).dump(pr,""String_Node_Str"");
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runQueryIntentReceivers(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentReceivers(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      if (!mComponents) {
        pw.print(result.size());
        pw.println(""String_Node_Str"");
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          pw.print(""String_Node_Str"");
          pw.print(i);
          pw.println(""String_Node_Str"");
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
 else {
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.8225490196078431
191933,"private Intent parseIntentAndUser() throws URISyntaxException {
  mTargetUser=UserHandle.USER_CURRENT;
  Intent intent=Intent.parseCommandArgs(this,new Intent.CommandOptionHandler(){
    @Override public boolean handleOption(    String opt,    ShellCommand cmd){
      if (""String_Node_Str"".equals(opt)) {
        mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
        return true;
      }
      return false;
    }
  }
);
  mTargetUser=ActivityManager.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),mTargetUser,false,false,null,null);
  return intent;
}","private Intent parseIntentAndUser() throws URISyntaxException {
  mTargetUser=UserHandle.USER_CURRENT;
  mBrief=false;
  mComponents=false;
  Intent intent=Intent.parseCommandArgs(this,new Intent.CommandOptionHandler(){
    @Override public boolean handleOption(    String opt,    ShellCommand cmd){
      if (""String_Node_Str"".equals(opt)) {
        mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
        return true;
      }
 else       if (""String_Node_Str"".equals(opt)) {
        mBrief=true;
        return true;
      }
 else       if (""String_Node_Str"".equals(opt)) {
        mComponents=true;
        return true;
      }
      return false;
    }
  }
);
  mTargetUser=ActivityManager.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),mTargetUser,false,false,null,null);
  return intent;
}",0.8305084745762712
191934,"private int runQueryIntentActivities(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentActivities(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      pw.print(result.size());
      pw.println(""String_Node_Str"");
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      for (int i=0; i < result.size(); i++) {
        pw.print(""String_Node_Str"");
        pw.print(i);
        pw.println(""String_Node_Str"");
        result.get(i).dump(pr,""String_Node_Str"");
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runQueryIntentActivities(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentActivities(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      if (!mComponents) {
        pw.print(result.size());
        pw.println(""String_Node_Str"");
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          pw.print(""String_Node_Str"");
          pw.print(i);
          pw.println(""String_Node_Str"");
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
 else {
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.8228962818003914
191935,"@Override public boolean handleOption(String opt,ShellCommand cmd){
  if (""String_Node_Str"".equals(opt)) {
    mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
    return true;
  }
  return false;
}","@Override public boolean handleOption(String opt,ShellCommand cmd){
  if (""String_Node_Str"".equals(opt)) {
    mTargetUser=UserHandle.parseUserArg(cmd.getNextArgRequired());
    return true;
  }
 else   if (""String_Node_Str"".equals(opt)) {
    mBrief=true;
    return true;
  }
 else   if (""String_Node_Str"".equals(opt)) {
    mComponents=true;
    return true;
  }
  return false;
}",0.6621848739495798
191936,"private int runQueryIntentServices(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentServices(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      pw.print(result.size());
      pw.println(""String_Node_Str"");
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      for (int i=0; i < result.size(); i++) {
        pw.print(""String_Node_Str"");
        pw.print(i);
        pw.println(""String_Node_Str"");
        result.get(i).dump(pr,""String_Node_Str"");
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runQueryIntentServices(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    List<ResolveInfo> result=mInterface.queryIntentServices(intent,null,0,mTargetUser).getList();
    PrintWriter pw=getOutPrintWriter();
    if (result == null || result.size() <= 0) {
      pw.println(""String_Node_Str"");
    }
 else {
      if (!mComponents) {
        pw.print(result.size());
        pw.println(""String_Node_Str"");
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          pw.print(""String_Node_Str"");
          pw.print(i);
          pw.println(""String_Node_Str"");
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
 else {
        PrintWriterPrinter pr=new PrintWriterPrinter(pw);
        for (int i=0; i < result.size(); i++) {
          printResolveInfo(pr,""String_Node_Str"",result.get(i),mBrief,mComponents);
        }
      }
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.8222003929273084
191937,"private int runResolveActivity(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    ResolveInfo ri=mInterface.resolveIntent(intent,null,0,mTargetUser);
    PrintWriter pw=getOutPrintWriter();
    if (ri == null) {
      pw.println(""String_Node_Str"");
    }
 else {
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      ri.dump(pr,""String_Node_Str"");
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}","private int runResolveActivity(){
  Intent intent;
  try {
    intent=parseIntentAndUser();
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  try {
    ResolveInfo ri=mInterface.resolveIntent(intent,null,0,mTargetUser);
    PrintWriter pw=getOutPrintWriter();
    if (ri == null) {
      pw.println(""String_Node_Str"");
    }
 else {
      PrintWriterPrinter pr=new PrintWriterPrinter(pw);
      printResolveInfo(pr,""String_Node_Str"",ri,mBrief,mComponents);
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return 0;
}",0.9622799664710812
191938,"public void instantCollapse(){
  abortAnimations();
  setExpandedFraction(0f);
  if (mExpanding) {
    notifyExpandingFinished();
  }
}","public void instantCollapse(){
  abortAnimations();
  setExpandedFraction(0f);
  if (mExpanding) {
    notifyExpandingFinished();
  }
  if (mInstantExpanding) {
    mInstantExpanding=false;
    notifyBarPanelExpansionChanged();
  }
}",0.7336956521739131
191939,"public void expand(final boolean animate){
  if (!isFullyCollapsed() && !isCollapsing()) {
    return;
  }
  mInstantExpanding=true;
  mUpdateFlingOnLayout=false;
  abortAnimations();
  cancelPeek();
  if (mTracking) {
    onTrackingStopped(true);
  }
  if (mExpanding) {
    notifyExpandingFinished();
  }
  notifyBarPanelExpansionChanged();
  getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      if (mStatusBar.getStatusBarWindow().getHeight() != mStatusBar.getStatusBarHeight()) {
        getViewTreeObserver().removeOnGlobalLayoutListener(this);
        if (animate) {
          notifyExpandingStarted();
          fling(0,true);
        }
 else {
          setExpandedFraction(1f);
        }
        mInstantExpanding=false;
      }
    }
  }
);
  requestLayout();
}","public void expand(final boolean animate){
  if (!isFullyCollapsed() && !isCollapsing()) {
    return;
  }
  mInstantExpanding=true;
  mUpdateFlingOnLayout=false;
  abortAnimations();
  cancelPeek();
  if (mTracking) {
    onTrackingStopped(true);
  }
  if (mExpanding) {
    notifyExpandingFinished();
  }
  notifyBarPanelExpansionChanged();
  getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      if (!mInstantExpanding) {
        getViewTreeObserver().removeOnGlobalLayoutListener(this);
        return;
      }
      if (mStatusBar.getStatusBarWindow().getHeight() != mStatusBar.getStatusBarHeight()) {
        getViewTreeObserver().removeOnGlobalLayoutListener(this);
        if (animate) {
          notifyExpandingStarted();
          fling(0,true);
        }
 else {
          setExpandedFraction(1f);
        }
        mInstantExpanding=false;
      }
    }
  }
);
  requestLayout();
}",0.933982683982684
191940,"@Override public void onGlobalLayout(){
  if (mStatusBar.getStatusBarWindow().getHeight() != mStatusBar.getStatusBarHeight()) {
    getViewTreeObserver().removeOnGlobalLayoutListener(this);
    if (animate) {
      notifyExpandingStarted();
      fling(0,true);
    }
 else {
      setExpandedFraction(1f);
    }
    mInstantExpanding=false;
  }
}","@Override public void onGlobalLayout(){
  if (!mInstantExpanding) {
    getViewTreeObserver().removeOnGlobalLayoutListener(this);
    return;
  }
  if (mStatusBar.getStatusBarWindow().getHeight() != mStatusBar.getStatusBarHeight()) {
    getViewTreeObserver().removeOnGlobalLayoutListener(this);
    if (animate) {
      notifyExpandingStarted();
      fling(0,true);
    }
 else {
      setExpandedFraction(1f);
    }
    mInstantExpanding=false;
  }
}",0.8675
191941,"@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (!mAppTransition.isTransitionSet() && mAppTransition.isReady()) {
        mOpeningApps.add(wtoken);
      }
      wtoken.startingMoved=false;
      if (wtoken.hidden || wtoken.mAppStopped) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (wtoken.mAppAnimator.usingTransferredAnimation && wtoken.mAppAnimator.animation == null) {
        Slog.wtf(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str"");
      }
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.mEnteringAnimation=true;
      }
 else {
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (!mAppTransition.isTransitionSet() && mAppTransition.isReady()) {
        mOpeningApps.add(wtoken);
      }
      wtoken.startingMoved=false;
      if (wtoken.hidden || wtoken.mAppStopped) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        if (wtoken.hidden) {
          wtoken.waitingToShow=true;
        }
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (wtoken.mAppAnimator.usingTransferredAnimation && wtoken.mAppAnimator.animation == null) {
        Slog.wtf(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str"");
      }
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.mEnteringAnimation=true;
      }
 else {
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}",0.988063027216298
191942,"public void instantCollapse(){
  abortAnimations();
  setExpandedFraction(0f);
  if (mExpanding) {
    notifyExpandingFinished();
  }
}","public void instantCollapse(){
  abortAnimations();
  setExpandedFraction(0f);
  if (mExpanding) {
    notifyExpandingFinished();
  }
  if (mInstantExpanding) {
    mInstantExpanding=false;
    notifyBarPanelExpansionChanged();
  }
}",0.7336956521739131
191943,"public void expand(final boolean animate){
  if (!isFullyCollapsed() && !isCollapsing()) {
    return;
  }
  mInstantExpanding=true;
  mUpdateFlingOnLayout=false;
  abortAnimations();
  cancelPeek();
  if (mTracking) {
    onTrackingStopped(true);
  }
  if (mExpanding) {
    notifyExpandingFinished();
  }
  notifyBarPanelExpansionChanged();
  getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      if (mStatusBar.getStatusBarWindow().getHeight() != mStatusBar.getStatusBarHeight()) {
        getViewTreeObserver().removeOnGlobalLayoutListener(this);
        if (animate) {
          notifyExpandingStarted();
          fling(0,true);
        }
 else {
          setExpandedFraction(1f);
        }
        mInstantExpanding=false;
      }
    }
  }
);
  requestLayout();
}","public void expand(final boolean animate){
  if (!isFullyCollapsed() && !isCollapsing()) {
    return;
  }
  mInstantExpanding=true;
  mUpdateFlingOnLayout=false;
  abortAnimations();
  cancelPeek();
  if (mTracking) {
    onTrackingStopped(true);
  }
  if (mExpanding) {
    notifyExpandingFinished();
  }
  notifyBarPanelExpansionChanged();
  getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      if (!mInstantExpanding) {
        getViewTreeObserver().removeOnGlobalLayoutListener(this);
        return;
      }
      if (mStatusBar.getStatusBarWindow().getHeight() != mStatusBar.getStatusBarHeight()) {
        getViewTreeObserver().removeOnGlobalLayoutListener(this);
        if (animate) {
          notifyExpandingStarted();
          fling(0,true);
        }
 else {
          setExpandedFraction(1f);
        }
        mInstantExpanding=false;
      }
    }
  }
);
  requestLayout();
}",0.933982683982684
191944,"@Override public void onGlobalLayout(){
  if (mStatusBar.getStatusBarWindow().getHeight() != mStatusBar.getStatusBarHeight()) {
    getViewTreeObserver().removeOnGlobalLayoutListener(this);
    if (animate) {
      notifyExpandingStarted();
      fling(0,true);
    }
 else {
      setExpandedFraction(1f);
    }
    mInstantExpanding=false;
  }
}","@Override public void onGlobalLayout(){
  if (!mInstantExpanding) {
    getViewTreeObserver().removeOnGlobalLayoutListener(this);
    return;
  }
  if (mStatusBar.getStatusBarWindow().getHeight() != mStatusBar.getStatusBarHeight()) {
    getViewTreeObserver().removeOnGlobalLayoutListener(this);
    if (animate) {
      notifyExpandingStarted();
      fling(0,true);
    }
 else {
      setExpandedFraction(1f);
    }
    mInstantExpanding=false;
  }
}",0.8675
191945,"@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (!mAppTransition.isTransitionSet() && mAppTransition.isReady()) {
        mOpeningApps.add(wtoken);
      }
      wtoken.startingMoved=false;
      if (wtoken.hidden || wtoken.mAppStopped) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (wtoken.mAppAnimator.usingTransferredAnimation && wtoken.mAppAnimator.animation == null) {
        Slog.wtf(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str"");
      }
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.mEnteringAnimation=true;
      }
 else {
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (!mAppTransition.isTransitionSet() && mAppTransition.isReady()) {
        mOpeningApps.add(wtoken);
      }
      wtoken.startingMoved=false;
      if (wtoken.hidden || wtoken.mAppStopped) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        if (wtoken.hidden) {
          wtoken.waitingToShow=true;
        }
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (wtoken.mAppAnimator.usingTransferredAnimation && wtoken.mAppAnimator.animation == null) {
        Slog.wtf(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str"");
      }
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.mEnteringAnimation=true;
      }
 else {
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}",0.988063027216298
191946,"boolean updateBoundsAfterConfigChange(boolean scheduleResize){
  if (mLastConfigChangedRotation != mLastUpdateDisplayInfoRotation) {
    return false;
  }
  final int newRotation=getDisplayInfo().rotation;
  final int newDensity=getDisplayInfo().logicalDensityDpi;
  if (mRotation == newRotation && mDensity == newDensity) {
    return false;
  }
  final int oldDockSide=mStackId == DOCKED_STACK_ID ? getDockSide() : DOCKED_INVALID;
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    repositionDockedStackAfterRotation(mTmpRect2);
    snapDockedStackAfterRotation(mTmpRect2);
    final int newDockSide=getDockSide(mTmpRect2);
    if (oldDockSide != newDockSide) {
      mDisplayContent.getDockedDividerController().notifyDockSideChanged(newDockSide);
    }
  }
  if (scheduleResize) {
    mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2).sendToTarget();
  }
 else {
    mBoundsAfterRotation.set(mTmpRect2);
  }
  return true;
}","boolean updateBoundsAfterConfigChange(boolean scheduleResize){
  if (mFullscreen) {
    return false;
  }
  if (mLastConfigChangedRotation != mLastUpdateDisplayInfoRotation) {
    return false;
  }
  final int newRotation=getDisplayInfo().rotation;
  final int newDensity=getDisplayInfo().logicalDensityDpi;
  if (mRotation == newRotation && mDensity == newDensity) {
    return false;
  }
  final int oldDockSide=mStackId == DOCKED_STACK_ID ? getDockSide() : DOCKED_INVALID;
  mTmpRect2.set(mBounds);
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    repositionDockedStackAfterRotation(mTmpRect2);
    snapDockedStackAfterRotation(mTmpRect2);
    final int newDockSide=getDockSide(mTmpRect2);
    if (oldDockSide != newDockSide) {
      mDisplayContent.getDockedDividerController().notifyDockSideChanged(newDockSide);
    }
  }
  if (scheduleResize) {
    mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2).sendToTarget();
  }
 else {
    mBoundsAfterRotation.set(mTmpRect2);
  }
  return true;
}",0.966456003889159
191947,"boolean updateBoundsAfterConfigChange(boolean scheduleResize){
  if (mLastConfigChangedRotation != mLastUpdateDisplayInfoRotation) {
    return false;
  }
  final int newRotation=getDisplayInfo().rotation;
  final int newDensity=getDisplayInfo().logicalDensityDpi;
  if (mRotation == newRotation && mDensity == newDensity) {
    return false;
  }
  final int oldDockSide=mStackId == DOCKED_STACK_ID ? getDockSide() : DOCKED_INVALID;
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    repositionDockedStackAfterRotation(mTmpRect2);
    snapDockedStackAfterRotation(mTmpRect2);
    final int newDockSide=getDockSide(mTmpRect2);
    if (oldDockSide != newDockSide) {
      mDisplayContent.getDockedDividerController().notifyDockSideChanged(newDockSide);
    }
  }
  if (scheduleResize) {
    mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2).sendToTarget();
  }
 else {
    mBoundsAfterRotation.set(mTmpRect2);
  }
  return true;
}","boolean updateBoundsAfterConfigChange(boolean scheduleResize){
  if (mFullscreen) {
    return false;
  }
  if (mLastConfigChangedRotation != mLastUpdateDisplayInfoRotation) {
    return false;
  }
  final int newRotation=getDisplayInfo().rotation;
  final int newDensity=getDisplayInfo().logicalDensityDpi;
  if (mRotation == newRotation && mDensity == newDensity) {
    return false;
  }
  final int oldDockSide=mStackId == DOCKED_STACK_ID ? getDockSide() : DOCKED_INVALID;
  mTmpRect2.set(mBounds);
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    repositionDockedStackAfterRotation(mTmpRect2);
    snapDockedStackAfterRotation(mTmpRect2);
    final int newDockSide=getDockSide(mTmpRect2);
    if (oldDockSide != newDockSide) {
      mDisplayContent.getDockedDividerController().notifyDockSideChanged(newDockSide);
    }
  }
  if (scheduleResize) {
    mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2).sendToTarget();
  }
 else {
    mBoundsAfterRotation.set(mTmpRect2);
  }
  return true;
}",0.966456003889159
191948,"boolean updateBoundsAfterConfigChange(boolean scheduleResize){
  if (mLastConfigChangedRotation != mLastUpdateDisplayInfoRotation) {
    return false;
  }
  final int newRotation=getDisplayInfo().rotation;
  final int newDensity=getDisplayInfo().logicalDensityDpi;
  if (mRotation == newRotation && mDensity == newDensity) {
    return false;
  }
  final int oldDockSide=mStackId == DOCKED_STACK_ID ? getDockSide() : DOCKED_INVALID;
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    repositionDockedStackAfterRotation(mTmpRect2);
    snapDockedStackAfterRotation(mTmpRect2);
    final int newDockSide=getDockSide(mTmpRect2);
    if (oldDockSide != newDockSide) {
      mDisplayContent.getDockedDividerController().notifyDockSideChanged(newDockSide);
    }
  }
  if (scheduleResize) {
    mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2).sendToTarget();
  }
 else {
    mBoundsAfterRotation.set(mTmpRect2);
  }
  return true;
}","boolean updateBoundsAfterConfigChange(boolean scheduleResize){
  if (mFullscreen) {
    return false;
  }
  if (mLastConfigChangedRotation != mLastUpdateDisplayInfoRotation) {
    return false;
  }
  final int newRotation=getDisplayInfo().rotation;
  final int newDensity=getDisplayInfo().logicalDensityDpi;
  if (mRotation == newRotation && mDensity == newDensity) {
    return false;
  }
  final int oldDockSide=mStackId == DOCKED_STACK_ID ? getDockSide() : DOCKED_INVALID;
  mTmpRect2.set(mBounds);
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    repositionDockedStackAfterRotation(mTmpRect2);
    snapDockedStackAfterRotation(mTmpRect2);
    final int newDockSide=getDockSide(mTmpRect2);
    if (oldDockSide != newDockSide) {
      mDisplayContent.getDockedDividerController().notifyDockSideChanged(newDockSide);
    }
  }
  if (scheduleResize) {
    mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2).sendToTarget();
  }
 else {
    mBoundsAfterRotation.set(mTmpRect2);
  }
  return true;
}",0.966456003889159
191949,"/** 
 * Handles dragging touch events
 */
private void handleTouchEvent(MotionEvent ev){
  int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  float evX=ev.getX();
  float evY=ev.getY();
  float x=evX - mTaskViewOffset.x;
  float y=evY - mTaskViewOffset.y;
  if (mDragRequested) {
    if (!mIsDragging) {
      mIsDragging=Math.hypot(evX - mDownPos.x,evY - mDownPos.y) > mDragSlop;
    }
    if (mIsDragging) {
      int width=mRv.getMeasuredWidth();
      int height=mRv.getMeasuredHeight();
      DropTarget currentDropTarget=null;
      if (mLastDropTarget != null) {
        if (mLastDropTarget.acceptsDrop((int)evX,(int)evY,width,height,true)) {
          currentDropTarget=mLastDropTarget;
        }
      }
      if (currentDropTarget == null) {
        for (        DropTarget target : mDropTargets) {
          if (target.acceptsDrop((int)evX,(int)evY,width,height,false)) {
            currentDropTarget=target;
            break;
          }
        }
      }
      if (mLastDropTarget != currentDropTarget) {
        mLastDropTarget=currentDropTarget;
        EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
      }
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragRequested) {
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,action == MotionEvent.ACTION_UP ? mLastDropTarget : null));
  break;
}
}
}
}","/** 
 * Handles dragging touch events
 */
private void handleTouchEvent(MotionEvent ev){
  int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  float evX=ev.getX();
  float evY=ev.getY();
  float x=evX - mTaskViewOffset.x;
  float y=evY - mTaskViewOffset.y;
  if (mDragRequested) {
    if (!mIsDragging) {
      mIsDragging=Math.hypot(evX - mDownPos.x,evY - mDownPos.y) > mDragSlop;
    }
    if (mIsDragging) {
      int width=mRv.getMeasuredWidth();
      int height=mRv.getMeasuredHeight();
      DropTarget currentDropTarget=null;
      if (mLastDropTarget != null) {
        if (mLastDropTarget.acceptsDrop((int)evX,(int)evY,width,height,true)) {
          currentDropTarget=mLastDropTarget;
        }
      }
      if (currentDropTarget == null) {
        for (        DropTarget target : mDropTargets) {
          if (target.acceptsDrop((int)evX,(int)evY,width,height,false)) {
            currentDropTarget=target;
            break;
          }
        }
      }
      if (mLastDropTarget != currentDropTarget) {
        mLastDropTarget=currentDropTarget;
        EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
      }
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragRequested) {
  boolean cancelled=action == MotionEvent.ACTION_CANCEL;
  if (cancelled) {
    EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,null));
  }
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,!cancelled ? mLastDropTarget : null));
  break;
}
}
}
}",0.9190803224843236
191950,"/** 
 * Handles dragging touch events
 */
private void handleTouchEvent(MotionEvent ev){
  int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  float evX=ev.getX();
  float evY=ev.getY();
  float x=evX - mTaskViewOffset.x;
  float y=evY - mTaskViewOffset.y;
  if (mDragRequested) {
    if (!mIsDragging) {
      mIsDragging=Math.hypot(evX - mDownPos.x,evY - mDownPos.y) > mDragSlop;
    }
    if (mIsDragging) {
      int width=mRv.getMeasuredWidth();
      int height=mRv.getMeasuredHeight();
      DropTarget currentDropTarget=null;
      if (mLastDropTarget != null) {
        if (mLastDropTarget.acceptsDrop((int)evX,(int)evY,width,height,true)) {
          currentDropTarget=mLastDropTarget;
        }
      }
      if (currentDropTarget == null) {
        for (        DropTarget target : mDropTargets) {
          if (target.acceptsDrop((int)evX,(int)evY,width,height,false)) {
            currentDropTarget=target;
            break;
          }
        }
      }
      if (mLastDropTarget != currentDropTarget) {
        mLastDropTarget=currentDropTarget;
        EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
      }
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragRequested) {
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,action == MotionEvent.ACTION_UP ? mLastDropTarget : null));
  break;
}
}
}
}","/** 
 * Handles dragging touch events
 */
private void handleTouchEvent(MotionEvent ev){
  int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  float evX=ev.getX();
  float evY=ev.getY();
  float x=evX - mTaskViewOffset.x;
  float y=evY - mTaskViewOffset.y;
  if (mDragRequested) {
    if (!mIsDragging) {
      mIsDragging=Math.hypot(evX - mDownPos.x,evY - mDownPos.y) > mDragSlop;
    }
    if (mIsDragging) {
      int width=mRv.getMeasuredWidth();
      int height=mRv.getMeasuredHeight();
      DropTarget currentDropTarget=null;
      if (mLastDropTarget != null) {
        if (mLastDropTarget.acceptsDrop((int)evX,(int)evY,width,height,true)) {
          currentDropTarget=mLastDropTarget;
        }
      }
      if (currentDropTarget == null) {
        for (        DropTarget target : mDropTargets) {
          if (target.acceptsDrop((int)evX,(int)evY,width,height,false)) {
            currentDropTarget=target;
            break;
          }
        }
      }
      if (mLastDropTarget != currentDropTarget) {
        mLastDropTarget=currentDropTarget;
        EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
      }
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragRequested) {
  boolean cancelled=action == MotionEvent.ACTION_CANCEL;
  if (cancelled) {
    EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,null));
  }
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,!cancelled ? mLastDropTarget : null));
  break;
}
}
}
}",0.9190803224843236
191951,"/** 
 * Handles dragging touch events
 */
private void handleTouchEvent(MotionEvent ev){
  int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  float evX=ev.getX();
  float evY=ev.getY();
  float x=evX - mTaskViewOffset.x;
  float y=evY - mTaskViewOffset.y;
  if (mDragRequested) {
    if (!mIsDragging) {
      mIsDragging=Math.hypot(evX - mDownPos.x,evY - mDownPos.y) > mDragSlop;
    }
    if (mIsDragging) {
      int width=mRv.getMeasuredWidth();
      int height=mRv.getMeasuredHeight();
      DropTarget currentDropTarget=null;
      if (mLastDropTarget != null) {
        if (mLastDropTarget.acceptsDrop((int)evX,(int)evY,width,height,true)) {
          currentDropTarget=mLastDropTarget;
        }
      }
      if (currentDropTarget == null) {
        for (        DropTarget target : mDropTargets) {
          if (target.acceptsDrop((int)evX,(int)evY,width,height,false)) {
            currentDropTarget=target;
            break;
          }
        }
      }
      if (mLastDropTarget != currentDropTarget) {
        mLastDropTarget=currentDropTarget;
        EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
      }
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragRequested) {
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,action == MotionEvent.ACTION_UP ? mLastDropTarget : null));
  break;
}
}
}
}","/** 
 * Handles dragging touch events
 */
private void handleTouchEvent(MotionEvent ev){
  int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  float evX=ev.getX();
  float evY=ev.getY();
  float x=evX - mTaskViewOffset.x;
  float y=evY - mTaskViewOffset.y;
  if (mDragRequested) {
    if (!mIsDragging) {
      mIsDragging=Math.hypot(evX - mDownPos.x,evY - mDownPos.y) > mDragSlop;
    }
    if (mIsDragging) {
      int width=mRv.getMeasuredWidth();
      int height=mRv.getMeasuredHeight();
      DropTarget currentDropTarget=null;
      if (mLastDropTarget != null) {
        if (mLastDropTarget.acceptsDrop((int)evX,(int)evY,width,height,true)) {
          currentDropTarget=mLastDropTarget;
        }
      }
      if (currentDropTarget == null) {
        for (        DropTarget target : mDropTargets) {
          if (target.acceptsDrop((int)evX,(int)evY,width,height,false)) {
            currentDropTarget=target;
            break;
          }
        }
      }
      if (mLastDropTarget != currentDropTarget) {
        mLastDropTarget=currentDropTarget;
        EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
      }
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragRequested) {
  boolean cancelled=action == MotionEvent.ACTION_CANCEL;
  if (cancelled) {
    EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,null));
  }
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,!cancelled ? mLastDropTarget : null));
  break;
}
}
}
}",0.9190803224843236
191952,"/** 
 * Sets the focused state.
 */
public void setFocusState(int focusState){
  int prevFocusState=mFocusState;
  mFocusState=focusState;
  updateFrontBackTransforms();
  if (mCb != null) {
    mCb.onFocusStateChanged(prevFocusState,focusState);
  }
}","/** 
 * Sets the focused state.
 */
public void setFocusState(int focusState){
  int prevFocusState=mFocusState;
  mFocusState=focusState;
  updateFrontBackTransforms();
  if (mCb != null && (prevFocusState != focusState)) {
    mCb.onFocusStateChanged(prevFocusState,focusState);
  }
}",0.9368029739776952
191953,"/** 
 * Relayout the the visible   {@link TaskView}s to their current transforms as specified by the  {@link TaskStackLayoutAlgorithm} with the given {@param animation}. This call cancels any animations that are current running on those task views, and will ensure that the children  {@link TaskView}s will match the set of visible tasks in the stack.
 */
private void relayoutTaskViews(AnimationProps animation,boolean ignoreTaskOverrides){
  mDeferredTaskViewLayoutAnimation=null;
  bindVisibleTaskViews(mStackScroller.getStackScroll(),ignoreTaskOverrides);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  for (int i=0; i < taskViewCount; i++) {
    TaskView tv=taskViews.get(i);
    int taskIndex=mStack.indexOfStackTask(tv.getTask());
    TaskViewTransform transform=mCurrentTaskTransforms.get(taskIndex);
    if (mIgnoreTasks.contains(tv.getTask().key)) {
      continue;
    }
    updateTaskViewToTransform(tv,transform,animation);
  }
}","/** 
 * Relayout the the visible   {@link TaskView}s to their current transforms as specified by the  {@link TaskStackLayoutAlgorithm} with the given {@param animation}. This call cancels any animations that are current running on those task views, and will ensure that the children  {@link TaskView}s will match the set of visible tasks in the stack.
 */
private void relayoutTaskViews(AnimationProps animation,boolean ignoreTaskOverrides){
  cancelDeferredTaskViewLayoutAnimation();
  bindVisibleTaskViews(mStackScroller.getStackScroll(),ignoreTaskOverrides);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  for (int i=0; i < taskViewCount; i++) {
    TaskView tv=taskViews.get(i);
    int taskIndex=mStack.indexOfStackTask(tv.getTask());
    TaskViewTransform transform=mCurrentTaskTransforms.get(taskIndex);
    if (mIgnoreTasks.contains(tv.getTask().key)) {
      continue;
    }
    updateTaskViewToTransform(tv,transform,animation);
  }
}",0.992849846782431
191954,"/** 
 * Cancels all   {@link TaskView} animations.
 * @param ignoreTasksSet The set of tasks to continue running their animations.
 */
void cancelAllTaskViewAnimations(ArraySet<Task.TaskKey> ignoreTasksSet){
  List<TaskView> taskViews=getTaskViews();
  for (int i=taskViews.size() - 1; i >= 0; i--) {
    final TaskView tv=taskViews.get(i);
    if (!ignoreTasksSet.contains(tv.getTask().key)) {
      tv.cancelTransformAnimation();
    }
  }
}","/** 
 * Cancels all   {@link TaskView} animations.
 */
void cancelAllTaskViewAnimations(){
  List<TaskView> taskViews=getTaskViews();
  for (int i=taskViews.size() - 1; i >= 0; i--) {
    final TaskView tv=taskViews.get(i);
    if (!mIgnoreTasks.contains(tv.getTask().key)) {
      tv.cancelTransformAnimation();
    }
  }
}",0.8396349413298566
191955,"private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      Utilities.cancelAnimationWithoutCallbacks(mScrollFlingAnimator);
      mSv.cancelAllTaskViewAnimations();
      ArrayMap<View,Animator> existingAnimators=new ArrayMap<>(mSwipeHelperAnimations);
      for (int i=0; i < existingAnimators.size(); i++) {
        existingAnimators.get(existingAnimators.keyAt(i)).end();
      }
      mSwipeHelperAnimations.clear();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}","private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      finishAnimations();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}",0.9566790846194784
191956,"/** 
 * Sets the focused state.
 */
public void setFocusState(int focusState){
  int prevFocusState=mFocusState;
  mFocusState=focusState;
  updateFrontBackTransforms();
  if (mCb != null) {
    mCb.onFocusStateChanged(prevFocusState,focusState);
  }
}","/** 
 * Sets the focused state.
 */
public void setFocusState(int focusState){
  int prevFocusState=mFocusState;
  mFocusState=focusState;
  updateFrontBackTransforms();
  if (mCb != null && (prevFocusState != focusState)) {
    mCb.onFocusStateChanged(prevFocusState,focusState);
  }
}",0.9368029739776952
191957,"/** 
 * Relayout the the visible   {@link TaskView}s to their current transforms as specified by the  {@link TaskStackLayoutAlgorithm} with the given {@param animation}. This call cancels any animations that are current running on those task views, and will ensure that the children  {@link TaskView}s will match the set of visible tasks in the stack.
 */
private void relayoutTaskViews(AnimationProps animation,boolean ignoreTaskOverrides){
  mDeferredTaskViewLayoutAnimation=null;
  bindVisibleTaskViews(mStackScroller.getStackScroll(),ignoreTaskOverrides);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  for (int i=0; i < taskViewCount; i++) {
    TaskView tv=taskViews.get(i);
    int taskIndex=mStack.indexOfStackTask(tv.getTask());
    TaskViewTransform transform=mCurrentTaskTransforms.get(taskIndex);
    if (mIgnoreTasks.contains(tv.getTask().key)) {
      continue;
    }
    updateTaskViewToTransform(tv,transform,animation);
  }
}","/** 
 * Relayout the the visible   {@link TaskView}s to their current transforms as specified by the  {@link TaskStackLayoutAlgorithm} with the given {@param animation}. This call cancels any animations that are current running on those task views, and will ensure that the children  {@link TaskView}s will match the set of visible tasks in the stack.
 */
private void relayoutTaskViews(AnimationProps animation,boolean ignoreTaskOverrides){
  cancelDeferredTaskViewLayoutAnimation();
  bindVisibleTaskViews(mStackScroller.getStackScroll(),ignoreTaskOverrides);
  List<TaskView> taskViews=getTaskViews();
  int taskViewCount=taskViews.size();
  for (int i=0; i < taskViewCount; i++) {
    TaskView tv=taskViews.get(i);
    int taskIndex=mStack.indexOfStackTask(tv.getTask());
    TaskViewTransform transform=mCurrentTaskTransforms.get(taskIndex);
    if (mIgnoreTasks.contains(tv.getTask().key)) {
      continue;
    }
    updateTaskViewToTransform(tv,transform,animation);
  }
}",0.992849846782431
191958,"/** 
 * Cancels all   {@link TaskView} animations.
 * @param ignoreTasksSet The set of tasks to continue running their animations.
 */
void cancelAllTaskViewAnimations(ArraySet<Task.TaskKey> ignoreTasksSet){
  List<TaskView> taskViews=getTaskViews();
  for (int i=taskViews.size() - 1; i >= 0; i--) {
    final TaskView tv=taskViews.get(i);
    if (!ignoreTasksSet.contains(tv.getTask().key)) {
      tv.cancelTransformAnimation();
    }
  }
}","/** 
 * Cancels all   {@link TaskView} animations.
 */
void cancelAllTaskViewAnimations(){
  List<TaskView> taskViews=getTaskViews();
  for (int i=taskViews.size() - 1; i >= 0; i--) {
    final TaskView tv=taskViews.get(i);
    if (!mIgnoreTasks.contains(tv.getTask().key)) {
      tv.cancelTransformAnimation();
    }
  }
}",0.8396349413298566
191959,"private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      Utilities.cancelAnimationWithoutCallbacks(mScrollFlingAnimator);
      mSv.cancelAllTaskViewAnimations();
      ArrayMap<View,Animator> existingAnimators=new ArrayMap<>(mSwipeHelperAnimations);
      for (int i=0; i < existingAnimators.size(); i++) {
        existingAnimators.get(existingAnimators.keyAt(i)).end();
      }
      mSwipeHelperAnimations.clear();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}","private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mSv.cancelDeferredTaskViewLayoutAnimation();
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      finishAnimations();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}",0.9566790846194784
191960,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int maxSize=Integer.MAX_VALUE;
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    maxSize=MeasureSpec.getSize(heightMeasureSpec);
  }
  int maxChildHeight=0;
  if (mExpandedChild != null) {
    int size=Math.min(maxSize,mNotificationMaxHeight);
    ViewGroup.LayoutParams layoutParams=mExpandedChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(maxSize,layoutParams.height);
    }
    int spec=size == Integer.MAX_VALUE ? MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED) : MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    mExpandedChild.measure(widthMeasureSpec,spec);
    maxChildHeight=Math.max(maxChildHeight,mExpandedChild.getMeasuredHeight());
  }
  if (mContractedChild != null) {
    int heightSpec;
    int size=Math.min(maxSize,mSmallHeight);
    if (shouldContractedBeFixedSize()) {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.EXACTLY);
    }
 else {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    }
    mContractedChild.measure(widthMeasureSpec,heightSpec);
    int measuredHeight=mContractedChild.getMeasuredHeight();
    if (measuredHeight < mMinContractedHeight) {
      heightSpec=MeasureSpec.makeMeasureSpec(mMinContractedHeight,MeasureSpec.EXACTLY);
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
    maxChildHeight=Math.max(maxChildHeight,measuredHeight);
    if (updateContractedHeaderWidth()) {
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
  }
  if (mHeadsUpChild != null) {
    int size=Math.min(maxSize,mHeadsUpHeight);
    ViewGroup.LayoutParams layoutParams=mHeadsUpChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(size,layoutParams.height);
    }
    mHeadsUpChild.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mHeadsUpChild.getMeasuredHeight());
  }
  if (mSingleLineView != null) {
    int singleLineWidthSpec=widthMeasureSpec;
    if (mSingleLineWidthIndention != 0 && MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.UNSPECIFIED) {
      singleLineWidthSpec=MeasureSpec.makeMeasureSpec(width - mSingleLineWidthIndention + mSingleLineView.getPaddingEnd(),MeasureSpec.AT_MOST);
    }
    mSingleLineView.measure(singleLineWidthSpec,MeasureSpec.makeMeasureSpec(maxSize,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mSingleLineView.getMeasuredHeight());
  }
  int ownHeight=Math.min(maxChildHeight,maxSize);
  setMeasuredDimension(width,ownHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int maxSize=Integer.MAX_VALUE;
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    maxSize=MeasureSpec.getSize(heightMeasureSpec);
  }
  int maxChildHeight=0;
  if (mExpandedChild != null) {
    int size=Math.min(maxSize,mNotificationMaxHeight);
    ViewGroup.LayoutParams layoutParams=mExpandedChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(maxSize,layoutParams.height);
    }
    int spec=size == Integer.MAX_VALUE ? MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED) : MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    mExpandedChild.measure(widthMeasureSpec,spec);
    maxChildHeight=Math.max(maxChildHeight,mExpandedChild.getMeasuredHeight());
  }
  if (mContractedChild != null) {
    int heightSpec;
    int size=Math.min(maxSize,mSmallHeight);
    if (shouldContractedBeFixedSize()) {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.EXACTLY);
    }
 else {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    }
    mContractedChild.measure(widthMeasureSpec,heightSpec);
    int measuredHeight=mContractedChild.getMeasuredHeight();
    if (measuredHeight < mMinContractedHeight) {
      heightSpec=MeasureSpec.makeMeasureSpec(mMinContractedHeight,MeasureSpec.EXACTLY);
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
    maxChildHeight=Math.max(maxChildHeight,measuredHeight);
    if (updateContractedHeaderWidth()) {
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
    if (mExpandedChild != null && mContractedChild.getMeasuredHeight() > mExpandedChild.getMeasuredHeight()) {
      heightSpec=MeasureSpec.makeMeasureSpec(mContractedChild.getMeasuredHeight(),MeasureSpec.EXACTLY);
      mExpandedChild.measure(widthMeasureSpec,heightSpec);
    }
  }
  if (mHeadsUpChild != null) {
    int size=Math.min(maxSize,mHeadsUpHeight);
    ViewGroup.LayoutParams layoutParams=mHeadsUpChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(size,layoutParams.height);
    }
    mHeadsUpChild.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mHeadsUpChild.getMeasuredHeight());
  }
  if (mSingleLineView != null) {
    int singleLineWidthSpec=widthMeasureSpec;
    if (mSingleLineWidthIndention != 0 && MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.UNSPECIFIED) {
      singleLineWidthSpec=MeasureSpec.makeMeasureSpec(width - mSingleLineWidthIndention + mSingleLineView.getPaddingEnd(),MeasureSpec.AT_MOST);
    }
    mSingleLineView.measure(singleLineWidthSpec,MeasureSpec.makeMeasureSpec(maxSize,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mSingleLineView.getMeasuredHeight());
  }
  int ownHeight=Math.min(maxChildHeight,maxSize);
  setMeasuredDimension(width,ownHeight);
}",0.953192912069542
191961,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int maxSize=Integer.MAX_VALUE;
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    maxSize=MeasureSpec.getSize(heightMeasureSpec);
  }
  int maxChildHeight=0;
  if (mExpandedChild != null) {
    int size=Math.min(maxSize,mNotificationMaxHeight);
    ViewGroup.LayoutParams layoutParams=mExpandedChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(maxSize,layoutParams.height);
    }
    int spec=size == Integer.MAX_VALUE ? MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED) : MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    mExpandedChild.measure(widthMeasureSpec,spec);
    maxChildHeight=Math.max(maxChildHeight,mExpandedChild.getMeasuredHeight());
  }
  if (mContractedChild != null) {
    int heightSpec;
    int size=Math.min(maxSize,mSmallHeight);
    if (shouldContractedBeFixedSize()) {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.EXACTLY);
    }
 else {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    }
    mContractedChild.measure(widthMeasureSpec,heightSpec);
    int measuredHeight=mContractedChild.getMeasuredHeight();
    if (measuredHeight < mMinContractedHeight) {
      heightSpec=MeasureSpec.makeMeasureSpec(mMinContractedHeight,MeasureSpec.EXACTLY);
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
    maxChildHeight=Math.max(maxChildHeight,measuredHeight);
    if (updateContractedHeaderWidth()) {
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
  }
  if (mHeadsUpChild != null) {
    int size=Math.min(maxSize,mHeadsUpHeight);
    ViewGroup.LayoutParams layoutParams=mHeadsUpChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(size,layoutParams.height);
    }
    mHeadsUpChild.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mHeadsUpChild.getMeasuredHeight());
  }
  if (mSingleLineView != null) {
    int singleLineWidthSpec=widthMeasureSpec;
    if (mSingleLineWidthIndention != 0 && MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.UNSPECIFIED) {
      singleLineWidthSpec=MeasureSpec.makeMeasureSpec(width - mSingleLineWidthIndention + mSingleLineView.getPaddingEnd(),MeasureSpec.AT_MOST);
    }
    mSingleLineView.measure(singleLineWidthSpec,MeasureSpec.makeMeasureSpec(maxSize,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mSingleLineView.getMeasuredHeight());
  }
  int ownHeight=Math.min(maxChildHeight,maxSize);
  setMeasuredDimension(width,ownHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int maxSize=Integer.MAX_VALUE;
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    maxSize=MeasureSpec.getSize(heightMeasureSpec);
  }
  int maxChildHeight=0;
  if (mExpandedChild != null) {
    int size=Math.min(maxSize,mNotificationMaxHeight);
    ViewGroup.LayoutParams layoutParams=mExpandedChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(maxSize,layoutParams.height);
    }
    int spec=size == Integer.MAX_VALUE ? MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED) : MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    mExpandedChild.measure(widthMeasureSpec,spec);
    maxChildHeight=Math.max(maxChildHeight,mExpandedChild.getMeasuredHeight());
  }
  if (mContractedChild != null) {
    int heightSpec;
    int size=Math.min(maxSize,mSmallHeight);
    if (shouldContractedBeFixedSize()) {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.EXACTLY);
    }
 else {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    }
    mContractedChild.measure(widthMeasureSpec,heightSpec);
    int measuredHeight=mContractedChild.getMeasuredHeight();
    if (measuredHeight < mMinContractedHeight) {
      heightSpec=MeasureSpec.makeMeasureSpec(mMinContractedHeight,MeasureSpec.EXACTLY);
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
    maxChildHeight=Math.max(maxChildHeight,measuredHeight);
    if (updateContractedHeaderWidth()) {
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
    if (mExpandedChild != null && mContractedChild.getMeasuredHeight() > mExpandedChild.getMeasuredHeight()) {
      heightSpec=MeasureSpec.makeMeasureSpec(mContractedChild.getMeasuredHeight(),MeasureSpec.EXACTLY);
      mExpandedChild.measure(widthMeasureSpec,heightSpec);
    }
  }
  if (mHeadsUpChild != null) {
    int size=Math.min(maxSize,mHeadsUpHeight);
    ViewGroup.LayoutParams layoutParams=mHeadsUpChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(size,layoutParams.height);
    }
    mHeadsUpChild.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mHeadsUpChild.getMeasuredHeight());
  }
  if (mSingleLineView != null) {
    int singleLineWidthSpec=widthMeasureSpec;
    if (mSingleLineWidthIndention != 0 && MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.UNSPECIFIED) {
      singleLineWidthSpec=MeasureSpec.makeMeasureSpec(width - mSingleLineWidthIndention + mSingleLineView.getPaddingEnd(),MeasureSpec.AT_MOST);
    }
    mSingleLineView.measure(singleLineWidthSpec,MeasureSpec.makeMeasureSpec(maxSize,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mSingleLineView.getMeasuredHeight());
  }
  int ownHeight=Math.min(maxChildHeight,maxSize);
  setMeasuredDimension(width,ownHeight);
}",0.953192912069542
191962,"/** 
 * Unflatten the notification from a parcel.
 */
public Notification(Parcel parcel){
  int version=parcel.readInt();
  when=parcel.readLong();
  if (parcel.readInt() != 0) {
    mSmallIcon=Icon.CREATOR.createFromParcel(parcel);
    if (mSmallIcon.getType() == Icon.TYPE_RESOURCE) {
      icon=mSmallIcon.getResId();
    }
  }
  number=parcel.readInt();
  if (parcel.readInt() != 0) {
    contentIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    deleteIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerText=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    contentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    mLargeIcon=Icon.CREATOR.createFromParcel(parcel);
  }
  defaults=parcel.readInt();
  flags=parcel.readInt();
  if (parcel.readInt() != 0) {
    sound=Uri.CREATOR.createFromParcel(parcel);
  }
  audioStreamType=parcel.readInt();
  if (parcel.readInt() != 0) {
    audioAttributes=AudioAttributes.CREATOR.createFromParcel(parcel);
  }
  vibrate=parcel.createLongArray();
  ledARGB=parcel.readInt();
  ledOnMS=parcel.readInt();
  ledOffMS=parcel.readInt();
  iconLevel=parcel.readInt();
  if (parcel.readInt() != 0) {
    fullScreenIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  priority=parcel.readInt();
  category=parcel.readString();
  mGroupKey=parcel.readString();
  mSortKey=parcel.readString();
  extras=Bundle.setDefusable(parcel.readBundle(),true);
  actions=parcel.createTypedArray(Action.CREATOR);
  if (parcel.readInt() != 0) {
    bigContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    headsUpContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  visibility=parcel.readInt();
  if (parcel.readInt() != 0) {
    publicVersion=Notification.CREATOR.createFromParcel(parcel);
  }
  color=parcel.readInt();
}","/** 
 * Unflatten the notification from a parcel.
 */
public Notification(Parcel parcel){
  int version=parcel.readInt();
  when=parcel.readLong();
  creationTime=parcel.readLong();
  if (parcel.readInt() != 0) {
    mSmallIcon=Icon.CREATOR.createFromParcel(parcel);
    if (mSmallIcon.getType() == Icon.TYPE_RESOURCE) {
      icon=mSmallIcon.getResId();
    }
  }
  number=parcel.readInt();
  if (parcel.readInt() != 0) {
    contentIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    deleteIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerText=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    contentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    mLargeIcon=Icon.CREATOR.createFromParcel(parcel);
  }
  defaults=parcel.readInt();
  flags=parcel.readInt();
  if (parcel.readInt() != 0) {
    sound=Uri.CREATOR.createFromParcel(parcel);
  }
  audioStreamType=parcel.readInt();
  if (parcel.readInt() != 0) {
    audioAttributes=AudioAttributes.CREATOR.createFromParcel(parcel);
  }
  vibrate=parcel.createLongArray();
  ledARGB=parcel.readInt();
  ledOnMS=parcel.readInt();
  ledOffMS=parcel.readInt();
  iconLevel=parcel.readInt();
  if (parcel.readInt() != 0) {
    fullScreenIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  priority=parcel.readInt();
  category=parcel.readString();
  mGroupKey=parcel.readString();
  mSortKey=parcel.readString();
  extras=Bundle.setDefusable(parcel.readBundle(),true);
  actions=parcel.createTypedArray(Action.CREATOR);
  if (parcel.readInt() != 0) {
    bigContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    headsUpContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  visibility=parcel.readInt();
  if (parcel.readInt() != 0) {
    publicVersion=Notification.CREATOR.createFromParcel(parcel);
  }
  color=parcel.readInt();
}",0.9918854415274464
191963,"private void bindHeaderChronometerAndTime(RemoteViews contentView){
  if (showsTimeOrChronometer()) {
    contentView.setViewVisibility(R.id.time_divider,View.VISIBLE);
    if (mN.extras.getBoolean(EXTRA_SHOW_CHRONOMETER)) {
      contentView.setViewVisibility(R.id.chronometer,View.VISIBLE);
      contentView.setLong(R.id.chronometer,""String_Node_Str"",mN.when + (SystemClock.elapsedRealtime() - System.currentTimeMillis()));
      contentView.setBoolean(R.id.chronometer,""String_Node_Str"",true);
      boolean countsDown=mN.extras.getBoolean(EXTRA_CHRONOMETER_COUNTS_DOWN);
      contentView.setChronometerCountDown(R.id.chronometer,countsDown);
    }
 else {
      contentView.setViewVisibility(R.id.time,View.VISIBLE);
      contentView.setLong(R.id.time,""String_Node_Str"",mN.when);
    }
  }
}","private void bindHeaderChronometerAndTime(RemoteViews contentView){
  if (showsTimeOrChronometer()) {
    contentView.setViewVisibility(R.id.time_divider,View.VISIBLE);
    if (mN.extras.getBoolean(EXTRA_SHOW_CHRONOMETER)) {
      contentView.setViewVisibility(R.id.chronometer,View.VISIBLE);
      contentView.setLong(R.id.chronometer,""String_Node_Str"",mN.when + (SystemClock.elapsedRealtime() - System.currentTimeMillis()));
      contentView.setBoolean(R.id.chronometer,""String_Node_Str"",true);
      boolean countsDown=mN.extras.getBoolean(EXTRA_CHRONOMETER_COUNTS_DOWN);
      contentView.setChronometerCountDown(R.id.chronometer,countsDown);
    }
 else {
      contentView.setViewVisibility(R.id.time,View.VISIBLE);
      contentView.setLong(R.id.time,""String_Node_Str"",mN.when);
    }
  }
 else {
    contentView.setLong(R.id.time,""String_Node_Str"",mN.when != 0 ? mN.when : mN.creationTime);
  }
}",0.9371697005284793
191964,"/** 
 * Resets the notification header to its original state
 */
private void resetNotificationHeader(RemoteViews contentView){
  contentView.setImageViewResource(R.id.icon,0);
  contentView.setBoolean(R.id.notification_header,""String_Node_Str"",false);
  contentView.setTextViewText(R.id.app_name_text,null);
  contentView.setViewVisibility(R.id.chronometer,View.GONE);
  contentView.setViewVisibility(R.id.header_text,View.GONE);
  contentView.setViewVisibility(R.id.header_text_divider,View.GONE);
  contentView.setViewVisibility(R.id.time_divider,View.GONE);
  contentView.setImageViewIcon(R.id.profile_badge,null);
  contentView.setViewVisibility(R.id.profile_badge,View.GONE);
}","/** 
 * Resets the notification header to its original state
 */
private void resetNotificationHeader(RemoteViews contentView){
  contentView.setImageViewResource(R.id.icon,0);
  contentView.setBoolean(R.id.notification_header,""String_Node_Str"",false);
  contentView.setTextViewText(R.id.app_name_text,null);
  contentView.setViewVisibility(R.id.chronometer,View.GONE);
  contentView.setViewVisibility(R.id.header_text,View.GONE);
  contentView.setViewVisibility(R.id.header_text_divider,View.GONE);
  contentView.setViewVisibility(R.id.time_divider,View.GONE);
  contentView.setViewVisibility(R.id.time,View.GONE);
  contentView.setImageViewIcon(R.id.profile_badge,null);
  contentView.setViewVisibility(R.id.profile_badge,View.GONE);
}",0.8380281690140845
191965,"/** 
 * @return true if the built notification will show the time or the chronometer; falseotherwise
 */
private boolean showsTimeOrChronometer(){
  return mN.when != 0 && mN.extras.getBoolean(EXTRA_SHOW_WHEN);
}","/** 
 * @return true if the notification will show the time or the chronometer; falseotherwise
 * @hide
 */
public boolean showsTimeOrChronometer(){
  return when != 0 && extras.getBoolean(EXTRA_SHOW_WHEN);
}",0.5952380952380952
191966,"/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.mSmallIcon=this.mSmallIcon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.mLargeIcon != null) {
    that.mLargeIcon=this.mLargeIcon;
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  if (this.audioAttributes != null) {
    that.audioAttributes=new AudioAttributes.Builder(this.audioAttributes).build();
  }
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  that.category=this.category;
  that.mGroupKey=this.mGroupKey;
  that.mSortKey=this.mSortKey;
  if (this.extras != null) {
    try {
      that.extras=new Bundle(this.extras);
      that.extras.size();
    }
 catch (    BadParcelableException e) {
      Log.e(TAG,""String_Node_Str"" + this,e);
      that.extras=null;
    }
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (heavy && this.headsUpContentView != null) {
    that.headsUpContentView=this.headsUpContentView.clone();
  }
  that.visibility=this.visibility;
  if (this.publicVersion != null) {
    that.publicVersion=new Notification();
    this.publicVersion.cloneInto(that.publicVersion,heavy);
  }
  that.color=this.color;
  if (!heavy) {
    that.lightenPayload();
  }
}","/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.creationTime=this.creationTime;
  that.mSmallIcon=this.mSmallIcon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.mLargeIcon != null) {
    that.mLargeIcon=this.mLargeIcon;
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  if (this.audioAttributes != null) {
    that.audioAttributes=new AudioAttributes.Builder(this.audioAttributes).build();
  }
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  that.category=this.category;
  that.mGroupKey=this.mGroupKey;
  that.mSortKey=this.mSortKey;
  if (this.extras != null) {
    try {
      that.extras=new Bundle(this.extras);
      that.extras.size();
    }
 catch (    BadParcelableException e) {
      Log.e(TAG,""String_Node_Str"" + this,e);
      that.extras=null;
    }
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (heavy && this.headsUpContentView != null) {
    that.headsUpContentView=this.headsUpContentView.clone();
  }
  that.visibility=this.visibility;
  if (this.publicVersion != null) {
    that.publicVersion=new Notification();
    this.publicVersion.cloneInto(that.publicVersion,heavy);
  }
  that.color=this.color;
  if (!heavy) {
    that.lightenPayload();
  }
}",0.9916362856530132
191967,"void update(){
  if (mTime == null) {
    return;
  }
  if (mShowRelativeTime) {
    updateRelativeTime();
    return;
  }
  int display;
  Date time=mTime;
  Time t=new Time();
  t.set(mTimeMillis);
  t.second=0;
  t.hour-=12;
  long twelveHoursBefore=t.toMillis(false);
  t.hour+=12;
  long twelveHoursAfter=t.toMillis(false);
  t.hour=0;
  t.minute=0;
  long midnightBefore=t.toMillis(false);
  t.monthDay++;
  long midnightAfter=t.toMillis(false);
  long nowMillis=System.currentTimeMillis();
  t.set(nowMillis);
  t.second=0;
  nowMillis=t.normalize(false);
  choose_display: {
    if ((nowMillis >= midnightBefore && nowMillis < midnightAfter) || (nowMillis >= twelveHoursBefore && nowMillis < twelveHoursAfter)) {
      display=SHOW_TIME;
      break choose_display;
    }
    display=SHOW_MONTH_DAY_YEAR;
    break choose_display;
  }
  DateFormat format;
  if (display == mLastDisplay && mLastFormat != null) {
    format=mLastFormat;
  }
 else {
switch (display) {
case SHOW_TIME:
      format=getTimeFormat();
    break;
case SHOW_MONTH_DAY_YEAR:
  format=DateFormat.getDateInstance(DateFormat.SHORT);
break;
default :
throw new RuntimeException(""String_Node_Str"" + display);
}
mLastFormat=format;
}
String text=format.format(mTime);
setText(text);
if (display == SHOW_TIME) {
mUpdateTimeMillis=twelveHoursAfter > midnightAfter ? twelveHoursAfter : midnightAfter;
}
 else {
if (mTimeMillis < nowMillis) {
mUpdateTimeMillis=0;
}
 else {
mUpdateTimeMillis=twelveHoursBefore < midnightBefore ? twelveHoursBefore : midnightBefore;
}
}
}","void update(){
  if (mTime == null || getVisibility() == GONE) {
    return;
  }
  if (mShowRelativeTime) {
    updateRelativeTime();
    return;
  }
  int display;
  Date time=mTime;
  Time t=new Time();
  t.set(mTimeMillis);
  t.second=0;
  t.hour-=12;
  long twelveHoursBefore=t.toMillis(false);
  t.hour+=12;
  long twelveHoursAfter=t.toMillis(false);
  t.hour=0;
  t.minute=0;
  long midnightBefore=t.toMillis(false);
  t.monthDay++;
  long midnightAfter=t.toMillis(false);
  long nowMillis=System.currentTimeMillis();
  t.set(nowMillis);
  t.second=0;
  nowMillis=t.normalize(false);
  choose_display: {
    if ((nowMillis >= midnightBefore && nowMillis < midnightAfter) || (nowMillis >= twelveHoursBefore && nowMillis < twelveHoursAfter)) {
      display=SHOW_TIME;
      break choose_display;
    }
    display=SHOW_MONTH_DAY_YEAR;
    break choose_display;
  }
  DateFormat format;
  if (display == mLastDisplay && mLastFormat != null) {
    format=mLastFormat;
  }
 else {
switch (display) {
case SHOW_TIME:
      format=getTimeFormat();
    break;
case SHOW_MONTH_DAY_YEAR:
  format=DateFormat.getDateInstance(DateFormat.SHORT);
break;
default :
throw new RuntimeException(""String_Node_Str"" + display);
}
mLastFormat=format;
}
String text=format.format(mTime);
setText(text);
if (display == SHOW_TIME) {
mUpdateTimeMillis=twelveHoursAfter > midnightAfter ? twelveHoursAfter : midnightAfter;
}
 else {
if (mTimeMillis < nowMillis) {
mUpdateTimeMillis=0;
}
 else {
mUpdateTimeMillis=twelveHoursBefore < midnightBefore ? twelveHoursBefore : midnightBefore;
}
}
}",0.9913266945069064
191968,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int maxSize=Integer.MAX_VALUE;
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    maxSize=MeasureSpec.getSize(heightMeasureSpec);
  }
  int maxChildHeight=0;
  if (mExpandedChild != null) {
    int size=Math.min(maxSize,mNotificationMaxHeight);
    ViewGroup.LayoutParams layoutParams=mExpandedChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(maxSize,layoutParams.height);
    }
    int spec=size == Integer.MAX_VALUE ? MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED) : MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    mExpandedChild.measure(widthMeasureSpec,spec);
    maxChildHeight=Math.max(maxChildHeight,mExpandedChild.getMeasuredHeight());
  }
  if (mContractedChild != null) {
    int heightSpec;
    int size=Math.min(maxSize,mSmallHeight);
    if (shouldContractedBeFixedSize()) {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.EXACTLY);
    }
 else {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    }
    mContractedChild.measure(widthMeasureSpec,heightSpec);
    int measuredHeight=mContractedChild.getMeasuredHeight();
    if (measuredHeight < mMinContractedHeight) {
      heightSpec=MeasureSpec.makeMeasureSpec(mMinContractedHeight,MeasureSpec.EXACTLY);
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
    maxChildHeight=Math.max(maxChildHeight,measuredHeight);
    if (updateContractedHeaderWidth()) {
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
  }
  if (mHeadsUpChild != null) {
    int size=Math.min(maxSize,mHeadsUpHeight);
    ViewGroup.LayoutParams layoutParams=mHeadsUpChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(size,layoutParams.height);
    }
    mHeadsUpChild.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mHeadsUpChild.getMeasuredHeight());
  }
  if (mSingleLineView != null) {
    int singleLineWidthSpec=widthMeasureSpec;
    if (mSingleLineWidthIndention != 0 && MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.UNSPECIFIED) {
      singleLineWidthSpec=MeasureSpec.makeMeasureSpec(width - mSingleLineWidthIndention + mSingleLineView.getPaddingEnd(),MeasureSpec.AT_MOST);
    }
    mSingleLineView.measure(singleLineWidthSpec,MeasureSpec.makeMeasureSpec(maxSize,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mSingleLineView.getMeasuredHeight());
  }
  int ownHeight=Math.min(maxChildHeight,maxSize);
  setMeasuredDimension(width,ownHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  boolean hasFixedHeight=heightMode == MeasureSpec.EXACTLY;
  boolean isHeightLimited=heightMode == MeasureSpec.AT_MOST;
  int maxSize=Integer.MAX_VALUE;
  int width=MeasureSpec.getSize(widthMeasureSpec);
  if (hasFixedHeight || isHeightLimited) {
    maxSize=MeasureSpec.getSize(heightMeasureSpec);
  }
  int maxChildHeight=0;
  if (mExpandedChild != null) {
    int size=Math.min(maxSize,mNotificationMaxHeight);
    ViewGroup.LayoutParams layoutParams=mExpandedChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(maxSize,layoutParams.height);
    }
    int spec=size == Integer.MAX_VALUE ? MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED) : MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    mExpandedChild.measure(widthMeasureSpec,spec);
    maxChildHeight=Math.max(maxChildHeight,mExpandedChild.getMeasuredHeight());
  }
  if (mContractedChild != null) {
    int heightSpec;
    int size=Math.min(maxSize,mSmallHeight);
    if (shouldContractedBeFixedSize()) {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.EXACTLY);
    }
 else {
      heightSpec=MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST);
    }
    mContractedChild.measure(widthMeasureSpec,heightSpec);
    int measuredHeight=mContractedChild.getMeasuredHeight();
    if (measuredHeight < mMinContractedHeight) {
      heightSpec=MeasureSpec.makeMeasureSpec(mMinContractedHeight,MeasureSpec.EXACTLY);
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
    maxChildHeight=Math.max(maxChildHeight,measuredHeight);
    if (updateContractedHeaderWidth()) {
      mContractedChild.measure(widthMeasureSpec,heightSpec);
    }
    if (mExpandedChild != null && mContractedChild.getMeasuredHeight() > mExpandedChild.getMeasuredHeight()) {
      heightSpec=MeasureSpec.makeMeasureSpec(mContractedChild.getMeasuredHeight(),MeasureSpec.EXACTLY);
      mExpandedChild.measure(widthMeasureSpec,heightSpec);
    }
  }
  if (mHeadsUpChild != null) {
    int size=Math.min(maxSize,mHeadsUpHeight);
    ViewGroup.LayoutParams layoutParams=mHeadsUpChild.getLayoutParams();
    if (layoutParams.height >= 0) {
      size=Math.min(size,layoutParams.height);
    }
    mHeadsUpChild.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(size,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mHeadsUpChild.getMeasuredHeight());
  }
  if (mSingleLineView != null) {
    int singleLineWidthSpec=widthMeasureSpec;
    if (mSingleLineWidthIndention != 0 && MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.UNSPECIFIED) {
      singleLineWidthSpec=MeasureSpec.makeMeasureSpec(width - mSingleLineWidthIndention + mSingleLineView.getPaddingEnd(),MeasureSpec.AT_MOST);
    }
    mSingleLineView.measure(singleLineWidthSpec,MeasureSpec.makeMeasureSpec(maxSize,MeasureSpec.AT_MOST));
    maxChildHeight=Math.max(maxChildHeight,mSingleLineView.getMeasuredHeight());
  }
  int ownHeight=Math.min(maxChildHeight,maxSize);
  setMeasuredDimension(width,ownHeight);
}",0.953192912069542
191969,"private void recreateNotificationHeader(){
  final Notification.Builder builder=Notification.Builder.recoverBuilder(getContext(),getStatusBarNotification().getNotification());
  final RemoteViews header=builder.makeNotificationHeader();
  if (mNotificationHeader == null) {
    mNotificationHeader=(NotificationHeaderView)header.apply(getContext(),this);
    final View expandButton=mNotificationHeader.findViewById(com.android.internal.R.id.expand_button);
    expandButton.setVisibility(VISIBLE);
    mNotificationHeader.setOnClickListener(mExpandClickListener);
    mNotificationHeaderWrapper=NotificationViewWrapper.wrap(getContext(),mNotificationHeader);
    addView(mNotificationHeader,indexOfChild(mChildrenContainer) + 1);
    mTranslateableViews.add(mNotificationHeader);
  }
 else {
    header.reapply(getContext(),mNotificationHeader);
    mNotificationHeaderWrapper.notifyContentUpdated(mEntry.notification);
  }
  updateChildrenHeaderAppearance();
}","private void recreateNotificationHeader(){
  final Notification.Builder builder=Notification.Builder.recoverBuilder(getContext(),getStatusBarNotification().getNotification());
  final RemoteViews header=builder.makeNotificationHeader();
  if (mNotificationHeader == null) {
    mNotificationHeader=(NotificationHeaderView)header.apply(getContext(),this);
    final View expandButton=mNotificationHeader.findViewById(com.android.internal.R.id.expand_button);
    expandButton.setVisibility(VISIBLE);
    mNotificationHeader.setOnClickListener(mExpandClickListener);
    mNotificationHeaderWrapper=NotificationViewWrapper.wrap(getContext(),mNotificationHeader,this);
    addView(mNotificationHeader,indexOfChild(mChildrenContainer) + 1);
    mTranslateableViews.add(mNotificationHeader);
  }
 else {
    header.reapply(getContext(),mNotificationHeader);
    mNotificationHeaderWrapper.notifyContentUpdated(mEntry.notification);
  }
  updateChildrenHeaderAppearance();
}",0.9974079834110938
191970,"public void setContractedChild(View child){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    mContractedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mContractedChild);
  }
  addView(child);
  mContractedChild=child;
  mContractedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mContractedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
  mContractedWrapper.setDark(mDark,false,0);
}","public void setContractedChild(View child){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    mContractedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mContractedChild);
  }
  addView(child);
  mContractedChild=child;
  mContractedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mContractedWrapper=NotificationViewWrapper.wrap(getContext(),child,mContainingNotification);
  selectLayout(false,true);
  mContractedWrapper.setDark(mDark,false,0);
}",0.9753593429158112
191971,"public void setExpandedChild(View child){
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    mExpandedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mExpandedChild);
  }
  addView(child);
  mExpandedChild=child;
  mExpandedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mExpandedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
}","public void setExpandedChild(View child){
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    mExpandedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mExpandedChild);
  }
  addView(child);
  mExpandedChild=child;
  mExpandedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mExpandedWrapper=NotificationViewWrapper.wrap(getContext(),child,mContainingNotification);
  selectLayout(false,true);
}",0.971830985915493
191972,"public void setHeadsUpChild(View child){
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    mHeadsUpChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mHeadsUpChild);
  }
  addView(child);
  mHeadsUpChild=child;
  mHeadsUpChild.addOnLayoutChangeListener(mLayoutUpdater);
  mHeadsUpWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
}","public void setHeadsUpChild(View child){
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    mHeadsUpChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mHeadsUpChild);
  }
  addView(child);
  mHeadsUpChild=child;
  mHeadsUpChild.addOnLayoutChangeListener(mLayoutUpdater);
  mHeadsUpWrapper=NotificationViewWrapper.wrap(getContext(),child,mContainingNotification);
  selectLayout(false,true);
}",0.971291866028708
191973,"protected NotificationBigPictureTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
}","protected NotificationBigPictureTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
}",0.8495575221238938
191974,"protected NotificationBigTextTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
}","protected NotificationBigTextTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
}",0.8454545454545455
191975,"protected NotificationCustomViewWrapper(View view){
  super(view);
  mInvertHelper=new ViewInvertHelper(view,NotificationPanelView.DOZE_ANIMATION_DURATION);
}","protected NotificationCustomViewWrapper(View view,ExpandableNotificationRow row){
  super(view,row);
  mInvertHelper=new ViewInvertHelper(view,NotificationPanelView.DOZE_ANIMATION_DURATION);
}",0.9028571428571428
191976,"@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark && mDarkInitialized) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
  if (mIcon != null) {
    boolean hadColorFilter=mNotificationHeader.getOriginalIconColor() != NotificationHeaderView.NO_COLOR;
    if (fade) {
      if (hadColorFilter) {
        fadeIconColorFilter(mIcon,dark,delay);
        fadeIconAlpha(mIcon,dark,delay);
      }
 else {
        fadeGrayscale(mIcon,dark,delay);
      }
    }
 else {
      if (hadColorFilter) {
        updateIconColorFilter(mIcon,dark);
        updateIconAlpha(mIcon,dark);
      }
 else {
        updateGrayscale(mIcon,dark);
      }
    }
  }
}","@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark && mDarkInitialized) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
  if (mIcon != null && !mRow.isChildInGroup()) {
    boolean hadColorFilter=mNotificationHeader.getOriginalIconColor() != NotificationHeaderView.NO_COLOR;
    if (fade) {
      if (hadColorFilter) {
        fadeIconColorFilter(mIcon,dark,delay);
        fadeIconAlpha(mIcon,dark,delay);
      }
 else {
        fadeGrayscale(mIcon,dark,delay);
      }
    }
 else {
      if (hadColorFilter) {
        updateIconColorFilter(mIcon,dark);
        updateIconAlpha(mIcon,dark);
      }
 else {
        updateGrayscale(mIcon,dark);
      }
    }
  }
}",0.9836065573770492
191977,"protected NotificationHeaderViewWrapper(Context ctx,View view){
  super(view);
  mIconDarkAlpha=ctx.getResources().getInteger(R.integer.doze_small_icon_alpha);
  mInvertHelper=new ViewInvertHelper(ctx,NotificationPanelView.DOZE_ANIMATION_DURATION);
  mTransformationHelper=new ViewTransformationHelper();
  resolveHeaderViews();
  updateInvertHelper();
}","protected NotificationHeaderViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(view,row);
  mIconDarkAlpha=ctx.getResources().getInteger(R.integer.doze_small_icon_alpha);
  mInvertHelper=new ViewInvertHelper(ctx,NotificationPanelView.DOZE_ANIMATION_DURATION);
  mTransformationHelper=new ViewTransformationHelper();
  resolveHeaderViews();
  updateInvertHelper();
}",0.954177897574124
191978,"protected NotificationMediaTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
}","protected NotificationMediaTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
}",0.8425925925925926
191979,"protected NotificationTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
  mTransformationHelper.setCustomTransformation(new ViewTransformationHelper.CustomTransformation(){
    @Override public boolean transformTo(    TransformState ownState,    TransformableView notification,    final float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeOut(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalTo(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean customTransformTarget(    TransformState ownState,    TransformState otherState){
      float endY=getTransformationY(ownState,otherState);
      ownState.setTransformationEndY(endY);
      return true;
    }
    @Override public boolean transformFrom(    TransformState ownState,    TransformableView notification,    float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeIn(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalFrom(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean initTransformation(    TransformState ownState,    TransformState otherState){
      float startY=getTransformationY(ownState,otherState);
      ownState.setTransformationStartY(startY);
      return true;
    }
    private float getTransformationY(    TransformState ownState,    TransformState otherState){
      int[] otherStablePosition=otherState.getLaidOutLocationOnScreen();
      int[] ownStablePosition=ownState.getLaidOutLocationOnScreen();
      return (otherStablePosition[1] + otherState.getTransformedView().getHeight() - ownStablePosition[1]) * 0.33f;
    }
  }
,TRANSFORMING_VIEW_TEXT);
}","protected NotificationTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
  mTransformationHelper.setCustomTransformation(new ViewTransformationHelper.CustomTransformation(){
    @Override public boolean transformTo(    TransformState ownState,    TransformableView notification,    final float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeOut(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalTo(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean customTransformTarget(    TransformState ownState,    TransformState otherState){
      float endY=getTransformationY(ownState,otherState);
      ownState.setTransformationEndY(endY);
      return true;
    }
    @Override public boolean transformFrom(    TransformState ownState,    TransformableView notification,    float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeIn(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalFrom(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean initTransformation(    TransformState ownState,    TransformState otherState){
      float startY=getTransformationY(ownState,otherState);
      ownState.setTransformationStartY(startY);
      return true;
    }
    private float getTransformationY(    TransformState ownState,    TransformState otherState){
      int[] otherStablePosition=otherState.getLaidOutLocationOnScreen();
      int[] ownStablePosition=ownState.getLaidOutLocationOnScreen();
      return (otherStablePosition[1] + otherState.getTransformedView().getHeight() - ownStablePosition[1]) * 0.33f;
    }
  }
,TRANSFORMING_VIEW_TEXT);
}",0.9925731760594146
191980,"protected NotificationViewWrapper(View view){
  mView=view;
}","protected NotificationViewWrapper(View view,ExpandableNotificationRow row){
  mView=view;
  mRow=row;
}",0.7439024390243902
191981,"public static NotificationViewWrapper wrap(Context ctx,View v){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v);
    }
 else     if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigTextTemplateViewWrapper(ctx,v);
    }
 else     if (""String_Node_Str"".equals(v.getTag()) || ""String_Node_Str"".equals(v.getTag())) {
      return new NotificationMediaTemplateViewWrapper(ctx,v);
    }
    return new NotificationTemplateViewWrapper(ctx,v);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v);
  }
 else {
    return new NotificationCustomViewWrapper(v);
  }
}","public static NotificationViewWrapper wrap(Context ctx,View v,ExpandableNotificationRow row){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v,row);
    }
 else     if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigTextTemplateViewWrapper(ctx,v,row);
    }
 else     if (""String_Node_Str"".equals(v.getTag()) || ""String_Node_Str"".equals(v.getTag())) {
      return new NotificationMediaTemplateViewWrapper(ctx,v,row);
    }
    return new NotificationTemplateViewWrapper(ctx,v,row);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v,row);
  }
 else {
    return new NotificationCustomViewWrapper(v,row);
  }
}",0.966542750929368
191982,"private void recreateNotificationHeader(){
  final Notification.Builder builder=Notification.Builder.recoverBuilder(getContext(),getStatusBarNotification().getNotification());
  final RemoteViews header=builder.makeNotificationHeader();
  if (mNotificationHeader == null) {
    mNotificationHeader=(NotificationHeaderView)header.apply(getContext(),this);
    final View expandButton=mNotificationHeader.findViewById(com.android.internal.R.id.expand_button);
    expandButton.setVisibility(VISIBLE);
    mNotificationHeader.setOnClickListener(mExpandClickListener);
    mNotificationHeaderWrapper=NotificationViewWrapper.wrap(getContext(),mNotificationHeader);
    addView(mNotificationHeader,indexOfChild(mChildrenContainer) + 1);
    mTranslateableViews.add(mNotificationHeader);
  }
 else {
    header.reapply(getContext(),mNotificationHeader);
    mNotificationHeaderWrapper.notifyContentUpdated(mEntry.notification);
  }
  updateChildrenHeaderAppearance();
}","private void recreateNotificationHeader(){
  final Notification.Builder builder=Notification.Builder.recoverBuilder(getContext(),getStatusBarNotification().getNotification());
  final RemoteViews header=builder.makeNotificationHeader();
  if (mNotificationHeader == null) {
    mNotificationHeader=(NotificationHeaderView)header.apply(getContext(),this);
    final View expandButton=mNotificationHeader.findViewById(com.android.internal.R.id.expand_button);
    expandButton.setVisibility(VISIBLE);
    mNotificationHeader.setOnClickListener(mExpandClickListener);
    mNotificationHeaderWrapper=NotificationViewWrapper.wrap(getContext(),mNotificationHeader,this);
    addView(mNotificationHeader,indexOfChild(mChildrenContainer) + 1);
    mTranslateableViews.add(mNotificationHeader);
  }
 else {
    header.reapply(getContext(),mNotificationHeader);
    mNotificationHeaderWrapper.notifyContentUpdated(mEntry.notification);
  }
  updateChildrenHeaderAppearance();
}",0.9974079834110938
191983,"public void setContractedChild(View child){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    mContractedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mContractedChild);
  }
  addView(child);
  mContractedChild=child;
  mContractedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mContractedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
  mContractedWrapper.setDark(mDark,false,0);
}","public void setContractedChild(View child){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    mContractedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mContractedChild);
  }
  addView(child);
  mContractedChild=child;
  mContractedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mContractedWrapper=NotificationViewWrapper.wrap(getContext(),child,mContainingNotification);
  selectLayout(false,true);
  mContractedWrapper.setDark(mDark,false,0);
}",0.9753593429158112
191984,"public void setExpandedChild(View child){
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    mExpandedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mExpandedChild);
  }
  addView(child);
  mExpandedChild=child;
  mExpandedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mExpandedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
}","public void setExpandedChild(View child){
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    mExpandedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mExpandedChild);
  }
  addView(child);
  mExpandedChild=child;
  mExpandedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mExpandedWrapper=NotificationViewWrapper.wrap(getContext(),child,mContainingNotification);
  selectLayout(false,true);
}",0.971830985915493
191985,"public void setHeadsUpChild(View child){
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    mHeadsUpChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mHeadsUpChild);
  }
  addView(child);
  mHeadsUpChild=child;
  mHeadsUpChild.addOnLayoutChangeListener(mLayoutUpdater);
  mHeadsUpWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
}","public void setHeadsUpChild(View child){
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    mHeadsUpChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mHeadsUpChild);
  }
  addView(child);
  mHeadsUpChild=child;
  mHeadsUpChild.addOnLayoutChangeListener(mLayoutUpdater);
  mHeadsUpWrapper=NotificationViewWrapper.wrap(getContext(),child,mContainingNotification);
  selectLayout(false,true);
}",0.971291866028708
191986,"protected NotificationBigPictureTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
}","protected NotificationBigPictureTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
}",0.8495575221238938
191987,"protected NotificationBigTextTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
}","protected NotificationBigTextTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
}",0.8454545454545455
191988,"protected NotificationCustomViewWrapper(View view){
  super(view);
  mInvertHelper=new ViewInvertHelper(view,NotificationPanelView.DOZE_ANIMATION_DURATION);
}","protected NotificationCustomViewWrapper(View view,ExpandableNotificationRow row){
  super(view,row);
  mInvertHelper=new ViewInvertHelper(view,NotificationPanelView.DOZE_ANIMATION_DURATION);
}",0.9028571428571428
191989,"@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark && mDarkInitialized) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
  if (mIcon != null) {
    boolean hadColorFilter=mNotificationHeader.getOriginalIconColor() != NotificationHeaderView.NO_COLOR;
    if (fade) {
      if (hadColorFilter) {
        fadeIconColorFilter(mIcon,dark,delay);
        fadeIconAlpha(mIcon,dark,delay);
      }
 else {
        fadeGrayscale(mIcon,dark,delay);
      }
    }
 else {
      if (hadColorFilter) {
        updateIconColorFilter(mIcon,dark);
        updateIconAlpha(mIcon,dark);
      }
 else {
        updateGrayscale(mIcon,dark);
      }
    }
  }
}","@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark && mDarkInitialized) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
  if (mIcon != null && !mRow.isChildInGroup()) {
    boolean hadColorFilter=mNotificationHeader.getOriginalIconColor() != NotificationHeaderView.NO_COLOR;
    if (fade) {
      if (hadColorFilter) {
        fadeIconColorFilter(mIcon,dark,delay);
        fadeIconAlpha(mIcon,dark,delay);
      }
 else {
        fadeGrayscale(mIcon,dark,delay);
      }
    }
 else {
      if (hadColorFilter) {
        updateIconColorFilter(mIcon,dark);
        updateIconAlpha(mIcon,dark);
      }
 else {
        updateGrayscale(mIcon,dark);
      }
    }
  }
}",0.9836065573770492
191990,"protected NotificationHeaderViewWrapper(Context ctx,View view){
  super(view);
  mIconDarkAlpha=ctx.getResources().getInteger(R.integer.doze_small_icon_alpha);
  mInvertHelper=new ViewInvertHelper(ctx,NotificationPanelView.DOZE_ANIMATION_DURATION);
  mTransformationHelper=new ViewTransformationHelper();
  resolveHeaderViews();
  updateInvertHelper();
}","protected NotificationHeaderViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(view,row);
  mIconDarkAlpha=ctx.getResources().getInteger(R.integer.doze_small_icon_alpha);
  mInvertHelper=new ViewInvertHelper(ctx,NotificationPanelView.DOZE_ANIMATION_DURATION);
  mTransformationHelper=new ViewTransformationHelper();
  resolveHeaderViews();
  updateInvertHelper();
}",0.954177897574124
191991,"protected NotificationMediaTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
}","protected NotificationMediaTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
}",0.8425925925925926
191992,"protected NotificationTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
  mTransformationHelper.setCustomTransformation(new ViewTransformationHelper.CustomTransformation(){
    @Override public boolean transformTo(    TransformState ownState,    TransformableView notification,    final float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeOut(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalTo(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean customTransformTarget(    TransformState ownState,    TransformState otherState){
      float endY=getTransformationY(ownState,otherState);
      ownState.setTransformationEndY(endY);
      return true;
    }
    @Override public boolean transformFrom(    TransformState ownState,    TransformableView notification,    float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeIn(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalFrom(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean initTransformation(    TransformState ownState,    TransformState otherState){
      float startY=getTransformationY(ownState,otherState);
      ownState.setTransformationStartY(startY);
      return true;
    }
    private float getTransformationY(    TransformState ownState,    TransformState otherState){
      int[] otherStablePosition=otherState.getLaidOutLocationOnScreen();
      int[] ownStablePosition=ownState.getLaidOutLocationOnScreen();
      return (otherStablePosition[1] + otherState.getTransformedView().getHeight() - ownStablePosition[1]) * 0.33f;
    }
  }
,TRANSFORMING_VIEW_TEXT);
}","protected NotificationTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
  mTransformationHelper.setCustomTransformation(new ViewTransformationHelper.CustomTransformation(){
    @Override public boolean transformTo(    TransformState ownState,    TransformableView notification,    final float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeOut(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalTo(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean customTransformTarget(    TransformState ownState,    TransformState otherState){
      float endY=getTransformationY(ownState,otherState);
      ownState.setTransformationEndY(endY);
      return true;
    }
    @Override public boolean transformFrom(    TransformState ownState,    TransformableView notification,    float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeIn(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalFrom(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean initTransformation(    TransformState ownState,    TransformState otherState){
      float startY=getTransformationY(ownState,otherState);
      ownState.setTransformationStartY(startY);
      return true;
    }
    private float getTransformationY(    TransformState ownState,    TransformState otherState){
      int[] otherStablePosition=otherState.getLaidOutLocationOnScreen();
      int[] ownStablePosition=ownState.getLaidOutLocationOnScreen();
      return (otherStablePosition[1] + otherState.getTransformedView().getHeight() - ownStablePosition[1]) * 0.33f;
    }
  }
,TRANSFORMING_VIEW_TEXT);
}",0.9925731760594146
191993,"protected NotificationViewWrapper(View view){
  mView=view;
}","protected NotificationViewWrapper(View view,ExpandableNotificationRow row){
  mView=view;
  mRow=row;
}",0.7439024390243902
191994,"public static NotificationViewWrapper wrap(Context ctx,View v){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v);
    }
 else     if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigTextTemplateViewWrapper(ctx,v);
    }
 else     if (""String_Node_Str"".equals(v.getTag()) || ""String_Node_Str"".equals(v.getTag())) {
      return new NotificationMediaTemplateViewWrapper(ctx,v);
    }
    return new NotificationTemplateViewWrapper(ctx,v);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v);
  }
 else {
    return new NotificationCustomViewWrapper(v);
  }
}","public static NotificationViewWrapper wrap(Context ctx,View v,ExpandableNotificationRow row){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v,row);
    }
 else     if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigTextTemplateViewWrapper(ctx,v,row);
    }
 else     if (""String_Node_Str"".equals(v.getTag()) || ""String_Node_Str"".equals(v.getTag())) {
      return new NotificationMediaTemplateViewWrapper(ctx,v,row);
    }
    return new NotificationTemplateViewWrapper(ctx,v,row);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v,row);
  }
 else {
    return new NotificationCustomViewWrapper(v,row);
  }
}",0.966542750929368
191995,"/** 
 * Unflatten the notification from a parcel.
 */
public Notification(Parcel parcel){
  int version=parcel.readInt();
  when=parcel.readLong();
  if (parcel.readInt() != 0) {
    mSmallIcon=Icon.CREATOR.createFromParcel(parcel);
    if (mSmallIcon.getType() == Icon.TYPE_RESOURCE) {
      icon=mSmallIcon.getResId();
    }
  }
  number=parcel.readInt();
  if (parcel.readInt() != 0) {
    contentIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    deleteIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerText=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    contentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    mLargeIcon=Icon.CREATOR.createFromParcel(parcel);
  }
  defaults=parcel.readInt();
  flags=parcel.readInt();
  if (parcel.readInt() != 0) {
    sound=Uri.CREATOR.createFromParcel(parcel);
  }
  audioStreamType=parcel.readInt();
  if (parcel.readInt() != 0) {
    audioAttributes=AudioAttributes.CREATOR.createFromParcel(parcel);
  }
  vibrate=parcel.createLongArray();
  ledARGB=parcel.readInt();
  ledOnMS=parcel.readInt();
  ledOffMS=parcel.readInt();
  iconLevel=parcel.readInt();
  if (parcel.readInt() != 0) {
    fullScreenIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  priority=parcel.readInt();
  category=parcel.readString();
  mGroupKey=parcel.readString();
  mSortKey=parcel.readString();
  extras=Bundle.setDefusable(parcel.readBundle(),true);
  actions=parcel.createTypedArray(Action.CREATOR);
  if (parcel.readInt() != 0) {
    bigContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    headsUpContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  visibility=parcel.readInt();
  if (parcel.readInt() != 0) {
    publicVersion=Notification.CREATOR.createFromParcel(parcel);
  }
  color=parcel.readInt();
}","/** 
 * Unflatten the notification from a parcel.
 */
public Notification(Parcel parcel){
  int version=parcel.readInt();
  when=parcel.readLong();
  creationTime=parcel.readLong();
  if (parcel.readInt() != 0) {
    mSmallIcon=Icon.CREATOR.createFromParcel(parcel);
    if (mSmallIcon.getType() == Icon.TYPE_RESOURCE) {
      icon=mSmallIcon.getResId();
    }
  }
  number=parcel.readInt();
  if (parcel.readInt() != 0) {
    contentIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    deleteIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerText=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    contentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    mLargeIcon=Icon.CREATOR.createFromParcel(parcel);
  }
  defaults=parcel.readInt();
  flags=parcel.readInt();
  if (parcel.readInt() != 0) {
    sound=Uri.CREATOR.createFromParcel(parcel);
  }
  audioStreamType=parcel.readInt();
  if (parcel.readInt() != 0) {
    audioAttributes=AudioAttributes.CREATOR.createFromParcel(parcel);
  }
  vibrate=parcel.createLongArray();
  ledARGB=parcel.readInt();
  ledOnMS=parcel.readInt();
  ledOffMS=parcel.readInt();
  iconLevel=parcel.readInt();
  if (parcel.readInt() != 0) {
    fullScreenIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  priority=parcel.readInt();
  category=parcel.readString();
  mGroupKey=parcel.readString();
  mSortKey=parcel.readString();
  extras=Bundle.setDefusable(parcel.readBundle(),true);
  actions=parcel.createTypedArray(Action.CREATOR);
  if (parcel.readInt() != 0) {
    bigContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    headsUpContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  visibility=parcel.readInt();
  if (parcel.readInt() != 0) {
    publicVersion=Notification.CREATOR.createFromParcel(parcel);
  }
  color=parcel.readInt();
}",0.9918854415274464
191996,"private void bindHeaderChronometerAndTime(RemoteViews contentView){
  if (showsTimeOrChronometer()) {
    contentView.setViewVisibility(R.id.time_divider,View.VISIBLE);
    if (mN.extras.getBoolean(EXTRA_SHOW_CHRONOMETER)) {
      contentView.setViewVisibility(R.id.chronometer,View.VISIBLE);
      contentView.setLong(R.id.chronometer,""String_Node_Str"",mN.when + (SystemClock.elapsedRealtime() - System.currentTimeMillis()));
      contentView.setBoolean(R.id.chronometer,""String_Node_Str"",true);
      boolean countsDown=mN.extras.getBoolean(EXTRA_CHRONOMETER_COUNTS_DOWN);
      contentView.setChronometerCountDown(R.id.chronometer,countsDown);
    }
 else {
      contentView.setViewVisibility(R.id.time,View.VISIBLE);
      contentView.setLong(R.id.time,""String_Node_Str"",mN.when);
    }
  }
}","private void bindHeaderChronometerAndTime(RemoteViews contentView){
  if (showsTimeOrChronometer()) {
    contentView.setViewVisibility(R.id.time_divider,View.VISIBLE);
    if (mN.extras.getBoolean(EXTRA_SHOW_CHRONOMETER)) {
      contentView.setViewVisibility(R.id.chronometer,View.VISIBLE);
      contentView.setLong(R.id.chronometer,""String_Node_Str"",mN.when + (SystemClock.elapsedRealtime() - System.currentTimeMillis()));
      contentView.setBoolean(R.id.chronometer,""String_Node_Str"",true);
      boolean countsDown=mN.extras.getBoolean(EXTRA_CHRONOMETER_COUNTS_DOWN);
      contentView.setChronometerCountDown(R.id.chronometer,countsDown);
    }
 else {
      contentView.setViewVisibility(R.id.time,View.VISIBLE);
      contentView.setLong(R.id.time,""String_Node_Str"",mN.when);
    }
  }
 else {
    contentView.setLong(R.id.time,""String_Node_Str"",mN.when != 0 ? mN.when : mN.creationTime);
  }
}",0.9371697005284793
191997,"/** 
 * Resets the notification header to its original state
 */
private void resetNotificationHeader(RemoteViews contentView){
  contentView.setImageViewResource(R.id.icon,0);
  contentView.setBoolean(R.id.notification_header,""String_Node_Str"",false);
  contentView.setTextViewText(R.id.app_name_text,null);
  contentView.setViewVisibility(R.id.chronometer,View.GONE);
  contentView.setViewVisibility(R.id.header_text,View.GONE);
  contentView.setViewVisibility(R.id.header_text_divider,View.GONE);
  contentView.setViewVisibility(R.id.time_divider,View.GONE);
  contentView.setImageViewIcon(R.id.profile_badge,null);
  contentView.setViewVisibility(R.id.profile_badge,View.GONE);
}","/** 
 * Resets the notification header to its original state
 */
private void resetNotificationHeader(RemoteViews contentView){
  contentView.setImageViewResource(R.id.icon,0);
  contentView.setBoolean(R.id.notification_header,""String_Node_Str"",false);
  contentView.setTextViewText(R.id.app_name_text,null);
  contentView.setViewVisibility(R.id.chronometer,View.GONE);
  contentView.setViewVisibility(R.id.header_text,View.GONE);
  contentView.setViewVisibility(R.id.header_text_divider,View.GONE);
  contentView.setViewVisibility(R.id.time_divider,View.GONE);
  contentView.setViewVisibility(R.id.time,View.GONE);
  contentView.setImageViewIcon(R.id.profile_badge,null);
  contentView.setViewVisibility(R.id.profile_badge,View.GONE);
}",0.8380281690140845
191998,"/** 
 * @return true if the built notification will show the time or the chronometer; falseotherwise
 */
private boolean showsTimeOrChronometer(){
  return mN.when != 0 && mN.extras.getBoolean(EXTRA_SHOW_WHEN);
}","/** 
 * @return true if the notification will show the time or the chronometer; falseotherwise
 * @hide
 */
public boolean showsTimeOrChronometer(){
  return when != 0 && extras.getBoolean(EXTRA_SHOW_WHEN);
}",0.5952380952380952
191999,"/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.mSmallIcon=this.mSmallIcon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.mLargeIcon != null) {
    that.mLargeIcon=this.mLargeIcon;
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  if (this.audioAttributes != null) {
    that.audioAttributes=new AudioAttributes.Builder(this.audioAttributes).build();
  }
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  that.category=this.category;
  that.mGroupKey=this.mGroupKey;
  that.mSortKey=this.mSortKey;
  if (this.extras != null) {
    try {
      that.extras=new Bundle(this.extras);
      that.extras.size();
    }
 catch (    BadParcelableException e) {
      Log.e(TAG,""String_Node_Str"" + this,e);
      that.extras=null;
    }
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (heavy && this.headsUpContentView != null) {
    that.headsUpContentView=this.headsUpContentView.clone();
  }
  that.visibility=this.visibility;
  if (this.publicVersion != null) {
    that.publicVersion=new Notification();
    this.publicVersion.cloneInto(that.publicVersion,heavy);
  }
  that.color=this.color;
  if (!heavy) {
    that.lightenPayload();
  }
}","/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.creationTime=this.creationTime;
  that.mSmallIcon=this.mSmallIcon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.mLargeIcon != null) {
    that.mLargeIcon=this.mLargeIcon;
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  if (this.audioAttributes != null) {
    that.audioAttributes=new AudioAttributes.Builder(this.audioAttributes).build();
  }
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  that.category=this.category;
  that.mGroupKey=this.mGroupKey;
  that.mSortKey=this.mSortKey;
  if (this.extras != null) {
    try {
      that.extras=new Bundle(this.extras);
      that.extras.size();
    }
 catch (    BadParcelableException e) {
      Log.e(TAG,""String_Node_Str"" + this,e);
      that.extras=null;
    }
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (heavy && this.headsUpContentView != null) {
    that.headsUpContentView=this.headsUpContentView.clone();
  }
  that.visibility=this.visibility;
  if (this.publicVersion != null) {
    that.publicVersion=new Notification();
    this.publicVersion.cloneInto(that.publicVersion,heavy);
  }
  that.color=this.color;
  if (!heavy) {
    that.lightenPayload();
  }
}",0.9916362856530132
192000,"void update(){
  if (mTime == null) {
    return;
  }
  if (mShowRelativeTime) {
    updateRelativeTime();
    return;
  }
  int display;
  Date time=mTime;
  Time t=new Time();
  t.set(mTimeMillis);
  t.second=0;
  t.hour-=12;
  long twelveHoursBefore=t.toMillis(false);
  t.hour+=12;
  long twelveHoursAfter=t.toMillis(false);
  t.hour=0;
  t.minute=0;
  long midnightBefore=t.toMillis(false);
  t.monthDay++;
  long midnightAfter=t.toMillis(false);
  long nowMillis=System.currentTimeMillis();
  t.set(nowMillis);
  t.second=0;
  nowMillis=t.normalize(false);
  choose_display: {
    if ((nowMillis >= midnightBefore && nowMillis < midnightAfter) || (nowMillis >= twelveHoursBefore && nowMillis < twelveHoursAfter)) {
      display=SHOW_TIME;
      break choose_display;
    }
    display=SHOW_MONTH_DAY_YEAR;
    break choose_display;
  }
  DateFormat format;
  if (display == mLastDisplay && mLastFormat != null) {
    format=mLastFormat;
  }
 else {
switch (display) {
case SHOW_TIME:
      format=getTimeFormat();
    break;
case SHOW_MONTH_DAY_YEAR:
  format=DateFormat.getDateInstance(DateFormat.SHORT);
break;
default :
throw new RuntimeException(""String_Node_Str"" + display);
}
mLastFormat=format;
}
String text=format.format(mTime);
setText(text);
if (display == SHOW_TIME) {
mUpdateTimeMillis=twelveHoursAfter > midnightAfter ? twelveHoursAfter : midnightAfter;
}
 else {
if (mTimeMillis < nowMillis) {
mUpdateTimeMillis=0;
}
 else {
mUpdateTimeMillis=twelveHoursBefore < midnightBefore ? twelveHoursBefore : midnightBefore;
}
}
}","void update(){
  if (mTime == null || getVisibility() == GONE) {
    return;
  }
  if (mShowRelativeTime) {
    updateRelativeTime();
    return;
  }
  int display;
  Date time=mTime;
  Time t=new Time();
  t.set(mTimeMillis);
  t.second=0;
  t.hour-=12;
  long twelveHoursBefore=t.toMillis(false);
  t.hour+=12;
  long twelveHoursAfter=t.toMillis(false);
  t.hour=0;
  t.minute=0;
  long midnightBefore=t.toMillis(false);
  t.monthDay++;
  long midnightAfter=t.toMillis(false);
  long nowMillis=System.currentTimeMillis();
  t.set(nowMillis);
  t.second=0;
  nowMillis=t.normalize(false);
  choose_display: {
    if ((nowMillis >= midnightBefore && nowMillis < midnightAfter) || (nowMillis >= twelveHoursBefore && nowMillis < twelveHoursAfter)) {
      display=SHOW_TIME;
      break choose_display;
    }
    display=SHOW_MONTH_DAY_YEAR;
    break choose_display;
  }
  DateFormat format;
  if (display == mLastDisplay && mLastFormat != null) {
    format=mLastFormat;
  }
 else {
switch (display) {
case SHOW_TIME:
      format=getTimeFormat();
    break;
case SHOW_MONTH_DAY_YEAR:
  format=DateFormat.getDateInstance(DateFormat.SHORT);
break;
default :
throw new RuntimeException(""String_Node_Str"" + display);
}
mLastFormat=format;
}
String text=format.format(mTime);
setText(text);
if (display == SHOW_TIME) {
mUpdateTimeMillis=twelveHoursAfter > midnightAfter ? twelveHoursAfter : midnightAfter;
}
 else {
if (mTimeMillis < nowMillis) {
mUpdateTimeMillis=0;
}
 else {
mUpdateTimeMillis=twelveHoursBefore < midnightBefore ? twelveHoursBefore : midnightBefore;
}
}
}",0.9913266945069064
